begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"sha1-array.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"commit-slab.h"
end_include
begin_include
include|#
directive|include
file|"sigchain.h"
end_include
begin_decl_stmt
DECL|variable|is_shallow
specifier|static
name|int
name|is_shallow
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|shallow_stat
specifier|static
name|struct
name|stat_validity
name|shallow_stat
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|alternate_shallow_file
specifier|static
name|char
modifier|*
name|alternate_shallow_file
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|set_alternate_shallow_file
name|void
name|set_alternate_shallow_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|override
parameter_list|)
block|{
if|if
condition|(
name|is_shallow
operator|!=
operator|-
literal|1
condition|)
name|die
argument_list|(
literal|"BUG: is_repository_shallow must not be called before set_alternate_shallow_file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate_shallow_file
operator|&&
operator|!
name|override
condition|)
return|return;
name|free
argument_list|(
name|alternate_shallow_file
argument_list|)
expr_stmt|;
name|alternate_shallow_file
operator|=
name|path
condition|?
name|xstrdup
argument_list|(
name|path
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|register_shallow
name|int
name|register_shallow
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_graft
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|hashcpy
argument_list|(
name|graft
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|graft
operator|->
name|nr_parent
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|commit
operator|&&
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|commit
operator|->
name|parents
operator|=
name|NULL
expr_stmt|;
return|return
name|register_commit_graft
argument_list|(
name|graft
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|is_repository_shallow
name|int
name|is_repository_shallow
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|alternate_shallow_file
decl_stmt|;
if|if
condition|(
name|is_shallow
operator|>=
literal|0
condition|)
return|return
name|is_shallow
return|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
expr_stmt|;
comment|/* 	 * fetch-pack sets '--shallow-file ""' as an indicator that no 	 * shallow file should be used. We could just open it and it 	 * will likely fail. But let's do an explicit check instead. 	 */
if|if
condition|(
operator|!
operator|*
name|path
operator|||
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|stat_validity_clear
argument_list|(
operator|&
name|shallow_stat
argument_list|)
expr_stmt|;
name|is_shallow
operator|=
literal|0
expr_stmt|;
return|return
name|is_shallow
return|;
block|}
name|stat_validity_update
argument_list|(
operator|&
name|shallow_stat
argument_list|,
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|is_shallow
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"bad shallow line: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|register_shallow
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|is_shallow
return|;
block|}
end_function
begin_function
DECL|function|get_shallow_commits
name|struct
name|commit_list
modifier|*
name|get_shallow_commits
parameter_list|(
name|struct
name|object_array
modifier|*
name|heads
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|shallow_flag
parameter_list|,
name|int
name|not_shallow_flag
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|cur_depth
init|=
literal|0
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|struct
name|object_array
name|stack
init|=
name|OBJECT_ARRAY_INIT
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
decl_stmt|;
while|while
condition|(
name|commit
operator|||
name|i
operator|<
name|heads
operator|->
name|nr
operator|||
name|stack
operator|.
name|nr
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|heads
operator|->
name|nr
condition|)
block|{
name|commit
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|deref_tag
argument_list|(
name|heads
operator|->
name|objects
index|[
name|i
operator|++
index|]
operator|.
name|item
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|commit
operator|->
name|object
operator|.
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
name|commit
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|commit
operator|->
name|util
condition|)
name|commit
operator|->
name|util
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|commit
operator|->
name|util
operator|=
literal|0
expr_stmt|;
name|cur_depth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|commit
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|stack
operator|.
name|objects
index|[
operator|--
name|stack
operator|.
name|nr
index|]
operator|.
name|item
expr_stmt|;
name|cur_depth
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|commit
operator|->
name|util
expr_stmt|;
block|}
block|}
name|parse_commit_or_die
argument_list|(
name|commit
argument_list|)
expr_stmt|;
name|cur_depth
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|depth
operator|!=
name|INFINITE_DEPTH
operator|&&
name|cur_depth
operator|>=
name|depth
operator|)
operator|||
operator|(
name|is_repository_shallow
argument_list|()
operator|&&
operator|!
name|commit
operator|->
name|parents
operator|&&
operator|(
name|graft
operator|=
name|lookup_commit_graft
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|graft
operator|->
name|nr_parent
operator|<
literal|0
operator|)
condition|)
block|{
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|shallow_flag
expr_stmt|;
name|commit
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|not_shallow_flag
expr_stmt|;
for|for
control|(
name|p
operator|=
name|commit
operator|->
name|parents
operator|,
name|commit
operator|=
name|NULL
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|item
operator|->
name|util
condition|)
block|{
name|int
modifier|*
name|pointer
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|item
operator|->
name|util
operator|=
name|pointer
expr_stmt|;
operator|*
name|pointer
operator|=
name|cur_depth
expr_stmt|;
block|}
else|else
block|{
name|int
modifier|*
name|pointer
init|=
name|p
operator|->
name|item
operator|->
name|util
decl_stmt|;
if|if
condition|(
name|cur_depth
operator|>=
operator|*
name|pointer
condition|)
continue|continue;
operator|*
name|pointer
operator|=
name|cur_depth
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|next
condition|)
name|add_object_array
argument_list|(
operator|&
name|p
operator|->
name|item
operator|->
name|object
argument_list|,
name|NULL
argument_list|,
operator|&
name|stack
argument_list|)
expr_stmt|;
else|else
block|{
name|commit
operator|=
name|p
operator|->
name|item
expr_stmt|;
name|cur_depth
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|commit
operator|->
name|util
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|check_shallow_file_for_update
name|void
name|check_shallow_file_for_update
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|is_shallow
operator|==
operator|-
literal|1
condition|)
name|die
argument_list|(
literal|"BUG: shallow must be initialized by now"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat_validity_check
argument_list|(
operator|&
name|shallow_stat
argument_list|,
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
argument_list|)
condition|)
name|die
argument_list|(
literal|"shallow file has changed since we read it"
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|SEEN_ONLY
define|#
directive|define
name|SEEN_ONLY
value|1
end_define
begin_define
DECL|macro|VERBOSE
define|#
directive|define
name|VERBOSE
value|2
end_define
begin_struct
DECL|struct|write_shallow_data
struct|struct
name|write_shallow_data
block|{
DECL|member|out
name|struct
name|strbuf
modifier|*
name|out
decl_stmt|;
DECL|member|use_pack_protocol
name|int
name|use_pack_protocol
decl_stmt|;
DECL|member|count
name|int
name|count
decl_stmt|;
DECL|member|flags
name|unsigned
name|flags
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|write_one_shallow
specifier|static
name|int
name|write_one_shallow
parameter_list|(
specifier|const
name|struct
name|commit_graft
modifier|*
name|graft
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|write_shallow_data
modifier|*
name|data
init|=
name|cb_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|graft
operator|->
name|nr_parent
operator|!=
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|SEEN_ONLY
condition|)
block|{
name|struct
name|commit
modifier|*
name|c
init|=
name|lookup_commit
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|!
operator|(
name|c
operator|->
name|object
operator|.
name|flags
operator|&
name|SEEN
operator|)
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|VERBOSE
condition|)
name|printf
argument_list|(
literal|"Removing %s from .git/shallow\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|c
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|data
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|use_pack_protocol
condition|)
name|packet_buf_write
argument_list|(
name|data
operator|->
name|out
argument_list|,
literal|"shallow %s"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
else|else
block|{
name|strbuf_addstr
argument_list|(
name|data
operator|->
name|out
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|data
operator|->
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_shallow_commits_1
specifier|static
name|int
name|write_shallow_commits_1
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|int
name|use_pack_protocol
parameter_list|,
specifier|const
name|struct
name|sha1_array
modifier|*
name|extra
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|struct
name|write_shallow_data
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|data
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|data
operator|.
name|use_pack_protocol
operator|=
name|use_pack_protocol
expr_stmt|;
name|data
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|for_each_commit_graft
argument_list|(
name|write_one_shallow
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extra
condition|)
return|return
name|data
operator|.
name|count
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|strbuf_addstr
argument_list|(
name|out
argument_list|,
name|sha1_to_hex
argument_list|(
name|extra
operator|->
name|sha1
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|data
operator|.
name|count
operator|++
expr_stmt|;
block|}
return|return
name|data
operator|.
name|count
return|;
block|}
end_function
begin_function
DECL|function|write_shallow_commits
name|int
name|write_shallow_commits
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|int
name|use_pack_protocol
parameter_list|,
specifier|const
name|struct
name|sha1_array
modifier|*
name|extra
parameter_list|)
block|{
return|return
name|write_shallow_commits_1
argument_list|(
name|out
argument_list|,
name|use_pack_protocol
argument_list|,
name|extra
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|temporary_shallow
specifier|static
name|struct
name|strbuf
name|temporary_shallow
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|remove_temporary_shallow
specifier|static
name|void
name|remove_temporary_shallow
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|temporary_shallow
operator|.
name|len
condition|)
block|{
name|unlink_or_warn
argument_list|(
name|temporary_shallow
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|temporary_shallow
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|remove_temporary_shallow_on_signal
specifier|static
name|void
name|remove_temporary_shallow_on_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|remove_temporary_shallow
argument_list|()
expr_stmt|;
name|sigchain_pop
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setup_temporary_shallow
specifier|const
name|char
modifier|*
name|setup_temporary_shallow
parameter_list|(
specifier|const
name|struct
name|sha1_array
modifier|*
name|extra
parameter_list|)
block|{
specifier|static
name|int
name|installed_handler
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|temporary_shallow
operator|.
name|len
condition|)
name|die
argument_list|(
literal|"BUG: attempt to create two temporary shallow files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_shallow_commits
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|extra
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|temporary_shallow
argument_list|,
name|git_path
argument_list|(
literal|"shallow_XXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|xmkstemp
argument_list|(
name|temporary_shallow
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|installed_handler
condition|)
block|{
name|atexit
argument_list|(
name|remove_temporary_shallow
argument_list|)
expr_stmt|;
name|sigchain_push_common
argument_list|(
name|remove_temporary_shallow_on_signal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|!=
name|sb
operator|.
name|len
condition|)
name|die_errno
argument_list|(
literal|"failed to write to %s"
argument_list|,
name|temporary_shallow
operator|.
name|buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|temporary_shallow
operator|.
name|buf
return|;
block|}
comment|/* 	 * is_repository_shallow() sees empty string as "no shallow 	 * file". 	 */
return|return
name|temporary_shallow
operator|.
name|buf
return|;
block|}
end_function
begin_function
DECL|function|setup_alternate_shallow
name|void
name|setup_alternate_shallow
parameter_list|(
name|struct
name|lock_file
modifier|*
name|shallow_lock
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|alternate_shallow_file
parameter_list|,
specifier|const
name|struct
name|sha1_array
modifier|*
name|extra
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
name|shallow_lock
argument_list|,
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
name|check_shallow_file_for_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_shallow_commits
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|extra
argument_list|)
condition|)
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|!=
name|sb
operator|.
name|len
condition|)
name|die_errno
argument_list|(
literal|"failed to write to %s"
argument_list|,
name|shallow_lock
operator|->
name|filename
argument_list|)
expr_stmt|;
operator|*
name|alternate_shallow_file
operator|=
name|shallow_lock
operator|->
name|filename
expr_stmt|;
block|}
else|else
comment|/* 		 * is_repository_shallow() sees empty string as "no 		 * shallow file". 		 */
operator|*
name|alternate_shallow_file
operator|=
literal|""
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|advertise_shallow_grafts_cb
specifier|static
name|int
name|advertise_shallow_grafts_cb
parameter_list|(
specifier|const
name|struct
name|commit_graft
modifier|*
name|graft
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|fd
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|cb
decl_stmt|;
if|if
condition|(
name|graft
operator|->
name|nr_parent
operator|==
operator|-
literal|1
condition|)
name|packet_write
argument_list|(
name|fd
argument_list|,
literal|"shallow %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|advertise_shallow_grafts
name|void
name|advertise_shallow_grafts
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_repository_shallow
argument_list|()
condition|)
return|return;
name|for_each_commit_graft
argument_list|(
name|advertise_shallow_grafts_cb
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * mark_reachable_objects() should have been run prior to this and all  * reachable commits marked as "SEEN".  */
end_comment
begin_function
DECL|function|prune_shallow
name|void
name|prune_shallow
parameter_list|(
name|int
name|show_only
parameter_list|)
block|{
specifier|static
name|struct
name|lock_file
name|shallow_lock
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|show_only
condition|)
block|{
name|write_shallow_commits_1
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SEEN_ONLY
operator||
name|VERBOSE
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return;
block|}
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|shallow_lock
argument_list|,
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
name|check_shallow_file_for_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_shallow_commits_1
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SEEN_ONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|!=
name|sb
operator|.
name|len
condition|)
name|die_errno
argument_list|(
literal|"failed to write to %s"
argument_list|,
name|shallow_lock
operator|.
name|filename
argument_list|)
expr_stmt|;
name|commit_lock_file
argument_list|(
operator|&
name|shallow_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|shallow_lock
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|trace_shallow
name|struct
name|trace_key
name|trace_shallow
init|=
name|TRACE_KEY_INIT
argument_list|(
name|SHALLOW
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Step 1, split sender shallow commits into "ours" and "theirs"  * Step 2, clean "ours" based on .git/shallow  */
end_comment
begin_function
DECL|function|prepare_shallow_info
name|void
name|prepare_shallow_info
parameter_list|(
name|struct
name|shallow_info
modifier|*
name|info
parameter_list|,
name|struct
name|sha1_array
modifier|*
name|sa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|trace_printf_key
argument_list|(
operator|&
name|trace_shallow
argument_list|,
literal|"shallow: prepare_shallow_info\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|shallow
operator|=
name|sa
expr_stmt|;
if|if
condition|(
operator|!
name|sa
condition|)
return|return;
name|info
operator|->
name|ours
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|ours
argument_list|)
operator|*
name|sa
operator|->
name|nr
argument_list|)
expr_stmt|;
name|info
operator|->
name|theirs
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|theirs
argument_list|)
operator|*
name|sa
operator|->
name|nr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sa
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sa
operator|->
name|sha1
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|struct
name|commit_graft
modifier|*
name|graft
decl_stmt|;
name|graft
operator|=
name|lookup_commit_graft
argument_list|(
name|sa
operator|->
name|sha1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|graft
operator|&&
name|graft
operator|->
name|nr_parent
operator|<
literal|0
condition|)
continue|continue;
name|info
operator|->
name|ours
index|[
name|info
operator|->
name|nr_ours
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
name|info
operator|->
name|theirs
index|[
name|info
operator|->
name|nr_theirs
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clear_shallow_info
name|void
name|clear_shallow_info
parameter_list|(
name|struct
name|shallow_info
modifier|*
name|info
parameter_list|)
block|{
name|free
argument_list|(
name|info
operator|->
name|ours
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|theirs
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Step 4, remove non-existent ones in "theirs" after getting the pack */
end_comment
begin_function
DECL|function|remove_nonexistent_theirs_shallow
name|void
name|remove_nonexistent_theirs_shallow
parameter_list|(
name|struct
name|shallow_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|char
argument_list|(
operator|*
name|sha1
argument_list|)
decl|[20]
init|=
name|info
operator|->
name|shallow
operator|->
name|sha1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dst
decl_stmt|;
name|trace_printf_key
argument_list|(
operator|&
name|trace_shallow
argument_list|,
literal|"shallow: remove_nonexistent_theirs_shallow\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dst
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|nr_theirs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|dst
condition|)
name|info
operator|->
name|theirs
index|[
name|dst
index|]
operator|=
name|info
operator|->
name|theirs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sha1
index|[
name|info
operator|->
name|theirs
index|[
name|i
index|]
index|]
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
block|}
name|info
operator|->
name|nr_theirs
operator|=
name|dst
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|define_commit_slab
argument_list|(
name|ref_bitmap
argument_list|,
name|uint32_t
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt
begin_struct
DECL|struct|paint_info
struct|struct
name|paint_info
block|{
DECL|member|ref_bitmap
name|struct
name|ref_bitmap
name|ref_bitmap
decl_stmt|;
DECL|member|nr_bits
name|unsigned
name|nr_bits
decl_stmt|;
DECL|member|slab
name|char
modifier|*
modifier|*
name|slab
decl_stmt|;
DECL|member|free
DECL|member|end
name|char
modifier|*
name|free
decl_stmt|,
modifier|*
name|end
decl_stmt|;
DECL|member|slab_count
name|unsigned
name|slab_count
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|paint_alloc
specifier|static
name|uint32_t
modifier|*
name|paint_alloc
parameter_list|(
name|struct
name|paint_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|nr
init|=
operator|(
name|info
operator|->
name|nr_bits
operator|+
literal|31
operator|)
operator|/
literal|32
decl_stmt|;
name|unsigned
name|size
init|=
name|nr
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|slab_count
operator|||
name|info
operator|->
name|free
operator|+
name|size
operator|>
name|info
operator|->
name|end
condition|)
block|{
name|info
operator|->
name|slab_count
operator|++
expr_stmt|;
name|info
operator|->
name|slab
operator|=
name|xrealloc
argument_list|(
name|info
operator|->
name|slab
argument_list|,
name|info
operator|->
name|slab_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|info
operator|->
name|slab
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|free
operator|=
name|xmalloc
argument_list|(
name|COMMIT_SLAB_SIZE
argument_list|)
expr_stmt|;
name|info
operator|->
name|slab
index|[
name|info
operator|->
name|slab_count
operator|-
literal|1
index|]
operator|=
name|info
operator|->
name|free
expr_stmt|;
name|info
operator|->
name|end
operator|=
name|info
operator|->
name|free
operator|+
name|COMMIT_SLAB_SIZE
expr_stmt|;
block|}
name|p
operator|=
name|info
operator|->
name|free
expr_stmt|;
name|info
operator|->
name|free
operator|+=
name|size
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_comment
comment|/*  * Given a commit SHA-1, walk down to parents until either SEEN,  * UNINTERESTING or BOTTOM is hit. Set the id-th bit in ref_bitmap for  * all walked commits.  */
end_comment
begin_function
DECL|function|paint_down
specifier|static
name|void
name|paint_down
parameter_list|(
name|struct
name|paint_info
modifier|*
name|info
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|nr
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|int
name|bitmap_nr
init|=
operator|(
name|info
operator|->
name|nr_bits
operator|+
literal|31
operator|)
operator|/
literal|32
decl_stmt|;
name|int
name|bitmap_size
init|=
name|bitmap_nr
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
name|tmp
init|=
name|xmalloc
argument_list|(
name|bitmap_size
argument_list|)
decl_stmt|;
comment|/* to be freed before return */
name|uint32_t
modifier|*
name|bitmap
init|=
name|paint_alloc
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|c
init|=
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return;
name|memset
argument_list|(
name|bitmap
argument_list|,
literal|0
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
name|bitmap
index|[
name|id
operator|/
literal|32
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|id
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|c
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
name|struct
name|commit
modifier|*
name|c
init|=
name|head
operator|->
name|item
decl_stmt|;
name|uint32_t
modifier|*
modifier|*
name|refs
init|=
name|ref_bitmap_at
argument_list|(
operator|&
name|info
operator|->
name|ref_bitmap
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|p
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX check "UNINTERESTING" from pack bitmaps if available */
if|if
condition|(
name|c
operator|->
name|object
operator|.
name|flags
operator|&
operator|(
name|SEEN
operator||
name|UNINTERESTING
operator|)
condition|)
continue|continue;
else|else
name|c
operator|->
name|object
operator|.
name|flags
operator||=
name|SEEN
expr_stmt|;
if|if
condition|(
operator|*
name|refs
operator|==
name|NULL
condition|)
operator|*
name|refs
operator|=
name|bitmap
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|tmp
argument_list|,
operator|*
name|refs
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bitmap_nr
condition|;
name|i
operator|++
control|)
name|tmp
index|[
name|i
index|]
operator||=
name|bitmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
operator|*
name|refs
argument_list|,
name|bitmap_size
argument_list|)
condition|)
block|{
operator|*
name|refs
operator|=
name|paint_alloc
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|refs
argument_list|,
name|tmp
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|->
name|object
operator|.
name|flags
operator|&
name|BOTTOM
condition|)
continue|continue;
if|if
condition|(
name|parse_commit
argument_list|(
name|c
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to parse commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|c
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|c
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|uint32_t
modifier|*
modifier|*
name|p_refs
init|=
name|ref_bitmap_at
argument_list|(
operator|&
name|info
operator|->
name|ref_bitmap
argument_list|,
name|p
operator|->
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|SEEN
condition|)
continue|continue;
if|if
condition|(
operator|*
name|p_refs
operator|==
name|NULL
operator|||
operator|*
name|p_refs
operator|==
operator|*
name|refs
condition|)
operator|*
name|p_refs
operator|=
operator|*
name|refs
expr_stmt|;
name|commit_list_insert
argument_list|(
name|p
operator|->
name|item
argument_list|,
operator|&
name|head
argument_list|)
expr_stmt|;
block|}
block|}
name|nr
operator|=
name|get_max_object_index
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|get_indexed_object
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|o
operator|->
name|flags
operator|&=
operator|~
name|SEEN
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mark_uninteresting
specifier|static
name|int
name|mark_uninteresting
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
return|return
literal|0
return|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|mark_parents_uninteresting
argument_list|(
name|commit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|post_assign_shallow
parameter_list|(
name|struct
name|shallow_info
modifier|*
name|info
parameter_list|,
name|struct
name|ref_bitmap
modifier|*
name|ref_bitmap
parameter_list|,
name|int
modifier|*
name|ref_status
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * Step 6(+7), associate shallow commits with new refs  *  * info->ref must be initialized before calling this function.  *  * If used is not NULL, it's an array of info->shallow->nr  * bitmaps. The n-th bit set in the m-th bitmap if ref[n] needs the  * m-th shallow commit from info->shallow.  *  * If used is NULL, "ours" and "theirs" are updated. And if ref_status  * is not NULL it's an array of ref->nr ints. ref_status[i] is true if  * the ref needs some shallow commits from either info->ours or  * info->theirs.  */
end_comment
begin_function
DECL|function|assign_shallow_commits_to_refs
name|void
name|assign_shallow_commits_to_refs
parameter_list|(
name|struct
name|shallow_info
modifier|*
name|info
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|used
parameter_list|,
name|int
modifier|*
name|ref_status
parameter_list|)
block|{
name|unsigned
name|char
argument_list|(
operator|*
name|sha1
argument_list|)
decl|[20]
init|=
name|info
operator|->
name|shallow
operator|->
name|sha1
decl_stmt|;
name|struct
name|sha1_array
modifier|*
name|ref
init|=
name|info
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|nr
decl_stmt|;
name|int
modifier|*
name|shallow
decl_stmt|,
name|nr_shallow
init|=
literal|0
decl_stmt|;
name|struct
name|paint_info
name|pi
decl_stmt|;
name|trace_printf_key
argument_list|(
operator|&
name|trace_shallow
argument_list|,
literal|"shallow: assign_shallow_commits_to_refs\n"
argument_list|)
expr_stmt|;
name|shallow
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|shallow
argument_list|)
operator|*
operator|(
name|info
operator|->
name|nr_ours
operator|+
name|info
operator|->
name|nr_theirs
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|nr_ours
condition|;
name|i
operator|++
control|)
name|shallow
index|[
name|nr_shallow
operator|++
index|]
operator|=
name|info
operator|->
name|ours
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|nr_theirs
condition|;
name|i
operator|++
control|)
name|shallow
index|[
name|nr_shallow
operator|++
index|]
operator|=
name|info
operator|->
name|theirs
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Prepare the commit graph to track what refs can reach what 	 * (new) shallow commits. 	 */
name|nr
operator|=
name|get_max_object_index
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|get_indexed_object
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
continue|continue;
name|o
operator|->
name|flags
operator|&=
operator|~
operator|(
name|UNINTERESTING
operator||
name|BOTTOM
operator||
name|SEEN
operator|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|init_ref_bitmap
argument_list|(
operator|&
name|pi
operator|.
name|ref_bitmap
argument_list|)
expr_stmt|;
name|pi
operator|.
name|nr_bits
operator|=
name|ref
operator|->
name|nr
expr_stmt|;
comment|/* 	 * "--not --all" to cut short the traversal if new refs 	 * connect to old refs. If not (e.g. force ref updates) it'll 	 * have to go down to the current shallow commits. 	 */
name|head_ref
argument_list|(
name|mark_uninteresting
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|for_each_ref
argument_list|(
name|mark_uninteresting
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Mark potential bottoms so we won't go out of bound */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_shallow
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|commit
modifier|*
name|c
init|=
name|lookup_commit
argument_list|(
name|sha1
index|[
name|shallow
index|[
name|i
index|]
index|]
argument_list|)
decl_stmt|;
name|c
operator|->
name|object
operator|.
name|flags
operator||=
name|BOTTOM
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ref
operator|->
name|nr
condition|;
name|i
operator|++
control|)
name|paint_down
argument_list|(
operator|&
name|pi
argument_list|,
name|ref
operator|->
name|sha1
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
condition|)
block|{
name|int
name|bitmap_size
init|=
operator|(
operator|(
name|pi
operator|.
name|nr_bits
operator|+
literal|31
operator|)
operator|/
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|used
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|used
argument_list|)
operator|*
name|info
operator|->
name|shallow
operator|->
name|nr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_shallow
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|commit
modifier|*
name|c
init|=
name|lookup_commit
argument_list|(
name|sha1
index|[
name|shallow
index|[
name|i
index|]
index|]
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
modifier|*
name|map
init|=
name|ref_bitmap_at
argument_list|(
operator|&
name|pi
operator|.
name|ref_bitmap
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|map
condition|)
name|used
index|[
name|shallow
index|[
name|i
index|]
index|]
operator|=
name|xmemdupz
argument_list|(
operator|*
name|map
argument_list|,
name|bitmap_size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * unreachable shallow commits are not removed from 		 * "ours" and "theirs". The user is supposed to run 		 * step 7 on every ref separately and not trust "ours" 		 * and "theirs" any more. 		 */
block|}
else|else
name|post_assign_shallow
argument_list|(
name|info
argument_list|,
operator|&
name|pi
operator|.
name|ref_bitmap
argument_list|,
name|ref_status
argument_list|)
expr_stmt|;
name|clear_ref_bitmap
argument_list|(
operator|&
name|pi
operator|.
name|ref_bitmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|.
name|slab_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|pi
operator|.
name|slab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
operator|.
name|slab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|shallow
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|commit_array
struct|struct
name|commit_array
block|{
DECL|member|commits
name|struct
name|commit
modifier|*
modifier|*
name|commits
decl_stmt|;
DECL|member|nr
DECL|member|alloc
name|int
name|nr
decl_stmt|,
name|alloc
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|add_ref
specifier|static
name|int
name|add_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|commit_array
modifier|*
name|ca
init|=
name|cb_data
decl_stmt|;
name|ALLOC_GROW
argument_list|(
name|ca
operator|->
name|commits
argument_list|,
name|ca
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|ca
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|ca
operator|->
name|commits
index|[
name|ca
operator|->
name|nr
index|]
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|commits
index|[
name|ca
operator|->
name|nr
index|]
condition|)
name|ca
operator|->
name|nr
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|update_refstatus
specifier|static
name|void
name|update_refstatus
parameter_list|(
name|int
modifier|*
name|ref_status
parameter_list|,
name|int
name|nr
parameter_list|,
name|uint32_t
modifier|*
name|bitmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ref_status
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bitmap
index|[
name|i
operator|/
literal|32
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|32
operator|)
operator|)
condition|)
name|ref_status
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Step 7, reachability test on "ours" at commit level  */
end_comment
begin_function
DECL|function|post_assign_shallow
specifier|static
name|void
name|post_assign_shallow
parameter_list|(
name|struct
name|shallow_info
modifier|*
name|info
parameter_list|,
name|struct
name|ref_bitmap
modifier|*
name|ref_bitmap
parameter_list|,
name|int
modifier|*
name|ref_status
parameter_list|)
block|{
name|unsigned
name|char
argument_list|(
operator|*
name|sha1
argument_list|)
decl|[20]
init|=
name|info
operator|->
name|shallow
operator|->
name|sha1
decl_stmt|;
name|struct
name|commit
modifier|*
name|c
decl_stmt|;
name|uint32_t
modifier|*
modifier|*
name|bitmap
decl_stmt|;
name|int
name|dst
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|bitmap_nr
init|=
operator|(
name|info
operator|->
name|ref
operator|->
name|nr
operator|+
literal|31
operator|)
operator|/
literal|32
decl_stmt|;
name|struct
name|commit_array
name|ca
decl_stmt|;
name|trace_printf_key
argument_list|(
operator|&
name|trace_shallow
argument_list|,
literal|"shallow: post_assign_shallow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_status
condition|)
name|memset
argument_list|(
name|ref_status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref_status
argument_list|)
operator|*
name|info
operator|->
name|ref
operator|->
name|nr
argument_list|)
expr_stmt|;
comment|/* Remove unreachable shallow commits from "theirs" */
for|for
control|(
name|i
operator|=
name|dst
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|nr_theirs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|dst
condition|)
name|info
operator|->
name|theirs
index|[
name|dst
index|]
operator|=
name|info
operator|->
name|theirs
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
name|lookup_commit
argument_list|(
name|sha1
index|[
name|info
operator|->
name|theirs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|ref_bitmap_at
argument_list|(
name|ref_bitmap
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bitmap
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bitmap_nr
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitmap
index|[
literal|0
index|]
index|[
name|j
index|]
condition|)
block|{
name|update_refstatus
argument_list|(
name|ref_status
argument_list|,
name|info
operator|->
name|ref
operator|->
name|nr
argument_list|,
operator|*
name|bitmap
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|info
operator|->
name|nr_theirs
operator|=
name|dst
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
name|head_ref
argument_list|(
name|add_ref
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
name|for_each_ref
argument_list|(
name|add_ref
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
comment|/* Remove unreachable shallow commits from "ours" */
for|for
control|(
name|i
operator|=
name|dst
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|nr_ours
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|dst
condition|)
name|info
operator|->
name|ours
index|[
name|dst
index|]
operator|=
name|info
operator|->
name|ours
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
name|lookup_commit
argument_list|(
name|sha1
index|[
name|info
operator|->
name|ours
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|ref_bitmap_at
argument_list|(
name|ref_bitmap
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bitmap
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bitmap_nr
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitmap
index|[
literal|0
index|]
index|[
name|j
index|]
operator|&&
comment|/* Step 7, reachability test at commit level */
operator|!
name|in_merge_bases_many
argument_list|(
name|c
argument_list|,
name|ca
operator|.
name|nr
argument_list|,
name|ca
operator|.
name|commits
argument_list|)
condition|)
block|{
name|update_refstatus
argument_list|(
name|ref_status
argument_list|,
name|info
operator|->
name|ref
operator|->
name|nr
argument_list|,
operator|*
name|bitmap
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|info
operator|->
name|nr_ours
operator|=
name|dst
expr_stmt|;
name|free
argument_list|(
name|ca
operator|.
name|commits
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* (Delayed) step 7, reachability test at commit level */
end_comment
begin_function
DECL|function|delayed_reachability_test
name|int
name|delayed_reachability_test
parameter_list|(
name|struct
name|shallow_info
modifier|*
name|si
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|si
operator|->
name|need_reachability_test
index|[
name|c
index|]
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit
argument_list|(
name|si
operator|->
name|shallow
operator|->
name|sha1
index|[
name|c
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|si
operator|->
name|commits
condition|)
block|{
name|struct
name|commit_array
name|ca
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
name|head_ref
argument_list|(
name|add_ref
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
name|for_each_ref
argument_list|(
name|add_ref
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
name|si
operator|->
name|commits
operator|=
name|ca
operator|.
name|commits
expr_stmt|;
name|si
operator|->
name|nr_commits
operator|=
name|ca
operator|.
name|nr
expr_stmt|;
block|}
name|si
operator|->
name|reachable
index|[
name|c
index|]
operator|=
name|in_merge_bases_many
argument_list|(
name|commit
argument_list|,
name|si
operator|->
name|nr_commits
argument_list|,
name|si
operator|->
name|commits
argument_list|)
expr_stmt|;
name|si
operator|->
name|need_reachability_test
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|si
operator|->
name|reachable
index|[
name|c
index|]
return|;
block|}
end_function
end_unit
