begin_unit
begin_comment
comment|/*  * Another stupid program, this one parsing the headers of an  * email to figure out authorship and subject  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_decl_stmt
DECL|variable|cmitmsg
DECL|variable|patchfile
DECL|variable|fin
DECL|variable|fout
specifier|static
name|FILE
modifier|*
name|cmitmsg
decl_stmt|,
modifier|*
name|patchfile
decl_stmt|,
modifier|*
name|fin
decl_stmt|,
modifier|*
name|fout
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keep_subject
specifier|static
name|int
name|keep_subject
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|metainfo_charset
specifier|static
specifier|const
name|char
modifier|*
name|metainfo_charset
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|line
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|name
specifier|static
name|char
name|name
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|email
specifier|static
name|char
name|email
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|TE_DONTCARE
DECL|enumerator|TE_QP
DECL|enumerator|TE_BASE64
name|TE_DONTCARE
block|,
name|TE_QP
block|,
name|TE_BASE64
block|, }
DECL|variable|transfer_encoding
name|transfer_encoding
enum|;
end_enum
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|TYPE_TEXT
DECL|enumerator|TYPE_OTHER
name|TYPE_TEXT
block|,
name|TYPE_OTHER
block|, }
DECL|variable|message_type
name|message_type
enum|;
end_enum
begin_decl_stmt
DECL|variable|charset
specifier|static
name|char
name|charset
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|patch_lines
specifier|static
name|int
name|patch_lines
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|p_hdr_data
DECL|variable|s_hdr_data
specifier|static
name|char
modifier|*
modifier|*
name|p_hdr_data
decl_stmt|,
modifier|*
modifier|*
name|s_hdr_data
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|MAX_HDR_PARSED
define|#
directive|define
name|MAX_HDR_PARSED
value|10
end_define
begin_define
DECL|macro|MAX_BOUNDARIES
define|#
directive|define
name|MAX_BOUNDARIES
value|5
end_define
begin_function
DECL|function|sanity_check
specifier|static
name|char
modifier|*
name|sanity_check
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|email
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
operator|||
name|len
operator|>
literal|60
condition|)
return|return
name|email
return|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
literal|'<'
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
literal|'>'
argument_list|)
condition|)
return|return
name|email
return|;
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|bogus_from
specifier|static
name|int
name|bogus_from
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* John Doe<johndoe> */
name|char
modifier|*
name|bra
decl_stmt|,
modifier|*
name|ket
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* This is fallback, so do not bother if we already have an 	 * e-mail address. 	 */
if|if
condition|(
operator|*
name|email
condition|)
return|return
literal|0
return|;
name|bra
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bra
condition|)
return|return
literal|0
return|;
name|ket
operator|=
name|strchr
argument_list|(
name|bra
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ket
condition|)
return|return
literal|0
return|;
for|for
control|(
name|dst
operator|=
name|email
operator|,
name|cp
operator|=
name|bra
operator|+
literal|1
init|;
name|cp
operator|<
name|ket
condition|;
control|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|line
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
for|for
control|(
name|bra
operator|--
init|;
name|isspace
argument_list|(
operator|*
name|bra
argument_list|)
condition|;
name|bra
operator|--
control|)
operator|*
name|bra
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|sanity_check
argument_list|(
name|cp
argument_list|,
name|email
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|handle_from
specifier|static
name|int
name|handle_from
parameter_list|(
name|char
modifier|*
name|in_line
parameter_list|)
block|{
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|in_line
argument_list|)
expr_stmt|;
name|at
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|at
condition|)
return|return
name|bogus_from
argument_list|(
name|line
argument_list|)
return|;
comment|/* 	 * If we already have one email, don't take any confusing lines 	 */
if|if
condition|(
operator|*
name|email
operator|&&
name|strchr
argument_list|(
name|at
operator|+
literal|1
argument_list|,
literal|'@'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Pick up the string around '@', possibly delimited with<> 	 * pair; that is the email part.  White them out while copying. 	 */
while|while
condition|(
name|at
operator|>
name|line
condition|)
block|{
name|char
name|c
init|=
name|at
index|[
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|at
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
name|at
operator|--
expr_stmt|;
block|}
name|dst
operator|=
name|email
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
name|c
operator|==
literal|'>'
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|*
name|at
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
operator|*
name|at
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dst
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* The remainder is name.  It could be "John Doe<john.doe@xz>" 	 * or "john.doe@xz (John Doe)", but we have whited out the 	 * email part, so trim from both ends, possibly removing 	 * the () pair at the end. 	 */
name|at
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
operator|>
name|line
condition|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
operator|--
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|at
index|[
operator|(
name|c
operator|==
literal|')'
operator|)
condition|?
literal|0
else|:
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|at
operator|=
name|line
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|at
operator|++
expr_stmt|;
break|break;
block|}
name|at
operator|++
expr_stmt|;
block|}
name|at
operator|=
name|sanity_check
argument_list|(
name|at
argument_list|,
name|email
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|handle_header
specifier|static
name|int
name|handle_header
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|ofs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|line
operator|||
operator|!
name|data
condition|)
return|return
literal|1
return|;
name|strcpy
argument_list|(
name|data
argument_list|,
name|line
operator|+
name|ofs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* NOTE NOTE NOTE.  We do not claim we do full MIME.  We just attempt  * to have enough heuristics to grok MIME encoded patches often found  * on our mailing lists.  For example, we do not even treat header lines  * case insensitively.  */
end_comment
begin_function
DECL|function|slurp_attr
specifier|static
name|int
name|slurp_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ends
decl_stmt|,
modifier|*
name|ap
init|=
name|strcasestr
argument_list|(
name|line
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
block|{
operator|*
name|attr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ap
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'"'
condition|)
block|{
name|ap
operator|++
expr_stmt|;
name|ends
operator|=
literal|"\""
expr_stmt|;
block|}
else|else
name|ends
operator|=
literal|"; \t"
expr_stmt|;
name|sz
operator|=
name|strcspn
argument_list|(
name|ap
argument_list|,
name|ends
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|attr
argument_list|,
name|ap
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|attr
index|[
name|sz
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_struct
DECL|struct|content_type
struct|struct
name|content_type
block|{
DECL|member|boundary
name|char
modifier|*
name|boundary
decl_stmt|;
DECL|member|boundary_len
name|int
name|boundary_len
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|content
specifier|static
name|struct
name|content_type
name|content
index|[
name|MAX_BOUNDARIES
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|content_top
specifier|static
name|struct
name|content_type
modifier|*
name|content_top
init|=
name|content
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|handle_content_type
specifier|static
name|int
name|handle_content_type
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
name|boundary
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|strcasestr
argument_list|(
name|line
argument_list|,
literal|"text/"
argument_list|)
operator|==
name|NULL
condition|)
name|message_type
operator|=
name|TYPE_OTHER
expr_stmt|;
if|if
condition|(
name|slurp_attr
argument_list|(
name|line
argument_list|,
literal|"boundary="
argument_list|,
name|boundary
operator|+
literal|2
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|boundary
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_top
operator|++
operator|>=
operator|&
name|content
index|[
name|MAX_BOUNDARIES
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many boundaries to handle\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|content_top
operator|->
name|boundary_len
operator|=
name|strlen
argument_list|(
name|boundary
argument_list|)
expr_stmt|;
name|content_top
operator|->
name|boundary
operator|=
name|xmalloc
argument_list|(
name|content_top
operator|->
name|boundary_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|content_top
operator|->
name|boundary
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slurp_attr
argument_list|(
name|line
argument_list|,
literal|"charset="
argument_list|,
name|charset
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|charset
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|charset
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_content_transfer_encoding
specifier|static
name|int
name|handle_content_transfer_encoding
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
name|strcasestr
argument_list|(
name|line
argument_list|,
literal|"base64"
argument_list|)
condition|)
name|transfer_encoding
operator|=
name|TE_BASE64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasestr
argument_list|(
name|line
argument_list|,
literal|"quoted-printable"
argument_list|)
condition|)
name|transfer_encoding
operator|=
name|TE_QP
expr_stmt|;
else|else
name|transfer_encoding
operator|=
name|TE_DONTCARE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_multipart_boundary
specifier|static
name|int
name|is_multipart_boundary
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
return|return
operator|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
name|content_top
operator|->
name|boundary
argument_list|,
name|content_top
operator|->
name|boundary_len
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|eatspace
specifier|static
name|int
name|eatspace
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|cleanup_subject
specifier|static
name|char
modifier|*
name|cleanup_subject
parameter_list|(
name|char
modifier|*
name|subject
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|,
name|remove
decl_stmt|;
switch|switch
condition|(
operator|*
name|subject
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"e:"
argument_list|,
name|subject
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|subject
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|':'
case|:
name|subject
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
name|p
operator|=
name|strchr
argument_list|(
name|subject
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|subject
operator|++
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|remove
operator|=
name|p
operator|-
name|subject
expr_stmt|;
if|if
condition|(
name|remove
operator|<=
name|len
operator|*
literal|2
condition|)
block|{
name|subject
operator|=
name|p
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|eatspace
argument_list|(
name|subject
argument_list|)
expr_stmt|;
return|return
name|subject
return|;
block|}
block|}
end_function
begin_function
DECL|function|cleanup_space
specifier|static
name|void
name|cleanup_space
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|buf
operator|)
operator|!=
literal|0
condition|)
block|{
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|buf
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|c
operator|=
operator|*
name|buf
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|memmove
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|buf
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|decode_header
parameter_list|(
name|char
modifier|*
name|it
parameter_list|,
name|unsigned
name|itsize
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|header
specifier|static
specifier|const
name|char
modifier|*
name|header
index|[
name|MAX_HDR_PARSED
index|]
init|=
block|{
literal|"From"
block|,
literal|"Subject"
block|,
literal|"Date"
block|, }
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|check_header
specifier|static
name|int
name|check_header
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|linesize
parameter_list|,
name|char
modifier|*
modifier|*
name|hdr_data
parameter_list|,
name|int
name|overwrite
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* search for the interesting parts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|header
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|hdr_data
index|[
name|i
index|]
operator|||
name|overwrite
operator|)
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|line
argument_list|,
name|header
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|&&
name|line
index|[
name|len
index|]
operator|==
literal|':'
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Unwrap inline B and Q encoding, and optionally 			 * normalize the meta information to utf8. 			 */
name|decode_header
argument_list|(
name|line
operator|+
name|len
operator|+
literal|2
argument_list|,
name|linesize
operator|-
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|hdr_data
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
literal|1000
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle_header
argument_list|(
name|line
argument_list|,
name|hdr_data
index|[
name|i
index|]
argument_list|,
name|len
operator|+
literal|2
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Content stuff */
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|line
argument_list|,
literal|"Content-Type"
argument_list|,
literal|12
argument_list|)
operator|&&
name|line
index|[
literal|12
index|]
operator|==
literal|':'
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|12
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|decode_header
argument_list|(
name|line
operator|+
literal|12
operator|+
literal|2
argument_list|,
name|linesize
operator|-
literal|12
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle_content_type
argument_list|(
name|line
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|line
argument_list|,
literal|"Content-Transfer-Encoding"
argument_list|,
literal|25
argument_list|)
operator|&&
name|line
index|[
literal|25
index|]
operator|==
literal|':'
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|25
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|decode_header
argument_list|(
name|line
operator|+
literal|25
operator|+
literal|2
argument_list|,
name|linesize
operator|-
literal|25
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle_content_transfer_encoding
argument_list|(
name|line
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
comment|/* for inbody stuff */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|">From"
argument_list|,
name|line
argument_list|,
literal|5
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"[PATCH]"
argument_list|,
name|line
argument_list|,
literal|7
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|7
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"Subject: "
argument_list|,
name|header
index|[
name|i
index|]
argument_list|,
literal|9
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|handle_header
argument_list|(
name|line
argument_list|,
name|hdr_data
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
comment|/* no match */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_rfc2822_header
specifier|static
name|int
name|is_rfc2822_header
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* 	 * The section that defines the loosest possible 	 * field name is "3.6.8 Optional fields". 	 * 	 * optional-field = field-name ":" unstructured CRLF 	 * field-name = 1*ftext 	 * ftext = %d33-57 / %59-126 	 */
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|line
decl_stmt|;
comment|/* Count mbox From headers as headers */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|">From "
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
return|return
name|cp
operator|!=
name|line
return|;
if|if
condition|(
operator|(
literal|33
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|57
operator|)
operator|||
operator|(
literal|59
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|126
operator|)
condition|)
continue|continue;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * sz is size of 'line' buffer in bytes.  Must be reasonably  * long enough to hold one physical real-world e-mail line.  */
end_comment
begin_function
DECL|function|read_one_header_line
specifier|static
name|int
name|read_one_header_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|sz
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* 	 * We will read at most (sz-1) bytes and then potentially 	 * re-add NUL after it.  Accessing line[sz] after this is safe 	 * and we can allow len to grow up to and including sz. 	 */
name|sz
operator|--
expr_stmt|;
comment|/* Get the first part of the line. */
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|line
argument_list|,
name|sz
argument_list|,
name|in
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Is it an empty line or not a valid rfc2822 header? 	 * If so, stop here, and return false ("not a header") 	 */
name|len
operator|=
name|eatspace
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|is_rfc2822_header
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* Re-add the newline */
name|line
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|line
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Now we need to eat all the continuation lines.. 	 * Yuck, 2822 header "folding" 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|peek
decl_stmt|,
name|addlen
decl_stmt|;
specifier|static
name|char
name|continuation
index|[
literal|1000
index|]
decl_stmt|;
name|peek
operator|=
name|fgetc
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|peek
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|!=
literal|' '
operator|&&
name|peek
operator|!=
literal|'\t'
condition|)
break|break;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|continuation
argument_list|,
sizeof|sizeof
argument_list|(
name|continuation
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
break|break;
name|addlen
operator|=
name|eatspace
argument_list|(
name|continuation
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|sz
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|addlen
operator|>=
name|sz
operator|-
name|len
condition|)
name|addlen
operator|=
name|sz
operator|-
name|len
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|line
operator|+
name|len
argument_list|,
name|continuation
argument_list|,
name|addlen
argument_list|)
expr_stmt|;
name|line
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|len
operator|+=
name|addlen
expr_stmt|;
block|}
block|}
name|line
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|decode_q_segment
specifier|static
name|int
name|decode_q_segment
parameter_list|(
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|ot
parameter_list|,
name|unsigned
name|otsize
parameter_list|,
name|char
modifier|*
name|ep
parameter_list|,
name|int
name|rfc2047
parameter_list|)
block|{
name|char
modifier|*
name|otbegin
init|=
name|ot
decl_stmt|;
name|char
modifier|*
name|otend
init|=
name|ot
operator|+
name|otsize
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|in
operator|++
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|in
operator|<=
name|ep
operator|)
condition|)
block|{
if|if
condition|(
name|ot
operator|==
name|otend
condition|)
block|{
operator|*
operator|--
name|ot
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|int
name|d
init|=
operator|*
name|in
operator|++
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|'\n'
operator|||
operator|!
name|d
condition|)
break|break;
comment|/* drop trailing newline */
operator|*
name|ot
operator|++
operator|=
operator|(
operator|(
name|hexval
argument_list|(
name|d
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hexval
argument_list|(
operator|*
name|in
operator|++
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rfc2047
operator|&&
name|c
operator|==
literal|'_'
condition|)
comment|/* rfc2047 4.2 (2) */
name|c
operator|=
literal|0x20
expr_stmt|;
operator|*
name|ot
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|ot
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ot
operator|-
name|otbegin
operator|)
return|;
block|}
end_function
begin_function
DECL|function|decode_b_segment
specifier|static
name|int
name|decode_b_segment
parameter_list|(
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|ot
parameter_list|,
name|unsigned
name|otsize
parameter_list|,
name|char
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Decode in..ep, possibly in-place to ot */
name|int
name|c
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|,
name|acc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|otbegin
init|=
name|ot
decl_stmt|;
name|char
modifier|*
name|otend
init|=
name|ot
operator|+
name|otsize
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|in
operator|++
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|in
operator|<=
name|ep
operator|)
condition|)
block|{
if|if
condition|(
name|ot
operator|==
name|otend
condition|)
block|{
operator|*
operator|--
name|ot
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
literal|62
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|c
operator|=
literal|63
expr_stmt|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|-=
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|-=
literal|'a'
operator|-
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|c
operator|-=
literal|'0'
operator|-
literal|52
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
comment|/* padding is almost like (c == 0), except we do 			 * not output NUL resulting only from it; 			 * for now we just trust the data. 			 */
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* garbage */
switch|switch
condition|(
name|pos
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|acc
operator|=
operator|(
name|c
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|ot
operator|++
operator|=
operator|(
name|acc
operator||
operator|(
name|c
operator|>>
literal|4
operator|)
operator|)
expr_stmt|;
name|acc
operator|=
operator|(
name|c
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|ot
operator|++
operator|=
operator|(
name|acc
operator||
operator|(
name|c
operator|>>
literal|2
operator|)
operator|)
expr_stmt|;
name|acc
operator|=
operator|(
name|c
operator|&
literal|3
operator|)
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|ot
operator|++
operator|=
operator|(
name|acc
operator||
name|c
operator|)
expr_stmt|;
name|acc
operator|=
name|pos
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|ot
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ot
operator|-
name|otbegin
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * When there is no known charset, guess.  *  * Right now we assume that if the target is UTF-8 (the default),  * and it already looks like UTF-8 (which includes US-ASCII as its  * subset, of course) then that is what it is and there is nothing  * to do.  *  * Otherwise, we default to assuming it is Latin1 for historical  * reasons.  */
end_comment
begin_function
DECL|function|guess_charset
specifier|static
specifier|const
name|char
modifier|*
name|guess_charset
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|target_charset
parameter_list|)
block|{
if|if
condition|(
name|is_encoding_utf8
argument_list|(
name|target_charset
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_utf8
argument_list|(
name|line
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
literal|"latin1"
return|;
block|}
end_function
begin_function
DECL|function|convert_to_utf8
specifier|static
name|void
name|convert_to_utf8
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|linesize
parameter_list|,
specifier|const
name|char
modifier|*
name|charset
parameter_list|)
block|{
name|char
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|charset
operator|||
operator|!
operator|*
name|charset
condition|)
block|{
name|charset
operator|=
name|guess_charset
argument_list|(
name|line
argument_list|,
name|metainfo_charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|charset
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|metainfo_charset
argument_list|,
name|charset
argument_list|)
condition|)
return|return;
name|out
operator|=
name|reencode_string
argument_list|(
name|line
argument_list|,
name|metainfo_charset
argument_list|,
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
name|die
argument_list|(
literal|"cannot convert from %s to %s\n"
argument_list|,
name|charset
argument_list|,
name|metainfo_charset
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|line
argument_list|,
name|out
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decode_header_bq
specifier|static
name|int
name|decode_header_bq
parameter_list|(
name|char
modifier|*
name|it
parameter_list|,
name|unsigned
name|itsize
parameter_list|)
block|{
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|char
name|outbuf
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|rfc2047
init|=
literal|0
decl_stmt|;
name|in
operator|=
name|it
expr_stmt|;
name|out
operator|=
name|outbuf
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|=
name|strstr
argument_list|(
name|in
argument_list|,
literal|"=?"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|sz
decl_stmt|,
name|encoding
decl_stmt|;
name|char
name|charset_q
index|[
literal|256
index|]
decl_stmt|,
name|piecebuf
index|[
literal|256
index|]
decl_stmt|;
name|rfc2047
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|ep
condition|)
block|{
name|sz
operator|=
name|ep
operator|-
name|in
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|out
operator|+=
name|sz
expr_stmt|;
name|in
operator|+=
name|sz
expr_stmt|;
block|}
comment|/* E.g. 		 * ep : "=?iso-2022-jp?B?GyR...?= foo" 		 * ep : "=?ISO-8859-1?Q?Foo=FCbar?= baz" 		 */
name|ep
operator|+=
literal|2
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|ep
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|rfc2047
return|;
comment|/* no munging */
for|for
control|(
name|sp
operator|=
name|ep
init|;
name|sp
operator|<
name|cp
condition|;
name|sp
operator|++
control|)
name|charset_q
index|[
name|sp
operator|-
name|ep
index|]
operator|=
name|tolower
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
name|charset_q
index|[
name|cp
operator|-
name|ep
index|]
operator|=
literal|0
expr_stmt|;
name|encoding
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
operator|||
name|cp
index|[
literal|2
index|]
operator|!=
literal|'?'
condition|)
return|return
name|rfc2047
return|;
comment|/* no munging */
name|ep
operator|=
name|strstr
argument_list|(
name|cp
operator|+
literal|3
argument_list|,
literal|"?="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
return|return
name|rfc2047
return|;
comment|/* no munging */
switch|switch
condition|(
name|tolower
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
default|default:
return|return
name|rfc2047
return|;
comment|/* no munging */
case|case
literal|'b'
case|:
name|sz
operator|=
name|decode_b_segment
argument_list|(
name|cp
operator|+
literal|3
argument_list|,
name|piecebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|piecebuf
argument_list|)
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|sz
operator|=
name|decode_q_segment
argument_list|(
name|cp
operator|+
literal|3
argument_list|,
name|piecebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|piecebuf
argument_list|)
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
return|return
name|rfc2047
return|;
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|piecebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|piecebuf
argument_list|)
argument_list|,
name|charset_q
argument_list|)
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|piecebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|+
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
operator|<=
name|out
operator|+
name|sz
condition|)
return|return
name|rfc2047
return|;
comment|/* no munging */
name|strcpy
argument_list|(
name|out
argument_list|,
name|piecebuf
argument_list|)
expr_stmt|;
name|out
operator|+=
name|sz
expr_stmt|;
name|in
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|it
argument_list|,
name|outbuf
argument_list|,
name|itsize
argument_list|)
expr_stmt|;
return|return
name|rfc2047
return|;
block|}
end_function
begin_function
DECL|function|decode_header
specifier|static
name|void
name|decode_header
parameter_list|(
name|char
modifier|*
name|it
parameter_list|,
name|unsigned
name|itsize
parameter_list|)
block|{
if|if
condition|(
name|decode_header_bq
argument_list|(
name|it
argument_list|,
name|itsize
argument_list|)
condition|)
return|return;
comment|/* otherwise "it" is a straight copy of the input. 	 * This can be binary guck but there is no charset specified. 	 */
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|it
argument_list|,
name|itsize
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decode_transfer_encoding
specifier|static
name|int
name|decode_transfer_encoding
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|linesize
parameter_list|,
name|int
name|inputlen
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
switch|switch
condition|(
name|transfer_encoding
condition|)
block|{
case|case
name|TE_QP
case|:
name|ep
operator|=
name|line
operator|+
name|inputlen
expr_stmt|;
return|return
name|decode_q_segment
argument_list|(
name|line
argument_list|,
name|line
argument_list|,
name|linesize
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|TE_BASE64
case|:
name|ep
operator|=
name|line
operator|+
name|inputlen
expr_stmt|;
return|return
name|decode_b_segment
argument_list|(
name|line
argument_list|,
name|line
argument_list|,
name|linesize
argument_list|,
name|ep
argument_list|)
return|;
case|case
name|TE_DONTCARE
case|:
default|default:
return|return
name|inputlen
return|;
block|}
block|}
end_function
begin_function_decl
specifier|static
name|int
name|handle_filter
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|linesize
parameter_list|,
name|int
name|linelen
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|find_boundary
specifier|static
name|int
name|find_boundary
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|is_multipart_boundary
argument_list|(
name|line
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_boundary
specifier|static
name|int
name|handle_boundary
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|newline
index|[]
init|=
literal|"\n"
decl_stmt|;
name|again
label|:
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
operator|+
name|content_top
operator|->
name|boundary_len
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* we hit an end boundary */
comment|/* pop the current boundary off the stack */
name|free
argument_list|(
name|content_top
operator|->
name|boundary
argument_list|)
expr_stmt|;
comment|/* technically won't happen as is_multipart_boundary() 		   will fail first.  But just in case.. 		 */
if|if
condition|(
name|content_top
operator|--
operator|<
name|content
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Detected mismatched boundaries, "
literal|"can't recover\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|handle_filter
argument_list|(
name|newline
argument_list|,
sizeof|sizeof
argument_list|(
name|newline
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|newline
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip to the next boundary */
if|if
condition|(
operator|!
name|find_boundary
argument_list|()
condition|)
return|return
literal|0
return|;
goto|goto
name|again
goto|;
block|}
comment|/* set some defaults */
name|transfer_encoding
operator|=
name|TE_DONTCARE
expr_stmt|;
name|charset
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|message_type
operator|=
name|TYPE_TEXT
expr_stmt|;
comment|/* slurp in this section's info */
while|while
condition|(
name|read_one_header_line
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
condition|)
name|check_header
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|p_hdr_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* eat the blank line after section info */
return|return
operator|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function
begin_function
DECL|function|patchbreak
specifier|static
specifier|inline
name|int
name|patchbreak
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* Beginning of a "diff -" header? */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"diff -"
argument_list|,
name|line
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* CVS "Index: " line? */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"Index: "
argument_list|,
name|line
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* 	 * "---<filename>" starts patches without headers 	 * "---<sp>*" is a manual separator 	 */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"---"
argument_list|,
name|line
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|line
operator|+=
literal|3
expr_stmt|;
comment|/* space followed by a filename? */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|' '
operator|&&
operator|!
name|isspace
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Just whitespace? */
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|line
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_commit_msg
specifier|static
name|int
name|handle_commit_msg
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|linesize
parameter_list|)
block|{
specifier|static
name|int
name|still_looking
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|endline
init|=
name|line
operator|+
name|linesize
decl_stmt|;
if|if
condition|(
operator|!
name|cmitmsg
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|still_looking
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|line
decl_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|still_looking
operator|=
name|check_header
argument_list|(
name|cp
argument_list|,
name|endline
operator|-
name|cp
argument_list|,
name|s_hdr_data
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* normalize the log message to UTF-8. */
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|line
argument_list|,
name|endline
operator|-
name|line
argument_list|,
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
name|patchbreak
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|cmitmsg
argument_list|)
expr_stmt|;
name|cmitmsg
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fputs
argument_list|(
name|line
argument_list|,
name|cmitmsg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_patch
specifier|static
name|int
name|handle_patch
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|fwrite
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|patchfile
argument_list|)
expr_stmt|;
name|patch_lines
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_filter
specifier|static
name|int
name|handle_filter
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|linesize
parameter_list|,
name|int
name|linelen
parameter_list|)
block|{
specifier|static
name|int
name|filter
init|=
literal|0
decl_stmt|;
comment|/* filter tells us which part we left off on 	 * a non-zero return indicates we hit a filter point 	 */
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|handle_commit_msg
argument_list|(
name|line
argument_list|,
name|linesize
argument_list|)
condition|)
break|break;
name|filter
operator|++
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|handle_patch
argument_list|(
name|line
argument_list|,
name|linelen
argument_list|)
condition|)
break|break;
name|filter
operator|++
expr_stmt|;
default|default:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_body
specifier|static
name|void
name|handle_body
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|newline
index|[
literal|2000
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|np
init|=
name|newline
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
comment|/* Skip up to the first boundary */
if|if
condition|(
name|content_top
operator|->
name|boundary
condition|)
block|{
if|if
condition|(
operator|!
name|find_boundary
argument_list|()
condition|)
return|return;
block|}
do|do
block|{
comment|/* process any boundary lines */
if|if
condition|(
name|content_top
operator|->
name|boundary
operator|&&
name|is_multipart_boundary
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* flush any leftover */
if|if
condition|(
name|np
operator|!=
name|newline
condition|)
name|handle_filter
argument_list|(
name|newline
argument_list|,
sizeof|sizeof
argument_list|(
name|newline
argument_list|)
argument_list|,
name|np
operator|-
name|newline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle_boundary
argument_list|()
condition|)
return|return;
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* Unwrap transfer encoding */
name|len
operator|=
name|decode_transfer_encoding
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Malformed input line"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|transfer_encoding
condition|)
block|{
case|case
name|TE_BASE64
case|:
case|case
name|TE_QP
case|:
block|{
name|char
modifier|*
name|op
init|=
name|line
decl_stmt|;
comment|/* binary data most likely doesn't have newlines */
if|if
condition|(
name|message_type
operator|!=
name|TYPE_TEXT
condition|)
block|{
name|rc
operator|=
name|handle_filter
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * This is a decoded line that may contain 			 * multiple new lines.  Pass only one chunk 			 * at a time to handle_filter() 			 */
do|do
block|{
while|while
condition|(
name|op
operator|<
name|line
operator|+
name|len
operator|&&
operator|*
name|op
operator|!=
literal|'\n'
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|op
operator|++
expr_stmt|;
operator|*
name|np
operator|=
operator|*
name|op
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|!=
literal|0
condition|)
block|{
comment|/* should be sitting on a new line */
operator|*
operator|(
operator|++
name|np
operator|)
operator|=
literal|0
expr_stmt|;
name|op
operator|++
expr_stmt|;
name|rc
operator|=
name|handle_filter
argument_list|(
name|newline
argument_list|,
sizeof|sizeof
argument_list|(
name|newline
argument_list|)
argument_list|,
name|np
operator|-
name|newline
argument_list|)
expr_stmt|;
name|np
operator|=
name|newline
expr_stmt|;
block|}
block|}
do|while
condition|(
name|op
operator|<
name|line
operator|+
name|len
condition|)
do|;
comment|/* 			 * The partial chunk is saved in newline and will be 			 * appended by the next iteration of read_line_with_nul(). 			 */
break|break;
block|}
default|default:
name|rc
operator|=
name|handle_filter
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
comment|/* nothing left to filter */
break|break;
block|}
do|while
condition|(
operator|(
name|len
operator|=
name|read_line_with_nul
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|)
condition|)
do|;
return|return;
block|}
end_function
begin_function
DECL|function|output_header_lines
specifier|static
name|void
name|output_header_lines
parameter_list|(
name|FILE
modifier|*
name|fout
parameter_list|,
specifier|const
name|char
modifier|*
name|hdr
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|ep
init|=
name|strchr
argument_list|(
name|data
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|ep
operator|-
name|data
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s: %.*s\n"
argument_list|,
name|hdr
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
break|break;
name|data
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handle_info
specifier|static
name|void
name|handle_info
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|sub
decl_stmt|;
name|char
modifier|*
name|hdr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* only print inbody headers if we output a patch file */
if|if
condition|(
name|patch_lines
operator|&&
name|s_hdr_data
index|[
name|i
index|]
condition|)
name|hdr
operator|=
name|s_hdr_data
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|p_hdr_data
index|[
name|i
index|]
condition|)
name|hdr
operator|=
name|p_hdr_data
index|[
name|i
index|]
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|header
index|[
name|i
index|]
argument_list|,
literal|"Subject"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
name|keep_subject
condition|)
name|sub
operator|=
name|hdr
expr_stmt|;
else|else
block|{
name|sub
operator|=
name|cleanup_subject
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|cleanup_space
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
name|output_header_lines
argument_list|(
name|fout
argument_list|,
literal|"Subject"
argument_list|,
name|sub
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|header
index|[
name|i
index|]
argument_list|,
literal|"From"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|handle_from
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"Author: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"Email: %s\n"
argument_list|,
name|email
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cleanup_space
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|header
index|[
name|i
index|]
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mailinfo
specifier|static
name|int
name|mailinfo
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|,
name|int
name|ks
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|patch
parameter_list|)
block|{
name|int
name|peek
decl_stmt|;
name|keep_subject
operator|=
name|ks
expr_stmt|;
name|metainfo_charset
operator|=
name|encoding
expr_stmt|;
name|fin
operator|=
name|in
expr_stmt|;
name|fout
operator|=
name|out
expr_stmt|;
name|cmitmsg
operator|=
name|fopen
argument_list|(
name|msg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmitmsg
condition|)
block|{
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|patchfile
operator|=
name|fopen
argument_list|(
name|patch
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patchfile
condition|)
block|{
name|perror
argument_list|(
name|patch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|cmitmsg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_hdr_data
operator|=
name|xcalloc
argument_list|(
name|MAX_HDR_PARSED
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|s_hdr_data
operator|=
name|xcalloc
argument_list|(
name|MAX_HDR_PARSED
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|peek
operator|=
name|fgetc
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|peek
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|peek
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* process the email header */
while|while
condition|(
name|read_one_header_line
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
condition|)
name|check_header
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|p_hdr_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handle_body
argument_list|()
expr_stmt|;
name|handle_info
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|mailinfo_usage
specifier|static
specifier|const
name|char
name|mailinfo_usage
index|[]
init|=
literal|"git-mailinfo [-k] [-u | --encoding=<encoding>] msg patch<mail>info"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cmd_mailinfo
name|int
name|cmd_mailinfo
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|def_charset
decl_stmt|;
comment|/* NEEDSWORK: might want to do the optional .git/ directory 	 * discovery 	 */
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|def_charset
operator|=
operator|(
name|git_commit_encoding
condition|?
name|git_commit_encoding
else|:
literal|"utf-8"
operator|)
expr_stmt|;
name|metainfo_charset
operator|=
name|def_charset
expr_stmt|;
while|while
condition|(
literal|1
operator|<
name|argc
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-k"
argument_list|)
condition|)
name|keep_subject
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-u"
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|def_charset
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--encoding="
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|11
expr_stmt|;
else|else
name|usage
argument_list|(
name|mailinfo_usage
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|usage
argument_list|(
name|mailinfo_usage
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|mailinfo
argument_list|(
name|stdin
argument_list|,
name|stdout
argument_list|,
name|keep_subject
argument_list|,
name|metainfo_charset
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
return|;
block|}
end_function
end_unit
