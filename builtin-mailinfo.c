begin_unit
begin_comment
comment|/*  * Another stupid program, this one parsing the headers of an  * email to figure out authorship and subject  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_decl_stmt
DECL|variable|cmitmsg
DECL|variable|patchfile
DECL|variable|fin
DECL|variable|fout
specifier|static
name|FILE
modifier|*
name|cmitmsg
decl_stmt|,
modifier|*
name|patchfile
decl_stmt|,
modifier|*
name|fin
decl_stmt|,
modifier|*
name|fout
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keep_subject
specifier|static
name|int
name|keep_subject
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|metainfo_charset
specifier|static
specifier|const
name|char
modifier|*
name|metainfo_charset
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|line
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|date
specifier|static
name|char
name|date
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|name
specifier|static
name|char
name|name
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|email
specifier|static
name|char
name|email
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|subject
specifier|static
name|char
name|subject
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|TE_DONTCARE
DECL|enumerator|TE_QP
DECL|enumerator|TE_BASE64
name|TE_DONTCARE
block|,
name|TE_QP
block|,
name|TE_BASE64
block|, }
DECL|variable|transfer_encoding
name|transfer_encoding
enum|;
end_enum
begin_decl_stmt
DECL|variable|charset
specifier|static
name|char
name|charset
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|multipart_boundary
specifier|static
name|char
name|multipart_boundary
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|multipart_boundary_len
specifier|static
name|int
name|multipart_boundary_len
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|patch_lines
specifier|static
name|int
name|patch_lines
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|sanity_check
specifier|static
name|char
modifier|*
name|sanity_check
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|email
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
operator|||
name|len
operator|>
literal|60
condition|)
return|return
name|email
return|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
literal|'<'
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
literal|'>'
argument_list|)
condition|)
return|return
name|email
return|;
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|bogus_from
specifier|static
name|int
name|bogus_from
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* John Doe<johndoe> */
name|char
modifier|*
name|bra
decl_stmt|,
modifier|*
name|ket
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* This is fallback, so do not bother if we already have an 	 * e-mail address. 	 */
if|if
condition|(
operator|*
name|email
condition|)
return|return
literal|0
return|;
name|bra
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bra
condition|)
return|return
literal|0
return|;
name|ket
operator|=
name|strchr
argument_list|(
name|bra
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ket
condition|)
return|return
literal|0
return|;
for|for
control|(
name|dst
operator|=
name|email
operator|,
name|cp
operator|=
name|bra
operator|+
literal|1
init|;
name|cp
operator|<
name|ket
condition|;
control|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|line
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
for|for
control|(
name|bra
operator|--
init|;
name|isspace
argument_list|(
operator|*
name|bra
argument_list|)
condition|;
name|bra
operator|--
control|)
operator|*
name|bra
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|sanity_check
argument_list|(
name|cp
argument_list|,
name|email
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|handle_from
specifier|static
name|int
name|handle_from
parameter_list|(
name|char
modifier|*
name|in_line
parameter_list|)
block|{
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|in_line
argument_list|)
expr_stmt|;
name|at
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|at
condition|)
return|return
name|bogus_from
argument_list|(
name|line
argument_list|)
return|;
comment|/* 	 * If we already have one email, don't take any confusing lines 	 */
if|if
condition|(
operator|*
name|email
operator|&&
name|strchr
argument_list|(
name|at
operator|+
literal|1
argument_list|,
literal|'@'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Pick up the string around '@', possibly delimited with<> 	 * pair; that is the email part.  White them out while copying. 	 */
while|while
condition|(
name|at
operator|>
name|line
condition|)
block|{
name|char
name|c
init|=
name|at
index|[
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|at
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
name|at
operator|--
expr_stmt|;
block|}
name|dst
operator|=
name|email
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
name|c
operator|==
literal|'>'
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
operator|*
name|at
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
operator|*
name|at
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dst
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* The remainder is name.  It could be "John Doe<john.doe@xz>" 	 * or "john.doe@xz (John Doe)", but we have whited out the 	 * email part, so trim from both ends, possibly removing 	 * the () pair at the end. 	 */
name|at
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|at
operator|>
name|line
condition|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
operator|--
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|at
index|[
operator|(
name|c
operator|==
literal|')'
operator|)
condition|?
literal|0
else|:
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|at
operator|=
name|line
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|at
operator|++
expr_stmt|;
break|break;
block|}
name|at
operator|++
expr_stmt|;
block|}
name|at
operator|=
name|sanity_check
argument_list|(
name|at
argument_list|,
name|email
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|handle_date
specifier|static
name|int
name|handle_date
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|strcpy
argument_list|(
name|date
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_subject
specifier|static
name|int
name|handle_subject
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|strcpy
argument_list|(
name|subject
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* NOTE NOTE NOTE.  We do not claim we do full MIME.  We just attempt  * to have enough heuristics to grok MIME encoded patches often found  * on our mailing lists.  For example, we do not even treat header lines  * case insensitively.  */
end_comment
begin_function
DECL|function|slurp_attr
specifier|static
name|int
name|slurp_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ends
decl_stmt|,
modifier|*
name|ap
init|=
name|strcasestr
argument_list|(
name|line
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
block|{
operator|*
name|attr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ap
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'"'
condition|)
block|{
name|ap
operator|++
expr_stmt|;
name|ends
operator|=
literal|"\""
expr_stmt|;
block|}
else|else
name|ends
operator|=
literal|"; \t"
expr_stmt|;
name|sz
operator|=
name|strcspn
argument_list|(
name|ap
argument_list|,
name|ends
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|attr
argument_list|,
name|ap
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|attr
index|[
name|sz
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|handle_subcontent_type
specifier|static
name|int
name|handle_subcontent_type
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* We do not want to mess with boundary.  Note that we do not 	 * handle nested multipart. 	 */
if|if
condition|(
name|strcasestr
argument_list|(
name|line
argument_list|,
literal|"boundary="
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not handling nested multipart message.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|slurp_attr
argument_list|(
name|line
argument_list|,
literal|"charset="
argument_list|,
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|charset
condition|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|charset
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|charset
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_content_type
specifier|static
name|int
name|handle_content_type
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
operator|*
name|multipart_boundary
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|slurp_attr
argument_list|(
name|line
argument_list|,
literal|"boundary="
argument_list|,
name|multipart_boundary
operator|+
literal|2
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|multipart_boundary
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|multipart_boundary_len
operator|=
name|strlen
argument_list|(
name|multipart_boundary
argument_list|)
expr_stmt|;
block|}
name|slurp_attr
argument_list|(
name|line
argument_list|,
literal|"charset="
argument_list|,
name|charset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_content_transfer_encoding
specifier|static
name|int
name|handle_content_transfer_encoding
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
name|strcasestr
argument_list|(
name|line
argument_list|,
literal|"base64"
argument_list|)
condition|)
name|transfer_encoding
operator|=
name|TE_BASE64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasestr
argument_list|(
name|line
argument_list|,
literal|"quoted-printable"
argument_list|)
condition|)
name|transfer_encoding
operator|=
name|TE_QP
expr_stmt|;
else|else
name|transfer_encoding
operator|=
name|TE_DONTCARE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_multipart_boundary
specifier|static
name|int
name|is_multipart_boundary
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
return|return
operator|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
name|multipart_boundary
argument_list|,
name|multipart_boundary_len
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|eatspace
specifier|static
name|int
name|eatspace
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_define
DECL|macro|SEEN_FROM
define|#
directive|define
name|SEEN_FROM
value|01
end_define
begin_define
DECL|macro|SEEN_DATE
define|#
directive|define
name|SEEN_DATE
value|02
end_define
begin_define
DECL|macro|SEEN_SUBJECT
define|#
directive|define
name|SEEN_SUBJECT
value|04
end_define
begin_define
DECL|macro|SEEN_BOGUS_UNIX_FROM
define|#
directive|define
name|SEEN_BOGUS_UNIX_FROM
value|010
end_define
begin_define
DECL|macro|SEEN_PREFIX
define|#
directive|define
name|SEEN_PREFIX
value|020
end_define
begin_comment
comment|/* First lines of body can have From:, Date:, and Subject: or empty */
end_comment
begin_function
DECL|function|handle_inbody_header
specifier|static
name|void
name|handle_inbody_header
parameter_list|(
name|int
modifier|*
name|seen
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
operator|*
name|seen
operator|&
name|SEEN_PREFIX
condition|)
return|return;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|">From"
argument_list|,
name|line
argument_list|,
literal|5
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|seen
operator|&
name|SEEN_BOGUS_UNIX_FROM
operator|)
condition|)
block|{
operator|*
name|seen
operator||=
name|SEEN_BOGUS_UNIX_FROM
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"From:"
argument_list|,
name|line
argument_list|,
literal|5
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|seen
operator|&
name|SEEN_FROM
operator|)
operator|&&
name|handle_from
argument_list|(
name|line
operator|+
literal|6
argument_list|)
condition|)
block|{
operator|*
name|seen
operator||=
name|SEEN_FROM
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"Date:"
argument_list|,
name|line
argument_list|,
literal|5
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|seen
operator|&
name|SEEN_DATE
operator|)
condition|)
block|{
name|handle_date
argument_list|(
name|line
operator|+
literal|6
argument_list|)
expr_stmt|;
operator|*
name|seen
operator||=
name|SEEN_DATE
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"Subject:"
argument_list|,
name|line
argument_list|,
literal|8
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|8
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|seen
operator|&
name|SEEN_SUBJECT
operator|)
condition|)
block|{
name|handle_subject
argument_list|(
name|line
operator|+
literal|9
argument_list|)
expr_stmt|;
operator|*
name|seen
operator||=
name|SEEN_SUBJECT
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"[PATCH]"
argument_list|,
name|line
argument_list|,
literal|7
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|7
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|seen
operator|&
name|SEEN_SUBJECT
operator|)
condition|)
block|{
name|handle_subject
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|*
name|seen
operator||=
name|SEEN_SUBJECT
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|seen
operator||=
name|SEEN_PREFIX
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanup_subject
specifier|static
name|char
modifier|*
name|cleanup_subject
parameter_list|(
name|char
modifier|*
name|subject
parameter_list|)
block|{
if|if
condition|(
name|keep_subject
condition|)
return|return
name|subject
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|,
name|remove
decl_stmt|;
switch|switch
condition|(
operator|*
name|subject
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"e:"
argument_list|,
name|subject
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|subject
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|':'
case|:
name|subject
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
name|p
operator|=
name|strchr
argument_list|(
name|subject
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|subject
operator|++
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|remove
operator|=
name|p
operator|-
name|subject
expr_stmt|;
if|if
condition|(
name|remove
operator|<=
name|len
operator|*
literal|2
condition|)
block|{
name|subject
operator|=
name|p
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|eatspace
argument_list|(
name|subject
argument_list|)
expr_stmt|;
return|return
name|subject
return|;
block|}
block|}
end_function
begin_function
DECL|function|cleanup_space
specifier|static
name|void
name|cleanup_space
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|buf
operator|)
operator|!=
literal|0
condition|)
block|{
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|buf
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|c
operator|=
operator|*
name|buf
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|memmove
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|buf
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|decode_header
parameter_list|(
name|char
modifier|*
name|it
parameter_list|)
function_decl|;
end_function_decl
begin_typedef
DECL|typedef|header_fn_t
typedef|typedef
name|int
function_decl|(
modifier|*
name|header_fn_t
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_struct
DECL|struct|header_def
struct|struct
name|header_def
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|func
name|header_fn_t
name|func
decl_stmt|;
DECL|member|namelen
name|int
name|namelen
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|check_header
specifier|static
name|void
name|check_header
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|header_def
modifier|*
name|header
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|header
index|[
literal|0
index|]
operator|.
name|namelen
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|header
index|[
name|i
index|]
operator|.
name|namelen
operator|=
name|strlen
argument_list|(
name|header
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|header
index|[
name|i
index|]
operator|.
name|namelen
decl_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|line
argument_list|,
name|header
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|&&
name|line
index|[
name|len
index|]
operator|==
literal|':'
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Unwrap inline B and Q encoding, and optionally 			 * normalize the meta information to utf8. 			 */
name|decode_header
argument_list|(
name|line
operator|+
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|header
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|line
operator|+
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|check_subheader_line
specifier|static
name|void
name|check_subheader_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
specifier|static
name|struct
name|header_def
name|header
index|[]
init|=
block|{
block|{
literal|"Content-Type"
block|,
name|handle_subcontent_type
block|}
block|,
block|{
literal|"Content-Transfer-Encoding"
block|,
name|handle_content_transfer_encoding
block|}
block|,
block|{
name|NULL
block|}
block|, 	}
decl_stmt|;
name|check_header
argument_list|(
name|line
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_header_line
specifier|static
name|void
name|check_header_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
specifier|static
name|struct
name|header_def
name|header
index|[]
init|=
block|{
block|{
literal|"From"
block|,
name|handle_from
block|}
block|,
block|{
literal|"Date"
block|,
name|handle_date
block|}
block|,
block|{
literal|"Subject"
block|,
name|handle_subject
block|}
block|,
block|{
literal|"Content-Type"
block|,
name|handle_content_type
block|}
block|,
block|{
literal|"Content-Transfer-Encoding"
block|,
name|handle_content_transfer_encoding
block|}
block|,
block|{
name|NULL
block|}
block|, 	}
decl_stmt|;
name|check_header
argument_list|(
name|line
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|is_rfc2822_header
specifier|static
name|int
name|is_rfc2822_header
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* 	 * The section that defines the loosest possible 	 * field name is "3.6.8 Optional fields". 	 * 	 * optional-field = field-name ":" unstructured CRLF 	 * field-name = 1*ftext 	 * ftext = %d33-57 / %59-126 	 */
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
return|return
name|cp
operator|!=
name|line
return|;
if|if
condition|(
operator|(
literal|33
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|57
operator|)
operator|||
operator|(
literal|59
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|126
operator|)
condition|)
continue|continue;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_one_header_line
specifier|static
name|int
name|read_one_header_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|sz
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|int
name|ofs
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ofs
operator|<
name|sz
condition|)
block|{
name|int
name|peek
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
operator|+
name|ofs
argument_list|,
name|sz
operator|-
name|ofs
argument_list|,
name|in
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|len
operator|=
name|eatspace
argument_list|(
name|line
operator|+
name|ofs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|!
name|is_rfc2822_header
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* Re-add the newline */
name|line
index|[
name|ofs
operator|+
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|line
index|[
name|ofs
operator|+
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|ofs
operator|+=
name|len
expr_stmt|;
comment|/* Yuck, 2822 header "folding" */
name|peek
operator|=
name|fgetc
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|peek
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|!=
literal|' '
operator|&&
name|peek
operator|!=
literal|'\t'
condition|)
break|break;
block|}
comment|/* Count mbox From headers as headers */
if|if
condition|(
operator|!
name|ofs
operator|&&
operator|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|">From "
argument_list|,
literal|6
argument_list|)
operator|)
condition|)
name|ofs
operator|=
literal|1
expr_stmt|;
return|return
name|ofs
return|;
block|}
end_function
begin_function
DECL|function|decode_q_segment
specifier|static
name|int
name|decode_q_segment
parameter_list|(
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|ot
parameter_list|,
name|char
modifier|*
name|ep
parameter_list|,
name|int
name|rfc2047
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|in
operator|++
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|in
operator|<=
name|ep
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|int
name|d
init|=
operator|*
name|in
operator|++
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|'\n'
operator|||
operator|!
name|d
condition|)
break|break;
comment|/* drop trailing newline */
operator|*
name|ot
operator|++
operator|=
operator|(
operator|(
name|hexval
argument_list|(
name|d
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hexval
argument_list|(
operator|*
name|in
operator|++
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rfc2047
operator|&&
name|c
operator|==
literal|'_'
condition|)
comment|/* rfc2047 4.2 (2) */
name|c
operator|=
literal|0x20
expr_stmt|;
operator|*
name|ot
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|ot
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|decode_b_segment
specifier|static
name|int
name|decode_b_segment
parameter_list|(
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|ot
parameter_list|,
name|char
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Decode in..ep, possibly in-place to ot */
name|int
name|c
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|,
name|acc
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|in
operator|++
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|in
operator|<=
name|ep
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
literal|62
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|c
operator|=
literal|63
expr_stmt|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|-=
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|-=
literal|'a'
operator|-
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|c
operator|-=
literal|'0'
operator|-
literal|52
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
comment|/* padding is almost like (c == 0), except we do 			 * not output NUL resulting only from it; 			 * for now we just trust the data. 			 */
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* garbage */
switch|switch
condition|(
name|pos
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|acc
operator|=
operator|(
name|c
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|ot
operator|++
operator|=
operator|(
name|acc
operator||
operator|(
name|c
operator|>>
literal|4
operator|)
operator|)
expr_stmt|;
name|acc
operator|=
operator|(
name|c
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|ot
operator|++
operator|=
operator|(
name|acc
operator||
operator|(
name|c
operator|>>
literal|2
operator|)
operator|)
expr_stmt|;
name|acc
operator|=
operator|(
name|c
operator|&
literal|3
operator|)
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|ot
operator|++
operator|=
operator|(
name|acc
operator||
name|c
operator|)
expr_stmt|;
name|acc
operator|=
name|pos
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|ot
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|convert_to_utf8
specifier|static
name|void
name|convert_to_utf8
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|charset
parameter_list|)
block|{
specifier|static
name|char
name|latin_one
index|[]
init|=
literal|"latin1"
decl_stmt|;
name|char
modifier|*
name|input_charset
init|=
operator|*
name|charset
condition|?
name|charset
else|:
name|latin_one
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|reencode_string
argument_list|(
name|line
argument_list|,
name|metainfo_charset
argument_list|,
name|input_charset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
name|die
argument_list|(
literal|"cannot convert from %s to %s\n"
argument_list|,
name|input_charset
argument_list|,
name|metainfo_charset
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decode_header_bq
specifier|static
name|int
name|decode_header_bq
parameter_list|(
name|char
modifier|*
name|it
parameter_list|)
block|{
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|char
name|outbuf
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|rfc2047
init|=
literal|0
decl_stmt|;
name|in
operator|=
name|it
expr_stmt|;
name|out
operator|=
name|outbuf
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|=
name|strstr
argument_list|(
name|in
argument_list|,
literal|"=?"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|sz
decl_stmt|,
name|encoding
decl_stmt|;
name|char
name|charset_q
index|[
literal|256
index|]
decl_stmt|,
name|piecebuf
index|[
literal|256
index|]
decl_stmt|;
name|rfc2047
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|ep
condition|)
block|{
name|sz
operator|=
name|ep
operator|-
name|in
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|out
operator|+=
name|sz
expr_stmt|;
name|in
operator|+=
name|sz
expr_stmt|;
block|}
comment|/* E.g. 		 * ep : "=?iso-2022-jp?B?GyR...?= foo" 		 * ep : "=?ISO-8859-1?Q?Foo=FCbar?= baz" 		 */
name|ep
operator|+=
literal|2
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|ep
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|rfc2047
return|;
comment|/* no munging */
for|for
control|(
name|sp
operator|=
name|ep
init|;
name|sp
operator|<
name|cp
condition|;
name|sp
operator|++
control|)
name|charset_q
index|[
name|sp
operator|-
name|ep
index|]
operator|=
name|tolower
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
name|charset_q
index|[
name|cp
operator|-
name|ep
index|]
operator|=
literal|0
expr_stmt|;
name|encoding
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
operator|||
name|cp
index|[
literal|2
index|]
operator|!=
literal|'?'
condition|)
return|return
name|rfc2047
return|;
comment|/* no munging */
name|ep
operator|=
name|strstr
argument_list|(
name|cp
operator|+
literal|3
argument_list|,
literal|"?="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
return|return
name|rfc2047
return|;
comment|/* no munging */
switch|switch
condition|(
name|tolower
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
default|default:
return|return
name|rfc2047
return|;
comment|/* no munging */
case|case
literal|'b'
case|:
name|sz
operator|=
name|decode_b_segment
argument_list|(
name|cp
operator|+
literal|3
argument_list|,
name|piecebuf
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|sz
operator|=
name|decode_q_segment
argument_list|(
name|cp
operator|+
literal|3
argument_list|,
name|piecebuf
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
return|return
name|rfc2047
return|;
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|piecebuf
argument_list|,
name|charset_q
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|out
argument_list|,
name|piecebuf
argument_list|)
expr_stmt|;
name|out
operator|+=
name|strlen
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|in
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|it
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
return|return
name|rfc2047
return|;
block|}
end_function
begin_function
DECL|function|decode_header
specifier|static
name|void
name|decode_header
parameter_list|(
name|char
modifier|*
name|it
parameter_list|)
block|{
if|if
condition|(
name|decode_header_bq
argument_list|(
name|it
argument_list|)
condition|)
return|return;
comment|/* otherwise "it" is a straight copy of the input. 	 * This can be binary guck but there is no charset specified. 	 */
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|it
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decode_transfer_encoding
specifier|static
name|void
name|decode_transfer_encoding
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
switch|switch
condition|(
name|transfer_encoding
condition|)
block|{
case|case
name|TE_QP
case|:
name|ep
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|decode_q_segment
argument_list|(
name|line
argument_list|,
name|line
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TE_BASE64
case|:
name|ep
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|decode_b_segment
argument_list|(
name|line
argument_list|,
name|line
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|TE_DONTCARE
case|:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|handle_info
specifier|static
name|void
name|handle_info
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|sub
decl_stmt|;
name|sub
operator|=
name|cleanup_subject
argument_list|(
name|subject
argument_list|)
expr_stmt|;
name|cleanup_space
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|cleanup_space
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|cleanup_space
argument_list|(
name|email
argument_list|)
expr_stmt|;
name|cleanup_space
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"Author: %s\nEmail: %s\nSubject: %s\nDate: %s\n\n"
argument_list|,
name|name
argument_list|,
name|email
argument_list|,
name|sub
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* We are inside message body and have read line[] already.  * Spit out the commit log.  */
end_comment
begin_function
DECL|function|handle_commit_msg
specifier|static
name|int
name|handle_commit_msg
parameter_list|(
name|int
modifier|*
name|seen
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cmitmsg
condition|)
return|return
literal|0
return|;
do|do
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"diff -"
argument_list|,
name|line
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|memcmp
argument_list|(
literal|"---"
argument_list|,
name|line
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|memcmp
argument_list|(
literal|"Index: "
argument_list|,
name|line
argument_list|,
literal|7
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|multipart_boundary
index|[
literal|0
index|]
operator|&&
name|is_multipart_boundary
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
comment|/* We come here when the first part had only 			 * the commit message without any patch.  We 			 * pretend we have not seen this line yet, and 			 * go back to the loop. 			 */
return|return
literal|1
return|;
block|}
comment|/* Unwrap transfer encoding and optionally 		 * normalize the log message to UTF-8. 		 */
name|decode_transfer_encoding
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|line
argument_list|,
name|charset
argument_list|)
expr_stmt|;
name|handle_inbody_header
argument_list|(
name|seen
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|seen
operator|&
name|SEEN_PREFIX
operator|)
condition|)
continue|continue;
name|fputs
argument_list|(
name|line
argument_list|,
name|cmitmsg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
do|;
name|fclose
argument_list|(
name|cmitmsg
argument_list|)
expr_stmt|;
name|cmitmsg
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* We have done the commit message and have the first  * line of the patch in line[].  */
end_comment
begin_function
DECL|function|handle_patch
specifier|static
name|void
name|handle_patch
parameter_list|(
name|void
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|multipart_boundary
index|[
literal|0
index|]
operator|&&
name|is_multipart_boundary
argument_list|(
name|line
argument_list|)
condition|)
break|break;
comment|/* Only unwrap transfer encoding but otherwise do not 		 * do anything.  We do *NOT* want UTF-8 conversion 		 * here; we are dealing with the user payload. 		 */
name|decode_transfer_encoding
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|patchfile
argument_list|)
expr_stmt|;
name|patch_lines
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function
begin_comment
comment|/* multipart boundary and transfer encoding are set up for us, and we  * are at the end of the sub header.  do equivalent of handle_body up  * to the next boundary without closing patchfile --- we will expect  * that the first part to contain commit message and a patch, and  * handle other parts as pure patches.  */
end_comment
begin_function
DECL|function|handle_multipart_one_part
specifier|static
name|int
name|handle_multipart_one_part
parameter_list|(
name|int
modifier|*
name|seen
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|again
label|:
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|is_multipart_boundary
argument_list|(
name|line
argument_list|)
condition|)
break|break;
if|if
condition|(
name|handle_commit_msg
argument_list|(
name|seen
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|handle_patch
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_multipart_body
specifier|static
name|void
name|handle_multipart_body
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|seen
init|=
literal|0
decl_stmt|;
name|int
name|part_num
init|=
literal|0
decl_stmt|;
comment|/* Skip up to the first boundary */
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|is_multipart_boundary
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|part_num
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|part_num
condition|)
return|return;
comment|/* We are on boundary line.  Start slurping the subhead. */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|hdr
init|=
name|read_one_header_line
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hdr
condition|)
block|{
if|if
condition|(
name|handle_multipart_one_part
argument_list|(
operator|&
name|seen
argument_list|)
operator|<
literal|0
condition|)
return|return;
comment|/* Reset per part headers */
name|transfer_encoding
operator|=
name|TE_DONTCARE
expr_stmt|;
name|charset
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|check_subheader_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|patchfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patch_lines
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No patch found\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Non multipart message */
end_comment
begin_function
DECL|function|handle_body
specifier|static
name|void
name|handle_body
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|seen
init|=
literal|0
decl_stmt|;
name|handle_commit_msg
argument_list|(
operator|&
name|seen
argument_list|)
expr_stmt|;
name|handle_patch
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|patchfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patch_lines
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No patch found\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|mailinfo
name|int
name|mailinfo
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|,
name|int
name|ks
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|patch
parameter_list|)
block|{
name|keep_subject
operator|=
name|ks
expr_stmt|;
name|metainfo_charset
operator|=
name|encoding
expr_stmt|;
name|fin
operator|=
name|in
expr_stmt|;
name|fout
operator|=
name|out
expr_stmt|;
name|cmitmsg
operator|=
name|fopen
argument_list|(
name|msg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmitmsg
condition|)
block|{
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|patchfile
operator|=
name|fopen
argument_list|(
name|patch
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patchfile
condition|)
block|{
name|perror
argument_list|(
name|patch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|cmitmsg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|hdr
init|=
name|read_one_header_line
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fin
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hdr
condition|)
block|{
if|if
condition|(
name|multipart_boundary
index|[
literal|0
index|]
condition|)
name|handle_multipart_body
argument_list|()
expr_stmt|;
else|else
name|handle_body
argument_list|()
expr_stmt|;
name|handle_info
argument_list|()
expr_stmt|;
break|break;
block|}
name|check_header_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|mailinfo_usage
specifier|static
specifier|const
name|char
name|mailinfo_usage
index|[]
init|=
literal|"git-mailinfo [-k] [-u | --encoding=<encoding>] msg patch<mail>info"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cmd_mailinfo
name|int
name|cmd_mailinfo
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|def_charset
decl_stmt|;
comment|/* NEEDSWORK: might want to do the optional .git/ directory 	 * discovery 	 */
name|git_config
argument_list|(
name|git_default_config
argument_list|)
expr_stmt|;
name|def_charset
operator|=
operator|(
name|git_commit_encoding
condition|?
name|git_commit_encoding
else|:
literal|"utf-8"
operator|)
expr_stmt|;
name|metainfo_charset
operator|=
name|def_charset
expr_stmt|;
while|while
condition|(
literal|1
operator|<
name|argc
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-k"
argument_list|)
condition|)
name|keep_subject
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-u"
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|def_charset
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--encoding="
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|11
expr_stmt|;
else|else
name|usage
argument_list|(
name|mailinfo_usage
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|usage
argument_list|(
name|mailinfo_usage
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|mailinfo
argument_list|(
name|stdin
argument_list|,
name|stdout
argument_list|,
name|keep_subject
argument_list|,
name|metainfo_charset
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
return|;
block|}
end_function
end_unit
