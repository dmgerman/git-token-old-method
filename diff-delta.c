begin_unit
begin_comment
comment|/*  * diff-delta.c: generate a delta between two buffers  *  *  Many parts of this file have been lifted from LibXDiff version 0.10.  *  http://www.xmailserver.org/xdiff-lib.html  *  *  LibXDiff was written by Davide Libenzi<davidel@xmailserver.org>  *  Copyright (C) 2003	Davide Libenzi  *  *  Many mods for GIT usage by Nicolas Pitre<nico@cam.org>, (C) 2005.  *  *  This file is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public  *  License as published by the Free Software Foundation; either  *  version 2.1 of the License, or (at your option) any later version.  *  *  Use of this within git automatically means that the LGPL  *  licensing gets turned into GPLv2 within this project.  */
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|"delta.h"
end_include
begin_comment
comment|/* block size: min = 16, max = 64k, power of 2 */
end_comment
begin_define
DECL|macro|BLK_SIZE
define|#
directive|define
name|BLK_SIZE
value|16
end_define
begin_define
DECL|macro|MIN
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define
begin_define
DECL|macro|GR_PRIME
define|#
directive|define
name|GR_PRIME
value|0x9e370001
end_define
begin_define
DECL|macro|HASH
define|#
directive|define
name|HASH
parameter_list|(
name|v
parameter_list|,
name|b
parameter_list|)
value|(((unsigned int)(v) * GR_PRIME)>> (32 - (b)))
end_define
begin_comment
comment|/* largest prime smaller than 65536 */
end_comment
begin_define
DECL|macro|BASE
define|#
directive|define
name|BASE
value|65521
end_define
begin_comment
comment|/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1)<= 2^32-1 */
end_comment
begin_define
DECL|macro|NMAX
define|#
directive|define
name|NMAX
value|5552
end_define
begin_define
DECL|macro|DO1
define|#
directive|define
name|DO1
parameter_list|(
name|buf
parameter_list|,
name|i
parameter_list|)
value|{ s1 += buf[i]; s2 += s1; }
end_define
begin_define
DECL|macro|DO2
define|#
directive|define
name|DO2
parameter_list|(
name|buf
parameter_list|,
name|i
parameter_list|)
value|DO1(buf, i); DO1(buf, i + 1);
end_define
begin_define
DECL|macro|DO4
define|#
directive|define
name|DO4
parameter_list|(
name|buf
parameter_list|,
name|i
parameter_list|)
value|DO2(buf, i); DO2(buf, i + 2);
end_define
begin_define
DECL|macro|DO8
define|#
directive|define
name|DO8
parameter_list|(
name|buf
parameter_list|,
name|i
parameter_list|)
value|DO4(buf, i); DO4(buf, i + 4);
end_define
begin_define
DECL|macro|DO16
define|#
directive|define
name|DO16
parameter_list|(
name|buf
parameter_list|)
value|DO8(buf, 0); DO8(buf, 8);
end_define
begin_function
DECL|function|adler32
specifier|static
name|unsigned
name|int
name|adler32
parameter_list|(
name|unsigned
name|int
name|adler
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|unsigned
name|int
name|s1
init|=
name|adler
operator|&
literal|0xffff
decl_stmt|;
name|unsigned
name|int
name|s2
init|=
name|adler
operator|>>
literal|16
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|k
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|NMAX
argument_list|)
expr_stmt|;
name|len
operator|-=
name|k
expr_stmt|;
while|while
condition|(
name|k
operator|>=
literal|16
condition|)
block|{
name|DO16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|16
expr_stmt|;
name|k
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
do|do
block|{
name|s1
operator|+=
operator|*
name|buf
operator|++
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|k
condition|)
do|;
name|s1
operator|%=
name|BASE
expr_stmt|;
name|s2
operator|%=
name|BASE
expr_stmt|;
block|}
return|return
operator|(
name|s2
operator|<<
literal|16
operator|)
operator||
name|s1
return|;
block|}
end_function
begin_function
DECL|function|hashbits
specifier|static
name|unsigned
name|int
name|hashbits
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|int
name|val
init|=
literal|1
decl_stmt|,
name|bits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|val
operator|<
name|size
operator|&&
name|bits
operator|<
literal|32
condition|)
block|{
name|val
operator|<<=
literal|1
expr_stmt|;
name|bits
operator|++
expr_stmt|;
block|}
return|return
name|bits
condition|?
name|bits
else|:
literal|1
return|;
block|}
end_function
begin_typedef
DECL|struct|s_chanode
typedef|typedef
struct|struct
name|s_chanode
block|{
DECL|member|next
name|struct
name|s_chanode
modifier|*
name|next
decl_stmt|;
DECL|member|icurr
name|int
name|icurr
decl_stmt|;
block|}
DECL|typedef|chanode_t
name|chanode_t
typedef|;
end_typedef
begin_typedef
DECL|struct|s_chastore
typedef|typedef
struct|struct
name|s_chastore
block|{
DECL|member|head
DECL|member|tail
name|chanode_t
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
DECL|member|isize
DECL|member|nsize
name|int
name|isize
decl_stmt|,
name|nsize
decl_stmt|;
DECL|member|ancur
name|chanode_t
modifier|*
name|ancur
decl_stmt|;
DECL|member|sncur
name|chanode_t
modifier|*
name|sncur
decl_stmt|;
DECL|member|scurr
name|int
name|scurr
decl_stmt|;
block|}
DECL|typedef|chastore_t
name|chastore_t
typedef|;
end_typedef
begin_function
DECL|function|cha_init
specifier|static
name|void
name|cha_init
parameter_list|(
name|chastore_t
modifier|*
name|cha
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|icount
parameter_list|)
block|{
name|cha
operator|->
name|head
operator|=
name|cha
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
name|cha
operator|->
name|isize
operator|=
name|isize
expr_stmt|;
name|cha
operator|->
name|nsize
operator|=
name|icount
operator|*
name|isize
expr_stmt|;
name|cha
operator|->
name|ancur
operator|=
name|cha
operator|->
name|sncur
operator|=
name|NULL
expr_stmt|;
name|cha
operator|->
name|scurr
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cha_alloc
specifier|static
name|void
modifier|*
name|cha_alloc
parameter_list|(
name|chastore_t
modifier|*
name|cha
parameter_list|)
block|{
name|chanode_t
modifier|*
name|ancur
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|ancur
operator|=
name|cha
operator|->
name|ancur
expr_stmt|;
if|if
condition|(
operator|!
name|ancur
operator|||
name|ancur
operator|->
name|icurr
operator|==
name|cha
operator|->
name|nsize
condition|)
block|{
name|ancur
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|chanode_t
argument_list|)
operator|+
name|cha
operator|->
name|nsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ancur
condition|)
return|return
name|NULL
return|;
name|ancur
operator|->
name|icurr
operator|=
literal|0
expr_stmt|;
name|ancur
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cha
operator|->
name|tail
condition|)
name|cha
operator|->
name|tail
operator|->
name|next
operator|=
name|ancur
expr_stmt|;
if|if
condition|(
operator|!
name|cha
operator|->
name|head
condition|)
name|cha
operator|->
name|head
operator|=
name|ancur
expr_stmt|;
name|cha
operator|->
name|tail
operator|=
name|ancur
expr_stmt|;
name|cha
operator|->
name|ancur
operator|=
name|ancur
expr_stmt|;
block|}
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|ancur
operator|+
sizeof|sizeof
argument_list|(
name|chanode_t
argument_list|)
operator|+
name|ancur
operator|->
name|icurr
expr_stmt|;
name|ancur
operator|->
name|icurr
operator|+=
name|cha
operator|->
name|isize
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|cha_free
specifier|static
name|void
name|cha_free
parameter_list|(
name|chastore_t
modifier|*
name|cha
parameter_list|)
block|{
name|chanode_t
modifier|*
name|cur
init|=
name|cha
operator|->
name|head
decl_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|chanode_t
modifier|*
name|tmp
init|=
name|cur
decl_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_typedef
DECL|struct|s_bdrecord
typedef|typedef
struct|struct
name|s_bdrecord
block|{
DECL|member|next
name|struct
name|s_bdrecord
modifier|*
name|next
decl_stmt|;
DECL|member|fp
name|unsigned
name|int
name|fp
decl_stmt|;
DECL|member|ptr
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
block|}
DECL|typedef|bdrecord_t
name|bdrecord_t
typedef|;
end_typedef
begin_typedef
DECL|struct|s_bdfile
typedef|typedef
struct|struct
name|s_bdfile
block|{
DECL|member|data
DECL|member|top
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|top
decl_stmt|;
DECL|member|cha
name|chastore_t
name|cha
decl_stmt|;
DECL|member|fphbits
name|unsigned
name|int
name|fphbits
decl_stmt|;
DECL|member|fphash
name|bdrecord_t
modifier|*
modifier|*
name|fphash
decl_stmt|;
block|}
DECL|typedef|bdfile_t
name|bdfile_t
typedef|;
end_typedef
begin_function
DECL|function|delta_prepare
specifier|static
name|int
name|delta_prepare
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|bdfile_t
modifier|*
name|bdf
parameter_list|)
block|{
name|unsigned
name|int
name|fphbits
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hsize
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|bdrecord_t
modifier|*
name|brec
decl_stmt|;
name|bdrecord_t
modifier|*
modifier|*
name|fphash
decl_stmt|;
name|fphbits
operator|=
name|hashbits
argument_list|(
name|bufsize
operator|/
name|BLK_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hsize
operator|=
literal|1
operator|<<
name|fphbits
expr_stmt|;
name|fphash
operator|=
name|malloc
argument_list|(
name|hsize
operator|*
sizeof|sizeof
argument_list|(
name|bdrecord_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fphash
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hsize
condition|;
name|i
operator|++
control|)
name|fphash
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|cha_init
argument_list|(
operator|&
name|bdf
operator|->
name|cha
argument_list|,
sizeof|sizeof
argument_list|(
name|bdrecord_t
argument_list|)
argument_list|,
name|hsize
operator|/
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bdf
operator|->
name|data
operator|=
name|data
operator|=
name|base
operator|=
name|buf
expr_stmt|;
name|bdf
operator|->
name|top
operator|=
name|top
operator|=
name|buf
operator|+
name|bufsize
expr_stmt|;
name|data
operator|+=
operator|(
name|bufsize
operator|/
name|BLK_SIZE
operator|)
operator|*
name|BLK_SIZE
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|top
condition|)
name|data
operator|-=
name|BLK_SIZE
expr_stmt|;
for|for
control|(
init|;
name|data
operator|>=
name|base
condition|;
name|data
operator|-=
name|BLK_SIZE
control|)
block|{
name|brec
operator|=
name|cha_alloc
argument_list|(
operator|&
name|bdf
operator|->
name|cha
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|brec
condition|)
block|{
name|cha_free
argument_list|(
operator|&
name|bdf
operator|->
name|cha
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fphash
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|brec
operator|->
name|fp
operator|=
name|adler32
argument_list|(
literal|0
argument_list|,
name|data
argument_list|,
name|MIN
argument_list|(
name|BLK_SIZE
argument_list|,
name|top
operator|-
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|brec
operator|->
name|ptr
operator|=
name|data
expr_stmt|;
name|i
operator|=
name|HASH
argument_list|(
name|brec
operator|->
name|fp
argument_list|,
name|fphbits
argument_list|)
expr_stmt|;
name|brec
operator|->
name|next
operator|=
name|fphash
index|[
name|i
index|]
expr_stmt|;
name|fphash
index|[
name|i
index|]
operator|=
name|brec
expr_stmt|;
block|}
name|bdf
operator|->
name|fphbits
operator|=
name|fphbits
expr_stmt|;
name|bdf
operator|->
name|fphash
operator|=
name|fphash
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|delta_cleanup
specifier|static
name|void
name|delta_cleanup
parameter_list|(
name|bdfile_t
modifier|*
name|bdf
parameter_list|)
block|{
name|free
argument_list|(
name|bdf
operator|->
name|fphash
argument_list|)
expr_stmt|;
name|cha_free
argument_list|(
operator|&
name|bdf
operator|->
name|cha
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|COPYOP_SIZE
define|#
directive|define
name|COPYOP_SIZE
parameter_list|(
name|o
parameter_list|,
name|s
parameter_list|)
define|\
value|(!!(o& 0xff) + !!(o& 0xff00) + !!(o& 0xff0000) + !!(o& 0xff000000) + \      !!(s& 0xff) + !!(s& 0xff00) + 1)
end_define
begin_function
DECL|function|diff_delta
name|void
modifier|*
name|diff_delta
parameter_list|(
name|void
modifier|*
name|from_buf
parameter_list|,
name|unsigned
name|long
name|from_size
parameter_list|,
name|void
modifier|*
name|to_buf
parameter_list|,
name|unsigned
name|long
name|to_size
parameter_list|,
name|unsigned
name|long
modifier|*
name|delta_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|outpos
decl_stmt|,
name|outsize
decl_stmt|,
name|inscnt
decl_stmt|,
name|csize
decl_stmt|,
name|msize
decl_stmt|,
name|moff
decl_stmt|;
name|unsigned
name|int
name|fp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|orig
decl_stmt|;
name|bdrecord_t
modifier|*
name|brec
decl_stmt|;
name|bdfile_t
name|bdf
decl_stmt|;
if|if
condition|(
operator|!
name|from_size
operator|||
operator|!
name|to_size
operator|||
name|delta_prepare
argument_list|(
name|from_buf
argument_list|,
name|from_size
argument_list|,
operator|&
name|bdf
argument_list|)
condition|)
return|return
name|NULL
return|;
name|outpos
operator|=
literal|0
expr_stmt|;
name|outsize
operator|=
literal|8192
expr_stmt|;
name|out
operator|=
name|malloc
argument_list|(
name|outsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|delta_cleanup
argument_list|(
operator|&
name|bdf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|data
operator|=
name|to_buf
expr_stmt|;
name|top
operator|=
name|to_buf
operator|+
name|to_size
expr_stmt|;
comment|/* store reference buffer size */
name|orig
operator|=
name|out
operator|+
name|outpos
operator|++
expr_stmt|;
operator|*
name|orig
operator|=
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|from_size
operator|&
literal|0xff
condition|)
block|{
operator|*
name|orig
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|from_size
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|from_size
operator|>>=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|from_size
condition|)
do|;
comment|/* store target buffer size */
name|orig
operator|=
name|out
operator|+
name|outpos
operator|++
expr_stmt|;
operator|*
name|orig
operator|=
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|to_size
operator|&
literal|0xff
condition|)
block|{
operator|*
name|orig
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|to_size
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|to_size
operator|>>=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|to_size
condition|)
do|;
name|inscnt
operator|=
literal|0
expr_stmt|;
name|moff
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|top
condition|)
block|{
name|msize
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|adler32
argument_list|(
literal|0
argument_list|,
name|data
argument_list|,
name|MIN
argument_list|(
name|top
operator|-
name|data
argument_list|,
name|BLK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|HASH
argument_list|(
name|fp
argument_list|,
name|bdf
operator|.
name|fphbits
argument_list|)
expr_stmt|;
for|for
control|(
name|brec
operator|=
name|bdf
operator|.
name|fphash
index|[
name|i
index|]
init|;
name|brec
condition|;
name|brec
operator|=
name|brec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|brec
operator|->
name|fp
operator|==
name|fp
condition|)
block|{
name|csize
operator|=
name|bdf
operator|.
name|top
operator|-
name|brec
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|csize
operator|>
name|top
operator|-
name|data
condition|)
name|csize
operator|=
name|top
operator|-
name|data
expr_stmt|;
for|for
control|(
name|ptr1
operator|=
name|brec
operator|->
name|ptr
operator|,
name|ptr2
operator|=
name|data
init|;
name|csize
operator|&&
operator|*
name|ptr1
operator|==
operator|*
name|ptr2
condition|;
name|csize
operator|--
operator|,
name|ptr1
operator|++
operator|,
name|ptr2
operator|++
control|)
empty_stmt|;
name|csize
operator|=
name|ptr1
operator|-
name|brec
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|csize
operator|>
name|msize
condition|)
block|{
name|moff
operator|=
name|brec
operator|->
name|ptr
operator|-
name|bdf
operator|.
name|data
expr_stmt|;
name|msize
operator|=
name|csize
expr_stmt|;
if|if
condition|(
name|msize
operator|>=
literal|0x10000
condition|)
block|{
name|msize
operator|=
literal|0x10000
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|msize
operator|||
name|msize
operator|<
name|COPYOP_SIZE
argument_list|(
name|moff
argument_list|,
name|msize
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inscnt
condition|)
name|outpos
operator|++
expr_stmt|;
name|out
index|[
name|outpos
operator|++
index|]
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|inscnt
operator|++
expr_stmt|;
if|if
condition|(
name|inscnt
operator|==
literal|0x7f
condition|)
block|{
name|out
index|[
name|outpos
operator|-
name|inscnt
operator|-
literal|1
index|]
operator|=
name|inscnt
expr_stmt|;
name|inscnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|inscnt
condition|)
block|{
name|out
index|[
name|outpos
operator|-
name|inscnt
operator|-
literal|1
index|]
operator|=
name|inscnt
expr_stmt|;
name|inscnt
operator|=
literal|0
expr_stmt|;
block|}
name|data
operator|+=
name|msize
expr_stmt|;
name|orig
operator|=
name|out
operator|+
name|outpos
operator|++
expr_stmt|;
name|i
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|moff
operator|&
literal|0xff
condition|)
block|{
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|moff
expr_stmt|;
name|i
operator||=
literal|0x01
expr_stmt|;
block|}
name|moff
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|moff
operator|&
literal|0xff
condition|)
block|{
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|moff
expr_stmt|;
name|i
operator||=
literal|0x02
expr_stmt|;
block|}
name|moff
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|moff
operator|&
literal|0xff
condition|)
block|{
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|moff
expr_stmt|;
name|i
operator||=
literal|0x04
expr_stmt|;
block|}
name|moff
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|moff
operator|&
literal|0xff
condition|)
block|{
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|moff
expr_stmt|;
name|i
operator||=
literal|0x08
expr_stmt|;
block|}
if|if
condition|(
name|msize
operator|&
literal|0xff
condition|)
block|{
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|msize
expr_stmt|;
name|i
operator||=
literal|0x10
expr_stmt|;
block|}
name|msize
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|msize
operator|&
literal|0xff
condition|)
block|{
name|out
index|[
name|outpos
operator|++
index|]
operator|=
name|msize
expr_stmt|;
name|i
operator||=
literal|0x20
expr_stmt|;
block|}
operator|*
name|orig
operator|=
name|i
expr_stmt|;
block|}
comment|/* next time around the largest possible output is 1 + 4 + 3 */
if|if
condition|(
name|outpos
operator|>
name|outsize
operator|-
literal|8
condition|)
block|{
name|void
modifier|*
name|tmp
init|=
name|out
decl_stmt|;
name|outsize
operator|=
name|outsize
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
name|out
operator|=
name|realloc
argument_list|(
name|out
argument_list|,
name|outsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|delta_cleanup
argument_list|(
operator|&
name|bdf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
if|if
condition|(
name|inscnt
condition|)
name|out
index|[
name|outpos
operator|-
name|inscnt
operator|-
literal|1
index|]
operator|=
name|inscnt
expr_stmt|;
name|delta_cleanup
argument_list|(
operator|&
name|bdf
argument_list|)
expr_stmt|;
operator|*
name|delta_size
operator|=
name|outpos
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
end_unit
