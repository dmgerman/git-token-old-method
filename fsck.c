begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"fsck.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"sha1-array.h"
end_include
begin_define
DECL|macro|FSCK_FATAL
define|#
directive|define
name|FSCK_FATAL
value|-1
end_define
begin_define
DECL|macro|FSCK_INFO
define|#
directive|define
name|FSCK_INFO
value|-2
end_define
begin_define
DECL|macro|FOREACH_MSG_ID
define|#
directive|define
name|FOREACH_MSG_ID
parameter_list|(
name|FUNC
parameter_list|)
define|\
comment|/* fatal errors */
define|\
value|FUNC(NUL_IN_HEADER, FATAL) \ 	FUNC(UNTERMINATED_HEADER, FATAL) \
comment|/* errors */
value|\ 	FUNC(BAD_DATE, ERROR) \ 	FUNC(BAD_DATE_OVERFLOW, ERROR) \ 	FUNC(BAD_EMAIL, ERROR) \ 	FUNC(BAD_NAME, ERROR) \ 	FUNC(BAD_OBJECT_SHA1, ERROR) \ 	FUNC(BAD_PARENT_SHA1, ERROR) \ 	FUNC(BAD_TAG_OBJECT, ERROR) \ 	FUNC(BAD_TIMEZONE, ERROR) \ 	FUNC(BAD_TREE, ERROR) \ 	FUNC(BAD_TREE_SHA1, ERROR) \ 	FUNC(BAD_TYPE, ERROR) \ 	FUNC(DUPLICATE_ENTRIES, ERROR) \ 	FUNC(MISSING_AUTHOR, ERROR) \ 	FUNC(MISSING_COMMITTER, ERROR) \ 	FUNC(MISSING_EMAIL, ERROR) \ 	FUNC(MISSING_GRAFT, ERROR) \ 	FUNC(MISSING_NAME_BEFORE_EMAIL, ERROR) \ 	FUNC(MISSING_OBJECT, ERROR) \ 	FUNC(MISSING_PARENT, ERROR) \ 	FUNC(MISSING_SPACE_BEFORE_DATE, ERROR) \ 	FUNC(MISSING_SPACE_BEFORE_EMAIL, ERROR) \ 	FUNC(MISSING_TAG, ERROR) \ 	FUNC(MISSING_TAG_ENTRY, ERROR) \ 	FUNC(MISSING_TAG_OBJECT, ERROR) \ 	FUNC(MISSING_TREE, ERROR) \ 	FUNC(MISSING_TYPE, ERROR) \ 	FUNC(MISSING_TYPE_ENTRY, ERROR) \ 	FUNC(MULTIPLE_AUTHORS, ERROR) \ 	FUNC(TAG_OBJECT_NOT_TAG, ERROR) \ 	FUNC(TREE_NOT_SORTED, ERROR) \ 	FUNC(UNKNOWN_TYPE, ERROR) \ 	FUNC(ZERO_PADDED_DATE, ERROR) \
comment|/* warnings */
value|\ 	FUNC(BAD_FILEMODE, WARN) \ 	FUNC(EMPTY_NAME, WARN) \ 	FUNC(FULL_PATHNAME, WARN) \ 	FUNC(HAS_DOT, WARN) \ 	FUNC(HAS_DOTDOT, WARN) \ 	FUNC(HAS_DOTGIT, WARN) \ 	FUNC(NULL_SHA1, WARN) \ 	FUNC(ZERO_PADDED_FILEMODE, WARN) \
comment|/* infos (reported as warnings, but ignored by default) */
value|\ 	FUNC(BAD_TAG_NAME, INFO) \ 	FUNC(MISSING_TAGGER_ENTRY, INFO)
end_define
begin_define
DECL|macro|MSG_ID
define|#
directive|define
name|MSG_ID
parameter_list|(
name|id
parameter_list|,
name|msg_type
parameter_list|)
value|FSCK_MSG_##id,
end_define
begin_enum
DECL|enum|fsck_msg_id
enum|enum
name|fsck_msg_id
block|{
DECL|enumerator|FOREACH_MSG_ID
name|FOREACH_MSG_ID
argument_list|(
argument|MSG_ID
argument_list|)
name|FSCK_MSG_MAX
block|}
enum|;
end_enum
begin_undef
DECL|macro|MSG_ID
undef|#
directive|undef
name|MSG_ID
end_undef
begin_define
DECL|macro|STR
define|#
directive|define
name|STR
parameter_list|(
name|x
parameter_list|)
value|#x
end_define
begin_define
DECL|macro|MSG_ID
define|#
directive|define
name|MSG_ID
parameter_list|(
name|id
parameter_list|,
name|msg_type
parameter_list|)
value|{ STR(id), NULL, FSCK_##msg_type },
end_define
begin_struct
specifier|static
struct|struct
block|{
DECL|member|id_string
specifier|const
name|char
modifier|*
name|id_string
decl_stmt|;
DECL|member|downcased
specifier|const
name|char
modifier|*
name|downcased
decl_stmt|;
DECL|member|msg_type
name|int
name|msg_type
decl_stmt|;
block|}
DECL|variable|msg_id_info
name|msg_id_info
index|[
name|FSCK_MSG_MAX
operator|+
literal|1
index|]
init|=
block|{
name|FOREACH_MSG_ID
argument_list|(
argument|MSG_ID
argument_list|)
block|{
name|NULL
block|,
name|NULL
block|,
operator|-
literal|1
block|}
block|}
struct|;
end_struct
begin_undef
DECL|macro|MSG_ID
undef|#
directive|undef
name|MSG_ID
end_undef
begin_function
DECL|function|parse_msg_id
specifier|static
name|int
name|parse_msg_id
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|msg_id_info
index|[
literal|0
index|]
operator|.
name|downcased
condition|)
block|{
comment|/* convert id_string to lower case, without underscores. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FSCK_MSG_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|msg_id_info
index|[
name|i
index|]
operator|.
name|id_string
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|msg_id_info
index|[
name|i
index|]
operator|.
name|downcased
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
name|p
operator|++
expr_stmt|;
else|else
operator|*
operator|(
name|q
operator|)
operator|++
operator|=
name|tolower
argument_list|(
operator|*
operator|(
name|p
operator|)
operator|++
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FSCK_MSG_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|text
argument_list|,
name|msg_id_info
index|[
name|i
index|]
operator|.
name|downcased
argument_list|)
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fsck_msg_type
specifier|static
name|int
name|fsck_msg_type
parameter_list|(
name|enum
name|fsck_msg_id
name|msg_id
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
name|int
name|msg_type
decl_stmt|;
name|assert
argument_list|(
name|msg_id
operator|>=
literal|0
operator|&&
name|msg_id
operator|<
name|FSCK_MSG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|msg_type
condition|)
name|msg_type
operator|=
name|options
operator|->
name|msg_type
index|[
name|msg_id
index|]
expr_stmt|;
else|else
block|{
name|msg_type
operator|=
name|msg_id_info
index|[
name|msg_id
index|]
operator|.
name|msg_type
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|strict
operator|&&
name|msg_type
operator|==
name|FSCK_WARN
condition|)
name|msg_type
operator|=
name|FSCK_ERROR
expr_stmt|;
block|}
return|return
name|msg_type
return|;
block|}
end_function
begin_function
DECL|function|init_skiplist
specifier|static
name|void
name|init_skiplist
parameter_list|(
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
specifier|static
name|struct
name|sha1_array
name|skiplist
init|=
name|SHA1_ARRAY_INIT
decl_stmt|;
name|int
name|sorted
decl_stmt|,
name|fd
decl_stmt|;
name|char
name|buffer
index|[
literal|41
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|options
operator|->
name|skiplist
condition|)
name|sorted
operator|=
name|options
operator|->
name|skiplist
operator|->
name|sorted
expr_stmt|;
else|else
block|{
name|sorted
operator|=
literal|1
expr_stmt|;
name|options
operator|->
name|skiplist
operator|=
operator|&
name|skiplist
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Could not open skip list: %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|result
init|=
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"Could not read '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
break|break;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|'\n'
condition|)
name|die
argument_list|(
literal|"Invalid SHA-1: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|sha1_array_append
argument_list|(
operator|&
name|skiplist
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorted
operator|&&
name|skiplist
operator|.
name|nr
operator|>
literal|1
operator|&&
name|hashcmp
argument_list|(
name|skiplist
operator|.
name|sha1
index|[
name|skiplist
operator|.
name|nr
operator|-
literal|2
index|]
argument_list|,
name|sha1
argument_list|)
operator|>
literal|0
condition|)
name|sorted
operator|=
literal|0
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorted
condition|)
name|skiplist
operator|.
name|sorted
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_msg_type
specifier|static
name|int
name|parse_msg_type
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"error"
argument_list|)
condition|)
return|return
name|FSCK_ERROR
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"warn"
argument_list|)
condition|)
return|return
name|FSCK_WARN
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"ignore"
argument_list|)
condition|)
return|return
name|FSCK_IGNORE
return|;
else|else
name|die
argument_list|(
literal|"Unknown fsck message type: '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|is_valid_msg_type
name|int
name|is_valid_msg_type
parameter_list|(
specifier|const
name|char
modifier|*
name|msg_id
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_type
parameter_list|)
block|{
if|if
condition|(
name|parse_msg_id
argument_list|(
name|msg_id
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|parse_msg_type
argument_list|(
name|msg_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fsck_set_msg_type
name|void
name|fsck_set_msg_type
parameter_list|(
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_id
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_type
parameter_list|)
block|{
name|int
name|id
init|=
name|parse_msg_id
argument_list|(
name|msg_id
argument_list|)
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Unhandled message id: %s"
argument_list|,
name|msg_id
argument_list|)
expr_stmt|;
name|type
operator|=
name|parse_msg_type
argument_list|(
name|msg_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|FSCK_ERROR
operator|&&
name|msg_id_info
index|[
name|id
index|]
operator|.
name|msg_type
operator|==
name|FSCK_FATAL
condition|)
name|die
argument_list|(
literal|"Cannot demote %s to %s"
argument_list|,
name|msg_id
argument_list|,
name|msg_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|->
name|msg_type
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|msg_type
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|FSCK_MSG_MAX
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FSCK_MSG_MAX
condition|;
name|i
operator|++
control|)
name|msg_type
index|[
name|i
index|]
operator|=
name|fsck_msg_type
argument_list|(
name|i
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|options
operator|->
name|msg_type
operator|=
name|msg_type
expr_stmt|;
block|}
name|options
operator|->
name|msg_type
index|[
name|id
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fsck_set_msg_types
name|void
name|fsck_set_msg_types
parameter_list|(
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|,
specifier|const
name|char
modifier|*
name|values
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|xstrdup
argument_list|(
name|values
argument_list|)
decl_stmt|,
modifier|*
name|to_free
init|=
name|buf
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|int
name|len
init|=
name|strcspn
argument_list|(
name|buf
argument_list|,
literal|" ,|"
argument_list|)
decl_stmt|,
name|equal
decl_stmt|;
name|done
operator|=
operator|!
name|buf
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
name|buf
operator|++
expr_stmt|;
continue|continue;
block|}
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|equal
operator|=
literal|0
init|;
name|equal
operator|<
name|len
operator|&&
name|buf
index|[
name|equal
index|]
operator|!=
literal|'='
operator|&&
name|buf
index|[
name|equal
index|]
operator|!=
literal|':'
condition|;
name|equal
operator|++
control|)
name|buf
index|[
name|equal
index|]
operator|=
name|tolower
argument_list|(
name|buf
index|[
name|equal
index|]
argument_list|)
expr_stmt|;
name|buf
index|[
name|equal
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"skiplist"
argument_list|)
condition|)
block|{
if|if
condition|(
name|equal
operator|==
name|len
condition|)
name|die
argument_list|(
literal|"skiplist requires a path"
argument_list|)
expr_stmt|;
name|init_skiplist
argument_list|(
name|options
argument_list|,
name|buf
operator|+
name|equal
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|equal
operator|==
name|len
condition|)
name|die
argument_list|(
literal|"Missing '=': '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fsck_set_msg_type
argument_list|(
name|options
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
name|equal
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append_msg_id
specifier|static
name|void
name|append_msg_id
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_id
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
operator|(
name|msg_id
operator|)
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|'_'
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
operator|*
name|msg_id
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
operator|*
operator|(
name|msg_id
operator|)
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|__attribute__
argument_list|(
argument|(format (printf,
literal|4
argument|,
literal|5
argument|))
argument_list|)
end_macro
begin_function
DECL|function|report
specifier|static
name|int
name|report
parameter_list|(
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|,
name|struct
name|object
modifier|*
name|object
parameter_list|,
name|enum
name|fsck_msg_id
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|msg_type
init|=
name|fsck_msg_type
argument_list|(
name|id
argument_list|,
name|options
argument_list|)
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|msg_type
operator|==
name|FSCK_IGNORE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|options
operator|->
name|skiplist
operator|&&
name|object
operator|&&
name|sha1_array_lookup
argument_list|(
name|options
operator|->
name|skiplist
argument_list|,
name|get_object_hash
argument_list|(
operator|*
name|object
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|msg_type
operator|==
name|FSCK_FATAL
condition|)
name|msg_type
operator|=
name|FSCK_ERROR
expr_stmt|;
elseif|else
if|if
condition|(
name|msg_type
operator|==
name|FSCK_INFO
condition|)
name|msg_type
operator|=
name|FSCK_WARN
expr_stmt|;
name|append_msg_id
argument_list|(
operator|&
name|sb
argument_list|,
name|msg_id_info
index|[
name|id
index|]
operator|.
name|id_string
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|strbuf_vaddf
argument_list|(
operator|&
name|sb
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|result
operator|=
name|options
operator|->
name|error_func
argument_list|(
name|object
argument_list|,
name|msg_type
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fsck_walk_tree
specifier|static
name|int
name|fsck_walk_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
name|struct
name|tree_desc
name|desc
decl_stmt|;
name|struct
name|name_entry
name|entry
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parse_tree
argument_list|(
name|tree
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|init_tree_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tree_entry
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|entry
operator|.
name|mode
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|entry
operator|.
name|mode
argument_list|)
condition|)
name|result
operator|=
name|options
operator|->
name|walk
argument_list|(
operator|&
name|lookup_tree
argument_list|(
name|entry
operator|.
name|sha1
argument_list|)
operator|->
name|object
argument_list|,
name|OBJ_TREE
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|entry
operator|.
name|mode
argument_list|)
operator|||
name|S_ISLNK
argument_list|(
name|entry
operator|.
name|mode
argument_list|)
condition|)
name|result
operator|=
name|options
operator|->
name|walk
argument_list|(
operator|&
name|lookup_blob
argument_list|(
name|entry
operator|.
name|sha1
argument_list|)
operator|->
name|object
argument_list|,
name|OBJ_BLOB
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|=
name|error
argument_list|(
literal|"in tree %s: entry %s has bad mode %.6o"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|entry
operator|.
name|path
argument_list|,
name|entry
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
name|res
condition|)
name|res
operator|=
name|result
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|fsck_walk_commit
specifier|static
name|int
name|fsck_walk_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|result
operator|=
name|options
operator|->
name|walk
argument_list|(
operator|(
expr|struct
name|object
operator|*
operator|)
name|commit
operator|->
name|tree
argument_list|,
name|OBJ_TREE
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|result
return|;
name|res
operator|=
name|result
expr_stmt|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|result
operator|=
name|options
operator|->
name|walk
argument_list|(
operator|(
expr|struct
name|object
operator|*
operator|)
name|parents
operator|->
name|item
argument_list|,
name|OBJ_COMMIT
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
name|res
condition|)
name|res
operator|=
name|result
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|fsck_walk_tag
specifier|static
name|int
name|fsck_walk_tag
parameter_list|(
name|struct
name|tag
modifier|*
name|tag
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
if|if
condition|(
name|parse_tag
argument_list|(
name|tag
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|options
operator|->
name|walk
argument_list|(
name|tag
operator|->
name|tagged
argument_list|,
name|OBJ_ANY
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fsck_walk
name|int
name|fsck_walk
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obj
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|OBJ_BLOB
case|:
return|return
literal|0
return|;
case|case
name|OBJ_TREE
case|:
return|return
name|fsck_walk_tree
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|obj
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
return|;
case|case
name|OBJ_COMMIT
case|:
return|return
name|fsck_walk_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
return|;
case|case
name|OBJ_TAG
case|:
return|return
name|fsck_walk_tag
argument_list|(
operator|(
expr|struct
name|tag
operator|*
operator|)
name|obj
argument_list|,
name|data
argument_list|,
name|options
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"Unknown object type for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * The entries in a tree are ordered in the _path_ order,  * which means that a directory entry is ordered by adding  * a slash to the end of it.  *  * So a directory called "a" is ordered _after_ a file  * called "a.c", because "a/" sorts after "a.c".  */
end_comment
begin_define
DECL|macro|TREE_UNORDERED
define|#
directive|define
name|TREE_UNORDERED
value|(-1)
end_define
begin_define
DECL|macro|TREE_HAS_DUPS
define|#
directive|define
name|TREE_HAS_DUPS
value|(-2)
end_define
begin_function
DECL|function|verify_ordered
specifier|static
name|int
name|verify_ordered
parameter_list|(
name|unsigned
name|mode1
parameter_list|,
specifier|const
name|char
modifier|*
name|name1
parameter_list|,
name|unsigned
name|mode2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|)
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|name1
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|strlen
argument_list|(
name|name2
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|len1
operator|<
name|len2
condition|?
name|len1
else|:
name|len2
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|memcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
return|return
name|TREE_UNORDERED
return|;
comment|/* 	 * Ok, the first<len> characters are the same. 	 * Now we need to order the next one, but turn 	 * a '\0' into a '/' for a directory entry. 	 */
name|c1
operator|=
name|name1
index|[
name|len
index|]
expr_stmt|;
name|c2
operator|=
name|name2
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c1
operator|&&
operator|!
name|c2
condition|)
comment|/* 		 * git-write-tree used to write out a nonsense tree that has 		 * entries with the same name, one blob and one tree.  Make 		 * sure we do not have duplicate entries. 		 */
return|return
name|TREE_HAS_DUPS
return|;
if|if
condition|(
operator|!
name|c1
operator|&&
name|S_ISDIR
argument_list|(
name|mode1
argument_list|)
condition|)
name|c1
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
name|c2
operator|&&
name|S_ISDIR
argument_list|(
name|mode2
argument_list|)
condition|)
name|c2
operator|=
literal|'/'
expr_stmt|;
return|return
name|c1
operator|<
name|c2
condition|?
literal|0
else|:
name|TREE_UNORDERED
return|;
block|}
end_function
begin_function
DECL|function|fsck_tree
specifier|static
name|int
name|fsck_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|item
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|int
name|has_null_sha1
init|=
literal|0
decl_stmt|;
name|int
name|has_full_path
init|=
literal|0
decl_stmt|;
name|int
name|has_empty_name
init|=
literal|0
decl_stmt|;
name|int
name|has_dot
init|=
literal|0
decl_stmt|;
name|int
name|has_dotdot
init|=
literal|0
decl_stmt|;
name|int
name|has_dotgit
init|=
literal|0
decl_stmt|;
name|int
name|has_zero_pad
init|=
literal|0
decl_stmt|;
name|int
name|has_bad_modes
init|=
literal|0
decl_stmt|;
name|int
name|has_dup_entries
init|=
literal|0
decl_stmt|;
name|int
name|not_properly_sorted
init|=
literal|0
decl_stmt|;
name|struct
name|tree_desc
name|desc
decl_stmt|;
name|unsigned
name|o_mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|o_name
decl_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|item
operator|->
name|buffer
argument_list|,
name|item
operator|->
name|size
argument_list|)
expr_stmt|;
name|o_mode
operator|=
literal|0
expr_stmt|;
name|o_name
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|desc
operator|.
name|size
condition|)
block|{
name|unsigned
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|sha1
operator|=
name|tree_entry_extract
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
name|has_null_sha1
operator||=
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|has_full_path
operator||=
operator|!
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|has_empty_name
operator||=
operator|!
operator|*
name|name
expr_stmt|;
name|has_dot
operator||=
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|has_dotdot
operator||=
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|has_dotgit
operator||=
operator|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".git"
argument_list|)
operator|||
name|is_hfs_dotgit
argument_list|(
name|name
argument_list|)
operator|||
name|is_ntfs_dotgit
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
name|has_zero_pad
operator||=
operator|*
operator|(
name|char
operator|*
operator|)
name|desc
operator|.
name|buffer
operator|==
literal|'0'
expr_stmt|;
name|update_tree_entry
argument_list|(
operator|&
name|desc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* 		 * Standard modes.. 		 */
case|case
name|S_IFREG
operator||
literal|0755
case|:
case|case
name|S_IFREG
operator||
literal|0644
case|:
case|case
name|S_IFLNK
case|:
case|case
name|S_IFDIR
case|:
case|case
name|S_IFGITLINK
case|:
break|break;
comment|/* 		 * This is nonstandard, but we had a few of these 		 * early on when we honored the full set of mode 		 * bits.. 		 */
case|case
name|S_IFREG
operator||
literal|0664
case|:
if|if
condition|(
operator|!
name|options
operator|->
name|strict
condition|)
break|break;
default|default:
name|has_bad_modes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|o_name
condition|)
block|{
switch|switch
condition|(
name|verify_ordered
argument_list|(
name|o_mode
argument_list|,
name|o_name
argument_list|,
name|mode
argument_list|,
name|name
argument_list|)
condition|)
block|{
case|case
name|TREE_UNORDERED
case|:
name|not_properly_sorted
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TREE_HAS_DUPS
case|:
name|has_dup_entries
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|o_mode
operator|=
name|mode
expr_stmt|;
name|o_name
operator|=
name|name
expr_stmt|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_null_sha1
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_NULL_SHA1
argument_list|,
literal|"contains entries pointing to null sha1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_full_path
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_FULL_PATHNAME
argument_list|,
literal|"contains full pathnames"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_empty_name
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_EMPTY_NAME
argument_list|,
literal|"contains empty pathname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_dot
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_HAS_DOT
argument_list|,
literal|"contains '.'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_dotdot
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_HAS_DOTDOT
argument_list|,
literal|"contains '..'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_dotgit
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_HAS_DOTGIT
argument_list|,
literal|"contains '.git'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_zero_pad
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_ZERO_PADDED_FILEMODE
argument_list|,
literal|"contains zero-padded file modes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_bad_modes
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_FILEMODE
argument_list|,
literal|"contains bad file modes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_dup_entries
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_DUPLICATE_ENTRIES
argument_list|,
literal|"contains duplicate file entries"
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_properly_sorted
condition|)
name|retval
operator|+=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|item
operator|->
name|object
argument_list|,
name|FSCK_MSG_TREE_NOT_SORTED
argument_list|,
literal|"not properly sorted"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|verify_headers
specifier|static
name|int
name|verify_headers
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buffer
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|buffer
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_NUL_IN_HEADER
argument_list|,
literal|"unterminated header: NUL at offset %ld"
argument_list|,
name|i
argument_list|)
return|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|size
operator|&&
name|buffer
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * We did not find double-LF that separates the header 	 * and the body.  Not having a body is not a crime but 	 * we do want to see the terminating LF for the last header 	 * line. 	 */
if|if
condition|(
name|size
operator|&&
name|buffer
index|[
name|size
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_UNTERMINATED_HEADER
argument_list|,
literal|"unterminated header"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fsck_ident
specifier|static
name|int
name|fsck_ident
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ident
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|ident
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
operator|*
name|ident
operator|=
name|strchrnul
argument_list|(
operator|*
name|ident
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ident
operator|==
literal|'\n'
condition|)
operator|(
operator|*
name|ident
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_MISSING_NAME_BEFORE_EMAIL
argument_list|,
literal|"invalid author/committer line - missing space before email"
argument_list|)
return|;
name|p
operator|+=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|"<>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_BAD_NAME
argument_list|,
literal|"invalid author/committer line - bad name"
argument_list|)
return|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'<'
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_MISSING_EMAIL
argument_list|,
literal|"invalid author/committer line - missing email"
argument_list|)
return|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_MISSING_SPACE_BEFORE_EMAIL
argument_list|,
literal|"invalid author/committer line - missing space before email"
argument_list|)
return|;
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|"<>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'>'
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_BAD_EMAIL
argument_list|,
literal|"invalid author/committer line - bad email"
argument_list|)
return|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_MISSING_SPACE_BEFORE_DATE
argument_list|,
literal|"invalid author/committer line - missing space before date"
argument_list|)
return|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_ZERO_PADDED_DATE
argument_list|,
literal|"invalid author/committer line - zero-padded date"
argument_list|)
return|;
if|if
condition|(
name|date_overflows
argument_list|(
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
argument_list|)
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_BAD_DATE_OVERFLOW
argument_list|,
literal|"invalid author/committer line - date causes integer overflow"
argument_list|)
return|;
if|if
condition|(
operator|(
name|end
operator|==
name|p
operator|||
operator|*
name|end
operator|!=
literal|' '
operator|)
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_BAD_DATE
argument_list|,
literal|"invalid author/committer line - bad date"
argument_list|)
return|;
name|p
operator|=
name|end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'+'
operator|&&
operator|*
name|p
operator|!=
literal|'-'
operator|)
operator|||
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
operator|||
operator|(
name|p
index|[
literal|5
index|]
operator|!=
literal|'\n'
operator|)
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_BAD_TIMEZONE
argument_list|,
literal|"invalid author/committer line - bad time zone"
argument_list|)
return|;
name|p
operator|+=
literal|6
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fsck_commit_buffer
specifier|static
name|int
name|fsck_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
name|unsigned
name|char
name|tree_sha1
index|[
literal|20
index|]
decl_stmt|,
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
decl_stmt|;
name|unsigned
name|parent_count
decl_stmt|,
name|parent_line_count
init|=
literal|0
decl_stmt|,
name|author_count
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|verify_headers
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"tree "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_TREE
argument_list|,
literal|"invalid format - expected 'tree' line"
argument_list|)
return|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|tree_sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|err
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_TREE_SHA1
argument_list|,
literal|"invalid 'tree' line format - bad sha1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|buffer
operator|+=
literal|41
expr_stmt|;
while|while
condition|(
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"parent "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|err
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_PARENT_SHA1
argument_list|,
literal|"invalid 'parent' line format - bad sha1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|buffer
operator|+=
literal|41
expr_stmt|;
name|parent_line_count
operator|++
expr_stmt|;
block|}
name|graft
operator|=
name|lookup_commit_graft
argument_list|(
name|get_object_hash
argument_list|(
name|commit
operator|->
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|parent_count
operator|=
name|commit_list_count
argument_list|(
name|commit
operator|->
name|parents
argument_list|)
expr_stmt|;
if|if
condition|(
name|graft
condition|)
block|{
if|if
condition|(
name|graft
operator|->
name|nr_parent
operator|==
operator|-
literal|1
operator|&&
operator|!
name|parent_count
condition|)
empty_stmt|;
comment|/* shallow commit */
elseif|else
if|if
condition|(
name|graft
operator|->
name|nr_parent
operator|!=
name|parent_count
condition|)
block|{
name|err
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_GRAFT
argument_list|,
literal|"graft objects missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parent_count
operator|!=
name|parent_line_count
condition|)
block|{
name|err
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_PARENT
argument_list|,
literal|"parent objects missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
block|}
name|author_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"author "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|author_count
operator|++
expr_stmt|;
name|err
operator|=
name|fsck_ident
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
if|if
condition|(
name|author_count
operator|<
literal|1
condition|)
name|err
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_AUTHOR
argument_list|,
literal|"invalid format - expected 'author' line"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|author_count
operator|>
literal|1
condition|)
name|err
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_MULTIPLE_AUTHORS
argument_list|,
literal|"invalid format - multiple 'author' lines"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"committer "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_COMMITTER
argument_list|,
literal|"invalid format - expected 'committer' line"
argument_list|)
return|;
name|err
operator|=
name|fsck_ident
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|commit
operator|->
name|tree
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_TREE
argument_list|,
literal|"could not load commit's tree %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tree_sha1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fsck_commit
specifier|static
name|int
name|fsck_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buffer
init|=
name|data
condition|?
name|data
else|:
name|get_commit_buffer
argument_list|(
name|commit
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|fsck_commit_buffer
argument_list|(
name|commit
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
name|unuse_commit_buffer
argument_list|(
name|commit
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|fsck_tag_buffer
specifier|static
name|int
name|fsck_tag_buffer
parameter_list|(
name|struct
name|tag
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|to_free
init|=
name|NULL
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|data
condition|)
name|buffer
operator|=
name|data
expr_stmt|;
else|else
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|buffer
operator|=
name|to_free
operator|=
name|read_sha1_file
argument_list|(
name|get_object_hash
argument_list|(
name|tag
operator|->
name|object
argument_list|)
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_TAG_OBJECT
argument_list|,
literal|"cannot read tag object"
argument_list|)
return|;
if|if
condition|(
name|type
operator|!=
name|OBJ_TAG
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_TAG_OBJECT_NOT_TAG
argument_list|,
literal|"expected tag got %s"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|verify_headers
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|options
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"object "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_OBJECT
argument_list|,
literal|"invalid format - expected 'object' line"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_OBJECT_SHA1
argument_list|,
literal|"invalid 'object' line format - bad sha1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|done
goto|;
block|}
name|buffer
operator|+=
literal|41
expr_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"type "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_TYPE_ENTRY
argument_list|,
literal|"invalid format - expected 'type' line"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|eol
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_TYPE
argument_list|,
literal|"invalid format - unexpected end after 'type' line"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|type_from_string_gently
argument_list|(
name|buffer
argument_list|,
name|eol
operator|-
name|buffer
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_TYPE
argument_list|,
literal|"invalid 'type' value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|done
goto|;
name|buffer
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"tag "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_TAG_ENTRY
argument_list|,
literal|"invalid format - expected 'tag' line"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|eol
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_TAG
argument_list|,
literal|"invalid format - unexpected end after 'type' line"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"refs/tags/%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eol
operator|-
name|buffer
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_refname_format
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_TAG_NAME
argument_list|,
literal|"invalid 'tag' name: %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|eol
operator|-
name|buffer
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|done
goto|;
block|}
name|buffer
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"tagger "
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
block|{
comment|/* early tags do not contain 'tagger' lines; warn only */
name|ret
operator|=
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_MISSING_TAGGER_ENTRY
argument_list|,
literal|"invalid format - expected 'tagger' line"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|done
goto|;
block|}
else|else
name|ret
operator|=
name|fsck_ident
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|done
label|:
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|fsck_tag
specifier|static
name|int
name|fsck_tag
parameter_list|(
name|struct
name|tag
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|tagged
init|=
name|tag
operator|->
name|tagged
decl_stmt|;
if|if
condition|(
operator|!
name|tagged
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
operator|&
name|tag
operator|->
name|object
argument_list|,
name|FSCK_MSG_BAD_TAG_OBJECT
argument_list|,
literal|"could not load tagged object"
argument_list|)
return|;
return|return
name|fsck_tag_buffer
argument_list|(
name|tag
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fsck_object
name|int
name|fsck_object
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|fsck_options
modifier|*
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_BAD_OBJECT_SHA1
argument_list|,
literal|"no valid object to fsck"
argument_list|)
return|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_BLOB
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TREE
condition|)
return|return
name|fsck_tree
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|obj
argument_list|,
name|options
argument_list|)
return|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
return|return
name|fsck_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|size
argument_list|,
name|options
argument_list|)
return|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
return|return
name|fsck_tag
argument_list|(
operator|(
expr|struct
name|tag
operator|*
operator|)
name|obj
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|size
argument_list|,
name|options
argument_list|)
return|;
return|return
name|report
argument_list|(
name|options
argument_list|,
name|obj
argument_list|,
name|FSCK_MSG_UNKNOWN_TYPE
argument_list|,
literal|"unknown type '%d' (internal fsck error)"
argument_list|,
name|obj
operator|->
name|type
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fsck_error_function
name|int
name|fsck_error_function
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|int
name|msg_type
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
name|msg_type
operator|==
name|FSCK_WARN
condition|)
block|{
name|warning
argument_list|(
literal|"object %s: %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
argument_list|(
literal|"object %s: %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
end_unit
