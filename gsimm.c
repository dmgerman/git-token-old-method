begin_unit
begin_include
include|#
directive|include
file|"rabinpoly.h"
end_include
begin_include
include|#
directive|include
file|"gsimm.h"
end_include
begin_comment
comment|/* Has to be power of two. Since the Rabin hash only has 63    usable bits, the number of hashes is limited to 32.    Lower powers of two could be used for speeding up processing    of very large files.  */
end_comment
begin_define
DECL|macro|NUM_HASHES_PER_CHAR
define|#
directive|define
name|NUM_HASHES_PER_CHAR
value|32
end_define
begin_comment
comment|/* Size of cache used to eliminate duplicate substrings.    Make small enough to comfortably fit in L1 cache.  */
end_comment
begin_define
DECL|macro|DUP_CACHE_SIZE
define|#
directive|define
name|DUP_CACHE_SIZE
value|256
end_define
begin_comment
comment|/* For the final counting, do not count each bit individually, but    group them. Must be power of two, at most NUM_HASHES_PER_CHAR.    However, larger sizes result in higher cache usage. Use 8 bits    per group for efficient processing of large files on fast machines    with decent caches, or 4 bits for faster processing of small files    and for machines with small caches.  */
end_comment
begin_define
DECL|macro|GROUP_BITS
define|#
directive|define
name|GROUP_BITS
value|4
end_define
begin_define
DECL|macro|GROUP_COUNTERS
define|#
directive|define
name|GROUP_COUNTERS
value|(1<<GROUP_BITS)
end_define
begin_function
DECL|function|freq_to_md
specifier|static
name|void
name|freq_to_md
parameter_list|(
name|u_char
modifier|*
name|md
parameter_list|,
name|int
modifier|*
name|freq
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MD_LENGTH
condition|;
name|j
operator|++
control|)
block|{
name|u_char
name|ch
init|=
literal|0
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
name|ch
operator|=
literal|2
operator|*
name|ch
operator|+
operator|(
name|freq
index|[
literal|8
operator|*
name|j
operator|+
name|k
index|]
operator|>
literal|0
operator|)
expr_stmt|;
name|md
index|[
name|j
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|bzero
argument_list|(
name|freq
argument_list|,
sizeof|sizeof
argument_list|(
name|freq
index|[
literal|0
index|]
argument_list|)
operator|*
name|MD_BITS
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|gb_simm_process
name|void
name|gb_simm_process
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|u_char
modifier|*
name|md
parameter_list|)
block|{
name|size_t
name|j
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|ofs
decl_stmt|;
name|u_int32_t
name|dup_cache
index|[
name|DUP_CACHE_SIZE
index|]
decl_stmt|;
name|u_int32_t
name|count
index|[
name|MD_BITS
operator|*
operator|(
name|GROUP_COUNTERS
operator|/
name|GROUP_BITS
operator|)
index|]
decl_stmt|;
name|int
name|freq
index|[
name|MD_BITS
index|]
decl_stmt|;
name|bzero
argument_list|(
name|freq
argument_list|,
sizeof|sizeof
argument_list|(
name|freq
index|[
literal|0
index|]
argument_list|)
operator|*
name|MD_BITS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dup_cache
argument_list|,
name|DUP_CACHE_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|count
argument_list|,
operator|(
name|MD_BITS
operator|*
operator|(
name|GROUP_COUNTERS
operator|/
name|GROUP_BITS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Ignore incomplete substrings */
while|while
condition|(
name|j
operator|<
name|len
operator|&&
name|j
operator|<
name|RABIN_WINDOW_SIZE
condition|)
name|rabin_slide8
argument_list|(
name|data
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|len
condition|)
block|{
name|u_int64_t
name|hash
decl_stmt|;
name|u_int32_t
name|ofs
decl_stmt|,
name|sum
decl_stmt|;
name|u_char
name|idx
decl_stmt|;
name|int
name|k
decl_stmt|;
name|hash
operator|=
name|rabin_slide8
argument_list|(
name|data
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* In order to update a much larger frequency table        with only 32 bits of checksum, randomly select a        part of the table to update. The selection should        only depend on the content of the represented data,        and be independent of the bits used for the update.         Instead of updating 32 individual counters, process        the checksum in MD_BITS / GROUP_BITS groups of        GROUP_BITS bits, and count the frequency of each bit pattern.     */
name|idx
operator|=
operator|(
name|hash
operator|>>
literal|32
operator|)
expr_stmt|;
name|sum
operator|=
operator|(
name|u_int32_t
operator|)
name|hash
expr_stmt|;
name|ofs
operator|=
name|idx
operator|%
operator|(
name|MD_BITS
operator|/
name|NUM_HASHES_PER_CHAR
operator|)
operator|*
name|NUM_HASHES_PER_CHAR
expr_stmt|;
name|idx
operator|%=
name|DUP_CACHE_SIZE
expr_stmt|;
if|if
condition|(
name|dup_cache
index|[
name|idx
index|]
operator|!=
name|sum
condition|)
block|{
name|dup_cache
index|[
name|idx
index|]
operator|=
name|sum
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_HASHES_PER_CHAR
operator|/
name|GROUP_BITS
condition|;
name|k
operator|++
control|)
block|{
name|count
index|[
name|ofs
operator|*
name|GROUP_COUNTERS
operator|/
name|GROUP_BITS
operator|+
operator|(
name|sum
operator|%
name|GROUP_COUNTERS
operator|)
index|]
operator|++
expr_stmt|;
name|ofs
operator|+=
name|GROUP_BITS
expr_stmt|;
name|sum
operator|>>=
name|GROUP_BITS
expr_stmt|;
block|}
block|}
block|}
comment|/* Distribute the occurrences of each bit group over the frequency table. */
for|for
control|(
name|ofs
operator|=
literal|0
init|;
name|ofs
operator|<
name|MD_BITS
condition|;
name|ofs
operator|+=
name|GROUP_BITS
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|GROUP_COUNTERS
condition|;
name|j
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|GROUP_BITS
condition|;
name|k
operator|++
control|)
block|{
name|freq
index|[
name|ofs
operator|+
name|k
index|]
operator|+=
operator|(
operator|(
literal|1
operator|<<
name|k
operator|)
operator|&
name|j
operator|)
condition|?
name|count
index|[
name|ofs
operator|*
name|GROUP_COUNTERS
operator|/
name|GROUP_BITS
operator|+
name|j
index|]
else|:
operator|-
name|count
index|[
name|ofs
operator|*
name|GROUP_COUNTERS
operator|/
name|GROUP_BITS
operator|+
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|md
condition|)
block|{
name|rabin_reset
argument_list|()
expr_stmt|;
name|freq_to_md
argument_list|(
name|md
argument_list|,
name|freq
argument_list|)
expr_stmt|;
block|}
block|}
end_function
end_unit
