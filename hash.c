begin_unit
begin_comment
comment|/*  * Some generic hashing helpers.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"hash.h"
end_include
begin_comment
comment|/*  * Look up a hash entry in the hash table. Return the pointer to  * the existing entry, or the empty slot if none existed. The caller  * can then look at the (*ptr) to see whether it existed or not.  */
end_comment
begin_function
DECL|function|lookup_hash_entry
specifier|static
name|struct
name|hash_table_entry
modifier|*
name|lookup_hash_entry
parameter_list|(
name|unsigned
name|int
name|hash
parameter_list|,
specifier|const
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
name|table
operator|->
name|size
decl_stmt|,
name|nr
init|=
name|hash
operator|%
name|size
decl_stmt|;
name|struct
name|hash_table_entry
modifier|*
name|array
init|=
name|table
operator|->
name|array
decl_stmt|;
while|while
condition|(
name|array
index|[
name|nr
index|]
operator|.
name|ptr
condition|)
block|{
if|if
condition|(
name|array
index|[
name|nr
index|]
operator|.
name|hash
operator|==
name|hash
condition|)
break|break;
name|nr
operator|++
expr_stmt|;
if|if
condition|(
name|nr
operator|>=
name|size
condition|)
name|nr
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|array
operator|+
name|nr
return|;
block|}
end_function
begin_comment
comment|/*  * Insert a new hash entry pointer into the table.  *  * If that hash entry already existed, return the pointer to  * the existing entry (and the caller can create a list of the  * pointers or do anything else). If it didn't exist, return  * NULL (and the caller knows the pointer has been inserted).  */
end_comment
begin_function
DECL|function|insert_hash_entry
specifier|static
name|void
modifier|*
modifier|*
name|insert_hash_entry
parameter_list|(
name|unsigned
name|int
name|hash
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|struct
name|hash_table_entry
modifier|*
name|entry
init|=
name|lookup_hash_entry
argument_list|(
name|hash
argument_list|,
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|ptr
condition|)
block|{
name|entry
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|entry
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|table
operator|->
name|nr
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|entry
operator|->
name|ptr
return|;
block|}
end_function
begin_function
DECL|function|grow_hash_table
specifier|static
name|void
name|grow_hash_table
parameter_list|(
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|old_size
init|=
name|table
operator|->
name|size
decl_stmt|,
name|new_size
decl_stmt|;
name|struct
name|hash_table_entry
modifier|*
name|old_array
init|=
name|table
operator|->
name|array
decl_stmt|,
modifier|*
name|new_array
decl_stmt|;
name|new_size
operator|=
name|alloc_nr
argument_list|(
name|old_size
argument_list|)
expr_stmt|;
name|new_array
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hash_table_entry
argument_list|)
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|new_size
expr_stmt|;
name|table
operator|->
name|array
operator|=
name|new_array
expr_stmt|;
name|table
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|hash
init|=
name|old_array
index|[
name|i
index|]
operator|.
name|hash
decl_stmt|;
name|void
modifier|*
name|ptr
init|=
name|old_array
index|[
name|i
index|]
operator|.
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
name|insert_hash_entry
argument_list|(
name|hash
argument_list|,
name|ptr
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old_array
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lookup_hash
name|void
modifier|*
name|lookup_hash
parameter_list|(
name|unsigned
name|int
name|hash
parameter_list|,
specifier|const
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
if|if
condition|(
operator|!
name|table
operator|->
name|array
condition|)
return|return
name|NULL
return|;
return|return
name|lookup_hash_entry
argument_list|(
name|hash
argument_list|,
name|table
argument_list|)
operator|->
name|ptr
return|;
block|}
end_function
begin_function
DECL|function|insert_hash
name|void
modifier|*
modifier|*
name|insert_hash
parameter_list|(
name|unsigned
name|int
name|hash
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|unsigned
name|int
name|nr
init|=
name|table
operator|->
name|nr
decl_stmt|;
if|if
condition|(
name|nr
operator|>=
name|table
operator|->
name|size
operator|/
literal|2
condition|)
name|grow_hash_table
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|insert_hash_entry
argument_list|(
name|hash
argument_list|,
name|ptr
argument_list|,
name|table
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|for_each_hash
name|int
name|for_each_hash
parameter_list|(
specifier|const
name|struct
name|hash_table
modifier|*
name|table
parameter_list|,
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|table
operator|->
name|size
decl_stmt|;
name|struct
name|hash_table_entry
modifier|*
name|array
init|=
name|table
operator|->
name|array
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|ptr
init|=
name|array
operator|->
name|ptr
decl_stmt|;
name|array
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|int
name|val
init|=
name|fn
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
name|val
return|;
name|sum
operator|+=
name|val
expr_stmt|;
block|}
block|}
return|return
name|sum
return|;
block|}
end_function
begin_function
DECL|function|free_hash
name|void
name|free_hash
parameter_list|(
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|free
argument_list|(
name|table
operator|->
name|array
argument_list|)
expr_stmt|;
name|table
operator|->
name|array
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
block|}
end_function
end_unit
