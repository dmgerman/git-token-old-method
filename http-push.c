begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"fetch.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"http.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
end_ifdef
begin_include
include|#
directive|include
file|<expat.h>
end_include
begin_decl_stmt
DECL|variable|http_push_usage
specifier|static
specifier|const
name|char
name|http_push_usage
index|[]
init|=
literal|"git-http-push [--complete] [--force] [--verbose]<url><ref> [<ref>...]\n"
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|XML_STATUS_OK
end_ifndef
begin_enum
DECL|enum|XML_Status
enum|enum
name|XML_Status
block|{
DECL|enumerator|XML_STATUS_OK
name|XML_STATUS_OK
init|=
literal|1
block|,
DECL|enumerator|XML_STATUS_ERROR
name|XML_STATUS_ERROR
init|=
literal|0
block|}
enum|;
end_enum
begin_define
DECL|macro|XML_STATUS_OK
define|#
directive|define
name|XML_STATUS_OK
value|1
end_define
begin_define
DECL|macro|XML_STATUS_ERROR
define|#
directive|define
name|XML_STATUS_ERROR
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|RANGE_HEADER_SIZE
define|#
directive|define
name|RANGE_HEADER_SIZE
value|30
end_define
begin_comment
comment|/* DAV method names and request body templates */
end_comment
begin_define
DECL|macro|DAV_LOCK
define|#
directive|define
name|DAV_LOCK
value|"LOCK"
end_define
begin_define
DECL|macro|DAV_MKCOL
define|#
directive|define
name|DAV_MKCOL
value|"MKCOL"
end_define
begin_define
DECL|macro|DAV_MOVE
define|#
directive|define
name|DAV_MOVE
value|"MOVE"
end_define
begin_define
DECL|macro|DAV_PROPFIND
define|#
directive|define
name|DAV_PROPFIND
value|"PROPFIND"
end_define
begin_define
DECL|macro|DAV_PUT
define|#
directive|define
name|DAV_PUT
value|"PUT"
end_define
begin_define
DECL|macro|DAV_UNLOCK
define|#
directive|define
name|DAV_UNLOCK
value|"UNLOCK"
end_define
begin_define
DECL|macro|PROPFIND_REQUEST
define|#
directive|define
name|PROPFIND_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n<D:prop xmlns:R=\"%s\">\n<D:supportedlock/>\n</D:prop>\n</D:propfind>"
end_define
begin_define
DECL|macro|LOCK_REQUEST
define|#
directive|define
name|LOCK_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n<D:owner>\n<D:href>mailto:%s</D:href>\n</D:owner>\n</D:lockinfo>"
end_define
begin_define
DECL|macro|LOCK_TIME
define|#
directive|define
name|LOCK_TIME
value|600
end_define
begin_define
DECL|macro|LOCK_REFRESH
define|#
directive|define
name|LOCK_REFRESH
value|30
end_define
begin_decl_stmt
DECL|variable|pushing
specifier|static
name|int
name|pushing
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|aborted
specifier|static
name|int
name|aborted
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remote_dir_exists
specifier|static
name|char
name|remote_dir_exists
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_pragma_header
specifier|static
name|struct
name|curl_slist
modifier|*
name|no_pragma_header
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_headers
specifier|static
name|struct
name|curl_slist
modifier|*
name|default_headers
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|push_verbosely
specifier|static
name|int
name|push_verbosely
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|push_all
specifier|static
name|int
name|push_all
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|force_all
specifier|static
name|int
name|force_all
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|repo
struct|struct
name|repo
block|{
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|packs
name|struct
name|packed_git
modifier|*
name|packs
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|remote
specifier|static
name|struct
name|repo
modifier|*
name|remote
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|transfer_state
enum|enum
name|transfer_state
block|{
DECL|enumerator|NEED_CHECK
name|NEED_CHECK
block|,
DECL|enumerator|RUN_HEAD
name|RUN_HEAD
block|,
DECL|enumerator|NEED_PUSH
name|NEED_PUSH
block|,
DECL|enumerator|RUN_MKCOL
name|RUN_MKCOL
block|,
DECL|enumerator|RUN_PUT
name|RUN_PUT
block|,
DECL|enumerator|RUN_MOVE
name|RUN_MOVE
block|,
DECL|enumerator|ABORTED
name|ABORTED
block|,
DECL|enumerator|COMPLETE
name|COMPLETE
block|, }
enum|;
end_enum
begin_struct
DECL|struct|transfer_request
struct|struct
name|transfer_request
block|{
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|dest
name|char
modifier|*
name|dest
decl_stmt|;
DECL|member|lock
name|struct
name|active_lock
modifier|*
name|lock
decl_stmt|;
DECL|member|headers
name|struct
name|curl_slist
modifier|*
name|headers
decl_stmt|;
DECL|member|buffer
name|struct
name|buffer
name|buffer
decl_stmt|;
DECL|member|filename
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
DECL|member|tmpfile
name|char
name|tmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
DECL|member|state
name|enum
name|transfer_state
name|state
decl_stmt|;
DECL|member|curl_result
name|CURLcode
name|curl_result
decl_stmt|;
DECL|member|errorstr
name|char
name|errorstr
index|[
name|CURL_ERROR_SIZE
index|]
decl_stmt|;
DECL|member|http_code
name|long
name|http_code
decl_stmt|;
DECL|member|real_sha1
name|unsigned
name|char
name|real_sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|c
name|SHA_CTX
name|c
decl_stmt|;
DECL|member|stream
name|z_stream
name|stream
decl_stmt|;
DECL|member|zret
name|int
name|zret
decl_stmt|;
DECL|member|rename
name|int
name|rename
decl_stmt|;
DECL|member|slot
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
DECL|member|next
name|struct
name|transfer_request
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|request_queue_head
specifier|static
name|struct
name|transfer_request
modifier|*
name|request_queue_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|active_lock
struct|struct
name|active_lock
block|{
DECL|member|ctx_activelock
name|int
name|ctx_activelock
decl_stmt|;
DECL|member|ctx_owner
name|int
name|ctx_owner
decl_stmt|;
DECL|member|ctx_owner_href
name|int
name|ctx_owner_href
decl_stmt|;
DECL|member|ctx_timeout
name|int
name|ctx_timeout
decl_stmt|;
DECL|member|ctx_locktoken
name|int
name|ctx_locktoken
decl_stmt|;
DECL|member|ctx_locktoken_href
name|int
name|ctx_locktoken_href
decl_stmt|;
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|owner
name|char
modifier|*
name|owner
decl_stmt|;
DECL|member|token
name|char
modifier|*
name|token
decl_stmt|;
DECL|member|start_time
name|time_t
name|start_time
decl_stmt|;
DECL|member|timeout
name|long
name|timeout
decl_stmt|;
DECL|member|refreshing
name|int
name|refreshing
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|lockprop
struct|struct
name|lockprop
block|{
DECL|member|supported_lock
name|int
name|supported_lock
decl_stmt|;
DECL|member|lock_entry
name|int
name|lock_entry
decl_stmt|;
DECL|member|lock_scope
name|int
name|lock_scope
decl_stmt|;
DECL|member|lock_type
name|int
name|lock_type
decl_stmt|;
DECL|member|lock_exclusive
name|int
name|lock_exclusive
decl_stmt|;
DECL|member|lock_exclusive_write
name|int
name|lock_exclusive_write
decl_stmt|;
block|}
struct|;
end_struct
begin_function_decl
specifier|static
name|void
name|finish_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|process_response
specifier|static
name|void
name|process_response
parameter_list|(
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
operator|(
expr|struct
name|transfer_request
operator|*
operator|)
name|callback_data
decl_stmt|;
name|finish_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|start_check
specifier|static
name|void
name|start_check
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|posn
decl_stmt|;
name|request
operator|->
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|55
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|request
operator|->
name|url
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|=
name|request
operator|->
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"objects/"
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|posn
argument_list|,
name|hex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|posn
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
name|hex
operator|+
literal|2
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_ERRORBUFFER
argument_list|,
name|request
operator|->
name|errorstr
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_HEAD
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_mkcol
specifier|static
name|void
name|start_mkcol
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|posn
decl_stmt|;
name|request
operator|->
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|13
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|request
operator|->
name|url
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|=
name|request
operator|->
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"objects/"
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|posn
argument_list|,
name|hex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* undo PUT setup */
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_ERRORBUFFER
argument_list|,
name|request
operator|->
name|errorstr
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_MKCOL
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_MKCOL
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_put
specifier|static
name|void
name|start_put
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|posn
decl_stmt|;
name|char
name|type
index|[
literal|20
index|]
decl_stmt|;
name|char
name|hdr
index|[
literal|50
index|]
decl_stmt|;
name|void
modifier|*
name|unpacked
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|unpacked
operator|=
name|read_sha1_file
argument_list|(
name|request
operator|->
name|sha1
argument_list|,
name|type
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|type
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Set it up */
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|deflateInit
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_BEST_COMPRESSION
argument_list|)
expr_stmt|;
name|size
operator|=
name|deflateBound
argument_list|(
operator|&
name|stream
argument_list|,
name|len
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
name|request
operator|->
name|buffer
operator|.
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Compress it */
name|stream
operator|.
name|next_out
operator|=
name|request
operator|->
name|buffer
operator|.
name|buffer
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
comment|/* First header.. */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|hdr
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|hdrlen
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
comment|/* Then the data itself.. */
name|stream
operator|.
name|next_in
operator|=
name|unpacked
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
name|deflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unpacked
argument_list|)
expr_stmt|;
name|request
operator|->
name|buffer
operator|.
name|size
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
name|request
operator|->
name|buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|url
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|request
operator|->
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|51
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|request
operator|->
name|url
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|=
name|request
operator|->
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"objects/"
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|posn
argument_list|,
name|hex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|posn
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
name|hex
operator|+
literal|2
argument_list|)
expr_stmt|;
name|request
operator|->
name|dest
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|request
operator|->
name|url
argument_list|)
operator|+
literal|14
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|request
operator|->
name|dest
argument_list|,
literal|"Destination: %s"
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|38
expr_stmt|;
operator|*
operator|(
name|posn
operator|++
operator|)
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
name|request
operator|->
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|request
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|request
operator|->
name|buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PUT
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_PUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_PUT
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_move
specifier|static
name|void
name|start_move
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* undo PUT setup */
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_MOVE
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|request
operator|->
name|dest
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Overwrite: T"
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_MOVE
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|refresh_lock
specifier|static
name|int
name|refresh_lock
parameter_list|(
name|struct
name|active_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|if_header
decl_stmt|;
name|char
name|timeout_header
index|[
literal|25
index|]
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|lock
operator|->
name|refreshing
operator|=
literal|1
expr_stmt|;
name|if_header
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|25
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|if_header
argument_list|,
literal|"If: (<opaquelocktoken:%s>)"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timeout_header
argument_list|,
literal|"Timeout: Second-%ld"
argument_list|,
name|lock
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|if_header
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|timeout_header
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_LOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got HTTP error %ld\n"
argument_list|,
name|slot
operator|->
name|http_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock
operator|->
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|lock
operator|->
name|refreshing
operator|=
literal|0
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|if_header
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|finish_request
specifier|static
name|void
name|finish_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|time_t
name|current_time
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|time_remaining
decl_stmt|;
name|request
operator|->
name|curl_result
operator|=
name|request
operator|->
name|slot
operator|->
name|curl_result
expr_stmt|;
name|request
operator|->
name|http_code
operator|=
name|request
operator|->
name|slot
operator|->
name|http_code
expr_stmt|;
name|request
operator|->
name|slot
operator|=
name|NULL
expr_stmt|;
comment|/* Refresh the lock if it is close to timing out */
name|time_remaining
operator|=
name|request
operator|->
name|lock
operator|->
name|start_time
operator|+
name|request
operator|->
name|lock
operator|->
name|timeout
operator|-
name|current_time
expr_stmt|;
if|if
condition|(
name|time_remaining
operator|<
name|LOCK_REFRESH
operator|&&
operator|!
name|request
operator|->
name|lock
operator|->
name|refreshing
condition|)
block|{
if|if
condition|(
operator|!
name|refresh_lock
argument_list|(
name|request
operator|->
name|lock
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to refresh remote lock\n"
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|request
operator|->
name|headers
operator|!=
name|NULL
condition|)
name|curl_slist_free_all
argument_list|(
name|request
operator|->
name|headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_HEAD
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|http_code
operator|==
literal|404
condition|)
block|{
name|request
operator|->
name|state
operator|=
name|NEED_PUSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|remote_dir_exists
index|[
name|request
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|COMPLETE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HEAD %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_MKCOL
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
operator|||
name|request
operator|->
name|http_code
operator|==
literal|405
condition|)
block|{
name|remote_dir_exists
index|[
name|request
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|start_put
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MKCOL %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_PUT
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|start_move
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_MOVE
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|COMPLETE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MOVE %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|release_request
specifier|static
name|void
name|release_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|entry
init|=
name|request_queue_head
decl_stmt|;
if|if
condition|(
name|request
operator|==
name|request_queue_head
condition|)
block|{
name|request_queue_head
operator|=
name|request
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|next
operator|!=
name|request
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|==
name|request
condition|)
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|next
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fill_active_slots
name|void
name|fill_active_slots
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
name|request_queue_head
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
init|=
name|active_queue_head
decl_stmt|;
name|int
name|num_transfers
decl_stmt|;
if|if
condition|(
name|aborted
condition|)
return|return;
while|while
condition|(
name|active_requests
operator|<
name|max_requests
operator|&&
name|request
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|pushing
operator|&&
name|request
operator|->
name|state
operator|==
name|NEED_CHECK
condition|)
block|{
name|start_check
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|curl_multi_perform
argument_list|(
name|curlm
argument_list|,
operator|&
name|num_transfers
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pushing
operator|&&
name|request
operator|->
name|state
operator|==
name|NEED_PUSH
condition|)
block|{
if|if
condition|(
name|remote_dir_exists
index|[
name|request
operator|->
name|sha1
index|[
literal|0
index|]
index|]
condition|)
name|start_put
argument_list|(
name|request
argument_list|)
expr_stmt|;
else|else
name|start_mkcol
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|curl_multi_perform
argument_list|(
name|curlm
argument_list|,
operator|&
name|num_transfers
argument_list|)
expr_stmt|;
block|}
name|request
operator|=
name|request
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
name|slot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|slot
operator|->
name|in_use
operator|&&
name|slot
operator|->
name|curl
operator|!=
name|NULL
condition|)
block|{
name|curl_easy_cleanup
argument_list|(
name|slot
operator|->
name|curl
argument_list|)
expr_stmt|;
name|slot
operator|->
name|curl
operator|=
name|NULL
expr_stmt|;
block|}
name|slot
operator|=
name|slot
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_request
specifier|static
name|void
name|add_request
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|active_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
name|request_queue_head
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|target
decl_stmt|;
while|while
condition|(
name|request
operator|!=
name|NULL
operator|&&
name|memcmp
argument_list|(
name|request
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|,
literal|20
argument_list|)
condition|)
name|request
operator|=
name|request
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|request
operator|!=
name|NULL
condition|)
return|return;
name|target
operator|=
name|find_sha1_pack
argument_list|(
name|sha1
argument_list|,
name|remote
operator|->
name|packs
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return;
name|request
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|request
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|request
operator|->
name|headers
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|NEED_CHECK
expr_stmt|;
name|request
operator|->
name|next
operator|=
name|request_queue_head
expr_stmt|;
name|request_queue_head
operator|=
name|request
expr_stmt|;
name|fill_active_slots
argument_list|()
expr_stmt|;
name|step_active_slots
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fetch_index
specifier|static
name|int
name|fetch_index
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|char
name|tmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|long
name|prev_posn
init|=
literal|0
decl_stmt|;
name|char
name|range
index|[
name|RANGE_HEADER_SIZE
index|]
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|range_header
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|indexfile
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
comment|/* Don't use the index if the pack isn't there */
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|65
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s/objects/pack/pack-%s.pack"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to verify pack %s is available"
argument_list|,
name|hex
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
if|if
condition|(
name|has_pack_index
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Getting index for pack %s\n"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s/objects/pack/pack-%s.idx"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|filename
operator|=
name|sha1_pack_index_name
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"%s.temp"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|indexfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexfile
condition|)
return|return
name|error
argument_list|(
literal|"Unable to open local file %s for pack index"
argument_list|,
name|filename
argument_list|)
return|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
name|indexfile
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|no_pragma_header
argument_list|)
expr_stmt|;
name|slot
operator|->
name|local
operator|=
name|indexfile
expr_stmt|;
comment|/* If there is data present from a previous transfer attempt, 	   resume where it left off */
name|prev_posn
operator|=
name|ftell
argument_list|(
name|indexfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_posn
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Resuming fetch of index for pack %s at byte %ld\n"
argument_list|,
name|hex
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|range
argument_list|,
literal|"Range: bytes=%ld-"
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|range_header
operator|=
name|curl_slist_append
argument_list|(
name|range_header
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|range_header
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|indexfile
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to get pack index %s\n%s"
argument_list|,
name|url
argument_list|,
name|curl_errorstr
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|indexfile
argument_list|)
expr_stmt|;
return|return
name|move_temp_to_file
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setup_index
specifier|static
name|int
name|setup_index
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|new_pack
decl_stmt|;
if|if
condition|(
name|fetch_index
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|new_pack
operator|=
name|parse_pack_index
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|new_pack
operator|->
name|next
operator|=
name|remote
operator|->
name|packs
expr_stmt|;
name|remote
operator|->
name|packs
operator|=
name|new_pack
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fetch_indices
specifier|static
name|int
name|fetch_indices
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|struct
name|buffer
name|buffer
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|size
operator|=
literal|4096
expr_stmt|;
name|buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|buffer
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Getting pack list\n"
argument_list|)
expr_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|21
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s/objects/info/packs"
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|free
argument_list|(
name|buffer
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|http_code
operator|==
literal|404
condition|)
return|return
literal|0
return|;
else|else
return|return
name|error
argument_list|(
literal|"%s"
argument_list|,
name|curl_errorstr
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|buffer
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|data
operator|=
name|buffer
operator|.
name|buffer
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|buffer
operator|.
name|posn
condition|)
block|{
switch|switch
condition|(
name|data
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'P'
case|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|52
operator|<
name|buffer
operator|.
name|posn
operator|&&
operator|!
name|strncmp
argument_list|(
name|data
operator|+
name|i
argument_list|,
literal|" pack-"
argument_list|,
literal|6
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|data
operator|+
name|i
operator|+
literal|46
argument_list|,
literal|".pack\n"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|get_sha1_hex
argument_list|(
name|data
operator|+
name|i
operator|+
literal|6
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|setup_index
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|51
expr_stmt|;
break|break;
block|}
default|default:
while|while
condition|(
name|data
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
operator|.
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|needs_quote
specifier|static
specifier|inline
name|int
name|needs_quote
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'/'
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'A'
operator|...
literal|'Z'
case|:
case|case
literal|'a'
operator|...
literal|'z'
case|:
case|case
literal|'0'
operator|...
literal|'9'
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function
begin_function
DECL|function|hex
specifier|static
specifier|inline
name|int
name|hex
parameter_list|(
name|int
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|v
return|;
else|else
return|return
literal|'A'
operator|+
name|v
operator|-
literal|10
return|;
block|}
end_function
begin_function
DECL|function|quote_ref_url
specifier|static
name|char
modifier|*
name|quote_ref_url
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|qref
decl_stmt|;
name|int
name|len
decl_stmt|,
name|baselen
decl_stmt|,
name|ch
decl_stmt|;
name|baselen
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|len
operator|=
name|baselen
operator|+
literal|12
expr_stmt|;
comment|/* "refs/heads/" + NUL */
for|for
control|(
name|cp
operator|=
name|ref
init|;
operator|(
name|ch
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|0
condition|;
name|cp
operator|++
operator|,
name|len
operator|++
control|)
if|if
condition|(
name|needs_quote
argument_list|(
name|ch
argument_list|)
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
comment|/* extra two hex plus replacement % */
name|qref
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|qref
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|qref
operator|+
name|baselen
argument_list|,
literal|"refs/heads/"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|ref
operator|,
name|dp
operator|=
name|qref
operator|+
name|baselen
operator|+
literal|11
init|;
operator|(
name|ch
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|needs_quote
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|hex
argument_list|(
operator|(
name|ch
operator|>>
literal|4
operator|)
operator|&
literal|0xF
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|hex
argument_list|(
name|ch
operator|&
literal|0xF
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|dp
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
name|qref
return|;
block|}
end_function
begin_function
DECL|function|fetch_ref
name|int
name|fetch_ref
parameter_list|(
name|char
modifier|*
name|ref
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|url
decl_stmt|;
name|char
name|hex
index|[
literal|42
index|]
decl_stmt|;
name|struct
name|buffer
name|buffer
decl_stmt|;
name|char
modifier|*
name|base
init|=
name|remote
operator|->
name|url
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|buffer
operator|.
name|size
operator|=
literal|41
expr_stmt|;
name|buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|buffer
operator|=
name|hex
expr_stmt|;
name|hex
index|[
literal|41
index|]
operator|=
literal|'\0'
expr_stmt|;
name|url
operator|=
name|quote_ref_url
argument_list|(
name|base
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
return|return
name|error
argument_list|(
literal|"Couldn't get %s for %s\n%s"
argument_list|,
name|url
argument_list|,
name|ref
argument_list|,
name|curl_errorstr
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
name|hex
index|[
literal|40
index|]
operator|=
literal|'\0'
expr_stmt|;
name|get_sha1_hex
argument_list|(
name|hex
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|start_activelock_element
name|start_activelock_element
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|active_lock
modifier|*
name|lock
init|=
operator|(
expr|struct
name|active_lock
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|ctx_activelock
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:timeout"
argument_list|)
condition|)
name|lock
operator|->
name|ctx_timeout
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_owner
operator|&&
name|strstr
argument_list|(
name|name
argument_list|,
literal|"href"
argument_list|)
condition|)
name|lock
operator|->
name|ctx_owner_href
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_activelock
operator|&&
name|strstr
argument_list|(
name|name
argument_list|,
literal|"owner"
argument_list|)
condition|)
name|lock
operator|->
name|ctx_owner
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_locktoken
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:href"
argument_list|)
condition|)
name|lock
operator|->
name|ctx_locktoken_href
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_activelock
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:locktoken"
argument_list|)
condition|)
name|lock
operator|->
name|ctx_locktoken
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:activelock"
argument_list|)
condition|)
name|lock
operator|->
name|ctx_activelock
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|end_activelock_element
name|end_activelock_element
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|active_lock
modifier|*
name|lock
init|=
operator|(
expr|struct
name|active_lock
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|ctx_timeout
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:timeout"
argument_list|)
condition|)
block|{
name|lock
operator|->
name|ctx_timeout
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_owner_href
operator|&&
name|strstr
argument_list|(
name|name
argument_list|,
literal|"href"
argument_list|)
condition|)
block|{
name|lock
operator|->
name|ctx_owner_href
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_owner
operator|&&
name|strstr
argument_list|(
name|name
argument_list|,
literal|"owner"
argument_list|)
condition|)
block|{
name|lock
operator|->
name|ctx_owner
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_locktoken_href
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:href"
argument_list|)
condition|)
block|{
name|lock
operator|->
name|ctx_locktoken_href
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_locktoken
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:locktoken"
argument_list|)
condition|)
block|{
name|lock
operator|->
name|ctx_locktoken
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_activelock
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:activelock"
argument_list|)
condition|)
block|{
name|lock
operator|->
name|ctx_activelock
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|activelock_cdata
name|activelock_cdata
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|active_lock
modifier|*
name|lock
init|=
operator|(
expr|struct
name|active_lock
operator|*
operator|)
name|userData
decl_stmt|;
name|char
modifier|*
name|this
init|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|this
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|ctx_owner_href
condition|)
block|{
name|lock
operator|->
name|owner
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lock
operator|->
name|owner
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_locktoken_href
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|this
argument_list|,
literal|"opaquelocktoken:"
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|lock
operator|->
name|token
operator|=
name|malloc
argument_list|(
name|len
operator|-
literal|15
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lock
operator|->
name|token
argument_list|,
name|this
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lock
operator|->
name|ctx_timeout
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|this
argument_list|,
literal|"Second-"
argument_list|,
literal|7
argument_list|)
condition|)
name|lock
operator|->
name|timeout
operator|=
name|strtol
argument_list|(
name|this
operator|+
literal|7
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|start_lockprop_element
name|start_lockprop_element
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|lockprop
modifier|*
name|prop
init|=
operator|(
expr|struct
name|lockprop
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
name|prop
operator|->
name|lock_type
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:write"
argument_list|)
condition|)
block|{
if|if
condition|(
name|prop
operator|->
name|lock_exclusive
condition|)
block|{
name|prop
operator|->
name|lock_exclusive_write
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prop
operator|->
name|lock_scope
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:exclusive"
argument_list|)
condition|)
block|{
name|prop
operator|->
name|lock_exclusive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|->
name|lock_entry
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:lockscope"
argument_list|)
condition|)
block|{
name|prop
operator|->
name|lock_scope
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:locktype"
argument_list|)
condition|)
block|{
name|prop
operator|->
name|lock_type
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prop
operator|->
name|supported_lock
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:lockentry"
argument_list|)
condition|)
block|{
name|prop
operator|->
name|lock_entry
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:supportedlock"
argument_list|)
condition|)
block|{
name|prop
operator|->
name|supported_lock
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|end_lockprop_element
name|end_lockprop_element
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|lockprop
modifier|*
name|prop
init|=
operator|(
expr|struct
name|lockprop
operator|*
operator|)
name|userData
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:lockentry"
argument_list|)
condition|)
block|{
name|prop
operator|->
name|lock_entry
operator|=
literal|0
expr_stmt|;
name|prop
operator|->
name|lock_scope
operator|=
literal|0
expr_stmt|;
name|prop
operator|->
name|lock_type
operator|=
literal|0
expr_stmt|;
name|prop
operator|->
name|lock_exclusive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"D:supportedlock"
argument_list|)
condition|)
block|{
name|prop
operator|->
name|supported_lock
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|lock_remote
specifier|static
name|struct
name|active_lock
modifier|*
name|lock_remote
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|buffer
name|out_buffer
decl_stmt|;
name|struct
name|buffer
name|in_buffer
decl_stmt|;
name|char
modifier|*
name|out_data
decl_stmt|;
name|char
modifier|*
name|in_data
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|char
name|timeout_header
index|[
literal|25
index|]
decl_stmt|;
name|struct
name|active_lock
modifier|*
name|new_lock
decl_stmt|;
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Make sure leading directories exist for the remote ref */
name|ep
operator|=
name|strchr
argument_list|(
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|11
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_MKCOL
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
operator|&&
name|slot
operator|->
name|http_code
operator|!=
literal|405
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to create branch path %s\n"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start request\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|ep
operator|=
literal|'/'
expr_stmt|;
name|ep
operator|=
name|strchr
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|out_buffer
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|LOCK_REQUEST
argument_list|)
operator|+
name|strlen
argument_list|(
name|git_default_email
argument_list|)
operator|-
literal|2
expr_stmt|;
name|out_data
operator|=
name|xmalloc
argument_list|(
name|out_buffer
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|out_data
argument_list|,
name|out_buffer
operator|.
name|size
operator|+
literal|1
argument_list|,
name|LOCK_REQUEST
argument_list|,
name|git_default_email
argument_list|)
expr_stmt|;
name|out_buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
name|out_buffer
operator|.
name|buffer
operator|=
name|out_data
expr_stmt|;
name|in_buffer
operator|.
name|size
operator|=
literal|4096
expr_stmt|;
name|in_data
operator|=
name|xmalloc
argument_list|(
name|in_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|in_buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
name|in_buffer
operator|.
name|buffer
operator|=
name|in_data
expr_stmt|;
name|new_lock
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_lock
argument_list|)
argument_list|)
expr_stmt|;
name|new_lock
operator|->
name|owner
operator|=
name|NULL
expr_stmt|;
name|new_lock
operator|->
name|token
operator|=
name|NULL
expr_stmt|;
name|new_lock
operator|->
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
name|new_lock
operator|->
name|refreshing
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|timeout_header
argument_list|,
literal|"Timeout: Second-%ld"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|timeout_header
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|out_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|out_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_LOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got HTTP error %ld\n"
argument_list|,
name|slot
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|new_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start request\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|out_data
argument_list|)
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|new_lock
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|start_activelock_element
argument_list|,
name|end_activelock_element
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|activelock_cdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buffer
argument_list|,
name|in_buffer
operator|.
name|posn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|new_lock
operator|->
name|token
operator|==
name|NULL
operator|||
name|new_lock
operator|->
name|timeout
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|new_lock
operator|->
name|token
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|new_lock
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_lock
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|new_lock
operator|->
name|owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|new_lock
operator|->
name|url
operator|=
name|url
expr_stmt|;
name|new_lock
operator|->
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new_lock
return|;
block|}
end_function
begin_function
DECL|function|unlock_remote
specifier|static
name|int
name|unlock_remote
parameter_list|(
name|struct
name|active_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|lock_token_header
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|lock_token_header
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|31
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|lock_token_header
argument_list|,
literal|"Lock-Token:<opaquelocktoken:%s>"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|lock_token_header
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_UNLOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
name|rc
operator|=
literal|1
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got HTTP error %ld\n"
argument_list|,
name|slot
operator|->
name|http_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start request\n"
argument_list|)
expr_stmt|;
block|}
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock_token_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|check_locking
specifier|static
name|int
name|check_locking
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|buffer
name|in_buffer
decl_stmt|;
name|struct
name|buffer
name|out_buffer
decl_stmt|;
name|char
modifier|*
name|in_data
decl_stmt|;
name|char
modifier|*
name|out_data
decl_stmt|;
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|struct
name|lockprop
name|supported_lock
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|out_buffer
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|PROPFIND_REQUEST
argument_list|)
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|-
literal|2
expr_stmt|;
name|out_data
operator|=
name|xmalloc
argument_list|(
name|out_buffer
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|out_data
argument_list|,
name|out_buffer
operator|.
name|size
operator|+
literal|1
argument_list|,
name|PROPFIND_REQUEST
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|out_buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
name|out_buffer
operator|.
name|buffer
operator|=
name|out_data
expr_stmt|;
name|in_buffer
operator|.
name|size
operator|=
literal|4096
expr_stmt|;
name|in_data
operator|=
name|xmalloc
argument_list|(
name|in_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|in_buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
name|in_buffer
operator|.
name|buffer
operator|=
name|in_data
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Depth: 0"
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|out_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|out_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PROPFIND
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|free
argument_list|(
name|in_buffer
operator|.
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|supported_lock
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|start_lockprop_element
argument_list|,
name|end_lockprop_element
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buffer
argument_list|,
name|in_buffer
operator|.
name|posn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_buffer
operator|.
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
return|return
name|error
argument_list|(
literal|"%s"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|out_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_buffer
operator|.
name|buffer
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
if|if
condition|(
name|supported_lock
operator|.
name|lock_exclusive_write
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|is_ancestor
specifier|static
name|int
name|is_ancestor
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return
literal|0
return|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
for|for
control|(
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|sha1
argument_list|,
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|20
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|type
operator|==
name|commit_type
condition|)
block|{
if|if
condition|(
name|is_ancestor
argument_list|(
name|sha1
argument_list|,
operator|(
expr|struct
name|commit
operator|*
operator|)
operator|&
name|parents
operator|->
name|item
operator|->
name|object
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_delta
specifier|static
name|void
name|get_delta
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|struct
name|active_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|tree_entry_list
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|sha1
operator|&&
operator|!
name|memcmp
argument_list|(
name|sha1
argument_list|,
name|obj
operator|->
name|sha1
argument_list|,
literal|20
argument_list|)
condition|)
return|return;
if|if
condition|(
name|aborted
condition|)
return|return;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|commit_type
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"walk %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|add_request
argument_list|(
name|obj
operator|->
name|sha1
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|commit
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error parsing commit %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
for|for
control|(
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
if|if
condition|(
name|sha1
operator|==
name|NULL
operator|||
name|memcmp
argument_list|(
name|sha1
argument_list|,
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|20
argument_list|)
condition|)
name|get_delta
argument_list|(
name|sha1
argument_list|,
operator|&
name|parents
operator|->
name|item
operator|->
name|object
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|get_delta
argument_list|(
name|sha1
argument_list|,
operator|&
name|commit
operator|->
name|tree
operator|->
name|object
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|tree_type
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"walk %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|add_request
argument_list|(
name|obj
operator|->
name|sha1
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|tree
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
name|obj
expr_stmt|;
if|if
condition|(
name|parse_tree
argument_list|(
name|tree
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error parsing tree %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|entry
operator|=
name|tree
operator|->
name|entries
expr_stmt|;
name|tree
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|struct
name|tree_entry_list
modifier|*
name|next
init|=
name|entry
operator|->
name|next
decl_stmt|;
name|get_delta
argument_list|(
name|sha1
argument_list|,
name|entry
operator|->
name|item
operator|.
name|any
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|blob_type
operator|||
name|obj
operator|->
name|type
operator|==
name|tag_type
condition|)
block|{
name|add_request
argument_list|(
name|obj
operator|->
name|sha1
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|update_remote
specifier|static
name|int
name|update_remote
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|active_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|out_data
decl_stmt|;
name|char
modifier|*
name|if_header
decl_stmt|;
name|struct
name|buffer
name|out_buffer
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|if_header
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|25
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|if_header
argument_list|,
literal|"If: (<opaquelocktoken:%s>)"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|if_header
argument_list|)
expr_stmt|;
name|out_buffer
operator|.
name|size
operator|=
literal|41
expr_stmt|;
name|out_data
operator|=
name|xmalloc
argument_list|(
name|out_buffer
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|snprintf
argument_list|(
name|out_data
argument_list|,
name|out_buffer
operator|.
name|size
operator|+
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|out_buffer
operator|.
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to initialize PUT request body\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|out_buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
name|out_buffer
operator|.
name|buffer
operator|=
name|out_data
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|out_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|out_buffer
operator|.
name|size
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PUT
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_PUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|if_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT error: curl result=%d, HTTP code=%ld\n"
argument_list|,
name|slot
operator|->
name|curl_result
argument_list|,
name|slot
operator|->
name|http_code
argument_list|)
expr_stmt|;
comment|/* We should attempt recovery? */
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|out_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|if_header
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start PUT request\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
decl_stmt|;
name|struct
name|transfer_request
modifier|*
name|next_request
decl_stmt|;
name|int
name|nr_refspec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|refspec
init|=
name|NULL
decl_stmt|;
name|int
name|do_remote_update
decl_stmt|;
name|int
name|new_branch
decl_stmt|;
name|int
name|force_this
decl_stmt|;
name|char
modifier|*
name|local_ref
decl_stmt|;
name|unsigned
name|char
name|local_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|local_object
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|remote_ref
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|remote_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|active_lock
modifier|*
name|remote_lock
decl_stmt|;
name|char
modifier|*
name|remote_path
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|setup_ident
argument_list|()
expr_stmt|;
name|remote
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|remote
operator|->
name|packs
operator|=
name|NULL
expr_stmt|;
name|argv
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|argv
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
operator|*
name|argv
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--complete"
argument_list|)
condition|)
block|{
name|push_all
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--force"
argument_list|)
condition|)
block|{
name|force_all
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|push_verbosely
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|usage
argument_list|(
name|http_push_usage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|remote
operator|->
name|url
condition|)
block|{
name|remote
operator|->
name|url
operator|=
name|arg
expr_stmt|;
continue|continue;
block|}
name|refspec
operator|=
name|argv
expr_stmt|;
name|nr_refspec
operator|=
name|argc
operator|-
name|i
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
name|remote_dir_exists
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|http_init
argument_list|()
expr_stmt|;
name|no_pragma_header
operator|=
name|curl_slist_append
argument_list|(
name|no_pragma_header
argument_list|,
literal|"Pragma:"
argument_list|)
expr_stmt|;
name|default_headers
operator|=
name|curl_slist_append
argument_list|(
name|default_headers
argument_list|,
literal|"Range:"
argument_list|)
expr_stmt|;
name|default_headers
operator|=
name|curl_slist_append
argument_list|(
name|default_headers
argument_list|,
literal|"Destination:"
argument_list|)
expr_stmt|;
name|default_headers
operator|=
name|curl_slist_append
argument_list|(
name|default_headers
argument_list|,
literal|"If:"
argument_list|)
expr_stmt|;
name|default_headers
operator|=
name|curl_slist_append
argument_list|(
name|default_headers
argument_list|,
literal|"Pragma: no-cache"
argument_list|)
expr_stmt|;
comment|/* Verify DAV compliance/lock support */
if|if
condition|(
name|check_locking
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: no DAV locking support on remote repo %s\n"
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Process each refspec */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|force_this
operator|=
literal|0
expr_stmt|;
name|do_remote_update
operator|=
literal|0
expr_stmt|;
name|new_branch
operator|=
literal|0
expr_stmt|;
name|local_ref
operator|=
name|refspec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|local_ref
operator|==
literal|'+'
condition|)
block|{
name|force_this
operator|=
literal|1
expr_stmt|;
name|local_ref
operator|++
expr_stmt|;
block|}
name|ep
operator|=
name|strchr
argument_list|(
name|local_ref
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
condition|)
block|{
name|remote_ref
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|remote_ref
operator|=
name|local_ref
expr_stmt|;
comment|/* Lock remote branch ref */
if|if
condition|(
name|remote_path
condition|)
name|free
argument_list|(
name|remote_path
argument_list|)
expr_stmt|;
name|remote_path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote_ref
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|remote_path
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|remote_ref
argument_list|)
expr_stmt|;
name|remote_lock
operator|=
name|lock_remote
argument_list|(
name|remote_path
argument_list|,
name|LOCK_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_lock
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to lock remote branch %s\n"
argument_list|,
name|remote_ref
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Resolve local and remote refs */
if|if
condition|(
name|fetch_ref
argument_list|(
name|remote_ref
argument_list|,
name|remote_sha1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote branch %s does not exist on %s\n"
argument_list|,
name|remote_ref
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|new_branch
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|get_sha1
argument_list|(
name|local_ref
argument_list|,
name|local_sha1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error resolving local branch %s\n"
argument_list|,
name|local_ref
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* Find relationship between local and remote */
name|local_object
operator|=
name|parse_object
argument_list|(
name|local_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_object
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to parse local object %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|local_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
elseif|else
if|if
condition|(
name|new_branch
condition|)
block|{
name|do_remote_update
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|local_sha1
argument_list|,
name|remote_sha1
argument_list|,
literal|20
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s: same as branch '%s' of %s\n"
argument_list|,
name|local_ref
argument_list|,
name|remote_ref
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_ancestor
argument_list|(
name|remote_sha1
argument_list|,
operator|(
expr|struct
name|commit
operator|*
operator|)
name|local_object
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote %s will fast-forward to local %s\n"
argument_list|,
name|remote_ref
argument_list|,
name|local_ref
argument_list|)
expr_stmt|;
name|do_remote_update
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force_all
operator|||
name|force_this
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s on %s does not fast forward to local branch '%s', overwriting\n"
argument_list|,
name|remote_ref
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|local_ref
argument_list|)
expr_stmt|;
name|do_remote_update
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s on %s does not fast forward to local branch '%s'\n"
argument_list|,
name|remote_ref
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|local_ref
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
comment|/* Generate and check list of required objects */
name|pushing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|do_remote_update
operator|||
name|push_all
condition|)
name|fetch_indices
argument_list|()
expr_stmt|;
name|get_delta
argument_list|(
name|push_all
condition|?
name|NULL
else|:
name|remote_sha1
argument_list|,
name|local_object
argument_list|,
name|remote_lock
argument_list|)
expr_stmt|;
name|finish_all_active_slots
argument_list|()
expr_stmt|;
comment|/* Push missing objects to remote, this would be a 		   convenient time to pack them first if appropriate. */
name|pushing
operator|=
literal|1
expr_stmt|;
name|fill_active_slots
argument_list|()
expr_stmt|;
name|finish_all_active_slots
argument_list|()
expr_stmt|;
comment|/* Update the remote branch if all went well */
if|if
condition|(
name|do_remote_update
condition|)
block|{
if|if
condition|(
operator|!
name|aborted
operator|&&
name|update_remote
argument_list|(
name|local_sha1
argument_list|,
name|remote_lock
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s remote branch %s\n"
argument_list|,
name|new_branch
condition|?
literal|"Created"
else|:
literal|"Updated"
argument_list|,
name|remote_ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to %s remote branch %s\n"
argument_list|,
name|new_branch
condition|?
literal|"create"
else|:
literal|"update"
argument_list|,
name|remote_ref
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
name|unlock
label|:
name|unlock_remote
argument_list|(
name|remote_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote_path
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|free
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|no_pragma_header
argument_list|)
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|default_headers
argument_list|)
expr_stmt|;
name|http_cleanup
argument_list|()
expr_stmt|;
name|request
operator|=
name|request_queue_head
expr_stmt|;
while|while
condition|(
name|request
operator|!=
name|NULL
condition|)
block|{
name|next_request
operator|=
name|request
operator|->
name|next
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|request
operator|=
name|next_request
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ifdef USE_CURL_MULTI */
end_comment
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"http-push requires curl 7.9.8 or higher.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
end_unit
