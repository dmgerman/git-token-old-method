begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"http.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"list-objects.h"
end_include
begin_include
include|#
directive|include
file|"sigchain.h"
end_include
begin_include
include|#
directive|include
file|<expat.h>
end_include
begin_decl_stmt
DECL|variable|http_push_usage
specifier|static
specifier|const
name|char
name|http_push_usage
index|[]
init|=
literal|"git http-push [--all] [--dry-run] [--force] [--verbose]<remote> [<head>...]\n"
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|XML_STATUS_OK
end_ifndef
begin_enum
DECL|enum|XML_Status
enum|enum
name|XML_Status
block|{
DECL|enumerator|XML_STATUS_OK
name|XML_STATUS_OK
init|=
literal|1
block|,
DECL|enumerator|XML_STATUS_ERROR
name|XML_STATUS_ERROR
init|=
literal|0
block|}
enum|;
end_enum
begin_define
DECL|macro|XML_STATUS_OK
define|#
directive|define
name|XML_STATUS_OK
value|1
end_define
begin_define
DECL|macro|XML_STATUS_ERROR
define|#
directive|define
name|XML_STATUS_ERROR
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|PREV_BUF_SIZE
define|#
directive|define
name|PREV_BUF_SIZE
value|4096
end_define
begin_comment
comment|/* DAV methods */
end_comment
begin_define
DECL|macro|DAV_LOCK
define|#
directive|define
name|DAV_LOCK
value|"LOCK"
end_define
begin_define
DECL|macro|DAV_MKCOL
define|#
directive|define
name|DAV_MKCOL
value|"MKCOL"
end_define
begin_define
DECL|macro|DAV_MOVE
define|#
directive|define
name|DAV_MOVE
value|"MOVE"
end_define
begin_define
DECL|macro|DAV_PROPFIND
define|#
directive|define
name|DAV_PROPFIND
value|"PROPFIND"
end_define
begin_define
DECL|macro|DAV_PUT
define|#
directive|define
name|DAV_PUT
value|"PUT"
end_define
begin_define
DECL|macro|DAV_UNLOCK
define|#
directive|define
name|DAV_UNLOCK
value|"UNLOCK"
end_define
begin_define
DECL|macro|DAV_DELETE
define|#
directive|define
name|DAV_DELETE
value|"DELETE"
end_define
begin_comment
comment|/* DAV lock flags */
end_comment
begin_define
DECL|macro|DAV_PROP_LOCKWR
define|#
directive|define
name|DAV_PROP_LOCKWR
value|(1u<< 0)
end_define
begin_define
DECL|macro|DAV_PROP_LOCKEX
define|#
directive|define
name|DAV_PROP_LOCKEX
value|(1u<< 1)
end_define
begin_define
DECL|macro|DAV_LOCK_OK
define|#
directive|define
name|DAV_LOCK_OK
value|(1u<< 2)
end_define
begin_comment
comment|/* DAV XML properties */
end_comment
begin_define
DECL|macro|DAV_CTX_LOCKENTRY
define|#
directive|define
name|DAV_CTX_LOCKENTRY
value|".multistatus.response.propstat.prop.supportedlock.lockentry"
end_define
begin_define
DECL|macro|DAV_CTX_LOCKTYPE_WRITE
define|#
directive|define
name|DAV_CTX_LOCKTYPE_WRITE
value|".multistatus.response.propstat.prop.supportedlock.lockentry.locktype.write"
end_define
begin_define
DECL|macro|DAV_CTX_LOCKTYPE_EXCLUSIVE
define|#
directive|define
name|DAV_CTX_LOCKTYPE_EXCLUSIVE
value|".multistatus.response.propstat.prop.supportedlock.lockentry.lockscope.exclusive"
end_define
begin_define
DECL|macro|DAV_ACTIVELOCK_OWNER
define|#
directive|define
name|DAV_ACTIVELOCK_OWNER
value|".prop.lockdiscovery.activelock.owner.href"
end_define
begin_define
DECL|macro|DAV_ACTIVELOCK_TIMEOUT
define|#
directive|define
name|DAV_ACTIVELOCK_TIMEOUT
value|".prop.lockdiscovery.activelock.timeout"
end_define
begin_define
DECL|macro|DAV_ACTIVELOCK_TOKEN
define|#
directive|define
name|DAV_ACTIVELOCK_TOKEN
value|".prop.lockdiscovery.activelock.locktoken.href"
end_define
begin_define
DECL|macro|DAV_PROPFIND_RESP
define|#
directive|define
name|DAV_PROPFIND_RESP
value|".multistatus.response"
end_define
begin_define
DECL|macro|DAV_PROPFIND_NAME
define|#
directive|define
name|DAV_PROPFIND_NAME
value|".multistatus.response.href"
end_define
begin_define
DECL|macro|DAV_PROPFIND_COLLECTION
define|#
directive|define
name|DAV_PROPFIND_COLLECTION
value|".multistatus.response.propstat.prop.resourcetype.collection"
end_define
begin_comment
comment|/* DAV request body templates */
end_comment
begin_define
DECL|macro|PROPFIND_SUPPORTEDLOCK_REQUEST
define|#
directive|define
name|PROPFIND_SUPPORTEDLOCK_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n<D:prop xmlns:R=\"%s\">\n<D:supportedlock/>\n</D:prop>\n</D:propfind>"
end_define
begin_define
DECL|macro|PROPFIND_ALL_REQUEST
define|#
directive|define
name|PROPFIND_ALL_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n<D:allprop/>\n</D:propfind>"
end_define
begin_define
DECL|macro|LOCK_REQUEST
define|#
directive|define
name|LOCK_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n<D:owner>\n<D:href>mailto:%s</D:href>\n</D:owner>\n</D:lockinfo>"
end_define
begin_define
DECL|macro|LOCK_TIME
define|#
directive|define
name|LOCK_TIME
value|600
end_define
begin_define
DECL|macro|LOCK_REFRESH
define|#
directive|define
name|LOCK_REFRESH
value|30
end_define
begin_comment
comment|/* bits #0-15 in revision.h */
end_comment
begin_define
DECL|macro|LOCAL
define|#
directive|define
name|LOCAL
value|(1u<<16)
end_define
begin_define
DECL|macro|REMOTE
define|#
directive|define
name|REMOTE
value|(1u<<17)
end_define
begin_define
DECL|macro|FETCHING
define|#
directive|define
name|FETCHING
value|(1u<<18)
end_define
begin_define
DECL|macro|PUSHING
define|#
directive|define
name|PUSHING
value|(1u<<19)
end_define
begin_comment
comment|/* We allow "recursive" symbolic refs. Only within reason, though */
end_comment
begin_define
DECL|macro|MAXDEPTH
define|#
directive|define
name|MAXDEPTH
value|5
end_define
begin_decl_stmt
DECL|variable|pushing
specifier|static
name|int
name|pushing
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|aborted
specifier|static
name|int
name|aborted
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remote_dir_exists
specifier|static
name|signed
name|char
name|remote_dir_exists
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|push_verbosely
specifier|static
name|int
name|push_verbosely
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|push_all
specifier|static
name|int
name|push_all
init|=
name|MATCH_REFS_NONE
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|force_all
specifier|static
name|int
name|force_all
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|dry_run
specifier|static
name|int
name|dry_run
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|helper_status
specifier|static
name|int
name|helper_status
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|objects
specifier|static
name|struct
name|object_list
modifier|*
name|objects
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|repo
struct|struct
name|repo
block|{
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|path
name|char
modifier|*
name|path
decl_stmt|;
DECL|member|path_len
name|int
name|path_len
decl_stmt|;
DECL|member|has_info_refs
name|int
name|has_info_refs
decl_stmt|;
DECL|member|can_update_info_refs
name|int
name|can_update_info_refs
decl_stmt|;
DECL|member|has_info_packs
name|int
name|has_info_packs
decl_stmt|;
DECL|member|packs
name|struct
name|packed_git
modifier|*
name|packs
decl_stmt|;
DECL|member|locks
name|struct
name|remote_lock
modifier|*
name|locks
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|repo
specifier|static
name|struct
name|repo
modifier|*
name|repo
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|transfer_state
enum|enum
name|transfer_state
block|{
DECL|enumerator|NEED_FETCH
name|NEED_FETCH
block|,
DECL|enumerator|RUN_FETCH_LOOSE
name|RUN_FETCH_LOOSE
block|,
DECL|enumerator|RUN_FETCH_PACKED
name|RUN_FETCH_PACKED
block|,
DECL|enumerator|NEED_PUSH
name|NEED_PUSH
block|,
DECL|enumerator|RUN_MKCOL
name|RUN_MKCOL
block|,
DECL|enumerator|RUN_PUT
name|RUN_PUT
block|,
DECL|enumerator|RUN_MOVE
name|RUN_MOVE
block|,
DECL|enumerator|ABORTED
name|ABORTED
block|,
DECL|enumerator|COMPLETE
name|COMPLETE
block|}
enum|;
end_enum
begin_struct
DECL|struct|transfer_request
struct|struct
name|transfer_request
block|{
DECL|member|obj
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|dest
name|char
modifier|*
name|dest
decl_stmt|;
DECL|member|lock
name|struct
name|remote_lock
modifier|*
name|lock
decl_stmt|;
DECL|member|headers
name|struct
name|curl_slist
modifier|*
name|headers
decl_stmt|;
DECL|member|buffer
name|struct
name|buffer
name|buffer
decl_stmt|;
DECL|member|state
name|enum
name|transfer_state
name|state
decl_stmt|;
DECL|member|curl_result
name|CURLcode
name|curl_result
decl_stmt|;
DECL|member|errorstr
name|char
name|errorstr
index|[
name|CURL_ERROR_SIZE
index|]
decl_stmt|;
DECL|member|http_code
name|long
name|http_code
decl_stmt|;
DECL|member|userData
name|void
modifier|*
name|userData
decl_stmt|;
DECL|member|slot
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
DECL|member|next
name|struct
name|transfer_request
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|request_queue_head
specifier|static
name|struct
name|transfer_request
modifier|*
name|request_queue_head
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|xml_ctx
struct|struct
name|xml_ctx
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|cdata
name|char
modifier|*
name|cdata
decl_stmt|;
DECL|member|userFunc
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
function_decl|;
DECL|member|userData
name|void
modifier|*
name|userData
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|remote_lock
struct|struct
name|remote_lock
block|{
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|owner
name|char
modifier|*
name|owner
decl_stmt|;
DECL|member|token
name|char
modifier|*
name|token
decl_stmt|;
DECL|member|tmpfile_suffix
name|char
name|tmpfile_suffix
index|[
literal|41
index|]
decl_stmt|;
DECL|member|start_time
name|time_t
name|start_time
decl_stmt|;
DECL|member|timeout
name|long
name|timeout
decl_stmt|;
DECL|member|refreshing
name|int
name|refreshing
decl_stmt|;
DECL|member|next
name|struct
name|remote_lock
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Flags that control remote_ls processing */
end_comment
begin_define
DECL|macro|PROCESS_FILES
define|#
directive|define
name|PROCESS_FILES
value|(1u<< 0)
end_define
begin_define
DECL|macro|PROCESS_DIRS
define|#
directive|define
name|PROCESS_DIRS
value|(1u<< 1)
end_define
begin_define
DECL|macro|RECURSIVE
define|#
directive|define
name|RECURSIVE
value|(1u<< 2)
end_define
begin_comment
comment|/* Flags that remote_ls passes to callback functions */
end_comment
begin_define
DECL|macro|IS_DIR
define|#
directive|define
name|IS_DIR
value|(1u<< 0)
end_define
begin_struct
DECL|struct|remote_ls_ctx
struct|struct
name|remote_ls_ctx
block|{
DECL|member|path
name|char
modifier|*
name|path
decl_stmt|;
DECL|member|userFunc
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
function_decl|;
DECL|member|userData
name|void
modifier|*
name|userData
decl_stmt|;
DECL|member|flags
name|int
name|flags
decl_stmt|;
DECL|member|dentry_name
name|char
modifier|*
name|dentry_name
decl_stmt|;
DECL|member|dentry_flags
name|int
name|dentry_flags
decl_stmt|;
DECL|member|parent
name|struct
name|remote_ls_ctx
modifier|*
name|parent
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* get_dav_token_headers options */
end_comment
begin_enum
DECL|enum|dav_header_flag
enum|enum
name|dav_header_flag
block|{
DECL|enumerator|DAV_HEADER_IF
name|DAV_HEADER_IF
init|=
operator|(
literal|1u
operator|<<
literal|0
operator|)
block|,
DECL|enumerator|DAV_HEADER_LOCK
name|DAV_HEADER_LOCK
init|=
operator|(
literal|1u
operator|<<
literal|1
operator|)
block|,
DECL|enumerator|DAV_HEADER_TIMEOUT
name|DAV_HEADER_TIMEOUT
init|=
operator|(
literal|1u
operator|<<
literal|2
operator|)
block|}
enum|;
end_enum
begin_function
DECL|function|xml_entities
specifier|static
name|char
modifier|*
name|xml_entities
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|size_t
name|len
init|=
name|strcspn
argument_list|(
name|s
argument_list|,
literal|"\"<>&"
argument_list|)
decl_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'"'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"&quot;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
return|return
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|s
operator|++
expr_stmt|;
block|}
return|return
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|curl_setup_http_get
specifier|static
name|void
name|curl_setup_http_get
parameter_list|(
name|CURL
modifier|*
name|curl
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|custom_req
parameter_list|)
block|{
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|custom_req
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|curl_setup_http
specifier|static
name|void
name|curl_setup_http
parameter_list|(
name|CURL
modifier|*
name|curl
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|custom_req
parameter_list|,
name|struct
name|buffer
modifier|*
name|buffer
parameter_list|,
name|curl_write_callback
name|write_fn
parameter_list|)
block|{
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_PUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|buffer
operator|->
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_CURL_IOCTL
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_IOCTLFUNCTION
argument_list|,
name|ioctl_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_IOCTLDATA
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|write_fn
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|custom_req
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_dav_token_headers
specifier|static
name|struct
name|curl_slist
modifier|*
name|get_dav_token_headers
parameter_list|(
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|,
name|enum
name|dav_header_flag
name|options
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|options
operator|&
name|DAV_HEADER_IF
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"If: (<%s>)"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|DAV_HEADER_LOCK
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"Lock-Token:<%s>"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|DAV_HEADER_TIMEOUT
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"Timeout: Second-%ld"
argument_list|,
name|lock
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|dav_headers
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|finish_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|release_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|process_response
specifier|static
name|void
name|process_response
parameter_list|(
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
operator|(
expr|struct
name|transfer_request
operator|*
operator|)
name|callback_data
decl_stmt|;
name|finish_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
end_ifdef
begin_function
DECL|function|start_fetch_loose
specifier|static
name|void
name|start_fetch_loose
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|http_object_request
modifier|*
name|obj_req
decl_stmt|;
name|obj_req
operator|=
name|new_http_object_request
argument_list|(
name|repo
operator|->
name|url
argument_list|,
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_req
operator|==
name|NULL
condition|)
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
return|return;
block|}
name|slot
operator|=
name|obj_req
operator|->
name|slot
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|userData
operator|=
name|obj_req
expr_stmt|;
comment|/* Try to get the request started, abort the request on error */
name|request
operator|->
name|state
operator|=
name|RUN_FETCH_LOOSE
expr_stmt|;
if|if
condition|(
operator|!
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start GET request\n"
argument_list|)
expr_stmt|;
name|repo
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|release_http_object_request
argument_list|(
name|obj_req
argument_list|)
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_mkcol
specifier|static
name|void
name|start_mkcol
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|request
operator|->
name|url
operator|=
name|get_remote_object_url
argument_list|(
name|repo
operator|->
name|url
argument_list|,
name|hex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_setup_http_get
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|request
operator|->
name|url
argument_list|,
name|DAV_MKCOL
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_ERRORBUFFER
argument_list|,
name|request
operator|->
name|errorstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_MKCOL
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|start_fetch_packed
specifier|static
name|void
name|start_fetch_packed
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|target
decl_stmt|;
name|struct
name|transfer_request
modifier|*
name|check_request
init|=
name|request_queue_head
decl_stmt|;
name|struct
name|http_pack_request
modifier|*
name|preq
decl_stmt|;
name|target
operator|=
name|find_sha1_pack
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|,
name|repo
operator|->
name|packs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to fetch %s, will not be able to update server info refs\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|repo
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fetching pack %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|target
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" which contains %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|preq
operator|=
name|new_http_pack_request
argument_list|(
name|target
argument_list|,
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|preq
operator|==
name|NULL
condition|)
block|{
name|release_http_pack_request
argument_list|(
name|preq
argument_list|)
expr_stmt|;
name|repo
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|preq
operator|->
name|lst
operator|=
operator|&
name|repo
operator|->
name|packs
expr_stmt|;
comment|/* Make sure there isn't another open request for this pack */
while|while
condition|(
name|check_request
condition|)
block|{
if|if
condition|(
name|check_request
operator|->
name|state
operator|==
name|RUN_FETCH_PACKED
operator|&&
operator|!
name|strcmp
argument_list|(
name|check_request
operator|->
name|url
argument_list|,
name|preq
operator|->
name|url
argument_list|)
condition|)
block|{
name|release_http_pack_request
argument_list|(
name|preq
argument_list|)
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
name|check_request
operator|=
name|check_request
operator|->
name|next
expr_stmt|;
block|}
name|preq
operator|->
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|preq
operator|->
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|request
operator|->
name|slot
operator|=
name|preq
operator|->
name|slot
expr_stmt|;
name|request
operator|->
name|userData
operator|=
name|preq
expr_stmt|;
comment|/* Try to get the request started, abort the request on error */
name|request
operator|->
name|state
operator|=
name|RUN_FETCH_PACKED
expr_stmt|;
if|if
condition|(
operator|!
name|start_active_slot
argument_list|(
name|preq
operator|->
name|slot
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start GET request\n"
argument_list|)
expr_stmt|;
name|release_http_pack_request
argument_list|(
name|preq
argument_list|)
expr_stmt|;
name|repo
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_put
specifier|static
name|void
name|start_put
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
name|hdr
index|[
literal|50
index|]
decl_stmt|;
name|void
modifier|*
name|unpacked
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|git_zstream
name|stream
decl_stmt|;
name|unpacked
operator|=
name|read_sha1_file
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Set it up */
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|git_deflate_init
argument_list|(
operator|&
name|stream
argument_list|,
name|zlib_compression_level
argument_list|)
expr_stmt|;
name|size
operator|=
name|git_deflate_bound
argument_list|(
operator|&
name|stream
argument_list|,
name|len
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|request
operator|->
name|buffer
operator|.
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|request
operator|->
name|buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
comment|/* Compress it */
name|stream
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|request
operator|->
name|buffer
operator|.
name|buf
operator|.
name|buf
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
comment|/* First header.. */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|hdr
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|hdrlen
expr_stmt|;
while|while
condition|(
name|git_deflate
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|)
operator|==
name|Z_OK
condition|)
empty_stmt|;
comment|/* nothing */
comment|/* Then the data itself.. */
name|stream
operator|.
name|next_in
operator|=
name|unpacked
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|git_deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
empty_stmt|;
comment|/* nothing */
name|git_deflate_end
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unpacked
argument_list|)
expr_stmt|;
name|request
operator|->
name|buffer
operator|.
name|buf
operator|.
name|len
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"Destination: "
argument_list|)
expr_stmt|;
name|append_remote_object_url
argument_list|(
operator|&
name|buf
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|hex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|request
operator|->
name|dest
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_remote_object_url
argument_list|(
operator|&
name|buf
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|hex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|request
operator|->
name|lock
operator|->
name|tmpfile_suffix
argument_list|,
literal|41
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_setup_http
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|request
operator|->
name|url
argument_list|,
name|DAV_PUT
argument_list|,
operator|&
name|request
operator|->
name|buffer
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_PUT
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_move
specifier|static
name|void
name|start_move
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_setup_http_get
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|request
operator|->
name|url
argument_list|,
name|DAV_MOVE
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|request
operator|->
name|dest
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Overwrite: T"
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_MOVE
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|refresh_lock
specifier|static
name|int
name|refresh_lock
parameter_list|(
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|lock
operator|->
name|refreshing
operator|=
literal|1
expr_stmt|;
name|dav_headers
operator|=
name|get_dav_token_headers
argument_list|(
name|lock
argument_list|,
name|DAV_HEADER_IF
operator||
name|DAV_HEADER_TIMEOUT
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http_get
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|lock
operator|->
name|url
argument_list|,
name|DAV_LOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LOCK HTTP error %ld\n"
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock
operator|->
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|lock
operator|->
name|refreshing
operator|=
literal|0
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|check_locks
specifier|static
name|void
name|check_locks
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_lock
modifier|*
name|lock
init|=
name|repo
operator|->
name|locks
decl_stmt|;
name|time_t
name|current_time
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|time_remaining
decl_stmt|;
while|while
condition|(
name|lock
condition|)
block|{
name|time_remaining
operator|=
name|lock
operator|->
name|start_time
operator|+
name|lock
operator|->
name|timeout
operator|-
name|current_time
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|->
name|refreshing
operator|&&
name|time_remaining
operator|<
name|LOCK_REFRESH
condition|)
block|{
if|if
condition|(
operator|!
name|refresh_lock
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to refresh lock for %s\n"
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|lock
operator|=
name|lock
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|release_request
specifier|static
name|void
name|release_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|entry
init|=
name|request_queue_head
decl_stmt|;
if|if
condition|(
name|request
operator|==
name|request_queue_head
condition|)
block|{
name|request_queue_head
operator|=
name|request
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|next
operator|!=
name|request
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|==
name|request
condition|)
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|next
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finish_request
specifier|static
name|void
name|finish_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|http_pack_request
modifier|*
name|preq
decl_stmt|;
name|struct
name|http_object_request
modifier|*
name|obj_req
decl_stmt|;
name|request
operator|->
name|curl_result
operator|=
name|request
operator|->
name|slot
operator|->
name|curl_result
expr_stmt|;
name|request
operator|->
name|http_code
operator|=
name|request
operator|->
name|slot
operator|->
name|http_code
expr_stmt|;
name|request
operator|->
name|slot
operator|=
name|NULL
expr_stmt|;
comment|/* Keep locks active */
name|check_locks
argument_list|()
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|headers
operator|!=
name|NULL
condition|)
name|curl_slist_free_all
argument_list|(
name|request
operator|->
name|headers
argument_list|)
expr_stmt|;
comment|/* URL is reused for MOVE after PUT */
if|if
condition|(
name|request
operator|->
name|state
operator|!=
name|RUN_PUT
condition|)
block|{
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_MKCOL
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
operator|||
name|request
operator|->
name|http_code
operator|==
literal|405
condition|)
block|{
name|remote_dir_exists
index|[
name|request
operator|->
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|start_put
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MKCOL %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_PUT
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|start_move
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_MOVE
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    sent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|obj
operator|->
name|flags
operator||=
name|REMOTE
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MOVE %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_FETCH_LOOSE
condition|)
block|{
name|obj_req
operator|=
operator|(
expr|struct
name|http_object_request
operator|*
operator|)
name|request
operator|->
name|userData
expr_stmt|;
if|if
condition|(
name|finish_http_object_request
argument_list|(
name|obj_req
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|obj_req
operator|->
name|rename
operator|==
literal|0
condition|)
name|request
operator|->
name|obj
operator|->
name|flags
operator||=
operator|(
name|LOCAL
operator||
name|REMOTE
operator|)
expr_stmt|;
comment|/* Try fetching packed if necessary */
if|if
condition|(
name|request
operator|->
name|obj
operator|->
name|flags
operator|&
name|LOCAL
condition|)
block|{
name|release_http_object_request
argument_list|(
name|obj_req
argument_list|)
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
name|start_fetch_packed
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_FETCH_PACKED
condition|)
block|{
name|int
name|fail
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|request
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to get pack file %s\n%s"
argument_list|,
name|request
operator|->
name|url
argument_list|,
name|curl_errorstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|preq
operator|=
operator|(
expr|struct
name|http_pack_request
operator|*
operator|)
name|request
operator|->
name|userData
expr_stmt|;
if|if
condition|(
name|preq
condition|)
block|{
if|if
condition|(
name|finish_http_pack_request
argument_list|(
name|preq
argument_list|)
operator|==
literal|0
condition|)
name|fail
operator|=
literal|0
expr_stmt|;
name|release_http_pack_request
argument_list|(
name|preq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fail
condition|)
name|repo
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
end_ifdef
begin_decl_stmt
DECL|variable|is_running_queue
specifier|static
name|int
name|is_running_queue
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|fill_active_slot
specifier|static
name|int
name|fill_active_slot
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
decl_stmt|;
if|if
condition|(
name|aborted
operator|||
operator|!
name|is_running_queue
condition|)
return|return
literal|0
return|;
for|for
control|(
name|request
operator|=
name|request_queue_head
init|;
name|request
condition|;
name|request
operator|=
name|request
operator|->
name|next
control|)
block|{
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|NEED_FETCH
condition|)
block|{
name|start_fetch_loose
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|pushing
operator|&&
name|request
operator|->
name|state
operator|==
name|NEED_PUSH
condition|)
block|{
if|if
condition|(
name|remote_dir_exists
index|[
name|request
operator|->
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|==
literal|1
condition|)
block|{
name|start_put
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_mkcol
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|void
name|get_remote_object_list
parameter_list|(
name|unsigned
name|char
name|parent
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|add_fetch_request
specifier|static
name|void
name|add_fetch_request
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
decl_stmt|;
name|check_locks
argument_list|()
expr_stmt|;
comment|/* 	 * Don't fetch the object if it's known to exist locally 	 * or is already in the request queue 	 */
if|if
condition|(
name|remote_dir_exists
index|[
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|==
operator|-
literal|1
condition|)
name|get_remote_object_list
argument_list|(
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|LOCAL
operator||
name|FETCHING
operator|)
condition|)
return|return;
name|obj
operator|->
name|flags
operator||=
name|FETCHING
expr_stmt|;
name|request
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|lock
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|headers
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|NEED_FETCH
expr_stmt|;
name|request
operator|->
name|next
operator|=
name|request_queue_head
expr_stmt|;
name|request_queue_head
operator|=
name|request
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|fill_active_slots
argument_list|()
expr_stmt|;
name|step_active_slots
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|add_send_request
specifier|static
name|int
name|add_send_request
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
name|request_queue_head
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|target
decl_stmt|;
comment|/* Keep locks active */
name|check_locks
argument_list|()
expr_stmt|;
comment|/* 	 * Don't push the object if it's known to exist on the remote 	 * or is already in the request queue 	 */
if|if
condition|(
name|remote_dir_exists
index|[
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|==
operator|-
literal|1
condition|)
name|get_remote_object_list
argument_list|(
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|REMOTE
operator||
name|PUSHING
operator|)
condition|)
return|return
literal|0
return|;
name|target
operator|=
name|find_sha1_pack
argument_list|(
name|obj
operator|->
name|sha1
argument_list|,
name|repo
operator|->
name|packs
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
name|obj
operator|->
name|flags
operator||=
name|REMOTE
expr_stmt|;
return|return
literal|0
return|;
block|}
name|obj
operator|->
name|flags
operator||=
name|PUSHING
expr_stmt|;
name|request
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|request
operator|->
name|headers
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|NEED_PUSH
expr_stmt|;
name|request
operator|->
name|next
operator|=
name|request_queue_head
expr_stmt|;
name|request_queue_head
operator|=
name|request
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|fill_active_slots
argument_list|()
expr_stmt|;
name|step_active_slots
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fetch_indices
specifier|static
name|int
name|fetch_indices
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Getting pack list\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|http_get_info_packs
argument_list|(
name|repo
operator|->
name|url
argument_list|,
operator|&
name|repo
operator|->
name|packs
argument_list|)
condition|)
block|{
case|case
name|HTTP_OK
case|:
case|case
name|HTTP_MISSING_TARGET
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|one_remote_object
specifier|static
name|void
name|one_remote_object
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|hex
argument_list|,
name|sha1
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|obj
operator|=
name|lookup_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|obj
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
comment|/* Ignore remote objects that don't exist locally */
if|if
condition|(
operator|!
name|obj
condition|)
return|return;
name|obj
operator|->
name|flags
operator||=
name|REMOTE
expr_stmt|;
if|if
condition|(
operator|!
name|object_list_contains
argument_list|(
name|objects
argument_list|,
name|obj
argument_list|)
condition|)
name|object_list_insert
argument_list|(
name|obj
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_lockprop_ctx
specifier|static
name|void
name|handle_lockprop_ctx
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
block|{
name|int
modifier|*
name|lock_flags
init|=
operator|(
name|int
operator|*
operator|)
name|ctx
operator|->
name|userData
decl_stmt|;
if|if
condition|(
name|tag_closed
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_CTX_LOCKENTRY
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|lock_flags
operator|&
name|DAV_PROP_LOCKEX
operator|)
operator|&&
operator|(
operator|*
name|lock_flags
operator|&
name|DAV_PROP_LOCKWR
operator|)
condition|)
block|{
operator|*
name|lock_flags
operator||=
name|DAV_LOCK_OK
expr_stmt|;
block|}
operator|*
name|lock_flags
operator|&=
name|DAV_LOCK_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_CTX_LOCKTYPE_WRITE
argument_list|)
condition|)
block|{
operator|*
name|lock_flags
operator||=
name|DAV_PROP_LOCKWR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_CTX_LOCKTYPE_EXCLUSIVE
argument_list|)
condition|)
block|{
operator|*
name|lock_flags
operator||=
name|DAV_PROP_LOCKEX
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|handle_new_lock_ctx
specifier|static
name|void
name|handle_new_lock_ctx
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
block|{
name|struct
name|remote_lock
modifier|*
name|lock
init|=
operator|(
expr|struct
name|remote_lock
operator|*
operator|)
name|ctx
operator|->
name|userData
decl_stmt|;
name|git_SHA_CTX
name|sha_ctx
decl_stmt|;
name|unsigned
name|char
name|lock_token_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|tag_closed
operator|&&
name|ctx
operator|->
name|cdata
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_ACTIVELOCK_OWNER
argument_list|)
condition|)
block|{
name|lock
operator|->
name|owner
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lock
operator|->
name|owner
argument_list|,
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_ACTIVELOCK_TIMEOUT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|,
literal|"Second-"
argument_list|)
condition|)
name|lock
operator|->
name|timeout
operator|=
name|strtol
argument_list|(
name|ctx
operator|->
name|cdata
operator|+
literal|7
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_ACTIVELOCK_TOKEN
argument_list|)
condition|)
block|{
name|lock
operator|->
name|token
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lock
operator|->
name|token
argument_list|,
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|git_SHA1_Init
argument_list|(
operator|&
name|sha_ctx
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|sha_ctx
argument_list|,
name|lock
operator|->
name|token
argument_list|,
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|git_SHA1_Final
argument_list|(
name|lock_token_sha1
argument_list|,
operator|&
name|sha_ctx
argument_list|)
expr_stmt|;
name|lock
operator|->
name|tmpfile_suffix
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
name|lock
operator|->
name|tmpfile_suffix
operator|+
literal|1
argument_list|,
name|sha1_to_hex
argument_list|(
name|lock_token_sha1
argument_list|)
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|one_remote_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
name|void
DECL|function|xml_start_tag
name|xml_start_tag
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|xml_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|xml_ctx
operator|*
operator|)
name|userData
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|int
name|new_len
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|name
expr_stmt|;
else|else
name|c
operator|++
expr_stmt|;
name|new_len
operator|=
name|strlen
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|c
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|new_len
operator|>
name|ctx
operator|->
name|len
condition|)
block|{
name|ctx
operator|->
name|name
operator|=
name|xrealloc
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|len
operator|=
name|new_len
expr_stmt|;
block|}
name|strcat
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|userFunc
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xml_end_tag
name|xml_end_tag
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|xml_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|xml_ctx
operator|*
operator|)
name|userData
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|ctx
operator|->
name|userFunc
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|name
expr_stmt|;
else|else
name|c
operator|++
expr_stmt|;
name|ep
operator|=
name|ctx
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|c
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xml_cdata
name|xml_cdata
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|xml_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|xml_ctx
operator|*
operator|)
name|userData
decl_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cdata
operator|=
name|xmemdupz
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lock_remote
specifier|static
name|struct
name|remote_lock
modifier|*
name|lock_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|strbuf
name|in_buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|char
name|timeout_header
index|[
literal|25
index|]
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|lock
init|=
name|NULL
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|struct
name|xml_ctx
name|ctx
decl_stmt|;
name|char
modifier|*
name|escaped
decl_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repo
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Make sure leading directories exist for the remote ref */
name|ep
operator|=
name|strchr
argument_list|(
name|url
operator|+
name|strlen
argument_list|(
name|repo
operator|->
name|url
argument_list|)
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
name|char
name|saved_character
init|=
name|ep
index|[
literal|1
index|]
decl_stmt|;
name|ep
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http_get
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|url
argument_list|,
name|DAV_MKCOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
operator|&&
name|results
operator|.
name|http_code
operator|!=
literal|405
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to create branch path %s\n"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start MKCOL request\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ep
index|[
literal|1
index|]
operator|=
name|saved_character
expr_stmt|;
name|ep
operator|=
name|strchr
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|escaped
operator|=
name|xml_entities
argument_list|(
name|git_default_email
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
name|LOCK_REQUEST
argument_list|,
name|escaped
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|escaped
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timeout_header
argument_list|,
literal|"Timeout: Second-%ld"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|timeout_header
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|url
argument_list|,
name|DAV_LOCK
argument_list|,
operator|&
name|out_buffer
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|lock
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|ctx
operator|.
name|name
operator|=
name|xcalloc
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|.
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|userFunc
operator|=
name|handle_new_lock_ctx
expr_stmt|;
name|ctx
operator|.
name|userData
operator|=
name|lock
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|xml_start_tag
argument_list|,
name|xml_end_tag
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|xml_cdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buf
argument_list|,
name|in_buffer
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XML error: %s\n"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start LOCK request\n"
argument_list|)
expr_stmt|;
block|}
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|token
operator|==
name|NULL
operator|||
name|lock
operator|->
name|timeout
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|lock
operator|->
name|url
operator|=
name|url
expr_stmt|;
name|lock
operator|->
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|lock
operator|->
name|next
operator|=
name|repo
operator|->
name|locks
expr_stmt|;
name|repo
operator|->
name|locks
operator|=
name|lock
expr_stmt|;
block|}
return|return
name|lock
return|;
block|}
end_function
begin_function
DECL|function|unlock_remote
specifier|static
name|int
name|unlock_remote
parameter_list|(
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|prev
init|=
name|repo
operator|->
name|locks
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|dav_headers
operator|=
name|get_dav_token_headers
argument_list|(
name|lock
argument_list|,
name|DAV_HEADER_LOCK
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http_get
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|lock
operator|->
name|url
argument_list|,
name|DAV_UNLOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
name|rc
operator|=
literal|1
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UNLOCK HTTP error %ld\n"
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start UNLOCK request\n"
argument_list|)
expr_stmt|;
block|}
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|repo
operator|->
name|locks
operator|==
name|lock
condition|)
block|{
name|repo
operator|->
name|locks
operator|=
name|lock
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|prev
operator|&&
name|prev
operator|->
name|next
operator|!=
name|lock
condition|)
name|prev
operator|=
name|prev
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|prev
operator|->
name|next
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|remove_locks
specifier|static
name|void
name|remove_locks
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_lock
modifier|*
name|lock
init|=
name|repo
operator|->
name|locks
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removing remote locks...\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|lock
condition|)
block|{
name|struct
name|remote_lock
modifier|*
name|next
init|=
name|lock
operator|->
name|next
decl_stmt|;
name|unlock_remote
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|lock
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|remove_locks_on_signal
specifier|static
name|void
name|remove_locks_on_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|remove_locks
argument_list|()
expr_stmt|;
name|sigchain_pop
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|remote_ls
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|process_ls_object
specifier|static
name|void
name|process_ls_object
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|parent
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ls
operator|->
name|userData
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|ls
operator|->
name|dentry_name
decl_stmt|;
name|char
modifier|*
name|obj_hex
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ls
operator|->
name|path
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
operator|&&
operator|(
name|ls
operator|->
name|flags
operator|&
name|IS_DIR
operator|)
condition|)
block|{
name|remote_dir_exists
index|[
operator|*
name|parent
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|!=
literal|49
condition|)
return|return;
name|path
operator|+=
literal|8
expr_stmt|;
name|obj_hex
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: path is not null-terminated, can not use strlcpy here */
name|memcpy
argument_list|(
name|obj_hex
argument_list|,
name|path
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|obj_hex
operator|+
literal|2
argument_list|,
name|path
operator|+
literal|3
argument_list|)
expr_stmt|;
name|one_remote_object
argument_list|(
name|obj_hex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj_hex
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|process_ls_ref
specifier|static
name|void
name|process_ls_ref
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ls
operator|->
name|path
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
operator|&&
operator|(
name|ls
operator|->
name|dentry_flags
operator|&
name|IS_DIR
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s\n"
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|ls
operator|->
name|dentry_flags
operator|&
name|IS_DIR
operator|)
condition|)
name|one_remote_ref
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_remote_ls_ctx
specifier|static
name|void
name|handle_remote_ls_ctx
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
block|{
name|struct
name|remote_ls_ctx
modifier|*
name|ls
init|=
operator|(
expr|struct
name|remote_ls_ctx
operator|*
operator|)
name|ctx
operator|->
name|userData
decl_stmt|;
if|if
condition|(
name|tag_closed
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_RESP
argument_list|)
operator|&&
name|ls
operator|->
name|dentry_name
condition|)
block|{
if|if
condition|(
name|ls
operator|->
name|dentry_flags
operator|&
name|IS_DIR
condition|)
block|{
comment|/* ensure collection names end with slash */
name|str_end_url_with_slash
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|,
operator|&
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|flags
operator|&
name|PROCESS_DIRS
condition|)
block|{
name|ls
operator|->
name|userFunc
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|,
name|ls
operator|->
name|path
argument_list|)
operator|&&
name|ls
operator|->
name|flags
operator|&
name|RECURSIVE
condition|)
block|{
name|remote_ls
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|,
name|ls
operator|->
name|flags
argument_list|,
name|ls
operator|->
name|userFunc
argument_list|,
name|ls
operator|->
name|userData
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ls
operator|->
name|flags
operator|&
name|PROCESS_FILES
condition|)
block|{
name|ls
operator|->
name|userFunc
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_NAME
argument_list|)
operator|&&
name|ctx
operator|->
name|cdata
condition|)
block|{
name|char
modifier|*
name|path
init|=
name|ctx
operator|->
name|cdata
decl_stmt|;
if|if
condition|(
operator|*
name|ctx
operator|->
name|cdata
operator|==
literal|'h'
condition|)
block|{
name|path
operator|=
name|strstr
argument_list|(
name|path
argument_list|,
literal|"//"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
name|path
operator|=
name|strchr
argument_list|(
name|path
operator|+
literal|2
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
condition|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|repo
operator|->
name|url
decl_stmt|;
if|if
condition|(
name|repo
operator|->
name|path
condition|)
name|url
operator|=
name|repo
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
name|url
argument_list|,
name|repo
operator|->
name|path_len
argument_list|)
condition|)
name|error
argument_list|(
literal|"Parsed path '%s' does not match url: '%s'\n"
argument_list|,
name|path
argument_list|,
name|url
argument_list|)
expr_stmt|;
else|else
block|{
name|path
operator|+=
name|repo
operator|->
name|path_len
expr_stmt|;
name|ls
operator|->
name|dentry_name
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_COLLECTION
argument_list|)
condition|)
block|{
name|ls
operator|->
name|dentry_flags
operator||=
name|IS_DIR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_RESP
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|ls
operator|->
name|dentry_name
operator|=
name|NULL
expr_stmt|;
name|ls
operator|->
name|dentry_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * NEEDSWORK: remote_ls() ignores info/refs on the remote side.  But it  * should _only_ heed the information from that file, instead of trying to  * determine the refs from the remote file system (badly: it does not even  * know about packed-refs).  */
end_comment
begin_function
DECL|function|remote_ls
specifier|static
name|void
name|remote_ls
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
block|{
name|char
modifier|*
name|url
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repo
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|strbuf
name|in_buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|struct
name|xml_ctx
name|ctx
decl_stmt|;
name|struct
name|remote_ls_ctx
name|ls
decl_stmt|;
name|ls
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|ls
operator|.
name|path
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|ls
operator|.
name|dentry_name
operator|=
name|NULL
expr_stmt|;
name|ls
operator|.
name|dentry_flags
operator|=
literal|0
expr_stmt|;
name|ls
operator|.
name|userData
operator|=
name|userData
expr_stmt|;
name|ls
operator|.
name|userFunc
operator|=
name|userFunc
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
name|PROPFIND_ALL_REQUEST
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Depth: 1"
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|url
argument_list|,
name|DAV_PROPFIND
argument_list|,
operator|&
name|out_buffer
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|ctx
operator|.
name|name
operator|=
name|xcalloc
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|.
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|userFunc
operator|=
name|handle_remote_ls_ctx
expr_stmt|;
name|ctx
operator|.
name|userData
operator|=
operator|&
name|ls
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|xml_start_tag
argument_list|,
name|xml_end_tag
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|xml_cdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buf
argument_list|,
name|in_buffer
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XML error: %s\n"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start PROPFIND request\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ls
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_remote_object_list
specifier|static
name|void
name|get_remote_object_list
parameter_list|(
name|unsigned
name|char
name|parent
parameter_list|)
block|{
name|char
name|path
index|[]
init|=
literal|"objects/XX/"
decl_stmt|;
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|unsigned
name|int
name|val
init|=
name|parent
decl_stmt|;
name|path
index|[
literal|8
index|]
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
name|path
index|[
literal|9
index|]
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
name|remote_dir_exists
index|[
name|val
index|]
operator|=
literal|0
expr_stmt|;
name|remote_ls
argument_list|(
name|path
argument_list|,
operator|(
name|PROCESS_FILES
operator||
name|PROCESS_DIRS
operator|)
argument_list|,
name|process_ls_object
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|locking_available
specifier|static
name|int
name|locking_available
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|strbuf
name|in_buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|struct
name|xml_ctx
name|ctx
decl_stmt|;
name|int
name|lock_flags
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|escaped
decl_stmt|;
name|escaped
operator|=
name|xml_entities
argument_list|(
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
name|PROPFIND_SUPPORTEDLOCK_REQUEST
argument_list|,
name|escaped
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|escaped
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Depth: 0"
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|DAV_PROPFIND
argument_list|,
operator|&
name|out_buffer
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|ctx
operator|.
name|name
operator|=
name|xcalloc
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|.
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|userFunc
operator|=
name|handle_lockprop_ctx
expr_stmt|;
name|ctx
operator|.
name|userData
operator|=
operator|&
name|lock_flags
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|xml_start_tag
argument_list|,
name|xml_end_tag
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buf
argument_list|,
name|in_buffer
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XML error: %s\n"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lock_flags
operator|=
literal|0
expr_stmt|;
block|}
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock_flags
condition|)
name|error
argument_list|(
literal|"no DAV locking support on %s"
argument_list|,
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Cannot access URL %s, return code %d"
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|results
operator|.
name|curl_result
argument_list|)
expr_stmt|;
name|lock_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"Unable to start PROPFIND request on %s"
argument_list|,
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
return|return
name|lock_flags
return|;
block|}
end_function
begin_function
DECL|function|add_one_object
specifier|static
name|struct
name|object_list
modifier|*
modifier|*
name|add_one_object
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|struct
name|object_list
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|object_list
modifier|*
name|entry
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object_list
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|->
name|item
operator|=
name|obj
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|entry
expr_stmt|;
return|return
operator|&
name|entry
operator|->
name|next
return|;
block|}
end_function
begin_function
DECL|function|process_blob
specifier|static
name|struct
name|object_list
modifier|*
modifier|*
name|process_blob
parameter_list|(
name|struct
name|blob
modifier|*
name|blob
parameter_list|,
name|struct
name|object_list
modifier|*
modifier|*
name|p
parameter_list|,
name|struct
name|name_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
operator|&
name|blob
operator|->
name|object
decl_stmt|;
name|obj
operator|->
name|flags
operator||=
name|LOCAL
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|UNINTERESTING
operator||
name|SEEN
operator|)
condition|)
return|return
name|p
return|;
name|obj
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
return|return
name|add_one_object
argument_list|(
name|obj
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|process_tree
specifier|static
name|struct
name|object_list
modifier|*
modifier|*
name|process_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|struct
name|object_list
modifier|*
modifier|*
name|p
parameter_list|,
name|struct
name|name_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
operator|&
name|tree
operator|->
name|object
decl_stmt|;
name|struct
name|tree_desc
name|desc
decl_stmt|;
name|struct
name|name_entry
name|entry
decl_stmt|;
name|struct
name|name_path
name|me
decl_stmt|;
name|obj
operator|->
name|flags
operator||=
name|LOCAL
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|UNINTERESTING
operator||
name|SEEN
operator|)
condition|)
return|return
name|p
return|;
if|if
condition|(
name|parse_tree
argument_list|(
name|tree
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"bad tree object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|add_one_object
argument_list|(
name|obj
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|me
operator|.
name|up
operator|=
name|path
expr_stmt|;
name|me
operator|.
name|elem
operator|=
name|name
expr_stmt|;
name|me
operator|.
name|elem_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tree_entry
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
switch|switch
condition|(
name|object_type
argument_list|(
name|entry
operator|.
name|mode
argument_list|)
condition|)
block|{
case|case
name|OBJ_TREE
case|:
name|p
operator|=
name|process_tree
argument_list|(
name|lookup_tree
argument_list|(
name|entry
operator|.
name|sha1
argument_list|)
argument_list|,
name|p
argument_list|,
operator|&
name|me
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_BLOB
case|:
name|p
operator|=
name|process_blob
argument_list|(
name|lookup_blob
argument_list|(
name|entry
operator|.
name|sha1
argument_list|)
argument_list|,
name|p
argument_list|,
operator|&
name|me
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Subproject commit - not in this repository */
break|break;
block|}
name|free
argument_list|(
name|tree
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|tree
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|get_delta
specifier|static
name|int
name|get_delta
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|object_list
modifier|*
modifier|*
name|p
init|=
operator|&
name|objects
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
name|revs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|process_tree
argument_list|(
name|commit
operator|->
name|tree
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|LOCAL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
name|count
operator|+=
name|add_send_request
argument_list|(
operator|&
name|commit
operator|->
name|object
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revs
operator|->
name|pending
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object_array_entry
modifier|*
name|entry
init|=
name|revs
operator|->
name|pending
operator|.
name|objects
operator|+
name|i
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
init|=
name|entry
operator|->
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|entry
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|UNINTERESTING
operator||
name|SEEN
operator|)
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|obj
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
name|p
operator|=
name|add_one_object
argument_list|(
name|obj
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TREE
condition|)
block|{
name|p
operator|=
name|process_tree
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|obj
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_BLOB
condition|)
block|{
name|p
operator|=
name|process_blob
argument_list|(
operator|(
expr|struct
name|blob
operator|*
operator|)
name|obj
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|die
argument_list|(
literal|"unknown pending object %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|objects
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|objects
operator|->
name|item
operator|->
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
name|count
operator|+=
name|add_send_request
argument_list|(
name|objects
operator|->
name|item
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|objects
operator|=
name|objects
operator|->
name|next
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|update_remote
specifier|static
name|int
name|update_remote
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
decl_stmt|;
name|dav_headers
operator|=
name|get_dav_token_headers
argument_list|(
name|lock
argument_list|,
name|DAV_HEADER_IF
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|lock
operator|->
name|url
argument_list|,
name|DAV_PUT
argument_list|,
operator|&
name|out_buffer
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT error: curl result=%d, HTTP code=%ld\n"
argument_list|,
name|results
operator|.
name|curl_result
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
comment|/* We should attempt recovery? */
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start PUT request\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|remote_refs
specifier|static
name|struct
name|ref
modifier|*
name|remote_refs
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|one_remote_ref
specifier|static
name|void
name|one_remote_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
name|http_fetch_ref
argument_list|(
name|repo
operator|->
name|url
argument_list|,
name|ref
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to fetch ref %s from %s\n"
argument_list|,
name|refname
argument_list|,
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fetch a copy of the object if it doesn't exist locally - it 	 * may be required for updating server info later. 	 */
if|if
condition|(
name|repo
operator|->
name|can_update_info_refs
operator|&&
operator|!
name|has_sha1_file
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
name|obj
operator|=
name|lookup_unknown_object
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  fetch %s for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
name|add_fetch_request
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
name|ref
operator|->
name|next
operator|=
name|remote_refs
expr_stmt|;
name|remote_refs
operator|=
name|ref
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_dav_remote_heads
specifier|static
name|void
name|get_dav_remote_heads
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_ls
argument_list|(
literal|"refs/"
argument_list|,
operator|(
name|PROCESS_FILES
operator||
name|PROCESS_DIRS
operator||
name|RECURSIVE
operator|)
argument_list|,
name|process_ls_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_remote_info_ref
specifier|static
name|void
name|add_remote_info_ref
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|buf
init|=
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|ls
operator|->
name|userData
decl_stmt|;
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|ref_info
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|http_fetch_ref
argument_list|(
name|repo
operator|->
name|url
argument_list|,
name|ref
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to fetch ref %s from %s\n"
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|,
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return;
block|}
name|o
operator|=
name|parse_object
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to parse object %s for remote ref %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
operator|+
literal|42
expr_stmt|;
name|ref_info
operator|=
name|xcalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ref_info
argument_list|,
literal|"%s	%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|fwrite_buffer
argument_list|(
name|ref_info
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|o
operator|=
name|deref_tag
argument_list|(
name|o
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
operator|+
literal|45
expr_stmt|;
name|ref_info
operator|=
name|xcalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ref_info
argument_list|,
literal|"%s	%s^{}\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|sha1
argument_list|)
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|fwrite_buffer
argument_list|(
name|ref_info
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_info
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_remote_info_refs
specifier|static
name|void
name|update_remote_info_refs
parameter_list|(
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|buffer
name|buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
decl_stmt|;
name|remote_ls
argument_list|(
literal|"refs/"
argument_list|,
operator|(
name|PROCESS_FILES
operator||
name|RECURSIVE
operator|)
argument_list|,
name|add_remote_info_ref
argument_list|,
operator|&
name|buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aborted
condition|)
block|{
name|dav_headers
operator|=
name|get_dav_token_headers
argument_list|(
name|lock
argument_list|,
name|DAV_HEADER_IF
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|lock
operator|->
name|url
argument_list|,
name|DAV_PUT
argument_list|,
operator|&
name|buffer
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT error: curl result=%d, HTTP code=%ld\n"
argument_list|,
name|results
operator|.
name|curl_result
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|strbuf_release
argument_list|(
operator|&
name|buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remote_exists
specifier|static
name|int
name|remote_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|url
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repo
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|http_get_strbuf
argument_list|(
name|url
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|HTTP_OK
case|:
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HTTP_MISSING_TARGET
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HTTP_ERROR
case|:
name|http_error
argument_list|(
name|url
argument_list|,
name|HTTP_ERROR
argument_list|)
expr_stmt|;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|fetch_symref
specifier|static
name|void
name|fetch_symref
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|symref
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|url
decl_stmt|;
name|struct
name|strbuf
name|buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repo
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|http_get_strbuf
argument_list|(
name|url
argument_list|,
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
operator|!=
name|HTTP_OK
condition|)
name|die
argument_list|(
literal|"Couldn't get %s for remote symref\n%s"
argument_list|,
name|url
argument_list|,
name|curl_errorstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|symref
argument_list|)
expr_stmt|;
operator|*
name|symref
operator|=
name|NULL
expr_stmt|;
name|hashclr
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|len
operator|==
literal|0
condition|)
return|return;
comment|/* If it's a symref, set the refname; otherwise try for a sha1 */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|.
name|buf
argument_list|,
literal|"ref: "
argument_list|)
condition|)
block|{
operator|*
name|symref
operator|=
name|xmemdupz
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|.
name|buf
operator|+
literal|5
argument_list|,
name|buffer
operator|.
name|len
operator|-
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_sha1_hex
argument_list|(
name|buffer
operator|.
name|buf
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|verify_merge_base
specifier|static
name|int
name|verify_merge_base
parameter_list|(
name|unsigned
name|char
modifier|*
name|head_sha1
parameter_list|,
name|struct
name|ref
modifier|*
name|remote
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|head
init|=
name|lookup_commit_or_die
argument_list|(
name|head_sha1
argument_list|,
literal|"HEAD"
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|branch
init|=
name|lookup_commit_or_die
argument_list|(
name|remote
operator|->
name|old_sha1
argument_list|,
name|remote
operator|->
name|name
argument_list|)
decl_stmt|;
return|return
name|in_merge_bases
argument_list|(
name|branch
argument_list|,
name|head
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|delete_remote_branch
specifier|static
name|int
name|delete_remote_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|refs
init|=
name|remote_refs
decl_stmt|;
name|struct
name|ref
modifier|*
name|remote_ref
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|symref
init|=
name|NULL
decl_stmt|;
name|int
name|match
decl_stmt|;
name|int
name|patlen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
comment|/* Find the remote branch(es) matching the specified branch name */
for|for
control|(
name|match
operator|=
literal|0
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|refs
operator|->
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|<
name|patlen
operator|||
name|memcmp
argument_list|(
name|name
operator|+
name|namelen
operator|-
name|patlen
argument_list|,
name|pattern
argument_list|,
name|patlen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|name
index|[
name|namelen
operator|-
name|patlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
name|match
operator|++
expr_stmt|;
name|remote_ref
operator|=
name|refs
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|==
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"No remote branch matches %s"
argument_list|,
name|pattern
argument_list|)
return|;
if|if
condition|(
name|match
operator|!=
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"More than one remote branch matches %s"
argument_list|,
name|pattern
argument_list|)
return|;
comment|/* 	 * Remote HEAD must be a symref (not exactly foolproof; a remote 	 * symlink to a symref will look like a symref) 	 */
name|fetch_symref
argument_list|(
literal|"HEAD"
argument_list|,
operator|&
name|symref
argument_list|,
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symref
condition|)
return|return
name|error
argument_list|(
literal|"Remote HEAD is not a symref"
argument_list|)
return|;
comment|/* Remote branch must not be the remote HEAD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|symref
operator|&&
name|i
operator|<
name|MAXDEPTH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|remote_ref
operator|->
name|name
argument_list|,
name|symref
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Remote branch %s is the current HEAD"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
return|;
name|fetch_symref
argument_list|(
name|symref
argument_list|,
operator|&
name|symref
argument_list|,
name|head_sha1
argument_list|)
expr_stmt|;
block|}
comment|/* Run extra sanity checks if delete is not forced */
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|/* Remote HEAD must resolve to a known object */
if|if
condition|(
name|symref
condition|)
return|return
name|error
argument_list|(
literal|"Remote HEAD symrefs too deep"
argument_list|)
return|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|head_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Unable to resolve remote HEAD"
argument_list|)
return|;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|head_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Remote HEAD resolves to object %s\nwhich does not exist locally, perhaps you need to fetch?"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head_sha1
argument_list|)
argument_list|)
return|;
comment|/* Remote branch must resolve to a known object */
if|if
condition|(
name|is_null_sha1
argument_list|(
name|remote_ref
operator|->
name|old_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Unable to resolve remote branch %s"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|remote_ref
operator|->
name|old_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Remote branch %s resolves to object %s\nwhich does not exist locally, perhaps you need to fetch?"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_ref
operator|->
name|old_sha1
argument_list|)
argument_list|)
return|;
comment|/* Remote branch must be an ancestor of remote HEAD */
if|if
condition|(
operator|!
name|verify_merge_base
argument_list|(
name|head_sha1
argument_list|,
name|remote_ref
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
literal|"The branch '%s' is not an ancestor "
literal|"of your current HEAD.\n"
literal|"If you are sure you want to delete it,"
literal|" run:\n\t'git http-push -D %s %s'"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|pattern
argument_list|)
return|;
block|}
block|}
comment|/* Send delete request */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removing remote branch '%s'\n"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
return|return
literal|0
return|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repo
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|remote_ref
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|repo
operator|->
name|url
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_setup_http_get
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|url
argument_list|,
name|DAV_DELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
return|return
name|error
argument_list|(
literal|"DELETE request failed (%d/%ld)\n"
argument_list|,
name|results
operator|.
name|curl_result
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start DELETE request"
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|run_request_queue
specifier|static
name|void
name|run_request_queue
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|is_running_queue
operator|=
literal|1
expr_stmt|;
name|fill_active_slots
argument_list|()
expr_stmt|;
name|add_fill_function
argument_list|(
name|NULL
argument_list|,
name|fill_active_slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|finish_all_active_slots
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|fill_active_slots
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|request_queue_head
operator|&&
operator|!
name|aborted
condition|)
do|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|is_running_queue
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
decl_stmt|;
name|struct
name|transfer_request
modifier|*
name|next_request
decl_stmt|;
name|int
name|nr_refspec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|refspec
init|=
name|NULL
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|ref_lock
init|=
name|NULL
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|info_ref_lock
init|=
name|NULL
decl_stmt|;
name|struct
name|rev_info
name|revs
decl_stmt|;
name|int
name|delete_branch
init|=
literal|0
decl_stmt|;
name|int
name|force_delete
init|=
literal|0
decl_stmt|;
name|int
name|objects_to_send
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|new_refs
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|local_refs
decl_stmt|;
name|git_setup_gettext
argument_list|()
expr_stmt|;
name|git_extract_argv0_path
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|repo
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|repo
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|argv
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
operator|*
name|argv
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--all"
argument_list|)
condition|)
block|{
name|push_all
operator|=
name|MATCH_REFS_ALL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--force"
argument_list|)
condition|)
block|{
name|force_all
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--dry-run"
argument_list|)
condition|)
block|{
name|dry_run
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--helper-status"
argument_list|)
condition|)
block|{
name|helper_status
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|push_verbosely
operator|=
literal|1
expr_stmt|;
name|http_is_verbose
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-d"
argument_list|)
condition|)
block|{
name|delete_branch
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-D"
argument_list|)
condition|)
block|{
name|delete_branch
operator|=
literal|1
expr_stmt|;
name|force_delete
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage
argument_list|(
name|http_push_usage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|repo
operator|->
name|url
condition|)
block|{
name|char
modifier|*
name|path
init|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|"//"
argument_list|)
decl_stmt|;
name|str_end_url_with_slash
argument_list|(
name|arg
argument_list|,
operator|&
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
name|repo
operator|->
name|path_len
operator|=
name|strlen
argument_list|(
name|repo
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
name|repo
operator|->
name|path
operator|=
name|strchr
argument_list|(
name|path
operator|+
literal|2
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|repo
operator|->
name|path
condition|)
name|repo
operator|->
name|path_len
operator|=
name|strlen
argument_list|(
name|repo
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|refspec
operator|=
name|argv
expr_stmt|;
name|nr_refspec
operator|=
name|argc
operator|-
name|i
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|USE_CURL_MULTI
name|die
argument_list|(
literal|"git-push is not available for http/https repository when not compiled with USE_CURL_MULTI"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|repo
operator|->
name|url
condition|)
name|usage
argument_list|(
name|http_push_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_branch
operator|&&
name|nr_refspec
operator|!=
literal|1
condition|)
name|die
argument_list|(
literal|"You must specify only one branch name when deleting a remote branch"
argument_list|)
expr_stmt|;
name|setup_git_directory
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|remote_dir_exists
argument_list|,
operator|-
literal|1
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|http_init
argument_list|(
name|NULL
argument_list|,
name|repo
operator|->
name|url
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|is_running_queue
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Verify DAV compliance/lock support */
if|if
condition|(
operator|!
name|locking_available
argument_list|()
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|sigchain_push_common
argument_list|(
name|remove_locks_on_signal
argument_list|)
expr_stmt|;
comment|/* Check whether the remote has server info files */
name|repo
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|repo
operator|->
name|has_info_refs
operator|=
name|remote_exists
argument_list|(
literal|"info/refs"
argument_list|)
expr_stmt|;
name|repo
operator|->
name|has_info_packs
operator|=
name|remote_exists
argument_list|(
literal|"objects/info/packs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|repo
operator|->
name|has_info_refs
condition|)
block|{
name|info_ref_lock
operator|=
name|lock_remote
argument_list|(
literal|"info/refs"
argument_list|,
name|LOCK_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ref_lock
condition|)
name|repo
operator|->
name|can_update_info_refs
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"cannot lock existing info/refs"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
if|if
condition|(
name|repo
operator|->
name|has_info_packs
condition|)
name|fetch_indices
argument_list|()
expr_stmt|;
comment|/* Get a list of all local and remote heads to validate refspecs */
name|local_refs
operator|=
name|get_local_heads
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fetching remote heads...\n"
argument_list|)
expr_stmt|;
name|get_dav_remote_heads
argument_list|()
expr_stmt|;
name|run_request_queue
argument_list|()
expr_stmt|;
comment|/* Remove a remote branch if -d or -D was specified */
if|if
condition|(
name|delete_branch
condition|)
block|{
if|if
condition|(
name|delete_remote_branch
argument_list|(
name|refspec
index|[
literal|0
index|]
argument_list|,
name|force_delete
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to delete remote branch %s\n"
argument_list|,
name|refspec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"error %s cannot remove\n"
argument_list|,
name|refspec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
comment|/* match them up */
if|if
condition|(
name|match_push_refs
argument_list|(
name|local_refs
argument_list|,
operator|&
name|remote_refs
argument_list|,
name|nr_refspec
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|refspec
argument_list|,
name|push_all
argument_list|)
condition|)
block|{
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|remote_refs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No refs in common and none specified; doing nothing.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"error null no match\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|new_refs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|char
name|old_hex
index|[
literal|60
index|]
decl_stmt|,
modifier|*
name|new_hex
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_argv
index|[
literal|5
index|]
decl_stmt|;
name|int
name|commit_argc
decl_stmt|;
name|char
modifier|*
name|new_sha1_hex
decl_stmt|,
modifier|*
name|old_sha1_hex
decl_stmt|;
if|if
condition|(
operator|!
name|ref
operator|->
name|peer_ref
condition|)
continue|continue;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|delete_remote_branch
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Could not remove %s"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"error %s cannot remove\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"ok %s\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|new_refs
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'%s': up-to-date\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"ok %s up to date\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|force_all
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
operator|&&
operator|!
name|ref
operator|->
name|force
condition|)
block|{
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
operator|||
operator|!
name|ref_newer
argument_list|(
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
comment|/* 				 * We do not have the remote ref, or 				 * we know that the remote ref is not 				 * an ancestor of what we are trying to 				 * push.  Either way this can be losing 				 * commits at the remote end and likely 				 * we were not up to date to begin with. 				 */
name|error
argument_list|(
literal|"remote '%s' is not an ancestor of\n"
literal|"local '%s'.\n"
literal|"Maybe you are not up-to-date and "
literal|"need to pull first?"
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"error %s non-fast forward\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
block|}
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|new_refs
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|old_hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|new_hex
operator|=
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"updating '%s'"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" using '%s'"
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  from %s\n  to   %s\n"
argument_list|,
name|old_hex
argument_list|,
name|new_hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
block|{
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"ok %s\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Lock remote branch ref */
name|ref_lock
operator|=
name|lock_remote
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|LOCK_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_lock
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to lock remote branch %s\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"error %s lock error\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Set up revision info for this refspec */
name|commit_argc
operator|=
literal|3
expr_stmt|;
name|new_sha1_hex
operator|=
name|xstrdup
argument_list|(
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|old_sha1_hex
operator|=
name|NULL
expr_stmt|;
name|commit_argv
index|[
literal|1
index|]
operator|=
literal|"--objects"
expr_stmt|;
name|commit_argv
index|[
literal|2
index|]
operator|=
name|new_sha1_hex
expr_stmt|;
if|if
condition|(
operator|!
name|push_all
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
name|old_sha1_hex
operator|=
name|xmalloc
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|old_sha1_hex
argument_list|,
literal|"^%s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|commit_argv
index|[
literal|3
index|]
operator|=
name|old_sha1_hex
expr_stmt|;
name|commit_argc
operator|++
expr_stmt|;
block|}
name|commit_argv
index|[
name|commit_argc
index|]
operator|=
name|NULL
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|setup_git_directory
argument_list|()
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
name|commit_argc
argument_list|,
name|commit_argv
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|revs
operator|.
name|edge_hint
operator|=
literal|0
expr_stmt|;
comment|/* just in case */
name|free
argument_list|(
name|new_sha1_hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_sha1_hex
condition|)
block|{
name|free
argument_list|(
name|old_sha1_hex
argument_list|)
expr_stmt|;
name|commit_argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Generate a list of objects that need to be pushed */
name|pushing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
literal|"revision walk setup failed"
argument_list|)
expr_stmt|;
name|mark_edges_uninteresting
argument_list|(
name|revs
operator|.
name|commits
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|objects_to_send
operator|=
name|get_delta
argument_list|(
operator|&
name|revs
argument_list|,
name|ref_lock
argument_list|)
expr_stmt|;
name|finish_all_active_slots
argument_list|()
expr_stmt|;
comment|/* Push missing objects to remote, this would be a 		   convenient time to pack them first if appropriate. */
name|pushing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|objects_to_send
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    sending %d objects\n"
argument_list|,
name|objects_to_send
argument_list|)
expr_stmt|;
name|run_request_queue
argument_list|()
expr_stmt|;
comment|/* Update the remote branch if all went well */
if|if
condition|(
name|aborted
operator|||
operator|!
name|update_remote
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|ref_lock
argument_list|)
condition|)
name|rc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|helper_status
condition|)
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
operator|!
name|rc
condition|?
literal|"ok"
else|:
literal|"error"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|unlock_remote
argument_list|(
name|ref_lock
argument_list|)
expr_stmt|;
name|check_locks
argument_list|()
expr_stmt|;
block|}
comment|/* Update remote server info if appropriate */
if|if
condition|(
name|repo
operator|->
name|has_info_refs
operator|&&
name|new_refs
condition|)
block|{
if|if
condition|(
name|info_ref_lock
operator|&&
name|repo
operator|->
name|can_update_info_refs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Updating remote server info\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
name|update_remote_info_refs
argument_list|(
name|info_ref_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to update server info\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|info_ref_lock
condition|)
name|unlock_remote
argument_list|(
name|info_ref_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repo
argument_list|)
expr_stmt|;
name|http_cleanup
argument_list|()
expr_stmt|;
name|request
operator|=
name|request_queue_head
expr_stmt|;
while|while
condition|(
name|request
operator|!=
name|NULL
condition|)
block|{
name|next_request
operator|=
name|request
operator|->
name|next
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|request
operator|=
name|next_request
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
end_unit
