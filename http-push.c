begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"http.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|<expat.h>
end_include
begin_decl_stmt
DECL|variable|http_push_usage
specifier|static
specifier|const
name|char
name|http_push_usage
index|[]
init|=
literal|"git-http-push [--all] [--dry-run] [--force] [--verbose]<remote> [<head>...]\n"
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|XML_STATUS_OK
end_ifndef
begin_enum
DECL|enum|XML_Status
enum|enum
name|XML_Status
block|{
DECL|enumerator|XML_STATUS_OK
name|XML_STATUS_OK
init|=
literal|1
block|,
DECL|enumerator|XML_STATUS_ERROR
name|XML_STATUS_ERROR
init|=
literal|0
block|}
enum|;
end_enum
begin_define
DECL|macro|XML_STATUS_OK
define|#
directive|define
name|XML_STATUS_OK
value|1
end_define
begin_define
DECL|macro|XML_STATUS_ERROR
define|#
directive|define
name|XML_STATUS_ERROR
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|PREV_BUF_SIZE
define|#
directive|define
name|PREV_BUF_SIZE
value|4096
end_define
begin_define
DECL|macro|RANGE_HEADER_SIZE
define|#
directive|define
name|RANGE_HEADER_SIZE
value|30
end_define
begin_comment
comment|/* DAV methods */
end_comment
begin_define
DECL|macro|DAV_LOCK
define|#
directive|define
name|DAV_LOCK
value|"LOCK"
end_define
begin_define
DECL|macro|DAV_MKCOL
define|#
directive|define
name|DAV_MKCOL
value|"MKCOL"
end_define
begin_define
DECL|macro|DAV_MOVE
define|#
directive|define
name|DAV_MOVE
value|"MOVE"
end_define
begin_define
DECL|macro|DAV_PROPFIND
define|#
directive|define
name|DAV_PROPFIND
value|"PROPFIND"
end_define
begin_define
DECL|macro|DAV_PUT
define|#
directive|define
name|DAV_PUT
value|"PUT"
end_define
begin_define
DECL|macro|DAV_UNLOCK
define|#
directive|define
name|DAV_UNLOCK
value|"UNLOCK"
end_define
begin_define
DECL|macro|DAV_DELETE
define|#
directive|define
name|DAV_DELETE
value|"DELETE"
end_define
begin_comment
comment|/* DAV lock flags */
end_comment
begin_define
DECL|macro|DAV_PROP_LOCKWR
define|#
directive|define
name|DAV_PROP_LOCKWR
value|(1u<< 0)
end_define
begin_define
DECL|macro|DAV_PROP_LOCKEX
define|#
directive|define
name|DAV_PROP_LOCKEX
value|(1u<< 1)
end_define
begin_define
DECL|macro|DAV_LOCK_OK
define|#
directive|define
name|DAV_LOCK_OK
value|(1u<< 2)
end_define
begin_comment
comment|/* DAV XML properties */
end_comment
begin_define
DECL|macro|DAV_CTX_LOCKENTRY
define|#
directive|define
name|DAV_CTX_LOCKENTRY
value|".multistatus.response.propstat.prop.supportedlock.lockentry"
end_define
begin_define
DECL|macro|DAV_CTX_LOCKTYPE_WRITE
define|#
directive|define
name|DAV_CTX_LOCKTYPE_WRITE
value|".multistatus.response.propstat.prop.supportedlock.lockentry.locktype.write"
end_define
begin_define
DECL|macro|DAV_CTX_LOCKTYPE_EXCLUSIVE
define|#
directive|define
name|DAV_CTX_LOCKTYPE_EXCLUSIVE
value|".multistatus.response.propstat.prop.supportedlock.lockentry.lockscope.exclusive"
end_define
begin_define
DECL|macro|DAV_ACTIVELOCK_OWNER
define|#
directive|define
name|DAV_ACTIVELOCK_OWNER
value|".prop.lockdiscovery.activelock.owner.href"
end_define
begin_define
DECL|macro|DAV_ACTIVELOCK_TIMEOUT
define|#
directive|define
name|DAV_ACTIVELOCK_TIMEOUT
value|".prop.lockdiscovery.activelock.timeout"
end_define
begin_define
DECL|macro|DAV_ACTIVELOCK_TOKEN
define|#
directive|define
name|DAV_ACTIVELOCK_TOKEN
value|".prop.lockdiscovery.activelock.locktoken.href"
end_define
begin_define
DECL|macro|DAV_PROPFIND_RESP
define|#
directive|define
name|DAV_PROPFIND_RESP
value|".multistatus.response"
end_define
begin_define
DECL|macro|DAV_PROPFIND_NAME
define|#
directive|define
name|DAV_PROPFIND_NAME
value|".multistatus.response.href"
end_define
begin_define
DECL|macro|DAV_PROPFIND_COLLECTION
define|#
directive|define
name|DAV_PROPFIND_COLLECTION
value|".multistatus.response.propstat.prop.resourcetype.collection"
end_define
begin_comment
comment|/* DAV request body templates */
end_comment
begin_define
DECL|macro|PROPFIND_SUPPORTEDLOCK_REQUEST
define|#
directive|define
name|PROPFIND_SUPPORTEDLOCK_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n<D:prop xmlns:R=\"%s\">\n<D:supportedlock/>\n</D:prop>\n</D:propfind>"
end_define
begin_define
DECL|macro|PROPFIND_ALL_REQUEST
define|#
directive|define
name|PROPFIND_ALL_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n<D:allprop/>\n</D:propfind>"
end_define
begin_define
DECL|macro|LOCK_REQUEST
define|#
directive|define
name|LOCK_REQUEST
value|"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:lockinfo xmlns:D=\"DAV:\">\n<D:lockscope><D:exclusive/></D:lockscope>\n<D:locktype><D:write/></D:locktype>\n<D:owner>\n<D:href>mailto:%s</D:href>\n</D:owner>\n</D:lockinfo>"
end_define
begin_define
DECL|macro|LOCK_TIME
define|#
directive|define
name|LOCK_TIME
value|600
end_define
begin_define
DECL|macro|LOCK_REFRESH
define|#
directive|define
name|LOCK_REFRESH
value|30
end_define
begin_comment
comment|/* bits #0-15 in revision.h */
end_comment
begin_define
DECL|macro|LOCAL
define|#
directive|define
name|LOCAL
value|(1u<<16)
end_define
begin_define
DECL|macro|REMOTE
define|#
directive|define
name|REMOTE
value|(1u<<17)
end_define
begin_define
DECL|macro|FETCHING
define|#
directive|define
name|FETCHING
value|(1u<<18)
end_define
begin_define
DECL|macro|PUSHING
define|#
directive|define
name|PUSHING
value|(1u<<19)
end_define
begin_comment
comment|/* We allow "recursive" symbolic refs. Only within reason, though */
end_comment
begin_define
DECL|macro|MAXDEPTH
define|#
directive|define
name|MAXDEPTH
value|5
end_define
begin_decl_stmt
DECL|variable|pushing
specifier|static
name|int
name|pushing
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|aborted
specifier|static
name|int
name|aborted
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remote_dir_exists
specifier|static
name|signed
name|char
name|remote_dir_exists
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_pragma_header
specifier|static
name|struct
name|curl_slist
modifier|*
name|no_pragma_header
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|push_verbosely
specifier|static
name|int
name|push_verbosely
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|push_all
specifier|static
name|int
name|push_all
init|=
name|MATCH_REFS_NONE
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|force_all
specifier|static
name|int
name|force_all
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|dry_run
specifier|static
name|int
name|dry_run
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|objects
specifier|static
name|struct
name|object_list
modifier|*
name|objects
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|repo
struct|struct
name|repo
block|{
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|path_len
name|int
name|path_len
decl_stmt|;
DECL|member|has_info_refs
name|int
name|has_info_refs
decl_stmt|;
DECL|member|can_update_info_refs
name|int
name|can_update_info_refs
decl_stmt|;
DECL|member|has_info_packs
name|int
name|has_info_packs
decl_stmt|;
DECL|member|packs
name|struct
name|packed_git
modifier|*
name|packs
decl_stmt|;
DECL|member|locks
name|struct
name|remote_lock
modifier|*
name|locks
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|remote
specifier|static
name|struct
name|repo
modifier|*
name|remote
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|transfer_state
enum|enum
name|transfer_state
block|{
DECL|enumerator|NEED_FETCH
name|NEED_FETCH
block|,
DECL|enumerator|RUN_FETCH_LOOSE
name|RUN_FETCH_LOOSE
block|,
DECL|enumerator|RUN_FETCH_PACKED
name|RUN_FETCH_PACKED
block|,
DECL|enumerator|NEED_PUSH
name|NEED_PUSH
block|,
DECL|enumerator|RUN_MKCOL
name|RUN_MKCOL
block|,
DECL|enumerator|RUN_PUT
name|RUN_PUT
block|,
DECL|enumerator|RUN_MOVE
name|RUN_MOVE
block|,
DECL|enumerator|ABORTED
name|ABORTED
block|,
DECL|enumerator|COMPLETE
name|COMPLETE
block|, }
enum|;
end_enum
begin_struct
DECL|struct|transfer_request
struct|struct
name|transfer_request
block|{
DECL|member|obj
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|dest
name|char
modifier|*
name|dest
decl_stmt|;
DECL|member|lock
name|struct
name|remote_lock
modifier|*
name|lock
decl_stmt|;
DECL|member|headers
name|struct
name|curl_slist
modifier|*
name|headers
decl_stmt|;
DECL|member|buffer
name|struct
name|buffer
name|buffer
decl_stmt|;
DECL|member|filename
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
DECL|member|tmpfile
name|char
name|tmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
DECL|member|local_fileno
name|int
name|local_fileno
decl_stmt|;
DECL|member|local_stream
name|FILE
modifier|*
name|local_stream
decl_stmt|;
DECL|member|state
name|enum
name|transfer_state
name|state
decl_stmt|;
DECL|member|curl_result
name|CURLcode
name|curl_result
decl_stmt|;
DECL|member|errorstr
name|char
name|errorstr
index|[
name|CURL_ERROR_SIZE
index|]
decl_stmt|;
DECL|member|http_code
name|long
name|http_code
decl_stmt|;
DECL|member|real_sha1
name|unsigned
name|char
name|real_sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|c
name|SHA_CTX
name|c
decl_stmt|;
DECL|member|stream
name|z_stream
name|stream
decl_stmt|;
DECL|member|zret
name|int
name|zret
decl_stmt|;
DECL|member|rename
name|int
name|rename
decl_stmt|;
DECL|member|userData
name|void
modifier|*
name|userData
decl_stmt|;
DECL|member|slot
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
DECL|member|next
name|struct
name|transfer_request
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|request_queue_head
specifier|static
name|struct
name|transfer_request
modifier|*
name|request_queue_head
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|xml_ctx
struct|struct
name|xml_ctx
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|cdata
name|char
modifier|*
name|cdata
decl_stmt|;
DECL|member|userFunc
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
function_decl|;
DECL|member|userData
name|void
modifier|*
name|userData
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|remote_lock
struct|struct
name|remote_lock
block|{
DECL|member|url
name|char
modifier|*
name|url
decl_stmt|;
DECL|member|owner
name|char
modifier|*
name|owner
decl_stmt|;
DECL|member|token
name|char
modifier|*
name|token
decl_stmt|;
DECL|member|start_time
name|time_t
name|start_time
decl_stmt|;
DECL|member|timeout
name|long
name|timeout
decl_stmt|;
DECL|member|refreshing
name|int
name|refreshing
decl_stmt|;
DECL|member|next
name|struct
name|remote_lock
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Flags that control remote_ls processing */
end_comment
begin_define
DECL|macro|PROCESS_FILES
define|#
directive|define
name|PROCESS_FILES
value|(1u<< 0)
end_define
begin_define
DECL|macro|PROCESS_DIRS
define|#
directive|define
name|PROCESS_DIRS
value|(1u<< 1)
end_define
begin_define
DECL|macro|RECURSIVE
define|#
directive|define
name|RECURSIVE
value|(1u<< 2)
end_define
begin_comment
comment|/* Flags that remote_ls passes to callback functions */
end_comment
begin_define
DECL|macro|IS_DIR
define|#
directive|define
name|IS_DIR
value|(1u<< 0)
end_define
begin_struct
DECL|struct|remote_ls_ctx
struct|struct
name|remote_ls_ctx
block|{
DECL|member|path
name|char
modifier|*
name|path
decl_stmt|;
DECL|member|userFunc
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
function_decl|;
DECL|member|userData
name|void
modifier|*
name|userData
decl_stmt|;
DECL|member|flags
name|int
name|flags
decl_stmt|;
DECL|member|dentry_name
name|char
modifier|*
name|dentry_name
decl_stmt|;
DECL|member|dentry_flags
name|int
name|dentry_flags
decl_stmt|;
DECL|member|parent
name|struct
name|remote_ls_ctx
modifier|*
name|parent
decl_stmt|;
block|}
struct|;
end_struct
begin_function_decl
specifier|static
name|void
name|finish_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|release_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|process_response
specifier|static
name|void
name|process_response
parameter_list|(
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
operator|(
expr|struct
name|transfer_request
operator|*
operator|)
name|callback_data
decl_stmt|;
name|finish_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
end_ifdef
begin_function
DECL|function|fwrite_sha1_file
specifier|static
name|size_t
name|fwrite_sha1_file
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|eltsize
parameter_list|,
name|size_t
name|nmemb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|char
name|expn
index|[
literal|4096
index|]
decl_stmt|;
name|size_t
name|size
init|=
name|eltsize
operator|*
name|nmemb
decl_stmt|;
name|int
name|posn
init|=
literal|0
decl_stmt|;
name|struct
name|transfer_request
modifier|*
name|request
init|=
operator|(
expr|struct
name|transfer_request
operator|*
operator|)
name|data
decl_stmt|;
do|do
block|{
name|ssize_t
name|retval
init|=
name|xwrite
argument_list|(
name|request
operator|->
name|local_fileno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|posn
argument_list|,
name|size
operator|-
name|posn
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
return|return
name|posn
return|;
name|posn
operator|+=
name|retval
expr_stmt|;
block|}
do|while
condition|(
name|posn
operator|<
name|size
condition|)
do|;
name|request
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|size
expr_stmt|;
name|request
operator|->
name|stream
operator|.
name|next_in
operator|=
name|ptr
expr_stmt|;
do|do
block|{
name|request
operator|->
name|stream
operator|.
name|next_out
operator|=
name|expn
expr_stmt|;
name|request
operator|->
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|expn
argument_list|)
expr_stmt|;
name|request
operator|->
name|zret
operator|=
name|inflate
argument_list|(
operator|&
name|request
operator|->
name|stream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
operator|&
name|request
operator|->
name|c
argument_list|,
name|expn
argument_list|,
sizeof|sizeof
argument_list|(
name|expn
argument_list|)
operator|-
name|request
operator|->
name|stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|request
operator|->
name|stream
operator|.
name|avail_in
operator|&&
name|request
operator|->
name|zret
operator|==
name|Z_OK
condition|)
do|;
name|data_received
operator|++
expr_stmt|;
return|return
name|size
return|;
block|}
end_function
begin_function
DECL|function|start_fetch_loose
specifier|static
name|void
name|start_fetch_loose
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
name|prevfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|char
modifier|*
name|posn
decl_stmt|;
name|int
name|prevlocal
decl_stmt|;
name|unsigned
name|char
name|prev_buf
index|[
name|PREV_BUF_SIZE
index|]
decl_stmt|;
name|ssize_t
name|prev_read
init|=
literal|0
decl_stmt|;
name|long
name|prev_posn
init|=
literal|0
decl_stmt|;
name|char
name|range
index|[
name|RANGE_HEADER_SIZE
index|]
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|range_header
init|=
name|NULL
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|filename
operator|=
name|sha1_file_name
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|request
operator|->
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|filename
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|)
argument_list|,
literal|"%s.temp"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|prevfile
argument_list|,
sizeof|sizeof
argument_list|(
name|prevfile
argument_list|)
argument_list|,
literal|"%s.prev"
argument_list|,
name|request
operator|->
name|filename
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|prevfile
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
name|prevfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|local_fileno
operator|!=
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"fd leakage in start: %d"
argument_list|,
name|request
operator|->
name|local_fileno
argument_list|)
expr_stmt|;
name|request
operator|->
name|local_fileno
operator|=
name|open
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
comment|/* This could have failed due to the "lazy directory creation"; 	 * try to mkdir the last path component. 	 */
if|if
condition|(
name|request
operator|->
name|local_fileno
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|char
modifier|*
name|dir
init|=
name|strrchr
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
operator|*
name|dir
operator|=
literal|0
expr_stmt|;
name|mkdir
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
operator|*
name|dir
operator|=
literal|'/'
expr_stmt|;
block|}
name|request
operator|->
name|local_fileno
operator|=
name|open
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|local_fileno
operator|<
literal|0
condition|)
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|error
argument_list|(
literal|"Couldn't create temporary file %s for %s: %s"
argument_list|,
name|request
operator|->
name|tmpfile
argument_list|,
name|request
operator|->
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|request
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|request
operator|->
name|stream
argument_list|)
expr_stmt|;
name|SHA1_Init
argument_list|(
operator|&
name|request
operator|->
name|c
argument_list|)
expr_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|url
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|=
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"objects/"
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|posn
argument_list|,
name|hex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|posn
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
name|hex
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|request
operator|->
name|url
argument_list|,
name|url
argument_list|)
expr_stmt|;
comment|/* If a previous temp file is present, process what was already 	   fetched. */
name|prevlocal
operator|=
name|open
argument_list|(
name|prevfile
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevlocal
operator|!=
operator|-
literal|1
condition|)
block|{
do|do
block|{
name|prev_read
operator|=
name|xread
argument_list|(
name|prevlocal
argument_list|,
name|prev_buf
argument_list|,
name|PREV_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_read
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite_sha1_file
argument_list|(
name|prev_buf
argument_list|,
literal|1
argument_list|,
name|prev_read
argument_list|,
name|request
argument_list|)
operator|==
name|prev_read
condition|)
block|{
name|prev_posn
operator|+=
name|prev_read
expr_stmt|;
block|}
else|else
block|{
name|prev_read
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|prev_read
operator|>
literal|0
condition|)
do|;
name|close
argument_list|(
name|prevlocal
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|prevfile
argument_list|)
expr_stmt|;
comment|/* Reset inflate/SHA1 if there was an error reading the previous temp 	   file; also rewind to the beginning of the local file. */
if|if
condition|(
name|prev_read
operator|==
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|&
name|request
operator|->
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|request
operator|->
name|stream
argument_list|)
expr_stmt|;
name|SHA1_Init
argument_list|(
operator|&
name|request
operator|->
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_posn
operator|>
literal|0
condition|)
block|{
name|prev_posn
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|request
operator|->
name|local_fileno
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ftruncate
argument_list|(
name|request
operator|->
name|local_fileno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_sha1_file
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_ERRORBUFFER
argument_list|,
name|request
operator|->
name|errorstr
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|no_pragma_header
argument_list|)
expr_stmt|;
comment|/* If we have successfully processed data from a previous fetch 	   attempt, only fetch the data we don't already have. */
if|if
condition|(
name|prev_posn
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Resuming fetch of object %s at byte %ld\n"
argument_list|,
name|hex
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|range
argument_list|,
literal|"Range: bytes=%ld-"
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|range_header
operator|=
name|curl_slist_append
argument_list|(
name|range_header
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|range_header
argument_list|)
expr_stmt|;
block|}
comment|/* Try to get the request started, abort the request on error */
name|request
operator|->
name|state
operator|=
name|RUN_FETCH_LOOSE
expr_stmt|;
if|if
condition|(
operator|!
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start GET request\n"
argument_list|)
expr_stmt|;
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_mkcol
specifier|static
name|void
name|start_mkcol
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|posn
decl_stmt|;
name|request
operator|->
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|13
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|request
operator|->
name|url
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|=
name|request
operator|->
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"objects/"
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|posn
argument_list|,
name|hex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* undo PUT setup */
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_ERRORBUFFER
argument_list|,
name|request
operator|->
name|errorstr
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_MKCOL
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_MKCOL
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|start_fetch_packed
specifier|static
name|void
name|start_fetch_packed
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|url
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|target
decl_stmt|;
name|FILE
modifier|*
name|packfile
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|long
name|prev_posn
init|=
literal|0
decl_stmt|;
name|char
name|range
index|[
name|RANGE_HEADER_SIZE
index|]
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|range_header
init|=
name|NULL
decl_stmt|;
name|struct
name|transfer_request
modifier|*
name|check_request
init|=
name|request_queue_head
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|target
operator|=
name|find_sha1_pack
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|,
name|remote
operator|->
name|packs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to fetch %s, will not be able to update server info refs\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fetching pack %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|target
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" which contains %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|filename
operator|=
name|sha1_pack_name
argument_list|(
name|target
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|request
operator|->
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|filename
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|)
argument_list|,
literal|"%s.temp"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|64
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%sobjects/pack/pack-%s.pack"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|sha1_to_hex
argument_list|(
name|target
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure there isn't another open request for this pack */
while|while
condition|(
name|check_request
condition|)
block|{
if|if
condition|(
name|check_request
operator|->
name|state
operator|==
name|RUN_FETCH_PACKED
operator|&&
operator|!
name|strcmp
argument_list|(
name|check_request
operator|->
name|url
argument_list|,
name|url
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
name|check_request
operator|=
name|check_request
operator|->
name|next
expr_stmt|;
block|}
name|packfile
operator|=
name|fopen
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|packfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open local file %s for pack"
argument_list|,
name|request
operator|->
name|tmpfile
argument_list|)
expr_stmt|;
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return;
block|}
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|local_stream
operator|=
name|packfile
expr_stmt|;
name|request
operator|->
name|userData
operator|=
name|target
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|url
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
name|packfile
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|no_pragma_header
argument_list|)
expr_stmt|;
name|slot
operator|->
name|local
operator|=
name|packfile
expr_stmt|;
comment|/* If there is data present from a previous transfer attempt, 	   resume where it left off */
name|prev_posn
operator|=
name|ftell
argument_list|(
name|packfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_posn
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Resuming fetch of pack %s at byte %ld\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|target
operator|->
name|sha1
argument_list|)
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|range
argument_list|,
literal|"Range: bytes=%ld-"
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|range_header
operator|=
name|curl_slist_append
argument_list|(
name|range_header
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|range_header
argument_list|)
expr_stmt|;
block|}
comment|/* Try to get the request started, abort the request on error */
name|request
operator|->
name|state
operator|=
name|RUN_FETCH_PACKED
expr_stmt|;
if|if
condition|(
operator|!
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start GET request\n"
argument_list|)
expr_stmt|;
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_put
specifier|static
name|void
name|start_put
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|char
modifier|*
name|posn
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
name|hdr
index|[
literal|50
index|]
decl_stmt|;
name|void
modifier|*
name|unpacked
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|unpacked
operator|=
name|read_sha1_file
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Set it up */
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|deflateInit
argument_list|(
operator|&
name|stream
argument_list|,
name|zlib_compression_level
argument_list|)
expr_stmt|;
name|size
operator|=
name|deflateBound
argument_list|(
operator|&
name|stream
argument_list|,
name|len
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|request
operator|->
name|buffer
operator|.
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|request
operator|->
name|buffer
operator|.
name|posn
operator|=
literal|0
expr_stmt|;
comment|/* Compress it */
name|stream
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|request
operator|->
name|buffer
operator|.
name|buf
operator|.
name|buf
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
comment|/* First header.. */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|hdr
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|hdrlen
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
comment|/* Then the data itself.. */
name|stream
operator|.
name|next_in
operator|=
name|unpacked
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
name|deflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unpacked
argument_list|)
expr_stmt|;
name|request
operator|->
name|buffer
operator|.
name|buf
operator|.
name|len
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|request
operator|->
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|51
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|request
operator|->
name|url
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|=
name|request
operator|->
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
literal|"objects/"
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|posn
argument_list|,
name|hex
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|posn
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
name|hex
operator|+
literal|2
argument_list|)
expr_stmt|;
name|request
operator|->
name|dest
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|request
operator|->
name|url
argument_list|)
operator|+
literal|14
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|request
operator|->
name|dest
argument_list|,
literal|"Destination: %s"
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|posn
operator|+=
literal|38
expr_stmt|;
operator|*
operator|(
name|posn
operator|++
operator|)
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|posn
argument_list|,
name|request
operator|->
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|request
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|request
operator|->
name|buffer
operator|.
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PUT
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_PUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_PUT
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|start_move
specifier|static
name|void
name|start_move
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|callback_func
operator|=
name|process_response
expr_stmt|;
name|slot
operator|->
name|callback_data
operator|=
name|request
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* undo PUT setup */
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_MOVE
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|request
operator|->
name|dest
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Overwrite: T"
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|request
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|RUN_MOVE
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|refresh_lock
specifier|static
name|int
name|refresh_lock
parameter_list|(
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|char
modifier|*
name|if_header
decl_stmt|;
name|char
name|timeout_header
index|[
literal|25
index|]
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|lock
operator|->
name|refreshing
operator|=
literal|1
expr_stmt|;
name|if_header
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|25
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|if_header
argument_list|,
literal|"If: (<opaquelocktoken:%s>)"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timeout_header
argument_list|,
literal|"Timeout: Second-%ld"
argument_list|,
name|lock
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|if_header
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|timeout_header
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_LOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LOCK HTTP error %ld\n"
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock
operator|->
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|lock
operator|->
name|refreshing
operator|=
literal|0
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|if_header
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|check_locks
specifier|static
name|void
name|check_locks
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_lock
modifier|*
name|lock
init|=
name|remote
operator|->
name|locks
decl_stmt|;
name|time_t
name|current_time
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|time_remaining
decl_stmt|;
while|while
condition|(
name|lock
condition|)
block|{
name|time_remaining
operator|=
name|lock
operator|->
name|start_time
operator|+
name|lock
operator|->
name|timeout
operator|-
name|current_time
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|->
name|refreshing
operator|&&
name|time_remaining
operator|<
name|LOCK_REFRESH
condition|)
block|{
if|if
condition|(
operator|!
name|refresh_lock
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to refresh lock for %s\n"
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|lock
operator|=
name|lock
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|release_request
specifier|static
name|void
name|release_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|entry
init|=
name|request_queue_head
decl_stmt|;
if|if
condition|(
name|request
operator|==
name|request_queue_head
condition|)
block|{
name|request_queue_head
operator|=
name|request
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|next
operator|!=
name|request
condition|)
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|==
name|request
condition|)
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|next
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|local_fileno
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|request
operator|->
name|local_fileno
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|local_stream
condition|)
name|fclose
argument_list|(
name|request
operator|->
name|local_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|url
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finish_request
specifier|static
name|void
name|finish_request
parameter_list|(
name|struct
name|transfer_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|target
decl_stmt|;
name|struct
name|packed_git
modifier|*
modifier|*
name|lst
decl_stmt|;
name|request
operator|->
name|curl_result
operator|=
name|request
operator|->
name|slot
operator|->
name|curl_result
expr_stmt|;
name|request
operator|->
name|http_code
operator|=
name|request
operator|->
name|slot
operator|->
name|http_code
expr_stmt|;
name|request
operator|->
name|slot
operator|=
name|NULL
expr_stmt|;
comment|/* Keep locks active */
name|check_locks
argument_list|()
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|headers
operator|!=
name|NULL
condition|)
name|curl_slist_free_all
argument_list|(
name|request
operator|->
name|headers
argument_list|)
expr_stmt|;
comment|/* URL is reused for MOVE after PUT */
if|if
condition|(
name|request
operator|->
name|state
operator|!=
name|RUN_PUT
condition|)
block|{
name|free
argument_list|(
name|request
operator|->
name|url
argument_list|)
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_MKCOL
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
operator|||
name|request
operator|->
name|http_code
operator|==
literal|405
condition|)
block|{
name|remote_dir_exists
index|[
name|request
operator|->
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|start_put
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MKCOL %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_PUT
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|start_move
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_MOVE
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    sent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|obj
operator|->
name|flags
operator||=
name|REMOTE
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MOVE %s failed, aborting (%d/%ld)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|request
operator|->
name|curl_result
argument_list|,
name|request
operator|->
name|http_code
argument_list|)
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|ABORTED
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_FETCH_LOOSE
condition|)
block|{
name|fchmod
argument_list|(
name|request
operator|->
name|local_fileno
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|request
operator|->
name|local_fileno
argument_list|)
expr_stmt|;
name|request
operator|->
name|local_fileno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|curl_result
operator|!=
name|CURLE_OK
operator|&&
name|request
operator|->
name|http_code
operator|!=
literal|416
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
name|unlink
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|request
operator|->
name|http_code
operator|==
literal|416
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: requested range invalid; we may already have all the data.\n"
argument_list|)
expr_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|request
operator|->
name|stream
argument_list|)
expr_stmt|;
name|SHA1_Final
argument_list|(
name|request
operator|->
name|real_sha1
argument_list|,
operator|&
name|request
operator|->
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|zret
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|unlink
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hashcmp
argument_list|(
name|request
operator|->
name|obj
operator|->
name|sha1
argument_list|,
name|request
operator|->
name|real_sha1
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|rename
operator|=
name|move_temp_to_file
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
name|request
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|rename
operator|==
literal|0
condition|)
block|{
name|request
operator|->
name|obj
operator|->
name|flags
operator||=
operator|(
name|LOCAL
operator||
name|REMOTE
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Try fetching packed if necessary */
if|if
condition|(
name|request
operator|->
name|obj
operator|->
name|flags
operator|&
name|LOCAL
condition|)
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
else|else
name|start_fetch_packed
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|RUN_FETCH_PACKED
condition|)
block|{
if|if
condition|(
name|request
operator|->
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to get pack file %s\n%s"
argument_list|,
name|request
operator|->
name|url
argument_list|,
name|curl_errorstr
argument_list|)
expr_stmt|;
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|off_t
name|pack_size
init|=
name|ftell
argument_list|(
name|request
operator|->
name|local_stream
argument_list|)
decl_stmt|;
name|fclose
argument_list|(
name|request
operator|->
name|local_stream
argument_list|)
expr_stmt|;
name|request
operator|->
name|local_stream
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|move_temp_to_file
argument_list|(
name|request
operator|->
name|tmpfile
argument_list|,
name|request
operator|->
name|filename
argument_list|)
condition|)
block|{
name|target
operator|=
operator|(
expr|struct
name|packed_git
operator|*
operator|)
name|request
operator|->
name|userData
expr_stmt|;
name|target
operator|->
name|pack_size
operator|=
name|pack_size
expr_stmt|;
name|lst
operator|=
operator|&
name|remote
operator|->
name|packs
expr_stmt|;
while|while
condition|(
operator|*
name|lst
operator|!=
name|target
condition|)
name|lst
operator|=
operator|&
operator|(
operator|(
operator|*
name|lst
operator|)
operator|->
name|next
operator|)
expr_stmt|;
operator|*
name|lst
operator|=
operator|(
operator|*
name|lst
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|verify_pack
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
condition|)
name|install_packed_git
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
end_ifdef
begin_function
DECL|function|fill_active_slot
specifier|static
name|int
name|fill_active_slot
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
name|request_queue_head
decl_stmt|;
if|if
condition|(
name|aborted
condition|)
return|return
literal|0
return|;
for|for
control|(
name|request
operator|=
name|request_queue_head
init|;
name|request
condition|;
name|request
operator|=
name|request
operator|->
name|next
control|)
block|{
if|if
condition|(
name|request
operator|->
name|state
operator|==
name|NEED_FETCH
condition|)
block|{
name|start_fetch_loose
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|pushing
operator|&&
name|request
operator|->
name|state
operator|==
name|NEED_PUSH
condition|)
block|{
if|if
condition|(
name|remote_dir_exists
index|[
name|request
operator|->
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|==
literal|1
condition|)
block|{
name|start_put
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_mkcol
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
specifier|static
name|void
name|get_remote_object_list
parameter_list|(
name|unsigned
name|char
name|parent
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|add_fetch_request
specifier|static
name|void
name|add_fetch_request
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
decl_stmt|;
name|check_locks
argument_list|()
expr_stmt|;
comment|/* 	 * Don't fetch the object if it's known to exist locally 	 * or is already in the request queue 	 */
if|if
condition|(
name|remote_dir_exists
index|[
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|==
operator|-
literal|1
condition|)
name|get_remote_object_list
argument_list|(
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|LOCAL
operator||
name|FETCHING
operator|)
condition|)
return|return;
name|obj
operator|->
name|flags
operator||=
name|FETCHING
expr_stmt|;
name|request
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|lock
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|headers
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|local_fileno
operator|=
operator|-
literal|1
expr_stmt|;
name|request
operator|->
name|local_stream
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|NEED_FETCH
expr_stmt|;
name|request
operator|->
name|next
operator|=
name|request_queue_head
expr_stmt|;
name|request_queue_head
operator|=
name|request
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|fill_active_slots
argument_list|()
expr_stmt|;
name|step_active_slots
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|add_send_request
specifier|static
name|int
name|add_send_request
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
init|=
name|request_queue_head
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|target
decl_stmt|;
comment|/* Keep locks active */
name|check_locks
argument_list|()
expr_stmt|;
comment|/* 	 * Don't push the object if it's known to exist on the remote 	 * or is already in the request queue 	 */
if|if
condition|(
name|remote_dir_exists
index|[
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
index|]
operator|==
operator|-
literal|1
condition|)
name|get_remote_object_list
argument_list|(
name|obj
operator|->
name|sha1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|REMOTE
operator||
name|PUSHING
operator|)
condition|)
return|return
literal|0
return|;
name|target
operator|=
name|find_sha1_pack
argument_list|(
name|obj
operator|->
name|sha1
argument_list|,
name|remote
operator|->
name|packs
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
name|obj
operator|->
name|flags
operator||=
name|REMOTE
expr_stmt|;
return|return
literal|0
return|;
block|}
name|obj
operator|->
name|flags
operator||=
name|PUSHING
expr_stmt|;
name|request
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|request
operator|->
name|url
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|request
operator|->
name|headers
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|local_fileno
operator|=
operator|-
literal|1
expr_stmt|;
name|request
operator|->
name|local_stream
operator|=
name|NULL
expr_stmt|;
name|request
operator|->
name|state
operator|=
name|NEED_PUSH
expr_stmt|;
name|request
operator|->
name|next
operator|=
name|request_queue_head
expr_stmt|;
name|request_queue_head
operator|=
name|request
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|fill_active_slots
argument_list|()
expr_stmt|;
name|step_active_slots
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fetch_index
specifier|static
name|int
name|fetch_index
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|char
name|tmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|long
name|prev_posn
init|=
literal|0
decl_stmt|;
name|char
name|range
index|[
name|RANGE_HEADER_SIZE
index|]
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|range_header
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|indexfile
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
comment|/* Don't use the index if the pack isn't there */
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|64
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%sobjects/pack/pack-%s.pack"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to verify pack %s is available"
argument_list|,
name|hex
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
if|if
condition|(
name|has_pack_index
argument_list|(
name|sha1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Getting index for pack %s\n"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%sobjects/pack/pack-%s.idx"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|filename
operator|=
name|sha1_pack_index_name
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"%s.temp"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|indexfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexfile
condition|)
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to open local file %s for pack index"
argument_list|,
name|tmpfile
argument_list|)
return|;
block|}
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
name|indexfile
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|no_pragma_header
argument_list|)
expr_stmt|;
name|slot
operator|->
name|local
operator|=
name|indexfile
expr_stmt|;
comment|/* If there is data present from a previous transfer attempt, 	   resume where it left off */
name|prev_posn
operator|=
name|ftell
argument_list|(
name|indexfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_posn
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Resuming fetch of index for pack %s at byte %ld\n"
argument_list|,
name|hex
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|range
argument_list|,
literal|"Range: bytes=%ld-"
argument_list|,
name|prev_posn
argument_list|)
expr_stmt|;
name|range_header
operator|=
name|curl_slist_append
argument_list|(
name|range_header
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|range_header
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|indexfile
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to get pack index %s\n%s"
argument_list|,
name|url
argument_list|,
name|curl_errorstr
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|indexfile
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|indexfile
argument_list|)
expr_stmt|;
return|return
name|move_temp_to_file
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setup_index
specifier|static
name|int
name|setup_index
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|new_pack
decl_stmt|;
if|if
condition|(
name|fetch_index
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|new_pack
operator|=
name|parse_pack_index
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|new_pack
operator|->
name|next
operator|=
name|remote
operator|->
name|packs
expr_stmt|;
name|remote
operator|->
name|packs
operator|=
name|new_pack
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fetch_indices
specifier|static
name|int
name|fetch_indices
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|struct
name|strbuf
name|buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
if|if
condition|(
name|push_verbosely
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Getting pack list\n"
argument_list|)
expr_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%sobjects/info/packs"
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|http_code
operator|==
literal|404
condition|)
return|return
literal|0
return|;
else|else
return|return
name|error
argument_list|(
literal|"%s"
argument_list|,
name|curl_errorstr
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|strbuf_release
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start request"
argument_list|)
return|;
block|}
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|data
operator|=
name|buffer
operator|.
name|buf
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|buffer
operator|.
name|len
condition|)
block|{
switch|switch
condition|(
name|data
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'P'
case|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|52
operator|<
name|buffer
operator|.
name|len
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|data
operator|+
name|i
argument_list|,
literal|" pack-"
argument_list|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|data
operator|+
name|i
operator|+
literal|46
argument_list|,
literal|".pack\n"
argument_list|)
condition|)
block|{
name|get_sha1_hex
argument_list|(
name|data
operator|+
name|i
operator|+
literal|6
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|setup_index
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|51
expr_stmt|;
break|break;
block|}
default|default:
while|while
condition|(
name|data
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|one_remote_object
specifier|static
name|void
name|one_remote_object
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|hex
argument_list|,
name|sha1
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|obj
operator|=
name|lookup_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|obj
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
comment|/* Ignore remote objects that don't exist locally */
if|if
condition|(
operator|!
name|obj
condition|)
return|return;
name|obj
operator|->
name|flags
operator||=
name|REMOTE
expr_stmt|;
if|if
condition|(
operator|!
name|object_list_contains
argument_list|(
name|objects
argument_list|,
name|obj
argument_list|)
condition|)
name|object_list_insert
argument_list|(
name|obj
argument_list|,
operator|&
name|objects
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_lockprop_ctx
specifier|static
name|void
name|handle_lockprop_ctx
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
block|{
name|int
modifier|*
name|lock_flags
init|=
operator|(
name|int
operator|*
operator|)
name|ctx
operator|->
name|userData
decl_stmt|;
if|if
condition|(
name|tag_closed
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_CTX_LOCKENTRY
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|lock_flags
operator|&
name|DAV_PROP_LOCKEX
operator|)
operator|&&
operator|(
operator|*
name|lock_flags
operator|&
name|DAV_PROP_LOCKWR
operator|)
condition|)
block|{
operator|*
name|lock_flags
operator||=
name|DAV_LOCK_OK
expr_stmt|;
block|}
operator|*
name|lock_flags
operator|&=
name|DAV_LOCK_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_CTX_LOCKTYPE_WRITE
argument_list|)
condition|)
block|{
operator|*
name|lock_flags
operator||=
name|DAV_PROP_LOCKWR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_CTX_LOCKTYPE_EXCLUSIVE
argument_list|)
condition|)
block|{
operator|*
name|lock_flags
operator||=
name|DAV_PROP_LOCKEX
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|handle_new_lock_ctx
specifier|static
name|void
name|handle_new_lock_ctx
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
block|{
name|struct
name|remote_lock
modifier|*
name|lock
init|=
operator|(
expr|struct
name|remote_lock
operator|*
operator|)
name|ctx
operator|->
name|userData
decl_stmt|;
if|if
condition|(
name|tag_closed
operator|&&
name|ctx
operator|->
name|cdata
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_ACTIVELOCK_OWNER
argument_list|)
condition|)
block|{
name|lock
operator|->
name|owner
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lock
operator|->
name|owner
argument_list|,
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_ACTIVELOCK_TIMEOUT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|,
literal|"Second-"
argument_list|)
condition|)
name|lock
operator|->
name|timeout
operator|=
name|strtol
argument_list|(
name|ctx
operator|->
name|cdata
operator|+
literal|7
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_ACTIVELOCK_TOKEN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|,
literal|"opaquelocktoken:"
argument_list|)
condition|)
block|{
name|lock
operator|->
name|token
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
operator|-
literal|15
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lock
operator|->
name|token
argument_list|,
name|ctx
operator|->
name|cdata
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|one_remote_ref
parameter_list|(
name|char
modifier|*
name|refname
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
name|void
DECL|function|xml_start_tag
name|xml_start_tag
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|atts
parameter_list|)
block|{
name|struct
name|xml_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|xml_ctx
operator|*
operator|)
name|userData
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|int
name|new_len
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|name
expr_stmt|;
else|else
name|c
operator|++
expr_stmt|;
name|new_len
operator|=
name|strlen
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|c
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|new_len
operator|>
name|ctx
operator|->
name|len
condition|)
block|{
name|ctx
operator|->
name|name
operator|=
name|xrealloc
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|len
operator|=
name|new_len
expr_stmt|;
block|}
name|strcat
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|userFunc
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xml_end_tag
name|xml_end_tag
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|xml_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|xml_ctx
operator|*
operator|)
name|userData
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|ctx
operator|->
name|userFunc
argument_list|(
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|name
expr_stmt|;
else|else
name|c
operator|++
expr_stmt|;
name|ep
operator|=
name|ctx
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|c
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|xml_cdata
name|xml_cdata
parameter_list|(
name|void
modifier|*
name|userData
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|xml_ctx
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|xml_ctx
operator|*
operator|)
name|userData
decl_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cdata
operator|=
name|xmemdupz
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lock_remote
specifier|static
name|struct
name|remote_lock
modifier|*
name|lock_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|strbuf
name|in_buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|char
name|timeout_header
index|[
literal|25
index|]
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|lock
init|=
name|NULL
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|struct
name|xml_ctx
name|ctx
decl_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Make sure leading directories exist for the remote ref */
name|ep
operator|=
name|strchr
argument_list|(
name|url
operator|+
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_MKCOL
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
operator|&&
name|results
operator|.
name|http_code
operator|!=
literal|405
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to create branch path %s\n"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start MKCOL request\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|ep
operator|=
literal|'/'
expr_stmt|;
name|ep
operator|=
name|strchr
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
name|LOCK_REQUEST
argument_list|,
name|git_default_email
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timeout_header
argument_list|,
literal|"Timeout: Second-%ld"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|timeout_header
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|out_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|out_buffer
operator|.
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_LOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|lock
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|ctx
operator|.
name|name
operator|=
name|xcalloc
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|.
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|userFunc
operator|=
name|handle_new_lock_ctx
expr_stmt|;
name|ctx
operator|.
name|userData
operator|=
name|lock
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|xml_start_tag
argument_list|,
name|xml_end_tag
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|xml_cdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buf
argument_list|,
name|in_buffer
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XML error: %s\n"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start LOCK request\n"
argument_list|)
expr_stmt|;
block|}
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|token
operator|==
name|NULL
operator|||
name|lock
operator|->
name|timeout
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|lock
operator|->
name|token
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|lock
operator|->
name|url
operator|=
name|url
expr_stmt|;
name|lock
operator|->
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|lock
operator|->
name|next
operator|=
name|remote
operator|->
name|locks
expr_stmt|;
name|remote
operator|->
name|locks
operator|=
name|lock
expr_stmt|;
block|}
return|return
name|lock
return|;
block|}
end_function
begin_function
DECL|function|unlock_remote
specifier|static
name|int
name|unlock_remote
parameter_list|(
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|prev
init|=
name|remote
operator|->
name|locks
decl_stmt|;
name|char
modifier|*
name|lock_token_header
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|lock_token_header
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|31
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|lock_token_header
argument_list|,
literal|"Lock-Token:<opaquelocktoken:%s>"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|lock_token_header
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_UNLOCK
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
name|rc
operator|=
literal|1
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UNLOCK HTTP error %ld\n"
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start UNLOCK request\n"
argument_list|)
expr_stmt|;
block|}
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock_token_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote
operator|->
name|locks
operator|==
name|lock
condition|)
block|{
name|remote
operator|->
name|locks
operator|=
name|lock
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|prev
operator|&&
name|prev
operator|->
name|next
operator|!=
name|lock
condition|)
name|prev
operator|=
name|prev
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|prev
operator|->
name|next
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|remote_ls
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|process_ls_object
specifier|static
name|void
name|process_ls_object
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|parent
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|ls
operator|->
name|userData
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|ls
operator|->
name|dentry_name
decl_stmt|;
name|char
modifier|*
name|obj_hex
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ls
operator|->
name|path
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
operator|&&
operator|(
name|ls
operator|->
name|flags
operator|&
name|IS_DIR
operator|)
condition|)
block|{
name|remote_dir_exists
index|[
operator|*
name|parent
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|!=
literal|49
condition|)
return|return;
name|path
operator|+=
literal|8
expr_stmt|;
name|obj_hex
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: path is not null-terminated, can not use strlcpy here */
name|memcpy
argument_list|(
name|obj_hex
argument_list|,
name|path
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|obj_hex
operator|+
literal|2
argument_list|,
name|path
operator|+
literal|3
argument_list|)
expr_stmt|;
name|one_remote_object
argument_list|(
name|obj_hex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj_hex
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|process_ls_ref
specifier|static
name|void
name|process_ls_ref
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ls
operator|->
name|path
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
operator|&&
operator|(
name|ls
operator|->
name|dentry_flags
operator|&
name|IS_DIR
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s\n"
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|ls
operator|->
name|dentry_flags
operator|&
name|IS_DIR
operator|)
condition|)
name|one_remote_ref
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_remote_ls_ctx
specifier|static
name|void
name|handle_remote_ls_ctx
parameter_list|(
name|struct
name|xml_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|tag_closed
parameter_list|)
block|{
name|struct
name|remote_ls_ctx
modifier|*
name|ls
init|=
operator|(
expr|struct
name|remote_ls_ctx
operator|*
operator|)
name|ctx
operator|->
name|userData
decl_stmt|;
if|if
condition|(
name|tag_closed
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_RESP
argument_list|)
operator|&&
name|ls
operator|->
name|dentry_name
condition|)
block|{
if|if
condition|(
name|ls
operator|->
name|dentry_flags
operator|&
name|IS_DIR
condition|)
block|{
if|if
condition|(
name|ls
operator|->
name|flags
operator|&
name|PROCESS_DIRS
condition|)
block|{
name|ls
operator|->
name|userFunc
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|,
name|ls
operator|->
name|path
argument_list|)
operator|&&
name|ls
operator|->
name|flags
operator|&
name|RECURSIVE
condition|)
block|{
name|remote_ls
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|,
name|ls
operator|->
name|flags
argument_list|,
name|ls
operator|->
name|userFunc
argument_list|,
name|ls
operator|->
name|userData
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ls
operator|->
name|flags
operator|&
name|PROCESS_FILES
condition|)
block|{
name|ls
operator|->
name|userFunc
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_NAME
argument_list|)
operator|&&
name|ctx
operator|->
name|cdata
condition|)
block|{
name|ls
operator|->
name|dentry_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|ctx
operator|->
name|cdata
argument_list|)
operator|-
name|remote
operator|->
name|path_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|,
name|ctx
operator|->
name|cdata
operator|+
name|remote
operator|->
name|path_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_COLLECTION
argument_list|)
condition|)
block|{
name|ls
operator|->
name|dentry_flags
operator||=
name|IS_DIR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|->
name|name
argument_list|,
name|DAV_PROPFIND_RESP
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|ls
operator|->
name|dentry_name
operator|=
name|NULL
expr_stmt|;
name|ls
operator|->
name|dentry_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|remote_ls
specifier|static
name|void
name|remote_ls
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|userFunc
function_decl|)
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
parameter_list|,
name|void
modifier|*
name|userData
parameter_list|)
block|{
name|char
modifier|*
name|url
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|strbuf
name|in_buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|struct
name|xml_ctx
name|ctx
decl_stmt|;
name|struct
name|remote_ls_ctx
name|ls
decl_stmt|;
name|ls
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|ls
operator|.
name|path
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|ls
operator|.
name|dentry_name
operator|=
name|NULL
expr_stmt|;
name|ls
operator|.
name|dentry_flags
operator|=
literal|0
expr_stmt|;
name|ls
operator|.
name|userData
operator|=
name|userData
expr_stmt|;
name|ls
operator|.
name|userFunc
operator|=
name|userFunc
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
name|PROPFIND_ALL_REQUEST
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Depth: 1"
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|out_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|out_buffer
operator|.
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PROPFIND
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|ctx
operator|.
name|name
operator|=
name|xcalloc
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|.
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|userFunc
operator|=
name|handle_remote_ls_ctx
expr_stmt|;
name|ctx
operator|.
name|userData
operator|=
operator|&
name|ls
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|xml_start_tag
argument_list|,
name|xml_end_tag
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|xml_cdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buf
argument_list|,
name|in_buffer
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XML error: %s\n"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start PROPFIND request\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ls
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_remote_object_list
specifier|static
name|void
name|get_remote_object_list
parameter_list|(
name|unsigned
name|char
name|parent
parameter_list|)
block|{
name|char
name|path
index|[]
init|=
literal|"objects/XX/"
decl_stmt|;
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|unsigned
name|int
name|val
init|=
name|parent
decl_stmt|;
name|path
index|[
literal|8
index|]
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
name|path
index|[
literal|9
index|]
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
name|remote_dir_exists
index|[
name|val
index|]
operator|=
literal|0
expr_stmt|;
name|remote_ls
argument_list|(
name|path
argument_list|,
operator|(
name|PROCESS_FILES
operator||
name|PROCESS_DIRS
operator|)
argument_list|,
name|process_ls_object
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|locking_available
specifier|static
name|int
name|locking_available
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|struct
name|strbuf
name|in_buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|struct
name|xml_ctx
name|ctx
decl_stmt|;
name|int
name|lock_flags
init|=
literal|0
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
name|PROPFIND_SUPPORTEDLOCK_REQUEST
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Depth: 0"
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
literal|"Content-Type: text/xml"
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|out_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|out_buffer
operator|.
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PROPFIND
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
block|{
name|XML_Parser
name|parser
init|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|enum
name|XML_Status
name|result
decl_stmt|;
name|ctx
operator|.
name|name
operator|=
name|xcalloc
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctx
operator|.
name|cdata
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|.
name|userFunc
operator|=
name|handle_lockprop_ctx
expr_stmt|;
name|ctx
operator|.
name|userData
operator|=
operator|&
name|lock_flags
expr_stmt|;
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|xml_start_tag
argument_list|,
name|xml_end_tag
argument_list|)
expr_stmt|;
name|result
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|in_buffer
operator|.
name|buf
argument_list|,
name|in_buffer
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XML error: %s\n"
argument_list|,
name|XML_ErrorString
argument_list|(
name|XML_GetErrorCode
argument_list|(
name|parser
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lock_flags
operator|=
literal|0
expr_stmt|;
block|}
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock_flags
condition|)
name|error
argument_list|(
literal|"Error: no DAV locking support on %s"
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Cannot access URL %s, return code %d"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|results
operator|.
name|curl_result
argument_list|)
expr_stmt|;
name|lock_flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"Unable to start PROPFIND request on %s"
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|in_buffer
argument_list|)
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|dav_headers
argument_list|)
expr_stmt|;
return|return
name|lock_flags
return|;
block|}
end_function
begin_function
DECL|function|add_one_object
specifier|static
name|struct
name|object_list
modifier|*
modifier|*
name|add_one_object
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|struct
name|object_list
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|object_list
modifier|*
name|entry
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object_list
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|->
name|item
operator|=
name|obj
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|entry
expr_stmt|;
return|return
operator|&
name|entry
operator|->
name|next
return|;
block|}
end_function
begin_function
DECL|function|process_blob
specifier|static
name|struct
name|object_list
modifier|*
modifier|*
name|process_blob
parameter_list|(
name|struct
name|blob
modifier|*
name|blob
parameter_list|,
name|struct
name|object_list
modifier|*
modifier|*
name|p
parameter_list|,
name|struct
name|name_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
operator|&
name|blob
operator|->
name|object
decl_stmt|;
name|obj
operator|->
name|flags
operator||=
name|LOCAL
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|UNINTERESTING
operator||
name|SEEN
operator|)
condition|)
return|return
name|p
return|;
name|obj
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
return|return
name|add_one_object
argument_list|(
name|obj
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|process_tree
specifier|static
name|struct
name|object_list
modifier|*
modifier|*
name|process_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|struct
name|object_list
modifier|*
modifier|*
name|p
parameter_list|,
name|struct
name|name_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
operator|&
name|tree
operator|->
name|object
decl_stmt|;
name|struct
name|tree_desc
name|desc
decl_stmt|;
name|struct
name|name_entry
name|entry
decl_stmt|;
name|struct
name|name_path
name|me
decl_stmt|;
name|obj
operator|->
name|flags
operator||=
name|LOCAL
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|UNINTERESTING
operator||
name|SEEN
operator|)
condition|)
return|return
name|p
return|;
if|if
condition|(
name|parse_tree
argument_list|(
name|tree
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"bad tree object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|add_one_object
argument_list|(
name|obj
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|me
operator|.
name|up
operator|=
name|path
expr_stmt|;
name|me
operator|.
name|elem
operator|=
name|name
expr_stmt|;
name|me
operator|.
name|elem_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tree_entry
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
switch|switch
condition|(
name|object_type
argument_list|(
name|entry
operator|.
name|mode
argument_list|)
condition|)
block|{
case|case
name|OBJ_TREE
case|:
name|p
operator|=
name|process_tree
argument_list|(
name|lookup_tree
argument_list|(
name|entry
operator|.
name|sha1
argument_list|)
argument_list|,
name|p
argument_list|,
operator|&
name|me
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_BLOB
case|:
name|p
operator|=
name|process_blob
argument_list|(
name|lookup_blob
argument_list|(
name|entry
operator|.
name|sha1
argument_list|)
argument_list|,
name|p
argument_list|,
operator|&
name|me
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Subproject commit - not in this repository */
break|break;
block|}
name|free
argument_list|(
name|tree
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|tree
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|get_delta
specifier|static
name|int
name|get_delta
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|object_list
modifier|*
modifier|*
name|p
init|=
operator|&
name|objects
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
name|revs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|process_tree
argument_list|(
name|commit
operator|->
name|tree
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|LOCAL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
name|count
operator|+=
name|add_send_request
argument_list|(
operator|&
name|commit
operator|->
name|object
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revs
operator|->
name|pending
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object_array_entry
modifier|*
name|entry
init|=
name|revs
operator|->
name|pending
operator|.
name|objects
operator|+
name|i
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
init|=
name|entry
operator|->
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|entry
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
operator|(
name|UNINTERESTING
operator||
name|SEEN
operator|)
condition|)
continue|continue;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|obj
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
name|p
operator|=
name|add_one_object
argument_list|(
name|obj
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TREE
condition|)
block|{
name|p
operator|=
name|process_tree
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|obj
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_BLOB
condition|)
block|{
name|p
operator|=
name|process_blob
argument_list|(
operator|(
expr|struct
name|blob
operator|*
operator|)
name|obj
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|die
argument_list|(
literal|"unknown pending object %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|objects
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|objects
operator|->
name|item
operator|->
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
name|count
operator|+=
name|add_send_request
argument_list|(
name|objects
operator|->
name|item
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|objects
operator|=
name|objects
operator|->
name|next
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|update_remote
specifier|static
name|int
name|update_remote
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|char
modifier|*
name|if_header
decl_stmt|;
name|struct
name|buffer
name|out_buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|if_header
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|25
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|if_header
argument_list|,
literal|"If: (<opaquelocktoken:%s>)"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|if_header
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|out_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|out_buffer
operator|.
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PUT
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_PUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|if_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT error: curl result=%d, HTTP code=%ld\n"
argument_list|,
name|results
operator|.
name|curl_result
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
comment|/* We should attempt recovery? */
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|strbuf_release
argument_list|(
operator|&
name|out_buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|if_header
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start PUT request\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|local_refs
DECL|variable|local_tail
specifier|static
name|struct
name|ref
modifier|*
name|local_refs
decl_stmt|,
modifier|*
modifier|*
name|local_tail
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remote_refs
DECL|variable|remote_tail
specifier|static
name|struct
name|ref
modifier|*
name|remote_refs
decl_stmt|,
modifier|*
modifier|*
name|remote_tail
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|one_local_ref
specifier|static
name|int
name|one_local_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|refname
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|local_tail
operator|=
name|ref
expr_stmt|;
name|local_tail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|one_remote_ref
specifier|static
name|void
name|one_remote_ref
parameter_list|(
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|unsigned
name|char
name|remote_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|http_fetch_ref
argument_list|(
name|remote
operator|->
name|url
argument_list|,
name|refname
operator|+
literal|5
comment|/* "refs/" */
argument_list|,
name|remote_sha1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to fetch ref %s from %s\n"
argument_list|,
name|refname
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fetch a copy of the object if it doesn't exist locally - it 	 * may be required for updating server info later. 	 */
if|if
condition|(
name|remote
operator|->
name|can_update_info_refs
operator|&&
operator|!
name|has_sha1_file
argument_list|(
name|remote_sha1
argument_list|)
condition|)
block|{
name|obj
operator|=
name|lookup_unknown_object
argument_list|(
name|remote_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  fetch %s for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
name|add_fetch_request
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|remote_sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|refname
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|remote_tail
operator|=
name|ref
expr_stmt|;
name|remote_tail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_local_heads
specifier|static
name|void
name|get_local_heads
parameter_list|(
name|void
parameter_list|)
block|{
name|local_tail
operator|=
operator|&
name|local_refs
expr_stmt|;
name|for_each_ref
argument_list|(
name|one_local_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_dav_remote_heads
specifier|static
name|void
name|get_dav_remote_heads
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_tail
operator|=
operator|&
name|remote_refs
expr_stmt|;
name|remote_ls
argument_list|(
literal|"refs/"
argument_list|,
operator|(
name|PROCESS_FILES
operator||
name|PROCESS_DIRS
operator||
name|RECURSIVE
operator|)
argument_list|,
name|process_ls_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|is_zero_sha1
specifier|static
name|int
name|is_zero_sha1
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sha1
operator|++
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|unmark_and_free
specifier|static
name|void
name|unmark_and_free
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|temp
init|=
name|list
decl_stmt|;
name|temp
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|mark
expr_stmt|;
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ref_newer
specifier|static
name|int
name|ref_newer
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|new_sha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|struct
name|commit
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|list
decl_stmt|,
modifier|*
name|used
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* Both new and old must be commit-ish and new is descendant of 	 * old.  Otherwise we require --force. 	 */
name|o
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|old_sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
literal|0
return|;
name|old
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
expr_stmt|;
name|o
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|new_sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
literal|0
return|;
name|new
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|new
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|used
operator|=
name|list
operator|=
name|NULL
expr_stmt|;
name|commit_list_insert
argument_list|(
name|new
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|new
operator|=
name|pop_most_recent_commit
argument_list|(
operator|&
name|list
argument_list|,
name|TMP_MARK
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|new
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|old
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|unmark_and_free
argument_list|(
name|list
argument_list|,
name|TMP_MARK
argument_list|)
expr_stmt|;
name|unmark_and_free
argument_list|(
name|used
argument_list|,
name|TMP_MARK
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function
begin_function
DECL|function|mark_edge_parents_uninteresting
specifier|static
name|void
name|mark_edge_parents_uninteresting
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
continue|continue;
name|mark_tree_uninteresting
argument_list|(
name|parent
operator|->
name|tree
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|mark_edges_uninteresting
specifier|static
name|void
name|mark_edges_uninteresting
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|list
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
block|{
name|mark_tree_uninteresting
argument_list|(
name|commit
operator|->
name|tree
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mark_edge_parents_uninteresting
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_remote_info_ref
specifier|static
name|void
name|add_remote_info_ref
parameter_list|(
name|struct
name|remote_ls_ctx
modifier|*
name|ls
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|buf
init|=
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|ls
operator|->
name|userData
decl_stmt|;
name|unsigned
name|char
name|remote_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|ref_info
decl_stmt|;
if|if
condition|(
name|http_fetch_ref
argument_list|(
name|remote
operator|->
name|url
argument_list|,
name|ls
operator|->
name|dentry_name
operator|+
literal|5
comment|/* "refs/" */
argument_list|,
name|remote_sha1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to fetch ref %s from %s\n"
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|o
operator|=
name|parse_object
argument_list|(
name|remote_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to parse object %s for remote ref %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
operator|+
literal|42
expr_stmt|;
name|ref_info
operator|=
name|xcalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ref_info
argument_list|,
literal|"%s	%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|fwrite_buffer
argument_list|(
name|ref_info
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|o
operator|=
name|deref_tag
argument_list|(
name|o
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|ls
operator|->
name|dentry_name
argument_list|)
operator|+
literal|45
expr_stmt|;
name|ref_info
operator|=
name|xcalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ref_info
argument_list|,
literal|"%s	%s^{}\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|sha1
argument_list|)
argument_list|,
name|ls
operator|->
name|dentry_name
argument_list|)
expr_stmt|;
name|fwrite_buffer
argument_list|(
name|ref_info
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|update_remote_info_refs
specifier|static
name|void
name|update_remote_info_refs
parameter_list|(
name|struct
name|remote_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|buffer
name|buffer
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|char
modifier|*
name|if_header
decl_stmt|;
name|struct
name|curl_slist
modifier|*
name|dav_headers
init|=
name|NULL
decl_stmt|;
name|remote_ls
argument_list|(
literal|"refs/"
argument_list|,
operator|(
name|PROCESS_FILES
operator||
name|RECURSIVE
operator|)
argument_list|,
name|add_remote_info_ref
argument_list|,
operator|&
name|buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aborted
condition|)
block|{
name|if_header
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|token
argument_list|)
operator|+
literal|25
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|if_header
argument_list|,
literal|"If: (<opaquelocktoken:%s>)"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
name|dav_headers
operator|=
name|curl_slist_append
argument_list|(
name|dav_headers
argument_list|,
name|if_header
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILE
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_INFILESIZE
argument_list|,
name|buffer
operator|.
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_READFUNCTION
argument_list|,
name|fread_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_PUT
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|dav_headers
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_UPLOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_PUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|lock
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PUT error: curl result=%d, HTTP code=%ld\n"
argument_list|,
name|results
operator|.
name|curl_result
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|if_header
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remote_exists
specifier|static
name|int
name|remote_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|url
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_NOBODY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|http_code
operator|==
literal|404
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|results
operator|.
name|curl_result
operator|==
name|CURLE_OK
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HEAD HTTP error %ld\n"
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to start HEAD request\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|fetch_symref
specifier|static
name|void
name|fetch_symref
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|symref
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|url
decl_stmt|;
name|struct
name|strbuf
name|buffer
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_FILE
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_buffer
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPHEADER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
block|{
name|die
argument_list|(
literal|"Couldn't get %s for remote symref\n%s"
argument_list|,
name|url
argument_list|,
name|curl_errorstr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|die
argument_list|(
literal|"Unable to start remote symref request"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|symref
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
name|symref
argument_list|)
expr_stmt|;
operator|*
name|symref
operator|=
name|NULL
expr_stmt|;
name|hashclr
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|len
operator|==
literal|0
condition|)
return|return;
comment|/* If it's a symref, set the refname; otherwise try for a sha1 */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|.
name|buf
argument_list|,
literal|"ref: "
argument_list|)
condition|)
block|{
operator|*
name|symref
operator|=
name|xmemdupz
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|.
name|buf
operator|+
literal|5
argument_list|,
name|buffer
operator|.
name|len
operator|-
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_sha1_hex
argument_list|(
name|buffer
operator|.
name|buf
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|verify_merge_base
specifier|static
name|int
name|verify_merge_base
parameter_list|(
name|unsigned
name|char
modifier|*
name|head_sha1
parameter_list|,
name|unsigned
name|char
modifier|*
name|branch_sha1
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|head
init|=
name|lookup_commit
argument_list|(
name|head_sha1
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|branch
init|=
name|lookup_commit
argument_list|(
name|branch_sha1
argument_list|)
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|merge_bases
init|=
name|get_merge_bases
argument_list|(
name|head
argument_list|,
name|branch
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|merge_bases
operator|&&
operator|!
name|merge_bases
operator|->
name|next
operator|&&
name|merge_bases
operator|->
name|item
operator|==
name|branch
operator|)
return|;
block|}
end_function
begin_function
DECL|function|delete_remote_branch
specifier|static
name|int
name|delete_remote_branch
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|refs
init|=
name|remote_refs
decl_stmt|;
name|struct
name|ref
modifier|*
name|remote_ref
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|symref
init|=
name|NULL
decl_stmt|;
name|int
name|match
decl_stmt|;
name|int
name|patlen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|active_request_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|slot_results
name|results
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|;
comment|/* Find the remote branch(es) matching the specified branch name */
for|for
control|(
name|match
operator|=
literal|0
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|refs
operator|->
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|<
name|patlen
operator|||
name|memcmp
argument_list|(
name|name
operator|+
name|namelen
operator|-
name|patlen
argument_list|,
name|pattern
argument_list|,
name|patlen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|name
index|[
name|namelen
operator|-
name|patlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
name|match
operator|++
expr_stmt|;
name|remote_ref
operator|=
name|refs
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|==
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"No remote branch matches %s"
argument_list|,
name|pattern
argument_list|)
return|;
if|if
condition|(
name|match
operator|!=
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"More than one remote branch matches %s"
argument_list|,
name|pattern
argument_list|)
return|;
comment|/* 	 * Remote HEAD must be a symref (not exactly foolproof; a remote 	 * symlink to a symref will look like a symref) 	 */
name|fetch_symref
argument_list|(
literal|"HEAD"
argument_list|,
operator|&
name|symref
argument_list|,
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symref
condition|)
return|return
name|error
argument_list|(
literal|"Remote HEAD is not a symref"
argument_list|)
return|;
comment|/* Remote branch must not be the remote HEAD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|symref
operator|&&
name|i
operator|<
name|MAXDEPTH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|remote_ref
operator|->
name|name
argument_list|,
name|symref
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Remote branch %s is the current HEAD"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
return|;
name|fetch_symref
argument_list|(
name|symref
argument_list|,
operator|&
name|symref
argument_list|,
name|head_sha1
argument_list|)
expr_stmt|;
block|}
comment|/* Run extra sanity checks if delete is not forced */
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|/* Remote HEAD must resolve to a known object */
if|if
condition|(
name|symref
condition|)
return|return
name|error
argument_list|(
literal|"Remote HEAD symrefs too deep"
argument_list|)
return|;
if|if
condition|(
name|is_zero_sha1
argument_list|(
name|head_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Unable to resolve remote HEAD"
argument_list|)
return|;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|head_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Remote HEAD resolves to object %s\nwhich does not exist locally, perhaps you need to fetch?"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head_sha1
argument_list|)
argument_list|)
return|;
comment|/* Remote branch must resolve to a known object */
if|if
condition|(
name|is_zero_sha1
argument_list|(
name|remote_ref
operator|->
name|old_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Unable to resolve remote branch %s"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|remote_ref
operator|->
name|old_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Remote branch %s resolves to object %s\nwhich does not exist locally, perhaps you need to fetch?"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_ref
operator|->
name|old_sha1
argument_list|)
argument_list|)
return|;
comment|/* Remote branch must be an ancestor of remote HEAD */
if|if
condition|(
operator|!
name|verify_merge_base
argument_list|(
name|head_sha1
argument_list|,
name|remote_ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
return|return
name|error
argument_list|(
literal|"The branch '%s' is not an ancestor "
literal|"of your current HEAD.\n"
literal|"If you are sure you want to delete it,"
literal|" run:\n\t'git http-push -D %s %s'"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|pattern
argument_list|)
return|;
block|}
block|}
comment|/* Send delete request */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removing remote branch '%s'\n"
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|url
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
name|strlen
argument_list|(
name|remote_ref
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|url
argument_list|,
literal|"%s%s"
argument_list|,
name|remote
operator|->
name|url
argument_list|,
name|remote_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_active_slot
argument_list|()
expr_stmt|;
name|slot
operator|->
name|results
operator|=
operator|&
name|results
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_HTTPGET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_WRITEFUNCTION
argument_list|,
name|fwrite_null
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_URL
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|curl_easy_setopt
argument_list|(
name|slot
operator|->
name|curl
argument_list|,
name|CURLOPT_CUSTOMREQUEST
argument_list|,
name|DAV_DELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_active_slot
argument_list|(
name|slot
argument_list|)
condition|)
block|{
name|run_active_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|.
name|curl_result
operator|!=
name|CURLE_OK
condition|)
return|return
name|error
argument_list|(
literal|"DELETE request failed (%d/%ld)\n"
argument_list|,
name|results
operator|.
name|curl_result
argument_list|,
name|results
operator|.
name|http_code
argument_list|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Unable to start DELETE request"
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|transfer_request
modifier|*
name|request
decl_stmt|;
name|struct
name|transfer_request
modifier|*
name|next_request
decl_stmt|;
name|int
name|nr_refspec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|refspec
init|=
name|NULL
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|ref_lock
init|=
name|NULL
decl_stmt|;
name|struct
name|remote_lock
modifier|*
name|info_ref_lock
init|=
name|NULL
decl_stmt|;
name|struct
name|rev_info
name|revs
decl_stmt|;
name|int
name|delete_branch
init|=
literal|0
decl_stmt|;
name|int
name|force_delete
init|=
literal|0
decl_stmt|;
name|int
name|objects_to_send
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|new_refs
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|char
modifier|*
name|rewritten_url
init|=
name|NULL
decl_stmt|;
name|setup_git_directory
argument_list|()
expr_stmt|;
name|remote
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|remote
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|argv
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
operator|*
name|argv
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--all"
argument_list|)
condition|)
block|{
name|push_all
operator|=
name|MATCH_REFS_ALL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--force"
argument_list|)
condition|)
block|{
name|force_all
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--dry-run"
argument_list|)
condition|)
block|{
name|dry_run
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|push_verbosely
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-d"
argument_list|)
condition|)
block|{
name|delete_branch
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-D"
argument_list|)
condition|)
block|{
name|delete_branch
operator|=
literal|1
expr_stmt|;
name|force_delete
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|remote
operator|->
name|url
condition|)
block|{
name|char
modifier|*
name|path
init|=
name|strstr
argument_list|(
name|arg
argument_list|,
literal|"//"
argument_list|)
decl_stmt|;
name|remote
operator|->
name|url
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
name|path
operator|=
name|strchr
argument_list|(
name|path
operator|+
literal|2
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|remote
operator|->
name|path_len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|refspec
operator|=
name|argv
expr_stmt|;
name|nr_refspec
operator|=
name|argc
operator|-
name|i
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|USE_CURL_MULTI
name|die
argument_list|(
literal|"git-push is not available for http/https repository when not compiled with USE_CURL_MULTI"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|remote
operator|->
name|url
condition|)
name|usage
argument_list|(
name|http_push_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_branch
operator|&&
name|nr_refspec
operator|!=
literal|1
condition|)
name|die
argument_list|(
literal|"You must specify only one branch name when deleting a remote branch"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|remote_dir_exists
argument_list|,
operator|-
literal|1
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|http_init
argument_list|()
expr_stmt|;
name|no_pragma_header
operator|=
name|curl_slist_append
argument_list|(
name|no_pragma_header
argument_list|,
literal|"Pragma:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote
operator|->
name|url
operator|&&
name|remote
operator|->
name|url
index|[
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|rewritten_url
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|remote
operator|->
name|url
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rewritten_url
argument_list|,
name|remote
operator|->
name|url
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rewritten_url
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|remote
operator|->
name|url
operator|=
name|rewritten_url
expr_stmt|;
operator|++
name|remote
operator|->
name|path_len
expr_stmt|;
block|}
comment|/* Verify DAV compliance/lock support */
if|if
condition|(
operator|!
name|locking_available
argument_list|()
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Check whether the remote has server info files */
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|0
expr_stmt|;
name|remote
operator|->
name|has_info_refs
operator|=
name|remote_exists
argument_list|(
literal|"info/refs"
argument_list|)
expr_stmt|;
name|remote
operator|->
name|has_info_packs
operator|=
name|remote_exists
argument_list|(
literal|"objects/info/packs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote
operator|->
name|has_info_refs
condition|)
block|{
name|info_ref_lock
operator|=
name|lock_remote
argument_list|(
literal|"info/refs"
argument_list|,
name|LOCK_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ref_lock
condition|)
name|remote
operator|->
name|can_update_info_refs
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: cannot lock existing info/refs\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
if|if
condition|(
name|remote
operator|->
name|has_info_packs
condition|)
name|fetch_indices
argument_list|()
expr_stmt|;
comment|/* Get a list of all local and remote heads to validate refspecs */
name|get_local_heads
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fetching remote heads...\n"
argument_list|)
expr_stmt|;
name|get_dav_remote_heads
argument_list|()
expr_stmt|;
comment|/* Remove a remote branch if -d or -D was specified */
if|if
condition|(
name|delete_branch
condition|)
block|{
if|if
condition|(
name|delete_remote_branch
argument_list|(
name|refspec
index|[
literal|0
index|]
argument_list|,
name|force_delete
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to delete remote branch %s\n"
argument_list|,
name|refspec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* match them up */
if|if
condition|(
operator|!
name|remote_tail
condition|)
name|remote_tail
operator|=
operator|&
name|remote_refs
expr_stmt|;
if|if
condition|(
name|match_refs
argument_list|(
name|local_refs
argument_list|,
name|remote_refs
argument_list|,
operator|&
name|remote_tail
argument_list|,
name|nr_refspec
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|refspec
argument_list|,
name|push_all
argument_list|)
condition|)
block|{
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|remote_refs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No refs in common and none specified; doing nothing.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|new_refs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|char
name|old_hex
index|[
literal|60
index|]
decl_stmt|,
modifier|*
name|new_hex
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_argv
index|[
literal|4
index|]
decl_stmt|;
name|int
name|commit_argc
decl_stmt|;
name|char
modifier|*
name|new_sha1_hex
decl_stmt|,
modifier|*
name|old_sha1_hex
decl_stmt|;
if|if
condition|(
operator|!
name|ref
operator|->
name|peer_ref
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|push_verbosely
operator|||
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'%s': up-to-date\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|force_all
operator|&&
operator|!
name|is_zero_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
operator|&&
operator|!
name|ref
operator|->
name|force
condition|)
block|{
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
operator|||
operator|!
name|ref_newer
argument_list|(
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
comment|/* 				 * We do not have the remote ref, or 				 * we know that the remote ref is not 				 * an ancestor of what we are trying to 				 * push.  Either way this can be losing 				 * commits at the remote end and likely 				 * we were not up to date to begin with. 				 */
name|error
argument_list|(
literal|"remote '%s' is not an ancestor of\n"
literal|"local '%s'.\n"
literal|"Maybe you are not up-to-date and "
literal|"need to pull first?"
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
block|}
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_zero_sha1
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot happen anymore"
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|3
expr_stmt|;
continue|continue;
block|}
name|new_refs
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|old_hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|new_hex
operator|=
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"updating '%s'"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" using '%s'"
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  from %s\n  to   %s\n"
argument_list|,
name|old_hex
argument_list|,
name|new_hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
continue|continue;
comment|/* Lock remote branch ref */
name|ref_lock
operator|=
name|lock_remote
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|LOCK_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_lock
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to lock remote branch %s\n"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Set up revision info for this refspec */
name|commit_argc
operator|=
literal|3
expr_stmt|;
name|new_sha1_hex
operator|=
name|xstrdup
argument_list|(
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|old_sha1_hex
operator|=
name|NULL
expr_stmt|;
name|commit_argv
index|[
literal|1
index|]
operator|=
literal|"--objects"
expr_stmt|;
name|commit_argv
index|[
literal|2
index|]
operator|=
name|new_sha1_hex
expr_stmt|;
if|if
condition|(
operator|!
name|push_all
operator|&&
operator|!
name|is_zero_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
name|old_sha1_hex
operator|=
name|xmalloc
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|old_sha1_hex
argument_list|,
literal|"^%s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|commit_argv
index|[
literal|3
index|]
operator|=
name|old_sha1_hex
expr_stmt|;
name|commit_argc
operator|++
expr_stmt|;
block|}
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|setup_git_directory
argument_list|()
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
name|commit_argc
argument_list|,
name|commit_argv
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_sha1_hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_sha1_hex
condition|)
block|{
name|free
argument_list|(
name|old_sha1_hex
argument_list|)
expr_stmt|;
name|commit_argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Generate a list of objects that need to be pushed */
name|pushing
operator|=
literal|0
expr_stmt|;
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
name|mark_edges_uninteresting
argument_list|(
name|revs
operator|.
name|commits
argument_list|)
expr_stmt|;
name|objects_to_send
operator|=
name|get_delta
argument_list|(
operator|&
name|revs
argument_list|,
name|ref_lock
argument_list|)
expr_stmt|;
name|finish_all_active_slots
argument_list|()
expr_stmt|;
comment|/* Push missing objects to remote, this would be a 		   convenient time to pack them first if appropriate. */
name|pushing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|objects_to_send
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    sending %d objects\n"
argument_list|,
name|objects_to_send
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|fill_active_slots
argument_list|()
expr_stmt|;
name|add_fill_function
argument_list|(
name|NULL
argument_list|,
name|fill_active_slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|finish_all_active_slots
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURL_MULTI
name|fill_active_slots
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|request_queue_head
operator|&&
operator|!
name|aborted
condition|)
do|;
comment|/* Update the remote branch if all went well */
if|if
condition|(
name|aborted
operator|||
operator|!
name|update_remote
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|ref_lock
argument_list|)
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|unlock
label|:
if|if
condition|(
operator|!
name|rc
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    done\n"
argument_list|)
expr_stmt|;
name|unlock_remote
argument_list|(
name|ref_lock
argument_list|)
expr_stmt|;
name|check_locks
argument_list|()
expr_stmt|;
block|}
comment|/* Update remote server info if appropriate */
if|if
condition|(
name|remote
operator|->
name|has_info_refs
operator|&&
name|new_refs
condition|)
block|{
if|if
condition|(
name|info_ref_lock
operator|&&
name|remote
operator|->
name|can_update_info_refs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Updating remote server info\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
name|update_remote_info_refs
argument_list|(
name|info_ref_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to update server info\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|rewritten_url
condition|)
name|free
argument_list|(
name|rewritten_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_ref_lock
condition|)
name|unlock_remote
argument_list|(
name|info_ref_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|curl_slist_free_all
argument_list|(
name|no_pragma_header
argument_list|)
expr_stmt|;
name|http_cleanup
argument_list|()
expr_stmt|;
name|request
operator|=
name|request_queue_head
expr_stmt|;
while|while
condition|(
name|request
operator|!=
name|NULL
condition|)
block|{
name|next_request
operator|=
name|request
operator|->
name|next
expr_stmt|;
name|release_request
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|request
operator|=
name|next_request
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
end_unit
