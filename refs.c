begin_unit
begin_comment
comment|/*  * The backend-independent part of the reference module.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"lockfile.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"refs/refs-internal.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_comment
comment|/*  * How to handle various characters in refnames:  * 0: An acceptable character for refs  * 1: End-of-component  * 2: ., look for a preceding . to reject .. in refs  * 3: {, look for a preceding @ to reject @{ in refs  * 4: A bad character: ASCII control characters, and  *    ":", "?", "[", "\", "^", "~", SP, or TAB  * 5: *, reject unless REFNAME_REFSPEC_PATTERN is set  */
end_comment
begin_decl_stmt
DECL|variable|refname_disposition
specifier|static
name|unsigned
name|char
name|refname_disposition
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Try to read one refname component from the front of refname.  * Return the length of the component found, or -1 if the component is  * not legal.  It is legal if it is something reasonable to have under  * ".git/refs/"; We do not like it if:  *  * - any path component of it begins with ".", or  * - it has double dots "..", or  * - it has ASCII control characters, or  * - it has ":", "?", "[", "\", "^", "~", SP, or TAB anywhere, or  * - it has "*" anywhere unless REFNAME_REFSPEC_PATTERN is set, or  * - it ends with a "/", or  * - it ends with ".lock", or  * - it contains a "@{" portion  */
end_comment
begin_function
DECL|function|check_refname_component
specifier|static
name|int
name|check_refname_component
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|last
init|=
literal|'\0'
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|refname
init|;
condition|;
name|cp
operator|++
control|)
block|{
name|int
name|ch
init|=
operator|*
name|cp
operator|&
literal|255
decl_stmt|;
name|unsigned
name|char
name|disp
init|=
name|refname_disposition
index|[
name|ch
index|]
decl_stmt|;
switch|switch
condition|(
name|disp
condition|)
block|{
case|case
literal|1
case|:
goto|goto
name|out
goto|;
case|case
literal|2
case|:
if|if
condition|(
name|last
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Refname contains "..". */
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|last
operator|==
literal|'@'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Refname contains "@{". */
break|break;
case|case
literal|4
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|5
case|:
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|REFNAME_REFSPEC_PATTERN
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* refspec can't be a pattern */
comment|/* 			 * Unset the pattern flag so that we only accept 			 * a single asterisk for one side of refspec. 			 */
operator|*
name|flags
operator|&=
operator|~
name|REFNAME_REFSPEC_PATTERN
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|ch
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|cp
operator|==
name|refname
condition|)
return|return
literal|0
return|;
comment|/* Component has zero length. */
if|if
condition|(
name|refname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Component starts with '.'. */
if|if
condition|(
name|cp
operator|-
name|refname
operator|>=
name|LOCK_SUFFIX_LEN
operator|&&
operator|!
name|memcmp
argument_list|(
name|cp
operator|-
name|LOCK_SUFFIX_LEN
argument_list|,
name|LOCK_SUFFIX
argument_list|,
name|LOCK_SUFFIX_LEN
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Refname ends with ".lock". */
return|return
name|cp
operator|-
name|refname
return|;
block|}
end_function
begin_function
DECL|function|check_refname_format
name|int
name|check_refname_format
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|component_len
decl_stmt|,
name|component_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|refname
argument_list|,
literal|"@"
argument_list|)
condition|)
comment|/* Refname is a single character '@'. */
return|return
operator|-
literal|1
return|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* We are at the start of a path component. */
name|component_len
operator|=
name|check_refname_component
argument_list|(
name|refname
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|component_len
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|component_count
operator|++
expr_stmt|;
if|if
condition|(
name|refname
index|[
name|component_len
index|]
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Skip to next component. */
name|refname
operator|+=
name|component_len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|refname
index|[
name|component_len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Refname ends with '.'. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REFNAME_ALLOW_ONELEVEL
operator|)
operator|&&
name|component_count
operator|<
literal|2
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Refname has only one component. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|refname_is_safe
name|int
name|refname_is_safe
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
if|if
condition|(
name|starts_with
argument_list|(
name|refname
argument_list|,
literal|"refs/"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|result
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|refname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Does the refname try to escape refs/? 		 * For example: refs/foo/../bar is safe but refs/foo/../../bar 		 * is not. 		 */
name|result
operator|=
operator|!
name|normalize_path_copy
argument_list|(
name|buf
argument_list|,
name|refname
operator|+
name|strlen
argument_list|(
literal|"refs/"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
while|while
condition|(
operator|*
name|refname
condition|)
block|{
if|if
condition|(
operator|!
name|isupper
argument_list|(
operator|*
name|refname
argument_list|)
operator|&&
operator|*
name|refname
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
name|refname
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|resolve_refdup
name|char
modifier|*
name|resolve_refdup
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|int
name|resolve_flags
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
return|return
name|xstrdup_or_null
argument_list|(
name|resolve_ref_unsafe
argument_list|(
name|refname
argument_list|,
name|resolve_flags
argument_list|,
name|sha1
argument_list|,
name|flags
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* The argument to filter_refs */
end_comment
begin_struct
DECL|struct|ref_filter
struct|struct
name|ref_filter
block|{
DECL|member|pattern
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
DECL|member|fn
name|each_ref_fn
modifier|*
name|fn
decl_stmt|;
DECL|member|cb_data
name|void
modifier|*
name|cb_data
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|read_ref_full
name|int
name|read_ref_full
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|int
name|resolve_flags
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
if|if
condition|(
name|resolve_ref_unsafe
argument_list|(
name|refname
argument_list|,
name|resolve_flags
argument_list|,
name|sha1
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|read_ref
name|int
name|read_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|read_ref_full
argument_list|(
name|refname
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ref_exists
name|int
name|ref_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
return|return
operator|!
operator|!
name|resolve_ref_unsafe
argument_list|(
name|refname
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|filter_refs
specifier|static
name|int
name|filter_refs
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|struct
name|object_id
modifier|*
name|oid
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ref_filter
modifier|*
name|filter
init|=
operator|(
expr|struct
name|ref_filter
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|wildmatch
argument_list|(
name|filter
operator|->
name|pattern
argument_list|,
name|refname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|filter
operator|->
name|fn
argument_list|(
name|refname
argument_list|,
name|oid
argument_list|,
name|flags
argument_list|,
name|filter
operator|->
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|peel_object
name|enum
name|peel_status
name|peel_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|lookup_unknown_object
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_NONE
condition|)
block|{
name|int
name|type
init|=
name|sha1_object_info
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
operator|||
operator|!
name|object_as_type
argument_list|(
name|o
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|PEEL_INVALID
return|;
block|}
if|if
condition|(
name|o
operator|->
name|type
operator|!=
name|OBJ_TAG
condition|)
return|return
name|PEEL_NON_TAG
return|;
name|o
operator|=
name|deref_tag_noverify
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|PEEL_INVALID
return|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|o
operator|->
name|oid
operator|.
name|hash
argument_list|)
expr_stmt|;
return|return
name|PEEL_PEELED
return|;
block|}
end_function
begin_struct
DECL|struct|warn_if_dangling_data
struct|struct
name|warn_if_dangling_data
block|{
DECL|member|fp
name|FILE
modifier|*
name|fp
decl_stmt|;
DECL|member|refname
specifier|const
name|char
modifier|*
name|refname
decl_stmt|;
DECL|member|refnames
specifier|const
name|struct
name|string_list
modifier|*
name|refnames
decl_stmt|;
DECL|member|msg_fmt
specifier|const
name|char
modifier|*
name|msg_fmt
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|warn_if_dangling_symref
specifier|static
name|int
name|warn_if_dangling_symref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|struct
name|object_id
modifier|*
name|oid
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|warn_if_dangling_data
modifier|*
name|d
init|=
name|cb_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|resolves_to
decl_stmt|;
name|struct
name|object_id
name|junk
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REF_ISSYMREF
operator|)
condition|)
return|return
literal|0
return|;
name|resolves_to
operator|=
name|resolve_ref_unsafe
argument_list|(
name|refname
argument_list|,
literal|0
argument_list|,
name|junk
operator|.
name|hash
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resolves_to
operator|||
operator|(
name|d
operator|->
name|refname
condition|?
name|strcmp
argument_list|(
name|resolves_to
argument_list|,
name|d
operator|->
name|refname
argument_list|)
else|:
operator|!
name|string_list_has_string
argument_list|(
name|d
operator|->
name|refnames
argument_list|,
name|resolves_to
argument_list|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|fprintf
argument_list|(
name|d
operator|->
name|fp
argument_list|,
name|d
operator|->
name|msg_fmt
argument_list|,
name|refname
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|d
operator|->
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|warn_dangling_symref
name|void
name|warn_dangling_symref
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|struct
name|warn_if_dangling_data
name|data
decl_stmt|;
name|data
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|data
operator|.
name|refname
operator|=
name|refname
expr_stmt|;
name|data
operator|.
name|refnames
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|msg_fmt
operator|=
name|msg_fmt
expr_stmt|;
name|for_each_rawref
argument_list|(
name|warn_if_dangling_symref
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|warn_dangling_symrefs
name|void
name|warn_dangling_symrefs
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_fmt
parameter_list|,
specifier|const
name|struct
name|string_list
modifier|*
name|refnames
parameter_list|)
block|{
name|struct
name|warn_if_dangling_data
name|data
decl_stmt|;
name|data
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|data
operator|.
name|refname
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|refnames
operator|=
name|refnames
expr_stmt|;
name|data
operator|.
name|msg_fmt
operator|=
name|msg_fmt
expr_stmt|;
name|for_each_rawref
argument_list|(
name|warn_if_dangling_symref
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|for_each_tag_ref
name|int
name|for_each_tag_ref
parameter_list|(
name|each_ref_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
return|return
name|for_each_ref_in
argument_list|(
literal|"refs/tags/"
argument_list|,
name|fn
argument_list|,
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|for_each_tag_ref_submodule
name|int
name|for_each_tag_ref_submodule
parameter_list|(
specifier|const
name|char
modifier|*
name|submodule
parameter_list|,
name|each_ref_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
return|return
name|for_each_ref_in_submodule
argument_list|(
name|submodule
argument_list|,
literal|"refs/tags/"
argument_list|,
name|fn
argument_list|,
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|for_each_branch_ref
name|int
name|for_each_branch_ref
parameter_list|(
name|each_ref_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
return|return
name|for_each_ref_in
argument_list|(
literal|"refs/heads/"
argument_list|,
name|fn
argument_list|,
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|for_each_branch_ref_submodule
name|int
name|for_each_branch_ref_submodule
parameter_list|(
specifier|const
name|char
modifier|*
name|submodule
parameter_list|,
name|each_ref_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
return|return
name|for_each_ref_in_submodule
argument_list|(
name|submodule
argument_list|,
literal|"refs/heads/"
argument_list|,
name|fn
argument_list|,
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|for_each_remote_ref
name|int
name|for_each_remote_ref
parameter_list|(
name|each_ref_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
return|return
name|for_each_ref_in
argument_list|(
literal|"refs/remotes/"
argument_list|,
name|fn
argument_list|,
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|for_each_remote_ref_submodule
name|int
name|for_each_remote_ref_submodule
parameter_list|(
specifier|const
name|char
modifier|*
name|submodule
parameter_list|,
name|each_ref_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
return|return
name|for_each_ref_in_submodule
argument_list|(
name|submodule
argument_list|,
literal|"refs/remotes/"
argument_list|,
name|fn
argument_list|,
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|head_ref_namespaced
name|int
name|head_ref_namespaced
parameter_list|(
name|each_ref_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|object_id
name|oid
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%sHEAD"
argument_list|,
name|get_git_namespace
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read_ref_full
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|oid
operator|.
name|hash
argument_list|,
operator|&
name|flag
argument_list|)
condition|)
name|ret
operator|=
name|fn
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
operator|&
name|oid
argument_list|,
name|flag
argument_list|,
name|cb_data
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|for_each_glob_ref_in
name|int
name|for_each_glob_ref_in
parameter_list|(
name|each_ref_fn
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|strbuf
name|real_pattern
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|ref_filter
name|filter
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|prefix
operator|&&
operator|!
name|starts_with
argument_list|(
name|pattern
argument_list|,
literal|"refs/"
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|real_pattern
argument_list|,
literal|"refs/"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|real_pattern
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|real_pattern
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_glob_specials
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
comment|/* Append implied '/' '*' if not present. */
name|strbuf_complete
argument_list|(
operator|&
name|real_pattern
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* No need to check for '*', there is none. */
name|strbuf_addch
argument_list|(
operator|&
name|real_pattern
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
block|}
name|filter
operator|.
name|pattern
operator|=
name|real_pattern
operator|.
name|buf
expr_stmt|;
name|filter
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|filter
operator|.
name|cb_data
operator|=
name|cb_data
expr_stmt|;
name|ret
operator|=
name|for_each_ref
argument_list|(
name|filter_refs
argument_list|,
operator|&
name|filter
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|real_pattern
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|for_each_glob_ref
name|int
name|for_each_glob_ref
parameter_list|(
name|each_ref_fn
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
return|return
name|for_each_glob_ref_in
argument_list|(
name|fn
argument_list|,
name|pattern
argument_list|,
name|NULL
argument_list|,
name|cb_data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|prettify_refname
specifier|const
name|char
modifier|*
name|prettify_refname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|name
operator|+
operator|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|?
literal|11
else|:
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|?
literal|10
else|:
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"refs/remotes/"
argument_list|)
condition|?
literal|13
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ref_rev_parse_rules
specifier|static
specifier|const
name|char
modifier|*
name|ref_rev_parse_rules
index|[]
init|=
block|{
literal|"%.*s"
block|,
literal|"refs/%.*s"
block|,
literal|"refs/tags/%.*s"
block|,
literal|"refs/heads/%.*s"
block|,
literal|"refs/remotes/%.*s"
block|,
literal|"refs/remotes/%.*s/HEAD"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|refname_match
name|int
name|refname_match
parameter_list|(
specifier|const
name|char
modifier|*
name|abbrev_name
parameter_list|,
specifier|const
name|char
modifier|*
name|full_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|const
name|int
name|abbrev_name_len
init|=
name|strlen
argument_list|(
name|abbrev_name
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ref_rev_parse_rules
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|full_name
argument_list|,
name|mkpath
argument_list|(
operator|*
name|p
argument_list|,
name|abbrev_name_len
argument_list|,
name|abbrev_name
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * *string and *len will only be substituted, and *string returned (for  * later free()ing) if the string passed in is a magic short-hand form  * to name a branch.  */
end_comment
begin_function
DECL|function|substitute_branch_name
specifier|static
name|char
modifier|*
name|substitute_branch_name
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
init|=
name|interpret_branch_name
argument_list|(
operator|*
name|string
argument_list|,
operator|*
name|len
argument_list|,
operator|&
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|*
name|len
condition|)
block|{
name|size_t
name|size
decl_stmt|;
operator|*
name|string
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
operator|*
name|string
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|dwim_ref
name|int
name|dwim_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
modifier|*
name|ref
parameter_list|)
block|{
name|char
modifier|*
name|last_branch
init|=
name|substitute_branch_name
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|refs_found
init|=
literal|0
decl_stmt|;
operator|*
name|ref
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ref_rev_parse_rules
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|char
name|fullref
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1_from_ref
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|this_result
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|this_result
operator|=
name|refs_found
condition|?
name|sha1_from_ref
else|:
name|sha1
expr_stmt|;
name|mksnpath
argument_list|(
name|fullref
argument_list|,
sizeof|sizeof
argument_list|(
name|fullref
argument_list|)
argument_list|,
operator|*
name|p
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|r
operator|=
name|resolve_ref_unsafe
argument_list|(
name|fullref
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|this_result
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
operator|!
name|refs_found
operator|++
condition|)
operator|*
name|ref
operator|=
name|xstrdup
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|warn_ambiguous_refs
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
name|strcmp
argument_list|(
name|fullref
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring dangling symref %s."
argument_list|,
name|fullref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flag
operator|&
name|REF_ISBROKEN
operator|)
operator|&&
name|strchr
argument_list|(
name|fullref
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring broken ref %s."
argument_list|,
name|fullref
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|last_branch
argument_list|)
expr_stmt|;
return|return
name|refs_found
return|;
block|}
end_function
begin_function
DECL|function|dwim_log
name|int
name|dwim_log
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
modifier|*
name|log
parameter_list|)
block|{
name|char
modifier|*
name|last_branch
init|=
name|substitute_branch_name
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|logs_found
init|=
literal|0
decl_stmt|;
operator|*
name|log
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ref_rev_parse_rules
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|unsigned
name|char
name|hash
index|[
literal|20
index|]
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ref
decl_stmt|,
modifier|*
name|it
decl_stmt|;
name|mksnpath
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
operator|*
name|p
argument_list|,
name|len
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|ref
operator|=
name|resolve_ref_unsafe
argument_list|(
name|path
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|hash
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
continue|continue;
if|if
condition|(
name|reflog_exists
argument_list|(
name|path
argument_list|)
condition|)
name|it
operator|=
name|path
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ref
argument_list|,
name|path
argument_list|)
operator|&&
name|reflog_exists
argument_list|(
name|ref
argument_list|)
condition|)
name|it
operator|=
name|ref
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
name|logs_found
operator|++
condition|)
block|{
operator|*
name|log
operator|=
name|xstrdup
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|warn_ambiguous_refs
condition|)
break|break;
block|}
name|free
argument_list|(
name|last_branch
argument_list|)
expr_stmt|;
return|return
name|logs_found
return|;
block|}
end_function
begin_function
DECL|function|is_per_worktree_ref
specifier|static
name|int
name|is_per_worktree_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
return|return
operator|!
name|strcmp
argument_list|(
name|refname
argument_list|,
literal|"HEAD"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|refname
argument_list|,
literal|"refs/bisect/"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|is_pseudoref_syntax
specifier|static
name|int
name|is_pseudoref_syntax
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|refname
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isupper
argument_list|(
operator|*
name|c
argument_list|)
operator|&&
operator|*
name|c
operator|!=
literal|'-'
operator|&&
operator|*
name|c
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|ref_type
name|enum
name|ref_type
name|ref_type
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
if|if
condition|(
name|is_per_worktree_ref
argument_list|(
name|refname
argument_list|)
condition|)
return|return
name|REF_TYPE_PER_WORKTREE
return|;
if|if
condition|(
name|is_pseudoref_syntax
argument_list|(
name|refname
argument_list|)
condition|)
return|return
name|REF_TYPE_PSEUDOREF
return|;
return|return
name|REF_TYPE_NORMAL
return|;
block|}
end_function
begin_function
DECL|function|write_pseudoref
specifier|static
name|int
name|write_pseudoref
parameter_list|(
specifier|const
name|char
modifier|*
name|pseudoref
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|static
name|struct
name|lock_file
name|lock
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
literal|"%s"
argument_list|,
name|pseudoref
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|lock
argument_list|,
name|filename
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|strbuf_addf
argument_list|(
name|err
argument_list|,
literal|"Could not open '%s' for writing: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|old_sha1
condition|)
block|{
name|unsigned
name|char
name|actual_old_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|read_ref
argument_list|(
name|pseudoref
argument_list|,
name|actual_old_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not read ref '%s'"
argument_list|,
name|pseudoref
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|actual_old_sha1
argument_list|,
name|old_sha1
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
name|err
argument_list|,
literal|"Unexpected sha1 when writing %s"
argument_list|,
name|pseudoref
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
operator|!=
name|buf
operator|.
name|len
condition|)
block|{
name|strbuf_addf
argument_list|(
name|err
argument_list|,
literal|"Could not write to '%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|commit_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|delete_pseudoref
specifier|static
name|int
name|delete_pseudoref
parameter_list|(
specifier|const
name|char
modifier|*
name|pseudoref
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|)
block|{
specifier|static
name|struct
name|lock_file
name|lock
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
literal|"%s"
argument_list|,
name|pseudoref
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_sha1
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|old_sha1
argument_list|)
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|unsigned
name|char
name|actual_old_sha1
index|[
literal|20
index|]
decl_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|lock
argument_list|,
name|filename
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_ref
argument_list|(
name|pseudoref
argument_list|,
name|actual_old_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not read ref '%s'"
argument_list|,
name|pseudoref
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|actual_old_sha1
argument_list|,
name|old_sha1
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Unexpected sha1 when deleting %s"
argument_list|,
name|pseudoref
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|delete_ref
name|int
name|delete_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ref_transaction
modifier|*
name|transaction
decl_stmt|;
name|struct
name|strbuf
name|err
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|ref_type
argument_list|(
name|refname
argument_list|)
operator|==
name|REF_TYPE_PSEUDOREF
condition|)
return|return
name|delete_pseudoref
argument_list|(
name|refname
argument_list|,
name|old_sha1
argument_list|)
return|;
name|transaction
operator|=
name|ref_transaction_begin
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transaction
operator|||
name|ref_transaction_delete
argument_list|(
name|transaction
argument_list|,
name|refname
argument_list|,
name|old_sha1
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
operator|||
name|ref_transaction_commit
argument_list|(
name|transaction
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
name|err
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ref_transaction_free
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ref_transaction_free
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|copy_reflog_msg
name|int
name|copy_reflog_msg
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|wasspace
init|=
literal|1
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\t'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|msg
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|wasspace
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
name|wasspace
operator|=
name|isspace
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasspace
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
while|while
condition|(
name|buf
operator|<
name|cp
operator|&&
name|isspace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cp
operator|--
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
return|return
name|cp
operator|-
name|buf
return|;
block|}
end_function
begin_function
DECL|function|should_autocreate_reflog
name|int
name|should_autocreate_reflog
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|log_all_ref_updates
condition|)
return|return
literal|0
return|;
return|return
name|starts_with
argument_list|(
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|refname
argument_list|,
literal|"refs/remotes/"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|refname
argument_list|,
literal|"refs/notes/"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|refname
argument_list|,
literal|"HEAD"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|is_branch
name|int
name|is_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
return|return
operator|!
name|strcmp
argument_list|(
name|refname
argument_list|,
literal|"HEAD"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|)
return|;
block|}
end_function
begin_struct
DECL|struct|read_ref_at_cb
struct|struct
name|read_ref_at_cb
block|{
DECL|member|refname
specifier|const
name|char
modifier|*
name|refname
decl_stmt|;
DECL|member|at_time
name|unsigned
name|long
name|at_time
decl_stmt|;
DECL|member|cnt
name|int
name|cnt
decl_stmt|;
DECL|member|reccnt
name|int
name|reccnt
decl_stmt|;
DECL|member|sha1
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
DECL|member|found_it
name|int
name|found_it
decl_stmt|;
DECL|member|osha1
name|unsigned
name|char
name|osha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|nsha1
name|unsigned
name|char
name|nsha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|tz
name|int
name|tz
decl_stmt|;
DECL|member|date
name|unsigned
name|long
name|date
decl_stmt|;
DECL|member|msg
name|char
modifier|*
modifier|*
name|msg
decl_stmt|;
DECL|member|cutoff_time
name|unsigned
name|long
modifier|*
name|cutoff_time
decl_stmt|;
DECL|member|cutoff_tz
name|int
modifier|*
name|cutoff_tz
decl_stmt|;
DECL|member|cutoff_cnt
name|int
modifier|*
name|cutoff_cnt
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|read_ref_at_ent
specifier|static
name|int
name|read_ref_at_ent
parameter_list|(
name|unsigned
name|char
modifier|*
name|osha1
parameter_list|,
name|unsigned
name|char
modifier|*
name|nsha1
parameter_list|,
specifier|const
name|char
modifier|*
name|email
parameter_list|,
name|unsigned
name|long
name|timestamp
parameter_list|,
name|int
name|tz
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|read_ref_at_cb
modifier|*
name|cb
init|=
name|cb_data
decl_stmt|;
name|cb
operator|->
name|reccnt
operator|++
expr_stmt|;
name|cb
operator|->
name|tz
operator|=
name|tz
expr_stmt|;
name|cb
operator|->
name|date
operator|=
name|timestamp
expr_stmt|;
if|if
condition|(
name|timestamp
operator|<=
name|cb
operator|->
name|at_time
operator|||
name|cb
operator|->
name|cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|msg
condition|)
operator|*
name|cb
operator|->
name|msg
operator|=
name|xstrdup
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cutoff_time
condition|)
operator|*
name|cb
operator|->
name|cutoff_time
operator|=
name|timestamp
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cutoff_tz
condition|)
operator|*
name|cb
operator|->
name|cutoff_tz
operator|=
name|tz
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cutoff_cnt
condition|)
operator|*
name|cb
operator|->
name|cutoff_cnt
operator|=
name|cb
operator|->
name|reccnt
operator|-
literal|1
expr_stmt|;
comment|/* 		 * we have not yet updated cb->[n|o]sha1 so they still 		 * hold the values for the previous record. 		 */
if|if
condition|(
operator|!
name|is_null_sha1
argument_list|(
name|cb
operator|->
name|osha1
argument_list|)
condition|)
block|{
name|hashcpy
argument_list|(
name|cb
operator|->
name|sha1
argument_list|,
name|nsha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|cb
operator|->
name|osha1
argument_list|,
name|nsha1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Log for ref %s has gap after %s."
argument_list|,
name|cb
operator|->
name|refname
argument_list|,
name|show_date
argument_list|(
name|cb
operator|->
name|date
argument_list|,
name|cb
operator|->
name|tz
argument_list|,
name|DATE_MODE
argument_list|(
name|RFC2822
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|date
operator|==
name|cb
operator|->
name|at_time
condition|)
name|hashcpy
argument_list|(
name|cb
operator|->
name|sha1
argument_list|,
name|nsha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hashcmp
argument_list|(
name|nsha1
argument_list|,
name|cb
operator|->
name|sha1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Log for ref %s unexpectedly ended on %s."
argument_list|,
name|cb
operator|->
name|refname
argument_list|,
name|show_date
argument_list|(
name|cb
operator|->
name|date
argument_list|,
name|cb
operator|->
name|tz
argument_list|,
name|DATE_MODE
argument_list|(
name|RFC2822
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|cb
operator|->
name|osha1
argument_list|,
name|osha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|cb
operator|->
name|nsha1
argument_list|,
name|nsha1
argument_list|)
expr_stmt|;
name|cb
operator|->
name|found_it
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
name|hashcpy
argument_list|(
name|cb
operator|->
name|osha1
argument_list|,
name|osha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|cb
operator|->
name|nsha1
argument_list|,
name|nsha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cnt
operator|>
literal|0
condition|)
name|cb
operator|->
name|cnt
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_ref_at_ent_oldest
specifier|static
name|int
name|read_ref_at_ent_oldest
parameter_list|(
name|unsigned
name|char
modifier|*
name|osha1
parameter_list|,
name|unsigned
name|char
modifier|*
name|nsha1
parameter_list|,
specifier|const
name|char
modifier|*
name|email
parameter_list|,
name|unsigned
name|long
name|timestamp
parameter_list|,
name|int
name|tz
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|read_ref_at_cb
modifier|*
name|cb
init|=
name|cb_data
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|msg
condition|)
operator|*
name|cb
operator|->
name|msg
operator|=
name|xstrdup
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cutoff_time
condition|)
operator|*
name|cb
operator|->
name|cutoff_time
operator|=
name|timestamp
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cutoff_tz
condition|)
operator|*
name|cb
operator|->
name|cutoff_tz
operator|=
name|tz
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|cutoff_cnt
condition|)
operator|*
name|cb
operator|->
name|cutoff_cnt
operator|=
name|cb
operator|->
name|reccnt
expr_stmt|;
name|hashcpy
argument_list|(
name|cb
operator|->
name|sha1
argument_list|,
name|osha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|cb
operator|->
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|cb
operator|->
name|sha1
argument_list|,
name|nsha1
argument_list|)
expr_stmt|;
comment|/* We just want the first entry */
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|read_ref_at
name|int
name|read_ref_at
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|long
name|at_time
parameter_list|,
name|int
name|cnt
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
modifier|*
name|msg
parameter_list|,
name|unsigned
name|long
modifier|*
name|cutoff_time
parameter_list|,
name|int
modifier|*
name|cutoff_tz
parameter_list|,
name|int
modifier|*
name|cutoff_cnt
parameter_list|)
block|{
name|struct
name|read_ref_at_cb
name|cb
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|.
name|refname
operator|=
name|refname
expr_stmt|;
name|cb
operator|.
name|at_time
operator|=
name|at_time
expr_stmt|;
name|cb
operator|.
name|cnt
operator|=
name|cnt
expr_stmt|;
name|cb
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
name|cb
operator|.
name|cutoff_time
operator|=
name|cutoff_time
expr_stmt|;
name|cb
operator|.
name|cutoff_tz
operator|=
name|cutoff_tz
expr_stmt|;
name|cb
operator|.
name|cutoff_cnt
operator|=
name|cutoff_cnt
expr_stmt|;
name|cb
operator|.
name|sha1
operator|=
name|sha1
expr_stmt|;
name|for_each_reflog_ent_reverse
argument_list|(
name|refname
argument_list|,
name|read_ref_at_ent
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|reccnt
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|GET_SHA1_QUIETLY
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Log for %s is empty."
argument_list|,
name|refname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|found_it
condition|)
return|return
literal|0
return|;
name|for_each_reflog_ent
argument_list|(
name|refname
argument_list|,
name|read_ref_at_ent_oldest
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|ref_transaction_begin
name|struct
name|ref_transaction
modifier|*
name|ref_transaction_begin
parameter_list|(
name|struct
name|strbuf
modifier|*
name|err
parameter_list|)
block|{
name|assert
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref_transaction
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ref_transaction_free
name|void
name|ref_transaction_free
parameter_list|(
name|struct
name|ref_transaction
modifier|*
name|transaction
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|transaction
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|transaction
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|transaction
operator|->
name|updates
index|[
name|i
index|]
operator|->
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|transaction
operator|->
name|updates
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|transaction
operator|->
name|updates
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_update
specifier|static
name|struct
name|ref_update
modifier|*
name|add_update
parameter_list|(
name|struct
name|ref_transaction
modifier|*
name|transaction
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|struct
name|ref_update
modifier|*
name|update
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|update
argument_list|)
operator|+
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|update
operator|->
name|refname
argument_list|,
name|refname
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* includes NUL */
name|ALLOC_GROW
argument_list|(
name|transaction
operator|->
name|updates
argument_list|,
name|transaction
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|transaction
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|transaction
operator|->
name|updates
index|[
name|transaction
operator|->
name|nr
operator|++
index|]
operator|=
name|update
expr_stmt|;
return|return
name|update
return|;
block|}
end_function
begin_function
DECL|function|ref_transaction_update
name|int
name|ref_transaction_update
parameter_list|(
name|struct
name|ref_transaction
modifier|*
name|transaction
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|new_sha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|ref_update
modifier|*
name|update
decl_stmt|;
name|assert
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|state
operator|!=
name|REF_TRANSACTION_OPEN
condition|)
name|die
argument_list|(
literal|"BUG: update called for transaction that is not open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sha1
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|new_sha1
argument_list|)
operator|&&
name|check_refname_format
argument_list|(
name|refname
argument_list|,
name|REFNAME_ALLOW_ONELEVEL
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
name|err
argument_list|,
literal|"refusing to update ref with bad name %s"
argument_list|,
name|refname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|update
operator|=
name|add_update
argument_list|(
name|transaction
argument_list|,
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sha1
condition|)
block|{
name|hashcpy
argument_list|(
name|update
operator|->
name|new_sha1
argument_list|,
name|new_sha1
argument_list|)
expr_stmt|;
name|flags
operator||=
name|REF_HAVE_NEW
expr_stmt|;
block|}
if|if
condition|(
name|old_sha1
condition|)
block|{
name|hashcpy
argument_list|(
name|update
operator|->
name|old_sha1
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
name|flags
operator||=
name|REF_HAVE_OLD
expr_stmt|;
block|}
name|update
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|update
operator|->
name|msg
operator|=
name|xstrdup
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ref_transaction_create
name|int
name|ref_transaction_create
parameter_list|(
name|struct
name|ref_transaction
modifier|*
name|transaction
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|new_sha1
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|new_sha1
operator|||
name|is_null_sha1
argument_list|(
name|new_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: create called without valid new_sha1"
argument_list|)
expr_stmt|;
return|return
name|ref_transaction_update
argument_list|(
name|transaction
argument_list|,
name|refname
argument_list|,
name|new_sha1
argument_list|,
name|null_sha1
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ref_transaction_delete
name|int
name|ref_transaction_delete
parameter_list|(
name|struct
name|ref_transaction
modifier|*
name|transaction
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
name|old_sha1
operator|&&
name|is_null_sha1
argument_list|(
name|old_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: delete called with old_sha1 set to zeros"
argument_list|)
expr_stmt|;
return|return
name|ref_transaction_update
argument_list|(
name|transaction
argument_list|,
name|refname
argument_list|,
name|null_sha1
argument_list|,
name|old_sha1
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ref_transaction_verify
name|int
name|ref_transaction_verify
parameter_list|(
name|struct
name|ref_transaction
modifier|*
name|transaction
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|old_sha1
condition|)
name|die
argument_list|(
literal|"BUG: verify called with old_sha1 set to NULL"
argument_list|)
expr_stmt|;
return|return
name|ref_transaction_update
argument_list|(
name|transaction
argument_list|,
name|refname
argument_list|,
name|NULL
argument_list|,
name|old_sha1
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|update_ref
name|int
name|update_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|new_sha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|enum
name|action_on_err
name|onerr
parameter_list|)
block|{
name|struct
name|ref_transaction
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|struct
name|strbuf
name|err
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ref_type
argument_list|(
name|refname
argument_list|)
operator|==
name|REF_TYPE_PSEUDOREF
condition|)
block|{
name|ret
operator|=
name|write_pseudoref
argument_list|(
name|refname
argument_list|,
name|new_sha1
argument_list|,
name|old_sha1
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|ref_transaction_begin
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|ref_transaction_update
argument_list|(
name|t
argument_list|,
name|refname
argument_list|,
name|new_sha1
argument_list|,
name|old_sha1
argument_list|,
name|flags
argument_list|,
name|msg
argument_list|,
operator|&
name|err
argument_list|)
operator|||
name|ref_transaction_commit
argument_list|(
name|t
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|ref_transaction_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"update_ref failed for ref '%s': %s"
decl_stmt|;
switch|switch
condition|(
name|onerr
condition|)
block|{
case|case
name|UPDATE_REFS_MSG_ON_ERR
case|:
name|error
argument_list|(
name|str
argument_list|,
name|refname
argument_list|,
name|err
operator|.
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPDATE_REFS_DIE_ON_ERR
case|:
name|die
argument_list|(
name|str
argument_list|,
name|refname
argument_list|,
name|err
operator|.
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPDATE_REFS_QUIET_ON_ERR
case|:
break|break;
block|}
name|strbuf_release
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|ref_transaction_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|shorten_unambiguous_ref
name|char
modifier|*
name|shorten_unambiguous_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|scanf_fmts
decl_stmt|;
specifier|static
name|int
name|nr_rules
decl_stmt|;
name|char
modifier|*
name|short_name
decl_stmt|;
if|if
condition|(
operator|!
name|nr_rules
condition|)
block|{
comment|/* 		 * Pre-generate scanf formats from ref_rev_parse_rules[]. 		 * Generate a format suitable for scanf from a 		 * ref_rev_parse_rules rule by interpolating "%s" at the 		 * location of the "%.*s". 		 */
name|size_t
name|total_len
init|=
literal|0
decl_stmt|;
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
comment|/* the rule list is NULL terminated, count them first */
for|for
control|(
name|nr_rules
operator|=
literal|0
init|;
name|ref_rev_parse_rules
index|[
name|nr_rules
index|]
condition|;
name|nr_rules
operator|++
control|)
comment|/* -2 for strlen("%.*s") - strlen("%s"); +1 for NUL */
name|total_len
operator|+=
name|strlen
argument_list|(
name|ref_rev_parse_rules
index|[
name|nr_rules
index|]
argument_list|)
operator|-
literal|2
operator|+
literal|1
expr_stmt|;
name|scanf_fmts
operator|=
name|xmalloc
argument_list|(
name|nr_rules
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|total_len
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_rules
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|offset
operator|<
name|total_len
argument_list|)
expr_stmt|;
name|scanf_fmts
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|scanf_fmts
index|[
name|nr_rules
index|]
operator|+
name|offset
expr_stmt|;
name|offset
operator|+=
name|snprintf
argument_list|(
name|scanf_fmts
index|[
name|i
index|]
argument_list|,
name|total_len
operator|-
name|offset
argument_list|,
name|ref_rev_parse_rules
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|,
literal|"%s"
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* bail out if there are no rules */
if|if
condition|(
operator|!
name|nr_rules
condition|)
return|return
name|xstrdup
argument_list|(
name|refname
argument_list|)
return|;
comment|/* buffer for scanf result, at most refname must fit */
name|short_name
operator|=
name|xstrdup
argument_list|(
name|refname
argument_list|)
expr_stmt|;
comment|/* skip first rule, it will always match */
for|for
control|(
name|i
operator|=
name|nr_rules
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|rules_to_fail
init|=
name|i
decl_stmt|;
name|int
name|short_name_len
decl_stmt|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|refname
argument_list|,
name|scanf_fmts
index|[
name|i
index|]
argument_list|,
name|short_name
argument_list|)
condition|)
continue|continue;
name|short_name_len
operator|=
name|strlen
argument_list|(
name|short_name
argument_list|)
expr_stmt|;
comment|/* 		 * in strict mode, all (except the matched one) rules 		 * must fail to resolve to a valid non-ambiguous ref 		 */
if|if
condition|(
name|strict
condition|)
name|rules_to_fail
operator|=
name|nr_rules
expr_stmt|;
comment|/* 		 * check if the short name resolves to a valid ref, 		 * but use only rules prior to the matched one 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rules_to_fail
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|rule
init|=
name|ref_rev_parse_rules
index|[
name|j
index|]
decl_stmt|;
name|char
name|refname
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* skip matched rule */
if|if
condition|(
name|i
operator|==
name|j
condition|)
continue|continue;
comment|/* 			 * the short name is ambiguous, if it resolves 			 * (with this previous rule) to a valid ref 			 * read_ref() returns 0 on success 			 */
name|mksnpath
argument_list|(
name|refname
argument_list|,
sizeof|sizeof
argument_list|(
name|refname
argument_list|)
argument_list|,
name|rule
argument_list|,
name|short_name_len
argument_list|,
name|short_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_exists
argument_list|(
name|refname
argument_list|)
condition|)
break|break;
block|}
comment|/* 		 * short name is non-ambiguous if all previous rules 		 * haven't resolved to a valid ref 		 */
if|if
condition|(
name|j
operator|==
name|rules_to_fail
condition|)
return|return
name|short_name
return|;
block|}
name|free
argument_list|(
name|short_name
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|refname
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|hide_refs
specifier|static
name|struct
name|string_list
modifier|*
name|hide_refs
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parse_hide_refs_config
name|int
name|parse_hide_refs_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"transfer.hiderefs"
argument_list|,
name|var
argument_list|)
operator|||
comment|/* NEEDSWORK: use parse_config_key() once both are merged */
operator|(
name|starts_with
argument_list|(
name|var
argument_list|,
name|section
argument_list|)
operator|&&
name|var
index|[
name|strlen
argument_list|(
name|section
argument_list|)
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|strcmp
argument_list|(
name|var
operator|+
name|strlen
argument_list|(
name|section
argument_list|)
argument_list|,
literal|".hiderefs"
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|ref
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
name|ref
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ref
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|&&
name|ref
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|ref
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|hide_refs
condition|)
block|{
name|hide_refs
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hide_refs
argument_list|)
argument_list|)
expr_stmt|;
name|hide_refs
operator|->
name|strdup_strings
operator|=
literal|1
expr_stmt|;
block|}
name|string_list_append
argument_list|(
name|hide_refs
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ref_is_hidden
name|int
name|ref_is_hidden
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|char
modifier|*
name|refname_full
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|hide_refs
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|hide_refs
operator|->
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|const
name|char
modifier|*
name|match
init|=
name|hide_refs
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|subject
decl_stmt|;
name|int
name|neg
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|match
operator|==
literal|'!'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|match
operator|==
literal|'^'
condition|)
block|{
name|subject
operator|=
name|refname_full
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|subject
operator|=
name|refname
expr_stmt|;
block|}
comment|/* refname can be NULL when namespaces are used. */
if|if
condition|(
operator|!
name|subject
operator|||
operator|!
name|starts_with
argument_list|(
name|subject
argument_list|,
name|match
argument_list|)
condition|)
continue|continue;
name|len
operator|=
name|strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subject
index|[
name|len
index|]
operator|||
name|subject
index|[
name|len
index|]
operator|==
literal|'/'
condition|)
return|return
operator|!
name|neg
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_descendant_ref
specifier|const
name|char
modifier|*
name|find_descendant_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
specifier|const
name|struct
name|string_list
modifier|*
name|extras
parameter_list|,
specifier|const
name|struct
name|string_list
modifier|*
name|skip
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|extras
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Look at the place where dirname would be inserted into 	 * extras. If there is an entry at that position that starts 	 * with dirname (remember, dirname includes the trailing 	 * slash) and is not in skip, then we have a conflict. 	 */
for|for
control|(
name|pos
operator|=
name|string_list_find_insert_index
argument_list|(
name|extras
argument_list|,
name|dirname
argument_list|,
literal|0
argument_list|)
init|;
name|pos
operator|<
name|extras
operator|->
name|nr
condition|;
name|pos
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|extra_refname
init|=
name|extras
operator|->
name|items
index|[
name|pos
index|]
operator|.
name|string
decl_stmt|;
if|if
condition|(
operator|!
name|starts_with
argument_list|(
name|extra_refname
argument_list|,
name|dirname
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|skip
operator|||
operator|!
name|string_list_has_string
argument_list|(
name|skip
argument_list|,
name|extra_refname
argument_list|)
condition|)
return|return
name|extra_refname
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|rename_ref_available
name|int
name|rename_ref_available
parameter_list|(
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|struct
name|string_list
name|skip
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|struct
name|strbuf
name|err
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|string_list_insert
argument_list|(
operator|&
name|skip
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|!
name|verify_refname_available
argument_list|(
name|newname
argument_list|,
name|NULL
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|error
argument_list|(
literal|"%s"
argument_list|,
name|err
operator|.
name|buf
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|skip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
end_unit
