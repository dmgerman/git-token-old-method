begin_unit
begin_comment
comment|/*  * Copyright (c) 2005, Junio C Hamano  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"lockfile.h"
end_include
begin_comment
comment|/*  * path = absolute or relative path name  *  * Remove the last path name element from path (leaving the preceding  * "/", if any).  If path is empty or the root directory ("/"), set  * path to the empty string.  */
end_comment
begin_function
DECL|function|trim_last_path_component
specifier|static
name|void
name|trim_last_path_component
parameter_list|(
name|struct
name|strbuf
modifier|*
name|path
parameter_list|)
block|{
name|int
name|i
init|=
name|path
operator|->
name|len
decl_stmt|;
comment|/* back up past trailing slashes, if any */
while|while
condition|(
name|i
operator|&&
name|path
operator|->
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|i
operator|--
expr_stmt|;
comment|/* 	 * then go backwards until a slash, or the beginning of the 	 * string 	 */
while|while
condition|(
name|i
operator|&&
name|path
operator|->
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|i
operator|--
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* We allow "recursive" symbolic links. Only within reason, though */
end_comment
begin_define
DECL|macro|MAXDEPTH
define|#
directive|define
name|MAXDEPTH
value|5
end_define
begin_comment
comment|/*  * path contains a path that might be a symlink.  *  * If path is a symlink, attempt to overwrite it with a path to the  * real file or directory (which may or may not exist), following a  * chain of symlinks if necessary.  Otherwise, leave path unmodified.  *  * This is a best-effort routine.  If an error occurs, path will  * either be left unmodified or will name a different symlink in a  * symlink chain that started with the original path.  */
end_comment
begin_function
DECL|function|resolve_symlink
specifier|static
name|void
name|resolve_symlink
parameter_list|(
name|struct
name|strbuf
modifier|*
name|path
parameter_list|)
block|{
name|int
name|depth
init|=
name|MAXDEPTH
decl_stmt|;
specifier|static
name|struct
name|strbuf
name|link
init|=
name|STRBUF_INIT
decl_stmt|;
while|while
condition|(
name|depth
operator|--
condition|)
block|{
if|if
condition|(
name|strbuf_readlink
argument_list|(
operator|&
name|link
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|is_absolute_path
argument_list|(
name|link
operator|.
name|buf
argument_list|)
condition|)
comment|/* absolute path simply replaces p */
name|strbuf_reset
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
comment|/* 			 * link is a relative path, so replace the 			 * last element of p with it. 			 */
name|trim_last_path_component
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
name|path
argument_list|,
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
name|strbuf_reset
argument_list|(
operator|&
name|link
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Make sure errno contains a meaningful value on error */
end_comment
begin_function
DECL|function|lock_file
specifier|static
name|int
name|lock_file
parameter_list|(
name|struct
name|lock_file
modifier|*
name|lk
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|strbuf
name|filename
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|filename
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOCK_NO_DEREF
operator|)
condition|)
name|resolve_symlink
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|filename
argument_list|,
name|LOCK_SUFFIX
argument_list|)
expr_stmt|;
name|fd
operator|=
name|create_tempfile
argument_list|(
operator|&
name|lk
operator|->
name|tempfile
argument_list|,
name|filename
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function
begin_comment
comment|/*  * Constants defining the gaps between attempts to lock a file. The  * first backoff period is approximately INITIAL_BACKOFF_MS  * milliseconds. The longest backoff period is approximately  * (BACKOFF_MAX_MULTIPLIER * INITIAL_BACKOFF_MS) milliseconds.  */
end_comment
begin_define
DECL|macro|INITIAL_BACKOFF_MS
define|#
directive|define
name|INITIAL_BACKOFF_MS
value|1L
end_define
begin_define
DECL|macro|BACKOFF_MAX_MULTIPLIER
define|#
directive|define
name|BACKOFF_MAX_MULTIPLIER
value|1000
end_define
begin_comment
comment|/*  * Try locking path, retrying with quadratic backoff for at least  * timeout_ms milliseconds. If timeout_ms is 0, try locking the file  * exactly once. If timeout_ms is -1, try indefinitely.  */
end_comment
begin_function
DECL|function|lock_file_timeout
specifier|static
name|int
name|lock_file_timeout
parameter_list|(
name|struct
name|lock_file
modifier|*
name|lk
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|long
name|timeout_ms
parameter_list|)
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
name|int
name|multiplier
init|=
literal|1
decl_stmt|;
name|long
name|remaining_ms
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|random_initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|timeout_ms
operator|==
literal|0
condition|)
return|return
name|lock_file
argument_list|(
name|lk
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
return|;
if|if
condition|(
operator|!
name|random_initialized
condition|)
block|{
name|srand
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|random_initialized
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|timeout_ms
operator|>
literal|0
condition|)
name|remaining_ms
operator|=
name|timeout_ms
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|long
name|backoff_ms
decl_stmt|,
name|wait_ms
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|lock_file
argument_list|(
name|lk
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
name|fd
return|;
comment|/* success */
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
comment|/* failure other than lock held */
elseif|else
if|if
condition|(
name|timeout_ms
operator|>
literal|0
operator|&&
name|remaining_ms
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* failure due to timeout */
name|backoff_ms
operator|=
name|multiplier
operator|*
name|INITIAL_BACKOFF_MS
expr_stmt|;
comment|/* back off for between 0.75*backoff_ms and 1.25*backoff_ms */
name|wait_ms
operator|=
operator|(
literal|750
operator|+
name|rand
argument_list|()
operator|%
literal|500
operator|)
operator|*
name|backoff_ms
operator|/
literal|1000
expr_stmt|;
name|sleep_millisec
argument_list|(
name|wait_ms
argument_list|)
expr_stmt|;
name|remaining_ms
operator|-=
name|wait_ms
expr_stmt|;
comment|/* Recursion: (n+1)^2 = n^2 + 2n + 1 */
name|multiplier
operator|+=
literal|2
operator|*
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|multiplier
operator|>
name|BACKOFF_MAX_MULTIPLIER
condition|)
name|multiplier
operator|=
name|BACKOFF_MAX_MULTIPLIER
expr_stmt|;
else|else
name|n
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|unable_to_lock_message
name|void
name|unable_to_lock_message
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|err
parameter_list|,
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|err
operator|==
name|EEXIST
condition|)
block|{
name|strbuf_addf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Unable to create '%s.lock': %s.\n\n"
literal|"Another git process seems to be running in this repository, e.g.\n"
literal|"an editor opened by 'git commit'. Please make sure all processes\n"
literal|"are terminated then try again. If it still fails, a git process\n"
literal|"may have crashed in this repository earlier:\n"
literal|"remove the file manually to continue."
argument_list|)
argument_list|,
name|absolute_path
argument_list|(
name|path
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Unable to create '%s.lock': %s"
argument_list|)
argument_list|,
name|absolute_path
argument_list|(
name|path
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unable_to_lock_die
name|NORETURN
name|void
name|unable_to_lock_die
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|unable_to_lock_message
argument_list|(
name|path
argument_list|,
name|err
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"%s"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This should return a meaningful errno on failure */
end_comment
begin_function
DECL|function|hold_lock_file_for_update_timeout
name|int
name|hold_lock_file_for_update_timeout
parameter_list|(
name|struct
name|lock_file
modifier|*
name|lk
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|long
name|timeout_ms
parameter_list|)
block|{
name|int
name|fd
init|=
name|lock_file_timeout
argument_list|(
name|lk
argument_list|,
name|path
argument_list|,
name|flags
argument_list|,
name|timeout_ms
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
operator|(
name|flags
operator|&
name|LOCK_DIE_ON_ERROR
operator|)
condition|)
name|unable_to_lock_die
argument_list|(
name|path
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function
begin_function
DECL|function|get_locked_file_path
name|char
modifier|*
name|get_locked_file_path
parameter_list|(
name|struct
name|lock_file
modifier|*
name|lk
parameter_list|)
block|{
name|struct
name|strbuf
name|ret
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|ret
argument_list|,
name|get_tempfile_path
argument_list|(
operator|&
name|lk
operator|->
name|tempfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|len
operator|<=
name|LOCK_SUFFIX_LEN
operator|||
name|strcmp
argument_list|(
name|ret
operator|.
name|buf
operator|+
name|ret
operator|.
name|len
operator|-
name|LOCK_SUFFIX_LEN
argument_list|,
name|LOCK_SUFFIX
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: get_locked_file_path() called for malformed lock object"
argument_list|)
expr_stmt|;
comment|/* remove ".lock": */
name|strbuf_setlen
argument_list|(
operator|&
name|ret
argument_list|,
name|ret
operator|.
name|len
operator|-
name|LOCK_SUFFIX_LEN
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|ret
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|commit_lock_file
name|int
name|commit_lock_file
parameter_list|(
name|struct
name|lock_file
modifier|*
name|lk
parameter_list|)
block|{
name|char
modifier|*
name|result_path
init|=
name|get_locked_file_path
argument_list|(
name|lk
argument_list|)
decl_stmt|;
if|if
condition|(
name|commit_lock_file_to
argument_list|(
name|lk
argument_list|,
name|result_path
argument_list|)
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|result_path
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|free
argument_list|(
name|result_path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
