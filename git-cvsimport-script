#!/usr/bin/perl -w

# This tool is copyright (c) 2005, Matthias Urlichs.
# It is released under the Gnu Public License, version 2.
#
# The basic idea is to aggregate CVS check-ins into related changes.
# Fortunately, "cvsps" does that for us; all we have to do is to parse
# its output.
#
# Checking out the files is done by a single long-running CVS connection
# / server process.
#
# The head revision is on branch "origin" by default.
# You can change that with the '-o' option.

use strict;
use warnings;
use Getopt::Std;
use File::Path qw(mkpath);
use File::Basename qw(basename dirname);
use Time::Local;
use IO::Socket;
use IO::Pipe;
use POSIX qw(strftime dup2);

$SIG{'PIPE'}="IGNORE";
$ENV{'TZ'}="UTC";

our($opt_h,$opt_o,$opt_v,$opt_d);

sub usage() {
	print STDERR <<END;
Usage: ${\basename $0}     # fetch/update GIT from CVS
	   [ -o branch-for-HEAD ] [ -h ] [ -v ] [ -d CVSROOT ]
       CVS_module [ GIT_repository ]
END
	exit(1);
}

getopts("hqvo:d:") or usage();
usage if $opt_h;

@ARGV == 1 or @ARGV == 2 or usage();

my($cvs_tree, $git_tree) = @ARGV;

if($opt_d) {
	$ENV{"CVSROOT"} = $opt_d;
} elsif($ENV{"CVSROOT"}) {
	$opt_d = $ENV{"CVSROOT"};
} else {
	die "CVSROOT needs to be set";
}
$opt_o ||= "origin";
$git_tree ||= ".";

select(STDERR); $|=1; select(STDOUT);


package CVSconn;
# Basic CVS dialog.
# We're only interested in connecting and downloading, so ...

sub new {
	my($what,$repo,$subdir) = @_;
	$what=ref($what) if ref($what);

	my $self = {};
	$self->{'buffer'} = "";
	bless($self,$what);

	$repo =~ s#/+$##;
	$self->{'fullrep'} = $repo;
	$self->conn();

	$self->{'subdir'} = $subdir;
	$self->{'lines'} = undef;

	return $self;
}

sub conn {
	my $self = shift;
	my $repo = $self->{'fullrep'};
	if($repo =~ s/^:pserver:(?:(.*?)(?::(.*?))?@)?([^:\/]*)(?::(\d*))?//) {
		my($user,$pass,$serv,$port) = ($1,$2,$3,$4);
		$user="anonymous" unless defined $user;
		my $rr2 = "-";
		unless($port) {
			$rr2 = ":pserver:$user\@$serv:$repo";
			$port=2401;
		}
		my $rr = ":pserver:$user\@$serv:$port$repo";

		unless($pass) {
			open(H,$ENV{'HOME'}."/.cvspass") and do {
				# :pserver:cvs@mea.tmt.tele.fi:/cvsroot/zmailer Ah<Z
				while(<H>) {
					chomp;
					s/^\/\d+\s+//;
					my ($w,$p) = split(/\s/,$_,2);
					if($w eq $rr or $w eq $rr2) {
						$pass = $p;
						last;
					}
				}
			};
		}
		$pass="A" unless $pass;

		my $s = IO::Socket::INET->new(PeerHost => $serv, PeerPort => $port);
		die "Socket to $serv: $!\n" unless defined $s;
		$s->write("BEGIN AUTH REQUEST\n$repo\n$user\n$pass\nEND AUTH REQUEST\n")
			or die "Write to $serv: $!\n";
		$s->flush();

		my $rep = <$s>;

		if($rep ne "I LOVE YOU\n") {
			$rep="<unknown>" unless $rep;
			die "AuthReply: $rep\n";
		}
		$self->{'socketo'} = $s;
		$self->{'socketi'} = $s;
	} else { # local: Fork off our own cvs server.
		my $pr = IO::Pipe->new();
		my $pw = IO::Pipe->new();
		my $pid = fork();
		die "Fork: $!\n" unless defined $pid;
		unless($pid) {
			$pr->writer();
			$pw->reader();
			dup2($pw->fileno(),0);
			dup2($pr->fileno(),1);
			$pr->close();
			$pw->close();
			exec("cvs","server");
		}
		$pw->writer();
		$pr->reader();
		$self->{'socketo'} = $pw;
		$self->{'socketi'} = $pr;
	}
	$self->{'socketo'}->write("Root $repo\n");

	# Trial and error says that this probably is the minimum set
	$self->{'socketo'}->write("Valid-responses ok error Valid-requests Mode M Mbinary E F Checked-in Created Updated Merged Removed\n");

	$self->{'socketo'}->write("valid-requests\n");
	$self->{'socketo'}->flush();

	chomp(my $rep=$self->readline());
	if($rep !~ s/^Valid-requests\s*//) {
		$rep="<unknown>" unless $rep;
		die "Expected Valid-requests from server, but got: $rep\n";
	}
	chomp(my $res=$self->readline());
	die "validReply: $res\n" if $res ne "ok";

	$self->{'socketo'}->write("UseUnchanged\n") if $rep =~ /\bUseUnchanged\b/;
	$self->{'repo'} = $repo;
}

sub readline {
	my($self) = @_;
	return $self->{'socketi'}->getline();
}

sub _file {
	# Request a file with a given revision.
	# Trial and error says this is a good way to do it. :-/
	my($self,$fn,$rev) = @_;
	$self->{'socketo'}->write("Argument -N\n") or return undef;
	$self->{'socketo'}->write("Argument -P\n") or return undef;
	# $self->{'socketo'}->write("Argument -ko\n") or return undef;
	# -ko: Linus' version doesn't use it
	$self->{'socketo'}->write("Argument -r\n") or return undef;
	$self->{'socketo'}->write("Argument $rev\n") or return undef;
	$self->{'socketo'}->write("Argument --\n") or return undef;
	$self->{'socketo'}->write("Argument $self->{'subdir'}/$fn\n") or return undef;
	$self->{'socketo'}->write("Directory .\n") or return undef;
	$self->{'socketo'}->write("$self->{'repo'}\n") or return undef;
	$self->{'socketo'}->write("Sticky T1.1\n") or return undef;
	$self->{'socketo'}->write("co\n") or return undef;
	$self->{'socketo'}->flush() or return undef;
	$self->{'lines'} = 0;
	return 1;
}
sub _line {
	# Read a line from the server.
	# ... except that 'line' may be an entire file. ;-)
	my($self) = @_;
	die "Not in lines" unless defined $self->{'lines'};

	my $line;
	my $res="";
	while(defined($line = $self->readline())) {
		# M U gnupg-cvs-rep/AUTHORS
		# Updated gnupg-cvs-rep/
		# /daten/src/rsync/gnupg-cvs-rep/AUTHORS
		# /AUTHORS/1.1///T1.1
		# u=rw,g=rw,o=rw
		# 0
		# ok

		if($line =~ s/^(?:Created|Updated) //) {
			$line = $self->readline(); # path
			$line = $self->readline(); # Entries line
			my $mode = $self->readline(); chomp $mode;
			$self->{'mode'} = $mode;
			defined (my $cnt = $self->readline())
				or die "EOF from server after 'Changed'\n";
			chomp $cnt;
			die "Duh: Filesize $cnt" if $cnt !~ /^\d+$/;
			$line="";
			$res="";
			while($cnt) {
				my $buf;
				my $num = $self->{'socketi'}->read($buf,$cnt);
				die "Server: Filesize $cnt: $num: $!\n" if not defined $num or $num<=0;
				$res .= $buf;
				$cnt -= $num;
			}
		} elsif($line =~ s/^ //) {
			$res .= $line;
		} elsif($line =~ /^M\b/) {
			# output, do nothing
		} elsif($line =~ /^Mbinary\b/) {
			my $cnt;
			die "EOF from server after 'Mbinary'" unless defined ($cnt = $self->readline());
			chomp $cnt;
			die "Duh: Mbinary $cnt" if $cnt !~ /^\d+$/ or $cnt<1;
			$line="";
			while($cnt) {
				my $buf;
				my $num = $self->{'socketi'}->read($buf,$cnt);
				die "S: Mbinary $cnt: $num: $!\n" if not defined $num or $num<=0;
				$res .= $buf;
				$cnt -= $num;
			}
		} else {
			chomp $line;
			if($line eq "ok") {
				# print STDERR "S: ok (".length($res).")\n";
				return $res;
			} elsif($line =~ s/^E //) {
				# print STDERR "S: $line\n";
			} else {
				die "Unknown: $line\n";
			}
		}
	}
}
sub file {
	my($self,$fn,$rev) = @_;
	my $res;

	if ($self->_file($fn,$rev)) {
		$res = $self->_line();
		return $res if defined $res;
	}

	# retry
	$self->conn();
	$self->_file($fn,$rev)
		or die "No file command send\n";
	$res = $self->_line();
	die "No input: $fn $rev\n" unless defined $res;
	return $res;
}


package main;

my $cvs = CVSconn->new($opt_d, $cvs_tree);


sub pdate($) {
	my($d) = @_;
	m#(\d{2,4})/(\d\d)/(\d\d)\s(\d\d):(\d\d)(?::(\d\d))?#
		or die "Unparseable date: $d\n";
	my $y=$1; $y-=1900 if $y>1900;
	return timegm($6||0,$5,$4,$3,$2-1,$y);
}

sub pmode($) {
	my($mode) = @_;
	my $m = 0;
	my $mm = 0;
	my $um = 0;
	for my $x(split(//,$mode)) {
		if($x eq ",") {
			$m |= $mm&$um;
			$mm = 0;
			$um = 0;
		} elsif($x eq "u") { $um |= 0700;
		} elsif($x eq "g") { $um |= 0070;
		} elsif($x eq "o") { $um |= 0007;
		} elsif($x eq "r") { $mm |= 0444;
		} elsif($x eq "w") { $mm |= 0222;
		} elsif($x eq "x") { $mm |= 0111;
		} elsif($x eq "=") { # do nothing
		} else { die "Unknown mode: $mode\n";
		}
	}
	$m |= $mm&$um;
	return $m;
}

my $tmpcv = "/var/cache/cvs";

sub getwd() {
	my $pwd = `pwd`;
	chomp $pwd;
	return $pwd;
}

-d $git_tree
	or mkdir($git_tree,0777)
	or die "Could not create $git_tree: $!";
chdir($git_tree);

my $last_branch = "";
my %branch_date;

my $git_dir = $ENV{"GIT_DIR"} || ".git";
$git_dir = getwd()."/".$git_dir unless $git_dir =~ m#^/#;
$ENV{"GIT_DIR"} = $git_dir;
unless(-d $git_dir) {
	system("git-init-db");
	die "Cannot init the GIT db at $git_tree: $?\n" if $?;
	system("git-read-tree");
	die "Cannot init an empty tree: $?\n" if $?;

	$last_branch = $opt_o;
} else {
	$last_branch = basename(readlink("$git_dir/HEAD"));
	die "Cannot read the last branch name: $!\n" unless $last_branch;

	# Get the last import timestamps
	opendir(D,"$git_dir/refs/heads");
	while(defined(my $head = readdir(D))) {
		next if $head =~ /^\./;
		open(F,"$git_dir/refs/heads/$head")
			or die "Bad head branch: $head: $!\n";
		chomp(my $ftag = <F>);
		close(F);
		open(F,"git-cat-file commit $ftag |");
		while(<F>) {
			next unless /^author\s.*\s(\d+)\s[-+]\d{4}$/;
			$branch_date{$head} = $1;
			last;
		}
		close(F);
	}
	closedir(D);
}

-d $git_dir
	or die "Could not create git subdir ($git_dir).\n";

my $pid = open(CVS,"-|");
die "Cannot fork: $!\n" unless defined $pid;
unless($pid) {
	exec("cvsps","-A","--cvs-direct",$cvs_tree);
	die "Could not start cvsps: $!\n";
}


## cvsps output:
#---------------------
#PatchSet 314
#Date: 1999/09/18 13:03:59
#Author: wkoch
#Branch: STABLE-BRANCH-1-0
#Ancestor branch: HEAD
#Tag: (none)
#Log:
#    See ChangeLog: Sat Sep 18 13:03:28 CEST 1999  Werner Koch
#Members:
#	README:1.57->1.57.2.1
#	VERSION:1.96->1.96.2.1
#
#---------------------

my $state = 0;

my($patchset,$date,$author,$branch,$ancestor,$tag,$logmsg);
my(@old,@new);
my $commit = sub {
	my $pid;
	system("git-update-cache","--force-remove","--",@old) if @old;
	die "Cannot remove files: $?\n" if $?;
	system("git-update-cache","--add","--",@new) if @new;
	die "Cannot add files: $?\n" if $?;

	$pid = open(C,"-|");
	die "Cannot fork: $!" unless defined $pid;
	unless($pid) {
		exec("git-write-tree");
		die "Cannot exec git-write-tree: $!\n";
	}
	chomp(my $tree = <C>);
	length($tree) == 40
		or die "Cannot get tree id ($tree): $!\n";
	close(C)
		or die "Error running git-write-tree: $?\n";
	print "Tree ID $tree\n" if $opt_v;

	my $parent = "";
	if(open(C,"$git_dir/refs/heads/$last_branch")) {
		chomp($parent = <C>);
		close(C);
		length($parent) == 40
			or die "Cannot get parent id ($parent): $!\n";
		print "Parent ID $parent\n" if $opt_v;
	}

	my $pr = IO::Pipe->new();
	my $pw = IO::Pipe->new();
	$pid = fork();
	die "Fork: $!\n" unless defined $pid;
	unless($pid) {
		$pr->writer();
		$pw->reader();
		dup2($pw->fileno(),0);
		dup2($pr->fileno(),1);
		$pr->close();
		$pw->close();

		my @par = ();
		@par = ("-p",$parent) if $parent;
		exec("env",
			"GIT_AUTHOR_NAME=$author",
			"GIT_AUTHOR_EMAIL=$author",
			"GIT_AUTHOR_DATE=".strftime("+0000 %Y-%m-%d %H:%M:%S",gmtime($date)),
			"GIT_COMMITTER_NAME=$author",
			"GIT_COMMITTER_EMAIL=$author",
			"GIT_COMMITTER_DATE=".strftime("+0000 %Y-%m-%d %H:%M:%S",gmtime($date)),
			"git-commit-tree", $tree,@par);
		die "Cannot exec git-commit-tree: $!\n";
	}
	$pw->writer();
	$pr->reader();
	print $pw $logmsg
		or die "Error writing to git-commit-tree: $!\n";
	$pw->close();

	print "Committed patch $patchset ($branch)\n" if $opt_v;
	chomp(my $cid = <$pr>);
	length($cid) == 40
		or die "Cannot get commit id ($cid): $!\n";
	print "Commit ID $cid\n" if $opt_v;
	$pr->close();

	waitpid($pid,0);
	die "Error running git-commit-tree: $?\n" if $?;

	open(C,">$git_dir/refs/heads/$branch")
		or die "Cannot open branch $branch for update: $!\n";
	print C "$cid\n"
		or die "Cannot write branch $branch for update: $!\n";
	close(C)
		or die "Cannot write branch $branch for update: $!\n";

	if($tag) {
		open(C,">$git_dir/refs/tags/$tag")
			or die "Cannot create tag $tag: $!\n";
		print C "$cid\n"
			or die "Cannot write tag $branch: $!\n";
		close(C)
			or die "Cannot write tag $branch: $!\n";
		print "Created tag '$tag' on '$branch'\n" if $opt_v;
	}

	@old = ();
	@new = ();
};

while(<CVS>) {
	chomp;
	if($state == 0 and /^-+$/) {
		$state = 1;
	} elsif($state == 0) {
		$state = 1;
		redo;
	} elsif(($state==0 or $state==1) and s/^PatchSet\s+//) {
		$patchset = 0+$_;
		$state=2;
	} elsif($state == 2 and s/^Date:\s+//) {
		$date = pdate($_);
		unless($date) {
			print STDERR "Could not parse date: $_\n";
			$state=0;
			next;
		}
		$state=3;
	} elsif($state == 3 and s/^Author:\s+//) {
		s/\s+$//;
		$author = $_;
		$state = 4;
	} elsif($state == 4 and s/^Branch:\s+//) {
		s/\s+$//;
		$branch = $_;
		$state = 5;
	} elsif($state == 5 and s/^Ancestor branch:\s+//) {
		s/\s+$//;
		$ancestor = $_;
		$ancestor = $opt_o if $ancestor == "HEAD";
		$state = 6;
	} elsif($state == 5) {
		$ancestor = undef;
		$state = 6;
		redo;
	} elsif($state == 6 and s/^Tag:\s+//) {
		s/\s+$//;
		if($_ eq "(none)") {
			$tag = undef;
		} else {
			$tag = $_;
		}
		$state = 7;
	} elsif($state == 7 and /^Log:/) {
		$logmsg = "";
		$state = 8;
	} elsif($state == 8 and /^Members:/) {
		$branch = $opt_o if $branch eq "HEAD";
		if(defined $branch_date{$branch} and $branch_date{$branch} >= $date) {
			# skip
			print "skip patchset $patchset: $date before $branch_date{$branch}\n";
			$state = 11;
			next;
		}
		if($ancestor) {
			if(-f "$git_dir/refs/heads/$branch") {
				print STDERR "Branch $branch already exists!\n";
				$state=11;
				next;
			}
			unless(open(H,"$git_dir/refs/heads/$ancestor")) {
				print STDERR "Branch $ancestor does not exist!\n";
				$state=11;
				next;
			}
			chomp(my $id = <H>);
			close(H);
			unless(open(H,"> $git_dir/refs/heads/$branch")) {
				print STDERR "Could not create branch $branch: $!\n";
				$state=11;
				next;
			}
			print H "$id\n"
				or die "Could not write branch $branch: $!";
			close(H)
				or die "Could not write branch $branch: $!";
		}
		if(($ancestor || $branch) ne $last_branch) {
			print "Switching from $last_branch to $branch\n" if $opt_v;
			system("git-read-tree -m -u $last_branch $branch");
			die "read-tree $branch failed at $branch: $?\n" if $?;
		}
		if($branch ne $last_branch) {
			unlink("$git_dir/HEAD");
			symlink("refs/heads/$branch","$git_dir/HEAD");
			$last_branch = $branch;
		}
		$state = 9;
	} elsif($state == 8) {
		$logmsg .= "$_\n";
	} elsif($state == 9 and /^\s+(\S+):(INITIAL|\d(?:\.\d+)+)->(\d(?:\.\d+)+)\s*$/) {
#	VERSION:1.96->1.96.2.1
		my $init = ($2 eq "INITIAL");
		my $fn = $1;
		my $data = $cvs->file($fn,$3);
		print "".($init ? "New" : "Update")." $fn: ".length($data)." bytes.\n";
		mkpath(dirname($fn),$opt_v);
		open(F,"> ./$fn")
			or die "Cannot create '$fn': $!\n";
		print F $data
			or die "Cannot write to '$fn': $!\n";
		close(F)
			or die "Cannot write to '$fn': $!\n";
		chmod(pmode($cvs->{'mode'}), $fn);
		push(@new,$fn); # may be resurrected!
	} elsif($state == 9 and /^\s+(\S+):\d(?:\.\d+)+->(\d(?:\.\d+)+)\(DEAD\)\s*$/) {
		push(@old,$1);
	} elsif($state == 9 and /^\s*$/) {
		$state = 10;
	} elsif(($state == 9 or $state == 10) and /^-+$/) {
		&$commit();
		$state = 1;
	} elsif($state == 11 and /^-+$/) {
		$state = 1;
	} elsif(/^-+$/) { # end of unknown-line processing
		$state = 1;
	} elsif($state != 11) { # ignore stuff when skipping
		print "* UNKNOWN LINE * $_\n";
	}
}
&$commit() if $branch and $state != 11;

print "DONE\n" if $opt_v;
