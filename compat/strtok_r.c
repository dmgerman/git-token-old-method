begin_unit
begin_comment
comment|/* Reentrant string tokenizer.  Generic version.    Copyright (C) 1991,1996-1999,2001,2004 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, write to the Free    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA    02111-1307 USA.  */
end_comment
begin_include
include|#
directive|include
file|"../git-compat-util.h"
end_include
begin_comment
comment|/* Parse S into tokens separated by characters in DELIM.    If S is NULL, the saved pointer in SAVE_PTR is used as    the next starting point.  For example: 	char s[] = "-abc-=-def"; 	char *sp; 	x = strtok_r(s, "-",&sp);	// x = "abc", sp = "=-def" 	x = strtok_r(NULL, "-=",&sp);	// x = "def", sp = NULL 	x = strtok_r(NULL, "=",&sp);	// x = NULL 		// s = "abc\0-def\0" */
end_comment
begin_function
name|char
modifier|*
DECL|function|gitstrtok_r
name|gitstrtok_r
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|,
name|char
modifier|*
modifier|*
name|save_ptr
parameter_list|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
operator|*
name|save_ptr
expr_stmt|;
comment|/* Scan leading delimiters.  */
name|s
operator|+=
name|strspn
argument_list|(
name|s
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|save_ptr
operator|=
name|s
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Find the end of the token.  */
name|token
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|strpbrk
argument_list|(
name|token
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
comment|/* This token finishes the string.  */
operator|*
name|save_ptr
operator|=
name|token
operator|+
name|strlen
argument_list|(
name|token
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Terminate the token and make *SAVE_PTR point past it.  */
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|save_ptr
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
end_function
end_unit
