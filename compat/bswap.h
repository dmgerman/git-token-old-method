begin_unit
begin_comment
comment|/*  * Let's make sure we always have a sane definition for ntohl()/htonl().  * Some libraries define those as a function call, just to perform byte  * shifting, bringing significant overhead to what should be a simple  * operation.  */
end_comment
begin_comment
comment|/*  * Default version that the compiler ought to optimize properly with  * constant values.  */
end_comment
begin_function
DECL|function|default_swab32
specifier|static
specifier|inline
name|uint32_t
name|default_swab32
parameter_list|(
name|uint32_t
name|val
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|val
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x0000ff00
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|default_bswap64
specifier|static
specifier|inline
name|uint64_t
name|default_bswap64
parameter_list|(
name|uint64_t
name|val
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0x00000000000000ffULL
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0x000000000000ff00ULL
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0x0000000000ff0000ULL
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0x00000000ff000000ULL
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0x000000ff00000000ULL
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0x0000ff0000000000ULL
operator|)
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0x00ff000000000000ULL
operator|)
operator|>>
literal|40
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|uint64_t
operator|)
literal|0xff00000000000000ULL
operator|)
operator|>>
literal|56
operator|)
operator|)
return|;
block|}
end_function
begin_undef
DECL|macro|bswap32
undef|#
directive|undef
name|bswap32
end_undef
begin_undef
DECL|macro|bswap64
undef|#
directive|undef
name|bswap64
end_undef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|bswap32
define|#
directive|define
name|bswap32
value|git_bswap32
end_define
begin_function
DECL|function|git_bswap32
specifier|static
specifier|inline
name|uint32_t
name|git_bswap32
parameter_list|(
name|uint32_t
name|x
parameter_list|)
block|{
name|uint32_t
name|result
decl_stmt|;
if|if
condition|(
name|__builtin_constant_p
argument_list|(
name|x
argument_list|)
condition|)
name|result
operator|=
name|default_swab32
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
asm|__asm__("bswap %0" : "=r" (result) : "0" (x));
return|return
name|result
return|;
block|}
end_function
begin_define
DECL|macro|bswap64
define|#
directive|define
name|bswap64
value|git_bswap64
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_if
begin_function
DECL|function|git_bswap64
specifier|static
specifier|inline
name|uint64_t
name|git_bswap64
parameter_list|(
name|uint64_t
name|x
parameter_list|)
block|{
name|uint64_t
name|result
decl_stmt|;
if|if
condition|(
name|__builtin_constant_p
argument_list|(
name|x
argument_list|)
condition|)
name|result
operator|=
name|default_bswap64
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
asm|__asm__("bswap %q0" : "=r" (result) : "0" (x));
return|return
name|result
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|git_bswap64
specifier|static
specifier|inline
name|uint64_t
name|git_bswap64
parameter_list|(
name|uint64_t
name|x
parameter_list|)
block|{
union|union
block|{
name|uint64_t
name|i64
decl_stmt|;
name|uint32_t
name|i32
index|[
literal|2
index|]
decl_stmt|;
block|}
name|tmp
union|,
name|result
union|;
if|if
condition|(
name|__builtin_constant_p
argument_list|(
name|x
argument_list|)
condition|)
name|result
operator|.
name|i64
operator|=
name|default_bswap64
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|tmp
operator|.
name|i64
operator|=
name|x
expr_stmt|;
name|result
operator|.
name|i32
index|[
literal|0
index|]
operator|=
name|git_bswap32
argument_list|(
name|tmp
operator|.
name|i32
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|result
operator|.
name|i32
index|[
literal|1
index|]
operator|=
name|git_bswap32
argument_list|(
name|tmp
operator|.
name|i32
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|i64
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|)
end_elif
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_define
DECL|macro|bswap32
define|#
directive|define
name|bswap32
parameter_list|(
name|x
parameter_list|)
value|_byteswap_ulong(x)
end_define
begin_define
DECL|macro|bswap64
define|#
directive|define
name|bswap64
parameter_list|(
name|x
parameter_list|)
value|_byteswap_uint64(x)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|bswap32
argument_list|)
end_if
begin_undef
DECL|macro|ntohl
undef|#
directive|undef
name|ntohl
end_undef
begin_undef
DECL|macro|htonl
undef|#
directive|undef
name|htonl
end_undef
begin_define
DECL|macro|ntohl
define|#
directive|define
name|ntohl
parameter_list|(
name|x
parameter_list|)
value|bswap32(x)
end_define
begin_define
DECL|macro|htonl
define|#
directive|define
name|htonl
parameter_list|(
name|x
parameter_list|)
value|bswap32(x)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|bswap64
argument_list|)
end_if
begin_undef
DECL|macro|ntohll
undef|#
directive|undef
name|ntohll
end_undef
begin_undef
DECL|macro|htonll
undef|#
directive|undef
name|htonll
end_undef
begin_define
DECL|macro|ntohll
define|#
directive|define
name|ntohll
parameter_list|(
name|x
parameter_list|)
value|bswap64(x)
end_define
begin_define
DECL|macro|htonll
define|#
directive|define
name|htonll
parameter_list|(
name|x
parameter_list|)
value|bswap64(x)
end_define
begin_else
else|#
directive|else
end_else
begin_undef
DECL|macro|ntohll
undef|#
directive|undef
name|ntohll
end_undef
begin_undef
DECL|macro|htonll
undef|#
directive|undef
name|htonll
end_undef
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BYTE_ORDER
argument_list|)
end_if
begin_if
if|#
directive|if
name|defined
argument_list|(
name|BYTE_ORDER
argument_list|)
operator|&&
name|defined
argument_list|(
name|LITTLE_ENDIAN
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIG_ENDIAN
argument_list|)
end_if
begin_define
DECL|macro|__BYTE_ORDER
define|#
directive|define
name|__BYTE_ORDER
value|BYTE_ORDER
end_define
begin_define
DECL|macro|__LITTLE_ENDIAN
define|#
directive|define
name|__LITTLE_ENDIAN
value|LITTLE_ENDIAN
end_define
begin_define
DECL|macro|__BIG_ENDIAN
define|#
directive|define
name|__BIG_ENDIAN
value|BIG_ENDIAN
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__BYTE_ORDER
argument_list|)
end_if
begin_error
error|#
directive|error
literal|"Cannot determine endianness"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
end_if
begin_define
DECL|macro|ntohll
define|#
directive|define
name|ntohll
parameter_list|(
name|n
parameter_list|)
value|(n)
end_define
begin_define
DECL|macro|htonll
define|#
directive|define
name|htonll
parameter_list|(
name|n
parameter_list|)
value|(n)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ntohll
define|#
directive|define
name|ntohll
parameter_list|(
name|n
parameter_list|)
value|default_bswap64(n)
end_define
begin_define
DECL|macro|htonll
define|#
directive|define
name|htonll
parameter_list|(
name|n
parameter_list|)
value|default_bswap64(n)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
end_unit
