begin_unit
comment|'# subprocess - Subprocesses with accessible I/O streams'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# For more information about this module, see PEP 324.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2003-2004 by Peter Astrand <astrand@lysator.liu.se>'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# By obtaining, using, and/or copying this software and/or its'
nl|'\n'
comment|'# associated documentation, you agree that you have read, understood,'
nl|'\n'
comment|'# and will comply with the following terms and conditions:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Permission to use, copy, modify, and distribute this software and'
nl|'\n'
comment|'# its associated documentation for any purpose and without fee is'
nl|'\n'
comment|'# hereby granted, provided that the above copyright notice appears in'
nl|'\n'
comment|'# all copies, and that both that copyright notice and this permission'
nl|'\n'
comment|'# notice appear in supporting documentation, and that the name of the'
nl|'\n'
comment|'# author not be used in advertising or publicity pertaining to'
nl|'\n'
comment|'# distribution of the software without specific, written prior'
nl|'\n'
comment|'# permission.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,'
nl|'\n'
comment|'# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.'
nl|'\n'
comment|'# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR'
nl|'\n'
comment|'# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS'
nl|'\n'
comment|'# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,'
nl|'\n'
comment|'# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION'
nl|'\n'
comment|'# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Use of this file within git is permitted under GPLv2.'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
string|'r"""subprocess - Subprocesses with accessible I/O streams\n\nThis module allows you to spawn processes, connect to their\ninput/output/error pipes, and obtain their return codes.  This module\nintends to replace several other, older modules and functions, like:\n\nos.system\nos.spawn*\nos.popen*\npopen2.*\ncommands.*\n\nInformation about how the subprocess module can be used to replace these\nmodules and functions can be found below.\n\n\n\nUsing the subprocess module\n===========================\nThis module defines one class called Popen:\n\nclass Popen(args, bufsize=0, executable=None,\n            stdin=None, stdout=None, stderr=None,\n            preexec_fn=None, close_fds=False, shell=False,\n            cwd=None, env=None, universal_newlines=False,\n            startupinfo=None, creationflags=0):\n\n\nArguments are:\n\nargs should be a string, or a sequence of program arguments.  The\nprogram to execute is normally the first item in the args sequence or\nstring, but can be explicitly set by using the executable argument.\n\nOn UNIX, with shell=False (default): In this case, the Popen class\nuses os.execvp() to execute the child program.  args should normally\nbe a sequence.  A string will be treated as a sequence with the string\nas the only item (the program to execute).\n\nOn UNIX, with shell=True: If args is a string, it specifies the\ncommand string to execute through the shell.  If args is a sequence,\nthe first item specifies the command string, and any additional items\nwill be treated as additional shell arguments.\n\nOn Windows: the Popen class uses CreateProcess() to execute the child\nprogram, which operates on strings.  If args is a sequence, it will be\nconverted to a string using the list2cmdline method.  Please note that\nnot all MS Windows applications interpret the command line the same\nway: The list2cmdline is designed for applications using the same\nrules as the MS C runtime.\n\nbufsize, if given, has the same meaning as the corresponding argument\nto the built-in open() function: 0 means unbuffered, 1 means line\nbuffered, any other positive value means use a buffer of\n(approximately) that size.  A negative bufsize means to use the system\ndefault, which usually means fully buffered.  The default value for\nbufsize is 0 (unbuffered).\n\nstdin, stdout and stderr specify the executed programs\' standard\ninput, standard output and standard error file handles, respectively.\nValid values are PIPE, an existing file descriptor (a positive\ninteger), an existing file object, and None.  PIPE indicates that a\nnew pipe to the child should be created.  With None, no redirection\nwill occur; the child\'s file handles will be inherited from the\nparent.  Additionally, stderr can be STDOUT, which indicates that the\nstderr data from the applications should be captured into the same\nfile handle as for stdout.\n\nIf preexec_fn is set to a callable object, this object will be called\nin the child process just before the child is executed.\n\nIf close_fds is true, all file descriptors except 0, 1 and 2 will be\nclosed before the child process is executed.\n\nif shell is true, the specified command will be executed through the\nshell.\n\nIf cwd is not None, the current directory will be changed to cwd\nbefore the child is executed.\n\nIf env is not None, it defines the environment variables for the new\nprocess.\n\nIf universal_newlines is true, the file objects stdout and stderr are\nopened as a text files, but lines may be terminated by any of \'\\n\',\nthe Unix end-of-line convention, \'\\r\', the Macintosh convention or\n\'\\r\\n\', the Windows convention.  All of these external representations\nare seen as \'\\n\' by the Python program.  Note: This feature is only\navailable if Python is built with universal newline support (the\ndefault).  Also, the newlines attribute of the file objects stdout,\nstdin and stderr are not updated by the communicate() method.\n\nThe startupinfo and creationflags, if given, will be passed to the\nunderlying CreateProcess() function.  They can specify things such as\nappearance of the main window and priority for the new process.\n(Windows only)\n\n\nThis module also defines two shortcut functions:\n\ncall(*args, **kwargs):\n    Run command with arguments.  Wait for command to complete, then\n    return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    retcode = call(["ls", "-l"])\n\n\nExceptions\n----------\nExceptions raised in the child process, before the new program has\nstarted to execute, will be re-raised in the parent.  Additionally,\nthe exception object will have one extra attribute called\n\'child_traceback\', which is a string containing traceback information\nfrom the childs point of view.\n\nThe most common exception raised is OSError.  This occurs, for\nexample, when trying to execute a non-existent file.  Applications\nshould prepare for OSErrors.\n\nA ValueError will be raised if Popen is called with invalid arguments.\n\n\nSecurity\n--------\nUnlike some other popen functions, this implementation will never call\n/bin/sh implicitly.  This means that all characters, including shell\nmetacharacters, can safely be passed to child processes.\n\n\nPopen objects\n=============\nInstances of the Popen class have the following methods:\n\npoll()\n    Check if child process has terminated.  Returns returncode\n    attribute.\n\nwait()\n    Wait for child process to terminate.  Returns returncode attribute.\n\ncommunicate(input=None)\n    Interact with process: Send data to stdin.  Read data from stdout\n    and stderr, until end-of-file is reached.  Wait for process to\n    terminate.  The optional stdin argument should be a string to be\n    sent to the child process, or None, if no data should be sent to\n    the child.\n\n    communicate() returns a tuple (stdout, stderr).\n\n    Note: The data read is buffered in memory, so do not use this\n    method if the data size is large or unlimited.\n\nThe following attributes are also available:\n\nstdin\n    If the stdin argument is PIPE, this attribute is a file object\n    that provides input to the child process.  Otherwise, it is None.\n\nstdout\n    If the stdout argument is PIPE, this attribute is a file object\n    that provides output from the child process.  Otherwise, it is\n    None.\n\nstderr\n    If the stderr argument is PIPE, this attribute is file object that\n    provides error output from the child process.  Otherwise, it is\n    None.\n\npid\n    The process ID of the child process.\n\nreturncode\n    The child return code.  A None value indicates that the process\n    hasn\'t terminated yet.  A negative value -N indicates that the\n    child was terminated by signal N (UNIX only).\n\n\nReplacing older functions with the subprocess module\n====================================================\nIn this section, "a ==> b" means that b can be used as a replacement\nfor a.\n\nNote: All functions in this section fail (more or less) silently if\nthe executed program cannot be found; this module raises an OSError\nexception.\n\nIn the following examples, we assume that the subprocess module is\nimported with "from subprocess import *".\n\n\nReplacing /bin/sh shell backquote\n---------------------------------\noutput=`mycmd myarg`\n==>\noutput = Popen(["mycmd", "myarg"], stdout=PIPE).communicate()[0]\n\n\nReplacing shell pipe line\n-------------------------\noutput=`dmesg | grep hda`\n==>\np1 = Popen(["dmesg"], stdout=PIPE)\np2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]\n\n\nReplacing os.system()\n---------------------\nsts = os.system("mycmd" + " myarg")\n==>\np = Popen("mycmd" + " myarg", shell=True)\nsts = os.waitpid(p.pid, 0)\n\nNote:\n\n* Calling the program through the shell is usually not required.\n\n* It\'s easier to look at the returncode attribute than the\n  exitstatus.\n\nA more real-world example would look like this:\n\ntry:\n    retcode = call("mycmd" + " myarg", shell=True)\n    if retcode < 0:\n        print >>sys.stderr, "Child was terminated by signal", -retcode\n    else:\n        print >>sys.stderr, "Child returned", retcode\nexcept OSError, e:\n    print >>sys.stderr, "Execution failed:", e\n\n\nReplacing os.spawn*\n-------------------\nP_NOWAIT example:\n\npid = os.spawnlp(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg")\n==>\npid = Popen(["/bin/mycmd", "myarg"]).pid\n\n\nP_WAIT example:\n\nretcode = os.spawnlp(os.P_WAIT, "/bin/mycmd", "mycmd", "myarg")\n==>\nretcode = call(["/bin/mycmd", "myarg"])\n\n\nVector example:\n\nos.spawnvp(os.P_NOWAIT, path, args)\n==>\nPopen([path] + args[1:])\n\n\nEnvironment example:\n\nos.spawnlpe(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg", env)\n==>\nPopen(["/bin/mycmd", "myarg"], env={"PATH": "/usr/bin"})\n\n\nReplacing os.popen*\n-------------------\npipe = os.popen(cmd, mode=\'r\', bufsize)\n==>\npipe = Popen(cmd, shell=True, bufsize=bufsize, stdout=PIPE).stdout\n\npipe = os.popen(cmd, mode=\'w\', bufsize)\n==>\npipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin\n\n\n(child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize)\n==>\np = Popen(cmd, shell=True, bufsize=bufsize,\n          stdin=PIPE, stdout=PIPE, close_fds=True)\n(child_stdin, child_stdout) = (p.stdin, p.stdout)\n\n\n(child_stdin,\n child_stdout,\n child_stderr) = os.popen3(cmd, mode, bufsize)\n==>\np = Popen(cmd, shell=True, bufsize=bufsize,\n          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)\n(child_stdin,\n child_stdout,\n child_stderr) = (p.stdin, p.stdout, p.stderr)\n\n\n(child_stdin, child_stdout_and_stderr) = os.popen4(cmd, mode, bufsize)\n==>\np = Popen(cmd, shell=True, bufsize=bufsize,\n          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)\n(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)\n\n\nReplacing popen2.*\n------------------\nNote: If the cmd argument to popen2 functions is a string, the command\nis executed through /bin/sh.  If it is a list, the command is directly\nexecuted.\n\n(child_stdout, child_stdin) = popen2.popen2("somestring", bufsize, mode)\n==>\np = Popen(["somestring"], shell=True, bufsize=bufsize\n          stdin=PIPE, stdout=PIPE, close_fds=True)\n(child_stdout, child_stdin) = (p.stdout, p.stdin)\n\n\n(child_stdout, child_stdin) = popen2.popen2(["mycmd", "myarg"], bufsize, mode)\n==>\np = Popen(["mycmd", "myarg"], bufsize=bufsize,\n          stdin=PIPE, stdout=PIPE, close_fds=True)\n(child_stdout, child_stdin) = (p.stdout, p.stdin)\n\nThe popen2.Popen3 and popen3.Popen4 basically works as subprocess.Popen,\nexcept that:\n\n* subprocess.Popen raises an exception if the execution fails\n* the capturestderr argument is replaced with the stderr argument.\n* stdin=PIPE and stdout=PIPE must be specified.\n* popen2 closes all filedescriptors by default, but you have to specify\n  close_fds=True with subprocess.Popen.\n\n\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
newline|'\n'
DECL|variable|mswindows
name|'mswindows'
op|'='
op|'('
name|'sys'
op|'.'
name|'platform'
op|'=='
string|'"win32"'
op|')'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'types'
newline|'\n'
name|'import'
name|'traceback'
newline|'\n'
nl|'\n'
name|'if'
name|'mswindows'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'threading'
newline|'\n'
name|'import'
name|'msvcrt'
newline|'\n'
name|'if'
number|'0'
op|':'
comment|'# <-- change this to use pywin32 instead of the _subprocess driver'
newline|'\n'
indent|'        '
name|'import'
name|'pywintypes'
newline|'\n'
name|'from'
name|'win32api'
name|'import'
name|'GetStdHandle'
op|','
name|'STD_INPUT_HANDLE'
op|','
name|'STD_OUTPUT_HANDLE'
op|','
name|'STD_ERROR_HANDLE'
newline|'\n'
name|'from'
name|'win32api'
name|'import'
name|'GetCurrentProcess'
op|','
name|'DuplicateHandle'
op|','
name|'GetModuleFileName'
op|','
name|'GetVersion'
newline|'\n'
name|'from'
name|'win32con'
name|'import'
name|'DUPLICATE_SAME_ACCESS'
op|','
name|'SW_HIDE'
newline|'\n'
name|'from'
name|'win32pipe'
name|'import'
name|'CreatePipe'
newline|'\n'
name|'from'
name|'win32process'
name|'import'
name|'CreateProcess'
op|','
name|'STARTUPINFO'
op|','
name|'GetExitCodeProcess'
op|','
name|'STARTF_USESTDHANDLES'
op|','
name|'STARTF_USESHOWWINDOW'
op|','
name|'CREATE_NEW_CONSOLE'
newline|'\n'
name|'from'
name|'win32event'
name|'import'
name|'WaitForSingleObject'
op|','
name|'INFINITE'
op|','
name|'WAIT_OBJECT_0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'from'
name|'_subprocess'
name|'import'
op|'*'
newline|'\n'
DECL|class|STARTUPINFO
name|'class'
name|'STARTUPINFO'
op|':'
newline|'\n'
DECL|variable|dwFlags
indent|'            '
name|'dwFlags'
op|'='
number|'0'
newline|'\n'
DECL|variable|hStdInput
name|'hStdInput'
op|'='
name|'None'
newline|'\n'
DECL|variable|hStdOutput
name|'hStdOutput'
op|'='
name|'None'
newline|'\n'
DECL|variable|hStdError
name|'hStdError'
op|'='
name|'None'
newline|'\n'
DECL|class|pywintypes
dedent|''
name|'class'
name|'pywintypes'
op|':'
newline|'\n'
DECL|variable|error
indent|'            '
name|'error'
op|'='
name|'IOError'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'select'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'fcntl'
newline|'\n'
name|'import'
name|'pickle'
newline|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
name|'__all__'
op|'='
op|'['
string|'"Popen"'
op|','
string|'"PIPE"'
op|','
string|'"STDOUT"'
op|','
string|'"call"'
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
DECL|variable|MAXFD
indent|'    '
name|'MAXFD'
op|'='
name|'os'
op|'.'
name|'sysconf'
op|'('
string|'"SC_OPEN_MAX"'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
DECL|variable|MAXFD
indent|'    '
name|'MAXFD'
op|'='
number|'256'
newline|'\n'
nl|'\n'
comment|'# True/False does not exist on 2.2.0'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'False'
newline|'\n'
dedent|''
name|'except'
name|'NameError'
op|':'
newline|'\n'
DECL|variable|False
indent|'    '
name|'False'
op|'='
number|'0'
newline|'\n'
DECL|variable|True
name|'True'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|variable|_active
dedent|''
name|'_active'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|_cleanup
name|'def'
name|'_cleanup'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'inst'
name|'in'
name|'_active'
op|'['
op|':'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'inst'
op|'.'
name|'poll'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|PIPE
dedent|''
dedent|''
name|'PIPE'
op|'='
op|'-'
number|'1'
newline|'\n'
DECL|variable|STDOUT
name|'STDOUT'
op|'='
op|'-'
number|'2'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|call
name|'def'
name|'call'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Run command with arguments.  Wait for command to complete, then\n    return the returncode attribute.\n\n    The arguments are the same as for the Popen constructor.  Example:\n\n    retcode = call(["ls", "-l"])\n    """'
newline|'\n'
name|'return'
name|'Popen'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|list2cmdline
dedent|''
name|'def'
name|'list2cmdline'
op|'('
name|'seq'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Translate a sequence of arguments into a command line\n    string, using the same rules as the MS C runtime:\n\n    1) Arguments are delimited by white space, which is either a\n       space or a tab.\n\n    2) A string surrounded by double quotation marks is\n       interpreted as a single argument, regardless of white space\n       contained within.  A quoted string can be embedded in an\n       argument.\n\n    3) A double quotation mark preceded by a backslash is\n       interpreted as a literal double quotation mark.\n\n    4) Backslashes are interpreted literally, unless they\n       immediately precede a double quotation mark.\n\n    5) If backslashes immediately precede a double quotation mark,\n       every pair of backslashes is interpreted as a literal\n       backslash.  If the number of backslashes is odd, the last\n       backslash escapes the next double quotation mark as\n       described in rule 3.\n    """'
newline|'\n'
nl|'\n'
comment|'# See'
nl|'\n'
comment|'# http://msdn.microsoft.com/library/en-us/vccelng/htm/progs_12.asp'
nl|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'needquote'
op|'='
name|'False'
newline|'\n'
name|'for'
name|'arg'
name|'in'
name|'seq'
op|':'
newline|'\n'
indent|'        '
name|'bs_buf'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# Add a space to separate this argument from the others'
nl|'\n'
name|'if'
name|'result'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'append'
op|'('
string|"' '"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'needquote'
op|'='
op|'('
string|'" "'
name|'in'
name|'arg'
op|')'
name|'or'
op|'('
string|'"\\t"'
name|'in'
name|'arg'
op|')'
newline|'\n'
name|'if'
name|'needquote'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'append'
op|'('
string|'\'"\''
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'c'
name|'in'
name|'arg'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'c'
op|'=='
string|"'\\\\'"
op|':'
newline|'\n'
comment|"# Don't know if we need to double yet."
nl|'\n'
indent|'                '
name|'bs_buf'
op|'.'
name|'append'
op|'('
name|'c'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'c'
op|'=='
string|'\'"\''
op|':'
newline|'\n'
comment|'# Double backspaces.'
nl|'\n'
indent|'                '
name|'result'
op|'.'
name|'append'
op|'('
string|"'\\\\'"
op|'*'
name|'len'
op|'('
name|'bs_buf'
op|')'
op|'*'
number|'2'
op|')'
newline|'\n'
name|'bs_buf'
op|'='
op|'['
op|']'
newline|'\n'
name|'result'
op|'.'
name|'append'
op|'('
string|'\'\\\\"\''
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Normal char'
nl|'\n'
indent|'                '
name|'if'
name|'bs_buf'
op|':'
newline|'\n'
indent|'                    '
name|'result'
op|'.'
name|'extend'
op|'('
name|'bs_buf'
op|')'
newline|'\n'
name|'bs_buf'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'result'
op|'.'
name|'append'
op|'('
name|'c'
op|')'
newline|'\n'
nl|'\n'
comment|'# Add remaining backspaces, if any.'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'bs_buf'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'extend'
op|'('
name|'bs_buf'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'needquote'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'extend'
op|'('
name|'bs_buf'
op|')'
newline|'\n'
name|'result'
op|'.'
name|'append'
op|'('
string|'\'"\''
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
string|"''"
op|'.'
name|'join'
op|'('
name|'result'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Popen
dedent|''
name|'class'
name|'Popen'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'args'
op|','
name|'bufsize'
op|'='
number|'0'
op|','
name|'executable'
op|'='
name|'None'
op|','
nl|'\n'
name|'stdin'
op|'='
name|'None'
op|','
name|'stdout'
op|'='
name|'None'
op|','
name|'stderr'
op|'='
name|'None'
op|','
nl|'\n'
name|'preexec_fn'
op|'='
name|'None'
op|','
name|'close_fds'
op|'='
name|'False'
op|','
name|'shell'
op|'='
name|'False'
op|','
nl|'\n'
name|'cwd'
op|'='
name|'None'
op|','
name|'env'
op|'='
name|'None'
op|','
name|'universal_newlines'
op|'='
name|'False'
op|','
nl|'\n'
name|'startupinfo'
op|'='
name|'None'
op|','
name|'creationflags'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create new Popen instance."""'
newline|'\n'
name|'_cleanup'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'bufsize'
op|','
op|'('
name|'int'
op|','
name|'long'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"bufsize must be an integer"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'mswindows'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'preexec_fn'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|'('
string|'"preexec_fn is not supported on Windows "'
nl|'\n'
string|'"platforms"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'close_fds'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|'('
string|'"close_fds is not supported on Windows "'
nl|'\n'
string|'"platforms"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# POSIX'
nl|'\n'
indent|'            '
name|'if'
name|'startupinfo'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|'('
string|'"startupinfo is only supported on Windows "'
nl|'\n'
string|'"platforms"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'creationflags'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|'('
string|'"creationflags is only supported on Windows "'
nl|'\n'
string|'"platforms"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'stdin'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'stdout'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'stderr'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'pid'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'returncode'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'universal_newlines'
op|'='
name|'universal_newlines'
newline|'\n'
nl|'\n'
comment|'# Input and output objects. The general principle is like'
nl|'\n'
comment|'# this:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Parent                   Child'
nl|'\n'
comment|'# ------                   -----'
nl|'\n'
comment|'# p2cwrite   ---stdin--->  p2cread'
nl|'\n'
comment|'# c2pread    <--stdout---  c2pwrite'
nl|'\n'
comment|'# errread    <--stderr---  errwrite'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# On POSIX, the child objects are file descriptors.  On'
nl|'\n'
comment|'# Windows, these are Windows file handles.  The parent objects'
nl|'\n'
comment|'# are file descriptors on both platforms.  The parent objects'
nl|'\n'
comment|'# are None when not using PIPEs. The child objects are None'
nl|'\n'
comment|'# when not redirecting.'
nl|'\n'
nl|'\n'
op|'('
name|'p2cread'
op|','
name|'p2cwrite'
op|','
nl|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|','
nl|'\n'
name|'errread'
op|','
name|'errwrite'
op|')'
op|'='
name|'self'
op|'.'
name|'_get_handles'
op|'('
name|'stdin'
op|','
name|'stdout'
op|','
name|'stderr'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_execute_child'
op|'('
name|'args'
op|','
name|'executable'
op|','
name|'preexec_fn'
op|','
name|'close_fds'
op|','
nl|'\n'
name|'cwd'
op|','
name|'env'
op|','
name|'universal_newlines'
op|','
nl|'\n'
name|'startupinfo'
op|','
name|'creationflags'
op|','
name|'shell'
op|','
nl|'\n'
name|'p2cread'
op|','
name|'p2cwrite'
op|','
nl|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|','
nl|'\n'
name|'errread'
op|','
name|'errwrite'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'p2cwrite'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'stdin'
op|'='
name|'os'
op|'.'
name|'fdopen'
op|'('
name|'p2cwrite'
op|','
string|"'wb'"
op|','
name|'bufsize'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'c2pread'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'universal_newlines'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'stdout'
op|'='
name|'os'
op|'.'
name|'fdopen'
op|'('
name|'c2pread'
op|','
string|"'rU'"
op|','
name|'bufsize'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'stdout'
op|'='
name|'os'
op|'.'
name|'fdopen'
op|'('
name|'c2pread'
op|','
string|"'rb'"
op|','
name|'bufsize'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'errread'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'universal_newlines'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'stderr'
op|'='
name|'os'
op|'.'
name|'fdopen'
op|'('
name|'errread'
op|','
string|"'rU'"
op|','
name|'bufsize'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'stderr'
op|'='
name|'os'
op|'.'
name|'fdopen'
op|'('
name|'errread'
op|','
string|"'rb'"
op|','
name|'bufsize'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'_active'
op|'.'
name|'append'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_translate_newlines
dedent|''
name|'def'
name|'_translate_newlines'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'data'
op|'='
name|'data'
op|'.'
name|'replace'
op|'('
string|'"\\r\\n"'
op|','
string|'"\\n"'
op|')'
newline|'\n'
name|'data'
op|'='
name|'data'
op|'.'
name|'replace'
op|'('
string|'"\\r"'
op|','
string|'"\\n"'
op|')'
newline|'\n'
name|'return'
name|'data'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'mswindows'
op|':'
newline|'\n'
comment|'#'
nl|'\n'
comment|'# Windows methods'
nl|'\n'
comment|'#'
nl|'\n'
DECL|function|_get_handles
indent|'        '
name|'def'
name|'_get_handles'
op|'('
name|'self'
op|','
name|'stdin'
op|','
name|'stdout'
op|','
name|'stderr'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Construct and return tupel with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            """'
newline|'\n'
name|'if'
name|'stdin'
op|'=='
name|'None'
name|'and'
name|'stdout'
op|'=='
name|'None'
name|'and'
name|'stderr'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'None'
op|','
name|'None'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'p2cread'
op|','
name|'p2cwrite'
op|'='
name|'None'
op|','
name|'None'
newline|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|'='
name|'None'
op|','
name|'None'
newline|'\n'
name|'errread'
op|','
name|'errwrite'
op|'='
name|'None'
op|','
name|'None'
newline|'\n'
nl|'\n'
name|'if'
name|'stdin'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'p2cread'
op|'='
name|'GetStdHandle'
op|'('
name|'STD_INPUT_HANDLE'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'stdin'
op|'=='
name|'PIPE'
op|':'
newline|'\n'
indent|'                '
name|'p2cread'
op|','
name|'p2cwrite'
op|'='
name|'CreatePipe'
op|'('
name|'None'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# Detach and turn into fd'
nl|'\n'
name|'p2cwrite'
op|'='
name|'p2cwrite'
op|'.'
name|'Detach'
op|'('
op|')'
newline|'\n'
name|'p2cwrite'
op|'='
name|'msvcrt'
op|'.'
name|'open_osfhandle'
op|'('
name|'p2cwrite'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'('
name|'stdin'
op|')'
op|'=='
name|'types'
op|'.'
name|'IntType'
op|':'
newline|'\n'
indent|'                '
name|'p2cread'
op|'='
name|'msvcrt'
op|'.'
name|'get_osfhandle'
op|'('
name|'stdin'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Assuming file-like object'
nl|'\n'
indent|'                '
name|'p2cread'
op|'='
name|'msvcrt'
op|'.'
name|'get_osfhandle'
op|'('
name|'stdin'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'p2cread'
op|'='
name|'self'
op|'.'
name|'_make_inheritable'
op|'('
name|'p2cread'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'stdout'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'c2pwrite'
op|'='
name|'GetStdHandle'
op|'('
name|'STD_OUTPUT_HANDLE'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'stdout'
op|'=='
name|'PIPE'
op|':'
newline|'\n'
indent|'                '
name|'c2pread'
op|','
name|'c2pwrite'
op|'='
name|'CreatePipe'
op|'('
name|'None'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# Detach and turn into fd'
nl|'\n'
name|'c2pread'
op|'='
name|'c2pread'
op|'.'
name|'Detach'
op|'('
op|')'
newline|'\n'
name|'c2pread'
op|'='
name|'msvcrt'
op|'.'
name|'open_osfhandle'
op|'('
name|'c2pread'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'('
name|'stdout'
op|')'
op|'=='
name|'types'
op|'.'
name|'IntType'
op|':'
newline|'\n'
indent|'                '
name|'c2pwrite'
op|'='
name|'msvcrt'
op|'.'
name|'get_osfhandle'
op|'('
name|'stdout'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Assuming file-like object'
nl|'\n'
indent|'                '
name|'c2pwrite'
op|'='
name|'msvcrt'
op|'.'
name|'get_osfhandle'
op|'('
name|'stdout'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'c2pwrite'
op|'='
name|'self'
op|'.'
name|'_make_inheritable'
op|'('
name|'c2pwrite'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'stderr'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'errwrite'
op|'='
name|'GetStdHandle'
op|'('
name|'STD_ERROR_HANDLE'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'stderr'
op|'=='
name|'PIPE'
op|':'
newline|'\n'
indent|'                '
name|'errread'
op|','
name|'errwrite'
op|'='
name|'CreatePipe'
op|'('
name|'None'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# Detach and turn into fd'
nl|'\n'
name|'errread'
op|'='
name|'errread'
op|'.'
name|'Detach'
op|'('
op|')'
newline|'\n'
name|'errread'
op|'='
name|'msvcrt'
op|'.'
name|'open_osfhandle'
op|'('
name|'errread'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'stderr'
op|'=='
name|'STDOUT'
op|':'
newline|'\n'
indent|'                '
name|'errwrite'
op|'='
name|'c2pwrite'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'('
name|'stderr'
op|')'
op|'=='
name|'types'
op|'.'
name|'IntType'
op|':'
newline|'\n'
indent|'                '
name|'errwrite'
op|'='
name|'msvcrt'
op|'.'
name|'get_osfhandle'
op|'('
name|'stderr'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Assuming file-like object'
nl|'\n'
indent|'                '
name|'errwrite'
op|'='
name|'msvcrt'
op|'.'
name|'get_osfhandle'
op|'('
name|'stderr'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'errwrite'
op|'='
name|'self'
op|'.'
name|'_make_inheritable'
op|'('
name|'errwrite'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'('
name|'p2cread'
op|','
name|'p2cwrite'
op|','
nl|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|','
nl|'\n'
name|'errread'
op|','
name|'errwrite'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_make_inheritable
dedent|''
name|'def'
name|'_make_inheritable'
op|'('
name|'self'
op|','
name|'handle'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Return a duplicate of handle, which is inheritable"""'
newline|'\n'
name|'return'
name|'DuplicateHandle'
op|'('
name|'GetCurrentProcess'
op|'('
op|')'
op|','
name|'handle'
op|','
nl|'\n'
name|'GetCurrentProcess'
op|'('
op|')'
op|','
number|'0'
op|','
number|'1'
op|','
nl|'\n'
name|'DUPLICATE_SAME_ACCESS'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_w9xpopen
dedent|''
name|'def'
name|'_find_w9xpopen'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Find and return absolut path to w9xpopen.exe"""'
newline|'\n'
name|'w9xpopen'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'GetModuleFileName'
op|'('
number|'0'
op|')'
op|')'
op|','
nl|'\n'
string|'"w9xpopen.exe"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'w9xpopen'
op|')'
op|':'
newline|'\n'
comment|'# Eeek - file-not-found - possibly an embedding'
nl|'\n'
comment|'# situation - see if we can locate it in sys.exec_prefix'
nl|'\n'
indent|'                '
name|'w9xpopen'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'sys'
op|'.'
name|'exec_prefix'
op|')'
op|','
nl|'\n'
string|'"w9xpopen.exe"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'w9xpopen'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'RuntimeError'
op|'('
string|'"Cannot locate w9xpopen.exe, which is "'
nl|'\n'
string|'"needed for Popen to work with your "'
nl|'\n'
string|'"shell or platform."'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'w9xpopen'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_execute_child
dedent|''
name|'def'
name|'_execute_child'
op|'('
name|'self'
op|','
name|'args'
op|','
name|'executable'
op|','
name|'preexec_fn'
op|','
name|'close_fds'
op|','
nl|'\n'
name|'cwd'
op|','
name|'env'
op|','
name|'universal_newlines'
op|','
nl|'\n'
name|'startupinfo'
op|','
name|'creationflags'
op|','
name|'shell'
op|','
nl|'\n'
name|'p2cread'
op|','
name|'p2cwrite'
op|','
nl|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|','
nl|'\n'
name|'errread'
op|','
name|'errwrite'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Execute program (MS Windows version)"""'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'args'
op|','
name|'types'
op|'.'
name|'StringTypes'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'args'
op|'='
name|'list2cmdline'
op|'('
name|'args'
op|')'
newline|'\n'
nl|'\n'
comment|'# Process startup details'
nl|'\n'
dedent|''
name|'default_startupinfo'
op|'='
name|'STARTUPINFO'
op|'('
op|')'
newline|'\n'
name|'if'
name|'startupinfo'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'startupinfo'
op|'='
name|'default_startupinfo'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'None'
name|'in'
op|'('
name|'p2cread'
op|','
name|'c2pwrite'
op|','
name|'errwrite'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'startupinfo'
op|'.'
name|'dwFlags'
op|'|='
name|'STARTF_USESTDHANDLES'
newline|'\n'
name|'startupinfo'
op|'.'
name|'hStdInput'
op|'='
name|'p2cread'
newline|'\n'
name|'startupinfo'
op|'.'
name|'hStdOutput'
op|'='
name|'c2pwrite'
newline|'\n'
name|'startupinfo'
op|'.'
name|'hStdError'
op|'='
name|'errwrite'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'shell'
op|':'
newline|'\n'
indent|'                '
name|'default_startupinfo'
op|'.'
name|'dwFlags'
op|'|='
name|'STARTF_USESHOWWINDOW'
newline|'\n'
name|'default_startupinfo'
op|'.'
name|'wShowWindow'
op|'='
name|'SW_HIDE'
newline|'\n'
name|'comspec'
op|'='
name|'os'
op|'.'
name|'environ'
op|'.'
name|'get'
op|'('
string|'"COMSPEC"'
op|','
string|'"cmd.exe"'
op|')'
newline|'\n'
name|'args'
op|'='
name|'comspec'
op|'+'
string|'" /c "'
op|'+'
name|'args'
newline|'\n'
name|'if'
op|'('
name|'GetVersion'
op|'('
op|')'
op|'>='
number|'0x80000000L'
name|'or'
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'comspec'
op|')'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|'"command.com"'
op|')'
op|':'
newline|'\n'
comment|'# Win9x, or using command.com on NT. We need to'
nl|'\n'
comment|'# use the w9xpopen intermediate program. For more'
nl|'\n'
comment|'# information, see KB Q150956'
nl|'\n'
comment|'# (http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp)'
nl|'\n'
indent|'                    '
name|'w9xpopen'
op|'='
name|'self'
op|'.'
name|'_find_w9xpopen'
op|'('
op|')'
newline|'\n'
name|'args'
op|'='
string|'\'"%s" %s\''
op|'%'
op|'('
name|'w9xpopen'
op|','
name|'args'
op|')'
newline|'\n'
comment|'# Not passing CREATE_NEW_CONSOLE has been known to'
nl|'\n'
comment|'# cause random failures on win9x.  Specifically a'
nl|'\n'
comment|'# dialog: "Your program accessed mem currently in'
nl|'\n'
comment|'# use at xxx" and a hopeful warning about the'
nl|'\n'
comment|'# stability of your system.  Cost is Ctrl+C wont'
nl|'\n'
comment|'# kill children.'
nl|'\n'
name|'creationflags'
op|'|='
name|'CREATE_NEW_CONSOLE'
newline|'\n'
nl|'\n'
comment|'# Start the process'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'hp'
op|','
name|'ht'
op|','
name|'pid'
op|','
name|'tid'
op|'='
name|'CreateProcess'
op|'('
name|'executable'
op|','
name|'args'
op|','
nl|'\n'
comment|'# no special security'
nl|'\n'
name|'None'
op|','
name|'None'
op|','
nl|'\n'
comment|'# must inherit handles to pass std'
nl|'\n'
comment|'# handles'
nl|'\n'
number|'1'
op|','
nl|'\n'
name|'creationflags'
op|','
nl|'\n'
name|'env'
op|','
nl|'\n'
name|'cwd'
op|','
nl|'\n'
name|'startupinfo'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'pywintypes'
op|'.'
name|'error'
op|','
name|'e'
op|':'
newline|'\n'
comment|'# Translate pywintypes.error to WindowsError, which is'
nl|'\n'
comment|'# a subclass of OSError.  FIXME: We should really'
nl|'\n'
comment|'# translate errno using _sys_errlist (or simliar), but'
nl|'\n'
comment|'# how can this be done from Python?'
nl|'\n'
indent|'                '
name|'raise'
name|'WindowsError'
op|'('
op|'*'
name|'e'
op|'.'
name|'args'
op|')'
newline|'\n'
nl|'\n'
comment|'# Retain the process handle, but close the thread handle'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_handle'
op|'='
name|'hp'
newline|'\n'
name|'self'
op|'.'
name|'pid'
op|'='
name|'pid'
newline|'\n'
name|'ht'
op|'.'
name|'Close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|"# Child is launched. Close the parent's copy of those pipe"
nl|'\n'
comment|'# handles that only the child should have open.  You need'
nl|'\n'
comment|'# to make sure that no handles to the write end of the'
nl|'\n'
comment|'# output pipe are maintained in this process or else the'
nl|'\n'
comment|'# pipe will not close when the child process exits and the'
nl|'\n'
comment|'# ReadFile will hang.'
nl|'\n'
name|'if'
name|'p2cread'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'p2cread'
op|'.'
name|'Close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'c2pwrite'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'c2pwrite'
op|'.'
name|'Close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'errwrite'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'errwrite'
op|'.'
name|'Close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|poll
dedent|''
dedent|''
name|'def'
name|'poll'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Check if child process has terminated.  Returns returncode\n            attribute."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'returncode'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'WaitForSingleObject'
op|'('
name|'self'
op|'.'
name|'_handle'
op|','
number|'0'
op|')'
op|'=='
name|'WAIT_OBJECT_0'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'returncode'
op|'='
name|'GetExitCodeProcess'
op|'('
name|'self'
op|'.'
name|'_handle'
op|')'
newline|'\n'
name|'_active'
op|'.'
name|'remove'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'returncode'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|wait
dedent|''
name|'def'
name|'wait'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Wait for child process to terminate.  Returns returncode\n            attribute."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'returncode'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'obj'
op|'='
name|'WaitForSingleObject'
op|'('
name|'self'
op|'.'
name|'_handle'
op|','
name|'INFINITE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'returncode'
op|'='
name|'GetExitCodeProcess'
op|'('
name|'self'
op|'.'
name|'_handle'
op|')'
newline|'\n'
name|'_active'
op|'.'
name|'remove'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'returncode'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_readerthread
dedent|''
name|'def'
name|'_readerthread'
op|'('
name|'self'
op|','
name|'fh'
op|','
name|'buffer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'buffer'
op|'.'
name|'append'
op|'('
name|'fh'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|communicate
dedent|''
name|'def'
name|'communicate'
op|'('
name|'self'
op|','
name|'input'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Interact with process: Send data to stdin.  Read data from\n            stdout and stderr, until end-of-file is reached.  Wait for\n            process to terminate.  The optional input argument should be a\n            string to be sent to the child process, or None, if no data\n            should be sent to the child.\n\n            communicate() returns a tuple (stdout, stderr)."""'
newline|'\n'
name|'stdout'
op|'='
name|'None'
comment|'# Return'
newline|'\n'
name|'stderr'
op|'='
name|'None'
comment|'# Return'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'stdout'
op|':'
newline|'\n'
indent|'                '
name|'stdout'
op|'='
op|'['
op|']'
newline|'\n'
name|'stdout_thread'
op|'='
name|'threading'
op|'.'
name|'Thread'
op|'('
name|'target'
op|'='
name|'self'
op|'.'
name|'_readerthread'
op|','
nl|'\n'
name|'args'
op|'='
op|'('
name|'self'
op|'.'
name|'stdout'
op|','
name|'stdout'
op|')'
op|')'
newline|'\n'
name|'stdout_thread'
op|'.'
name|'setDaemon'
op|'('
name|'True'
op|')'
newline|'\n'
name|'stdout_thread'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'stderr'
op|':'
newline|'\n'
indent|'                '
name|'stderr'
op|'='
op|'['
op|']'
newline|'\n'
name|'stderr_thread'
op|'='
name|'threading'
op|'.'
name|'Thread'
op|'('
name|'target'
op|'='
name|'self'
op|'.'
name|'_readerthread'
op|','
nl|'\n'
name|'args'
op|'='
op|'('
name|'self'
op|'.'
name|'stderr'
op|','
name|'stderr'
op|')'
op|')'
newline|'\n'
name|'stderr_thread'
op|'.'
name|'setDaemon'
op|'('
name|'True'
op|')'
newline|'\n'
name|'stderr_thread'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'stdin'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'input'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'stdin'
op|'.'
name|'write'
op|'('
name|'input'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'stdin'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'stdout'
op|':'
newline|'\n'
indent|'                '
name|'stdout_thread'
op|'.'
name|'join'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'stderr'
op|':'
newline|'\n'
indent|'                '
name|'stderr_thread'
op|'.'
name|'join'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# All data exchanged.  Translate lists into strings.'
nl|'\n'
dedent|''
name|'if'
name|'stdout'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'stdout'
op|'='
name|'stdout'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'stderr'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'stderr'
op|'='
name|'stderr'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# Translate newlines, if requested.  We cannot let the file'
nl|'\n'
comment|'# object do the translation: It is based on stdio, which is'
nl|'\n'
comment|'# impossible to combine with select (unless forcing no'
nl|'\n'
comment|'# buffering).'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'universal_newlines'
name|'and'
name|'hasattr'
op|'('
name|'open'
op|','
string|"'newlines'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'stdout'
op|':'
newline|'\n'
indent|'                    '
name|'stdout'
op|'='
name|'self'
op|'.'
name|'_translate_newlines'
op|'('
name|'stdout'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'stderr'
op|':'
newline|'\n'
indent|'                    '
name|'stderr'
op|'='
name|'self'
op|'.'
name|'_translate_newlines'
op|'('
name|'stderr'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'return'
op|'('
name|'stdout'
op|','
name|'stderr'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'#'
nl|'\n'
comment|'# POSIX methods'
nl|'\n'
comment|'#'
nl|'\n'
DECL|function|_get_handles
indent|'        '
name|'def'
name|'_get_handles'
op|'('
name|'self'
op|','
name|'stdin'
op|','
name|'stdout'
op|','
name|'stderr'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Construct and return tupel with IO objects:\n            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite\n            """'
newline|'\n'
name|'p2cread'
op|','
name|'p2cwrite'
op|'='
name|'None'
op|','
name|'None'
newline|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|'='
name|'None'
op|','
name|'None'
newline|'\n'
name|'errread'
op|','
name|'errwrite'
op|'='
name|'None'
op|','
name|'None'
newline|'\n'
nl|'\n'
name|'if'
name|'stdin'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'elif'
name|'stdin'
op|'=='
name|'PIPE'
op|':'
newline|'\n'
indent|'                '
name|'p2cread'
op|','
name|'p2cwrite'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'('
name|'stdin'
op|')'
op|'=='
name|'types'
op|'.'
name|'IntType'
op|':'
newline|'\n'
indent|'                '
name|'p2cread'
op|'='
name|'stdin'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Assuming file-like object'
nl|'\n'
indent|'                '
name|'p2cread'
op|'='
name|'stdin'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'stdout'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'elif'
name|'stdout'
op|'=='
name|'PIPE'
op|':'
newline|'\n'
indent|'                '
name|'c2pread'
op|','
name|'c2pwrite'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'('
name|'stdout'
op|')'
op|'=='
name|'types'
op|'.'
name|'IntType'
op|':'
newline|'\n'
indent|'                '
name|'c2pwrite'
op|'='
name|'stdout'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Assuming file-like object'
nl|'\n'
indent|'                '
name|'c2pwrite'
op|'='
name|'stdout'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'stderr'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'elif'
name|'stderr'
op|'=='
name|'PIPE'
op|':'
newline|'\n'
indent|'                '
name|'errread'
op|','
name|'errwrite'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'stderr'
op|'=='
name|'STDOUT'
op|':'
newline|'\n'
indent|'                '
name|'errwrite'
op|'='
name|'c2pwrite'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'('
name|'stderr'
op|')'
op|'=='
name|'types'
op|'.'
name|'IntType'
op|':'
newline|'\n'
indent|'                '
name|'errwrite'
op|'='
name|'stderr'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Assuming file-like object'
nl|'\n'
indent|'                '
name|'errwrite'
op|'='
name|'stderr'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
op|'('
name|'p2cread'
op|','
name|'p2cwrite'
op|','
nl|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|','
nl|'\n'
name|'errread'
op|','
name|'errwrite'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_set_cloexec_flag
dedent|''
name|'def'
name|'_set_cloexec_flag'
op|'('
name|'self'
op|','
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'cloexec_flag'
op|'='
name|'fcntl'
op|'.'
name|'FD_CLOEXEC'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'                '
name|'cloexec_flag'
op|'='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'old'
op|'='
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'fd'
op|','
name|'fcntl'
op|'.'
name|'F_GETFD'
op|')'
newline|'\n'
name|'fcntl'
op|'.'
name|'fcntl'
op|'('
name|'fd'
op|','
name|'fcntl'
op|'.'
name|'F_SETFD'
op|','
name|'old'
op|'|'
name|'cloexec_flag'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_close_fds
dedent|''
name|'def'
name|'_close_fds'
op|'('
name|'self'
op|','
name|'but'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'3'
op|','
name|'MAXFD'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'i'
op|'=='
name|'but'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'close'
op|'('
name|'i'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_execute_child
dedent|''
dedent|''
dedent|''
name|'def'
name|'_execute_child'
op|'('
name|'self'
op|','
name|'args'
op|','
name|'executable'
op|','
name|'preexec_fn'
op|','
name|'close_fds'
op|','
nl|'\n'
name|'cwd'
op|','
name|'env'
op|','
name|'universal_newlines'
op|','
nl|'\n'
name|'startupinfo'
op|','
name|'creationflags'
op|','
name|'shell'
op|','
nl|'\n'
name|'p2cread'
op|','
name|'p2cwrite'
op|','
nl|'\n'
name|'c2pread'
op|','
name|'c2pwrite'
op|','
nl|'\n'
name|'errread'
op|','
name|'errwrite'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Execute program (POSIX version)"""'
newline|'\n'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'args'
op|','
name|'types'
op|'.'
name|'StringTypes'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'args'
op|'='
op|'['
name|'args'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'shell'
op|':'
newline|'\n'
indent|'                '
name|'args'
op|'='
op|'['
string|'"/bin/sh"'
op|','
string|'"-c"'
op|']'
op|'+'
name|'args'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'executable'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'executable'
op|'='
name|'args'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# For transferring possible exec failure from child to parent'
nl|'\n'
comment|'# The first char specifies the exception type: 0 means'
nl|'\n'
comment|'# OSError, 1 means some other error.'
nl|'\n'
dedent|''
name|'errpipe_read'
op|','
name|'errpipe_write'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_set_cloexec_flag'
op|'('
name|'errpipe_write'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'pid'
op|'='
name|'os'
op|'.'
name|'fork'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'pid'
op|'=='
number|'0'
op|':'
newline|'\n'
comment|'# Child'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
comment|"# Close parent's pipe ends"
nl|'\n'
indent|'                    '
name|'if'
name|'p2cwrite'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'close'
op|'('
name|'p2cwrite'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'c2pread'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'close'
op|'('
name|'c2pread'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'errread'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'close'
op|'('
name|'errread'
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'close'
op|'('
name|'errpipe_read'
op|')'
newline|'\n'
nl|'\n'
comment|'# Dup fds for child'
nl|'\n'
name|'if'
name|'p2cread'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'dup2'
op|'('
name|'p2cread'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'c2pwrite'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'dup2'
op|'('
name|'c2pwrite'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'errwrite'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'dup2'
op|'('
name|'errwrite'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
comment|"# Close pipe fds.  Make sure we doesn't close the same"
nl|'\n'
comment|'# fd more than once.'
nl|'\n'
dedent|''
name|'if'
name|'p2cread'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'close'
op|'('
name|'p2cread'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'c2pwrite'
name|'and'
name|'c2pwrite'
name|'not'
name|'in'
op|'('
name|'p2cread'
op|','
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'close'
op|'('
name|'c2pwrite'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'errwrite'
name|'and'
name|'errwrite'
name|'not'
name|'in'
op|'('
name|'p2cread'
op|','
name|'c2pwrite'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'close'
op|'('
name|'errwrite'
op|')'
newline|'\n'
nl|'\n'
comment|'# Close all other fds, if asked for'
nl|'\n'
dedent|''
name|'if'
name|'close_fds'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_close_fds'
op|'('
name|'but'
op|'='
name|'errpipe_write'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'cwd'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'chdir'
op|'('
name|'cwd'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'preexec_fn'
op|':'
newline|'\n'
indent|'                        '
name|'apply'
op|'('
name|'preexec_fn'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'env'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'execvp'
op|'('
name|'executable'
op|','
name|'args'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'os'
op|'.'
name|'execvpe'
op|'('
name|'executable'
op|','
name|'args'
op|','
name|'env'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                    '
name|'exc_type'
op|','
name|'exc_value'
op|','
name|'tb'
op|'='
name|'sys'
op|'.'
name|'exc_info'
op|'('
op|')'
newline|'\n'
comment|'# Save the traceback and attach it to the exception object'
nl|'\n'
name|'exc_lines'
op|'='
name|'traceback'
op|'.'
name|'format_exception'
op|'('
name|'exc_type'
op|','
nl|'\n'
name|'exc_value'
op|','
nl|'\n'
name|'tb'
op|')'
newline|'\n'
name|'exc_value'
op|'.'
name|'child_traceback'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'exc_lines'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'write'
op|'('
name|'errpipe_write'
op|','
name|'pickle'
op|'.'
name|'dumps'
op|'('
name|'exc_value'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|"# This exitcode won't be reported to applications, so it"
nl|'\n'
comment|"# really doesn't matter what we return."
nl|'\n'
dedent|''
name|'os'
op|'.'
name|'_exit'
op|'('
number|'255'
op|')'
newline|'\n'
nl|'\n'
comment|'# Parent'
nl|'\n'
dedent|''
name|'os'
op|'.'
name|'close'
op|'('
name|'errpipe_write'
op|')'
newline|'\n'
name|'if'
name|'p2cread'
name|'and'
name|'p2cwrite'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'p2cread'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'c2pwrite'
name|'and'
name|'c2pread'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'c2pwrite'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'errwrite'
name|'and'
name|'errread'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'errwrite'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for exec to fail or succeed; possibly raising exception'
nl|'\n'
dedent|''
name|'data'
op|'='
name|'os'
op|'.'
name|'read'
op|'('
name|'errpipe_read'
op|','
number|'1048576'
op|')'
comment|'# Exceptions limited to 1 MB'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'errpipe_read'
op|')'
newline|'\n'
name|'if'
name|'data'
op|'!='
string|'""'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'waitpid'
op|'('
name|'self'
op|'.'
name|'pid'
op|','
number|'0'
op|')'
newline|'\n'
name|'child_exception'
op|'='
name|'pickle'
op|'.'
name|'loads'
op|'('
name|'data'
op|')'
newline|'\n'
name|'raise'
name|'child_exception'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_handle_exitstatus
dedent|''
dedent|''
name|'def'
name|'_handle_exitstatus'
op|'('
name|'self'
op|','
name|'sts'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'os'
op|'.'
name|'WIFSIGNALED'
op|'('
name|'sts'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'returncode'
op|'='
op|'-'
name|'os'
op|'.'
name|'WTERMSIG'
op|'('
name|'sts'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'os'
op|'.'
name|'WIFEXITED'
op|'('
name|'sts'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'returncode'
op|'='
name|'os'
op|'.'
name|'WEXITSTATUS'
op|'('
name|'sts'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Should never happen'
nl|'\n'
indent|'                '
name|'raise'
name|'RuntimeError'
op|'('
string|'"Unknown child exit status!"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_active'
op|'.'
name|'remove'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|poll
dedent|''
name|'def'
name|'poll'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Check if child process has terminated.  Returns returncode\n            attribute."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'returncode'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'pid'
op|','
name|'sts'
op|'='
name|'os'
op|'.'
name|'waitpid'
op|'('
name|'self'
op|'.'
name|'pid'
op|','
name|'os'
op|'.'
name|'WNOHANG'
op|')'
newline|'\n'
name|'if'
name|'pid'
op|'=='
name|'self'
op|'.'
name|'pid'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_handle_exitstatus'
op|'('
name|'sts'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'os'
op|'.'
name|'error'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'returncode'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|wait
dedent|''
name|'def'
name|'wait'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Wait for child process to terminate.  Returns returncode\n            attribute."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'returncode'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'pid'
op|','
name|'sts'
op|'='
name|'os'
op|'.'
name|'waitpid'
op|'('
name|'self'
op|'.'
name|'pid'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_handle_exitstatus'
op|'('
name|'sts'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'returncode'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|communicate
dedent|''
name|'def'
name|'communicate'
op|'('
name|'self'
op|','
name|'input'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Interact with process: Send data to stdin.  Read data from\n            stdout and stderr, until end-of-file is reached.  Wait for\n            process to terminate.  The optional input argument should be a\n            string to be sent to the child process, or None, if no data\n            should be sent to the child.\n\n            communicate() returns a tuple (stdout, stderr)."""'
newline|'\n'
name|'read_set'
op|'='
op|'['
op|']'
newline|'\n'
name|'write_set'
op|'='
op|'['
op|']'
newline|'\n'
name|'stdout'
op|'='
name|'None'
comment|'# Return'
newline|'\n'
name|'stderr'
op|'='
name|'None'
comment|'# Return'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'stdin'
op|':'
newline|'\n'
comment|'# Flush stdio buffer.  This might block, if the user has'
nl|'\n'
comment|'# been writing to .stdin in an uncontrolled fashion.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'stdin'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
name|'if'
name|'input'
op|':'
newline|'\n'
indent|'                    '
name|'write_set'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'stdin'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'stdin'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'stdout'
op|':'
newline|'\n'
indent|'                '
name|'read_set'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'stdout'
op|')'
newline|'\n'
name|'stdout'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'stderr'
op|':'
newline|'\n'
indent|'                '
name|'read_set'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'stderr'
op|')'
newline|'\n'
name|'stderr'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'read_set'
name|'or'
name|'write_set'
op|':'
newline|'\n'
indent|'                '
name|'rlist'
op|','
name|'wlist'
op|','
name|'xlist'
op|'='
name|'select'
op|'.'
name|'select'
op|'('
name|'read_set'
op|','
name|'write_set'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'stdin'
name|'in'
name|'wlist'
op|':'
newline|'\n'
comment|'# When select has indicated that the file is writable,'
nl|'\n'
comment|'# we can write up to PIPE_BUF bytes without risk'
nl|'\n'
comment|'# blocking.  POSIX defines PIPE_BUF >= 512'
nl|'\n'
indent|'                    '
name|'bytes_written'
op|'='
name|'os'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'stdin'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'input'
op|'['
op|':'
number|'512'
op|']'
op|')'
newline|'\n'
name|'input'
op|'='
name|'input'
op|'['
name|'bytes_written'
op|':'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'input'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'stdin'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'write_set'
op|'.'
name|'remove'
op|'('
name|'self'
op|'.'
name|'stdin'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'stdout'
name|'in'
name|'rlist'
op|':'
newline|'\n'
indent|'                    '
name|'data'
op|'='
name|'os'
op|'.'
name|'read'
op|'('
name|'self'
op|'.'
name|'stdout'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
number|'1024'
op|')'
newline|'\n'
name|'if'
name|'data'
op|'=='
string|'""'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'stdout'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'read_set'
op|'.'
name|'remove'
op|'('
name|'self'
op|'.'
name|'stdout'
op|')'
newline|'\n'
dedent|''
name|'stdout'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'stderr'
name|'in'
name|'rlist'
op|':'
newline|'\n'
indent|'                    '
name|'data'
op|'='
name|'os'
op|'.'
name|'read'
op|'('
name|'self'
op|'.'
name|'stderr'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
number|'1024'
op|')'
newline|'\n'
name|'if'
name|'data'
op|'=='
string|'""'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'stderr'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'read_set'
op|'.'
name|'remove'
op|'('
name|'self'
op|'.'
name|'stderr'
op|')'
newline|'\n'
dedent|''
name|'stderr'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
comment|'# All data exchanged.  Translate lists into strings.'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'stdout'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'stdout'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'stdout'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'stderr'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'stderr'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'stderr'
op|')'
newline|'\n'
nl|'\n'
comment|'# Translate newlines, if requested.  We cannot let the file'
nl|'\n'
comment|'# object do the translation: It is based on stdio, which is'
nl|'\n'
comment|'# impossible to combine with select (unless forcing no'
nl|'\n'
comment|'# buffering).'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'universal_newlines'
name|'and'
name|'hasattr'
op|'('
name|'open'
op|','
string|"'newlines'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'stdout'
op|':'
newline|'\n'
indent|'                    '
name|'stdout'
op|'='
name|'self'
op|'.'
name|'_translate_newlines'
op|'('
name|'stdout'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'stderr'
op|':'
newline|'\n'
indent|'                    '
name|'stderr'
op|'='
name|'self'
op|'.'
name|'_translate_newlines'
op|'('
name|'stderr'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'return'
op|'('
name|'stdout'
op|','
name|'stderr'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_demo_posix
dedent|''
dedent|''
dedent|''
name|'def'
name|'_demo_posix'
op|'('
op|')'
op|':'
newline|'\n'
comment|'#'
nl|'\n'
comment|'# Example 1: Simple redirection: Get process list'
nl|'\n'
comment|'#'
nl|'\n'
indent|'    '
name|'plist'
op|'='
name|'Popen'
op|'('
op|'['
string|'"ps"'
op|']'
op|','
name|'stdout'
op|'='
name|'PIPE'
op|')'
op|'.'
name|'communicate'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'print'
string|'"Process list:"'
newline|'\n'
name|'print'
name|'plist'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Example 2: Change uid before executing child'
nl|'\n'
comment|'#'
nl|'\n'
name|'if'
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'p'
op|'='
name|'Popen'
op|'('
op|'['
string|'"id"'
op|']'
op|','
name|'preexec_fn'
op|'='
name|'lambda'
op|':'
name|'os'
op|'.'
name|'setuid'
op|'('
number|'100'
op|')'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Example 3: Connecting several subprocesses'
nl|'\n'
comment|'#'
nl|'\n'
dedent|''
name|'print'
string|'"Looking for \'hda\'..."'
newline|'\n'
name|'p1'
op|'='
name|'Popen'
op|'('
op|'['
string|'"dmesg"'
op|']'
op|','
name|'stdout'
op|'='
name|'PIPE'
op|')'
newline|'\n'
name|'p2'
op|'='
name|'Popen'
op|'('
op|'['
string|'"grep"'
op|','
string|'"hda"'
op|']'
op|','
name|'stdin'
op|'='
name|'p1'
op|'.'
name|'stdout'
op|','
name|'stdout'
op|'='
name|'PIPE'
op|')'
newline|'\n'
name|'print'
name|'repr'
op|'('
name|'p2'
op|'.'
name|'communicate'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Example 4: Catch execution error'
nl|'\n'
comment|'#'
nl|'\n'
name|'print'
newline|'\n'
name|'print'
string|'"Trying a weird file..."'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'print'
name|'Popen'
op|'('
op|'['
string|'"/this/path/does/not/exist"'
op|']'
op|')'
op|'.'
name|'communicate'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'            '
name|'print'
string|'"The file didn\'t exist.  I thought so..."'
newline|'\n'
name|'print'
string|'"Child traceback:"'
newline|'\n'
name|'print'
name|'e'
op|'.'
name|'child_traceback'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'print'
string|'"Error"'
op|','
name|'e'
op|'.'
name|'errno'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
string|'"Gosh.  No error."'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_demo_windows
dedent|''
dedent|''
name|'def'
name|'_demo_windows'
op|'('
op|')'
op|':'
newline|'\n'
comment|'#'
nl|'\n'
comment|'# Example 1: Connecting several subprocesses'
nl|'\n'
comment|'#'
nl|'\n'
indent|'    '
name|'print'
string|'"Looking for \'PROMPT\' in set output..."'
newline|'\n'
name|'p1'
op|'='
name|'Popen'
op|'('
string|'"set"'
op|','
name|'stdout'
op|'='
name|'PIPE'
op|','
name|'shell'
op|'='
name|'True'
op|')'
newline|'\n'
name|'p2'
op|'='
name|'Popen'
op|'('
string|'\'find "PROMPT"\''
op|','
name|'stdin'
op|'='
name|'p1'
op|'.'
name|'stdout'
op|','
name|'stdout'
op|'='
name|'PIPE'
op|')'
newline|'\n'
name|'print'
name|'repr'
op|'('
name|'p2'
op|'.'
name|'communicate'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Example 2: Simple execution of program'
nl|'\n'
comment|'#'
nl|'\n'
name|'print'
string|'"Executing calc..."'
newline|'\n'
name|'p'
op|'='
name|'Popen'
op|'('
string|'"calc"'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'__name__'
op|'=='
string|'"__main__"'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'mswindows'
op|':'
newline|'\n'
indent|'        '
name|'_demo_windows'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'_demo_posix'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
