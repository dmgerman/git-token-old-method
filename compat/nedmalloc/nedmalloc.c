begin_unit
begin_comment
comment|/* Alternative malloc implementation for multiple threads without lock contention based on dlmalloc. (C) 2005-2006 Niall Douglas  Boost Software License - Version 1.0 - August 17th, 2003  Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:  The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef
begin_comment
comment|/* Enable full aliasing on MSVC */
end_comment
begin_comment
comment|/*#pragma optimize("a", on)*/
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*#define FULLSANITYCHECKS*/
end_comment
begin_include
include|#
directive|include
file|"nedmalloc.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if
begin_include
include|#
directive|include
file|<malloc.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|MSPACES
define|#
directive|define
name|MSPACES
value|1
end_define
begin_define
DECL|macro|ONLY_MSPACES
define|#
directive|define
name|ONLY_MSPACES
value|1
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|USE_LOCKS
end_ifndef
begin_define
DECL|macro|USE_LOCKS
define|#
directive|define
name|USE_LOCKS
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|FOOTERS
define|#
directive|define
name|FOOTERS
value|1
end_define
begin_comment
DECL|macro|FOOTERS
comment|/* Need to enable footers so frees lock the right mspace */
end_comment
begin_undef
DECL|macro|DEBUG
undef|#
directive|undef
name|DEBUG
end_undef
begin_comment
DECL|macro|DEBUG
comment|/* dlmalloc wants DEBUG either 0 or 1 */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_DEBUG
end_ifdef
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|NDEBUG
end_ifdef
begin_comment
comment|/* Disable assert checking on release builds */
end_comment
begin_undef
DECL|macro|DEBUG
undef|#
directive|undef
name|DEBUG
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The default of 64Kb means we spend too much time kernel-side */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_GRANULARITY
end_ifndef
begin_define
DECL|macro|DEFAULT_GRANULARITY
define|#
directive|define
name|DEFAULT_GRANULARITY
value|(1*1024*1024)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*#define USE_SPIN_LOCKS 0*/
end_comment
begin_comment
comment|/*#define FORCEINLINE*/
end_comment
begin_include
include|#
directive|include
file|"malloc.c.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|NDEBUG
end_ifdef
begin_comment
comment|/* Disable assert checking on release builds */
end_comment
begin_undef
DECL|macro|DEBUG
undef|#
directive|undef
name|DEBUG
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The maximum concurrent threads in a pool possible */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MAXTHREADSINPOOL
end_ifndef
begin_define
DECL|macro|MAXTHREADSINPOOL
define|#
directive|define
name|MAXTHREADSINPOOL
value|16
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The maximum number of threadcaches which can be allocated */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|THREADCACHEMAXCACHES
end_ifndef
begin_define
DECL|macro|THREADCACHEMAXCACHES
define|#
directive|define
name|THREADCACHEMAXCACHES
value|256
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The maximum size to be allocated from the thread cache */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|THREADCACHEMAX
end_ifndef
begin_define
DECL|macro|THREADCACHEMAX
define|#
directive|define
name|THREADCACHEMAX
value|8192
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* The number of cache entries for finer grained bins. This is (topbitpos(THREADCACHEMAX)-4)*2 */
end_comment
begin_define
define|#
directive|define
name|THREADCACHEMAXBINS
value|((13-4)*2)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* The number of cache entries. This is (topbitpos(THREADCACHEMAX)-4) */
end_comment
begin_define
DECL|macro|THREADCACHEMAXBINS
define|#
directive|define
name|THREADCACHEMAXBINS
value|(13-4)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Point at which the free space in a thread cache is garbage collected */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|THREADCACHEMAXFREESPACE
end_ifndef
begin_define
DECL|macro|THREADCACHEMAXFREESPACE
define|#
directive|define
name|THREADCACHEMAXFREESPACE
value|(512*1024)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef
begin_define
DECL|macro|TLSVAR
define|#
directive|define
name|TLSVAR
value|DWORD
end_define
begin_define
DECL|macro|TLSALLOC
define|#
directive|define
name|TLSALLOC
parameter_list|(
name|k
parameter_list|)
value|(*(k)=TlsAlloc(), TLS_OUT_OF_INDEXES==*(k))
end_define
begin_define
DECL|macro|TLSFREE
define|#
directive|define
name|TLSFREE
parameter_list|(
name|k
parameter_list|)
value|(!TlsFree(k))
end_define
begin_define
DECL|macro|TLSGET
define|#
directive|define
name|TLSGET
parameter_list|(
name|k
parameter_list|)
value|TlsGetValue(k)
end_define
begin_define
DECL|macro|TLSSET
define|#
directive|define
name|TLSSET
parameter_list|(
name|k
parameter_list|,
name|a
parameter_list|)
value|(!TlsSetValue(k, a))
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef
begin_function
DECL|function|ChkedTlsGetValue
specifier|static
name|LPVOID
name|ChkedTlsGetValue
parameter_list|(
name|DWORD
name|idx
parameter_list|)
block|{
name|LPVOID
name|ret
init|=
name|TlsGetValue
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|S_OK
operator|==
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_undef
DECL|macro|TLSGET
undef|#
directive|undef
name|TLSGET
end_undef
begin_define
DECL|macro|TLSGET
define|#
directive|define
name|TLSGET
parameter_list|(
name|k
parameter_list|)
value|ChkedTlsGetValue(k)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|TLSVAR
define|#
directive|define
name|TLSVAR
value|pthread_key_t
end_define
begin_define
DECL|macro|TLSALLOC
define|#
directive|define
name|TLSALLOC
parameter_list|(
name|k
parameter_list|)
value|pthread_key_create(k, 0)
end_define
begin_define
DECL|macro|TLSFREE
define|#
directive|define
name|TLSFREE
parameter_list|(
name|k
parameter_list|)
value|pthread_key_delete(k)
end_define
begin_define
DECL|macro|TLSGET
define|#
directive|define
name|TLSGET
parameter_list|(
name|k
parameter_list|)
value|pthread_getspecific(k)
end_define
begin_define
DECL|macro|TLSSET
define|#
directive|define
name|TLSSET
parameter_list|(
name|k
parameter_list|,
name|a
parameter_list|)
value|pthread_setspecific(k, a)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* Only enable if testing with valgrind. Causes misoperation */
end_comment
begin_define
define|#
directive|define
name|mspace_malloc
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|malloc(s)
end_define
begin_define
define|#
directive|define
name|mspace_realloc
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
value|realloc(m, s)
end_define
begin_define
define|#
directive|define
name|mspace_calloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|)
value|calloc(n, s)
end_define
begin_define
define|#
directive|define
name|mspace_free
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|)
value|free(m)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_NED_NAMESPACE
argument_list|)
end_if
begin_decl_stmt
name|namespace
name|nedalloc
block|{
else|#
directive|else
extern|extern
literal|"C"
block|{
endif|#
directive|endif
endif|#
directive|endif
name|size_t
name|nedblksize
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
function|THROWSPEC
block|{
if|#
directive|if
literal|0
comment|/* Only enable if testing with valgrind. Causes misoperation */
block|return THREADCACHEMAX;
else|#
directive|else
if|if
condition|(
name|mem
condition|)
block|{
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|cinuse
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this fails, someone tried to free a block twice */
if|if
condition|(
name|cinuse
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|chunksize
argument_list|(
name|p
argument_list|)
operator|-
name|overhead_for
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|void
name|nedsetvalue
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function|THROWSPEC
block|{
name|nedpsetvalue
argument_list|(
literal|0
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|nedmalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpmalloc
argument_list|(
literal|0
argument_list|,
name|size
argument_list|)
return|;
block|}
name|void
modifier|*
name|nedcalloc
parameter_list|(
name|size_t
name|no
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpcalloc
argument_list|(
literal|0
argument_list|,
name|no
argument_list|,
name|size
argument_list|)
return|;
block|}
name|void
modifier|*
name|nedrealloc
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedprealloc
argument_list|(
literal|0
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
return|;
block|}
name|void
name|nedfree
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
function|THROWSPEC
block|{
name|nedpfree
argument_list|(
literal|0
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|nedmemalign
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpmemalign
argument_list|(
literal|0
argument_list|,
name|alignment
argument_list|,
name|bytes
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|NO_MALLINFO
name|struct
name|mallinfo
name|nedmallinfo
parameter_list|(
name|void
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpmallinfo
argument_list|(
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
name|int
name|nedmallopt
parameter_list|(
name|int
name|parno
parameter_list|,
name|int
name|value
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpmallopt
argument_list|(
literal|0
argument_list|,
name|parno
argument_list|,
name|value
argument_list|)
return|;
block|}
name|int
name|nedmalloc_trim
parameter_list|(
name|size_t
name|pad
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpmalloc_trim
argument_list|(
literal|0
argument_list|,
name|pad
argument_list|)
return|;
block|}
name|void
name|nedmalloc_stats
parameter_list|(
name|void
parameter_list|)
function|THROWSPEC
block|{
name|nedpmalloc_stats
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|size_t
name|nedmalloc_footprint
parameter_list|(
name|void
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpmalloc_footprint
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|void
modifier|*
modifier|*
name|nedindependent_calloc
parameter_list|(
name|size_t
name|elemsno
parameter_list|,
name|size_t
name|elemsize
parameter_list|,
name|void
modifier|*
modifier|*
name|chunks
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpindependent_calloc
argument_list|(
literal|0
argument_list|,
name|elemsno
argument_list|,
name|elemsize
argument_list|,
name|chunks
argument_list|)
return|;
block|}
name|void
modifier|*
modifier|*
name|nedindependent_comalloc
parameter_list|(
name|size_t
name|elems
parameter_list|,
name|size_t
modifier|*
name|sizes
parameter_list|,
name|void
modifier|*
modifier|*
name|chunks
parameter_list|)
function|THROWSPEC
block|{
return|return
name|nedpindependent_comalloc
argument_list|(
literal|0
argument_list|,
name|elems
argument_list|,
name|sizes
argument_list|,
name|chunks
argument_list|)
return|;
block|}
struct_decl|struct
name|threadcacheblk_t
struct_decl|;
typedef|typedef
name|struct
name|threadcacheblk_t
name|threadcacheblk
typedef|;
struct|struct
name|threadcacheblk_t
block|{
comment|/* Keep less than 16 bytes on 32 bit systems and 32 bytes on 64 bit systems */
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|unsigned
name|int
name|magic
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|lastUsed
decl_stmt|,
name|size
decl_stmt|;
name|threadcacheblk
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
typedef|typedef
struct|struct
name|threadcache_t
block|{
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|unsigned
name|int
name|magic1
decl_stmt|;
endif|#
directive|endif
name|int
name|mymspace
decl_stmt|;
comment|/* Last mspace entry this thread used */
name|long
name|threadid
decl_stmt|;
name|unsigned
name|int
name|mallocs
decl_stmt|,
name|frees
decl_stmt|,
name|successes
decl_stmt|;
name|size_t
name|freeInCache
decl_stmt|;
comment|/* How much free space is stored in this cache */
name|threadcacheblk
modifier|*
name|bins
index|[
operator|(
name|THREADCACHEMAXBINS
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|unsigned
name|int
name|magic2
decl_stmt|;
endif|#
directive|endif
block|}
name|threadcache
typedef|;
struct|struct
name|nedpool_t
block|{
name|MLOCK_T
name|mutex
decl_stmt|;
name|void
modifier|*
name|uservalue
decl_stmt|;
name|int
name|threads
decl_stmt|;
comment|/* Max entries in m to use */
name|threadcache
modifier|*
name|caches
index|[
name|THREADCACHEMAXCACHES
index|]
decl_stmt|;
name|TLSVAR
name|mycache
decl_stmt|;
comment|/* Thread cache for this thread. 0 for unset, negative for use mspace-1 directly, otherwise is cache-1 */
name|mstate
name|m
index|[
name|MAXTHREADSINPOOL
operator|+
literal|1
index|]
decl_stmt|;
comment|/* mspace entries for this pool */
block|}
struct|;
specifier|static
name|nedpool
name|syspool
decl_stmt|;
specifier|static
name|FORCEINLINE
name|unsigned
name|int
name|size2binidx
parameter_list|(
name|size_t
name|_size
parameter_list|)
function|THROWSPEC
block|{
comment|/* 8=1000	16=10000	20=10100	24=11000	32=100000	48=110000	4096=1000000000000 */
name|unsigned
name|int
name|topbit
decl_stmt|,
name|size
init|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|_size
operator|>>
literal|4
argument_list|)
decl_stmt|;
comment|/* 16=1		20=1	24=1	32=10	48=11	64=100	96=110	128=1000	4096=100000000 */
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|topbit
operator|=
sizeof|sizeof
argument_list|(
name|size
argument_list|)
operator|*
name|__CHAR_BIT__
operator|-
literal|1
operator|-
name|__builtin_clz
argument_list|(
name|size
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1300
block|{
name|unsigned
name|long
name|bsrTopBit
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|bsrTopBit
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|topbit
operator|=
name|bsrTopBit
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
literal|0
block|union { 		unsigned asInt[2]; 		double asDouble; 	}; 	int n;  	asDouble = (double)size + 0.5; 	topbit = (asInt[!FOX_BIGENDIAN]>> 20) - 1023;
else|#
directive|else
block|{
name|unsigned
name|int
name|x
init|=
name|size
decl_stmt|;
name|x
operator|=
name|x
operator||
operator|(
name|x
operator|>>
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator||
operator|(
name|x
operator|>>
literal|2
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator||
operator|(
name|x
operator|>>
literal|4
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator||
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator||
operator|(
name|x
operator|>>
literal|16
operator|)
expr_stmt|;
name|x
operator|=
operator|~
name|x
expr_stmt|;
name|x
operator|=
name|x
operator|-
operator|(
operator|(
name|x
operator|>>
literal|1
operator|)
operator|&
literal|0x55555555
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0x33333333
operator|)
operator|+
operator|(
operator|(
name|x
operator|>>
literal|2
operator|)
operator|&
literal|0x33333333
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|4
operator|)
operator|)
operator|&
literal|0x0F0F0F0F
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|<<
literal|8
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|<<
literal|16
operator|)
expr_stmt|;
name|topbit
operator|=
literal|31
operator|-
operator|(
name|x
operator|>>
literal|24
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|topbit
return|;
block|}
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
specifier|static
name|void
name|tcsanitycheck
parameter_list|(
name|threadcacheblk
modifier|*
modifier|*
name|ptr
parameter_list|)
function|THROWSPEC
block|{
name|assert
argument_list|(
operator|(
name|ptr
index|[
literal|0
index|]
operator|&&
name|ptr
index|[
literal|1
index|]
operator|)
operator|||
operator|(
operator|!
name|ptr
index|[
literal|0
index|]
operator|&&
operator|!
name|ptr
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|&&
name|ptr
index|[
literal|1
index|]
condition|)
block|{
name|assert
argument_list|(
name|nedblksize
argument_list|(
name|ptr
index|[
literal|0
index|]
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nedblksize
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDN"
operator|==
name|ptr
index|[
literal|0
index|]
operator|->
name|magic
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDN"
operator|==
name|ptr
index|[
literal|1
index|]
operator|->
name|magic
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ptr
index|[
literal|0
index|]
operator|->
name|prev
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ptr
index|[
literal|1
index|]
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
name|ptr
index|[
literal|1
index|]
condition|)
block|{
name|assert
argument_list|(
operator|!
name|ptr
index|[
literal|0
index|]
operator|->
name|next
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ptr
index|[
literal|1
index|]
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|tcfullsanitycheck
parameter_list|(
name|threadcache
modifier|*
name|tc
parameter_list|)
function|THROWSPEC
block|{
name|threadcacheblk
modifier|*
modifier|*
name|tcbptr
init|=
name|tc
operator|->
name|bins
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|THREADCACHEMAXBINS
condition|;
name|n
operator|++
operator|,
name|tcbptr
operator|+=
literal|2
control|)
block|{
name|threadcacheblk
modifier|*
name|b
decl_stmt|,
modifier|*
name|ob
init|=
literal|0
decl_stmt|;
name|tcsanitycheck
argument_list|(
name|tcbptr
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|tcbptr
index|[
literal|0
index|]
init|;
name|b
condition|;
name|ob
operator|=
name|b
operator|,
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
name|assert
argument_list|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDN"
operator|==
name|b
operator|->
name|magic
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ob
operator|||
name|ob
operator|->
name|next
operator|==
name|b
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|ob
operator|||
name|b
operator|->
name|prev
operator|==
name|ob
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
specifier|static
name|NOINLINE
name|void
name|RemoveCacheEntries
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|threadcache
modifier|*
name|tc
parameter_list|,
name|unsigned
name|int
name|age
parameter_list|)
function|THROWSPEC
block|{
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tcfullsanitycheck
argument_list|(
name|tc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tc
operator|->
name|freeInCache
condition|)
block|{
name|threadcacheblk
modifier|*
modifier|*
name|tcbptr
init|=
name|tc
operator|->
name|bins
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|THREADCACHEMAXBINS
condition|;
name|n
operator|++
operator|,
name|tcbptr
operator|+=
literal|2
control|)
block|{
name|threadcacheblk
modifier|*
modifier|*
name|tcb
init|=
name|tcbptr
operator|+
literal|1
decl_stmt|;
comment|/* come from oldest end of list */
comment|/*tcsanitycheck(tcbptr);*/
for|for
control|(
init|;
operator|*
name|tcb
operator|&&
name|tc
operator|->
name|frees
operator|-
operator|(
operator|*
name|tcb
operator|)
operator|->
name|lastUsed
operator|>=
name|age
condition|;
control|)
block|{
name|threadcacheblk
modifier|*
name|f
init|=
operator|*
name|tcb
decl_stmt|;
name|size_t
name|blksize
init|=
name|f
operator|->
name|size
decl_stmt|;
comment|/*nedblksize(f);*/
name|assert
argument_list|(
name|blksize
operator|<=
name|nedblksize
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|blksize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|assert
argument_list|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDN"
operator|==
operator|(
operator|*
name|tcb
operator|)
operator|->
name|magic
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|tcb
operator|=
operator|(
operator|*
name|tcb
operator|)
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|*
name|tcb
condition|)
operator|(
operator|*
name|tcb
operator|)
operator|->
name|next
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tcbptr
operator|=
literal|0
expr_stmt|;
name|tc
operator|->
name|freeInCache
operator|-=
name|blksize
expr_stmt|;
name|assert
argument_list|(
operator|(
name|long
operator|)
name|tc
operator|->
name|freeInCache
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|mspace_free
argument_list|(
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/*tcsanitycheck(tcbptr);*/
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tcfullsanitycheck
argument_list|(
name|tc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|DestroyCaches
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|)
function|THROWSPEC
block|{
if|if
condition|(
name|p
operator|->
name|caches
condition|)
block|{
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|THREADCACHEMAXCACHES
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tc
operator|=
name|p
operator|->
name|caches
index|[
name|n
index|]
operator|)
condition|)
block|{
name|tc
operator|->
name|frees
operator|++
expr_stmt|;
name|RemoveCacheEntries
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|tc
operator|->
name|freeInCache
argument_list|)
expr_stmt|;
name|tc
operator|->
name|mymspace
operator|=
operator|-
literal|1
expr_stmt|;
name|tc
operator|->
name|threadid
operator|=
literal|0
expr_stmt|;
name|mspace_free
argument_list|(
literal|0
argument_list|,
name|tc
argument_list|)
expr_stmt|;
name|p
operator|->
name|caches
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|static
name|NOINLINE
name|threadcache
modifier|*
name|AllocCache
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|)
function|THROWSPEC
block|{
name|threadcache
modifier|*
name|tc
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|end
decl_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|THREADCACHEMAXCACHES
operator|&&
name|p
operator|->
name|caches
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|THREADCACHEMAXCACHES
operator|==
name|n
condition|)
block|{
comment|/* List exhausted, so disable for this thread */
name|RELEASE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tc
operator|=
name|p
operator|->
name|caches
index|[
name|n
index|]
operator|=
operator|(
name|threadcache
operator|*
operator|)
name|mspace_calloc
argument_list|(
name|p
operator|->
name|m
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|threadcache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tc
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tc
operator|->
name|magic1
operator|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDMALC1"
expr_stmt|;
name|tc
operator|->
name|magic2
operator|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDMALC2"
expr_stmt|;
endif|#
directive|endif
name|tc
operator|->
name|threadid
operator|=
operator|(
name|long
operator|)
operator|(
name|size_t
operator|)
name|CURRENT_THREAD
expr_stmt|;
for|for
control|(
name|end
operator|=
literal|0
init|;
name|p
operator|->
name|m
index|[
name|end
index|]
condition|;
name|end
operator|++
control|)
empty_stmt|;
name|tc
operator|->
name|mymspace
operator|=
name|tc
operator|->
name|threadid
operator|%
name|end
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLSSET
argument_list|(
name|p
operator|->
name|mycache
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|size_t
call|)
argument_list|(
name|n
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|tc
return|;
block|}
specifier|static
name|void
modifier|*
name|threadcache_malloc
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|threadcache
modifier|*
name|tc
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function|THROWSPEC
block|{
name|void
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|bestsize
decl_stmt|;
name|unsigned
name|int
name|idx
init|=
name|size2binidx
argument_list|(
operator|*
name|size
argument_list|)
decl_stmt|;
name|size_t
name|blksize
init|=
literal|0
decl_stmt|;
name|threadcacheblk
modifier|*
name|blk
decl_stmt|,
modifier|*
modifier|*
name|binsptr
decl_stmt|;
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tcfullsanitycheck
argument_list|(
name|tc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Calculate best fit bin size */
name|bestsize
operator|=
literal|1
operator|<<
operator|(
name|idx
operator|+
literal|4
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Finer grained bin fit */
block|idx<<=1; 	if(*size>bestsize) 	{ 		idx++; 		bestsize+=bestsize>>1; 	} 	if(*size>bestsize) 	{ 		idx++; 		bestsize=1<<(4+(idx>>1)); 	}
else|#
directive|else
if|if
condition|(
operator|*
name|size
operator|>
name|bestsize
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|bestsize
operator|<<=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|bestsize
operator|>=
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
name|bestsize
condition|)
operator|*
name|size
operator|=
name|bestsize
expr_stmt|;
name|assert
argument_list|(
operator|*
name|size
operator|<=
name|THREADCACHEMAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|idx
operator|<=
name|THREADCACHEMAXBINS
argument_list|)
expr_stmt|;
name|binsptr
operator|=
operator|&
name|tc
operator|->
name|bins
index|[
name|idx
operator|*
literal|2
index|]
expr_stmt|;
comment|/* Try to match close, but move up a bin if necessary */
name|blk
operator|=
operator|*
name|binsptr
expr_stmt|;
if|if
condition|(
operator|!
name|blk
operator|||
name|blk
operator|->
name|size
operator|<
operator|*
name|size
condition|)
block|{
comment|/* Bump it up a bin */
if|if
condition|(
name|idx
operator|<
name|THREADCACHEMAXBINS
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|binsptr
operator|+=
literal|2
expr_stmt|;
name|blk
operator|=
operator|*
name|binsptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blk
condition|)
block|{
name|blksize
operator|=
name|blk
operator|->
name|size
expr_stmt|;
comment|/*nedblksize(blk);*/
name|assert
argument_list|(
name|nedblksize
argument_list|(
name|blk
argument_list|)
operator|>=
name|blksize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|blksize
operator|>=
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|->
name|next
condition|)
name|blk
operator|->
name|next
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
operator|*
name|binsptr
operator|=
name|blk
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|binsptr
condition|)
name|binsptr
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|blk
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|binsptr
index|[
literal|0
index|]
operator|!=
name|blk
operator|&&
name|binsptr
index|[
literal|1
index|]
operator|!=
name|blk
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nedblksize
argument_list|(
name|blk
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
operator|&&
name|nedblksize
argument_list|(
name|blk
argument_list|)
operator|<=
name|THREADCACHEMAX
operator|+
name|CHUNK_OVERHEAD
argument_list|)
expr_stmt|;
comment|/*printf("malloc: %p, %p, %p, %lu\n", p, tc, blk, (long) size);*/
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
name|blk
expr_stmt|;
block|}
operator|++
name|tc
operator|->
name|mallocs
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|assert
argument_list|(
name|blksize
operator|>=
operator|*
name|size
argument_list|)
expr_stmt|;
operator|++
name|tc
operator|->
name|successes
expr_stmt|;
name|tc
operator|->
name|freeInCache
operator|-=
name|blksize
expr_stmt|;
name|assert
argument_list|(
operator|(
name|long
operator|)
name|tc
operator|->
name|freeInCache
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
if|if
condition|(
operator|!
operator|(
name|tc
operator|->
name|mallocs
operator|&
literal|0xfff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"*** threadcache=%u, mallocs=%u (%f), free=%u (%f), freeInCache=%u\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|tc
operator|->
name|threadid
argument_list|,
name|tc
operator|->
name|mallocs
argument_list|,
operator|(
name|float
operator|)
name|tc
operator|->
name|successes
operator|/
name|tc
operator|->
name|mallocs
argument_list|,
name|tc
operator|->
name|frees
argument_list|,
operator|(
name|float
operator|)
name|tc
operator|->
name|successes
operator|/
name|tc
operator|->
name|frees
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|tc
operator|->
name|freeInCache
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tcfullsanitycheck
argument_list|(
name|tc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
specifier|static
name|NOINLINE
name|void
name|ReleaseFreeInCache
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|threadcache
modifier|*
name|tc
parameter_list|,
name|int
name|mymspace
parameter_list|)
function|THROWSPEC
block|{
name|unsigned
name|int
name|age
init|=
name|THREADCACHEMAXFREESPACE
operator|/
literal|8192
decl_stmt|;
comment|/*ACQUIRE_LOCK(&p->m[mymspace]->mutex);*/
while|while
condition|(
name|age
operator|&&
name|tc
operator|->
name|freeInCache
operator|>=
name|THREADCACHEMAXFREESPACE
condition|)
block|{
name|RemoveCacheEntries
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
name|age
argument_list|)
expr_stmt|;
comment|/*printf("*** Removing cache entries older than %u (%u)\n", age, (unsigned int) tc->freeInCache);*/
name|age
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/*RELEASE_LOCK(&p->m[mymspace]->mutex);*/
block|}
specifier|static
name|void
name|threadcache_free
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|threadcache
modifier|*
name|tc
parameter_list|,
name|int
name|mymspace
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
name|unsigned
name|int
name|bestsize
decl_stmt|;
name|unsigned
name|int
name|idx
init|=
name|size2binidx
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|threadcacheblk
modifier|*
modifier|*
name|binsptr
decl_stmt|,
modifier|*
name|tck
init|=
operator|(
name|threadcacheblk
operator|*
operator|)
name|mem
decl_stmt|;
name|assert
argument_list|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
operator|&&
name|size
operator|<=
name|THREADCACHEMAX
operator|+
name|CHUNK_OVERHEAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
comment|/* Make sure this is a valid memory block */
name|mchunkptr
name|p
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|mstate
name|fm
init|=
name|get_mstate_for
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|fm
argument_list|)
condition|)
block|{
name|USAGE_ERROR_ACTION
argument_list|(
name|fm
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tcfullsanitycheck
argument_list|(
name|tc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Calculate best fit bin size */
name|bestsize
operator|=
literal|1
operator|<<
operator|(
name|idx
operator|+
literal|4
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Finer grained bin fit */
block|idx<<=1; 	if(size>bestsize) 	{ 		unsigned int biggerbestsize=bestsize+bestsize<<1; 		if(size>=biggerbestsize) 		{ 			idx++; 			bestsize=biggerbestsize; 		} 	}
endif|#
directive|endif
if|if
condition|(
name|bestsize
operator|!=
name|size
condition|)
comment|/* dlmalloc can round up, so we round down to preserve indexing */
name|size
operator|=
name|bestsize
expr_stmt|;
name|binsptr
operator|=
operator|&
name|tc
operator|->
name|bins
index|[
name|idx
operator|*
literal|2
index|]
expr_stmt|;
name|assert
argument_list|(
name|idx
operator|<=
name|THREADCACHEMAXBINS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tck
operator|==
operator|*
name|binsptr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Attempt to free already freed memory block %p - aborting!\n"
argument_list|,
name|tck
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tck
operator|->
name|magic
operator|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDN"
expr_stmt|;
endif|#
directive|endif
name|tck
operator|->
name|lastUsed
operator|=
operator|++
name|tc
operator|->
name|frees
expr_stmt|;
name|tck
operator|->
name|size
operator|=
operator|(
name|unsigned
name|int
operator|)
name|size
expr_stmt|;
name|tck
operator|->
name|next
operator|=
operator|*
name|binsptr
expr_stmt|;
name|tck
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tck
operator|->
name|next
condition|)
name|tck
operator|->
name|next
operator|->
name|prev
operator|=
name|tck
expr_stmt|;
else|else
name|binsptr
index|[
literal|1
index|]
operator|=
name|tck
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|*
name|binsptr
operator|||
operator|(
operator|*
name|binsptr
operator|)
operator|->
name|size
operator|==
name|tck
operator|->
name|size
argument_list|)
expr_stmt|;
operator|*
name|binsptr
operator|=
name|tck
expr_stmt|;
name|assert
argument_list|(
name|tck
operator|==
name|tc
operator|->
name|bins
index|[
name|idx
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tc
operator|->
name|bins
index|[
name|idx
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
name|tck
operator|||
name|binsptr
index|[
literal|0
index|]
operator|->
name|next
operator|->
name|prev
operator|==
name|tck
argument_list|)
expr_stmt|;
comment|/*printf("free: %p, %p, %p, %lu\n", p, tc, mem, (long) size);*/
name|tc
operator|->
name|freeInCache
operator|+=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
name|tcfullsanitycheck
argument_list|(
name|tc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
if|if
condition|(
name|tc
operator|->
name|freeInCache
operator|>=
name|THREADCACHEMAXFREESPACE
condition|)
name|ReleaseFreeInCache
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|NOINLINE
name|int
name|InitPool
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|size_t
name|capacity
parameter_list|,
name|int
name|threads
parameter_list|)
function|THROWSPEC
block|{
comment|/* threads is -1 for system pool */
name|ensure_initialization
argument_list|()
expr_stmt|;
name|ACQUIRE_MALLOC_GLOBAL_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|threads
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|INITIAL_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|TLSALLOC
argument_list|(
operator|&
name|p
operator|->
name|mycache
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|m
index|[
literal|0
index|]
operator|=
operator|(
name|mstate
operator|)
name|create_mspace
argument_list|(
name|capacity
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|p
operator|->
name|m
index|[
literal|0
index|]
operator|->
name|extp
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|threads
operator|=
operator|(
name|threads
operator|<
literal|1
operator|||
name|threads
operator|>
name|MAXTHREADSINPOOL
operator|)
condition|?
name|MAXTHREADSINPOOL
else|:
name|threads
expr_stmt|;
name|done
label|:
name|RELEASE_MALLOC_GLOBAL_LOCK
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
name|err
label|:
if|if
condition|(
name|threads
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If you can't allocate for system pool, we're screwed */
name|DestroyCaches
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|m
index|[
literal|0
index|]
condition|)
block|{
name|destroy_mspace
argument_list|(
name|p
operator|->
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|m
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|mycache
condition|)
block|{
if|if
condition|(
name|TLSFREE
argument_list|(
name|p
operator|->
name|mycache
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|->
name|mycache
operator|=
literal|0
expr_stmt|;
block|}
name|RELEASE_MALLOC_GLOBAL_LOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|NOINLINE
name|mstate
name|FindMSpace
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|threadcache
modifier|*
name|tc
parameter_list|,
name|int
modifier|*
name|lastUsed
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
comment|/* Gets called when thread's last used mspace is in use. The strategy 	is to run through the list of all available mspaces looking for an 	unlocked one and if we fail, we create a new one so long as we don't 	exceed p->threads */
name|int
name|n
decl_stmt|,
name|end
decl_stmt|;
for|for
control|(
name|n
operator|=
name|end
operator|=
operator|*
name|lastUsed
operator|+
literal|1
init|;
name|p
operator|->
name|m
index|[
name|n
index|]
condition|;
name|end
operator|=
operator|++
name|n
control|)
block|{
if|if
condition|(
name|TRY_LOCK
argument_list|(
operator|&
name|p
operator|->
name|m
index|[
name|n
index|]
operator|->
name|mutex
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|*
name|lastUsed
operator|&&
name|p
operator|->
name|m
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|TRY_LOCK
argument_list|(
operator|&
name|p
operator|->
name|m
index|[
name|n
index|]
operator|->
name|mutex
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|end
operator|<
name|p
operator|->
name|threads
condition|)
block|{
name|mstate
name|temp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
operator|(
name|mstate
operator|)
name|create_mspace
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|badexit
goto|;
comment|/* Now we're ready to modify the lists, we lock */
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|m
index|[
name|end
index|]
operator|&&
name|end
operator|<
name|p
operator|->
name|threads
condition|)
name|end
operator|++
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|p
operator|->
name|threads
condition|)
block|{
comment|/* Drat, must destroy it now */
name|RELEASE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|destroy_mspace
argument_list|(
operator|(
name|mspace
operator|)
name|temp
argument_list|)
expr_stmt|;
goto|goto
name|badexit
goto|;
block|}
comment|/* We really want to make sure this goes into memory now but we 		have to be careful of breaking aliasing rules, so write it twice */
block|{
specifier|volatile
name|struct
name|malloc_state
modifier|*
modifier|*
name|_m
init|=
operator|(
specifier|volatile
expr|struct
name|malloc_state
operator|*
operator|*
operator|)
operator|&
name|p
operator|->
name|m
index|[
name|end
index|]
decl_stmt|;
operator|*
name|_m
operator|=
operator|(
name|p
operator|->
name|m
index|[
name|end
index|]
operator|=
name|temp
operator|)
expr_stmt|;
block|}
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|m
index|[
name|end
index|]
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/*printf("Created mspace idx %d\n", end);*/
name|RELEASE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|n
operator|=
name|end
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* Let it lock on the last one it used */
name|badexit
label|:
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|m
index|[
operator|*
name|lastUsed
index|]
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|p
operator|->
name|m
index|[
operator|*
name|lastUsed
index|]
return|;
name|found
label|:
operator|*
name|lastUsed
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|tc
condition|)
name|tc
operator|->
name|mymspace
operator|=
name|n
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TLSSET
argument_list|(
name|p
operator|->
name|mycache
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|size_t
call|)
argument_list|(
operator|-
operator|(
name|n
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|p
operator|->
name|m
index|[
name|n
index|]
return|;
block|}
name|nedpool
modifier|*
name|nedcreatepool
parameter_list|(
name|size_t
name|capacity
parameter_list|,
name|int
name|threads
parameter_list|)
function|THROWSPEC
block|{
name|nedpool
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
operator|(
name|nedpool
operator|*
operator|)
name|nedpcalloc
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|nedpool
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|InitPool
argument_list|(
name|ret
argument_list|,
name|capacity
argument_list|,
name|threads
argument_list|)
condition|)
block|{
name|nedpfree
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ret
return|;
block|}
name|void
name|neddestroypool
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|)
function|THROWSPEC
block|{
name|int
name|n
decl_stmt|;
name|ACQUIRE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|DestroyCaches
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|->
name|m
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|destroy_mspace
argument_list|(
name|p
operator|->
name|m
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|m
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLSFREE
argument_list|(
name|p
operator|->
name|mycache
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nedpfree
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|void
name|nedpsetvalue
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
function|THROWSPEC
block|{
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
operator|&
name|syspool
expr_stmt|;
if|if
condition|(
operator|!
name|syspool
operator|.
name|threads
condition|)
name|InitPool
argument_list|(
operator|&
name|syspool
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|uservalue
operator|=
name|v
expr_stmt|;
block|}
name|void
modifier|*
name|nedgetvalue
parameter_list|(
name|nedpool
modifier|*
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|)
function|THROWSPEC
block|{
name|nedpool
modifier|*
name|np
init|=
literal|0
decl_stmt|;
name|mchunkptr
name|mcp
init|=
name|mem2chunk
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|mstate
name|fm
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|is_aligned
argument_list|(
name|chunk2mem
argument_list|(
name|mcp
argument_list|)
argument_list|)
operator|)
operator|&&
name|mcp
operator|->
name|head
operator|!=
name|FENCEPOST_HEAD
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|cinuse
argument_list|(
name|mcp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|next_pinuse
argument_list|(
name|mcp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|is_mmapped
argument_list|(
name|mcp
argument_list|)
operator|&&
operator|!
name|pinuse
argument_list|(
name|mcp
argument_list|)
condition|)
block|{
if|if
condition|(
name|next_chunk
argument_list|(
name|prev_chunk
argument_list|(
name|mcp
argument_list|)
argument_list|)
operator|!=
name|mcp
condition|)
return|return
literal|0
return|;
block|}
name|fm
operator|=
name|get_mstate_for
argument_list|(
name|mcp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok_magic
argument_list|(
name|fm
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ok_address
argument_list|(
name|fm
argument_list|,
name|mcp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|fm
operator|->
name|extp
condition|)
return|return
literal|0
return|;
name|np
operator|=
operator|(
name|nedpool
operator|*
operator|)
name|fm
operator|->
name|extp
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
name|np
expr_stmt|;
return|return
name|np
operator|->
name|uservalue
return|;
block|}
name|void
name|neddisablethreadcache
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|)
function|THROWSPEC
block|{
name|int
name|mycache
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
operator|&
name|syspool
expr_stmt|;
if|if
condition|(
operator|!
name|syspool
operator|.
name|threads
condition|)
name|InitPool
argument_list|(
operator|&
name|syspool
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|mycache
operator|=
operator|(
name|int
operator|)
operator|(
name|size_t
operator|)
name|TLSGET
argument_list|(
name|p
operator|->
name|mycache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mycache
condition|)
block|{
comment|/* Set to mspace 0 */
if|if
condition|(
name|TLSSET
argument_list|(
name|p
operator|->
name|mycache
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mycache
operator|>
literal|0
condition|)
block|{
comment|/* Set to last used mspace */
name|threadcache
modifier|*
name|tc
init|=
name|p
operator|->
name|caches
index|[
name|mycache
operator|-
literal|1
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|printf
argument_list|(
literal|"Threadcache utilisation: %lf%% in cache with %lf%% lost to other threads\n"
argument_list|,
literal|100.0
operator|*
name|tc
operator|->
name|successes
operator|/
name|tc
operator|->
name|mallocs
argument_list|,
literal|100.0
operator|*
operator|(
operator|(
name|double
operator|)
name|tc
operator|->
name|mallocs
operator|-
name|tc
operator|->
name|frees
operator|)
operator|/
name|tc
operator|->
name|mallocs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TLSSET
argument_list|(
name|p
operator|->
name|mycache
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|size_t
call|)
argument_list|(
operator|-
name|tc
operator|->
name|mymspace
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tc
operator|->
name|frees
operator|++
expr_stmt|;
name|RemoveCacheEntries
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|tc
operator|->
name|freeInCache
argument_list|)
expr_stmt|;
name|tc
operator|->
name|mymspace
operator|=
operator|-
literal|1
expr_stmt|;
name|tc
operator|->
name|threadid
operator|=
literal|0
expr_stmt|;
name|mspace_free
argument_list|(
literal|0
argument_list|,
name|p
operator|->
name|caches
index|[
name|mycache
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|caches
index|[
name|mycache
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
DECL|macro|GETMSPACE
define|#
directive|define
name|GETMSPACE
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|,
name|tc
parameter_list|,
name|ms
parameter_list|,
name|s
parameter_list|,
name|action
parameter_list|)
define|\
value|do                                            \   {                                             \     mstate m = GetMSpace((p),(tc),(ms),(s));    \     action;                                     \     RELEASE_LOCK(&m->mutex);                    \   } while (0)
specifier|static
name|FORCEINLINE
name|mstate
name|GetMSpace
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|threadcache
modifier|*
name|tc
parameter_list|,
name|int
name|mymspace
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
comment|/* Returns a locked and ready for use mspace */
name|mstate
name|m
init|=
name|p
operator|->
name|m
index|[
name|mymspace
index|]
decl_stmt|;
name|assert
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
operator|&
name|p
operator|->
name|m
index|[
name|mymspace
index|]
operator|->
name|mutex
argument_list|)
condition|)
name|m
operator|=
name|FindMSpace
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|\
comment|/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
return|return
name|m
return|;
block|}
specifier|static
name|FORCEINLINE
name|void
name|GetThreadCache
parameter_list|(
name|nedpool
modifier|*
modifier|*
name|p
parameter_list|,
name|threadcache
modifier|*
modifier|*
name|tc
parameter_list|,
name|int
modifier|*
name|mymspace
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
function|THROWSPEC
block|{
name|int
name|mycache
decl_stmt|;
if|if
condition|(
name|size
operator|&&
operator|*
name|size
operator|<
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
condition|)
operator|*
name|size
operator|=
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|=
operator|&
name|syspool
expr_stmt|;
if|if
condition|(
operator|!
name|syspool
operator|.
name|threads
condition|)
name|InitPool
argument_list|(
operator|&
name|syspool
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|mycache
operator|=
operator|(
name|int
operator|)
operator|(
name|size_t
operator|)
name|TLSGET
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|mycache
argument_list|)
expr_stmt|;
if|if
condition|(
name|mycache
operator|>
literal|0
condition|)
block|{
operator|*
name|tc
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|caches
index|[
name|mycache
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|mymspace
operator|=
operator|(
operator|*
name|tc
operator|)
operator|->
name|mymspace
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mycache
condition|)
block|{
operator|*
name|tc
operator|=
name|AllocCache
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|tc
condition|)
block|{
comment|/* Disable */
if|if
condition|(
name|TLSSET
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|mycache
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|mymspace
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|mymspace
operator|=
operator|(
operator|*
name|tc
operator|)
operator|->
name|mymspace
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tc
operator|=
literal|0
expr_stmt|;
operator|*
name|mymspace
operator|=
operator|-
name|mycache
operator|-
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
operator|*
name|mymspace
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|long
operator|)
operator|(
name|size_t
operator|)
name|CURRENT_THREAD
operator|==
operator|(
operator|*
name|tc
operator|)
operator|->
name|threadid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLSANITYCHECKS
if|if
condition|(
operator|*
name|tc
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDMALC1"
operator|!=
operator|(
operator|*
name|tc
operator|)
operator|->
name|magic1
operator|||
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
literal|"NEDMALC2"
operator|!=
operator|(
operator|*
name|tc
operator|)
operator|->
name|magic2
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|void
modifier|*
name|nedpmalloc
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
name|void
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|mymspace
decl_stmt|;
name|GetThreadCache
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|THREADCACHEMAX
if|if
condition|(
name|tc
operator|&&
name|size
operator|<=
name|THREADCACHEMAX
condition|)
block|{
comment|/* Use the thread cache */
name|ret
operator|=
name|threadcache_malloc
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|ret
condition|)
block|{
comment|/* Use this thread's mspace */
name|GETMSPACE
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|,
name|size
argument_list|,
name|ret
operator|=
name|mspace_malloc
argument_list|(
name|m
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|void
modifier|*
name|nedpcalloc
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|size_t
name|no
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
name|size_t
name|rsize
init|=
name|size
operator|*
name|no
decl_stmt|;
name|void
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|mymspace
decl_stmt|;
name|GetThreadCache
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
operator|&
name|rsize
argument_list|)
expr_stmt|;
if|#
directive|if
name|THREADCACHEMAX
if|if
condition|(
name|tc
operator|&&
name|rsize
operator|<=
name|THREADCACHEMAX
condition|)
block|{
comment|/* Use the thread cache */
if|if
condition|(
operator|(
name|ret
operator|=
name|threadcache_malloc
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
operator|&
name|rsize
argument_list|)
operator|)
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|ret
condition|)
block|{
comment|/* Use this thread's mspace */
name|GETMSPACE
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|,
name|rsize
argument_list|,
name|ret
operator|=
name|mspace_calloc
argument_list|(
name|m
argument_list|,
literal|1
argument_list|,
name|rsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|void
modifier|*
name|nedprealloc
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
function|THROWSPEC
block|{
name|void
modifier|*
name|ret
init|=
literal|0
decl_stmt|;
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|mymspace
decl_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
return|return
name|nedpmalloc
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
return|;
name|GetThreadCache
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|THREADCACHEMAX
if|if
condition|(
name|tc
operator|&&
name|size
operator|&&
name|size
operator|<=
name|THREADCACHEMAX
condition|)
block|{
comment|/* Use the thread cache */
name|size_t
name|memsize
init|=
name|nedblksize
argument_list|(
name|mem
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|threadcache_malloc
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
operator|&
name|size
argument_list|)
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|memsize
operator|<
name|size
condition|?
name|memsize
else|:
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|memsize
operator|<=
name|THREADCACHEMAX
condition|)
name|threadcache_free
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|,
name|mem
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
else|else
name|mspace_free
argument_list|(
literal|0
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|ret
condition|)
block|{
comment|/* Reallocs always happen in the mspace they happened in, so skip 		locking the preferred mspace for this thread */
name|ret
operator|=
name|mspace_realloc
argument_list|(
literal|0
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|void
name|nedpfree
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|)
function|THROWSPEC
block|{
comment|/* Frees always happen in the mspace they happened in, so skip 	locking the preferred mspace for this thread */
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|mymspace
decl_stmt|;
name|size_t
name|memsize
decl_stmt|;
name|assert
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|GetThreadCache
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|THREADCACHEMAX
name|memsize
operator|=
name|nedblksize
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|&&
name|tc
operator|&&
name|memsize
operator|<=
operator|(
name|THREADCACHEMAX
operator|+
name|CHUNK_OVERHEAD
operator|)
condition|)
name|threadcache_free
argument_list|(
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|,
name|mem
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mspace_free
argument_list|(
literal|0
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|nedpmemalign
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|bytes
parameter_list|)
function|THROWSPEC
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|mymspace
decl_stmt|;
name|GetThreadCache
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
block|{
comment|/* Use this thread's mspace */
name|GETMSPACE
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|,
name|bytes
argument_list|,
name|ret
operator|=
name|mspace_memalign
argument_list|(
name|m
argument_list|,
name|alignment
argument_list|,
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
if|#
directive|if
operator|!
name|NO_MALLINFO
name|struct
name|mallinfo
name|nedpmallinfo
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|)
function|THROWSPEC
block|{
name|int
name|n
decl_stmt|;
name|struct
name|mallinfo
name|ret
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
operator|&
name|syspool
expr_stmt|;
if|if
condition|(
operator|!
name|syspool
operator|.
name|threads
condition|)
name|InitPool
argument_list|(
operator|&
name|syspool
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|->
name|m
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|mallinfo
name|t
init|=
name|mspace_mallinfo
argument_list|(
name|p
operator|->
name|m
index|[
name|n
index|]
argument_list|)
decl_stmt|;
name|ret
operator|.
name|arena
operator|+=
name|t
operator|.
name|arena
expr_stmt|;
name|ret
operator|.
name|ordblks
operator|+=
name|t
operator|.
name|ordblks
expr_stmt|;
name|ret
operator|.
name|hblkhd
operator|+=
name|t
operator|.
name|hblkhd
expr_stmt|;
name|ret
operator|.
name|usmblks
operator|+=
name|t
operator|.
name|usmblks
expr_stmt|;
name|ret
operator|.
name|uordblks
operator|+=
name|t
operator|.
name|uordblks
expr_stmt|;
name|ret
operator|.
name|fordblks
operator|+=
name|t
operator|.
name|fordblks
expr_stmt|;
name|ret
operator|.
name|keepcost
operator|+=
name|t
operator|.
name|keepcost
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
endif|#
directive|endif
name|int
name|nedpmallopt
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|int
name|parno
parameter_list|,
name|int
name|value
parameter_list|)
function|THROWSPEC
block|{
return|return
name|mspace_mallopt
argument_list|(
name|parno
argument_list|,
name|value
argument_list|)
return|;
block|}
name|int
name|nedpmalloc_trim
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|size_t
name|pad
parameter_list|)
function|THROWSPEC
block|{
name|int
name|n
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
operator|&
name|syspool
expr_stmt|;
if|if
condition|(
operator|!
name|syspool
operator|.
name|threads
condition|)
name|InitPool
argument_list|(
operator|&
name|syspool
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|->
name|m
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|ret
operator|+=
name|mspace_trim
argument_list|(
name|p
operator|->
name|m
index|[
name|n
index|]
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|void
name|nedpmalloc_stats
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|)
function|THROWSPEC
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
operator|&
name|syspool
expr_stmt|;
if|if
condition|(
operator|!
name|syspool
operator|.
name|threads
condition|)
name|InitPool
argument_list|(
operator|&
name|syspool
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|->
name|m
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|mspace_malloc_stats
argument_list|(
name|p
operator|->
name|m
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|size_t
name|nedpmalloc_footprint
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|)
function|THROWSPEC
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
operator|&
name|syspool
expr_stmt|;
if|if
condition|(
operator|!
name|syspool
operator|.
name|threads
condition|)
name|InitPool
argument_list|(
operator|&
name|syspool
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|->
name|m
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|ret
operator|+=
name|mspace_footprint
argument_list|(
name|p
operator|->
name|m
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|void
modifier|*
modifier|*
name|nedpindependent_calloc
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|size_t
name|elemsno
parameter_list|,
name|size_t
name|elemsize
parameter_list|,
name|void
modifier|*
modifier|*
name|chunks
parameter_list|)
function|THROWSPEC
block|{
name|void
modifier|*
modifier|*
name|ret
decl_stmt|;
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|mymspace
decl_stmt|;
name|GetThreadCache
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
operator|&
name|elemsize
argument_list|)
expr_stmt|;
name|GETMSPACE
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|,
name|elemsno
operator|*
name|elemsize
argument_list|,
name|ret
operator|=
name|mspace_independent_calloc
argument_list|(
name|m
argument_list|,
name|elemsno
argument_list|,
name|elemsize
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|void
modifier|*
modifier|*
name|nedpindependent_comalloc
parameter_list|(
name|nedpool
modifier|*
name|p
parameter_list|,
name|size_t
name|elems
parameter_list|,
name|size_t
modifier|*
name|sizes
parameter_list|,
name|void
modifier|*
modifier|*
name|chunks
parameter_list|)
function|THROWSPEC
block|{
name|void
modifier|*
modifier|*
name|ret
decl_stmt|;
name|threadcache
modifier|*
name|tc
decl_stmt|;
name|int
name|mymspace
decl_stmt|;
name|size_t
name|i
decl_stmt|,
modifier|*
name|adjustedsizes
init|=
operator|(
name|size_t
operator|*
operator|)
name|alloca
argument_list|(
name|elems
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|adjustedsizes
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elems
condition|;
name|i
operator|++
control|)
name|adjustedsizes
index|[
name|i
index|]
operator|=
name|sizes
index|[
name|i
index|]
operator|<
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|threadcacheblk
argument_list|)
else|:
name|sizes
index|[
name|i
index|]
expr_stmt|;
name|GetThreadCache
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|tc
argument_list|,
operator|&
name|mymspace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GETMSPACE
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|tc
argument_list|,
name|mymspace
argument_list|,
literal|0
argument_list|,
name|ret
operator|=
name|mspace_independent_comalloc
argument_list|(
name|m
argument_list|,
name|elems
argument_list|,
name|adjustedsizes
argument_list|,
name|chunks
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
ifdef|#
directive|ifdef
name|OVERRIDE_STRDUP
comment|/*  * This implementation is purely there to override the libc version, to  * avoid a crash due to allocation and free on different 'heaps'.  */
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|)
block|{
name|char
modifier|*
name|s2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s1
condition|)
block|{
name|s2
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s2
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
return|return
name|s2
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
end_unit
