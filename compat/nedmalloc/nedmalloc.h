begin_unit
begin_comment
comment|/* nedalloc, an alternative malloc implementation for multiple threads without lock contention based on dlmalloc v2.8.3. (C) 2005 Niall Douglas  Boost Software License - Version 1.0 - August 17th, 2003  Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:  The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NEDMALLOC_H
end_ifndef
begin_define
DECL|macro|NEDMALLOC_H
define|#
directive|define
name|NEDMALLOC_H
end_define
begin_comment
comment|/* See malloc.c.h for what each function does.  REPLACE_SYSTEM_ALLOCATOR causes nedalloc's functions to be called malloc, free etc. instead of nedmalloc, nedfree etc. You may or may not want this.  NO_NED_NAMESPACE prevents the functions from being defined in the nedalloc namespace when in C++ (uses the global namespace instead).  EXTSPEC can be defined to be __declspec(dllexport) or __attribute__ ((visibility("default"))) or whatever you like. It defaults to extern.  USE_LOCKS can be 2 if you want to define your own MLOCK_T, INITIAL_LOCK, ACQUIRE_LOCK, RELEASE_LOCK, TRY_LOCK, IS_LOCKED and NULL_LOCK_INITIALIZER.  */
end_comment
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_comment
comment|/* for size_t */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|EXTSPEC
end_ifndef
begin_define
DECL|macro|EXTSPEC
define|#
directive|define
name|EXTSPEC
value|extern
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
end_if
begin_define
DECL|macro|MALLOCATTR
define|#
directive|define
name|MALLOCATTR
value|__declspec(restrict)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef
begin_define
DECL|macro|MALLOCATTR
define|#
directive|define
name|MALLOCATTR
value|__attribute__ ((malloc))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|MALLOCATTR
end_ifndef
begin_define
DECL|macro|MALLOCATTR
define|#
directive|define
name|MALLOCATTR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|REPLACE_SYSTEM_ALLOCATOR
end_ifdef
begin_define
DECL|macro|nedmalloc
define|#
directive|define
name|nedmalloc
value|malloc
end_define
begin_define
DECL|macro|nedcalloc
define|#
directive|define
name|nedcalloc
value|calloc
end_define
begin_define
DECL|macro|nedrealloc
define|#
directive|define
name|nedrealloc
value|realloc
end_define
begin_define
DECL|macro|nedfree
define|#
directive|define
name|nedfree
value|free
end_define
begin_define
DECL|macro|nedmemalign
define|#
directive|define
name|nedmemalign
value|memalign
end_define
begin_define
DECL|macro|nedmallinfo
define|#
directive|define
name|nedmallinfo
value|mallinfo
end_define
begin_define
DECL|macro|nedmallopt
define|#
directive|define
name|nedmallopt
value|mallopt
end_define
begin_define
DECL|macro|nedmalloc_trim
define|#
directive|define
name|nedmalloc_trim
value|malloc_trim
end_define
begin_define
DECL|macro|nedmalloc_stats
define|#
directive|define
name|nedmalloc_stats
value|malloc_stats
end_define
begin_define
DECL|macro|nedmalloc_footprint
define|#
directive|define
name|nedmalloc_footprint
value|malloc_footprint
end_define
begin_define
DECL|macro|nedindependent_calloc
define|#
directive|define
name|nedindependent_calloc
value|independent_calloc
end_define
begin_define
DECL|macro|nedindependent_comalloc
define|#
directive|define
name|nedindependent_comalloc
value|independent_comalloc
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef
begin_define
DECL|macro|nedblksize
define|#
directive|define
name|nedblksize
value|_msize
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|NO_MALLINFO
end_ifndef
begin_define
DECL|macro|NO_MALLINFO
define|#
directive|define
name|NO_MALLINFO
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|NO_MALLINFO
end_if
begin_struct_decl
struct_decl|struct
name|mallinfo
struct_decl|;
end_struct_decl
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_NED_NAMESPACE
argument_list|)
end_if
begin_decl_stmt
name|namespace
name|nedalloc
block|{
else|#
directive|else
extern|extern
literal|"C"
block|{
endif|#
directive|endif
DECL|macro|THROWSPEC
define|#
directive|define
name|THROWSPEC
value|throw()
else|#
directive|else
define|#
directive|define
name|THROWSPEC
endif|#
directive|endif
comment|/* These are the global functions */
comment|/* Gets the usable size of an allocated block. Note this will always be bigger than what was asked for due to rounding etc. */
name|EXTSPEC
name|size_t
name|nedblksize
argument_list|(
name|void
operator|*
name|mem
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|void
name|nedsetvalue
argument_list|(
name|void
operator|*
name|v
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedmalloc
argument_list|(
name|size_t
name|size
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedcalloc
argument_list|(
name|size_t
name|no
argument_list|,
name|size_t
name|size
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedrealloc
argument_list|(
name|void
operator|*
name|mem
argument_list|,
name|size_t
name|size
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|void
name|nedfree
argument_list|(
name|void
operator|*
name|mem
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedmemalign
argument_list|(
name|size_t
name|alignment
argument_list|,
name|size_t
name|bytes
argument_list|)
name|THROWSPEC
decl_stmt|;
if|#
directive|if
operator|!
name|NO_MALLINFO
name|EXTSPEC
name|struct
name|mallinfo
name|nedmallinfo
argument_list|(
name|void
argument_list|)
name|THROWSPEC
decl_stmt|;
endif|#
directive|endif
name|EXTSPEC
name|int
name|nedmallopt
argument_list|(
name|int
name|parno
argument_list|,
name|int
name|value
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|int
name|nedmalloc_trim
argument_list|(
name|size_t
name|pad
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|void
name|nedmalloc_stats
argument_list|(
name|void
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|size_t
name|nedmalloc_footprint
argument_list|(
name|void
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
modifier|*
name|nedindependent_calloc
argument_list|(
name|size_t
name|elemsno
argument_list|,
name|size_t
name|elemsize
argument_list|,
name|void
operator|*
operator|*
name|chunks
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
modifier|*
name|nedindependent_comalloc
argument_list|(
name|size_t
name|elems
argument_list|,
name|size_t
operator|*
name|sizes
argument_list|,
name|void
operator|*
operator|*
name|chunks
argument_list|)
name|THROWSPEC
decl_stmt|;
comment|/* These are the pool functions */
struct_decl|struct
name|nedpool_t
struct_decl|;
typedef|typedef
name|struct
name|nedpool_t
name|nedpool
typedef|;
comment|/* Creates a memory pool for use with the nedp* functions below. Capacity is how much to allocate immediately (if you know you'll be allocating a lot of memory very soon) which you can leave at zero. Threads specifies how many threads will *normally* be accessing the pool concurrently. Setting this to zero means it extends on demand, but be careful of this as it can rapidly consume system resources where bursts of concurrent threads use a pool at once. */
name|EXTSPEC
name|MALLOCATTR
name|nedpool
modifier|*
name|nedcreatepool
argument_list|(
name|size_t
name|capacity
argument_list|,
name|int
name|threads
argument_list|)
name|THROWSPEC
decl_stmt|;
comment|/* Destroys a memory pool previously created by nedcreatepool(). */
name|EXTSPEC
name|void
name|neddestroypool
argument_list|(
name|nedpool
operator|*
name|p
argument_list|)
name|THROWSPEC
decl_stmt|;
comment|/* Sets a value to be associated with a pool. You can retrieve this value by passing any memory block allocated from that pool. */
name|EXTSPEC
name|void
name|nedpsetvalue
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|void
operator|*
name|v
argument_list|)
name|THROWSPEC
decl_stmt|;
comment|/* Gets a previously set value using nedpsetvalue() or zero if memory is unknown. Optionally can also retrieve pool. */
name|EXTSPEC
name|void
modifier|*
name|nedgetvalue
argument_list|(
name|nedpool
operator|*
operator|*
name|p
argument_list|,
name|void
operator|*
name|mem
argument_list|)
name|THROWSPEC
decl_stmt|;
comment|/* Disables the thread cache for the calling thread, returning any existing cache data to the central pool. */
name|EXTSPEC
name|void
name|neddisablethreadcache
argument_list|(
name|nedpool
operator|*
name|p
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedpmalloc
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|size_t
name|size
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedpcalloc
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|size_t
name|no
argument_list|,
name|size_t
name|size
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedprealloc
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|void
operator|*
name|mem
argument_list|,
name|size_t
name|size
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|void
name|nedpfree
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|void
operator|*
name|mem
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
name|nedpmemalign
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|size_t
name|alignment
argument_list|,
name|size_t
name|bytes
argument_list|)
name|THROWSPEC
decl_stmt|;
if|#
directive|if
operator|!
name|NO_MALLINFO
name|EXTSPEC
name|struct
name|mallinfo
name|nedpmallinfo
argument_list|(
name|nedpool
operator|*
name|p
argument_list|)
name|THROWSPEC
decl_stmt|;
endif|#
directive|endif
name|EXTSPEC
name|int
name|nedpmallopt
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|int
name|parno
argument_list|,
name|int
name|value
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|int
name|nedpmalloc_trim
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|size_t
name|pad
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|void
name|nedpmalloc_stats
argument_list|(
name|nedpool
operator|*
name|p
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|size_t
name|nedpmalloc_footprint
argument_list|(
name|nedpool
operator|*
name|p
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
modifier|*
name|nedpindependent_calloc
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|size_t
name|elemsno
argument_list|,
name|size_t
name|elemsize
argument_list|,
name|void
operator|*
operator|*
name|chunks
argument_list|)
name|THROWSPEC
decl_stmt|;
name|EXTSPEC
name|MALLOCATTR
name|void
modifier|*
modifier|*
name|nedpindependent_comalloc
argument_list|(
name|nedpool
operator|*
name|p
argument_list|,
name|size_t
name|elems
argument_list|,
name|size_t
operator|*
name|sizes
argument_list|,
name|void
operator|*
operator|*
name|chunks
argument_list|)
name|THROWSPEC
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|MALLOCATTR
undef|#
directive|undef
name|MALLOCATTR
end_undef
begin_undef
DECL|macro|EXTSPEC
undef|#
directive|undef
name|EXTSPEC
end_undef
begin_endif
endif|#
directive|endif
end_endif
end_unit
