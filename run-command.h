begin_unit
begin_ifndef
ifndef|#
directive|ifndef
name|RUN_COMMAND_H
end_ifndef
begin_define
DECL|macro|RUN_COMMAND_H
define|#
directive|define
name|RUN_COMMAND_H
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|NO_PTHREADS
end_ifndef
begin_include
include|#
directive|include
file|<pthread.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"argv-array.h"
end_include
begin_struct
DECL|struct|child_process
struct|struct
name|child_process
block|{
DECL|member|argv
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
DECL|member|args
name|struct
name|argv_array
name|args
decl_stmt|;
DECL|member|env_array
name|struct
name|argv_array
name|env_array
decl_stmt|;
DECL|member|pid
name|pid_t
name|pid
decl_stmt|;
comment|/* 	 * Using .in, .out, .err: 	 * - Specify 0 for no redirections (child inherits stdin, stdout, 	 *   stderr from parent). 	 * - Specify -1 to have a pipe allocated as follows: 	 *     .in: returns the writable pipe end; parent writes to it, 	 *          the readable pipe end becomes child's stdin 	 *     .out, .err: returns the readable pipe end; parent reads from 	 *          it, the writable pipe end becomes child's stdout/stderr 	 *   The caller of start_command() must close the returned FDs 	 *   after it has completed reading from/writing to it! 	 * - Specify> 0 to set a channel to a particular FD as follows: 	 *     .in: a readable FD, becomes child's stdin 	 *     .out: a writable FD, becomes child's stdout/stderr 	 *     .err: a writable FD, becomes child's stderr 	 *   The specified FD is closed by start_command(), even in case 	 *   of errors! 	 */
DECL|member|in
name|int
name|in
decl_stmt|;
DECL|member|out
name|int
name|out
decl_stmt|;
DECL|member|err
name|int
name|err
decl_stmt|;
DECL|member|dir
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
DECL|member|env
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|env
decl_stmt|;
DECL|member|no_stdin
name|unsigned
name|no_stdin
range|:
literal|1
decl_stmt|;
DECL|member|no_stdout
name|unsigned
name|no_stdout
range|:
literal|1
decl_stmt|;
DECL|member|no_stderr
name|unsigned
name|no_stderr
range|:
literal|1
decl_stmt|;
DECL|member|git_cmd
name|unsigned
name|git_cmd
range|:
literal|1
decl_stmt|;
comment|/* if this is to be git sub-command */
DECL|member|silent_exec_failure
name|unsigned
name|silent_exec_failure
range|:
literal|1
decl_stmt|;
DECL|member|stdout_to_stderr
name|unsigned
name|stdout_to_stderr
range|:
literal|1
decl_stmt|;
DECL|member|use_shell
name|unsigned
name|use_shell
range|:
literal|1
decl_stmt|;
DECL|member|clean_on_exit
name|unsigned
name|clean_on_exit
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|CHILD_PROCESS_INIT
define|#
directive|define
name|CHILD_PROCESS_INIT
value|{ NULL, ARGV_ARRAY_INIT, ARGV_ARRAY_INIT }
end_define
begin_function_decl
name|void
name|child_process_init
parameter_list|(
name|struct
name|child_process
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|child_process_clear
parameter_list|(
name|struct
name|child_process
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|start_command
parameter_list|(
name|struct
name|child_process
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|finish_command
parameter_list|(
name|struct
name|child_process
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|finish_command_in_signal
parameter_list|(
name|struct
name|child_process
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|run_command
parameter_list|(
name|struct
name|child_process
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * Returns the path to the hook file, or NULL if the hook is missing  * or disabled. Note that this points to static storage that will be  * overwritten by further calls to find_hook and run_hook_*.  */
end_comment
begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|find_hook
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|LAST_ARG_MUST_BE_NULL
specifier|extern
name|int
name|run_hook_le
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|int
name|run_hook_ve
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl
begin_define
DECL|macro|RUN_COMMAND_NO_STDIN
define|#
directive|define
name|RUN_COMMAND_NO_STDIN
value|1
end_define
begin_define
DECL|macro|RUN_GIT_CMD
define|#
directive|define
name|RUN_GIT_CMD
value|2
end_define
begin_comment
DECL|macro|RUN_GIT_CMD
comment|/*If this is to be git sub-command */
end_comment
begin_define
DECL|macro|RUN_COMMAND_STDOUT_TO_STDERR
define|#
directive|define
name|RUN_COMMAND_STDOUT_TO_STDERR
value|4
end_define
begin_define
DECL|macro|RUN_SILENT_EXEC_FAILURE
define|#
directive|define
name|RUN_SILENT_EXEC_FAILURE
value|8
end_define
begin_define
DECL|macro|RUN_USING_SHELL
define|#
directive|define
name|RUN_USING_SHELL
value|16
end_define
begin_define
DECL|macro|RUN_CLEAN_ON_EXIT
define|#
directive|define
name|RUN_CLEAN_ON_EXIT
value|32
end_define
begin_function_decl
name|int
name|run_command_v_opt
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|opt
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * env (the environment) is to be formatted like environ: "VAR=VALUE".  * To unset an environment variable use just "VAR".  */
end_comment
begin_function_decl
name|int
name|run_command_v_opt_cd_env
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/**  * Execute the given command, sending "in" to its stdin, and capturing its  * stdout and stderr in the "out" and "err" strbufs. Any of the three may  * be NULL to skip processing.  *  * Returns -1 if starting the command fails or reading fails, and otherwise  * returns the exit code of the command. Any output collected in the  * buffers is kept even if the command returns a non-zero exit. The hint fields  * gives starting sizes for the strbuf allocations.  *  * The fields of "cmd" should be set up as they would for a normal run_command  * invocation. But note that there is no need to set the in, out, or err  * fields; pipe_command handles that automatically.  */
end_comment
begin_function_decl
name|int
name|pipe_command
parameter_list|(
name|struct
name|child_process
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|in_len
parameter_list|,
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|size_t
name|out_hint
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|,
name|size_t
name|err_hint
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/**  * Convenience wrapper around pipe_command for the common case  * of capturing only stdout.  */
end_comment
begin_function
DECL|function|capture_command
specifier|static
specifier|inline
name|int
name|capture_command
parameter_list|(
name|struct
name|child_process
modifier|*
name|cmd
parameter_list|,
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|size_t
name|hint
parameter_list|)
block|{
return|return
name|pipe_command
argument_list|(
name|cmd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|out
argument_list|,
name|hint
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * The purpose of the following functions is to feed a pipe by running  * a function asynchronously and providing output that the caller reads.  *  * It is expected that no synchronization and mutual exclusion between  * the caller and the feed function is necessary so that the function  * can run in a thread without interfering with the caller.  */
end_comment
begin_struct
DECL|struct|async
struct|struct
name|async
block|{
comment|/* 	 * proc reads from in; closes it before return 	 * proc writes to out; closes it before return 	 * returns 0 on success, non-zero on failure 	 */
DECL|member|proc
name|int
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
DECL|member|data
name|void
modifier|*
name|data
decl_stmt|;
DECL|member|in
name|int
name|in
decl_stmt|;
comment|/* caller writes here and closes it */
DECL|member|out
name|int
name|out
decl_stmt|;
comment|/* caller reads from here and closes it */
ifdef|#
directive|ifdef
name|NO_PTHREADS
DECL|member|pid
name|pid_t
name|pid
decl_stmt|;
else|#
directive|else
DECL|member|tid
name|pthread_t
name|tid
decl_stmt|;
DECL|member|proc_in
name|int
name|proc_in
decl_stmt|;
DECL|member|proc_out
name|int
name|proc_out
decl_stmt|;
endif|#
directive|endif
DECL|member|isolate_sigpipe
name|int
name|isolate_sigpipe
decl_stmt|;
block|}
struct|;
end_struct
begin_function_decl
name|int
name|start_async
parameter_list|(
name|struct
name|async
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|finish_async
parameter_list|(
name|struct
name|async
modifier|*
name|async
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|in_async
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|NORETURN
name|async_exit
parameter_list|(
name|int
name|code
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/**  * This callback should initialize the child process and preload the  * error channel if desired. The preloading of is useful if you want to  * have a message printed directly before the output of the child process.  * pp_cb is the callback cookie as passed to run_processes_parallel.  * You can store a child process specific callback cookie in pp_task_cb.  *  * Even after returning 0 to indicate that there are no more processes,  * this function will be called again until there are no more running  * child processes.  *  * Return 1 if the next child is ready to run.  * Return 0 if there are currently no more tasks to be processed.  * To send a signal to other child processes for abortion,  * return the negative signal number.  */
end_comment
begin_typedef
DECL|typedef|get_next_task_fn
typedef|typedef
name|int
function_decl|(
modifier|*
name|get_next_task_fn
function_decl|)
parameter_list|(
name|struct
name|child_process
modifier|*
name|cp
parameter_list|,
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|pp_cb
parameter_list|,
name|void
modifier|*
modifier|*
name|pp_task_cb
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/**  * This callback is called whenever there are problems starting  * a new process.  *  * You must not write to stdout or stderr in this function. Add your  * message to the strbuf out instead, which will be printed without  * messing up the output of the other parallel processes.  *  * pp_cb is the callback cookie as passed into run_processes_parallel,  * pp_task_cb is the callback cookie as passed into get_next_task_fn.  *  * Return 0 to continue the parallel processing. To abort return non zero.  * To send a signal to other child processes for abortion, return  * the negative signal number.  */
end_comment
begin_typedef
DECL|typedef|start_failure_fn
typedef|typedef
name|int
function_decl|(
modifier|*
name|start_failure_fn
function_decl|)
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|pp_cb
parameter_list|,
name|void
modifier|*
name|pp_task_cb
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/**  * This callback is called on every child process that finished processing.  *  * You must not write to stdout or stderr in this function. Add your  * message to the strbuf out instead, which will be printed without  * messing up the output of the other parallel processes.  *  * pp_cb is the callback cookie as passed into run_processes_parallel,  * pp_task_cb is the callback cookie as passed into get_next_task_fn.  *  * Return 0 to continue the parallel processing.  To abort return non zero.  * To send a signal to other child processes for abortion, return  * the negative signal number.  */
end_comment
begin_typedef
DECL|typedef|task_finished_fn
typedef|typedef
name|int
function_decl|(
modifier|*
name|task_finished_fn
function_decl|)
parameter_list|(
name|int
name|result
parameter_list|,
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|pp_cb
parameter_list|,
name|void
modifier|*
name|pp_task_cb
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/**  * Runs up to n processes at the same time. Whenever a process can be  * started, the callback get_next_task_fn is called to obtain the data  * required to start another child process.  *  * The children started via this function run in parallel. Their output  * (both stdout and stderr) is routed to stderr in a manner that output  * from different tasks does not interleave.  *  * start_failure_fn and task_finished_fn can be NULL to omit any  * special handling.  */
end_comment
begin_function_decl
name|int
name|run_processes_parallel
parameter_list|(
name|int
name|n
parameter_list|,
name|get_next_task_fn
parameter_list|,
name|start_failure_fn
parameter_list|,
name|task_finished_fn
parameter_list|,
name|void
modifier|*
name|pp_cb
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
end_unit
