begin_unit
begin_comment
comment|/* * * Copyright 2005, Lukas Sandstrom<lukass@etek.chalmers.se> * * This file is licensed under the GPL v2. * */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_decl_stmt
DECL|variable|pack_redundant_usage
specifier|static
specifier|const
name|char
name|pack_redundant_usage
index|[]
init|=
literal|"git-pack-redundant [ --verbose ] [ --alt-odb ]< --all |<.pack filename> ...>"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|load_all_packs
DECL|variable|verbose
DECL|variable|alt_odb
name|int
name|load_all_packs
init|=
literal|0
decl_stmt|,
name|verbose
init|=
literal|0
decl_stmt|,
name|alt_odb
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|llist_item
struct|struct
name|llist_item
block|{
DECL|member|next
name|struct
name|llist_item
modifier|*
name|next
decl_stmt|;
DECL|member|sha1
name|char
modifier|*
name|sha1
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|llist
struct|struct
name|llist
block|{
DECL|member|front
name|struct
name|llist_item
modifier|*
name|front
decl_stmt|;
DECL|member|back
name|struct
name|llist_item
modifier|*
name|back
decl_stmt|;
DECL|member|size
name|size_t
name|size
decl_stmt|;
block|}
DECL|variable|all_objects
modifier|*
name|all_objects
struct|;
end_struct
begin_comment
DECL|variable|all_objects
comment|/* all objects which must be present in local packfiles */
end_comment
begin_struct
DECL|struct|pack_list
struct|struct
name|pack_list
block|{
DECL|member|next
name|struct
name|pack_list
modifier|*
name|next
decl_stmt|;
DECL|member|pack
name|struct
name|packed_git
modifier|*
name|pack
decl_stmt|;
DECL|member|unique_objects
name|struct
name|llist
modifier|*
name|unique_objects
decl_stmt|;
DECL|member|all_objects
name|struct
name|llist
modifier|*
name|all_objects
decl_stmt|;
block|}
DECL|variable|local_packs
DECL|variable|altodb_packs
modifier|*
name|local_packs
init|=
name|NULL
struct|,
modifier|*
name|altodb_packs
init|=
name|NULL
struct|;
end_struct
begin_struct
DECL|struct|pll
struct|struct
name|pll
block|{
DECL|member|next
name|struct
name|pll
modifier|*
name|next
decl_stmt|;
DECL|member|pl
name|struct
name|pack_list
modifier|*
name|pl
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|llist_free
specifier|inline
name|void
name|llist_free
parameter_list|(
name|struct
name|llist
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
operator|(
name|list
operator|->
name|back
operator|=
name|list
operator|->
name|front
operator|)
condition|)
block|{
name|list
operator|->
name|front
operator|=
name|list
operator|->
name|front
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|back
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|llist_init
specifier|inline
name|void
name|llist_init
parameter_list|(
name|struct
name|llist
modifier|*
modifier|*
name|list
parameter_list|)
block|{
operator|*
name|list
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|llist
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|list
operator|)
operator|->
name|front
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|back
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|list
operator|)
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|llist_copy
name|struct
name|llist
modifier|*
name|llist_copy
parameter_list|(
name|struct
name|llist
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|llist
modifier|*
name|ret
decl_stmt|;
name|struct
name|llist_item
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|llist_init
argument_list|(
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|->
name|size
operator|=
name|list
operator|->
name|size
operator|)
operator|==
literal|0
condition|)
return|return
name|ret
return|;
name|new
operator|=
name|ret
operator|->
name|front
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|llist_item
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|sha1
operator|=
name|list
operator|->
name|front
operator|->
name|sha1
expr_stmt|;
name|old
operator|=
name|list
operator|->
name|front
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|old
condition|)
block|{
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|llist_item
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|sha1
operator|=
name|old
operator|->
name|sha1
expr_stmt|;
name|old
operator|=
name|old
operator|->
name|next
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|back
operator|=
name|new
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|llist_insert
specifier|inline
name|struct
name|llist_item
modifier|*
name|llist_insert
parameter_list|(
name|struct
name|llist
modifier|*
name|list
parameter_list|,
name|struct
name|llist_item
modifier|*
name|after
parameter_list|,
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|llist_item
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|llist_item
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|sha1
operator|=
name|sha1
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
block|{
name|new
operator|->
name|next
operator|=
name|after
operator|->
name|next
expr_stmt|;
name|after
operator|->
name|next
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|list
operator|->
name|back
condition|)
name|list
operator|->
name|back
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* insert in front */
if|if
condition|(
name|list
operator|->
name|size
operator|==
literal|0
condition|)
name|list
operator|->
name|back
operator|=
name|new
expr_stmt|;
else|else
name|new
operator|->
name|next
operator|=
name|list
operator|->
name|front
expr_stmt|;
name|list
operator|->
name|front
operator|=
name|new
expr_stmt|;
block|}
name|list
operator|->
name|size
operator|++
expr_stmt|;
return|return
name|new
return|;
block|}
end_function
begin_function
DECL|function|llist_insert_back
specifier|inline
name|struct
name|llist_item
modifier|*
name|llist_insert_back
parameter_list|(
name|struct
name|llist
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|llist_insert
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|back
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|llist_insert_sorted_unique
specifier|inline
name|struct
name|llist_item
modifier|*
name|llist_insert_sorted_unique
parameter_list|(
name|struct
name|llist
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|llist_item
modifier|*
name|hint
parameter_list|)
block|{
name|struct
name|llist_item
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
name|hint
operator|==
name|NULL
operator|)
condition|?
name|list
operator|->
name|front
else|:
name|hint
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|int
name|cmp
init|=
name|memcmp
argument_list|(
name|l
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|,
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|/* we insert before this entry */
return|return
name|llist_insert
argument_list|(
name|list
argument_list|,
name|prev
argument_list|,
name|sha1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|cmp
condition|)
block|{
comment|/* already exists */
return|return
name|l
return|;
block|}
name|prev
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
comment|/* insert at the end */
return|return
name|llist_insert_back
argument_list|(
name|list
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* returns a pointer to an item in front of sha1 */
end_comment
begin_function
DECL|function|llist_sorted_remove
specifier|inline
name|struct
name|llist_item
modifier|*
name|llist_sorted_remove
parameter_list|(
name|struct
name|llist
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|llist_item
modifier|*
name|hint
parameter_list|)
block|{
name|struct
name|llist_item
modifier|*
name|prev
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|redo_from_start
label|:
name|l
operator|=
operator|(
name|hint
operator|==
name|NULL
operator|)
condition|?
name|list
operator|->
name|front
else|:
name|hint
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|int
name|cmp
init|=
name|memcmp
argument_list|(
name|l
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|,
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
comment|/* not in list, since sorted */
return|return
name|prev
return|;
if|if
condition|(
operator|!
name|cmp
condition|)
block|{
comment|/* found */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hint
operator|!=
name|NULL
operator|&&
name|hint
operator|!=
name|list
operator|->
name|front
condition|)
block|{
comment|/* we don't know the previous element */
name|hint
operator|=
name|NULL
expr_stmt|;
goto|goto
name|redo_from_start
goto|;
block|}
name|list
operator|->
name|front
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
else|else
name|prev
operator|->
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|list
operator|->
name|back
condition|)
name|list
operator|->
name|back
operator|=
name|prev
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|list
operator|->
name|size
operator|--
expr_stmt|;
return|return
name|prev
return|;
block|}
name|prev
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function
begin_comment
comment|/* computes A\B */
end_comment
begin_function
DECL|function|llist_sorted_difference_inplace
name|void
name|llist_sorted_difference_inplace
parameter_list|(
name|struct
name|llist
modifier|*
name|A
parameter_list|,
name|struct
name|llist
modifier|*
name|B
parameter_list|)
block|{
name|struct
name|llist_item
modifier|*
name|hint
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|hint
operator|=
name|NULL
expr_stmt|;
name|b
operator|=
name|B
operator|->
name|front
expr_stmt|;
while|while
condition|(
name|b
condition|)
block|{
name|hint
operator|=
name|llist_sorted_remove
argument_list|(
name|A
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|hint
argument_list|)
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pack_list_insert
specifier|inline
name|struct
name|pack_list
modifier|*
name|pack_list_insert
parameter_list|(
name|struct
name|pack_list
modifier|*
modifier|*
name|pl
parameter_list|,
name|struct
name|pack_list
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|pack_list
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|pl
expr_stmt|;
operator|*
name|pl
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|pack_list_size
specifier|inline
name|size_t
name|pack_list_size
parameter_list|(
name|struct
name|pack_list
modifier|*
name|pl
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|ret
operator|++
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|pack_list_difference
name|struct
name|pack_list
modifier|*
name|pack_list_difference
parameter_list|(
name|struct
name|pack_list
modifier|*
name|A
parameter_list|,
name|struct
name|pack_list
modifier|*
name|B
parameter_list|)
block|{
name|struct
name|pack_list
modifier|*
name|ret
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
if|if
condition|(
name|A
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|pl
operator|=
name|B
expr_stmt|;
while|while
condition|(
name|pl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|A
operator|->
name|pack
operator|==
name|pl
operator|->
name|pack
condition|)
return|return
name|pack_list_difference
argument_list|(
name|A
operator|->
name|next
argument_list|,
name|B
argument_list|)
return|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
name|ret
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|A
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|pack_list_difference
argument_list|(
name|A
operator|->
name|next
argument_list|,
name|B
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|cmp_two_packs
name|void
name|cmp_two_packs
parameter_list|(
name|struct
name|pack_list
modifier|*
name|p1
parameter_list|,
name|struct
name|pack_list
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|p1_off
decl_stmt|,
name|p2_off
decl_stmt|;
name|void
modifier|*
name|p1_base
decl_stmt|,
modifier|*
name|p2_base
decl_stmt|;
name|struct
name|llist_item
modifier|*
name|p1_hint
init|=
name|NULL
decl_stmt|,
modifier|*
name|p2_hint
init|=
name|NULL
decl_stmt|;
name|p1_off
operator|=
name|p2_off
operator|=
literal|256
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
name|p1_base
operator|=
operator|(
name|void
operator|*
operator|)
name|p1
operator|->
name|pack
operator|->
name|index_base
expr_stmt|;
name|p2_base
operator|=
operator|(
name|void
operator|*
operator|)
name|p2
operator|->
name|pack
operator|->
name|index_base
expr_stmt|;
while|while
condition|(
name|p1_off
operator|<=
name|p1
operator|->
name|pack
operator|->
name|index_size
operator|-
literal|3
operator|*
literal|20
operator|&&
name|p2_off
operator|<=
name|p2
operator|->
name|pack
operator|->
name|index_size
operator|-
literal|3
operator|*
literal|20
condition|)
block|{
name|int
name|cmp
init|=
name|memcmp
argument_list|(
name|p1_base
operator|+
name|p1_off
argument_list|,
name|p2_base
operator|+
name|p2_off
argument_list|,
literal|20
argument_list|)
decl_stmt|;
comment|/* cmp ~ p1 - p2 */
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|p1_hint
operator|=
name|llist_sorted_remove
argument_list|(
name|p1
operator|->
name|unique_objects
argument_list|,
name|p1_base
operator|+
name|p1_off
argument_list|,
name|p1_hint
argument_list|)
expr_stmt|;
name|p2_hint
operator|=
name|llist_sorted_remove
argument_list|(
name|p2
operator|->
name|unique_objects
argument_list|,
name|p1_base
operator|+
name|p1_off
argument_list|,
name|p2_hint
argument_list|)
expr_stmt|;
name|p1_off
operator|+=
literal|24
expr_stmt|;
name|p2_off
operator|+=
literal|24
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|/* p1 has the object, p2 doesn't */
name|p1_off
operator|+=
literal|24
expr_stmt|;
block|}
else|else
block|{
comment|/* p2 has the object, p1 doesn't */
name|p2_off
operator|+=
literal|24
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* all the permutations have to be free()d at the same time,  * since they refer to each other  */
end_comment
begin_function
DECL|function|get_all_permutations
name|struct
name|pll
modifier|*
name|get_all_permutations
parameter_list|(
name|struct
name|pack_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|pll
modifier|*
name|subset
decl_stmt|,
modifier|*
name|pll
decl_stmt|,
modifier|*
name|new_pll
init|=
name|NULL
decl_stmt|;
comment|/*silence warning*/
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|list
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|new_pll
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pll
argument_list|)
argument_list|)
expr_stmt|;
name|new_pll
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_pll
operator|->
name|pl
operator|=
name|list
expr_stmt|;
return|return
name|new_pll
return|;
block|}
name|pll
operator|=
name|subset
operator|=
name|get_all_permutations
argument_list|(
name|list
operator|->
name|next
argument_list|)
expr_stmt|;
while|while
condition|(
name|pll
condition|)
block|{
name|new_pll
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pll
argument_list|)
argument_list|)
expr_stmt|;
name|new_pll
operator|->
name|next
operator|=
name|pll
operator|->
name|next
expr_stmt|;
name|pll
operator|->
name|next
operator|=
name|new_pll
expr_stmt|;
name|new_pll
operator|->
name|pl
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_pll
operator|->
name|pl
argument_list|,
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_pll
operator|->
name|pl
operator|->
name|next
operator|=
name|pll
operator|->
name|pl
expr_stmt|;
name|pll
operator|=
name|new_pll
operator|->
name|next
expr_stmt|;
block|}
comment|/* add ourself to the end */
name|new_pll
operator|->
name|next
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pll
argument_list|)
argument_list|)
expr_stmt|;
name|new_pll
operator|->
name|next
operator|->
name|pl
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_pll
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|memcpy
argument_list|(
name|new_pll
operator|->
name|next
operator|->
name|pl
argument_list|,
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pack_list
argument_list|)
argument_list|)
expr_stmt|;
name|new_pll
operator|->
name|next
operator|->
name|pl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|subset
return|;
block|}
end_function
begin_function
DECL|function|is_superset
name|int
name|is_superset
parameter_list|(
name|struct
name|pack_list
modifier|*
name|pl
parameter_list|,
name|struct
name|llist
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|llist
modifier|*
name|diff
decl_stmt|;
name|diff
operator|=
name|llist_copy
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|llist_sorted_difference_inplace
argument_list|(
name|diff
argument_list|,
name|pl
operator|->
name|all_objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* we're done */
name|llist_free
argument_list|(
name|diff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
name|llist_free
argument_list|(
name|diff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sizeof_union
name|size_t
name|sizeof_union
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p1
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p2
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|p1_off
decl_stmt|,
name|p2_off
decl_stmt|;
name|void
modifier|*
name|p1_base
decl_stmt|,
modifier|*
name|p2_base
decl_stmt|;
name|p1_off
operator|=
name|p2_off
operator|=
literal|256
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
name|p1_base
operator|=
operator|(
name|void
operator|*
operator|)
name|p1
operator|->
name|index_base
expr_stmt|;
name|p2_base
operator|=
operator|(
name|void
operator|*
operator|)
name|p2
operator|->
name|index_base
expr_stmt|;
while|while
condition|(
name|p1_off
operator|<=
name|p1
operator|->
name|index_size
operator|-
literal|3
operator|*
literal|20
operator|&&
name|p2_off
operator|<=
name|p2
operator|->
name|index_size
operator|-
literal|3
operator|*
literal|20
condition|)
block|{
name|int
name|cmp
init|=
name|memcmp
argument_list|(
name|p1_base
operator|+
name|p1_off
argument_list|,
name|p2_base
operator|+
name|p2_off
argument_list|,
literal|20
argument_list|)
decl_stmt|;
comment|/* cmp ~ p1 - p2 */
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|ret
operator|++
expr_stmt|;
name|p1_off
operator|+=
literal|24
expr_stmt|;
name|p2_off
operator|+=
literal|24
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|/* p1 has the object, p2 doesn't */
name|p1_off
operator|+=
literal|24
expr_stmt|;
block|}
else|else
block|{
comment|/* p2 has the object, p1 doesn't */
name|p2_off
operator|+=
literal|24
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/* another O(n^2) function ... */
end_comment
begin_function
DECL|function|get_pack_redundancy
name|size_t
name|get_pack_redundancy
parameter_list|(
name|struct
name|pack_list
modifier|*
name|pl
parameter_list|)
block|{
name|struct
name|pack_list
modifier|*
name|subset
decl_stmt|;
if|if
condition|(
name|pl
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|subset
operator|=
name|pl
operator|->
name|next
operator|)
condition|)
block|{
while|while
condition|(
name|subset
condition|)
block|{
name|ret
operator|+=
name|sizeof_union
argument_list|(
name|pl
operator|->
name|pack
argument_list|,
name|subset
operator|->
name|pack
argument_list|)
expr_stmt|;
name|subset
operator|=
name|subset
operator|->
name|next
expr_stmt|;
block|}
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|pack_set_bytecount
specifier|inline
name|size_t
name|pack_set_bytecount
parameter_list|(
name|struct
name|pack_list
modifier|*
name|pl
parameter_list|)
block|{
name|size_t
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|ret
operator|+=
name|pl
operator|->
name|pack
operator|->
name|pack_size
expr_stmt|;
name|ret
operator|+=
name|pl
operator|->
name|pack
operator|->
name|index_size
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|minimize
name|void
name|minimize
parameter_list|(
name|struct
name|pack_list
modifier|*
modifier|*
name|min
parameter_list|)
block|{
name|struct
name|pack_list
modifier|*
name|pl
decl_stmt|,
modifier|*
name|unique
init|=
name|NULL
decl_stmt|,
modifier|*
name|non_unique
init|=
name|NULL
decl_stmt|,
modifier|*
name|min_perm
init|=
name|NULL
decl_stmt|;
name|struct
name|pll
modifier|*
name|perm
decl_stmt|,
modifier|*
name|perm_all
decl_stmt|,
modifier|*
name|perm_ok
init|=
name|NULL
decl_stmt|,
modifier|*
name|new_perm
decl_stmt|;
name|struct
name|llist
modifier|*
name|missing
decl_stmt|;
name|size_t
name|min_perm_size
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|,
name|perm_size
decl_stmt|;
name|pl
operator|=
name|local_packs
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
if|if
condition|(
name|pl
operator|->
name|unique_objects
operator|->
name|size
condition|)
name|pack_list_insert
argument_list|(
operator|&
name|unique
argument_list|,
name|pl
argument_list|)
expr_stmt|;
else|else
name|pack_list_insert
argument_list|(
operator|&
name|non_unique
argument_list|,
name|pl
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
comment|/* find out which objects are missing from the set of unique packs */
name|missing
operator|=
name|llist_copy
argument_list|(
name|all_objects
argument_list|)
expr_stmt|;
name|pl
operator|=
name|unique
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|llist_sorted_difference_inplace
argument_list|(
name|missing
argument_list|,
name|pl
operator|->
name|all_objects
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
comment|/* return if there are no objects missing from the unique set */
if|if
condition|(
name|missing
operator|->
name|size
operator|==
literal|0
condition|)
block|{
operator|*
name|min
operator|=
name|unique
expr_stmt|;
return|return;
block|}
comment|/* find the permutations which contain all missing objects */
name|perm_all
operator|=
name|perm
operator|=
name|get_all_permutations
argument_list|(
name|non_unique
argument_list|)
expr_stmt|;
while|while
condition|(
name|perm
condition|)
block|{
if|if
condition|(
name|is_superset
argument_list|(
name|perm
operator|->
name|pl
argument_list|,
name|missing
argument_list|)
condition|)
block|{
name|new_perm
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pll
argument_list|)
argument_list|)
expr_stmt|;
name|new_perm
operator|->
name|pl
operator|=
name|perm
operator|->
name|pl
expr_stmt|;
name|new_perm
operator|->
name|next
operator|=
name|perm_ok
expr_stmt|;
name|perm_ok
operator|=
name|new_perm
expr_stmt|;
block|}
name|perm
operator|=
name|perm
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|perm_ok
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"Internal error: No complete sets found!\n"
argument_list|)
expr_stmt|;
comment|/* find the permutation with the smallest size */
name|perm
operator|=
name|perm_ok
expr_stmt|;
while|while
condition|(
name|perm
condition|)
block|{
name|perm_size
operator|=
name|pack_set_bytecount
argument_list|(
name|perm
operator|->
name|pl
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_perm_size
operator|>
name|perm_size
condition|)
block|{
name|min_perm_size
operator|=
name|perm_size
expr_stmt|;
name|min_perm
operator|=
name|perm
operator|->
name|pl
expr_stmt|;
block|}
name|perm
operator|=
name|perm
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|min
operator|=
name|min_perm
expr_stmt|;
comment|/* add the unique packs to the list */
name|pl
operator|=
name|unique
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|pack_list_insert
argument_list|(
name|min
argument_list|,
name|pl
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|load_all_objects
name|void
name|load_all_objects
parameter_list|()
block|{
name|struct
name|pack_list
modifier|*
name|pl
init|=
name|local_packs
decl_stmt|;
name|struct
name|llist_item
modifier|*
name|hint
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
name|llist_init
argument_list|(
operator|&
name|all_objects
argument_list|)
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|hint
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
name|pl
operator|->
name|all_objects
operator|->
name|front
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|hint
operator|=
name|llist_insert_sorted_unique
argument_list|(
name|all_objects
argument_list|,
name|l
operator|->
name|sha1
argument_list|,
name|hint
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
comment|/* remove objects present in remote packs */
name|pl
operator|=
name|altodb_packs
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|llist_sorted_difference_inplace
argument_list|(
name|all_objects
argument_list|,
name|pl
operator|->
name|all_objects
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* this scales like O(n^2) */
end_comment
begin_function
DECL|function|cmp_packs
name|void
name|cmp_packs
parameter_list|()
block|{
name|struct
name|pack_list
modifier|*
name|subset
decl_stmt|,
modifier|*
name|pl
init|=
name|local_packs
decl_stmt|;
while|while
condition|(
operator|(
name|subset
operator|=
name|pl
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|subset
operator|=
name|subset
operator|->
name|next
operator|)
condition|)
name|cmp_two_packs
argument_list|(
name|pl
argument_list|,
name|subset
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
name|pl
operator|=
name|altodb_packs
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|subset
operator|=
name|local_packs
expr_stmt|;
while|while
condition|(
name|subset
condition|)
block|{
name|llist_sorted_difference_inplace
argument_list|(
name|subset
operator|->
name|unique_objects
argument_list|,
name|pl
operator|->
name|all_objects
argument_list|)
expr_stmt|;
name|subset
operator|=
name|subset
operator|->
name|next
expr_stmt|;
block|}
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_pack
name|struct
name|pack_list
modifier|*
name|add_pack
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pack_list
name|l
decl_stmt|;
name|size_t
name|off
decl_stmt|;
name|void
modifier|*
name|base
decl_stmt|;
name|l
operator|.
name|pack
operator|=
name|p
expr_stmt|;
name|llist_init
argument_list|(
operator|&
name|l
operator|.
name|all_objects
argument_list|)
expr_stmt|;
name|off
operator|=
literal|256
operator|*
literal|4
operator|+
literal|4
expr_stmt|;
name|base
operator|=
operator|(
name|void
operator|*
operator|)
name|p
operator|->
name|index_base
expr_stmt|;
while|while
condition|(
name|off
operator|<=
name|p
operator|->
name|index_size
operator|-
literal|3
operator|*
literal|20
condition|)
block|{
name|llist_insert_back
argument_list|(
name|l
operator|.
name|all_objects
argument_list|,
name|base
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|24
expr_stmt|;
block|}
comment|/* this list will be pruned in cmp_two_packs later */
name|l
operator|.
name|unique_objects
operator|=
name|llist_copy
argument_list|(
name|l
operator|.
name|all_objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pack_local
condition|)
return|return
name|pack_list_insert
argument_list|(
operator|&
name|local_packs
argument_list|,
operator|&
name|l
argument_list|)
return|;
else|else
return|return
name|alt_odb
condition|?
name|pack_list_insert
argument_list|(
operator|&
name|altodb_packs
argument_list|,
operator|&
name|l
argument_list|)
else|:
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|add_pack_file
name|struct
name|pack_list
modifier|*
name|add_pack_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
init|=
name|packed_git
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|<
literal|40
condition|)
name|die
argument_list|(
literal|"Bad pack filename: %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|filename
argument_list|)
condition|)
return|return
name|add_pack
argument_list|(
name|p
argument_list|)
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|die
argument_list|(
literal|"Filename %s not found in packed_git\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|load_all
name|void
name|load_all
parameter_list|()
block|{
name|struct
name|packed_git
modifier|*
name|p
init|=
name|packed_git
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|add_pack
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pack_list
modifier|*
name|min
decl_stmt|,
modifier|*
name|red
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--all"
argument_list|)
condition|)
block|{
name|load_all_packs
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--alt-odb"
argument_list|)
condition|)
block|{
name|alt_odb
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
name|usage
argument_list|(
name|pack_redundant_usage
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|prepare_packed_git
argument_list|()
expr_stmt|;
if|if
condition|(
name|load_all_packs
condition|)
name|load_all
argument_list|()
expr_stmt|;
else|else
while|while
condition|(
operator|*
operator|(
name|argv
operator|+
name|i
operator|)
operator|!=
name|NULL
condition|)
name|add_pack_file
argument_list|(
operator|*
operator|(
name|argv
operator|+
name|i
operator|++
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_packs
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"Zero packs found!\n"
argument_list|)
expr_stmt|;
name|cmp_packs
argument_list|()
expr_stmt|;
name|load_all_objects
argument_list|()
expr_stmt|;
name|minimize
argument_list|(
operator|&
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"There are %lu packs available in alt-odbs.\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pack_list_size
argument_list|(
name|altodb_packs
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The smallest (bytewise) set of packs is:\n"
argument_list|)
expr_stmt|;
name|pl
operator|=
name|min
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|pl
operator|->
name|pack
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"containing %lu duplicate objects "
literal|"with a total size of %lukb.\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|get_pack_redundancy
argument_list|(
name|min
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pack_set_bytecount
argument_list|(
name|min
argument_list|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"A total of %lu unique objects were considered.\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|all_objects
operator|->
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Redundant packs (with indexes):\n"
argument_list|)
expr_stmt|;
block|}
name|pl
operator|=
name|red
operator|=
name|pack_list_difference
argument_list|(
name|local_packs
argument_list|,
name|min
argument_list|)
expr_stmt|;
while|while
condition|(
name|pl
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n%s\n"
argument_list|,
name|sha1_pack_index_name
argument_list|(
name|pl
operator|->
name|pack
operator|->
name|sha1
argument_list|)
argument_list|,
name|pl
operator|->
name|pack
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|pl
operator|=
name|pl
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
