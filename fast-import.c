begin_unit
begin_comment
comment|/* (See Documentation/git-fast-import.txt for maintained documentation.) Format of STDIN stream:    stream ::= cmd*;    cmd ::= new_blob         | new_commit         | new_tag         | reset_branch         | checkpoint         | progress         ;    new_blob ::= 'blob' lf     mark?     file_content;   file_content ::= data;    new_commit ::= 'commit' sp ref_str lf     mark?     ('author' (sp name)? sp '<' email '>' sp when lf)?     'committer' (sp name)? sp '<' email '>' sp when lf     commit_msg     ('from' sp committish lf)?     ('merge' sp committish lf)*     (file_change | ls)*     lf?;   commit_msg ::= data;    ls ::= 'ls' sp '"' quoted(path) '"' lf;    file_change ::= file_clr     | file_del     | file_rnm     | file_cpy     | file_obm     | file_inm;   file_clr ::= 'deleteall' lf;   file_del ::= 'D' sp path_str lf;   file_rnm ::= 'R' sp path_str sp path_str lf;   file_cpy ::= 'C' sp path_str sp path_str lf;   file_obm ::= 'M' sp mode sp (hexsha1 | idnum) sp path_str lf;   file_inm ::= 'M' sp mode sp 'inline' sp path_str lf     data;   note_obm ::= 'N' sp (hexsha1 | idnum) sp committish lf;   note_inm ::= 'N' sp 'inline' sp committish lf     data;    new_tag ::= 'tag' sp tag_str lf     'from' sp committish lf     ('tagger' (sp name)? sp '<' email '>' sp when lf)?     tag_msg;   tag_msg ::= data;    reset_branch ::= 'reset' sp ref_str lf     ('from' sp committish lf)?     lf?;    checkpoint ::= 'checkpoint' lf     lf?;    progress ::= 'progress' sp not_lf* lf     lf?;       # note: the first idnum in a stream should be 1 and subsequent      # idnums should not have gaps between values as this will cause      # the stream parser to reserve space for the gapped values.  An      # idnum can be updated in the future to a new object by issuing      # a new mark directive with the old idnum.      #   mark ::= 'mark' sp idnum lf;   data ::= (delimited_data | exact_data)     lf?;      # note: delim may be any string but must not contain lf.     # data_line may contain any data but must not be exactly     # delim.   delimited_data ::= 'data' sp '<<' delim lf     (data_line lf)*     delim lf;       # note: declen indicates the length of binary_data in bytes.      # declen does not include the lf preceding the binary data.      #   exact_data ::= 'data' sp declen lf     binary_data;       # note: quoted strings are C-style quoting supporting \c for      # common escapes of 'c' (e..g \n, \t, \\, \") or \nnn where nnn      # is the signed byte value in octal.  Note that the only      # characters which must actually be escaped to protect the      # stream formatting is: \, " and LF.  Otherwise these values      # are UTF8.      #   committish  ::= (ref_str | hexsha1 | sha1exp_str | idnum);   ref_str     ::= ref;   sha1exp_str ::= sha1exp;   tag_str     ::= tag;   path_str    ::= path    | '"' quoted(path)    '"' ;   mode        ::= '100644' | '644'                 | '100755' | '755'                 | '120000'                 ;    declen ::= # unsigned 32 bit value, ascii base10 notation;   bigint ::= # unsigned integer value, ascii base10 notation;   binary_data ::= # file content, not interpreted;    when         ::= raw_when | rfc2822_when;   raw_when     ::= ts sp tz;   rfc2822_when ::= # Valid RFC 2822 date and time;    sp ::= # ASCII space character;   lf ::= # ASCII newline (LF) character;       # note: a colon (':') must precede the numerical value assigned to      # an idnum.  This is to distinguish it from a ref or tag name as      # GIT does not permit ':' in ref or tag strings.      #   idnum   ::= ':' bigint;   path    ::= # GIT style file path, e.g. "a/b/c";   ref     ::= # GIT ref name, e.g. "refs/heads/MOZ_GECKO_EXPERIMENT";   tag     ::= # GIT tag name, e.g. "FIREFOX_1_5";   sha1exp ::= # Any valid GIT SHA1 expression;   hexsha1 ::= # SHA1 in hexadecimal format;       # note: name and email are UTF8 strings, however name must not      # contain '<' or lf and email must not contain any of the      # following: '<', '>', lf.      #   name  ::= # valid GIT author/committer name;   email ::= # valid GIT author/committer email;   ts    ::= # time since the epoch in seconds, ascii base10 notation;   tz    ::= # GIT style timezone;       # note: comments, ls and cat requests may appear anywhere      # in the input, except within a data command.  Any form      # of the data command always escapes the related input      # from comment processing.      #      # In case it is not clear, the '#' that starts the comment      # must be the first character on that line (an lf      # preceded it).      #    cat_blob ::= 'cat-blob' sp (hexsha1 | idnum) lf;   ls_tree  ::= 'ls' sp (hexsha1 | idnum) sp path_str lf;    comment ::= '#' not_lf* lf;   not_lf  ::= # Any byte that is not ASCII newline (LF); */
end_comment
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"delta.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"csum-file.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_define
DECL|macro|PACK_ID_BITS
define|#
directive|define
name|PACK_ID_BITS
value|16
end_define
begin_define
DECL|macro|MAX_PACK_ID
define|#
directive|define
name|MAX_PACK_ID
value|((1<<PACK_ID_BITS)-1)
end_define
begin_define
DECL|macro|DEPTH_BITS
define|#
directive|define
name|DEPTH_BITS
value|13
end_define
begin_define
DECL|macro|MAX_DEPTH
define|#
directive|define
name|MAX_DEPTH
value|((1<<DEPTH_BITS)-1)
end_define
begin_comment
comment|/*  * We abuse the setuid bit on directories to mean "do not delta".  */
end_comment
begin_define
DECL|macro|NO_DELTA
define|#
directive|define
name|NO_DELTA
value|S_ISUID
end_define
begin_struct
DECL|struct|object_entry
struct|struct
name|object_entry
block|{
DECL|member|idx
name|struct
name|pack_idx_entry
name|idx
decl_stmt|;
DECL|member|next
name|struct
name|object_entry
modifier|*
name|next
decl_stmt|;
DECL|member|type
name|uint32_t
name|type
range|:
name|TYPE_BITS
decl_stmt|,
DECL|member|pack_id
name|pack_id
range|:
name|PACK_ID_BITS
decl_stmt|,
DECL|member|depth
name|depth
range|:
name|DEPTH_BITS
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|object_entry_pool
struct|struct
name|object_entry_pool
block|{
DECL|member|next_pool
name|struct
name|object_entry_pool
modifier|*
name|next_pool
decl_stmt|;
DECL|member|next_free
name|struct
name|object_entry
modifier|*
name|next_free
decl_stmt|;
DECL|member|end
name|struct
name|object_entry
modifier|*
name|end
decl_stmt|;
DECL|member|entries
name|struct
name|object_entry
name|entries
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
comment|/* more */
block|}
struct|;
end_struct
begin_struct
DECL|struct|mark_set
struct|struct
name|mark_set
block|{
union|union
block|{
DECL|member|marked
name|struct
name|object_entry
modifier|*
name|marked
index|[
literal|1024
index|]
decl_stmt|;
DECL|member|sets
name|struct
name|mark_set
modifier|*
name|sets
index|[
literal|1024
index|]
decl_stmt|;
block|}
DECL|member|data
name|data
union|;
DECL|member|shift
name|unsigned
name|int
name|shift
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|last_object
struct|struct
name|last_object
block|{
DECL|member|data
name|struct
name|strbuf
name|data
decl_stmt|;
DECL|member|offset
name|off_t
name|offset
decl_stmt|;
DECL|member|depth
name|unsigned
name|int
name|depth
decl_stmt|;
DECL|member|no_swap
name|unsigned
name|no_swap
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|mem_pool
struct|struct
name|mem_pool
block|{
DECL|member|next_pool
name|struct
name|mem_pool
modifier|*
name|next_pool
decl_stmt|;
DECL|member|next_free
name|char
modifier|*
name|next_free
decl_stmt|;
DECL|member|end
name|char
modifier|*
name|end
decl_stmt|;
DECL|member|space
name|uintmax_t
name|space
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
comment|/* more */
block|}
struct|;
end_struct
begin_struct
DECL|struct|atom_str
struct|struct
name|atom_str
block|{
DECL|member|next_atom
name|struct
name|atom_str
modifier|*
name|next_atom
decl_stmt|;
DECL|member|str_len
name|unsigned
name|short
name|str_len
decl_stmt|;
DECL|member|str_dat
name|char
name|str_dat
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
comment|/* more */
block|}
struct|;
end_struct
begin_struct_decl
struct_decl|struct
name|tree_content
struct_decl|;
end_struct_decl
begin_struct
DECL|struct|tree_entry
struct|struct
name|tree_entry
block|{
DECL|member|tree
name|struct
name|tree_content
modifier|*
name|tree
decl_stmt|;
DECL|member|name
name|struct
name|atom_str
modifier|*
name|name
decl_stmt|;
DECL|struct|tree_entry_ms
struct|struct
name|tree_entry_ms
block|{
DECL|member|mode
name|uint16_t
name|mode
decl_stmt|;
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
block|}
DECL|member|versions
name|versions
index|[
literal|2
index|]
struct|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|tree_content
struct|struct
name|tree_content
block|{
DECL|member|entry_capacity
name|unsigned
name|int
name|entry_capacity
decl_stmt|;
comment|/* must match avail_tree_content */
DECL|member|entry_count
name|unsigned
name|int
name|entry_count
decl_stmt|;
DECL|member|delta_depth
name|unsigned
name|int
name|delta_depth
decl_stmt|;
DECL|member|entries
name|struct
name|tree_entry
modifier|*
name|entries
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
comment|/* more */
block|}
struct|;
end_struct
begin_struct
DECL|struct|avail_tree_content
struct|struct
name|avail_tree_content
block|{
DECL|member|entry_capacity
name|unsigned
name|int
name|entry_capacity
decl_stmt|;
comment|/* must match tree_content */
DECL|member|next_avail
name|struct
name|avail_tree_content
modifier|*
name|next_avail
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|branch
struct|struct
name|branch
block|{
DECL|member|table_next_branch
name|struct
name|branch
modifier|*
name|table_next_branch
decl_stmt|;
DECL|member|active_next_branch
name|struct
name|branch
modifier|*
name|active_next_branch
decl_stmt|;
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|branch_tree
name|struct
name|tree_entry
name|branch_tree
decl_stmt|;
DECL|member|last_commit
name|uintmax_t
name|last_commit
decl_stmt|;
DECL|member|num_notes
name|uintmax_t
name|num_notes
decl_stmt|;
DECL|member|active
name|unsigned
name|active
range|:
literal|1
decl_stmt|;
DECL|member|pack_id
name|unsigned
name|pack_id
range|:
name|PACK_ID_BITS
decl_stmt|;
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|tag
struct|struct
name|tag
block|{
DECL|member|next_tag
name|struct
name|tag
modifier|*
name|next_tag
decl_stmt|;
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|pack_id
name|unsigned
name|int
name|pack_id
decl_stmt|;
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|hash_list
struct|struct
name|hash_list
block|{
DECL|member|next
name|struct
name|hash_list
modifier|*
name|next
decl_stmt|;
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|WHENSPEC_RAW
name|WHENSPEC_RAW
init|=
literal|1
block|,
DECL|enumerator|WHENSPEC_RFC2822
name|WHENSPEC_RFC2822
block|,
DECL|enumerator|WHENSPEC_NOW
name|WHENSPEC_NOW
block|}
DECL|typedef|whenspec_type
name|whenspec_type
typedef|;
end_typedef
begin_struct
DECL|struct|recent_command
struct|struct
name|recent_command
block|{
DECL|member|prev
name|struct
name|recent_command
modifier|*
name|prev
decl_stmt|;
DECL|member|next
name|struct
name|recent_command
modifier|*
name|next
decl_stmt|;
DECL|member|buf
name|char
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Configured limits on output */
end_comment
begin_decl_stmt
DECL|variable|max_depth
specifier|static
name|unsigned
name|long
name|max_depth
init|=
literal|10
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_packsize
specifier|static
name|off_t
name|max_packsize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|force_update
specifier|static
name|int
name|force_update
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_compression_level
specifier|static
name|int
name|pack_compression_level
init|=
name|Z_DEFAULT_COMPRESSION
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_compression_seen
specifier|static
name|int
name|pack_compression_seen
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Stats and misc. counters */
end_comment
begin_decl_stmt
DECL|variable|alloc_count
specifier|static
name|uintmax_t
name|alloc_count
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|marks_set_count
specifier|static
name|uintmax_t
name|marks_set_count
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|object_count_by_type
specifier|static
name|uintmax_t
name|object_count_by_type
index|[
literal|1
operator|<<
name|TYPE_BITS
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|duplicate_count_by_type
specifier|static
name|uintmax_t
name|duplicate_count_by_type
index|[
literal|1
operator|<<
name|TYPE_BITS
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|delta_count_by_type
specifier|static
name|uintmax_t
name|delta_count_by_type
index|[
literal|1
operator|<<
name|TYPE_BITS
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|delta_count_attempts_by_type
specifier|static
name|uintmax_t
name|delta_count_attempts_by_type
index|[
literal|1
operator|<<
name|TYPE_BITS
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|object_count
specifier|static
name|unsigned
name|long
name|object_count
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_count
specifier|static
name|unsigned
name|long
name|branch_count
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_load_count
specifier|static
name|unsigned
name|long
name|branch_load_count
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|failure
specifier|static
name|int
name|failure
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_edges
specifier|static
name|FILE
modifier|*
name|pack_edges
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|show_stats
specifier|static
name|unsigned
name|int
name|show_stats
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|global_argc
specifier|static
name|int
name|global_argc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|global_argv
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|global_argv
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Memory pools */
end_comment
begin_decl_stmt
DECL|variable|mem_pool_alloc
specifier|static
name|size_t
name|mem_pool_alloc
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mem_pool
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|total_allocd
specifier|static
name|size_t
name|total_allocd
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|mem_pool
specifier|static
name|struct
name|mem_pool
modifier|*
name|mem_pool
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Atom management */
end_comment
begin_decl_stmt
DECL|variable|atom_table_sz
specifier|static
name|unsigned
name|int
name|atom_table_sz
init|=
literal|4451
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|atom_cnt
specifier|static
name|unsigned
name|int
name|atom_cnt
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|atom_table
specifier|static
name|struct
name|atom_str
modifier|*
modifier|*
name|atom_table
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* The .pack file being generated */
end_comment
begin_decl_stmt
DECL|variable|pack_idx_opts
specifier|static
name|struct
name|pack_idx_option
name|pack_idx_opts
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_id
specifier|static
name|unsigned
name|int
name|pack_id
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_file
specifier|static
name|struct
name|sha1file
modifier|*
name|pack_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_data
specifier|static
name|struct
name|packed_git
modifier|*
name|pack_data
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|all_packs
specifier|static
name|struct
name|packed_git
modifier|*
modifier|*
name|all_packs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_size
specifier|static
name|off_t
name|pack_size
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Table of objects we've written. */
end_comment
begin_decl_stmt
DECL|variable|object_entry_alloc
specifier|static
name|unsigned
name|int
name|object_entry_alloc
init|=
literal|5000
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blocks
specifier|static
name|struct
name|object_entry_pool
modifier|*
name|blocks
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|object_table
specifier|static
name|struct
name|object_entry
modifier|*
name|object_table
index|[
literal|1
operator|<<
literal|16
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|marks
specifier|static
name|struct
name|mark_set
modifier|*
name|marks
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|export_marks_file
specifier|static
specifier|const
name|char
modifier|*
name|export_marks_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|import_marks_file
specifier|static
specifier|const
name|char
modifier|*
name|import_marks_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|import_marks_file_from_stream
specifier|static
name|int
name|import_marks_file_from_stream
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|import_marks_file_ignore_missing
specifier|static
name|int
name|import_marks_file_ignore_missing
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|relative_marks_paths
specifier|static
name|int
name|relative_marks_paths
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Our last blob */
end_comment
begin_decl_stmt
DECL|variable|last_blob
specifier|static
name|struct
name|last_object
name|last_blob
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Tree management */
end_comment
begin_decl_stmt
DECL|variable|tree_entry_alloc
specifier|static
name|unsigned
name|int
name|tree_entry_alloc
init|=
literal|1000
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|avail_tree_entry
specifier|static
name|void
modifier|*
name|avail_tree_entry
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|avail_tree_table_sz
specifier|static
name|unsigned
name|int
name|avail_tree_table_sz
init|=
literal|100
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|avail_tree_table
specifier|static
name|struct
name|avail_tree_content
modifier|*
modifier|*
name|avail_tree_table
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|old_tree
specifier|static
name|struct
name|strbuf
name|old_tree
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|new_tree
specifier|static
name|struct
name|strbuf
name|new_tree
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Branch data */
end_comment
begin_decl_stmt
DECL|variable|max_active_branches
specifier|static
name|unsigned
name|long
name|max_active_branches
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cur_active_branches
specifier|static
name|unsigned
name|long
name|cur_active_branches
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_table_sz
specifier|static
name|unsigned
name|long
name|branch_table_sz
init|=
literal|1039
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_table
specifier|static
name|struct
name|branch
modifier|*
modifier|*
name|branch_table
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|active_branches
specifier|static
name|struct
name|branch
modifier|*
name|active_branches
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Tag data */
end_comment
begin_decl_stmt
DECL|variable|first_tag
specifier|static
name|struct
name|tag
modifier|*
name|first_tag
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|last_tag
specifier|static
name|struct
name|tag
modifier|*
name|last_tag
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Input stream parsing */
end_comment
begin_decl_stmt
DECL|variable|whenspec
specifier|static
name|whenspec_type
name|whenspec
init|=
name|WHENSPEC_RAW
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|command_buf
specifier|static
name|struct
name|strbuf
name|command_buf
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|unread_command_buf
specifier|static
name|int
name|unread_command_buf
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cmd_hist
specifier|static
name|struct
name|recent_command
name|cmd_hist
init|=
block|{
operator|&
name|cmd_hist
block|,
operator|&
name|cmd_hist
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cmd_tail
specifier|static
name|struct
name|recent_command
modifier|*
name|cmd_tail
init|=
operator|&
name|cmd_hist
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rc_free
specifier|static
name|struct
name|recent_command
modifier|*
name|rc_free
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cmd_save
specifier|static
name|unsigned
name|int
name|cmd_save
init|=
literal|100
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|next_mark
specifier|static
name|uintmax_t
name|next_mark
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|new_data
specifier|static
name|struct
name|strbuf
name|new_data
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|seen_data_command
specifier|static
name|int
name|seen_data_command
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|require_explicit_termination
specifier|static
name|int
name|require_explicit_termination
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Signal handling */
end_comment
begin_decl_stmt
DECL|variable|checkpoint_requested
specifier|static
specifier|volatile
name|sig_atomic_t
name|checkpoint_requested
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Where to write output of cat-blob commands */
end_comment
begin_decl_stmt
DECL|variable|cat_blob_fd
specifier|static
name|int
name|cat_blob_fd
init|=
name|STDOUT_FILENO
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|parse_argv
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|parse_cat_blob
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|parse_ls
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|write_branch_report
specifier|static
name|void
name|write_branch_report
parameter_list|(
name|FILE
modifier|*
name|rpt
parameter_list|,
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"%s:\n"
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"  status      :"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|active
condition|)
name|fputs
argument_list|(
literal|" active"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|branch_tree
operator|.
name|tree
condition|)
name|fputs
argument_list|(
literal|" loaded"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" dirty"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"  tip commit  : %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"  old tree    : %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"  cur tree    : %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"  commit clock: %"
name|PRIuMAX
literal|"\n"
argument_list|,
name|b
operator|->
name|last_commit
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  last pack   : "
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|pack_id
operator|<
name|MAX_PACK_ID
condition|)
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"%u"
argument_list|,
name|b
operator|->
name|pack_id
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|dump_marks_helper
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|uintmax_t
parameter_list|,
name|struct
name|mark_set
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|write_crash_report
specifier|static
name|void
name|write_crash_report
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|)
block|{
name|char
modifier|*
name|loc
init|=
name|git_path
argument_list|(
literal|"fast_import_crash_%"
name|PRIuMAX
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getpid
argument_list|()
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|rpt
init|=
name|fopen
argument_list|(
name|loc
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|unsigned
name|long
name|lu
decl_stmt|;
name|struct
name|recent_command
modifier|*
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|rpt
condition|)
block|{
name|error
argument_list|(
literal|"can't write crash report %s: %s"
argument_list|,
name|loc
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fast-import: dumping crash report to %s\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"fast-import crash report:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"    fast-import process: %"
name|PRIuMAX
literal|"\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"    parent process     : %"
name|PRIuMAX
literal|"\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"    at %s\n"
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DATE_LOCAL
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"fatal: "
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|err
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Most Recent Commands Before Crash\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"---------------------------------\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
for|for
control|(
name|rc
operator|=
name|cmd_hist
operator|.
name|next
init|;
name|rc
operator|!=
operator|&
name|cmd_hist
condition|;
name|rc
operator|=
name|rc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rc
operator|->
name|next
operator|==
operator|&
name|cmd_hist
condition|)
name|fputs
argument_list|(
literal|"* "
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|rc
operator|->
name|buf
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Active Branch LRU\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-----------------\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"    active_branches = %lu cur, %lu max\n"
argument_list|,
name|cur_active_branches
argument_list|,
name|max_active_branches
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  pos  clock name\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|active_branches
operator|,
name|lu
operator|=
literal|0
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|active_next_branch
control|)
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"  %2lu) %6"
name|PRIuMAX
literal|" %s\n"
argument_list|,
operator|++
name|lu
argument_list|,
name|b
operator|->
name|last_commit
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Inactive Branches\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-----------------\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
for|for
control|(
name|lu
operator|=
literal|0
init|;
name|lu
operator|<
name|branch_table_sz
condition|;
name|lu
operator|++
control|)
block|{
for|for
control|(
name|b
operator|=
name|branch_table
index|[
name|lu
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|table_next_branch
control|)
name|write_branch_report
argument_list|(
name|rpt
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_tag
condition|)
block|{
name|struct
name|tag
modifier|*
name|tg
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Annotated Tags\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"--------------\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
for|for
control|(
name|tg
operator|=
name|first_tag
init|;
name|tg
condition|;
name|tg
operator|=
name|tg
operator|->
name|next_tag
control|)
block|{
name|fputs
argument_list|(
name|sha1_to_hex
argument_list|(
name|tg
operator|->
name|sha1
argument_list|)
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tg
operator|->
name|name
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Marks\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-----\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|export_marks_file
condition|)
name|fprintf
argument_list|(
name|rpt
argument_list|,
literal|"  exported to %s\n"
argument_list|,
name|export_marks_file
argument_list|)
expr_stmt|;
else|else
name|dump_marks_helper
argument_list|(
name|rpt
argument_list|,
literal|0
argument_list|,
name|marks
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-------------------\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"END OF CRASH REPORT\n"
argument_list|,
name|rpt
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rpt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|end_packfile
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|unkeep_all_packs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|dump_marks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|die_nicely
specifier|static
name|NORETURN
name|void
name|die_nicely
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
name|va_list
name|params
parameter_list|)
block|{
specifier|static
name|int
name|zombie
decl_stmt|;
name|char
name|message
index|[
literal|2
operator|*
name|PATH_MAX
index|]
decl_stmt|;
name|vsnprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
name|err
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"fatal: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|message
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zombie
condition|)
block|{
name|zombie
operator|=
literal|1
expr_stmt|;
name|write_crash_report
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|end_packfile
argument_list|()
expr_stmt|;
name|unkeep_all_packs
argument_list|()
expr_stmt|;
name|dump_marks
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|SIGUSR1
end_ifndef
begin_comment
comment|/* Windows, for example */
end_comment
begin_function
DECL|function|set_checkpoint_signal
specifier|static
name|void
name|set_checkpoint_signal
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|checkpoint_signal
specifier|static
name|void
name|checkpoint_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|checkpoint_requested
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_checkpoint_signal
specifier|static
name|void
name|set_checkpoint_signal
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|checkpoint_signal
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|alloc_objects
specifier|static
name|void
name|alloc_objects
parameter_list|(
name|unsigned
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|object_entry_pool
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object_entry_pool
argument_list|)
operator|+
name|cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|object_entry
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|next_pool
operator|=
name|blocks
expr_stmt|;
name|b
operator|->
name|next_free
operator|=
name|b
operator|->
name|entries
expr_stmt|;
name|b
operator|->
name|end
operator|=
name|b
operator|->
name|entries
operator|+
name|cnt
expr_stmt|;
name|blocks
operator|=
name|b
expr_stmt|;
name|alloc_count
operator|+=
name|cnt
expr_stmt|;
block|}
end_function
begin_function
DECL|function|new_object
specifier|static
name|struct
name|object_entry
modifier|*
name|new_object
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|blocks
operator|->
name|next_free
operator|==
name|blocks
operator|->
name|end
condition|)
name|alloc_objects
argument_list|(
name|object_entry_alloc
argument_list|)
expr_stmt|;
name|e
operator|=
name|blocks
operator|->
name|next_free
operator|++
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|idx
operator|.
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|find_object
specifier|static
name|struct
name|object_entry
modifier|*
name|find_object
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|int
name|h
init|=
name|sha1
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|sha1
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|object_table
index|[
name|h
index|]
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|e
operator|->
name|idx
operator|.
name|sha1
argument_list|)
condition|)
return|return
name|e
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|insert_object
specifier|static
name|struct
name|object_entry
modifier|*
name|insert_object
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|int
name|h
init|=
name|sha1
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|sha1
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|e
init|=
name|object_table
index|[
name|h
index|]
decl_stmt|;
while|while
condition|(
name|e
condition|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|e
operator|->
name|idx
operator|.
name|sha1
argument_list|)
condition|)
return|return
name|e
return|;
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
name|e
operator|=
name|new_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|object_table
index|[
name|h
index|]
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|object_table
index|[
name|h
index|]
operator|=
name|e
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|hc_str
specifier|static
name|unsigned
name|int
name|hc_str
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|r
operator|=
name|r
operator|*
literal|31
operator|+
operator|*
name|s
operator|++
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|pool_alloc
specifier|static
name|void
modifier|*
name|pool_alloc
parameter_list|(
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|mem_pool
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
comment|/* round up to a 'uintmax_t' alignment */
if|if
condition|(
name|len
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|-
operator|(
name|len
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|mem_pool
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_pool
control|)
if|if
condition|(
operator|(
name|p
operator|->
name|end
operator|-
name|p
operator|->
name|next_free
operator|>=
name|len
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|p
condition|)
block|{
if|if
condition|(
name|len
operator|>=
operator|(
name|mem_pool_alloc
operator|/
literal|2
operator|)
condition|)
block|{
name|total_allocd
operator|+=
name|len
expr_stmt|;
return|return
name|xmalloc
argument_list|(
name|len
argument_list|)
return|;
block|}
name|total_allocd
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mem_pool
argument_list|)
operator|+
name|mem_pool_alloc
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mem_pool
argument_list|)
operator|+
name|mem_pool_alloc
argument_list|)
expr_stmt|;
name|p
operator|->
name|next_pool
operator|=
name|mem_pool
expr_stmt|;
name|p
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|space
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|p
operator|->
name|next_free
operator|+
name|mem_pool_alloc
expr_stmt|;
name|mem_pool
operator|=
name|p
expr_stmt|;
block|}
name|r
operator|=
name|p
operator|->
name|next_free
expr_stmt|;
name|p
operator|->
name|next_free
operator|+=
name|len
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|pool_calloc
specifier|static
name|void
modifier|*
name|pool_calloc
parameter_list|(
name|size_t
name|count
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|len
init|=
name|count
operator|*
name|size
decl_stmt|;
name|void
modifier|*
name|r
init|=
name|pool_alloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|pool_strdup
specifier|static
name|char
modifier|*
name|pool_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|r
init|=
name|pool_alloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|insert_mark
specifier|static
name|void
name|insert_mark
parameter_list|(
name|uintmax_t
name|idnum
parameter_list|,
name|struct
name|object_entry
modifier|*
name|oe
parameter_list|)
block|{
name|struct
name|mark_set
modifier|*
name|s
init|=
name|marks
decl_stmt|;
while|while
condition|(
operator|(
name|idnum
operator|>>
name|s
operator|->
name|shift
operator|)
operator|>=
literal|1024
condition|)
block|{
name|s
operator|=
name|pool_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mark_set
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|shift
operator|=
name|marks
operator|->
name|shift
operator|+
literal|10
expr_stmt|;
name|s
operator|->
name|data
operator|.
name|sets
index|[
literal|0
index|]
operator|=
name|marks
expr_stmt|;
name|marks
operator|=
name|s
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|->
name|shift
condition|)
block|{
name|uintmax_t
name|i
init|=
name|idnum
operator|>>
name|s
operator|->
name|shift
decl_stmt|;
name|idnum
operator|-=
name|i
operator|<<
name|s
operator|->
name|shift
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|data
operator|.
name|sets
index|[
name|i
index|]
condition|)
block|{
name|s
operator|->
name|data
operator|.
name|sets
index|[
name|i
index|]
operator|=
name|pool_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mark_set
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|data
operator|.
name|sets
index|[
name|i
index|]
operator|->
name|shift
operator|=
name|s
operator|->
name|shift
operator|-
literal|10
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|data
operator|.
name|sets
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|data
operator|.
name|marked
index|[
name|idnum
index|]
condition|)
name|marks_set_count
operator|++
expr_stmt|;
name|s
operator|->
name|data
operator|.
name|marked
index|[
name|idnum
index|]
operator|=
name|oe
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_mark
specifier|static
name|struct
name|object_entry
modifier|*
name|find_mark
parameter_list|(
name|uintmax_t
name|idnum
parameter_list|)
block|{
name|uintmax_t
name|orig_idnum
init|=
name|idnum
decl_stmt|;
name|struct
name|mark_set
modifier|*
name|s
init|=
name|marks
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|oe
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|idnum
operator|>>
name|s
operator|->
name|shift
operator|)
operator|<
literal|1024
condition|)
block|{
while|while
condition|(
name|s
operator|&&
name|s
operator|->
name|shift
condition|)
block|{
name|uintmax_t
name|i
init|=
name|idnum
operator|>>
name|s
operator|->
name|shift
decl_stmt|;
name|idnum
operator|-=
name|i
operator|<<
name|s
operator|->
name|shift
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|data
operator|.
name|sets
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
name|oe
operator|=
name|s
operator|->
name|data
operator|.
name|marked
index|[
name|idnum
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oe
condition|)
name|die
argument_list|(
literal|"mark :%"
name|PRIuMAX
literal|" not declared"
argument_list|,
name|orig_idnum
argument_list|)
expr_stmt|;
return|return
name|oe
return|;
block|}
end_function
begin_function
DECL|function|to_atom
specifier|static
name|struct
name|atom_str
modifier|*
name|to_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|unsigned
name|short
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|hc
init|=
name|hc_str
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
operator|%
name|atom_table_sz
decl_stmt|;
name|struct
name|atom_str
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|atom_table
index|[
name|hc
index|]
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next_atom
control|)
if|if
condition|(
name|c
operator|->
name|str_len
operator|==
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|c
operator|->
name|str_dat
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|c
return|;
name|c
operator|=
name|pool_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|atom_str
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|str_len
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|c
operator|->
name|str_dat
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|c
operator|->
name|str_dat
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|next_atom
operator|=
name|atom_table
index|[
name|hc
index|]
expr_stmt|;
name|atom_table
index|[
name|hc
index|]
operator|=
name|c
expr_stmt|;
name|atom_cnt
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|lookup_branch
specifier|static
name|struct
name|branch
modifier|*
name|lookup_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|hc
init|=
name|hc_str
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|%
name|branch_table_sz
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|branch_table
index|[
name|hc
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|table_next_branch
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
condition|)
return|return
name|b
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|new_branch
specifier|static
name|struct
name|branch
modifier|*
name|new_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|hc
init|=
name|hc_str
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|%
name|branch_table_sz
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
init|=
name|lookup_branch
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
name|die
argument_list|(
literal|"Invalid attempt to create duplicate branch: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_refname_format
argument_list|(
name|name
argument_list|,
name|REFNAME_ALLOW_ONELEVEL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Branch name doesn't conform to GIT standards: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|b
operator|=
name|pool_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|branch
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|name
operator|=
name|pool_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|b
operator|->
name|table_next_branch
operator|=
name|branch_table
index|[
name|hc
index|]
expr_stmt|;
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|mode
operator|=
name|S_IFDIR
expr_stmt|;
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|S_IFDIR
expr_stmt|;
name|b
operator|->
name|num_notes
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|pack_id
operator|=
name|MAX_PACK_ID
expr_stmt|;
name|branch_table
index|[
name|hc
index|]
operator|=
name|b
expr_stmt|;
name|branch_count
operator|++
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|hc_entries
specifier|static
name|unsigned
name|int
name|hc_entries
parameter_list|(
name|unsigned
name|int
name|cnt
parameter_list|)
block|{
name|cnt
operator|=
name|cnt
operator|&
literal|7
condition|?
operator|(
name|cnt
operator|/
literal|8
operator|)
operator|+
literal|1
else|:
name|cnt
operator|/
literal|8
expr_stmt|;
return|return
name|cnt
operator|<
name|avail_tree_table_sz
condition|?
name|cnt
else|:
name|avail_tree_table_sz
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|new_tree_content
specifier|static
name|struct
name|tree_content
modifier|*
name|new_tree_content
parameter_list|(
name|unsigned
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|avail_tree_content
modifier|*
name|f
decl_stmt|,
modifier|*
name|l
init|=
name|NULL
decl_stmt|;
name|struct
name|tree_content
modifier|*
name|t
decl_stmt|;
name|unsigned
name|int
name|hc
init|=
name|hc_entries
argument_list|(
name|cnt
argument_list|)
decl_stmt|;
for|for
control|(
name|f
operator|=
name|avail_tree_table
index|[
name|hc
index|]
init|;
name|f
condition|;
name|l
operator|=
name|f
operator|,
name|f
operator|=
name|f
operator|->
name|next_avail
control|)
if|if
condition|(
name|f
operator|->
name|entry_capacity
operator|>=
name|cnt
condition|)
break|break;
if|if
condition|(
name|f
condition|)
block|{
if|if
condition|(
name|l
condition|)
name|l
operator|->
name|next_avail
operator|=
name|f
operator|->
name|next_avail
expr_stmt|;
else|else
name|avail_tree_table
index|[
name|hc
index|]
operator|=
name|f
operator|->
name|next_avail
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|cnt
operator|&
literal|7
condition|?
operator|(
operator|(
name|cnt
operator|/
literal|8
operator|)
operator|+
literal|1
operator|)
operator|*
literal|8
else|:
name|cnt
expr_stmt|;
name|f
operator|=
name|pool_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|t
operator|->
name|entries
index|[
literal|0
index|]
argument_list|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
name|f
operator|->
name|entry_capacity
operator|=
name|cnt
expr_stmt|;
block|}
name|t
operator|=
operator|(
expr|struct
name|tree_content
operator|*
operator|)
name|f
expr_stmt|;
name|t
operator|->
name|entry_count
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|delta_depth
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|release_tree_entry
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|release_tree_content
specifier|static
name|void
name|release_tree_content
parameter_list|(
name|struct
name|tree_content
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|avail_tree_content
modifier|*
name|f
init|=
operator|(
expr|struct
name|avail_tree_content
operator|*
operator|)
name|t
decl_stmt|;
name|unsigned
name|int
name|hc
init|=
name|hc_entries
argument_list|(
name|f
operator|->
name|entry_capacity
argument_list|)
decl_stmt|;
name|f
operator|->
name|next_avail
operator|=
name|avail_tree_table
index|[
name|hc
index|]
expr_stmt|;
name|avail_tree_table
index|[
name|hc
index|]
operator|=
name|f
expr_stmt|;
block|}
end_function
begin_function
DECL|function|release_tree_content_recursive
specifier|static
name|void
name|release_tree_content_recursive
parameter_list|(
name|struct
name|tree_content
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
name|release_tree_entry
argument_list|(
name|t
operator|->
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|release_tree_content
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grow_tree_content
specifier|static
name|struct
name|tree_content
modifier|*
name|grow_tree_content
parameter_list|(
name|struct
name|tree_content
modifier|*
name|t
parameter_list|,
name|int
name|amt
parameter_list|)
block|{
name|struct
name|tree_content
modifier|*
name|r
init|=
name|new_tree_content
argument_list|(
name|t
operator|->
name|entry_count
operator|+
name|amt
argument_list|)
decl_stmt|;
name|r
operator|->
name|entry_count
operator|=
name|t
operator|->
name|entry_count
expr_stmt|;
name|r
operator|->
name|delta_depth
operator|=
name|t
operator|->
name|delta_depth
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|entries
argument_list|,
name|t
operator|->
name|entries
argument_list|,
name|t
operator|->
name|entry_count
operator|*
sizeof|sizeof
argument_list|(
name|t
operator|->
name|entries
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|release_tree_content
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|new_tree_entry
specifier|static
name|struct
name|tree_entry
modifier|*
name|new_tree_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tree_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|avail_tree_entry
condition|)
block|{
name|unsigned
name|int
name|n
init|=
name|tree_entry_alloc
decl_stmt|;
name|total_allocd
operator|+=
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tree_entry
argument_list|)
expr_stmt|;
name|avail_tree_entry
operator|=
name|e
operator|=
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tree_entry
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|1
condition|)
block|{
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|e
operator|)
operator|=
name|e
operator|+
literal|1
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|e
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
name|e
operator|=
name|avail_tree_entry
expr_stmt|;
name|avail_tree_entry
operator|=
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|e
operator|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|release_tree_entry
specifier|static
name|void
name|release_tree_entry
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|tree
condition|)
name|release_tree_content_recursive
argument_list|(
name|e
operator|->
name|tree
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|e
operator|)
operator|=
name|avail_tree_entry
expr_stmt|;
name|avail_tree_entry
operator|=
name|e
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dup_tree_content
specifier|static
name|struct
name|tree_content
modifier|*
name|dup_tree_content
parameter_list|(
name|struct
name|tree_content
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|tree_content
modifier|*
name|d
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|NULL
return|;
name|d
operator|=
name|new_tree_content
argument_list|(
name|s
operator|->
name|entry_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
name|s
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
name|b
operator|=
name|new_tree_entry
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|tree
operator|&&
name|is_null_sha1
argument_list|(
name|b
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
condition|)
name|b
operator|->
name|tree
operator|=
name|dup_tree_content
argument_list|(
name|a
operator|->
name|tree
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tree
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|entries
index|[
name|i
index|]
operator|=
name|b
expr_stmt|;
block|}
name|d
operator|->
name|entry_count
operator|=
name|s
operator|->
name|entry_count
expr_stmt|;
name|d
operator|->
name|delta_depth
operator|=
name|s
operator|->
name|delta_depth
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|start_packfile
specifier|static
name|void
name|start_packfile
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|tmp_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|struct
name|pack_header
name|hdr
decl_stmt|;
name|int
name|pack_fd
decl_stmt|;
name|pack_fd
operator|=
name|odb_mkstemp
argument_list|(
name|tmp_file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_file
argument_list|)
argument_list|,
literal|"pack/tmp_pack_XXXXXX"
argument_list|)
expr_stmt|;
name|p
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|tmp_file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|tmp_file
argument_list|)
expr_stmt|;
name|p
operator|->
name|pack_fd
operator|=
name|pack_fd
expr_stmt|;
name|p
operator|->
name|do_not_close
operator|=
literal|1
expr_stmt|;
name|pack_file
operator|=
name|sha1fd
argument_list|(
name|pack_fd
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|hdr_signature
operator|=
name|htonl
argument_list|(
name|PACK_SIGNATURE
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|hdr_version
operator|=
name|htonl
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|hdr_entries
operator|=
literal|0
expr_stmt|;
name|sha1write
argument_list|(
name|pack_file
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|pack_data
operator|=
name|p
expr_stmt|;
name|pack_size
operator|=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|object_count
operator|=
literal|0
expr_stmt|;
name|all_packs
operator|=
name|xrealloc
argument_list|(
name|all_packs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|all_packs
argument_list|)
operator|*
operator|(
name|pack_id
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|all_packs
index|[
name|pack_id
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function
begin_function
DECL|function|create_index
specifier|static
specifier|const
name|char
modifier|*
name|create_index
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmpfile
decl_stmt|;
name|struct
name|pack_idx_entry
modifier|*
modifier|*
name|idx
decl_stmt|,
modifier|*
modifier|*
name|c
decl_stmt|,
modifier|*
modifier|*
name|last
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|object_entry_pool
modifier|*
name|o
decl_stmt|;
comment|/* Build the table of object IDs. */
name|idx
operator|=
name|xmalloc
argument_list|(
name|object_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|idx
expr_stmt|;
for|for
control|(
name|o
operator|=
name|blocks
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next_pool
control|)
for|for
control|(
name|e
operator|=
name|o
operator|->
name|next_free
init|;
name|e
operator|--
operator|!=
name|o
operator|->
name|entries
condition|;
control|)
if|if
condition|(
name|pack_id
operator|==
name|e
operator|->
name|pack_id
condition|)
operator|*
name|c
operator|++
operator|=
operator|&
name|e
operator|->
name|idx
expr_stmt|;
name|last
operator|=
name|idx
operator|+
name|object_count
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|last
condition|)
name|die
argument_list|(
literal|"internal consistency error creating the index"
argument_list|)
expr_stmt|;
name|tmpfile
operator|=
name|write_idx_file
argument_list|(
name|NULL
argument_list|,
name|idx
argument_list|,
name|object_count
argument_list|,
operator|&
name|pack_idx_opts
argument_list|,
name|pack_data
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
name|tmpfile
return|;
block|}
end_function
begin_function
DECL|function|keep_pack
specifier|static
name|char
modifier|*
name|keep_pack
parameter_list|(
specifier|const
name|char
modifier|*
name|curr_index_name
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|keep_msg
init|=
literal|"fast-import"
decl_stmt|;
name|int
name|keep_fd
decl_stmt|;
name|keep_fd
operator|=
name|odb_pack_keep
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|pack_data
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"cannot create keep file"
argument_list|)
expr_stmt|;
name|write_or_die
argument_list|(
name|keep_fd
argument_list|,
name|keep_msg
argument_list|,
name|strlen
argument_list|(
name|keep_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|keep_fd
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"failed to write keep file"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s/pack/pack-%s.pack"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|,
name|sha1_to_hex
argument_list|(
name|pack_data
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_temp_to_file
argument_list|(
name|pack_data
operator|->
name|pack_name
argument_list|,
name|name
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot store pack file"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s/pack/pack-%s.idx"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|,
name|sha1_to_hex
argument_list|(
name|pack_data
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_temp_to_file
argument_list|(
name|curr_index_name
argument_list|,
name|name
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot store index file"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|curr_index_name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|unkeep_all_packs
specifier|static
name|void
name|unkeep_all_packs
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|pack_id
condition|;
name|k
operator|++
control|)
block|{
name|struct
name|packed_git
modifier|*
name|p
init|=
name|all_packs
index|[
name|k
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s/pack/pack-%s.keep"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|unlink_or_warn
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|end_packfile
specifier|static
name|void
name|end_packfile
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|old_p
init|=
name|pack_data
decl_stmt|,
modifier|*
name|new_p
decl_stmt|;
name|clear_delta_base_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|object_count
condition|)
block|{
name|unsigned
name|char
name|cur_pack_sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|idx_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|close_pack_windows
argument_list|(
name|pack_data
argument_list|)
expr_stmt|;
name|sha1close
argument_list|(
name|pack_file
argument_list|,
name|cur_pack_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixup_pack_header_footer
argument_list|(
name|pack_data
operator|->
name|pack_fd
argument_list|,
name|pack_data
operator|->
name|sha1
argument_list|,
name|pack_data
operator|->
name|pack_name
argument_list|,
name|object_count
argument_list|,
name|cur_pack_sha1
argument_list|,
name|pack_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pack_data
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|idx_name
operator|=
name|keep_pack
argument_list|(
name|create_index
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Register the packfile with core git's machinery. */
name|new_p
operator|=
name|add_packed_git
argument_list|(
name|idx_name
argument_list|,
name|strlen
argument_list|(
name|idx_name
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_p
condition|)
name|die
argument_list|(
literal|"core git rejected index %s"
argument_list|,
name|idx_name
argument_list|)
expr_stmt|;
name|all_packs
index|[
name|pack_id
index|]
operator|=
name|new_p
expr_stmt|;
name|install_packed_git
argument_list|(
name|new_p
argument_list|)
expr_stmt|;
comment|/* Print the boundary */
if|if
condition|(
name|pack_edges
condition|)
block|{
name|fprintf
argument_list|(
name|pack_edges
argument_list|,
literal|"%s:"
argument_list|,
name|new_p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|branch_table_sz
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|b
operator|=
name|branch_table
index|[
name|i
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|table_next_branch
control|)
block|{
if|if
condition|(
name|b
operator|->
name|pack_id
operator|==
name|pack_id
condition|)
name|fprintf
argument_list|(
name|pack_edges
argument_list|,
literal|" %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|first_tag
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next_tag
control|)
block|{
if|if
condition|(
name|t
operator|->
name|pack_id
operator|==
name|pack_id
condition|)
name|fprintf
argument_list|(
name|pack_edges
argument_list|,
literal|" %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|t
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|pack_edges
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pack_edges
argument_list|)
expr_stmt|;
block|}
name|pack_id
operator|++
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|old_p
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|unlink_or_warn
argument_list|(
name|old_p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old_p
argument_list|)
expr_stmt|;
comment|/* We can't carry a delta across packfiles. */
name|strbuf_release
argument_list|(
operator|&
name|last_blob
operator|.
name|data
argument_list|)
expr_stmt|;
name|last_blob
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|last_blob
operator|.
name|depth
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cycle_packfile
specifier|static
name|void
name|cycle_packfile
parameter_list|(
name|void
parameter_list|)
block|{
name|end_packfile
argument_list|()
expr_stmt|;
name|start_packfile
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|store_object
specifier|static
name|int
name|store_object
parameter_list|(
name|enum
name|object_type
name|type
parameter_list|,
name|struct
name|strbuf
modifier|*
name|dat
parameter_list|,
name|struct
name|last_object
modifier|*
name|last
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1out
parameter_list|,
name|uintmax_t
name|mark
parameter_list|)
block|{
name|void
modifier|*
name|out
decl_stmt|,
modifier|*
name|delta
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|e
decl_stmt|;
name|unsigned
name|char
name|hdr
index|[
literal|96
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|long
name|hdrlen
decl_stmt|,
name|deltalen
decl_stmt|;
name|git_SHA_CTX
name|c
decl_stmt|;
name|git_zstream
name|s
decl_stmt|;
name|hdrlen
operator|=
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dat
operator|->
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
name|git_SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|dat
operator|->
name|buf
argument_list|,
name|dat
operator|->
name|len
argument_list|)
expr_stmt|;
name|git_SHA1_Final
argument_list|(
name|sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1out
condition|)
name|hashcpy
argument_list|(
name|sha1out
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|e
operator|=
name|insert_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
condition|)
name|insert_mark
argument_list|(
name|mark
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|idx
operator|.
name|offset
condition|)
block|{
name|duplicate_count_by_type
index|[
name|type
index|]
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|find_sha1_pack
argument_list|(
name|sha1
argument_list|,
name|packed_git
argument_list|)
condition|)
block|{
name|e
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|e
operator|->
name|pack_id
operator|=
name|MAX_PACK_ID
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
comment|/* just not zero! */
name|duplicate_count_by_type
index|[
name|type
index|]
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|last
operator|&&
name|last
operator|->
name|data
operator|.
name|buf
operator|&&
name|last
operator|->
name|depth
operator|<
name|max_depth
operator|&&
name|dat
operator|->
name|len
operator|>
literal|20
condition|)
block|{
name|delta_count_attempts_by_type
index|[
name|type
index|]
operator|++
expr_stmt|;
name|delta
operator|=
name|diff_delta
argument_list|(
name|last
operator|->
name|data
operator|.
name|buf
argument_list|,
name|last
operator|->
name|data
operator|.
name|len
argument_list|,
name|dat
operator|->
name|buf
argument_list|,
name|dat
operator|->
name|len
argument_list|,
operator|&
name|deltalen
argument_list|,
name|dat
operator|->
name|len
operator|-
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
name|delta
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|git_deflate_init
argument_list|(
operator|&
name|s
argument_list|,
name|pack_compression_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|s
operator|.
name|next_in
operator|=
name|delta
expr_stmt|;
name|s
operator|.
name|avail_in
operator|=
name|deltalen
expr_stmt|;
block|}
else|else
block|{
name|s
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|dat
operator|->
name|buf
expr_stmt|;
name|s
operator|.
name|avail_in
operator|=
name|dat
operator|->
name|len
expr_stmt|;
block|}
name|s
operator|.
name|avail_out
operator|=
name|git_deflate_bound
argument_list|(
operator|&
name|s
argument_list|,
name|s
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|s
operator|.
name|next_out
operator|=
name|out
operator|=
name|xmalloc
argument_list|(
name|s
operator|.
name|avail_out
argument_list|)
expr_stmt|;
while|while
condition|(
name|git_deflate
argument_list|(
operator|&
name|s
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
empty_stmt|;
comment|/* nothing */
name|git_deflate_end
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Determine if we should auto-checkpoint. */
if|if
condition|(
operator|(
name|max_packsize
operator|&&
operator|(
name|pack_size
operator|+
literal|60
operator|+
name|s
operator|.
name|total_out
operator|)
operator|>
name|max_packsize
operator|)
operator|||
operator|(
name|pack_size
operator|+
literal|60
operator|+
name|s
operator|.
name|total_out
operator|)
operator|<
name|pack_size
condition|)
block|{
comment|/* This new object needs to *not* have the current pack_id. */
name|e
operator|->
name|pack_id
operator|=
name|pack_id
operator|+
literal|1
expr_stmt|;
name|cycle_packfile
argument_list|()
expr_stmt|;
comment|/* We cannot carry a delta into the new pack. */
if|if
condition|(
name|delta
condition|)
block|{
name|free
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|git_deflate_init
argument_list|(
operator|&
name|s
argument_list|,
name|pack_compression_level
argument_list|)
expr_stmt|;
name|s
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|dat
operator|->
name|buf
expr_stmt|;
name|s
operator|.
name|avail_in
operator|=
name|dat
operator|->
name|len
expr_stmt|;
name|s
operator|.
name|avail_out
operator|=
name|git_deflate_bound
argument_list|(
operator|&
name|s
argument_list|,
name|s
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|s
operator|.
name|next_out
operator|=
name|out
operator|=
name|xrealloc
argument_list|(
name|out
argument_list|,
name|s
operator|.
name|avail_out
argument_list|)
expr_stmt|;
while|while
condition|(
name|git_deflate
argument_list|(
operator|&
name|s
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
empty_stmt|;
comment|/* nothing */
name|git_deflate_end
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|e
operator|->
name|pack_id
operator|=
name|pack_id
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|offset
operator|=
name|pack_size
expr_stmt|;
name|object_count
operator|++
expr_stmt|;
name|object_count_by_type
index|[
name|type
index|]
operator|++
expr_stmt|;
name|crc32_begin
argument_list|(
name|pack_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|off_t
name|ofs
init|=
name|e
operator|->
name|idx
operator|.
name|offset
operator|-
name|last
operator|->
name|offset
decl_stmt|;
name|unsigned
name|pos
init|=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
literal|1
decl_stmt|;
name|delta_count_by_type
index|[
name|type
index|]
operator|++
expr_stmt|;
name|e
operator|->
name|depth
operator|=
name|last
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
name|hdrlen
operator|=
name|encode_in_pack_object_header
argument_list|(
name|OBJ_OFS_DELTA
argument_list|,
name|deltalen
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|sha1write
argument_list|(
name|pack_file
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|pack_size
operator|+=
name|hdrlen
expr_stmt|;
name|hdr
index|[
name|pos
index|]
operator|=
name|ofs
operator|&
literal|127
expr_stmt|;
while|while
condition|(
name|ofs
operator|>>=
literal|7
condition|)
name|hdr
index|[
operator|--
name|pos
index|]
operator|=
literal|128
operator||
operator|(
operator|--
name|ofs
operator|&
literal|127
operator|)
expr_stmt|;
name|sha1write
argument_list|(
name|pack_file
argument_list|,
name|hdr
operator|+
name|pos
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
name|pos
argument_list|)
expr_stmt|;
name|pack_size
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
name|pos
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|hdrlen
operator|=
name|encode_in_pack_object_header
argument_list|(
name|type
argument_list|,
name|dat
operator|->
name|len
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|sha1write
argument_list|(
name|pack_file
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|pack_size
operator|+=
name|hdrlen
expr_stmt|;
block|}
name|sha1write
argument_list|(
name|pack_file
argument_list|,
name|out
argument_list|,
name|s
operator|.
name|total_out
argument_list|)
expr_stmt|;
name|pack_size
operator|+=
name|s
operator|.
name|total_out
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|crc32
operator|=
name|crc32_end
argument_list|(
name|pack_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
if|if
condition|(
name|last
operator|->
name|no_swap
condition|)
block|{
name|last
operator|->
name|data
operator|=
operator|*
name|dat
expr_stmt|;
block|}
else|else
block|{
name|strbuf_swap
argument_list|(
operator|&
name|last
operator|->
name|data
argument_list|,
name|dat
argument_list|)
expr_stmt|;
block|}
name|last
operator|->
name|offset
operator|=
name|e
operator|->
name|idx
operator|.
name|offset
expr_stmt|;
name|last
operator|->
name|depth
operator|=
name|e
operator|->
name|depth
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|truncate_pack
specifier|static
name|void
name|truncate_pack
parameter_list|(
name|struct
name|sha1file_checkpoint
modifier|*
name|checkpoint
parameter_list|)
block|{
if|if
condition|(
name|sha1file_truncate
argument_list|(
name|pack_file
argument_list|,
name|checkpoint
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"cannot truncate pack to skip duplicate"
argument_list|)
expr_stmt|;
name|pack_size
operator|=
name|checkpoint
operator|->
name|offset
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stream_blob
specifier|static
name|void
name|stream_blob
parameter_list|(
name|uintmax_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1out
parameter_list|,
name|uintmax_t
name|mark
parameter_list|)
block|{
name|size_t
name|in_sz
init|=
literal|64
operator|*
literal|1024
decl_stmt|,
name|out_sz
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
name|unsigned
name|char
modifier|*
name|in_buf
init|=
name|xmalloc
argument_list|(
name|in_sz
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|out_buf
init|=
name|xmalloc
argument_list|(
name|out_sz
argument_list|)
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|e
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|long
name|hdrlen
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|git_SHA_CTX
name|c
decl_stmt|;
name|git_zstream
name|s
decl_stmt|;
name|struct
name|sha1file_checkpoint
name|checkpoint
decl_stmt|;
name|int
name|status
init|=
name|Z_OK
decl_stmt|;
comment|/* Determine if we should auto-checkpoint. */
if|if
condition|(
operator|(
name|max_packsize
operator|&&
operator|(
name|pack_size
operator|+
literal|60
operator|+
name|len
operator|)
operator|>
name|max_packsize
operator|)
operator|||
operator|(
name|pack_size
operator|+
literal|60
operator|+
name|len
operator|)
operator|<
name|pack_size
condition|)
name|cycle_packfile
argument_list|()
expr_stmt|;
name|sha1file_checkpoint
argument_list|(
name|pack_file
argument_list|,
operator|&
name|checkpoint
argument_list|)
expr_stmt|;
name|offset
operator|=
name|checkpoint
operator|.
name|offset
expr_stmt|;
name|hdrlen
operator|=
name|snprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out_buf
argument_list|,
name|out_sz
argument_list|,
literal|"blob %"
name|PRIuMAX
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|out_sz
operator|<=
name|hdrlen
condition|)
name|die
argument_list|(
literal|"impossibly large object header"
argument_list|)
expr_stmt|;
name|git_SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|out_buf
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|crc32_begin
argument_list|(
name|pack_file
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|git_deflate_init
argument_list|(
operator|&
name|s
argument_list|,
name|pack_compression_level
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|encode_in_pack_object_header
argument_list|(
name|OBJ_BLOB
argument_list|,
name|len
argument_list|,
name|out_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_sz
operator|<=
name|hdrlen
condition|)
name|die
argument_list|(
literal|"impossibly large object header"
argument_list|)
expr_stmt|;
name|s
operator|.
name|next_out
operator|=
name|out_buf
operator|+
name|hdrlen
expr_stmt|;
name|s
operator|.
name|avail_out
operator|=
name|out_sz
operator|-
name|hdrlen
expr_stmt|;
while|while
condition|(
name|status
operator|!=
name|Z_STREAM_END
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|len
operator|&&
operator|!
name|s
operator|.
name|avail_in
condition|)
block|{
name|size_t
name|cnt
init|=
name|in_sz
operator|<
name|len
condition|?
name|in_sz
else|:
operator|(
name|size_t
operator|)
name|len
decl_stmt|;
name|size_t
name|n
init|=
name|fread
argument_list|(
name|in_buf
argument_list|,
literal|1
argument_list|,
name|cnt
argument_list|,
name|stdin
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|&&
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|die
argument_list|(
literal|"EOF in data (%"
name|PRIuMAX
literal|" bytes remaining)"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|in_buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|.
name|next_in
operator|=
name|in_buf
expr_stmt|;
name|s
operator|.
name|avail_in
operator|=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
name|status
operator|=
name|git_deflate
argument_list|(
operator|&
name|s
argument_list|,
name|len
condition|?
literal|0
else|:
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|avail_out
operator|||
name|status
operator|==
name|Z_STREAM_END
condition|)
block|{
name|size_t
name|n
init|=
name|s
operator|.
name|next_out
operator|-
name|out_buf
decl_stmt|;
name|sha1write
argument_list|(
name|pack_file
argument_list|,
name|out_buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|pack_size
operator|+=
name|n
expr_stmt|;
name|s
operator|.
name|next_out
operator|=
name|out_buf
expr_stmt|;
name|s
operator|.
name|avail_out
operator|=
name|out_sz
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|Z_OK
case|:
case|case
name|Z_BUF_ERROR
case|:
case|case
name|Z_STREAM_END
case|:
continue|continue;
default|default:
name|die
argument_list|(
literal|"unexpected deflate failure: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|git_deflate_end
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|git_SHA1_Final
argument_list|(
name|sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1out
condition|)
name|hashcpy
argument_list|(
name|sha1out
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|e
operator|=
name|insert_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
condition|)
name|insert_mark
argument_list|(
name|mark
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|idx
operator|.
name|offset
condition|)
block|{
name|duplicate_count_by_type
index|[
name|OBJ_BLOB
index|]
operator|++
expr_stmt|;
name|truncate_pack
argument_list|(
operator|&
name|checkpoint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|find_sha1_pack
argument_list|(
name|sha1
argument_list|,
name|packed_git
argument_list|)
condition|)
block|{
name|e
operator|->
name|type
operator|=
name|OBJ_BLOB
expr_stmt|;
name|e
operator|->
name|pack_id
operator|=
name|MAX_PACK_ID
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
comment|/* just not zero! */
name|duplicate_count_by_type
index|[
name|OBJ_BLOB
index|]
operator|++
expr_stmt|;
name|truncate_pack
argument_list|(
operator|&
name|checkpoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|OBJ_BLOB
expr_stmt|;
name|e
operator|->
name|pack_id
operator|=
name|pack_id
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|crc32
operator|=
name|crc32_end
argument_list|(
name|pack_file
argument_list|)
expr_stmt|;
name|object_count
operator|++
expr_stmt|;
name|object_count_by_type
index|[
name|OBJ_BLOB
index|]
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|in_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out_buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* All calls must be guarded by find_object() or find_mark() to  * ensure the 'struct object_entry' passed was written by this  * process instance.  We unpack the entry by the offset, avoiding  * the need for the corresponding .idx file.  This unpacking rule  * works because we only use OBJ_REF_DELTA within the packfiles  * created by fast-import.  *  * oe must not be NULL.  Such an oe usually comes from giving  * an unknown SHA-1 to find_object() or an undefined mark to  * find_mark().  Callers must test for this condition and use  * the standard read_sha1_file() when it happens.  *  * oe->pack_id must not be MAX_PACK_ID.  Such an oe is usually from  * find_mark(), where the mark was reloaded from an existing marks  * file and is referencing an object that this fast-import process  * instance did not write out to a packfile.  Callers must test for  * this condition and use read_sha1_file() instead.  */
end_comment
begin_function
DECL|function|gfi_unpack_entry
specifier|static
name|void
modifier|*
name|gfi_unpack_entry
parameter_list|(
name|struct
name|object_entry
modifier|*
name|oe
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
init|=
name|all_packs
index|[
name|oe
operator|->
name|pack_id
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pack_data
operator|&&
name|p
operator|->
name|pack_size
operator|<
operator|(
name|pack_size
operator|+
literal|20
operator|)
condition|)
block|{
comment|/* The object is stored in the packfile we are writing to 		 * and we have modified it since the last time we scanned 		 * back to read a previously written object.  If an old 		 * window covered [p->pack_size, p->pack_size + 20) its 		 * data is stale and is not valid.  Closing all windows 		 * and updating the packfile length ensures we can read 		 * the newly written data. 		 */
name|close_pack_windows
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sha1flush
argument_list|(
name|pack_file
argument_list|)
expr_stmt|;
comment|/* We have to offer 20 bytes additional on the end of 		 * the packfile as the core unpacker code assumes the 		 * footer is present at the file end and must promise 		 * at least 20 bytes within any window it maps.  But 		 * we don't actually create the footer here. 		 */
name|p
operator|->
name|pack_size
operator|=
name|pack_size
operator|+
literal|20
expr_stmt|;
block|}
return|return
name|unpack_entry
argument_list|(
name|p
argument_list|,
name|oe
operator|->
name|idx
operator|.
name|offset
argument_list|,
operator|&
name|type
argument_list|,
name|sizep
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_mode
specifier|static
specifier|const
name|char
modifier|*
name|get_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint16_t
modifier|*
name|modep
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|uint16_t
name|mode
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'7'
condition|)
return|return
name|NULL
return|;
name|mode
operator|=
operator|(
name|mode
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
operator|*
name|modep
operator|=
name|mode
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_function
DECL|function|load_tree
specifier|static
name|void
name|load_tree
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|sha1
init|=
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|myoe
decl_stmt|;
name|struct
name|tree_content
modifier|*
name|t
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|root
operator|->
name|tree
operator|=
name|t
operator|=
name|new_tree_content
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
condition|)
return|return;
name|myoe
operator|=
name|find_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|myoe
operator|&&
name|myoe
operator|->
name|pack_id
operator|!=
name|MAX_PACK_ID
condition|)
block|{
if|if
condition|(
name|myoe
operator|->
name|type
operator|!=
name|OBJ_TREE
condition|)
name|die
argument_list|(
literal|"Not a tree: %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|delta_depth
operator|=
name|myoe
operator|->
name|depth
expr_stmt|;
name|buf
operator|=
name|gfi_unpack_entry
argument_list|(
name|myoe
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"Can't load tree %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
name|type
operator|!=
name|OBJ_TREE
condition|)
name|die
argument_list|(
literal|"Can't load tree %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|c
operator|!=
operator|(
name|buf
operator|+
name|size
operator|)
condition|)
block|{
name|struct
name|tree_entry
modifier|*
name|e
init|=
name|new_tree_entry
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|entry_count
operator|==
name|t
operator|->
name|entry_capacity
condition|)
name|root
operator|->
name|tree
operator|=
name|t
operator|=
name|grow_tree_content
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|entry_count
argument_list|)
expr_stmt|;
name|t
operator|->
name|entries
index|[
name|t
operator|->
name|entry_count
operator|++
index|]
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|tree
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
name|get_mode
argument_list|(
name|c
argument_list|,
operator|&
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|die
argument_list|(
literal|"Corrupt mode in %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
operator|=
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|e
operator|->
name|name
operator|=
name|to_atom
argument_list|(
name|c
argument_list|,
name|strlen
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|+=
name|e
operator|->
name|name
operator|->
name|str_len
operator|+
literal|1
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|+=
literal|20
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tecmp0
specifier|static
name|int
name|tecmp0
parameter_list|(
specifier|const
name|void
modifier|*
name|_a
parameter_list|,
specifier|const
name|void
modifier|*
name|_b
parameter_list|)
block|{
name|struct
name|tree_entry
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
expr|struct
name|tree_entry
operator|*
operator|*
operator|)
name|_a
operator|)
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
expr|struct
name|tree_entry
operator|*
operator|*
operator|)
name|_b
operator|)
decl_stmt|;
return|return
name|base_name_compare
argument_list|(
name|a
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|a
operator|->
name|name
operator|->
name|str_len
argument_list|,
name|a
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
argument_list|,
name|b
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|b
operator|->
name|name
operator|->
name|str_len
argument_list|,
name|b
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|tecmp1
specifier|static
name|int
name|tecmp1
parameter_list|(
specifier|const
name|void
modifier|*
name|_a
parameter_list|,
specifier|const
name|void
modifier|*
name|_b
parameter_list|)
block|{
name|struct
name|tree_entry
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
expr|struct
name|tree_entry
operator|*
operator|*
operator|)
name|_a
operator|)
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
expr|struct
name|tree_entry
operator|*
operator|*
operator|)
name|_b
operator|)
decl_stmt|;
return|return
name|base_name_compare
argument_list|(
name|a
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|a
operator|->
name|name
operator|->
name|str_len
argument_list|,
name|a
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|,
name|b
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|b
operator|->
name|name
operator|->
name|str_len
argument_list|,
name|b
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|mktree
specifier|static
name|void
name|mktree
parameter_list|(
name|struct
name|tree_content
modifier|*
name|t
parameter_list|,
name|int
name|v
parameter_list|,
name|struct
name|strbuf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|maxlen
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
name|qsort
argument_list|(
name|t
operator|->
name|entries
argument_list|,
name|t
operator|->
name|entry_count
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|entries
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|tecmp0
argument_list|)
expr_stmt|;
else|else
name|qsort
argument_list|(
name|t
operator|->
name|entries
argument_list|,
name|t
operator|->
name|entry_count
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|entries
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|tecmp1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|entries
index|[
name|i
index|]
operator|->
name|versions
index|[
name|v
index|]
operator|.
name|mode
condition|)
name|maxlen
operator|+=
name|t
operator|->
name|entries
index|[
name|i
index|]
operator|->
name|name
operator|->
name|str_len
operator|+
literal|34
expr_stmt|;
block|}
name|strbuf_reset
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|strbuf_grow
argument_list|(
name|b
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tree_entry
modifier|*
name|e
init|=
name|t
operator|->
name|entries
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|versions
index|[
name|v
index|]
operator|.
name|mode
condition|)
continue|continue;
name|strbuf_addf
argument_list|(
name|b
argument_list|,
literal|"%o %s%c"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|e
operator|->
name|versions
index|[
name|v
index|]
operator|.
name|mode
operator|&
operator|~
name|NO_DELTA
argument_list|)
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_dat
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|b
argument_list|,
name|e
operator|->
name|versions
index|[
name|v
index|]
operator|.
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|store_tree
specifier|static
name|void
name|store_tree
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|tree_content
modifier|*
name|t
init|=
name|root
operator|->
name|tree
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|del
decl_stmt|;
name|struct
name|last_object
name|lo
init|=
block|{
name|STRBUF_INIT
block|,
literal|0
block|,
literal|0
block|,
comment|/* no_swap */
literal|1
block|}
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|le
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|is_null_sha1
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|entries
index|[
name|i
index|]
operator|->
name|tree
condition|)
name|store_tree
argument_list|(
name|t
operator|->
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|root
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
operator|&
name|NO_DELTA
operator|)
condition|)
name|le
operator|=
name|find_object
argument_list|(
name|root
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|root
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
operator|&&
name|le
operator|&&
name|le
operator|->
name|pack_id
operator|==
name|pack_id
condition|)
block|{
name|mktree
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
operator|&
name|old_tree
argument_list|)
expr_stmt|;
name|lo
operator|.
name|data
operator|=
name|old_tree
expr_stmt|;
name|lo
operator|.
name|offset
operator|=
name|le
operator|->
name|idx
operator|.
name|offset
expr_stmt|;
name|lo
operator|.
name|depth
operator|=
name|t
operator|->
name|delta_depth
expr_stmt|;
block|}
name|mktree
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
operator|&
name|new_tree
argument_list|)
expr_stmt|;
name|store_object
argument_list|(
name|OBJ_TREE
argument_list|,
operator|&
name|new_tree
argument_list|,
operator|&
name|lo
argument_list|,
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|delta_depth
operator|=
name|lo
operator|.
name|depth
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|del
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|tree_entry
modifier|*
name|e
init|=
name|t
operator|->
name|entries
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
condition|)
block|{
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
operator|=
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|,
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|t
operator|->
name|entries
index|[
name|j
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|release_tree_entry
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|del
operator|++
expr_stmt|;
block|}
block|}
name|t
operator|->
name|entry_count
operator|-=
name|del
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tree_content_replace
specifier|static
name|void
name|tree_content_replace
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|uint16_t
name|mode
parameter_list|,
name|struct
name|tree_content
modifier|*
name|newtree
parameter_list|)
block|{
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|die
argument_list|(
literal|"Root cannot be a non-directory"
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|root
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|tree
condition|)
name|release_tree_content_recursive
argument_list|(
name|root
operator|->
name|tree
argument_list|)
expr_stmt|;
name|root
operator|->
name|tree
operator|=
name|newtree
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tree_content_set
specifier|static
name|int
name|tree_content_set
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|uint16_t
name|mode
parameter_list|,
name|struct
name|tree_content
modifier|*
name|subtree
parameter_list|)
block|{
name|struct
name|tree_content
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|e
decl_stmt|;
name|slash1
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash1
condition|)
name|n
operator|=
name|slash1
operator|-
name|p
expr_stmt|;
else|else
name|n
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|die
argument_list|(
literal|"Empty path component found in input"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slash1
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
operator|&&
name|subtree
condition|)
name|die
argument_list|(
literal|"Non-directories cannot have subtrees"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|tree
condition|)
name|load_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|t
operator|=
name|root
operator|->
name|tree
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|t
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|name
operator|->
name|str_len
operator|==
name|n
operator|&&
operator|!
name|strncmp_icase
argument_list|(
name|p
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|slash1
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
operator|&&
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|==
name|mode
operator|&&
operator|!
name|hashcmp
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tree
condition|)
name|release_tree_content_recursive
argument_list|(
name|e
operator|->
name|tree
argument_list|)
expr_stmt|;
name|e
operator|->
name|tree
operator|=
name|subtree
expr_stmt|;
comment|/* 				 * We need to leave e->versions[0].sha1 alone 				 * to avoid modifying the preimage tree used 				 * when writing out the parent directory. 				 * But after replacing the subdir with a 				 * completely different one, it's not a good 				 * delta base any more, and besides, we've 				 * thrown away the tree entries needed to 				 * make a delta against it. 				 * 				 * So let's just explicitly disable deltas 				 * for the subtree. 				 */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
argument_list|)
condition|)
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
operator||=
name|NO_DELTA
expr_stmt|;
name|hashclr
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
condition|)
block|{
name|e
operator|->
name|tree
operator|=
name|new_tree_content
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|S_IFDIR
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|tree
condition|)
name|load_tree
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_content_set
argument_list|(
name|e
argument_list|,
name|slash1
operator|+
literal|1
argument_list|,
name|sha1
argument_list|,
name|mode
argument_list|,
name|subtree
argument_list|)
condition|)
block|{
name|hashclr
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|entry_count
operator|==
name|t
operator|->
name|entry_capacity
condition|)
name|root
operator|->
name|tree
operator|=
name|t
operator|=
name|grow_tree_content
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|entry_count
argument_list|)
expr_stmt|;
name|e
operator|=
name|new_tree_entry
argument_list|()
expr_stmt|;
name|e
operator|->
name|name
operator|=
name|to_atom
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|hashclr
argument_list|(
name|e
operator|->
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|t
operator|->
name|entries
index|[
name|t
operator|->
name|entry_count
operator|++
index|]
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|slash1
condition|)
block|{
name|e
operator|->
name|tree
operator|=
name|new_tree_content
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|S_IFDIR
expr_stmt|;
name|tree_content_set
argument_list|(
name|e
argument_list|,
name|slash1
operator|+
literal|1
argument_list|,
name|sha1
argument_list|,
name|mode
argument_list|,
name|subtree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|tree
operator|=
name|subtree
expr_stmt|;
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
name|hashclr
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|tree_content_remove
specifier|static
name|int
name|tree_content_remove
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|tree_entry
modifier|*
name|backup_leaf
parameter_list|)
block|{
name|struct
name|tree_content
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|e
decl_stmt|;
name|slash1
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash1
condition|)
name|n
operator|=
name|slash1
operator|-
name|p
expr_stmt|;
else|else
name|n
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|tree
condition|)
name|load_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|t
operator|=
name|root
operator|->
name|tree
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|t
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|name
operator|->
name|str_len
operator|==
name|n
operator|&&
operator|!
name|strncmp_icase
argument_list|(
name|p
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|slash1
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
condition|)
comment|/* 				 * If p names a file in some subdirectory, and a 				 * file or symlink matching the name of the 				 * parent directory of p exists, then p cannot 				 * exist and need not be deleted. 				 */
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|slash1
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
condition|)
goto|goto
name|del_entry
goto|;
if|if
condition|(
operator|!
name|e
operator|->
name|tree
condition|)
name|load_tree
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_content_remove
argument_list|(
name|e
argument_list|,
name|slash1
operator|+
literal|1
argument_list|,
name|backup_leaf
argument_list|)
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|e
operator|->
name|tree
operator|->
name|entry_count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|e
operator|->
name|tree
operator|->
name|entries
index|[
name|n
index|]
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
condition|)
block|{
name|hashclr
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|backup_leaf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|del_entry
goto|;
block|}
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
name|del_entry
label|:
if|if
condition|(
name|backup_leaf
condition|)
name|memcpy
argument_list|(
name|backup_leaf
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|backup_leaf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|tree
condition|)
name|release_tree_content_recursive
argument_list|(
name|e
operator|->
name|tree
argument_list|)
expr_stmt|;
name|e
operator|->
name|tree
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|hashclr
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|tree_content_get
specifier|static
name|int
name|tree_content_get
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|tree_entry
modifier|*
name|leaf
parameter_list|)
block|{
name|struct
name|tree_content
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|e
decl_stmt|;
name|slash1
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash1
condition|)
name|n
operator|=
name|slash1
operator|-
name|p
expr_stmt|;
else|else
name|n
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|tree
condition|)
name|load_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|t
operator|=
name|root
operator|->
name|tree
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|t
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|name
operator|->
name|str_len
operator|==
name|n
operator|&&
operator|!
name|strncmp_icase
argument_list|(
name|p
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|slash1
condition|)
block|{
name|memcpy
argument_list|(
name|leaf
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|leaf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tree
operator|&&
name|is_null_sha1
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
condition|)
name|leaf
operator|->
name|tree
operator|=
name|dup_tree_content
argument_list|(
name|e
operator|->
name|tree
argument_list|)
expr_stmt|;
else|else
name|leaf
operator|->
name|tree
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|e
operator|->
name|tree
condition|)
name|load_tree
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|tree_content_get
argument_list|(
name|e
argument_list|,
name|slash1
operator|+
literal|1
argument_list|,
name|leaf
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|update_branch
specifier|static
name|int
name|update_branch
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"fast-import"
decl_stmt|;
name|struct
name|ref_lock
modifier|*
name|lock
decl_stmt|;
name|unsigned
name|char
name|old_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|read_ref
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|old_sha1
argument_list|)
condition|)
name|hashclr
argument_list|(
name|old_sha1
argument_list|)
expr_stmt|;
name|lock
operator|=
name|lock_any_ref_for_update
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|old_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
name|error
argument_list|(
literal|"Unable to lock %s"
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|force_update
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|old_sha1
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|old_cmit
decl_stmt|,
modifier|*
name|new_cmit
decl_stmt|;
name|old_cmit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|old_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_cmit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_cmit
operator|||
operator|!
name|new_cmit
condition|)
block|{
name|unlock_ref
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Branch %s is missing commits."
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|in_merge_bases
argument_list|(
name|old_cmit
argument_list|,
operator|&
name|new_cmit
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unlock_ref
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Not updating %s"
literal|" (new tip %s does not contain %s)"
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|old_sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|write_ref_sha1
argument_list|(
name|lock
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|msg
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"Unable to update %s"
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|dump_branches
specifier|static
name|void
name|dump_branches
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|branch_table_sz
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|b
operator|=
name|branch_table
index|[
name|i
index|]
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|table_next_branch
control|)
name|failure
operator||=
name|update_branch
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|dump_tags
specifier|static
name|void
name|dump_tags
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"fast-import"
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|struct
name|ref_lock
modifier|*
name|lock
decl_stmt|;
name|char
name|ref_name
index|[
name|PATH_MAX
index|]
decl_stmt|;
for|for
control|(
name|t
operator|=
name|first_tag
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next_tag
control|)
block|{
name|sprintf
argument_list|(
name|ref_name
argument_list|,
literal|"tags/%s"
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
name|lock
operator|=
name|lock_ref_sha1
argument_list|(
name|ref_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|||
name|write_ref_sha1
argument_list|(
name|lock
argument_list|,
name|t
operator|->
name|sha1
argument_list|,
name|msg
argument_list|)
operator|<
literal|0
condition|)
name|failure
operator||=
name|error
argument_list|(
literal|"Unable to update %s"
argument_list|,
name|ref_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|dump_marks_helper
specifier|static
name|void
name|dump_marks_helper
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|uintmax_t
name|base
parameter_list|,
name|struct
name|mark_set
modifier|*
name|m
parameter_list|)
block|{
name|uintmax_t
name|k
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|shift
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|1024
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|data
operator|.
name|sets
index|[
name|k
index|]
condition|)
name|dump_marks_helper
argument_list|(
name|f
argument_list|,
name|base
operator|+
operator|(
name|k
operator|<<
name|m
operator|->
name|shift
operator|)
argument_list|,
name|m
operator|->
name|data
operator|.
name|sets
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|1024
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|data
operator|.
name|marked
index|[
name|k
index|]
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|":%"
name|PRIuMAX
literal|" %s\n"
argument_list|,
name|base
operator|+
name|k
argument_list|,
name|sha1_to_hex
argument_list|(
name|m
operator|->
name|data
operator|.
name|marked
index|[
name|k
index|]
operator|->
name|idx
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|dump_marks
specifier|static
name|void
name|dump_marks
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|lock_file
name|mark_lock
decl_stmt|;
name|int
name|mark_fd
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|export_marks_file
condition|)
return|return;
name|mark_fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|mark_lock
argument_list|,
name|export_marks_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_fd
operator|<
literal|0
condition|)
block|{
name|failure
operator||=
name|error
argument_list|(
literal|"Unable to write marks file %s: %s"
argument_list|,
name|export_marks_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|fdopen
argument_list|(
name|mark_fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|mark_lock
argument_list|)
expr_stmt|;
name|failure
operator||=
name|error
argument_list|(
literal|"Unable to write marks file %s: %s"
argument_list|,
name|export_marks_file
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Since the lock file was fdopen()'ed, it should not be close()'ed. 	 * Assign -1 to the lock file descriptor so that commit_lock_file() 	 * won't try to close() it. 	 */
name|mark_lock
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|dump_marks_helper
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|marks
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
operator|||
name|fclose
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|mark_lock
argument_list|)
expr_stmt|;
name|failure
operator||=
name|error
argument_list|(
literal|"Unable to write marks file %s: %s"
argument_list|,
name|export_marks_file
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|commit_lock_file
argument_list|(
operator|&
name|mark_lock
argument_list|)
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|mark_lock
argument_list|)
expr_stmt|;
name|failure
operator||=
name|error
argument_list|(
literal|"Unable to commit marks file %s: %s"
argument_list|,
name|export_marks_file
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function
begin_function
DECL|function|read_marks
specifier|static
name|void
name|read_marks
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|line
index|[
literal|512
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|import_marks_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|import_marks_file_ignore_missing
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
return|return;
comment|/* Marks file does not exist */
else|else
name|die_errno
argument_list|(
literal|"cannot read '%s'"
argument_list|,
name|import_marks_file
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|uintmax_t
name|mark
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|e
decl_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|':'
operator|||
operator|!
name|end
condition|)
name|die
argument_list|(
literal|"corrupt mark line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|mark
operator|=
name|strtoumax
argument_list|(
name|line
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mark
operator|||
name|end
operator|==
name|line
operator|+
literal|1
operator|||
operator|*
name|end
operator|!=
literal|' '
operator|||
name|get_sha1
argument_list|(
name|end
operator|+
literal|1
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"corrupt mark line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|e
operator|=
name|find_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
name|enum
name|object_type
name|type
init|=
name|sha1_object_info
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"object not found: %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|insert_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|e
operator|->
name|pack_id
operator|=
name|MAX_PACK_ID
expr_stmt|;
name|e
operator|->
name|idx
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
comment|/* just not zero! */
block|}
name|insert_mark
argument_list|(
name|mark
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_next_command
specifier|static
name|int
name|read_next_command
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|stdin_eof
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stdin_eof
condition|)
block|{
name|unread_command_buf
operator|=
literal|0
expr_stmt|;
return|return
name|EOF
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|unread_command_buf
condition|)
block|{
name|unread_command_buf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|recent_command
modifier|*
name|rc
decl_stmt|;
name|strbuf_detach
argument_list|(
operator|&
name|command_buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stdin_eof
operator|=
name|strbuf_getline
argument_list|(
operator|&
name|command_buf
argument_list|,
name|stdin
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdin_eof
condition|)
return|return
name|EOF
return|;
if|if
condition|(
operator|!
name|seen_data_command
operator|&&
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"feature "
argument_list|)
operator|&&
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"option "
argument_list|)
condition|)
block|{
name|parse_argv
argument_list|()
expr_stmt|;
block|}
name|rc
operator|=
name|rc_free
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|rc_free
operator|=
name|rc
operator|->
name|next
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|cmd_hist
operator|.
name|next
expr_stmt|;
name|cmd_hist
operator|.
name|next
operator|=
name|rc
operator|->
name|next
expr_stmt|;
name|cmd_hist
operator|.
name|next
operator|->
name|prev
operator|=
operator|&
name|cmd_hist
expr_stmt|;
name|free
argument_list|(
name|rc
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|rc
operator|->
name|buf
operator|=
name|command_buf
operator|.
name|buf
expr_stmt|;
name|rc
operator|->
name|prev
operator|=
name|cmd_tail
expr_stmt|;
name|rc
operator|->
name|next
operator|=
name|cmd_hist
operator|.
name|prev
expr_stmt|;
name|rc
operator|->
name|prev
operator|->
name|next
operator|=
name|rc
expr_stmt|;
name|cmd_tail
operator|=
name|rc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"cat-blob "
argument_list|)
condition|)
block|{
name|parse_cat_blob
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|command_buf
operator|.
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|skip_optional_lf
specifier|static
name|void
name|skip_optional_lf
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|term_char
init|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
if|if
condition|(
name|term_char
operator|!=
literal|'\n'
operator|&&
name|term_char
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|term_char
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_mark
specifier|static
name|void
name|parse_mark
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"mark :"
argument_list|)
condition|)
block|{
name|next_mark
operator|=
name|strtoumax
argument_list|(
name|command_buf
operator|.
name|buf
operator|+
literal|6
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
block|}
else|else
name|next_mark
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_data
specifier|static
name|int
name|parse_data
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|uintmax_t
name|limit
parameter_list|,
name|uintmax_t
modifier|*
name|len_res
parameter_list|)
block|{
name|strbuf_reset
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"data "
argument_list|)
condition|)
name|die
argument_list|(
literal|"Expected 'data n' command, found: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
operator|+
literal|5
argument_list|,
literal|"<<"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|term
init|=
name|xstrdup
argument_list|(
name|command_buf
operator|.
name|buf
operator|+
literal|5
operator|+
literal|2
argument_list|)
decl_stmt|;
name|size_t
name|term_len
init|=
name|command_buf
operator|.
name|len
operator|-
literal|5
operator|-
literal|2
decl_stmt|;
name|strbuf_detach
argument_list|(
operator|&
name|command_buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|command_buf
argument_list|,
name|stdin
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|EOF
condition|)
name|die
argument_list|(
literal|"EOF in data (terminator '%s' not found)"
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|term_len
operator|==
name|command_buf
operator|.
name|len
operator|&&
operator|!
name|strcmp
argument_list|(
name|term
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
condition|)
break|break;
name|strbuf_addbuf
argument_list|(
name|sb
argument_list|,
operator|&
name|command_buf
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uintmax_t
name|len
init|=
name|strtoumax
argument_list|(
name|command_buf
operator|.
name|buf
operator|+
literal|5
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|size_t
name|n
init|=
literal|0
decl_stmt|,
name|length
init|=
operator|(
name|size_t
operator|)
name|len
decl_stmt|;
if|if
condition|(
name|limit
operator|&&
name|limit
operator|<
name|len
condition|)
block|{
operator|*
name|len_res
operator|=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|length
operator|<
name|len
condition|)
name|die
argument_list|(
literal|"data is too large to use in this context"
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|length
condition|)
block|{
name|size_t
name|s
init|=
name|strbuf_fread
argument_list|(
name|sb
argument_list|,
name|length
operator|-
name|n
argument_list|,
name|stdin
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|&&
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|die
argument_list|(
literal|"EOF in data (%lu bytes remaining)"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|length
operator|-
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
name|s
expr_stmt|;
block|}
block|}
name|skip_optional_lf
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|validate_raw_date
specifier|static
name|int
name|validate_raw_date
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|result
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|orig_src
init|=
name|src
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|long
name|num
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|num
operator|=
name|strtoul
argument_list|(
name|src
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* NEEDSWORK: perhaps check for reasonable values? */
if|if
condition|(
name|errno
operator|||
name|endp
operator|==
name|src
operator|||
operator|*
name|endp
operator|!=
literal|' '
condition|)
return|return
operator|-
literal|1
return|;
name|src
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|'-'
operator|&&
operator|*
name|src
operator|!=
literal|'+'
condition|)
return|return
operator|-
literal|1
return|;
name|num
operator|=
name|strtoul
argument_list|(
name|src
operator|+
literal|1
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
name|endp
operator|==
name|src
operator|+
literal|1
operator|||
operator|*
name|endp
operator|||
operator|(
name|endp
operator|-
name|orig_src
operator|)
operator|>=
name|maxlen
operator|||
literal|1400
operator|<
name|num
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_ident
specifier|static
name|char
modifier|*
name|parse_ident
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ltgt
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
name|char
modifier|*
name|ident
decl_stmt|;
comment|/* ensure there is a space delimiter even if there is no name */
if|if
condition|(
operator|*
name|buf
operator|==
literal|'<'
condition|)
operator|--
name|buf
expr_stmt|;
name|ltgt
operator|=
name|buf
operator|+
name|strcspn
argument_list|(
name|buf
argument_list|,
literal|"<>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ltgt
operator|!=
literal|'<'
condition|)
name|die
argument_list|(
literal|"Missing< in ident string: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltgt
operator|!=
name|buf
operator|&&
name|ltgt
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"Missing space before< in ident string: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ltgt
operator|=
name|ltgt
operator|+
literal|1
operator|+
name|strcspn
argument_list|(
name|ltgt
operator|+
literal|1
argument_list|,
literal|"<>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ltgt
operator|!=
literal|'>'
condition|)
name|die
argument_list|(
literal|"Missing> in ident string: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ltgt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ltgt
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"Missing space after> in ident string: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ltgt
operator|++
expr_stmt|;
name|name_len
operator|=
name|ltgt
operator|-
name|buf
expr_stmt|;
name|ident
operator|=
name|xmalloc
argument_list|(
name|name_len
operator|+
literal|24
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ident
argument_list|,
name|buf
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|whenspec
condition|)
block|{
case|case
name|WHENSPEC_RAW
case|:
if|if
condition|(
name|validate_raw_date
argument_list|(
name|ltgt
argument_list|,
name|ident
operator|+
name|name_len
argument_list|,
literal|24
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Invalid raw date \"%s\" in ident: %s"
argument_list|,
name|ltgt
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHENSPEC_RFC2822
case|:
if|if
condition|(
name|parse_date
argument_list|(
name|ltgt
argument_list|,
name|ident
operator|+
name|name_len
argument_list|,
literal|24
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Invalid rfc2822 date \"%s\" in ident: %s"
argument_list|,
name|ltgt
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHENSPEC_NOW
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"now"
argument_list|,
name|ltgt
argument_list|)
condition|)
name|die
argument_list|(
literal|"Date in ident must be 'now': %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|datestamp
argument_list|(
name|ident
operator|+
name|name_len
argument_list|,
literal|24
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ident
return|;
block|}
end_function
begin_function
DECL|function|parse_and_store_blob
specifier|static
name|void
name|parse_and_store_blob
parameter_list|(
name|struct
name|last_object
modifier|*
name|last
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1out
parameter_list|,
name|uintmax_t
name|mark
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|uintmax_t
name|len
decl_stmt|;
if|if
condition|(
name|parse_data
argument_list|(
operator|&
name|buf
argument_list|,
name|big_file_threshold
argument_list|,
operator|&
name|len
argument_list|)
condition|)
name|store_object
argument_list|(
name|OBJ_BLOB
argument_list|,
operator|&
name|buf
argument_list|,
name|last
argument_list|,
name|sha1out
argument_list|,
name|mark
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|last
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|last
operator|->
name|data
argument_list|)
expr_stmt|;
name|last
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|last
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
block|}
name|stream_blob
argument_list|(
name|len
argument_list|,
name|sha1out
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|skip_optional_lf
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parse_new_blob
specifier|static
name|void
name|parse_new_blob
parameter_list|(
name|void
parameter_list|)
block|{
name|read_next_command
argument_list|()
expr_stmt|;
name|parse_mark
argument_list|()
expr_stmt|;
name|parse_and_store_blob
argument_list|(
operator|&
name|last_blob
argument_list|,
name|NULL
argument_list|,
name|next_mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unload_one_branch
specifier|static
name|void
name|unload_one_branch
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|cur_active_branches
operator|&&
name|cur_active_branches
operator|>=
name|max_active_branches
condition|)
block|{
name|uintmax_t
name|min_commit
init|=
name|ULONG_MAX
decl_stmt|;
name|struct
name|branch
modifier|*
name|e
decl_stmt|,
modifier|*
name|l
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|active_branches
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|active_next_branch
control|)
block|{
if|if
condition|(
name|e
operator|->
name|last_commit
operator|<
name|min_commit
condition|)
block|{
name|p
operator|=
name|l
expr_stmt|;
name|min_commit
operator|=
name|e
operator|->
name|last_commit
expr_stmt|;
block|}
name|l
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
block|{
name|e
operator|=
name|p
operator|->
name|active_next_branch
expr_stmt|;
name|p
operator|->
name|active_next_branch
operator|=
name|e
operator|->
name|active_next_branch
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|active_branches
expr_stmt|;
name|active_branches
operator|=
name|e
operator|->
name|active_next_branch
expr_stmt|;
block|}
name|e
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|active_next_branch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|branch_tree
operator|.
name|tree
condition|)
block|{
name|release_tree_content_recursive
argument_list|(
name|e
operator|->
name|branch_tree
operator|.
name|tree
argument_list|)
expr_stmt|;
name|e
operator|->
name|branch_tree
operator|.
name|tree
operator|=
name|NULL
expr_stmt|;
block|}
name|cur_active_branches
operator|--
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|load_branch
specifier|static
name|void
name|load_branch
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
name|load_tree
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|active
condition|)
block|{
name|b
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|active_next_branch
operator|=
name|active_branches
expr_stmt|;
name|active_branches
operator|=
name|b
expr_stmt|;
name|cur_active_branches
operator|++
expr_stmt|;
name|branch_load_count
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|convert_num_notes_to_fanout
specifier|static
name|unsigned
name|char
name|convert_num_notes_to_fanout
parameter_list|(
name|uintmax_t
name|num_notes
parameter_list|)
block|{
name|unsigned
name|char
name|fanout
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|num_notes
operator|>>=
literal|8
operator|)
condition|)
name|fanout
operator|++
expr_stmt|;
return|return
name|fanout
return|;
block|}
end_function
begin_function
DECL|function|construct_path_with_fanout
specifier|static
name|void
name|construct_path_with_fanout
parameter_list|(
specifier|const
name|char
modifier|*
name|hex_sha1
parameter_list|,
name|unsigned
name|char
name|fanout
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fanout
operator|>=
literal|20
condition|)
name|die
argument_list|(
literal|"Too large fanout (%u)"
argument_list|,
name|fanout
argument_list|)
expr_stmt|;
while|while
condition|(
name|fanout
condition|)
block|{
name|path
index|[
name|i
operator|++
index|]
operator|=
name|hex_sha1
index|[
name|j
operator|++
index|]
expr_stmt|;
name|path
index|[
name|i
operator|++
index|]
operator|=
name|hex_sha1
index|[
name|j
operator|++
index|]
expr_stmt|;
name|path
index|[
name|i
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|fanout
operator|--
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|path
operator|+
name|i
argument_list|,
name|hex_sha1
operator|+
name|j
argument_list|,
literal|40
operator|-
name|j
argument_list|)
expr_stmt|;
name|path
index|[
name|i
operator|+
literal|40
operator|-
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_function
DECL|function|do_change_note_fanout
specifier|static
name|uintmax_t
name|do_change_note_fanout
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|orig_root
parameter_list|,
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|,
name|char
modifier|*
name|hex_sha1
parameter_list|,
name|unsigned
name|int
name|hex_sha1_len
parameter_list|,
name|char
modifier|*
name|fullpath
parameter_list|,
name|unsigned
name|int
name|fullpath_len
parameter_list|,
name|unsigned
name|char
name|fanout
parameter_list|)
block|{
name|struct
name|tree_content
modifier|*
name|t
init|=
name|root
operator|->
name|tree
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|e
decl_stmt|,
name|leaf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|tmp_hex_sha1_len
decl_stmt|,
name|tmp_fullpath_len
decl_stmt|;
name|uintmax_t
name|num_notes
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|realpath
index|[
literal|60
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
operator|&&
name|i
operator|<
name|t
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|t
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
name|tmp_hex_sha1_len
operator|=
name|hex_sha1_len
operator|+
name|e
operator|->
name|name
operator|->
name|str_len
expr_stmt|;
name|tmp_fullpath_len
operator|=
name|fullpath_len
expr_stmt|;
comment|/* 		 * We're interested in EITHER existing note entries (entries 		 * with exactly 40 hex chars in path, not including directory 		 * separators), OR directory entries that may contain note 		 * entries (with< 40 hex chars in path). 		 * Also, each path component in a note entry must be a multiple 		 * of 2 chars. 		 */
if|if
condition|(
operator|!
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
operator|||
name|tmp_hex_sha1_len
operator|>
literal|40
operator|||
name|e
operator|->
name|name
operator|->
name|str_len
operator|%
literal|2
condition|)
continue|continue;
comment|/* This _may_ be a note entry, or a subdir containing notes */
name|memcpy
argument_list|(
name|hex_sha1
operator|+
name|hex_sha1_len
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_fullpath_len
condition|)
name|fullpath
index|[
name|tmp_fullpath_len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|fullpath
operator|+
name|tmp_fullpath_len
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_dat
argument_list|,
name|e
operator|->
name|name
operator|->
name|str_len
argument_list|)
expr_stmt|;
name|tmp_fullpath_len
operator|+=
name|e
operator|->
name|name
operator|->
name|str_len
expr_stmt|;
name|fullpath
index|[
name|tmp_fullpath_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tmp_hex_sha1_len
operator|==
literal|40
operator|&&
operator|!
name|get_sha1_hex
argument_list|(
name|hex_sha1
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
comment|/* This is a note entry */
if|if
condition|(
name|fanout
operator|==
literal|0xff
condition|)
block|{
comment|/* Counting mode, no rename */
name|num_notes
operator|++
expr_stmt|;
continue|continue;
block|}
name|construct_path_with_fanout
argument_list|(
name|hex_sha1
argument_list|,
name|fanout
argument_list|,
name|realpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fullpath
argument_list|,
name|realpath
argument_list|)
condition|)
block|{
comment|/* Note entry is in correct location */
name|num_notes
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Rename fullpath to realpath */
if|if
condition|(
operator|!
name|tree_content_remove
argument_list|(
name|orig_root
argument_list|,
name|fullpath
argument_list|,
operator|&
name|leaf
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to remove path %s"
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
name|tree_content_set
argument_list|(
name|orig_root
argument_list|,
name|realpath
argument_list|,
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|,
name|leaf
operator|.
name|tree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|e
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
condition|)
block|{
comment|/* This is a subdir that may contain note entries */
if|if
condition|(
operator|!
name|e
operator|->
name|tree
condition|)
name|load_tree
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|num_notes
operator|+=
name|do_change_note_fanout
argument_list|(
name|orig_root
argument_list|,
name|e
argument_list|,
name|hex_sha1
argument_list|,
name|tmp_hex_sha1_len
argument_list|,
name|fullpath
argument_list|,
name|tmp_fullpath_len
argument_list|,
name|fanout
argument_list|)
expr_stmt|;
block|}
comment|/* The above may have reallocated the current tree_content */
name|t
operator|=
name|root
operator|->
name|tree
expr_stmt|;
block|}
return|return
name|num_notes
return|;
block|}
end_function
begin_function
DECL|function|change_note_fanout
specifier|static
name|uintmax_t
name|change_note_fanout
parameter_list|(
name|struct
name|tree_entry
modifier|*
name|root
parameter_list|,
name|unsigned
name|char
name|fanout
parameter_list|)
block|{
name|char
name|hex_sha1
index|[
literal|40
index|]
decl_stmt|,
name|path
index|[
literal|60
index|]
decl_stmt|;
return|return
name|do_change_note_fanout
argument_list|(
name|root
argument_list|,
name|root
argument_list|,
name|hex_sha1
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|fanout
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|file_change_m
specifier|static
name|void
name|file_change_m
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|command_buf
operator|.
name|buf
operator|+
literal|2
decl_stmt|;
specifier|static
name|struct
name|strbuf
name|uq
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|endp
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|oe
init|=
name|oe
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|,
name|inline_data
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|get_mode
argument_list|(
name|p
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|die
argument_list|(
literal|"Corrupt mode: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0644
case|:
case|case
literal|0755
case|:
name|mode
operator||=
name|S_IFREG
expr_stmt|;
case|case
name|S_IFREG
operator||
literal|0644
case|:
case|case
name|S_IFREG
operator||
literal|0755
case|:
case|case
name|S_IFLNK
case|:
case|case
name|S_IFDIR
case|:
case|case
name|S_IFGITLINK
case|:
comment|/* ok */
break|break;
default|default:
name|die
argument_list|(
literal|"Corrupt mode: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|x
decl_stmt|;
name|oe
operator|=
name|find_mark
argument_list|(
name|strtoumax
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|x
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|oe
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|p
argument_list|,
literal|"inline"
argument_list|)
condition|)
block|{
name|inline_data
operator|=
literal|1
expr_stmt|;
name|p
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|p
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Invalid SHA1: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|oe
operator|=
name|find_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|40
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"Missing space after SHA1: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|uq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unquote_c_style
argument_list|(
operator|&
name|uq
argument_list|,
name|p
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|endp
condition|)
name|die
argument_list|(
literal|"Garbage after path in: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|uq
operator|.
name|buf
expr_stmt|;
block|}
comment|/* Git does not track empty, non-toplevel directories. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|sha1
argument_list|,
name|EMPTY_TREE_SHA1_BIN
argument_list|,
literal|20
argument_list|)
operator|&&
operator|*
name|p
condition|)
block|{
name|tree_content_remove
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|inline_data
condition|)
name|die
argument_list|(
literal|"Git links cannot be specified 'inline': %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oe
condition|)
block|{
if|if
condition|(
name|oe
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Not a commit (actually a %s): %s"
argument_list|,
name|typename
argument_list|(
name|oe
operator|->
name|type
argument_list|)
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Accept the sha1 without checking; it expected to be in 		 * another repository. 		 */
block|}
elseif|else
if|if
condition|(
name|inline_data
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|die
argument_list|(
literal|"Directories cannot be specified 'inline': %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|uq
operator|.
name|buf
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|uq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|uq
operator|.
name|buf
expr_stmt|;
block|}
name|read_next_command
argument_list|()
expr_stmt|;
name|parse_and_store_blob
argument_list|(
operator|&
name|last_blob
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|object_type
name|expected
init|=
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|?
name|OBJ_TREE
else|:
name|OBJ_BLOB
decl_stmt|;
name|enum
name|object_type
name|type
init|=
name|oe
condition|?
name|oe
operator|->
name|type
else|:
name|sha1_object_info
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"%s not found: %s"
argument_list|,
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|?
literal|"Tree"
else|:
literal|"Blob"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|expected
condition|)
name|die
argument_list|(
literal|"Not a %s (actually a %s): %s"
argument_list|,
name|typename
argument_list|(
name|expected
argument_list|)
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|tree_content_replace
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|sha1
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|tree_content_set
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|p
argument_list|,
name|sha1
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|file_change_d
specifier|static
name|void
name|file_change_d
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|command_buf
operator|.
name|buf
operator|+
literal|2
decl_stmt|;
specifier|static
name|struct
name|strbuf
name|uq
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|endp
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|uq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unquote_c_style
argument_list|(
operator|&
name|uq
argument_list|,
name|p
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|endp
condition|)
name|die
argument_list|(
literal|"Garbage after path in: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|uq
operator|.
name|buf
expr_stmt|;
block|}
name|tree_content_remove
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|file_change_cr
specifier|static
name|void
name|file_change_cr
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|,
name|int
name|rename
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|static
name|struct
name|strbuf
name|s_uq
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|static
name|struct
name|strbuf
name|d_uq
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|endp
decl_stmt|;
name|struct
name|tree_entry
name|leaf
decl_stmt|;
name|s
operator|=
name|command_buf
operator|.
name|buf
operator|+
literal|2
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|s_uq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unquote_c_style
argument_list|(
operator|&
name|s_uq
argument_list|,
name|s
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"Missing space after source: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endp
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endp
condition|)
name|die
argument_list|(
literal|"Missing space after source: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|s_uq
argument_list|,
name|s
argument_list|,
name|endp
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s_uq
operator|.
name|buf
expr_stmt|;
name|endp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|endp
condition|)
name|die
argument_list|(
literal|"Missing dest: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|d
operator|=
name|endp
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|d_uq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unquote_c_style
argument_list|(
operator|&
name|d_uq
argument_list|,
name|d
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|endp
condition|)
name|die
argument_list|(
literal|"Garbage after dest in: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|d
operator|=
name|d_uq
operator|.
name|buf
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|leaf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|leaf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
condition|)
name|tree_content_remove
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|s
argument_list|,
operator|&
name|leaf
argument_list|)
expr_stmt|;
else|else
name|tree_content_get
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|s
argument_list|,
operator|&
name|leaf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|mode
condition|)
name|die
argument_list|(
literal|"Path %s not in branch"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|d
condition|)
block|{
comment|/* C "path/to/subdir" "" */
name|tree_content_replace
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|,
name|leaf
operator|.
name|tree
argument_list|)
expr_stmt|;
return|return;
block|}
name|tree_content_set
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|d
argument_list|,
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|,
name|leaf
operator|.
name|tree
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|note_change_n
specifier|static
name|void
name|note_change_n
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|,
name|unsigned
name|char
modifier|*
name|old_fanout
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|command_buf
operator|.
name|buf
operator|+
literal|2
decl_stmt|;
specifier|static
name|struct
name|strbuf
name|uq
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|oe
init|=
name|oe
decl_stmt|;
name|struct
name|branch
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|,
name|commit_sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|path
index|[
literal|60
index|]
decl_stmt|;
name|uint16_t
name|inline_data
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|new_fanout
decl_stmt|;
comment|/* 	 * When loading a branch, we don't traverse its tree to count the real 	 * number of notes (too expensive to do this for all non-note refs). 	 * This means that recently loaded notes refs might incorrectly have 	 * b->num_notes == 0, and consequently, old_fanout might be wrong. 	 * 	 * Fix this by traversing the tree and counting the number of notes 	 * when b->num_notes == 0. If the notes tree is truly empty, the 	 * calculation should not take long. 	 */
if|if
condition|(
name|b
operator|->
name|num_notes
operator|==
literal|0
operator|&&
operator|*
name|old_fanout
operator|==
literal|0
condition|)
block|{
comment|/* Invoke change_note_fanout() in "counting mode". */
name|b
operator|->
name|num_notes
operator|=
name|change_note_fanout
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|old_fanout
operator|=
name|convert_num_notes_to_fanout
argument_list|(
name|b
operator|->
name|num_notes
argument_list|)
expr_stmt|;
block|}
comment|/* Now parse the notemodify command. */
comment|/*<dataref> or 'inline' */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|x
decl_stmt|;
name|oe
operator|=
name|find_mark
argument_list|(
name|strtoumax
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|x
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|oe
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|p
argument_list|,
literal|"inline"
argument_list|)
condition|)
block|{
name|inline_data
operator|=
literal|1
expr_stmt|;
name|p
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|p
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Invalid SHA1: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|oe
operator|=
name|find_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|40
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"Missing space after SHA1: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
comment|/*<committish> */
name|s
operator|=
name|lookup_branch
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|is_null_sha1
argument_list|(
name|s
operator|->
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Can't add a note on empty branch."
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|commit_sha1
argument_list|,
name|s
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|uintmax_t
name|commit_mark
init|=
name|strtoumax
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|commit_oe
init|=
name|find_mark
argument_list|(
name|commit_mark
argument_list|)
decl_stmt|;
if|if
condition|(
name|commit_oe
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Mark :%"
name|PRIuMAX
literal|" not a commit"
argument_list|,
name|commit_mark
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|commit_sha1
argument_list|,
name|commit_oe
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
name|p
argument_list|,
name|commit_sha1
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|read_object_with_reference
argument_list|(
name|commit_sha1
argument_list|,
name|commit_type
argument_list|,
operator|&
name|size
argument_list|,
name|commit_sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
name|size
operator|<
literal|46
condition|)
name|die
argument_list|(
literal|"Not a valid commit: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"Invalid ref name or SHA1 expression: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_data
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|uq
operator|.
name|buf
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|uq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|uq
operator|.
name|buf
expr_stmt|;
block|}
name|read_next_command
argument_list|()
expr_stmt|;
name|parse_and_store_blob
argument_list|(
operator|&
name|last_blob
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oe
condition|)
block|{
if|if
condition|(
name|oe
operator|->
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"Not a blob (actually a %s): %s"
argument_list|,
name|typename
argument_list|(
name|oe
operator|->
name|type
argument_list|)
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
condition|)
block|{
name|enum
name|object_type
name|type
init|=
name|sha1_object_info
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Blob not found: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"Not a blob (actually a %s): %s"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|construct_path_with_fanout
argument_list|(
name|sha1_to_hex
argument_list|(
name|commit_sha1
argument_list|)
argument_list|,
operator|*
name|old_fanout
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_content_remove
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
condition|)
name|b
operator|->
name|num_notes
operator|--
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
condition|)
return|return;
comment|/* nothing to insert */
name|b
operator|->
name|num_notes
operator|++
expr_stmt|;
name|new_fanout
operator|=
name|convert_num_notes_to_fanout
argument_list|(
name|b
operator|->
name|num_notes
argument_list|)
expr_stmt|;
name|construct_path_with_fanout
argument_list|(
name|sha1_to_hex
argument_list|(
name|commit_sha1
argument_list|)
argument_list|,
name|new_fanout
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|tree_content_set
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|path
argument_list|,
name|sha1
argument_list|,
name|S_IFREG
operator||
literal|0644
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|file_change_deleteall
specifier|static
name|void
name|file_change_deleteall
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
name|release_tree_content_recursive
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|tree
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|load_tree
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|)
expr_stmt|;
name|b
operator|->
name|num_notes
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_from_commit
specifier|static
name|void
name|parse_from_commit
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
operator|!
name|buf
operator|||
name|size
operator|<
literal|46
condition|)
name|die
argument_list|(
literal|"Not a valid commit: %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
literal|"tree "
argument_list|,
name|buf
argument_list|,
literal|5
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
name|buf
operator|+
literal|5
argument_list|,
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"The commit %s is corrupt"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|,
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_from_existing
specifier|static
name|void
name|parse_from_existing
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|is_null_sha1
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
condition|)
block|{
name|hashclr
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|read_object_with_reference
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|commit_type
argument_list|,
operator|&
name|size
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|parse_from_commit
argument_list|(
name|b
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parse_from
specifier|static
name|int
name|parse_from
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
name|struct
name|branch
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"from "
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|b
operator|->
name|branch_tree
operator|.
name|tree
condition|)
block|{
name|release_tree_content_recursive
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|tree
argument_list|)
expr_stmt|;
name|b
operator|->
name|branch_tree
operator|.
name|tree
operator|=
name|NULL
expr_stmt|;
block|}
name|from
operator|=
name|strchr
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|lookup_branch
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|s
condition|)
name|die
argument_list|(
literal|"Can't create a branch from itself: %s"
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
condition|)
block|{
name|unsigned
name|char
modifier|*
name|t
init|=
name|s
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
decl_stmt|;
name|hashcpy
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|s
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
literal|':'
condition|)
block|{
name|uintmax_t
name|idnum
init|=
name|strtoumax
argument_list|(
name|from
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|oe
init|=
name|find_mark
argument_list|(
name|idnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|oe
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Mark :%"
name|PRIuMAX
literal|" not a commit"
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|oe
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oe
operator|->
name|pack_id
operator|!=
name|MAX_PACK_ID
condition|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|gfi_unpack_entry
argument_list|(
name|oe
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|parse_from_commit
argument_list|(
name|b
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_from_existing
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
name|from
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
condition|)
name|parse_from_existing
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Invalid ref name or SHA1 expression: %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|parse_merge
specifier|static
name|struct
name|hash_list
modifier|*
name|parse_merge
parameter_list|(
name|unsigned
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|hash_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|e
init|=
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
name|struct
name|branch
modifier|*
name|s
decl_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"merge "
argument_list|)
condition|)
block|{
name|from
operator|=
name|strchr
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|lookup_branch
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|hashcpy
argument_list|(
name|n
operator|->
name|sha1
argument_list|,
name|s
operator|->
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
literal|':'
condition|)
block|{
name|uintmax_t
name|idnum
init|=
name|strtoumax
argument_list|(
name|from
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|oe
init|=
name|find_mark
argument_list|(
name|idnum
argument_list|)
decl_stmt|;
if|if
condition|(
name|oe
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Mark :%"
name|PRIuMAX
literal|" not a commit"
argument_list|,
name|idnum
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|n
operator|->
name|sha1
argument_list|,
name|oe
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
name|from
argument_list|,
name|n
operator|->
name|sha1
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|read_object_with_reference
argument_list|(
name|n
operator|->
name|sha1
argument_list|,
name|commit_type
argument_list|,
operator|&
name|size
argument_list|,
name|n
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
name|size
operator|<
literal|46
condition|)
name|die
argument_list|(
literal|"Not a valid commit: %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"Invalid ref name or SHA1 expression: %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|e
operator|->
name|next
operator|=
name|n
expr_stmt|;
else|else
name|list
operator|=
name|n
expr_stmt|;
name|e
operator|=
name|n
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|parse_new_commit
specifier|static
name|void
name|parse_new_commit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|author
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|committer
init|=
name|NULL
decl_stmt|;
name|struct
name|hash_list
modifier|*
name|merge_list
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|merge_count
decl_stmt|;
name|unsigned
name|char
name|prev_fanout
decl_stmt|,
name|new_fanout
decl_stmt|;
comment|/* Obtain the branch name from the rest of our command */
name|sp
operator|=
name|strchr
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|b
operator|=
name|lookup_branch
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|b
operator|=
name|new_branch
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
name|parse_mark
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"author "
argument_list|)
condition|)
block|{
name|author
operator|=
name|parse_ident
argument_list|(
name|command_buf
operator|.
name|buf
operator|+
literal|7
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"committer "
argument_list|)
condition|)
block|{
name|committer
operator|=
name|parse_ident
argument_list|(
name|command_buf
operator|.
name|buf
operator|+
literal|10
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|committer
condition|)
name|die
argument_list|(
literal|"Expected committer but didn't get one"
argument_list|)
expr_stmt|;
name|parse_data
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
name|parse_from
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|merge_list
operator|=
name|parse_merge
argument_list|(
operator|&
name|merge_count
argument_list|)
expr_stmt|;
comment|/* ensure the branch is active/loaded */
if|if
condition|(
operator|!
name|b
operator|->
name|branch_tree
operator|.
name|tree
operator|||
operator|!
name|max_active_branches
condition|)
block|{
name|unload_one_branch
argument_list|()
expr_stmt|;
name|load_branch
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|prev_fanout
operator|=
name|convert_num_notes_to_fanout
argument_list|(
name|b
operator|->
name|num_notes
argument_list|)
expr_stmt|;
comment|/* file_change* */
while|while
condition|(
name|command_buf
operator|.
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"M "
argument_list|)
condition|)
name|file_change_m
argument_list|(
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"D "
argument_list|)
condition|)
name|file_change_d
argument_list|(
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"R "
argument_list|)
condition|)
name|file_change_cr
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"C "
argument_list|)
condition|)
name|file_change_cr
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"N "
argument_list|)
condition|)
name|note_change_n
argument_list|(
name|b
argument_list|,
operator|&
name|prev_fanout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"deleteall"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
condition|)
name|file_change_deleteall
argument_list|(
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"ls "
argument_list|)
condition|)
name|parse_ls
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
block|{
name|unread_command_buf
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|read_next_command
argument_list|()
operator|==
name|EOF
condition|)
break|break;
block|}
name|new_fanout
operator|=
name|convert_num_notes_to_fanout
argument_list|(
name|b
operator|->
name|num_notes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fanout
operator|!=
name|prev_fanout
condition|)
name|b
operator|->
name|num_notes
operator|=
name|change_note_fanout
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|,
name|new_fanout
argument_list|)
expr_stmt|;
comment|/* build the tree and the commit */
name|store_tree
argument_list|(
operator|&
name|b
operator|->
name|branch_tree
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|,
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|new_data
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|new_data
argument_list|,
literal|"tree %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_null_sha1
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|new_data
argument_list|,
literal|"parent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|merge_list
condition|)
block|{
name|struct
name|hash_list
modifier|*
name|next
init|=
name|merge_list
operator|->
name|next
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|new_data
argument_list|,
literal|"parent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|merge_list
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|merge_list
argument_list|)
expr_stmt|;
name|merge_list
operator|=
name|next
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|new_data
argument_list|,
literal|"author %s\n"
literal|"committer %s\n"
literal|"\n"
argument_list|,
name|author
condition|?
name|author
else|:
name|committer
argument_list|,
name|committer
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|new_data
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|committer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store_object
argument_list|(
name|OBJ_COMMIT
argument_list|,
operator|&
name|new_data
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|next_mark
argument_list|)
condition|)
name|b
operator|->
name|pack_id
operator|=
name|pack_id
expr_stmt|;
name|b
operator|->
name|last_commit
operator|=
name|object_count_by_type
index|[
name|OBJ_COMMIT
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_new_tag
specifier|static
name|void
name|parse_new_tag
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|tagger
decl_stmt|;
name|struct
name|branch
modifier|*
name|s
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|uintmax_t
name|from_mark
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
comment|/* Obtain the new tag name from the rest of our command */
name|sp
operator|=
name|strchr
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|t
operator|=
name|pool_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|next_tag
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|name
operator|=
name|pool_strdup
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_tag
condition|)
name|last_tag
operator|->
name|next_tag
operator|=
name|t
expr_stmt|;
else|else
name|first_tag
operator|=
name|t
expr_stmt|;
name|last_tag
operator|=
name|t
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
comment|/* from ... */
if|if
condition|(
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"from "
argument_list|)
condition|)
name|die
argument_list|(
literal|"Expected from command, got %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|from
operator|=
name|strchr
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|lookup_branch
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|is_null_sha1
argument_list|(
name|s
operator|->
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Can't tag an empty branch."
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|s
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|type
operator|=
name|OBJ_COMMIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
literal|':'
condition|)
block|{
name|struct
name|object_entry
modifier|*
name|oe
decl_stmt|;
name|from_mark
operator|=
name|strtoumax
argument_list|(
name|from
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|oe
operator|=
name|find_mark
argument_list|(
name|from_mark
argument_list|)
expr_stmt|;
name|type
operator|=
name|oe
operator|->
name|type
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|oe
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
name|from
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
name|struct
name|object_entry
modifier|*
name|oe
init|=
name|find_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oe
condition|)
block|{
name|type
operator|=
name|sha1_object_info
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Not a valid object: %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|oe
operator|->
name|type
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"Invalid ref name or SHA1 expression: %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
comment|/* tagger ... */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"tagger "
argument_list|)
condition|)
block|{
name|tagger
operator|=
name|parse_ident
argument_list|(
name|command_buf
operator|.
name|buf
operator|+
literal|7
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
block|}
else|else
name|tagger
operator|=
name|NULL
expr_stmt|;
comment|/* tag payload/message */
name|parse_data
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* build the tag object */
name|strbuf_reset
argument_list|(
operator|&
name|new_data
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|new_data
argument_list|,
literal|"object %s\n"
literal|"type %s\n"
literal|"tag %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tagger
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|new_data
argument_list|,
literal|"tagger %s\n"
argument_list|,
name|tagger
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|new_data
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|new_data
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tagger
argument_list|)
expr_stmt|;
if|if
condition|(
name|store_object
argument_list|(
name|OBJ_TAG
argument_list|,
operator|&
name|new_data
argument_list|,
name|NULL
argument_list|,
name|t
operator|->
name|sha1
argument_list|,
literal|0
argument_list|)
condition|)
name|t
operator|->
name|pack_id
operator|=
name|MAX_PACK_ID
expr_stmt|;
else|else
name|t
operator|->
name|pack_id
operator|=
name|pack_id
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_reset_branch
specifier|static
name|void
name|parse_reset_branch
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* Obtain the branch name from the rest of our command */
name|sp
operator|=
name|strchr
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|b
operator|=
name|lookup_branch
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|hashclr
argument_list|(
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|0
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|branch_tree
operator|.
name|tree
condition|)
block|{
name|release_tree_content_recursive
argument_list|(
name|b
operator|->
name|branch_tree
operator|.
name|tree
argument_list|)
expr_stmt|;
name|b
operator|->
name|branch_tree
operator|.
name|tree
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|b
operator|=
name|new_branch
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|read_next_command
argument_list|()
expr_stmt|;
name|parse_from
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_buf
operator|.
name|len
operator|>
literal|0
condition|)
name|unread_command_buf
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cat_blob_write
specifier|static
name|void
name|cat_blob_write
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|cat_blob_fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
name|die_errno
argument_list|(
literal|"Write to frontend failed"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cat_blob
specifier|static
name|void
name|cat_blob
parameter_list|(
name|struct
name|object_entry
modifier|*
name|oe
parameter_list|,
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
parameter_list|)
block|{
name|struct
name|strbuf
name|line
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|oe
operator|||
name|oe
operator|->
name|pack_id
operator|==
name|MAX_PACK_ID
condition|)
block|{
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|oe
operator|->
name|type
expr_stmt|;
name|buf
operator|=
name|gfi_unpack_entry
argument_list|(
name|oe
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Output based on batch_one_object() from cat-file.c. 	 */
if|if
condition|(
name|type
operator|<=
literal|0
condition|)
block|{
name|strbuf_reset
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|line
argument_list|,
literal|"%s missing\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|cat_blob_write
argument_list|(
name|line
operator|.
name|buf
argument_list|,
name|line
operator|.
name|len
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"Can't read object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"Object %s is a %s but a blob was expected."
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|line
argument_list|,
literal|"%s %s %lu\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cat_blob_write
argument_list|(
name|line
operator|.
name|buf
argument_list|,
name|line
operator|.
name|len
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|cat_blob_write
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cat_blob_write
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oe
operator|&&
name|oe
operator|->
name|pack_id
operator|==
name|pack_id
condition|)
block|{
name|last_blob
operator|.
name|offset
operator|=
name|oe
operator|->
name|idx
operator|.
name|offset
expr_stmt|;
name|strbuf_attach
argument_list|(
operator|&
name|last_blob
operator|.
name|data
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|last_blob
operator|.
name|depth
operator|=
name|oe
operator|->
name|depth
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_cat_blob
specifier|static
name|void
name|parse_cat_blob
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|oe
init|=
name|oe
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
comment|/* cat-blob SP<object> LF */
name|p
operator|=
name|command_buf
operator|.
name|buf
operator|+
name|strlen
argument_list|(
literal|"cat-blob "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|x
decl_stmt|;
name|oe
operator|=
name|find_mark
argument_list|(
name|strtoumax
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|x
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|p
operator|+
literal|1
condition|)
name|die
argument_list|(
literal|"Invalid mark: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oe
condition|)
name|die
argument_list|(
literal|"Unknown mark: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|x
condition|)
name|die
argument_list|(
literal|"Garbage after mark: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|oe
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|p
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Invalid SHA1: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|40
index|]
condition|)
name|die
argument_list|(
literal|"Garbage after SHA1: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|oe
operator|=
name|find_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
block|}
name|cat_blob
argument_list|(
name|oe
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dereference
specifier|static
name|struct
name|object_entry
modifier|*
name|dereference
parameter_list|(
name|struct
name|object_entry
modifier|*
name|oe
parameter_list|,
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|oe
condition|)
block|{
name|enum
name|object_type
name|type
init|=
name|sha1_object_info
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"object not found: %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cache it! */
name|oe
operator|=
name|insert_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|oe
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|oe
operator|->
name|pack_id
operator|=
name|MAX_PACK_ID
expr_stmt|;
name|oe
operator|->
name|idx
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|oe
operator|->
name|type
condition|)
block|{
case|case
name|OBJ_TREE
case|:
comment|/* easy case. */
return|return
name|oe
return|;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TAG
case|:
break|break;
default|default:
name|die
argument_list|(
literal|"Not a treeish: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oe
operator|->
name|pack_id
operator|!=
name|MAX_PACK_ID
condition|)
block|{
comment|/* in a pack being written */
name|buf
operator|=
name|gfi_unpack_entry
argument_list|(
name|oe
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|object_type
name|unused
decl_stmt|;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|unused
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"Can't load object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Peel one layer. */
switch|switch
condition|(
name|oe
operator|->
name|type
condition|)
block|{
case|case
name|OBJ_TAG
case|:
if|if
condition|(
name|size
operator|<
literal|40
operator|+
name|strlen
argument_list|(
literal|"object "
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
literal|"object "
argument_list|)
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Invalid SHA1 in tag: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
if|if
condition|(
name|size
operator|<
literal|40
operator|+
name|strlen
argument_list|(
literal|"tree "
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
literal|"tree "
argument_list|)
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Invalid SHA1 in commit: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|find_object
argument_list|(
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_treeish_dataref
specifier|static
name|struct
name|object_entry
modifier|*
name|parse_treeish_dataref
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/*<mark> */
name|char
modifier|*
name|endptr
decl_stmt|;
name|e
operator|=
name|find_mark
argument_list|(
name|strtoumax
argument_list|(
operator|*
name|p
operator|+
literal|1
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|endptr
operator|==
operator|*
name|p
operator|+
literal|1
condition|)
name|die
argument_list|(
literal|"Invalid mark: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
name|die
argument_list|(
literal|"Unknown mark: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|endptr
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|e
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*<sha1> */
if|if
condition|(
name|get_sha1_hex
argument_list|(
operator|*
name|p
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Invalid SHA1: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|e
operator|=
name|find_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
literal|40
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|e
operator|||
name|e
operator|->
name|type
operator|!=
name|OBJ_TREE
condition|)
name|e
operator|=
name|dereference
argument_list|(
name|e
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_function
DECL|function|print_ls
specifier|static
name|void
name|print_ls
parameter_list|(
name|int
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|line
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* See show_tree(). */
specifier|const
name|char
modifier|*
name|type
init|=
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|?
name|commit_type
else|:
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|?
name|tree_type
else|:
name|blob_type
decl_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
block|{
comment|/* missing SP path LF */
name|strbuf_reset
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|line
argument_list|,
literal|"missing "
argument_list|)
expr_stmt|;
name|quote_c_style
argument_list|(
name|path
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mode SP type SP object_name TAB path LF */
name|strbuf_reset
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|line
argument_list|,
literal|"%06o %s %s\t"
argument_list|,
name|mode
operator|&
operator|~
name|NO_DELTA
argument_list|,
name|type
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|quote_c_style
argument_list|(
name|path
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|cat_blob_write
argument_list|(
name|line
operator|.
name|buf
argument_list|,
name|line
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_ls
specifier|static
name|void
name|parse_ls
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|root
init|=
name|NULL
decl_stmt|;
name|struct
name|tree_entry
name|leaf
init|=
block|{
name|NULL
block|}
decl_stmt|;
comment|/* ls SP (<treeish> SP)?<path> */
name|p
operator|=
name|command_buf
operator|.
name|buf
operator|+
name|strlen
argument_list|(
literal|"ls "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
name|die
argument_list|(
literal|"Not in a commit: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|root
operator|=
operator|&
name|b
operator|->
name|branch_tree
expr_stmt|;
block|}
else|else
block|{
name|struct
name|object_entry
modifier|*
name|e
init|=
name|parse_treeish_dataref
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
name|root
operator|=
name|new_tree_entry
argument_list|()
expr_stmt|;
name|hashcpy
argument_list|(
name|root
operator|->
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|e
operator|->
name|idx
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|load_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"Missing space after tree-ish: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
specifier|static
name|struct
name|strbuf
name|uq
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|endp
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|uq
argument_list|)
expr_stmt|;
if|if
condition|(
name|unquote_c_style
argument_list|(
operator|&
name|uq
argument_list|,
name|p
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
name|die
argument_list|(
literal|"Invalid path: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
condition|)
name|die
argument_list|(
literal|"Garbage after path in: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|uq
operator|.
name|buf
expr_stmt|;
block|}
name|tree_content_get
argument_list|(
name|root
argument_list|,
name|p
argument_list|,
operator|&
name|leaf
argument_list|)
expr_stmt|;
comment|/* 	 * A directory in preparation would have a sha1 of zero 	 * until it is saved.  Save, for simplicity. 	 */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
condition|)
name|store_tree
argument_list|(
operator|&
name|leaf
argument_list|)
expr_stmt|;
name|print_ls
argument_list|(
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|mode
argument_list|,
name|leaf
operator|.
name|versions
index|[
literal|1
index|]
operator|.
name|sha1
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|||
name|root
operator|!=
operator|&
name|b
operator|->
name|branch_tree
condition|)
name|release_tree_entry
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkpoint
specifier|static
name|void
name|checkpoint
parameter_list|(
name|void
parameter_list|)
block|{
name|checkpoint_requested
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|object_count
condition|)
block|{
name|cycle_packfile
argument_list|()
expr_stmt|;
name|dump_branches
argument_list|()
expr_stmt|;
name|dump_tags
argument_list|()
expr_stmt|;
name|dump_marks
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parse_checkpoint
specifier|static
name|void
name|parse_checkpoint
parameter_list|(
name|void
parameter_list|)
block|{
name|checkpoint_requested
operator|=
literal|1
expr_stmt|;
name|skip_optional_lf
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_progress
specifier|static
name|void
name|parse_progress
parameter_list|(
name|void
parameter_list|)
block|{
name|fwrite
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|command_buf
operator|.
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|skip_optional_lf
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_fast_import_path
specifier|static
name|char
modifier|*
name|make_fast_import_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|strbuf
name|abs_path
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|relative_marks_paths
operator|||
name|is_absolute_path
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|xstrdup
argument_list|(
name|path
argument_list|)
return|;
name|strbuf_addf
argument_list|(
operator|&
name|abs_path
argument_list|,
literal|"%s/info/fast-import/%s"
argument_list|,
name|get_git_dir
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|abs_path
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|option_import_marks
specifier|static
name|void
name|option_import_marks
parameter_list|(
specifier|const
name|char
modifier|*
name|marks
parameter_list|,
name|int
name|from_stream
parameter_list|,
name|int
name|ignore_missing
parameter_list|)
block|{
if|if
condition|(
name|import_marks_file
condition|)
block|{
if|if
condition|(
name|from_stream
condition|)
name|die
argument_list|(
literal|"Only one import-marks command allowed per stream"
argument_list|)
expr_stmt|;
comment|/* read previous mark file */
if|if
condition|(
operator|!
name|import_marks_file_from_stream
condition|)
name|read_marks
argument_list|()
expr_stmt|;
block|}
name|import_marks_file
operator|=
name|make_fast_import_path
argument_list|(
name|marks
argument_list|)
expr_stmt|;
name|safe_create_leading_directories_const
argument_list|(
name|import_marks_file
argument_list|)
expr_stmt|;
name|import_marks_file_from_stream
operator|=
name|from_stream
expr_stmt|;
name|import_marks_file_ignore_missing
operator|=
name|ignore_missing
expr_stmt|;
block|}
end_function
begin_function
DECL|function|option_date_format
specifier|static
name|void
name|option_date_format
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fmt
argument_list|,
literal|"raw"
argument_list|)
condition|)
name|whenspec
operator|=
name|WHENSPEC_RAW
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fmt
argument_list|,
literal|"rfc2822"
argument_list|)
condition|)
name|whenspec
operator|=
name|WHENSPEC_RFC2822
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fmt
argument_list|,
literal|"now"
argument_list|)
condition|)
name|whenspec
operator|=
name|WHENSPEC_NOW
expr_stmt|;
else|else
name|die
argument_list|(
literal|"unknown --date-format argument %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ulong_arg
specifier|static
name|unsigned
name|long
name|ulong_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|unsigned
name|long
name|rv
init|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'-'
argument_list|)
operator|||
name|endptr
operator|==
name|arg
operator|||
operator|*
name|endptr
condition|)
name|die
argument_list|(
literal|"%s: argument must be a non-negative integer"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function
begin_function
DECL|function|option_depth
specifier|static
name|void
name|option_depth
parameter_list|(
specifier|const
name|char
modifier|*
name|depth
parameter_list|)
block|{
name|max_depth
operator|=
name|ulong_arg
argument_list|(
literal|"--depth"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_depth
operator|>
name|MAX_DEPTH
condition|)
name|die
argument_list|(
literal|"--depth cannot exceed %u"
argument_list|,
name|MAX_DEPTH
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|option_active_branches
specifier|static
name|void
name|option_active_branches
parameter_list|(
specifier|const
name|char
modifier|*
name|branches
parameter_list|)
block|{
name|max_active_branches
operator|=
name|ulong_arg
argument_list|(
literal|"--active-branches"
argument_list|,
name|branches
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|option_export_marks
specifier|static
name|void
name|option_export_marks
parameter_list|(
specifier|const
name|char
modifier|*
name|marks
parameter_list|)
block|{
name|export_marks_file
operator|=
name|make_fast_import_path
argument_list|(
name|marks
argument_list|)
expr_stmt|;
name|safe_create_leading_directories_const
argument_list|(
name|export_marks_file
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|option_cat_blob_fd
specifier|static
name|void
name|option_cat_blob_fd
parameter_list|(
specifier|const
name|char
modifier|*
name|fd
parameter_list|)
block|{
name|unsigned
name|long
name|n
init|=
name|ulong_arg
argument_list|(
literal|"--cat-blob-fd"
argument_list|,
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
name|unsigned
name|long
operator|)
name|INT_MAX
condition|)
name|die
argument_list|(
literal|"--cat-blob-fd cannot exceed %d"
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|cat_blob_fd
operator|=
operator|(
name|int
operator|)
name|n
expr_stmt|;
block|}
end_function
begin_function
DECL|function|option_export_pack_edges
specifier|static
name|void
name|option_export_pack_edges
parameter_list|(
specifier|const
name|char
modifier|*
name|edges
parameter_list|)
block|{
if|if
condition|(
name|pack_edges
condition|)
name|fclose
argument_list|(
name|pack_edges
argument_list|)
expr_stmt|;
name|pack_edges
operator|=
name|fopen
argument_list|(
name|edges
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pack_edges
condition|)
name|die_errno
argument_list|(
literal|"Cannot open '%s'"
argument_list|,
name|edges
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_one_option
specifier|static
name|int
name|parse_one_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|option
argument_list|,
literal|"max-pack-size="
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|git_parse_ulong
argument_list|(
name|option
operator|+
literal|14
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|v
operator|<
literal|8192
condition|)
block|{
name|warning
argument_list|(
literal|"max-pack-size is now in bytes, assuming --max-pack-size=%lum"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|*=
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|1024
operator|*
literal|1024
condition|)
block|{
name|warning
argument_list|(
literal|"minimum max-pack-size is 1 MiB"
argument_list|)
expr_stmt|;
name|v
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
name|max_packsize
operator|=
name|v
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|option
argument_list|,
literal|"big-file-threshold="
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|git_parse_ulong
argument_list|(
name|option
operator|+
literal|19
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
literal|0
return|;
name|big_file_threshold
operator|=
name|v
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|option
argument_list|,
literal|"depth="
argument_list|)
condition|)
block|{
name|option_depth
argument_list|(
name|option
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|option
argument_list|,
literal|"active-branches="
argument_list|)
condition|)
block|{
name|option_active_branches
argument_list|(
name|option
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|option
argument_list|,
literal|"export-pack-edges="
argument_list|)
condition|)
block|{
name|option_export_pack_edges
argument_list|(
name|option
operator|+
literal|18
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|option
argument_list|,
literal|"quiet"
argument_list|)
condition|)
block|{
name|show_stats
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|option
argument_list|,
literal|"stats"
argument_list|)
condition|)
block|{
name|show_stats
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|parse_one_feature
specifier|static
name|int
name|parse_one_feature
parameter_list|(
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|int
name|from_stream
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|feature
argument_list|,
literal|"date-format="
argument_list|)
condition|)
block|{
name|option_date_format
argument_list|(
name|feature
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|feature
argument_list|,
literal|"import-marks="
argument_list|)
condition|)
block|{
name|option_import_marks
argument_list|(
name|feature
operator|+
literal|13
argument_list|,
name|from_stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|feature
argument_list|,
literal|"import-marks-if-exists="
argument_list|)
condition|)
block|{
name|option_import_marks
argument_list|(
name|feature
operator|+
name|strlen
argument_list|(
literal|"import-marks-if-exists="
argument_list|)
argument_list|,
name|from_stream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|feature
argument_list|,
literal|"export-marks="
argument_list|)
condition|)
block|{
name|option_export_marks
argument_list|(
name|feature
operator|+
literal|13
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|feature
argument_list|,
literal|"cat-blob"
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* Don't die - this feature is supported */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|feature
argument_list|,
literal|"relative-marks"
argument_list|)
condition|)
block|{
name|relative_marks_paths
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|feature
argument_list|,
literal|"no-relative-marks"
argument_list|)
condition|)
block|{
name|relative_marks_paths
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|feature
argument_list|,
literal|"done"
argument_list|)
condition|)
block|{
name|require_explicit_termination
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|feature
argument_list|,
literal|"force"
argument_list|)
condition|)
block|{
name|force_update
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|feature
argument_list|,
literal|"notes"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|feature
argument_list|,
literal|"ls"
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* do nothing; we have the feature */
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|parse_feature
specifier|static
name|void
name|parse_feature
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|feature
init|=
name|command_buf
operator|.
name|buf
operator|+
literal|8
decl_stmt|;
if|if
condition|(
name|seen_data_command
condition|)
name|die
argument_list|(
literal|"Got feature command '%s' after data command"
argument_list|,
name|feature
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_one_feature
argument_list|(
name|feature
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|die
argument_list|(
literal|"This version of fast-import does not support feature %s."
argument_list|,
name|feature
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_option
specifier|static
name|void
name|parse_option
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|option
init|=
name|command_buf
operator|.
name|buf
operator|+
literal|11
decl_stmt|;
if|if
condition|(
name|seen_data_command
condition|)
name|die
argument_list|(
literal|"Got option command '%s' after data command"
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_one_option
argument_list|(
name|option
argument_list|)
condition|)
return|return;
name|die
argument_list|(
literal|"This version of fast-import does not support option: %s"
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_pack_config
specifier|static
name|int
name|git_pack_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"pack.depth"
argument_list|)
condition|)
block|{
name|max_depth
operator|=
name|git_config_int
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_depth
operator|>
name|MAX_DEPTH
condition|)
name|max_depth
operator|=
name|MAX_DEPTH
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"pack.compression"
argument_list|)
condition|)
block|{
name|int
name|level
init|=
name|git_config_int
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|Z_BEST_COMPRESSION
condition|)
name|die
argument_list|(
literal|"bad pack compression level %d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|pack_compression_level
operator|=
name|level
expr_stmt|;
name|pack_compression_seen
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"pack.indexversion"
argument_list|)
condition|)
block|{
name|pack_idx_opts
operator|.
name|version
operator|=
name|git_config_int
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack_idx_opts
operator|.
name|version
operator|>
literal|2
condition|)
name|die
argument_list|(
literal|"bad pack.indexversion=%"
name|PRIu32
argument_list|,
name|pack_idx_opts
operator|.
name|version
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"pack.packsizelimit"
argument_list|)
condition|)
block|{
name|max_packsize
operator|=
name|git_config_ulong
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|fast_import_usage
specifier|static
specifier|const
name|char
name|fast_import_usage
index|[]
init|=
literal|"git fast-import [--date-format=<f>] [--max-pack-size=<n>] [--big-file-threshold=<n>] [--depth=<n>] [--active-branches=<n>] [--export-marks=<marks.file>]"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parse_argv
specifier|static
name|void
name|parse_argv
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|global_argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|a
init|=
name|global_argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|a
operator|!=
literal|'-'
operator|||
operator|!
name|strcmp
argument_list|(
name|a
argument_list|,
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|parse_one_option
argument_list|(
name|a
operator|+
literal|2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|parse_one_feature
argument_list|(
name|a
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|a
operator|+
literal|2
argument_list|,
literal|"cat-blob-fd="
argument_list|)
condition|)
block|{
name|option_cat_blob_fd
argument_list|(
name|a
operator|+
literal|2
operator|+
name|strlen
argument_list|(
literal|"cat-blob-fd="
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|die
argument_list|(
literal|"unknown option %s"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|global_argc
condition|)
name|usage
argument_list|(
name|fast_import_usage
argument_list|)
expr_stmt|;
name|seen_data_command
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|import_marks_file
condition|)
name|read_marks
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|git_extract_argv0_path
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|git_setup_gettext
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage
argument_list|(
name|fast_import_usage
argument_list|)
expr_stmt|;
name|setup_git_directory
argument_list|()
expr_stmt|;
name|reset_pack_idx_option
argument_list|(
operator|&
name|pack_idx_opts
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_pack_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pack_compression_seen
operator|&&
name|core_compression_seen
condition|)
name|pack_compression_level
operator|=
name|core_compression_level
expr_stmt|;
name|alloc_objects
argument_list|(
name|object_entry_alloc
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|command_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atom_table
operator|=
name|xcalloc
argument_list|(
name|atom_table_sz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atom_str
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|branch_table
operator|=
name|xcalloc
argument_list|(
name|branch_table_sz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|branch
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|avail_tree_table
operator|=
name|xcalloc
argument_list|(
name|avail_tree_table_sz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|avail_tree_content
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|marks
operator|=
name|pool_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mark_set
argument_list|)
argument_list|)
expr_stmt|;
name|global_argc
operator|=
name|argc
expr_stmt|;
name|global_argv
operator|=
name|argv
expr_stmt|;
name|rc_free
operator|=
name|pool_alloc
argument_list|(
name|cmd_save
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rc_free
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|cmd_save
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|rc_free
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
name|rc_free
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|rc_free
index|[
name|cmd_save
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
name|start_packfile
argument_list|()
expr_stmt|;
name|set_die_routine
argument_list|(
name|die_nicely
argument_list|)
expr_stmt|;
name|set_checkpoint_signal
argument_list|()
expr_stmt|;
while|while
condition|(
name|read_next_command
argument_list|()
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"blob"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
condition|)
name|parse_new_blob
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"ls "
argument_list|)
condition|)
name|parse_ls
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"commit "
argument_list|)
condition|)
name|parse_new_commit
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"tag "
argument_list|)
condition|)
name|parse_new_tag
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"reset "
argument_list|)
condition|)
name|parse_reset_branch
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"checkpoint"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
condition|)
name|parse_checkpoint
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"done"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"progress "
argument_list|)
condition|)
name|parse_progress
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"feature "
argument_list|)
condition|)
name|parse_feature
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"option git "
argument_list|)
condition|)
name|parse_option
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|command_buf
operator|.
name|buf
argument_list|,
literal|"option "
argument_list|)
condition|)
comment|/* ignore non-git options*/
empty_stmt|;
else|else
name|die
argument_list|(
literal|"Unsupported command: %s"
argument_list|,
name|command_buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkpoint_requested
condition|)
name|checkpoint
argument_list|()
expr_stmt|;
block|}
comment|/* argv hasn't been parsed yet, do so */
if|if
condition|(
operator|!
name|seen_data_command
condition|)
name|parse_argv
argument_list|()
expr_stmt|;
if|if
condition|(
name|require_explicit_termination
operator|&&
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|die
argument_list|(
literal|"stream ends early"
argument_list|)
expr_stmt|;
name|end_packfile
argument_list|()
expr_stmt|;
name|dump_branches
argument_list|()
expr_stmt|;
name|dump_tags
argument_list|()
expr_stmt|;
name|unkeep_all_packs
argument_list|()
expr_stmt|;
name|dump_marks
argument_list|()
expr_stmt|;
if|if
condition|(
name|pack_edges
condition|)
name|fclose
argument_list|(
name|pack_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_stats
condition|)
block|{
name|uintmax_t
name|total_count
init|=
literal|0
decl_stmt|,
name|duplicate_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|object_count_by_type
argument_list|)
condition|;
name|i
operator|++
control|)
name|total_count
operator|+=
name|object_count_by_type
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|duplicate_count_by_type
argument_list|)
condition|;
name|i
operator|++
control|)
name|duplicate_count
operator|+=
name|duplicate_count_by_type
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s statistics:\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Alloc'd objects: %10"
name|PRIuMAX
literal|"\n"
argument_list|,
name|alloc_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total objects:   %10"
name|PRIuMAX
literal|" (%10"
name|PRIuMAX
literal|" duplicates                  )\n"
argument_list|,
name|total_count
argument_list|,
name|duplicate_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      blobs  :   %10"
name|PRIuMAX
literal|" (%10"
name|PRIuMAX
literal|" duplicates %10"
name|PRIuMAX
literal|" deltas of %10"
name|PRIuMAX
literal|" attempts)\n"
argument_list|,
name|object_count_by_type
index|[
name|OBJ_BLOB
index|]
argument_list|,
name|duplicate_count_by_type
index|[
name|OBJ_BLOB
index|]
argument_list|,
name|delta_count_by_type
index|[
name|OBJ_BLOB
index|]
argument_list|,
name|delta_count_attempts_by_type
index|[
name|OBJ_BLOB
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      trees  :   %10"
name|PRIuMAX
literal|" (%10"
name|PRIuMAX
literal|" duplicates %10"
name|PRIuMAX
literal|" deltas of %10"
name|PRIuMAX
literal|" attempts)\n"
argument_list|,
name|object_count_by_type
index|[
name|OBJ_TREE
index|]
argument_list|,
name|duplicate_count_by_type
index|[
name|OBJ_TREE
index|]
argument_list|,
name|delta_count_by_type
index|[
name|OBJ_TREE
index|]
argument_list|,
name|delta_count_attempts_by_type
index|[
name|OBJ_TREE
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      commits:   %10"
name|PRIuMAX
literal|" (%10"
name|PRIuMAX
literal|" duplicates %10"
name|PRIuMAX
literal|" deltas of %10"
name|PRIuMAX
literal|" attempts)\n"
argument_list|,
name|object_count_by_type
index|[
name|OBJ_COMMIT
index|]
argument_list|,
name|duplicate_count_by_type
index|[
name|OBJ_COMMIT
index|]
argument_list|,
name|delta_count_by_type
index|[
name|OBJ_COMMIT
index|]
argument_list|,
name|delta_count_attempts_by_type
index|[
name|OBJ_COMMIT
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      tags   :   %10"
name|PRIuMAX
literal|" (%10"
name|PRIuMAX
literal|" duplicates %10"
name|PRIuMAX
literal|" deltas of %10"
name|PRIuMAX
literal|" attempts)\n"
argument_list|,
name|object_count_by_type
index|[
name|OBJ_TAG
index|]
argument_list|,
name|duplicate_count_by_type
index|[
name|OBJ_TAG
index|]
argument_list|,
name|delta_count_by_type
index|[
name|OBJ_TAG
index|]
argument_list|,
name|delta_count_attempts_by_type
index|[
name|OBJ_TAG
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total branches:  %10lu (%10lu loads     )\n"
argument_list|,
name|branch_count
argument_list|,
name|branch_load_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      marks:     %10"
name|PRIuMAX
literal|" (%10"
name|PRIuMAX
literal|" unique    )\n"
argument_list|,
operator|(
operator|(
operator|(
name|uintmax_t
operator|)
literal|1
operator|)
operator|<<
name|marks
operator|->
name|shift
operator|)
operator|*
literal|1024
argument_list|,
name|marks_set_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      atoms:     %10u\n"
argument_list|,
name|atom_cnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory total:    %10"
name|PRIuMAX
literal|" KiB\n"
argument_list|,
operator|(
name|total_allocd
operator|+
name|alloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|object_entry
argument_list|)
operator|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       pools:    %10lu KiB\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|total_allocd
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"     objects:    %10"
name|PRIuMAX
literal|" KiB\n"
argument_list|,
operator|(
name|alloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|object_entry
argument_list|)
operator|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|pack_report
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|failure
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
end_unit
