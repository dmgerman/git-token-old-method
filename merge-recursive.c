begin_unit
begin_comment
comment|/*  * Recursive Merge algorithm stolen from git-merge-recursive.py by  * Fredrik Kuivinen.  * The thieves were Alex Riesen and Johannes Schindelin, in June/July 2006  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"path-list.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"interpolate.h"
end_include
begin_include
include|#
directive|include
file|"attr.h"
end_include
begin_decl_stmt
DECL|variable|subtree_merge
specifier|static
name|int
name|subtree_merge
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|shift_tree_object
specifier|static
name|struct
name|tree
modifier|*
name|shift_tree_object
parameter_list|(
name|struct
name|tree
modifier|*
name|one
parameter_list|,
name|struct
name|tree
modifier|*
name|two
parameter_list|)
block|{
name|unsigned
name|char
name|shifted
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * NEEDSWORK: this limits the recursion depth to hardcoded 	 * value '2' to avoid excessive overhead. 	 */
name|shift_tree
argument_list|(
name|one
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|two
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|shifted
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|two
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|shifted
argument_list|)
condition|)
return|return
name|two
return|;
return|return
name|lookup_tree
argument_list|(
name|shifted
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * A virtual commit has  * - (const char *)commit->util set to the name, and  * - *(int *)commit->object.sha1 set to the virtual id.  */
end_comment
begin_function
DECL|function|commit_list_count
specifier|static
name|unsigned
name|commit_list_count
parameter_list|(
specifier|const
name|struct
name|commit_list
modifier|*
name|l
parameter_list|)
block|{
name|unsigned
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|c
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|make_virtual_commit
specifier|static
name|struct
name|commit
modifier|*
name|make_virtual_commit
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commit
argument_list|)
argument_list|)
decl_stmt|;
specifier|static
name|unsigned
name|virtual_id
init|=
literal|1
decl_stmt|;
name|commit
operator|->
name|tree
operator|=
name|tree
expr_stmt|;
name|commit
operator|->
name|util
operator|=
operator|(
name|void
operator|*
operator|)
name|comment
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|commit
operator|->
name|object
operator|.
name|sha1
operator|=
name|virtual_id
operator|++
expr_stmt|;
comment|/* avoid warnings */
name|commit
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
return|return
name|commit
return|;
block|}
end_function
begin_comment
comment|/*  * Since we use get_tree_entry(), which does not put the read object into  * the object pool, we cannot rely on a == b.  */
end_comment
begin_function
DECL|function|sha_eq
specifier|static
name|int
name|sha_eq
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|&&
operator|!
name|b
condition|)
return|return
literal|2
return|;
return|return
name|a
operator|&&
name|b
operator|&&
name|hashcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Since we want to write the index eventually, we cannot reuse the index  * for these (temporary) data.  */
end_comment
begin_struct
DECL|struct|stage_data
struct|struct
name|stage_data
block|{
struct|struct
block|{
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
block|}
DECL|member|stages
name|stages
index|[
literal|4
index|]
struct|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|output_buffer
struct|struct
name|output_buffer
block|{
DECL|member|next
name|struct
name|output_buffer
modifier|*
name|next
decl_stmt|;
DECL|member|str
name|char
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|current_file_set
specifier|static
name|struct
name|path_list
name|current_file_set
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_directory_set
specifier|static
name|struct
name|path_list
name|current_directory_set
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|call_depth
specifier|static
name|int
name|call_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|verbosity
specifier|static
name|int
name|verbosity
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|buffer_output
specifier|static
name|int
name|buffer_output
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|output_list
DECL|variable|output_end
specifier|static
name|struct
name|output_buffer
modifier|*
name|output_list
decl_stmt|,
modifier|*
name|output_end
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|show
specifier|static
name|int
name|show
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
operator|(
operator|!
name|call_depth
operator|&&
name|verbosity
operator|>=
name|v
operator|)
operator|||
name|verbosity
operator|>=
literal|5
return|;
block|}
end_function
begin_function
DECL|function|output
specifier|static
name|void
name|output
parameter_list|(
name|int
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_output
operator|&&
name|show
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|struct
name|output_buffer
modifier|*
name|b
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|nfvasprintf
argument_list|(
operator|&
name|b
operator|->
name|str
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|output_end
condition|)
name|output_end
operator|->
name|next
operator|=
name|b
expr_stmt|;
else|else
name|output_list
operator|=
name|b
expr_stmt|;
name|output_end
operator|=
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|call_depth
init|;
name|i
operator|--
condition|;
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|flush_output
specifier|static
name|void
name|flush_output
parameter_list|()
block|{
name|struct
name|output_buffer
modifier|*
name|b
decl_stmt|,
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|b
operator|=
name|output_list
init|;
name|b
condition|;
name|b
operator|=
name|n
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|call_depth
init|;
name|i
operator|--
condition|;
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|b
operator|->
name|str
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|n
operator|=
name|b
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|output_list
operator|=
name|NULL
expr_stmt|;
name|output_end
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_commit_title
specifier|static
name|void
name|output_commit_title
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|call_depth
init|;
name|i
operator|--
condition|;
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|util
condition|)
name|printf
argument_list|(
literal|"virtual %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|commit
operator|->
name|util
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"(bad commit)\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|commit
operator|->
name|buffer
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|s
index|[
name|len
index|]
operator|&&
literal|'\n'
operator|!=
name|s
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
name|len
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|make_cache_entry
specifier|static
name|struct
name|cache_entry
modifier|*
name|make_cache_entry
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|stage
parameter_list|,
name|int
name|refresh
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
operator|!
name|verify_path
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|size
operator|=
name|cache_entry_size
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ce
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
name|len
argument_list|,
name|stage
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|refresh
condition|)
return|return
name|refresh_cache_entry
argument_list|(
name|ce
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|ce
return|;
block|}
end_function
begin_function
DECL|function|add_cacheinfo
specifier|static
name|int
name|add_cacheinfo
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|stage
parameter_list|,
name|int
name|refresh
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|make_cache_entry
argument_list|(
name|mode
argument_list|,
name|sha1
condition|?
name|sha1
else|:
name|null_sha1
argument_list|,
name|path
argument_list|,
name|stage
argument_list|,
name|refresh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
name|error
argument_list|(
literal|"addinfo_cache failed for path '%s'"
argument_list|,
name|path
argument_list|)
return|;
return|return
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * This is a global variable which is used in a number of places but  * only written to in the 'merge' function.  *  * index_only == 1    => Don't leave any non-stage 0 entries in the cache and  *                       don't update the working directory.  *               0    => Leave unmerged entries in the cache and update  *                       the working directory.  */
end_comment
begin_decl_stmt
DECL|variable|index_only
specifier|static
name|int
name|index_only
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_merge_trees
specifier|static
name|int
name|git_merge_trees
parameter_list|(
name|int
name|index_only
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|object_list
modifier|*
name|trees
init|=
name|NULL
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
name|opts
operator|.
name|index_only
operator|=
literal|1
expr_stmt|;
else|else
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|2
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|threeway_merge
expr_stmt|;
name|object_list_append
argument_list|(
operator|&
name|common
operator|->
name|object
argument_list|,
operator|&
name|trees
argument_list|)
expr_stmt|;
name|object_list_append
argument_list|(
operator|&
name|head
operator|->
name|object
argument_list|,
operator|&
name|trees
argument_list|)
expr_stmt|;
name|object_list_append
argument_list|(
operator|&
name|merge
operator|->
name|object
argument_list|,
operator|&
name|trees
argument_list|)
expr_stmt|;
name|rc
operator|=
name|unpack_trees
argument_list|(
name|trees
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|cache_tree_free
argument_list|(
operator|&
name|active_cache_tree
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|unmerged_index
specifier|static
name|int
name|unmerged_index
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_write_tree
specifier|static
name|struct
name|tree
modifier|*
name|git_write_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|unmerged_index
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
name|output
argument_list|(
literal|0
argument_list|,
literal|"There are unmerged index entries:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
name|output
argument_list|(
literal|0
argument_list|,
literal|"%d %.*s"
argument_list|,
name|ce_stage
argument_list|(
name|ce
argument_list|)
argument_list|,
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|active_cache_tree
condition|)
name|active_cache_tree
operator|=
name|cache_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cache_tree_fully_valid
argument_list|(
name|active_cache_tree
argument_list|)
operator|&&
name|cache_tree_update
argument_list|(
name|active_cache_tree
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"error building trees"
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup_tree
argument_list|(
name|active_cache_tree
operator|->
name|sha1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|save_files_dirs
specifier|static
name|int
name|save_files_dirs
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|int
name|stage
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newpath
init|=
name|xmalloc
argument_list|(
name|baselen
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newpath
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newpath
operator|+
name|baselen
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newpath
index|[
name|baselen
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|path_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|current_directory_set
argument_list|)
expr_stmt|;
else|else
name|path_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|current_file_set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
name|READ_TREE_RECURSIVE
return|;
block|}
end_function
begin_function
DECL|function|get_files_dirs
specifier|static
name|int
name|get_files_dirs
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|read_tree_recursive
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|save_files_dirs
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|current_file_set
operator|.
name|nr
operator|+
name|current_directory_set
operator|.
name|nr
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*  * Returns a index_entry instance which doesn't have to correspond to  * a real cache entry in Git's index.  */
end_comment
begin_function
DECL|function|insert_stage_data
specifier|static
name|struct
name|stage_data
modifier|*
name|insert_stage_data
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|tree
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|a
parameter_list|,
name|struct
name|tree
modifier|*
name|b
parameter_list|,
name|struct
name|path_list
modifier|*
name|entries
parameter_list|)
block|{
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
decl_stmt|;
name|get_tree_entry
argument_list|(
name|o
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|a
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|b
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|item
operator|=
name|path_list_insert
argument_list|(
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|e
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_comment
comment|/*  * Create a dictionary mapping file names to stage_data objects. The  * dictionary contains one entry for every path with a non-zero stage entry.  */
end_comment
begin_function
DECL|function|get_unmerged
specifier|static
name|struct
name|path_list
modifier|*
name|get_unmerged
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|path_list
modifier|*
name|unmerged
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unmerged
operator|->
name|strdup_paths
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
continue|continue;
name|item
operator|=
name|path_list_lookup
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|unmerged
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|item
operator|=
name|path_list_insert
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|unmerged
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|mode
operator|=
name|ntohl
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|sha
argument_list|,
name|ce
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
return|return
name|unmerged
return|;
block|}
end_function
begin_struct
DECL|struct|rename
struct|struct
name|rename
block|{
DECL|member|pair
name|struct
name|diff_filepair
modifier|*
name|pair
decl_stmt|;
DECL|member|src_entry
name|struct
name|stage_data
modifier|*
name|src_entry
decl_stmt|;
DECL|member|dst_entry
name|struct
name|stage_data
modifier|*
name|dst_entry
decl_stmt|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Get information of all renames which occurred between 'o_tree' and  * 'tree'. We need the three trees in the merge ('o_tree', 'a_tree' and  * 'b_tree') to be able to associate the correct cache entries with  * the rename information. 'tree' is always equal to either a_tree or b_tree.  */
end_comment
begin_function
DECL|function|get_renames
specifier|static
name|struct
name|path_list
modifier|*
name|get_renames
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|struct
name|tree
modifier|*
name|o_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|a_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|b_tree
parameter_list|,
name|struct
name|path_list
modifier|*
name|entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|path_list
modifier|*
name|renames
decl_stmt|;
name|struct
name|diff_options
name|opts
decl_stmt|;
name|renames
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_list
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|recursive
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|detect_rename
operator|=
name|DIFF_DETECT_RENAME
expr_stmt|;
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff setup failed"
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|o_tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|rename
modifier|*
name|re
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|pair
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pair
operator|->
name|status
operator|!=
literal|'R'
condition|)
block|{
name|diff_free_filepair
argument_list|(
name|pair
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|re
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|re
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|pair
operator|=
name|pair
expr_stmt|;
name|item
operator|=
name|path_list_lookup
argument_list|(
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|src_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|src_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|path_list_lookup
argument_list|(
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|dst_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|dst_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|path_list_insert
argument_list|(
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|renames
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|re
expr_stmt|;
block|}
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_queued_diff
operator|.
name|nr
operator|=
literal|0
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
return|return
name|renames
return|;
block|}
end_function
begin_function
DECL|function|update_stages
specifier|static
name|int
name|update_stages
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
name|int
name|options
init|=
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_OK_TO_REPLACE
decl_stmt|;
if|if
condition|(
name|clear
condition|)
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|o
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|o
operator|->
name|mode
argument_list|,
name|o
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|a
operator|->
name|mode
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|b
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|b
operator|->
name|mode
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|remove_path
specifier|static
name|int
name|remove_path
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|dirs
decl_stmt|;
name|ret
operator|=
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dirs
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dirs
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dirs
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|slash
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|slash
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|remove_file
specifier|static
name|int
name|remove_file
parameter_list|(
name|int
name|clean
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|no_wd
parameter_list|)
block|{
name|int
name|update_cache
init|=
name|index_only
operator|||
name|clean
decl_stmt|;
name|int
name|update_working_directory
init|=
operator|!
name|index_only
operator|&&
operator|!
name|no_wd
decl_stmt|;
if|if
condition|(
name|update_cache
condition|)
block|{
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|update_working_directory
condition|)
block|{
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|||
name|errno
operator|!=
name|EISDIR
condition|)
return|return
operator|-
literal|1
return|;
name|remove_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unique_path
specifier|static
name|char
modifier|*
name|unique_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|branch
parameter_list|)
block|{
name|char
modifier|*
name|newpath
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|8
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|suffix
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|newpath
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'~'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|branch
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
literal|'/'
operator|==
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
while|while
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_file_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|lstat
argument_list|(
name|newpath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"_%d"
argument_list|,
name|suffix
operator|++
argument_list|)
expr_stmt|;
name|path_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|current_file_set
argument_list|)
expr_stmt|;
return|return
name|newpath
return|;
block|}
end_function
begin_function
DECL|function|mkdir_p
specifier|static
name|int
name|mkdir_p
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|long
name|mode
parameter_list|)
block|{
comment|/* path points to cache entries, so xstrdup before messing with it */
name|char
modifier|*
name|buf
init|=
name|xstrdup
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|safe_create_leading_directories
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|flush_buffer
specifier|static
name|void
name|flush_buffer
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|long
name|ret
init|=
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Ignore epipe */
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
break|break;
name|die
argument_list|(
literal|"merge-recursive: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|die
argument_list|(
literal|"merge-recursive: disk full?"
argument_list|)
expr_stmt|;
block|}
name|size
operator|-=
name|ret
expr_stmt|;
name|buf
operator|+=
name|ret
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|make_room_for_path
specifier|static
name|int
name|make_room_for_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"failed to create path '%s'%s"
decl_stmt|;
name|status
operator|=
name|mkdir_p
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|3
condition|)
block|{
comment|/* something else exists */
name|error
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
literal|": perhaps a D/F conflict?"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|die
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Successful unlink is good.. */
if|if
condition|(
operator|!
name|unlink
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* .. and so is no existing file */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
comment|/* .. but not some other error (who really cares what?) */
return|return
name|error
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
literal|": perhaps a D/F conflict?"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|update_file_flags
specifier|static
name|void
name|update_file_flags
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|update_cache
parameter_list|,
name|int
name|update_wd
parameter_list|)
block|{
if|if
condition|(
name|index_only
condition|)
name|update_wd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|update_wd
condition|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"cannot read object %s '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"blob expected for %s '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_room_for_path
argument_list|(
name|path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|update_wd
operator|=
literal|0
expr_stmt|;
goto|goto
name|update_index
goto|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
operator|!
name|has_symlinks
operator|&&
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|mode
operator|&
literal|0100
condition|)
name|mode
operator|=
literal|0777
expr_stmt|;
else|else
name|mode
operator|=
literal|0666
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"failed to open %s: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|lnk
init|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|lnk
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|lnk
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mkdir_p
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|symlink
argument_list|(
name|lnk
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"do not know what to do with %06o %s '%s'"
argument_list|,
name|mode
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|update_index
label|:
if|if
condition|(
name|update_cache
condition|)
name|add_cacheinfo
argument_list|(
name|mode
argument_list|,
name|sha
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|update_wd
argument_list|,
name|ADD_CACHE_OK_TO_ADD
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_file
specifier|static
name|void
name|update_file
parameter_list|(
name|int
name|clean
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|update_file_flags
argument_list|(
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|,
name|index_only
operator|||
name|clean
argument_list|,
operator|!
name|index_only
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Low level file merging, update and removal */
end_comment
begin_struct
DECL|struct|merge_file_info
struct|struct
name|merge_file_info
block|{
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|clean
name|unsigned
name|clean
range|:
literal|1
decl_stmt|,
DECL|member|merge
name|merge
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|fill_mm
specifier|static
name|void
name|fill_mm
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|mmfile_t
modifier|*
name|mm
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
name|mm
operator|->
name|ptr
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|mm
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|mm
operator|->
name|ptr
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mm
operator|->
name|ptr
operator|||
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"unable to read blob object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|mm
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Customizable low-level merge drivers support.  */
end_comment
begin_struct_decl
struct_decl|struct
name|ll_merge_driver
struct_decl|;
end_struct_decl
begin_typedef
DECL|typedef|ll_merge_fn
typedef|typedef
name|int
function_decl|(
modifier|*
name|ll_merge_fn
function_decl|)
parameter_list|(
specifier|const
name|struct
name|ll_merge_driver
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|mmfile_t
modifier|*
name|orig
parameter_list|,
name|mmfile_t
modifier|*
name|src1
parameter_list|,
specifier|const
name|char
modifier|*
name|name1
parameter_list|,
name|mmfile_t
modifier|*
name|src2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|mmbuffer_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_typedef
begin_struct
DECL|struct|ll_merge_driver
struct|struct
name|ll_merge_driver
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|description
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
DECL|member|fn
name|ll_merge_fn
name|fn
decl_stmt|;
DECL|member|recursive
specifier|const
name|char
modifier|*
name|recursive
decl_stmt|;
DECL|member|next
name|struct
name|ll_merge_driver
modifier|*
name|next
decl_stmt|;
DECL|member|cmdline
name|char
modifier|*
name|cmdline
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Built-in low-levels  */
end_comment
begin_function
DECL|function|ll_xdl_merge
specifier|static
name|int
name|ll_xdl_merge
parameter_list|(
specifier|const
name|struct
name|ll_merge_driver
modifier|*
name|drv_unused
parameter_list|,
specifier|const
name|char
modifier|*
name|path_unused
parameter_list|,
name|mmfile_t
modifier|*
name|orig
parameter_list|,
name|mmfile_t
modifier|*
name|src1
parameter_list|,
specifier|const
name|char
modifier|*
name|name1
parameter_list|,
name|mmfile_t
modifier|*
name|src2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|mmbuffer_t
modifier|*
name|result
parameter_list|)
block|{
name|xpparam_t
name|xpp
decl_stmt|;
if|if
condition|(
name|buffer_is_binary
argument_list|(
name|orig
operator|->
name|ptr
argument_list|,
name|orig
operator|->
name|size
argument_list|)
operator|||
name|buffer_is_binary
argument_list|(
name|src1
operator|->
name|ptr
argument_list|,
name|src1
operator|->
name|size
argument_list|)
operator|||
name|buffer_is_binary
argument_list|(
name|src2
operator|->
name|ptr
argument_list|,
name|src2
operator|->
name|size
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Cannot merge binary files: %s vs. %s\n"
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
return|;
name|memset
argument_list|(
operator|&
name|xpp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xpp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|xdl_merge
argument_list|(
name|orig
argument_list|,
name|src1
argument_list|,
name|name1
argument_list|,
name|src2
argument_list|,
name|name2
argument_list|,
operator|&
name|xpp
argument_list|,
name|XDL_MERGE_ZEALOUS
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ll_union_merge
specifier|static
name|int
name|ll_union_merge
parameter_list|(
specifier|const
name|struct
name|ll_merge_driver
modifier|*
name|drv_unused
parameter_list|,
specifier|const
name|char
modifier|*
name|path_unused
parameter_list|,
name|mmfile_t
modifier|*
name|orig
parameter_list|,
name|mmfile_t
modifier|*
name|src1
parameter_list|,
specifier|const
name|char
modifier|*
name|name1
parameter_list|,
name|mmfile_t
modifier|*
name|src2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|mmbuffer_t
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|long
name|size
decl_stmt|;
specifier|const
name|int
name|marker_size
init|=
literal|7
decl_stmt|;
name|int
name|status
init|=
name|ll_xdl_merge
argument_list|(
name|drv_unused
argument_list|,
name|path_unused
argument_list|,
name|orig
argument_list|,
name|src1
argument_list|,
name|NULL
argument_list|,
name|src2
argument_list|,
name|NULL
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
return|return
name|status
return|;
name|size
operator|=
name|result
operator|->
name|size
expr_stmt|;
name|src
operator|=
name|dst
operator|=
name|result
operator|->
name|ptr
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|(
name|marker_size
operator|<
name|size
operator|)
operator|&&
operator|(
operator|*
name|src
operator|==
literal|'<'
operator|||
operator|*
name|src
operator|==
literal|'='
operator|||
operator|*
name|src
operator|==
literal|'>'
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ch
operator|=
operator|*
name|src
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|marker_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|src
index|[
name|i
index|]
operator|!=
name|ch
condition|)
goto|goto
name|not_a_marker
goto|;
if|if
condition|(
name|src
index|[
name|marker_size
index|]
operator|!=
literal|'\n'
condition|)
goto|goto
name|not_a_marker
goto|;
name|src
operator|+=
name|marker_size
operator|+
literal|1
expr_stmt|;
name|size
operator|-=
name|marker_size
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|not_a_marker
label|:
do|do
block|{
name|ch
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|ch
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|size
condition|)
do|;
block|}
name|result
operator|->
name|size
operator|=
name|dst
operator|-
name|result
operator|->
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ll_binary_merge
specifier|static
name|int
name|ll_binary_merge
parameter_list|(
specifier|const
name|struct
name|ll_merge_driver
modifier|*
name|drv_unused
parameter_list|,
specifier|const
name|char
modifier|*
name|path_unused
parameter_list|,
name|mmfile_t
modifier|*
name|orig
parameter_list|,
name|mmfile_t
modifier|*
name|src1
parameter_list|,
specifier|const
name|char
modifier|*
name|name1
parameter_list|,
name|mmfile_t
modifier|*
name|src2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|mmbuffer_t
modifier|*
name|result
parameter_list|)
block|{
comment|/* 	 * The tentative merge result is "ours" for the final round, 	 * or common ancestor for an internal merge.  Still return 	 * "conflicted merge" status. 	 */
name|mmfile_t
modifier|*
name|stolen
init|=
name|index_only
condition|?
name|orig
else|:
name|src1
decl_stmt|;
name|result
operator|->
name|ptr
operator|=
name|stolen
operator|->
name|ptr
expr_stmt|;
name|result
operator|->
name|size
operator|=
name|stolen
operator|->
name|size
expr_stmt|;
name|stolen
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_define
DECL|macro|LL_BINARY_MERGE
define|#
directive|define
name|LL_BINARY_MERGE
value|0
end_define
begin_define
DECL|macro|LL_TEXT_MERGE
define|#
directive|define
name|LL_TEXT_MERGE
value|1
end_define
begin_define
DECL|macro|LL_UNION_MERGE
define|#
directive|define
name|LL_UNION_MERGE
value|2
end_define
begin_decl_stmt
DECL|variable|ll_merge_drv
specifier|static
name|struct
name|ll_merge_driver
name|ll_merge_drv
index|[]
init|=
block|{
block|{
literal|"binary"
block|,
literal|"built-in binary merge"
block|,
name|ll_binary_merge
block|}
block|,
block|{
literal|"text"
block|,
literal|"built-in 3-way text merge"
block|,
name|ll_xdl_merge
block|}
block|,
block|{
literal|"union"
block|,
literal|"built-in union merge"
block|,
name|ll_union_merge
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|create_temp
specifier|static
name|void
name|create_temp
parameter_list|(
name|mmfile_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
literal|".merge_file_XXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to create temp-file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|src
operator|->
name|ptr
argument_list|,
name|src
operator|->
name|size
argument_list|)
operator|!=
name|src
operator|->
name|size
condition|)
name|die
argument_list|(
literal|"unable to write temp-file"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * User defined low-level merge driver support.  */
end_comment
begin_function
DECL|function|ll_ext_merge
specifier|static
name|int
name|ll_ext_merge
parameter_list|(
specifier|const
name|struct
name|ll_merge_driver
modifier|*
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|mmfile_t
modifier|*
name|orig
parameter_list|,
name|mmfile_t
modifier|*
name|src1
parameter_list|,
specifier|const
name|char
modifier|*
name|name1
parameter_list|,
name|mmfile_t
modifier|*
name|src2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|mmbuffer_t
modifier|*
name|result
parameter_list|)
block|{
name|char
name|temp
index|[
literal|3
index|]
index|[
literal|50
index|]
decl_stmt|;
name|char
name|cmdbuf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|interp
name|table
index|[]
init|=
block|{
block|{
literal|"%O"
block|}
block|,
block|{
literal|"%A"
block|}
block|,
block|{
literal|"%B"
block|}
block|, 	}
decl_stmt|;
name|struct
name|child_process
name|child
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
index|[
literal|20
index|]
decl_stmt|;
name|int
name|status
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fn
operator|->
name|cmdline
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"custom merge driver %s lacks command line."
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
name|result
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|create_temp
argument_list|(
name|orig
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|create_temp
argument_list|(
name|src1
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|create_temp
argument_list|(
name|src2
argument_list|,
name|temp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|interp_set_entry
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|interp_set_entry
argument_list|(
name|table
argument_list|,
literal|1
argument_list|,
name|temp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|interp_set_entry
argument_list|(
name|table
argument_list|,
literal|2
argument_list|,
name|temp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"merging %s using %s"
argument_list|,
name|path
argument_list|,
name|fn
operator|->
name|description
condition|?
name|fn
operator|->
name|description
else|:
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
name|interpolate
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|,
name|fn
operator|->
name|cmdline
argument_list|,
name|table
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|child
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|.
name|argv
operator|=
name|args
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
literal|"sh"
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|"-c"
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|cmdbuf
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|run_command
argument_list|(
operator|&
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
operator|-
name|ERR_RUN_COMMAND_FORK
condition|)
empty_stmt|;
comment|/* failure in run-command */
else|else
name|status
operator|=
operator|-
name|status
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|temp
index|[
literal|1
index|]
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
goto|goto
name|close_bad
goto|;
name|result
operator|->
name|size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|result
operator|->
name|ptr
operator|=
name|xmalloc
argument_list|(
name|result
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|result
operator|->
name|ptr
argument_list|,
name|result
operator|->
name|size
argument_list|)
operator|!=
name|result
operator|->
name|size
condition|)
block|{
name|free
argument_list|(
name|result
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|result
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|close_bad
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|bad
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|unlink
argument_list|(
name|temp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_comment
comment|/*  * merge.default and merge.driver configuration items  */
end_comment
begin_decl_stmt
DECL|variable|ll_user_merge
DECL|variable|ll_user_merge_tail
specifier|static
name|struct
name|ll_merge_driver
modifier|*
name|ll_user_merge
decl_stmt|,
modifier|*
modifier|*
name|ll_user_merge_tail
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_ll_merge
specifier|static
specifier|const
name|char
modifier|*
name|default_ll_merge
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|read_merge_config
specifier|static
name|int
name|read_merge_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|ll_merge_driver
modifier|*
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"merge.default"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
condition|)
name|default_ll_merge
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * We are not interested in anything but "merge.<name>.variable"; 	 * especially, we do not want to look at variables such as 	 * "merge.summary", "merge.tool", and "merge.verbosity". 	 */
if|if
condition|(
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"merge."
argument_list|)
operator|||
operator|(
name|ep
operator|=
name|strrchr
argument_list|(
name|var
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|var
operator|+
literal|5
condition|)
return|return
literal|0
return|;
comment|/* 	 * Find existing one as we might be processing merge.<name>.var2 	 * after seeing merge.<name>.var1. 	 */
name|name
operator|=
name|var
operator|+
literal|6
expr_stmt|;
name|namelen
operator|=
name|ep
operator|-
name|name
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|ll_user_merge
init|;
name|fn
condition|;
name|fn
operator|=
name|fn
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|fn
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|&&
operator|!
name|fn
operator|->
name|name
index|[
name|namelen
index|]
condition|)
break|break;
if|if
condition|(
operator|!
name|fn
condition|)
block|{
name|char
modifier|*
name|namebuf
decl_stmt|;
name|fn
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ll_merge_driver
argument_list|)
argument_list|)
expr_stmt|;
name|namebuf
operator|=
name|xmalloc
argument_list|(
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|namebuf
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|namebuf
index|[
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
name|fn
operator|->
name|name
operator|=
name|namebuf
expr_stmt|;
name|fn
operator|->
name|fn
operator|=
name|ll_ext_merge
expr_stmt|;
name|fn
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|ll_user_merge_tail
operator|=
name|fn
expr_stmt|;
name|ll_user_merge_tail
operator|=
operator|&
operator|(
name|fn
operator|->
name|next
operator|)
expr_stmt|;
block|}
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"name"
argument_list|,
name|ep
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|error
argument_list|(
literal|"%s: lacks value"
argument_list|,
name|var
argument_list|)
return|;
name|fn
operator|->
name|description
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"driver"
argument_list|,
name|ep
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|error
argument_list|(
literal|"%s: lacks value"
argument_list|,
name|var
argument_list|)
return|;
comment|/* 		 * merge.<name>.driver specifies the command line: 		 * 		 *	command-line 		 * 		 * The command-line will be interpolated with the following 		 * tokens and is given to the shell: 		 * 		 *    %O - temporary file name for the merge base. 		 *    %A - temporary file name for our version. 		 *    %B - temporary file name for the other branches' version. 		 * 		 * The external merge driver should write the results in the 		 * file named by %A, and signal that it has done with zero exit 		 * status. 		 */
name|fn
operator|->
name|cmdline
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"recursive"
argument_list|,
name|ep
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|error
argument_list|(
literal|"%s: lacks value"
argument_list|,
name|var
argument_list|)
return|;
name|fn
operator|->
name|recursive
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|initialize_ll_merge
specifier|static
name|void
name|initialize_ll_merge
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ll_user_merge_tail
condition|)
return|return;
name|ll_user_merge_tail
operator|=
operator|&
name|ll_user_merge
expr_stmt|;
name|git_config
argument_list|(
name|read_merge_config
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_ll_merge_driver
specifier|static
specifier|const
name|struct
name|ll_merge_driver
modifier|*
name|find_ll_merge_driver
parameter_list|(
specifier|const
name|char
modifier|*
name|merge_attr
parameter_list|)
block|{
name|struct
name|ll_merge_driver
modifier|*
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|initialize_ll_merge
argument_list|()
expr_stmt|;
if|if
condition|(
name|ATTR_TRUE
argument_list|(
name|merge_attr
argument_list|)
condition|)
return|return
operator|&
name|ll_merge_drv
index|[
name|LL_TEXT_MERGE
index|]
return|;
elseif|else
if|if
condition|(
name|ATTR_FALSE
argument_list|(
name|merge_attr
argument_list|)
condition|)
return|return
operator|&
name|ll_merge_drv
index|[
name|LL_BINARY_MERGE
index|]
return|;
elseif|else
if|if
condition|(
name|ATTR_UNSET
argument_list|(
name|merge_attr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|default_ll_merge
condition|)
return|return
operator|&
name|ll_merge_drv
index|[
name|LL_TEXT_MERGE
index|]
return|;
else|else
name|name
operator|=
name|default_ll_merge
expr_stmt|;
block|}
else|else
name|name
operator|=
name|merge_attr
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|ll_user_merge
init|;
name|fn
condition|;
name|fn
operator|=
name|fn
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fn
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|fn
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|ll_merge_drv
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ll_merge_drv
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|&
name|ll_merge_drv
index|[
name|i
index|]
return|;
comment|/* default to the 3-way */
return|return
operator|&
name|ll_merge_drv
index|[
name|LL_TEXT_MERGE
index|]
return|;
block|}
end_function
begin_function
DECL|function|git_path_check_merge
specifier|static
specifier|const
name|char
modifier|*
name|git_path_check_merge
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
specifier|static
name|struct
name|git_attr_check
name|attr_merge_check
decl_stmt|;
if|if
condition|(
operator|!
name|attr_merge_check
operator|.
name|attr
condition|)
name|attr_merge_check
operator|.
name|attr
operator|=
name|git_attr
argument_list|(
literal|"merge"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_checkattr
argument_list|(
name|path
argument_list|,
literal|1
argument_list|,
operator|&
name|attr_merge_check
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|attr_merge_check
operator|.
name|value
return|;
block|}
end_function
begin_function
DECL|function|ll_merge
specifier|static
name|int
name|ll_merge
parameter_list|(
name|mmbuffer_t
modifier|*
name|result_buf
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|mmfile_t
name|orig
decl_stmt|,
name|src1
decl_stmt|,
name|src2
decl_stmt|;
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|int
name|merge_status
decl_stmt|;
specifier|const
name|char
modifier|*
name|ll_driver_name
decl_stmt|;
specifier|const
name|struct
name|ll_merge_driver
modifier|*
name|driver
decl_stmt|;
name|name1
operator|=
name|xstrdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s:%s"
argument_list|,
name|branch1
argument_list|,
name|a
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|name2
operator|=
name|xstrdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s:%s"
argument_list|,
name|branch2
argument_list|,
name|b
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|fill_mm
argument_list|(
name|o
operator|->
name|sha1
argument_list|,
operator|&
name|orig
argument_list|)
expr_stmt|;
name|fill_mm
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
operator|&
name|src1
argument_list|)
expr_stmt|;
name|fill_mm
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
operator|&
name|src2
argument_list|)
expr_stmt|;
name|ll_driver_name
operator|=
name|git_path_check_merge
argument_list|(
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
name|driver
operator|=
name|find_ll_merge_driver
argument_list|(
name|ll_driver_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
operator|&&
name|driver
operator|->
name|recursive
condition|)
name|driver
operator|=
name|find_ll_merge_driver
argument_list|(
name|driver
operator|->
name|recursive
argument_list|)
expr_stmt|;
name|merge_status
operator|=
name|driver
operator|->
name|fn
argument_list|(
name|driver
argument_list|,
name|a
operator|->
name|path
argument_list|,
operator|&
name|orig
argument_list|,
operator|&
name|src1
argument_list|,
name|name1
argument_list|,
operator|&
name|src2
argument_list|,
name|name2
argument_list|,
name|result_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|orig
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src1
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src2
operator|.
name|ptr
argument_list|)
expr_stmt|;
return|return
name|merge_status
return|;
block|}
end_function
begin_function
DECL|function|merge_file
specifier|static
name|struct
name|merge_file_info
name|merge_file
parameter_list|(
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|struct
name|merge_file_info
name|result
decl_stmt|;
name|result
operator|.
name|merge
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|S_IFMT
operator|&
name|a
operator|->
name|mode
operator|)
operator|!=
operator|(
name|S_IFMT
operator|&
name|b
operator|->
name|mode
operator|)
condition|)
block|{
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|mode
operator|=
name|b
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
operator|&&
operator|!
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
operator|==
name|o
operator|->
name|mode
condition|?
name|b
operator|->
name|mode
else|:
name|a
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|mmbuffer_t
name|result_buf
decl_stmt|;
name|int
name|merge_status
decl_stmt|;
name|merge_status
operator|=
name|ll_merge
argument_list|(
operator|&
name|result_buf
argument_list|,
name|o
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|merge_status
operator|<
literal|0
operator|)
operator|||
operator|!
name|result_buf
operator|.
name|ptr
condition|)
name|die
argument_list|(
literal|"Failed to execute internal merge"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_sha1_file
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|,
name|result_buf
operator|.
name|size
argument_list|,
name|blob_type
argument_list|,
name|result
operator|.
name|sha
argument_list|)
condition|)
name|die
argument_list|(
literal|"Unable to add %s to database"
argument_list|,
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|result
operator|.
name|clean
operator|=
operator|(
name|merge_status
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|S_ISLNK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
operator|||
name|S_ISLNK
argument_list|(
name|b
operator|->
name|mode
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"cannot merge modes?"
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|conflict_rename_rename
specifier|static
name|void
name|conflict_rename_rename
parameter_list|(
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
name|struct
name|rename
modifier|*
name|ren2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|char
modifier|*
name|del
index|[
literal|2
index|]
decl_stmt|;
name|int
name|delp
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren1_dst
init|=
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren2_dst
init|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_name1
init|=
name|ren1_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_name2
init|=
name|ren2_dst
decl_stmt|;
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|ren1_dst
argument_list|)
condition|)
block|{
name|dst_name1
operator|=
name|del
index|[
name|delp
operator|++
index|]
operator|=
name|unique_path
argument_list|(
name|ren1_dst
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"%s is a directory in %s added as %s instead"
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|,
name|dst_name1
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren1_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|ren2_dst
argument_list|)
condition|)
block|{
name|dst_name2
operator|=
name|del
index|[
name|delp
operator|++
index|]
operator|=
name|unique_path
argument_list|(
name|ren2_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"%s is a directory in %s added as %s instead"
argument_list|,
name|ren2_dst
argument_list|,
name|branch1
argument_list|,
name|dst_name2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren2_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index_only
condition|)
block|{
name|remove_file_from_cache
argument_list|(
name|dst_name1
argument_list|)
expr_stmt|;
name|remove_file_from_cache
argument_list|(
name|dst_name2
argument_list|)
expr_stmt|;
comment|/* 		 * Uncomment to leave the conflicting names in the resulting tree 		 * 		 * update_file(0, ren1->pair->two->sha1, ren1->pair->two->mode, dst_name1); 		 * update_file(0, ren2->pair->two->sha1, ren2->pair->two->mode, dst_name2); 		 */
block|}
else|else
block|{
name|update_stages
argument_list|(
name|dst_name1
argument_list|,
name|NULL
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_stages
argument_list|(
name|dst_name2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|delp
operator|--
condition|)
name|free
argument_list|(
name|del
index|[
name|delp
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_dir
specifier|static
name|void
name|conflict_rename_dir
parameter_list|(
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|)
block|{
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch1
argument_list|)
decl_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"Renamed %s to %s instead"
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_rename_2
specifier|static
name|void
name|conflict_rename_rename_2
parameter_list|(
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
name|struct
name|rename
modifier|*
name|ren2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|char
modifier|*
name|new_path1
init|=
name|unique_path
argument_list|(
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_path2
init|=
name|unique_path
argument_list|(
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch2
argument_list|)
decl_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"Renamed %s to %s and %s to %s instead"
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path1
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|process_renames
specifier|static
name|int
name|process_renames
parameter_list|(
name|struct
name|path_list
modifier|*
name|a_renames
parameter_list|,
name|struct
name|path_list
modifier|*
name|b_renames
parameter_list|,
specifier|const
name|char
modifier|*
name|a_branch
parameter_list|,
specifier|const
name|char
modifier|*
name|b_branch
parameter_list|)
block|{
name|int
name|clean_merge
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|path_list
name|a_by_dst
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|b_by_dst
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|struct
name|rename
modifier|*
name|sre
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|path_list_insert
argument_list|(
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
operator|&
name|a_by_dst
argument_list|)
operator|->
name|util
operator|=
name|sre
operator|->
name|dst_entry
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|b_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|path_list_insert
argument_list|(
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
operator|&
name|b_by_dst
argument_list|)
operator|->
name|util
operator|=
name|sre
operator|->
name|dst_entry
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
operator|||
name|j
operator|<
name|b_renames
operator|->
name|nr
condition|;
control|)
block|{
name|int
name|compare
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|struct
name|path_list
modifier|*
name|renames1
decl_stmt|,
modifier|*
name|renames2
decl_stmt|,
modifier|*
name|renames2Dst
decl_stmt|;
name|struct
name|rename
modifier|*
name|ren1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ren2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch1
decl_stmt|,
modifier|*
name|branch2
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren1_src
decl_stmt|,
modifier|*
name|ren1_dst
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|a_renames
operator|->
name|nr
condition|)
block|{
name|compare
operator|=
literal|1
expr_stmt|;
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>=
name|b_renames
operator|->
name|nr
condition|)
block|{
name|compare
operator|=
operator|-
literal|1
expr_stmt|;
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
else|else
block|{
name|compare
operator|=
name|strcmp
argument_list|(
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|path
argument_list|,
name|b_renames
operator|->
name|items
index|[
name|j
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|<=
literal|0
condition|)
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
if|if
condition|(
name|compare
operator|>=
literal|0
condition|)
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
comment|/* TODO: refactor, so that 1/2 are not needed */
if|if
condition|(
name|ren1
condition|)
block|{
name|renames1
operator|=
name|a_renames
expr_stmt|;
name|renames2
operator|=
name|b_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|b_by_dst
expr_stmt|;
name|branch1
operator|=
name|a_branch
expr_stmt|;
name|branch2
operator|=
name|b_branch
expr_stmt|;
block|}
else|else
block|{
name|struct
name|rename
modifier|*
name|tmp
decl_stmt|;
name|renames1
operator|=
name|b_renames
expr_stmt|;
name|renames2
operator|=
name|a_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|a_by_dst
expr_stmt|;
name|branch1
operator|=
name|b_branch
expr_stmt|;
name|branch2
operator|=
name|a_branch
expr_stmt|;
name|tmp
operator|=
name|ren2
expr_stmt|;
name|ren2
operator|=
name|ren1
expr_stmt|;
name|ren1
operator|=
name|tmp
expr_stmt|;
block|}
name|src
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|ren1
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1
operator|->
name|src_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ren1
operator|->
name|processed
condition|)
continue|continue;
name|ren1
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1_src
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|ren1_dst
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|ren2
condition|)
block|{
specifier|const
name|char
modifier|*
name|ren2_src
init|=
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren2_dst
init|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
comment|/* Renamed in 1 and renamed in 2 */
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_src
argument_list|,
name|ren2_src
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"ren1.src != ren2.src"
argument_list|)
expr_stmt|;
name|ren2
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_dst
argument_list|,
name|ren2_dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (rename/rename): "
literal|"Rename \"%s\"->\"%s\" in branch \"%s\" "
literal|"rename \"%s\"->\"%s\" in \"%s\"%s"
argument_list|,
name|src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|src
argument_list|,
name|ren2_dst
argument_list|,
name|branch2
argument_list|,
name|index_only
condition|?
literal|" (left unresolved)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
block|{
name|remove_file_from_cache
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|conflict_rename_rename
argument_list|(
name|ren1
argument_list|,
name|branch1
argument_list|,
name|ren2
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|remove_file
argument_list|(
literal|1
argument_list|,
name|ren1_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mfi
operator|=
name|merge_file
argument_list|(
name|ren1
operator|->
name|pair
operator|->
name|one
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
operator|||
operator|!
name|mfi
operator|.
name|clean
condition|)
name|output
argument_list|(
literal|1
argument_list|,
literal|"Renamed %s->%s"
argument_list|,
name|src
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
condition|)
name|output
argument_list|(
literal|2
argument_list|,
literal|"Auto-merged %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (content): merge conflict in %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|index_only
condition|)
name|update_stages
argument_list|(
name|ren1_dst
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
literal|1
comment|/* clear */
argument_list|)
expr_stmt|;
block|}
name|update_file
argument_list|(
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Renamed in 1, maybe changed in 2 */
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
comment|/* we only use sha1 and mode of these */
name|struct
name|diff_filespec
name|src_other
decl_stmt|,
name|dst_other
decl_stmt|;
name|int
name|try_merge
decl_stmt|,
name|stage
init|=
name|a_renames
operator|==
name|renames1
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|remove_file
argument_list|(
literal|1
argument_list|,
name|ren1_src
argument_list|,
name|index_only
operator|||
name|stage
operator|==
literal|3
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|src_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|dst_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|mode
expr_stmt|;
name|try_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|ren1_dst
argument_list|)
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (rename/directory): Renamed %s->%s in %s "
literal|" directory %s added in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|conflict_rename_dir
argument_list|(
name|ren1
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sha_eq
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (rename/delete): Renamed %s->%s in %s "
literal|"and deleted in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_path
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|try_merge
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (rename/add): Renamed %s->%s in %s. "
literal|"%s added in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|new_path
operator|=
name|unique_path
argument_list|(
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"Added as %s instead"
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|dst_other
operator|.
name|sha1
argument_list|,
name|dst_other
operator|.
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|item
operator|=
name|path_list_lookup
argument_list|(
name|ren1_dst
argument_list|,
name|renames2Dst
argument_list|)
operator|)
condition|)
block|{
name|ren2
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (rename/rename): Renamed %s->%s in %s. "
literal|"Renamed %s->%s in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|conflict_rename_rename_2
argument_list|(
name|ren1
argument_list|,
name|branch1
argument_list|,
name|ren2
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
block|}
else|else
name|try_merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|try_merge
condition|)
block|{
name|struct
name|diff_filespec
modifier|*
name|o
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|src_other
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ren1_src
expr_stmt|;
name|o
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
expr_stmt|;
if|if
condition|(
name|a_renames
operator|==
name|renames1
condition|)
block|{
name|a
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|b
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|a
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
name|mfi
operator|=
name|merge_file
argument_list|(
name|o
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|a_branch
argument_list|,
name|b_branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|clean
operator|&&
name|sha_eq
argument_list|(
name|mfi
operator|.
name|sha
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|)
operator|&&
name|mfi
operator|.
name|mode
operator|==
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
condition|)
comment|/* 					 * This messaged is part of 					 * t6022 test. If you change 					 * it update the test too. 					 */
name|output
argument_list|(
literal|3
argument_list|,
literal|"Skipped %s (merged same as existing)"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mfi
operator|.
name|merge
operator|||
operator|!
name|mfi
operator|.
name|clean
condition|)
name|output
argument_list|(
literal|1
argument_list|,
literal|"Renamed %s => %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
condition|)
name|output
argument_list|(
literal|2
argument_list|,
literal|"Auto-merged %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (rename/modify): Merge conflict in %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|index_only
condition|)
name|update_stages
argument_list|(
name|ren1_dst
argument_list|,
name|o
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update_file
argument_list|(
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|path_list_clear
argument_list|(
operator|&
name|a_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
operator|&
name|b_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|stage_sha
specifier|static
name|unsigned
name|char
modifier|*
name|stage_sha
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|)
block|{
return|return
operator|(
name|is_null_sha1
argument_list|(
name|sha
argument_list|)
operator|||
name|mode
operator|==
literal|0
operator|)
condition|?
name|NULL
else|:
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sha
return|;
block|}
end_function
begin_comment
comment|/* Per entry merge function */
end_comment
begin_function
DECL|function|process_entry
specifier|static
name|int
name|process_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stage_data
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
comment|/* 	printf("processing entry, clean cache: %s\n", index_only ? "yes": "no"); 	print_index_entry("\tpath: ", entry); 	*/
name|int
name|clean_merge
init|=
literal|1
decl_stmt|;
name|unsigned
name|o_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|a_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|b_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|o_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
name|o_mode
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|a_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
name|a_mode
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
name|b_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|o_sha
operator|&&
operator|(
operator|!
name|a_sha
operator|||
operator|!
name|b_sha
operator|)
condition|)
block|{
comment|/* Case A: Deleted in one */
if|if
condition|(
operator|(
operator|!
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
name|sha_eq
argument_list|(
name|a_sha
argument_list|,
name|o_sha
argument_list|)
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|a_sha
operator|&&
name|sha_eq
argument_list|(
name|b_sha
argument_list|,
name|o_sha
argument_list|)
operator|)
condition|)
block|{
comment|/* Deleted in both or deleted in one and 			 * unchanged in the other */
if|if
condition|(
name|a_sha
condition|)
name|output
argument_list|(
literal|2
argument_list|,
literal|"Removed %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* do not touch working file if it did not exist */
name|remove_file
argument_list|(
literal|1
argument_list|,
name|path
argument_list|,
operator|!
name|a_sha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Deleted in one and changed in the other */
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|a_sha
condition|)
block|{
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (delete/modify): %s deleted in %s "
literal|"and modified in %s. Version %s of %s left in tree."
argument_list|,
name|path
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
name|branch2
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (delete/modify): %s deleted in %s "
literal|"and modified in %s. Version %s of %s left in tree."
argument_list|,
name|path
argument_list|,
name|branch2
argument_list|,
name|branch1
argument_list|,
name|branch1
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|o_sha
operator|&&
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|o_sha
operator|&&
operator|!
name|a_sha
operator|&&
name|b_sha
operator|)
condition|)
block|{
comment|/* Case B: Added in one. */
specifier|const
name|char
modifier|*
name|add_branch
decl_stmt|;
specifier|const
name|char
modifier|*
name|other_branch
decl_stmt|;
name|unsigned
name|mode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha
decl_stmt|;
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
if|if
condition|(
name|a_sha
condition|)
block|{
name|add_branch
operator|=
name|branch1
expr_stmt|;
name|other_branch
operator|=
name|branch2
expr_stmt|;
name|mode
operator|=
name|a_mode
expr_stmt|;
name|sha
operator|=
name|a_sha
expr_stmt|;
name|conf
operator|=
literal|"file/directory"
expr_stmt|;
block|}
else|else
block|{
name|add_branch
operator|=
name|branch2
expr_stmt|;
name|other_branch
operator|=
name|branch1
expr_stmt|;
name|mode
operator|=
name|b_mode
expr_stmt|;
name|sha
operator|=
name|b_sha
expr_stmt|;
name|conf
operator|=
literal|"directory/file"
expr_stmt|;
block|}
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|path
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|path
argument_list|,
name|add_branch
argument_list|)
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (%s): There is a directory with name %s in %s. "
literal|"Added %s as %s"
argument_list|,
name|conf
argument_list|,
name|path
argument_list|,
name|other_branch
argument_list|,
name|path
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
literal|2
argument_list|,
literal|"Added %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|1
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|a_sha
operator|&&
name|b_sha
condition|)
block|{
comment|/* Case C: Added in both (check for same permissions) and */
comment|/* case D: Modified in both, but differently. */
specifier|const
name|char
modifier|*
name|reason
init|=
literal|"content"
decl_stmt|;
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|struct
name|diff_filespec
name|o
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|o_sha
condition|)
block|{
name|reason
operator|=
literal|"add/add"
expr_stmt|;
name|o_sha
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|null_sha1
expr_stmt|;
block|}
name|output
argument_list|(
literal|2
argument_list|,
literal|"Auto-merged %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|o
operator|.
name|path
operator|=
name|a
operator|.
name|path
operator|=
name|b
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|path
expr_stmt|;
name|hashcpy
argument_list|(
name|o
operator|.
name|sha1
argument_list|,
name|o_sha
argument_list|)
expr_stmt|;
name|o
operator|.
name|mode
operator|=
name|o_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|a
operator|.
name|sha1
argument_list|,
name|a_sha
argument_list|)
expr_stmt|;
name|a
operator|.
name|mode
operator|=
name|a_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|.
name|sha1
argument_list|,
name|b_sha
argument_list|)
expr_stmt|;
name|b
operator|.
name|mode
operator|=
name|b_mode
expr_stmt|;
name|mfi
operator|=
name|merge_file
argument_list|(
operator|&
name|o
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|clean
condition|)
name|update_file
argument_list|(
literal|1
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|1
argument_list|,
literal|"CONFLICT (%s): Merge conflict in %s"
argument_list|,
name|reason
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
name|update_file
argument_list|(
literal|0
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
name|update_file_flags
argument_list|(
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|,
literal|0
comment|/* update_cache */
argument_list|,
literal|1
comment|/* update_working_directory */
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|o_sha
operator|&&
operator|!
name|a_sha
operator|&&
operator|!
name|b_sha
condition|)
block|{
comment|/* 		 * this entry was deleted altogether. a_mode == 0 means 		 * we had that path and want to actively remove it. 		 */
name|remove_file
argument_list|(
literal|1
argument_list|,
name|path
argument_list|,
operator|!
name|a_mode
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"Fatal merge failure, shouldn't happen."
argument_list|)
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|merge_trees
specifier|static
name|int
name|merge_trees
parameter_list|(
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|,
name|struct
name|tree
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|clean
decl_stmt|;
if|if
condition|(
name|subtree_merge
condition|)
block|{
name|merge
operator|=
name|shift_tree_object
argument_list|(
name|head
argument_list|,
name|merge
argument_list|)
expr_stmt|;
name|common
operator|=
name|shift_tree_object
argument_list|(
name|head
argument_list|,
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sha_eq
argument_list|(
name|common
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|output
argument_list|(
literal|0
argument_list|,
literal|"Already uptodate!"
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|head
expr_stmt|;
return|return
literal|1
return|;
block|}
name|code
operator|=
name|git_merge_trees
argument_list|(
name|index_only
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"merging of trees %s and %s failed"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmerged_index
argument_list|()
condition|)
block|{
name|struct
name|path_list
modifier|*
name|entries
decl_stmt|,
modifier|*
name|re_head
decl_stmt|,
modifier|*
name|re_merge
decl_stmt|;
name|int
name|i
decl_stmt|;
name|path_list_clear
argument_list|(
operator|&
name|current_file_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
operator|&
name|current_directory_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|entries
operator|=
name|get_unmerged
argument_list|()
expr_stmt|;
name|re_head
operator|=
name|get_renames
argument_list|(
name|head
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|re_merge
operator|=
name|get_renames
argument_list|(
name|merge
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|clean
operator|=
name|process_renames
argument_list|(
name|re_head
argument_list|,
name|re_merge
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|path
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|processed
operator|&&
operator|!
name|process_entry
argument_list|(
name|path
argument_list|,
name|e
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
block|}
name|path_list_clear
argument_list|(
name|re_merge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
name|re_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
name|entries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
operator|*
name|result
operator|=
name|git_write_tree
argument_list|()
expr_stmt|;
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|reverse_commit_list
specifier|static
name|struct
name|commit_list
modifier|*
name|reverse_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
name|NULL
decl_stmt|,
modifier|*
name|current
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
for|for
control|(
name|current
operator|=
name|list
init|;
name|current
condition|;
name|current
operator|=
name|backup
control|)
block|{
name|backup
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|current
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|current
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function
begin_comment
comment|/*  * Merge the commits h1 and h2, return the resulting virtual  * commit object and a flag indicating the cleanness of the merge.  */
end_comment
begin_function
DECL|function|merge
specifier|static
name|int
name|merge
parameter_list|(
name|struct
name|commit
modifier|*
name|h1
parameter_list|,
name|struct
name|commit
modifier|*
name|h2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|,
name|struct
name|commit_list
modifier|*
name|ca
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|iter
decl_stmt|;
name|struct
name|commit
modifier|*
name|merged_common_ancestors
decl_stmt|;
name|struct
name|tree
modifier|*
name|mrtree
decl_stmt|;
name|int
name|clean
decl_stmt|;
if|if
condition|(
name|show
argument_list|(
literal|4
argument_list|)
condition|)
block|{
name|output
argument_list|(
literal|4
argument_list|,
literal|"Merging:"
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|h1
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|h2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ca
condition|)
block|{
name|ca
operator|=
name|get_merge_bases
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ca
operator|=
name|reverse_commit_list
argument_list|(
name|ca
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show
argument_list|(
literal|5
argument_list|)
condition|)
block|{
name|output
argument_list|(
literal|5
argument_list|,
literal|"found %u common ancestor(s):"
argument_list|,
name|commit_list_count
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
name|output_commit_title
argument_list|(
name|iter
operator|->
name|item
argument_list|)
expr_stmt|;
block|}
name|merged_common_ancestors
operator|=
name|pop_commit
argument_list|(
operator|&
name|ca
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_common_ancestors
operator|==
name|NULL
condition|)
block|{
comment|/* if there is no common ancestor, make an empty tree */
name|struct
name|tree
modifier|*
name|tree
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|tree
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|tree
operator|->
name|object
operator|.
name|type
operator|=
name|OBJ_TREE
expr_stmt|;
name|pretend_sha1_file
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|OBJ_TREE
argument_list|,
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|merged_common_ancestors
operator|=
name|make_virtual_commit
argument_list|(
name|tree
argument_list|,
literal|"ancestor"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
name|call_depth
operator|++
expr_stmt|;
comment|/* 		 * When the merge fails, the result contains files 		 * with conflict markers. The cleanness flag is 		 * ignored, it was never actually used, as result of 		 * merge_trees has always overwritten it: the committed 		 * "conflicts" were already resolved. 		 */
name|discard_cache
argument_list|()
expr_stmt|;
name|merge
argument_list|(
name|merged_common_ancestors
argument_list|,
name|iter
operator|->
name|item
argument_list|,
literal|"Temporary merge branch 1"
argument_list|,
literal|"Temporary merge branch 2"
argument_list|,
name|NULL
argument_list|,
operator|&
name|merged_common_ancestors
argument_list|)
expr_stmt|;
name|call_depth
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|merged_common_ancestors
condition|)
name|die
argument_list|(
literal|"merge returned no commit"
argument_list|)
expr_stmt|;
block|}
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|call_depth
condition|)
block|{
name|read_cache
argument_list|()
expr_stmt|;
name|index_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|index_only
operator|=
literal|1
expr_stmt|;
name|clean
operator|=
name|merge_trees
argument_list|(
name|h1
operator|->
name|tree
argument_list|,
name|h2
operator|->
name|tree
argument_list|,
name|merged_common_ancestors
operator|->
name|tree
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
operator|&
name|mrtree
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
block|{
operator|*
name|result
operator|=
name|make_virtual_commit
argument_list|(
name|mrtree
argument_list|,
literal|"merged tree"
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h1
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h2
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
name|flush_output
argument_list|()
expr_stmt|;
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|better_branch_name
specifier|static
specifier|const
name|char
modifier|*
name|better_branch_name
parameter_list|(
specifier|const
name|char
modifier|*
name|branch
parameter_list|)
block|{
specifier|static
name|char
name|githead_env
index|[
literal|8
operator|+
literal|40
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|branch
argument_list|)
operator|!=
literal|40
condition|)
return|return
name|branch
return|;
name|sprintf
argument_list|(
name|githead_env
argument_list|,
literal|"GITHEAD_%s"
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|name
operator|=
name|getenv
argument_list|(
name|githead_env
argument_list|)
expr_stmt|;
return|return
name|name
condition|?
name|name
else|:
name|branch
return|;
block|}
end_function
begin_function
DECL|function|get_ref
specifier|static
name|struct
name|commit
modifier|*
name|get_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|object
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|ref
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not resolve ref '%s'"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|object
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|ref
argument_list|,
name|strlen
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJ_TREE
condition|)
return|return
name|make_virtual_commit
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|object
argument_list|,
name|better_branch_name
argument_list|(
name|ref
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|parse_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not parse commit '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
return|;
block|}
end_function
begin_function
DECL|function|merge_config
specifier|static
name|int
name|merge_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
argument_list|,
literal|"merge.verbosity"
argument_list|)
condition|)
block|{
name|verbosity
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|bases
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|unsigned
name|bases_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clean
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch1
decl_stmt|,
modifier|*
name|branch2
decl_stmt|;
name|struct
name|commit
modifier|*
name|result
decl_stmt|,
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h2
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|ca
init|=
name|NULL
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|index_fd
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
condition|)
block|{
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
literal|8
operator|<
name|namelen
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
name|namelen
operator|-
literal|8
argument_list|,
literal|"-subtree"
argument_list|)
condition|)
name|subtree_merge
operator|=
literal|1
expr_stmt|;
block|}
name|git_config
argument_list|(
name|merge_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GIT_MERGE_VERBOSITY"
argument_list|)
condition|)
name|verbosity
operator|=
name|strtol
argument_list|(
name|getenv
argument_list|(
literal|"GIT_MERGE_VERBOSITY"
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
name|die
argument_list|(
literal|"Usage: %s<base>... --<head><remote> ...\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|bases_count
operator|<
sizeof|sizeof
argument_list|(
name|bases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|bases
argument_list|)
condition|)
name|bases
index|[
name|bases_count
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|-
name|i
operator|!=
literal|3
condition|)
comment|/* "--" "<head>" "<remote>" */
name|die
argument_list|(
literal|"Not handling anything other than two heads merge."
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|5
condition|)
name|buffer_output
operator|=
literal|0
expr_stmt|;
name|branch1
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|branch2
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|h1
operator|=
name|get_ref
argument_list|(
name|branch1
argument_list|)
expr_stmt|;
name|h2
operator|=
name|get_ref
argument_list|(
name|branch2
argument_list|)
expr_stmt|;
name|branch1
operator|=
name|better_branch_name
argument_list|(
name|branch1
argument_list|)
expr_stmt|;
name|branch2
operator|=
name|better_branch_name
argument_list|(
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
argument_list|(
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Merging %s with %s\n"
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|index_fd
operator|=
name|hold_locked_index
argument_list|(
name|lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bases_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|commit
modifier|*
name|ancestor
init|=
name|get_ref
argument_list|(
name|bases
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|ca
operator|=
name|commit_list_insert
argument_list|(
name|ancestor
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
block|}
name|clean
operator|=
name|merge
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
name|ca
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|&&
operator|(
name|write_cache
argument_list|(
name|index_fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close
argument_list|(
name|index_fd
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"unable to write %s"
argument_list|,
name|get_index_file
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|clean
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
end_unit
