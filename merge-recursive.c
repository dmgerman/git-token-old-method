begin_unit
begin_comment
comment|/*  * Recursive Merge algorithm stolen from git-merge-recursive.py by  * Fredrik Kuivinen.  * The thieves were Alex Riesen and Johannes Schindelin, in June/July 2006  */
end_comment
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<sys/wait.h>
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/stat.h>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"path-list.h"
end_include
begin_comment
comment|/*  * A virtual commit has  * - (const char *)commit->util set to the name, and  * - *(int *)commit->object.sha1 set to the virtual id.  */
end_comment
begin_function
DECL|function|commit_list_count
specifier|static
name|unsigned
name|commit_list_count
parameter_list|(
specifier|const
name|struct
name|commit_list
modifier|*
name|l
parameter_list|)
block|{
name|unsigned
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|c
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|make_virtual_commit
specifier|static
name|struct
name|commit
modifier|*
name|make_virtual_commit
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commit
argument_list|)
argument_list|)
decl_stmt|;
specifier|static
name|unsigned
name|virtual_id
init|=
literal|1
decl_stmt|;
name|commit
operator|->
name|tree
operator|=
name|tree
expr_stmt|;
name|commit
operator|->
name|util
operator|=
operator|(
name|void
operator|*
operator|)
name|comment
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|commit
operator|->
name|object
operator|.
name|sha1
operator|=
name|virtual_id
operator|++
expr_stmt|;
comment|/* avoid warnings */
name|commit
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
return|return
name|commit
return|;
block|}
end_function
begin_comment
comment|/*  * Since we use get_tree_entry(), which does not put the read object into  * the object pool, we cannot rely on a == b.  */
end_comment
begin_function
DECL|function|sha_eq
specifier|static
name|int
name|sha_eq
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|&&
operator|!
name|b
condition|)
return|return
literal|2
return|;
return|return
name|a
operator|&&
name|b
operator|&&
name|memcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|20
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Since we want to write the index eventually, we cannot reuse the index  * for these (temporary) data.  */
end_comment
begin_struct
DECL|struct|stage_data
struct|struct
name|stage_data
block|{
struct|struct
block|{
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
block|}
DECL|member|stages
name|stages
index|[
literal|4
index|]
struct|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|current_file_set
specifier|static
name|struct
name|path_list
name|current_file_set
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_directory_set
specifier|static
name|struct
name|path_list
name|current_directory_set
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|output_indent
specifier|static
name|int
name|output_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|output
specifier|static
name|void
name|output
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|output_indent
init|;
name|i
operator|--
condition|;
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_commit_title
specifier|static
name|void
name|output_commit_title
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|output_indent
init|;
name|i
operator|--
condition|;
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|util
condition|)
name|printf
argument_list|(
literal|"virtual %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|commit
operator|->
name|util
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"(bad commit)\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|commit
operator|->
name|buffer
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|s
index|[
name|len
index|]
operator|&&
literal|'\n'
operator|!=
name|s
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
name|len
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|original_index_file
specifier|static
specifier|const
name|char
modifier|*
name|original_index_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|temporary_index_file
specifier|static
specifier|const
name|char
modifier|*
name|temporary_index_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cache_dirty
specifier|static
name|int
name|cache_dirty
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|flush_cache
specifier|static
name|int
name|flush_cache
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* flush temporary index */
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|hold_lock_file_for_update
argument_list|(
name|lock
argument_list|,
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not lock %s"
argument_list|,
name|lock
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close
argument_list|(
name|fd
argument_list|)
operator|||
name|commit_lock_file
argument_list|(
name|lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write %s"
argument_list|,
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
name|cache_dirty
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setup_index
specifier|static
name|void
name|setup_index
parameter_list|(
name|int
name|temp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|idx
init|=
name|temp
condition|?
name|temporary_index_file
else|:
name|original_index_file
decl_stmt|;
if|if
condition|(
name|cache_dirty
condition|)
name|die
argument_list|(
literal|"fatal: cache changed flush_cache();"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|temporary_index_file
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_cache_entry
specifier|static
name|struct
name|cache_entry
modifier|*
name|make_cache_entry
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|stage
parameter_list|,
name|int
name|refresh
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
operator|!
name|verify_path
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|size
operator|=
name|cache_entry_size
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
name|len
argument_list|,
name|stage
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|refresh
condition|)
return|return
name|refresh_cache_entry
argument_list|(
name|ce
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|ce
return|;
block|}
end_function
begin_function
DECL|function|add_cacheinfo
specifier|static
name|int
name|add_cacheinfo
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|stage
parameter_list|,
name|int
name|refresh
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
operator|!
name|cache_dirty
condition|)
name|read_cache_from
argument_list|(
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|cache_dirty
operator|++
expr_stmt|;
name|ce
operator|=
name|make_cache_entry
argument_list|(
name|mode
argument_list|,
name|sha1
condition|?
name|sha1
else|:
name|null_sha1
argument_list|,
name|path
argument_list|,
name|stage
argument_list|,
name|refresh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
name|error
argument_list|(
literal|"cache_addinfo failed: %s"
argument_list|,
name|strerror
argument_list|(
name|cache_errno
argument_list|)
argument_list|)
return|;
return|return
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * This is a global variable which is used in a number of places but  * only written to in the 'merge' function.  *  * index_only == 1    => Don't leave any non-stage 0 entries in the cache and  *                       don't update the working directory.  *               0    => Leave unmerged entries in the cache and update  *                       the working directory.  */
end_comment
begin_decl_stmt
DECL|variable|index_only
specifier|static
name|int
name|index_only
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_read_tree
specifier|static
name|int
name|git_read_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|object_list
modifier|*
name|trees
init|=
name|NULL
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
if|if
condition|(
name|cache_dirty
condition|)
name|die
argument_list|(
literal|"read-tree with dirty cache"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|object_list_append
argument_list|(
operator|&
name|tree
operator|->
name|object
argument_list|,
operator|&
name|trees
argument_list|)
expr_stmt|;
name|rc
operator|=
name|unpack_trees
argument_list|(
name|trees
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|cache_tree_free
argument_list|(
operator|&
name|active_cache_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|cache_dirty
operator|=
literal|1
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|git_merge_trees
specifier|static
name|int
name|git_merge_trees
parameter_list|(
name|int
name|index_only
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|object_list
modifier|*
name|trees
init|=
name|NULL
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
if|if
condition|(
operator|!
name|cache_dirty
condition|)
block|{
name|read_cache_from
argument_list|(
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|cache_dirty
operator|=
literal|1
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
name|opts
operator|.
name|index_only
operator|=
literal|1
expr_stmt|;
else|else
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|2
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|threeway_merge
expr_stmt|;
name|object_list_append
argument_list|(
operator|&
name|common
operator|->
name|object
argument_list|,
operator|&
name|trees
argument_list|)
expr_stmt|;
name|object_list_append
argument_list|(
operator|&
name|head
operator|->
name|object
argument_list|,
operator|&
name|trees
argument_list|)
expr_stmt|;
name|object_list_append
argument_list|(
operator|&
name|merge
operator|->
name|object
argument_list|,
operator|&
name|trees
argument_list|)
expr_stmt|;
name|rc
operator|=
name|unpack_trees
argument_list|(
name|trees
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|cache_tree_free
argument_list|(
operator|&
name|active_cache_tree
argument_list|)
expr_stmt|;
name|cache_dirty
operator|=
literal|1
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|git_write_tree
specifier|static
name|struct
name|tree
modifier|*
name|git_write_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cache_dirty
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
else|else
name|read_cache_from
argument_list|(
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active_cache_tree
condition|)
name|active_cache_tree
operator|=
name|cache_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cache_tree_fully_valid
argument_list|(
name|active_cache_tree
argument_list|)
operator|&&
name|cache_tree_update
argument_list|(
name|active_cache_tree
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"error building trees"
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup_tree
argument_list|(
name|active_cache_tree
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|flush_cache
argument_list|()
expr_stmt|;
name|cache_dirty
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|save_files_dirs
specifier|static
name|int
name|save_files_dirs
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|int
name|stage
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newpath
init|=
name|malloc
argument_list|(
name|baselen
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newpath
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newpath
operator|+
name|baselen
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newpath
index|[
name|baselen
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|path_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|current_directory_set
argument_list|)
expr_stmt|;
else|else
name|path_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|current_file_set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
name|READ_TREE_RECURSIVE
return|;
block|}
end_function
begin_function
DECL|function|get_files_dirs
specifier|static
name|int
name|get_files_dirs
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|read_tree_recursive
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|save_files_dirs
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|current_file_set
operator|.
name|nr
operator|+
name|current_directory_set
operator|.
name|nr
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*  * Returns a index_entry instance which doesn't have to correspond to  * a real cache entry in Git's index.  */
end_comment
begin_function
DECL|function|insert_stage_data
specifier|static
name|struct
name|stage_data
modifier|*
name|insert_stage_data
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|tree
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|a
parameter_list|,
name|struct
name|tree
modifier|*
name|b
parameter_list|,
name|struct
name|path_list
modifier|*
name|entries
parameter_list|)
block|{
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
decl_stmt|;
name|get_tree_entry
argument_list|(
name|o
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|a
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|b
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|item
operator|=
name|path_list_insert
argument_list|(
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|e
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_comment
comment|/*  * Create a dictionary mapping file names to stage_data objects. The  * dictionary contains one entry for every path with a non-zero stage entry.  */
end_comment
begin_function
DECL|function|get_unmerged
specifier|static
name|struct
name|path_list
modifier|*
name|get_unmerged
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|path_list
modifier|*
name|unmerged
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unmerged
operator|->
name|strdup_paths
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cache_dirty
condition|)
block|{
name|read_cache_from
argument_list|(
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|cache_dirty
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
continue|continue;
name|item
operator|=
name|path_list_lookup
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|unmerged
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|item
operator|=
name|path_list_insert
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|unmerged
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|mode
operator|=
name|ntohl
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|sha
argument_list|,
name|ce
operator|->
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
return|return
name|unmerged
return|;
block|}
end_function
begin_struct
DECL|struct|rename
struct|struct
name|rename
block|{
DECL|member|pair
name|struct
name|diff_filepair
modifier|*
name|pair
decl_stmt|;
DECL|member|src_entry
name|struct
name|stage_data
modifier|*
name|src_entry
decl_stmt|;
DECL|member|dst_entry
name|struct
name|stage_data
modifier|*
name|dst_entry
decl_stmt|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Get information of all renames which occured between 'o_tree' and  * 'tree'. We need the three trees in the merge ('o_tree', 'a_tree' and  * 'b_tree') to be able to associate the correct cache entries with  * the rename information. 'tree' is always equal to either a_tree or b_tree.  */
end_comment
begin_function
DECL|function|get_renames
specifier|static
name|struct
name|path_list
modifier|*
name|get_renames
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|struct
name|tree
modifier|*
name|o_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|a_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|b_tree
parameter_list|,
name|struct
name|path_list
modifier|*
name|entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|path_list
modifier|*
name|renames
decl_stmt|;
name|struct
name|diff_options
name|opts
decl_stmt|;
name|renames
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|path_list
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|recursive
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|detect_rename
operator|=
name|DIFF_DETECT_RENAME
expr_stmt|;
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff setup failed"
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|o_tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|rename
modifier|*
name|re
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|pair
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pair
operator|->
name|status
operator|!=
literal|'R'
condition|)
block|{
name|diff_free_filepair
argument_list|(
name|pair
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|re
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|re
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|pair
operator|=
name|pair
expr_stmt|;
name|item
operator|=
name|path_list_lookup
argument_list|(
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|src_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|src_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|path_list_lookup
argument_list|(
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|dst_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|dst_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|path_list_insert
argument_list|(
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|renames
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|re
expr_stmt|;
block|}
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_queued_diff
operator|.
name|nr
operator|=
literal|0
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
return|return
name|renames
return|;
block|}
end_function
begin_function
DECL|function|update_stages
name|int
name|update_stages
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
name|int
name|options
init|=
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_OK_TO_REPLACE
decl_stmt|;
if|if
condition|(
name|clear
condition|)
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|o
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|o
operator|->
name|mode
argument_list|,
name|o
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|a
operator|->
name|mode
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|b
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|b
operator|->
name|mode
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|remove_path
specifier|static
name|int
name|remove_path
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|dirs
decl_stmt|;
name|ret
operator|=
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dirs
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dirs
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dirs
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|slash
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|slash
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * TODO: once we no longer call external programs, we'd probably be better off  * not setting / getting the environment variable GIT_INDEX_FILE all the time.  */
end_comment
begin_function
DECL|function|remove_file
name|int
name|remove_file
parameter_list|(
name|int
name|clean
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|update_cache
init|=
name|index_only
operator|||
name|clean
decl_stmt|;
name|int
name|update_working_directory
init|=
operator|!
name|index_only
decl_stmt|;
if|if
condition|(
name|update_cache
condition|)
block|{
if|if
condition|(
operator|!
name|cache_dirty
condition|)
name|read_cache_from
argument_list|(
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
argument_list|)
expr_stmt|;
name|cache_dirty
operator|++
expr_stmt|;
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|update_working_directory
condition|)
block|{
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|||
name|errno
operator|!=
name|EISDIR
condition|)
return|return
operator|-
literal|1
return|;
name|remove_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unique_path
specifier|static
name|char
modifier|*
name|unique_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|branch
parameter_list|)
block|{
name|char
modifier|*
name|newpath
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|8
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|suffix
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|newpath
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'~'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|branch
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
literal|'/'
operator|==
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
while|while
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_file_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|lstat
argument_list|(
name|newpath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"_%d"
argument_list|,
name|suffix
operator|++
argument_list|)
expr_stmt|;
name|path_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|current_file_set
argument_list|)
expr_stmt|;
return|return
name|newpath
return|;
block|}
end_function
begin_function
DECL|function|mkdir_p
specifier|static
name|int
name|mkdir_p
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|long
name|mode
parameter_list|)
block|{
comment|/* path points to cache entries, so strdup before messing with it */
name|char
modifier|*
name|buf
init|=
name|strdup
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|safe_create_leading_directories
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|flush_buffer
specifier|static
name|void
name|flush_buffer
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|long
name|ret
init|=
name|xwrite
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Ignore epipe */
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
break|break;
name|die
argument_list|(
literal|"merge-recursive: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|die
argument_list|(
literal|"merge-recursive: disk full?"
argument_list|)
expr_stmt|;
block|}
name|size
operator|-=
name|ret
expr_stmt|;
name|buf
operator|+=
name|ret
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|update_file_flags
name|void
name|update_file_flags
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|update_cache
parameter_list|,
name|int
name|update_wd
parameter_list|)
block|{
if|if
condition|(
name|index_only
condition|)
name|update_wd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|update_wd
condition|)
block|{
name|char
name|type
index|[
literal|20
index|]
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha
argument_list|,
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"cannot read object %s '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|blob_type
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"blob expected for %s '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|mkdir_p
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
condition|)
name|die
argument_list|(
literal|"failed to create path %s: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|0100
condition|)
name|mode
operator|=
literal|0777
expr_stmt|;
else|else
name|mode
operator|=
literal|0666
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"failed to open %s: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|lnk
init|=
name|malloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|lnk
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|lnk
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mkdir_p
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
name|symlink
argument_list|(
name|lnk
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"do not know what to do with %06o %s '%s'"
argument_list|,
name|mode
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_cache
condition|)
name|add_cacheinfo
argument_list|(
name|mode
argument_list|,
name|sha
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|update_wd
argument_list|,
name|ADD_CACHE_OK_TO_ADD
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_file
name|void
name|update_file
parameter_list|(
name|int
name|clean
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|update_file_flags
argument_list|(
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|,
name|index_only
operator|||
name|clean
argument_list|,
operator|!
name|index_only
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Low level file merging, update and removal */
end_comment
begin_struct
DECL|struct|merge_file_info
struct|struct
name|merge_file_info
block|{
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|clean
name|unsigned
name|clean
range|:
literal|1
decl_stmt|,
DECL|member|merge
name|merge
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|git_unpack_file
specifier|static
name|char
modifier|*
name|git_unpack_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|char
name|type
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
name|blob_type
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to read blob object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
literal|".merge_file_XXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to create temp-file"
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function
begin_function
DECL|function|merge_file
specifier|static
name|struct
name|merge_file_info
name|merge_file
parameter_list|(
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|struct
name|merge_file_info
name|result
decl_stmt|;
name|result
operator|.
name|merge
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|S_IFMT
operator|&
name|a
operator|->
name|mode
operator|)
operator|!=
operator|(
name|S_IFMT
operator|&
name|b
operator|->
name|mode
operator|)
condition|)
block|{
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|mode
operator|=
name|b
operator|->
name|mode
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
operator|&&
operator|!
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
operator|==
name|o
operator|->
name|mode
condition|?
name|b
operator|->
name|mode
else|:
name|a
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
condition|)
name|memcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
condition|)
name|memcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|int
name|code
init|=
literal|1
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|orig
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|src1
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|src2
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[]
init|=
block|{
literal|"merge"
block|,
literal|"-L"
block|,
name|NULL
block|,
literal|"-L"
block|,
name|NULL
block|,
literal|"-L"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
name|la
decl_stmt|,
modifier|*
name|lb
decl_stmt|,
modifier|*
name|lo
decl_stmt|;
name|git_unpack_file
argument_list|(
name|o
operator|->
name|sha1
argument_list|,
name|orig
argument_list|)
expr_stmt|;
name|git_unpack_file
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|git_unpack_file
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|la
operator|=
name|strdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s/%s"
argument_list|,
name|branch1
argument_list|,
name|a
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|=
name|lb
operator|=
name|strdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s/%s"
argument_list|,
name|branch2
argument_list|,
name|b
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|=
name|lo
operator|=
name|strdup
argument_list|(
name|mkpath
argument_list|(
literal|"orig/%s"
argument_list|,
name|o
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|=
name|src1
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|=
name|orig
expr_stmt|;
name|argv
index|[
literal|9
index|]
operator|=
name|src2
operator|,
name|code
operator|=
name|run_command_v
argument_list|(
literal|10
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|&&
name|code
operator|<
operator|-
literal|256
condition|)
block|{
name|die
argument_list|(
literal|"Failed to execute 'merge'. merge(1) is used as the "
literal|"file-level merge tool. Is 'merge' in your path?"
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|src1
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
name|index_fd
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|fd
argument_list|,
operator|&
name|st
argument_list|,
literal|1
argument_list|,
literal|"blob"
argument_list|)
condition|)
name|die
argument_list|(
literal|"Unable to add %s to database"
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|src1
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|src2
argument_list|)
expr_stmt|;
name|result
operator|.
name|clean
operator|=
name|WEXITSTATUS
argument_list|(
name|code
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|S_ISLNK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
operator|||
name|S_ISLNK
argument_list|(
name|b
operator|->
name|mode
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"cannot merge modes?"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|conflict_rename_rename
specifier|static
name|void
name|conflict_rename_rename
parameter_list|(
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
name|struct
name|rename
modifier|*
name|ren2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|char
modifier|*
name|del
index|[
literal|2
index|]
decl_stmt|;
name|int
name|delp
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren1_dst
init|=
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren2_dst
init|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_name1
init|=
name|ren1_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_name2
init|=
name|ren2_dst
decl_stmt|;
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|ren1_dst
argument_list|)
condition|)
block|{
name|dst_name1
operator|=
name|del
index|[
name|delp
operator|++
index|]
operator|=
name|unique_path
argument_list|(
name|ren1_dst
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|"%s is a directory in %s adding as %s instead"
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|,
name|dst_name1
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|ren2_dst
argument_list|)
condition|)
block|{
name|dst_name2
operator|=
name|del
index|[
name|delp
operator|++
index|]
operator|=
name|unique_path
argument_list|(
name|ren2_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|"%s is a directory in %s adding as %s instead"
argument_list|,
name|ren2_dst
argument_list|,
name|branch1
argument_list|,
name|dst_name2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren2_dst
argument_list|)
expr_stmt|;
block|}
name|update_stages
argument_list|(
name|dst_name1
argument_list|,
name|NULL
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_stages
argument_list|(
name|dst_name2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|delp
operator|--
condition|)
name|free
argument_list|(
name|del
index|[
name|delp
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_dir
specifier|static
name|void
name|conflict_rename_dir
parameter_list|(
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|)
block|{
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch1
argument_list|)
decl_stmt|;
name|output
argument_list|(
literal|"Renaming %s to %s instead"
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_rename_2
specifier|static
name|void
name|conflict_rename_rename_2
parameter_list|(
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
name|struct
name|rename
modifier|*
name|ren2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|char
modifier|*
name|new_path1
init|=
name|unique_path
argument_list|(
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_path2
init|=
name|unique_path
argument_list|(
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch2
argument_list|)
decl_stmt|;
name|output
argument_list|(
literal|"Renaming %s to %s and %s to %s instead"
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path1
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|process_renames
specifier|static
name|int
name|process_renames
parameter_list|(
name|struct
name|path_list
modifier|*
name|a_renames
parameter_list|,
name|struct
name|path_list
modifier|*
name|b_renames
parameter_list|,
specifier|const
name|char
modifier|*
name|a_branch
parameter_list|,
specifier|const
name|char
modifier|*
name|b_branch
parameter_list|)
block|{
name|int
name|clean_merge
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|path_list
name|a_by_dst
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|b_by_dst
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|struct
name|rename
modifier|*
name|sre
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|path_list_insert
argument_list|(
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
operator|&
name|a_by_dst
argument_list|)
operator|->
name|util
operator|=
name|sre
operator|->
name|dst_entry
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|b_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|path_list_insert
argument_list|(
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
operator|&
name|b_by_dst
argument_list|)
operator|->
name|util
operator|=
name|sre
operator|->
name|dst_entry
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
operator|||
name|j
operator|<
name|b_renames
operator|->
name|nr
condition|;
control|)
block|{
name|int
name|compare
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|struct
name|path_list
modifier|*
name|renames1
decl_stmt|,
modifier|*
name|renames2
decl_stmt|,
modifier|*
name|renames2Dst
decl_stmt|;
name|struct
name|rename
modifier|*
name|ren1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ren2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch1
decl_stmt|,
modifier|*
name|branch2
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren1_src
decl_stmt|,
modifier|*
name|ren1_dst
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|a_renames
operator|->
name|nr
condition|)
block|{
name|compare
operator|=
literal|1
expr_stmt|;
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>=
name|b_renames
operator|->
name|nr
condition|)
block|{
name|compare
operator|=
operator|-
literal|1
expr_stmt|;
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
else|else
block|{
name|compare
operator|=
name|strcmp
argument_list|(
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|path
argument_list|,
name|b_renames
operator|->
name|items
index|[
name|j
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|<=
literal|0
condition|)
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
if|if
condition|(
name|compare
operator|>=
literal|0
condition|)
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
comment|/* TODO: refactor, so that 1/2 are not needed */
if|if
condition|(
name|ren1
condition|)
block|{
name|renames1
operator|=
name|a_renames
expr_stmt|;
name|renames2
operator|=
name|b_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|b_by_dst
expr_stmt|;
name|branch1
operator|=
name|a_branch
expr_stmt|;
name|branch2
operator|=
name|b_branch
expr_stmt|;
block|}
else|else
block|{
name|struct
name|rename
modifier|*
name|tmp
decl_stmt|;
name|renames1
operator|=
name|b_renames
expr_stmt|;
name|renames2
operator|=
name|a_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|a_by_dst
expr_stmt|;
name|branch1
operator|=
name|b_branch
expr_stmt|;
name|branch2
operator|=
name|a_branch
expr_stmt|;
name|tmp
operator|=
name|ren2
expr_stmt|;
name|ren2
operator|=
name|ren1
expr_stmt|;
name|ren1
operator|=
name|tmp
expr_stmt|;
block|}
name|src
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|ren1
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1
operator|->
name|src_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ren1
operator|->
name|processed
condition|)
continue|continue;
name|ren1
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1_src
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|ren1_dst
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|ren2
condition|)
block|{
specifier|const
name|char
modifier|*
name|ren2_src
init|=
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren2_dst
init|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
comment|/* Renamed in 1 and renamed in 2 */
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_src
argument_list|,
name|ren2_src
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"ren1.src != ren2.src"
argument_list|)
expr_stmt|;
name|ren2
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_dst
argument_list|,
name|ren2_dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (rename/rename): "
literal|"Rename %s->%s in branch %s "
literal|"rename %s->%s in %s"
argument_list|,
name|src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|src
argument_list|,
name|ren2_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|conflict_rename_rename
argument_list|(
name|ren1
argument_list|,
name|branch1
argument_list|,
name|ren2
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|remove_file
argument_list|(
literal|1
argument_list|,
name|ren1_src
argument_list|)
expr_stmt|;
name|mfi
operator|=
name|merge_file
argument_list|(
name|ren1
operator|->
name|pair
operator|->
name|one
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
operator|||
operator|!
name|mfi
operator|.
name|clean
condition|)
name|output
argument_list|(
literal|"Renaming %s->%s"
argument_list|,
name|src
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
condition|)
name|output
argument_list|(
literal|"Auto-merging %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
name|output
argument_list|(
literal|"CONFLICT (content): merge conflict in %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|index_only
condition|)
name|update_stages
argument_list|(
name|ren1_dst
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
literal|1
comment|/* clear */
argument_list|)
expr_stmt|;
block|}
name|update_file
argument_list|(
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Renamed in 1, maybe changed in 2 */
name|struct
name|path_list_item
modifier|*
name|item
decl_stmt|;
comment|/* we only use sha1 and mode of these */
name|struct
name|diff_filespec
name|src_other
decl_stmt|,
name|dst_other
decl_stmt|;
name|int
name|try_merge
decl_stmt|,
name|stage
init|=
name|a_renames
operator|==
name|renames1
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|remove_file
argument_list|(
literal|1
argument_list|,
name|ren1_src
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|sha
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|src_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|mode
expr_stmt|;
name|memcpy
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|sha
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|dst_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|mode
expr_stmt|;
name|try_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|ren1_dst
argument_list|)
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (rename/directory): Rename %s->%s in %s "
literal|" directory %s added in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|conflict_rename_dir
argument_list|(
name|ren1
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sha_eq
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (rename/delete): Rename %s->%s in %s "
literal|"and deleted in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_path
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|try_merge
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (rename/add): Rename %s->%s in %s. "
literal|"%s added in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|new_path
operator|=
name|unique_path
argument_list|(
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|"Adding as %s instead"
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|dst_other
operator|.
name|sha1
argument_list|,
name|dst_other
operator|.
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|item
operator|=
name|path_list_lookup
argument_list|(
name|ren1_dst
argument_list|,
name|renames2Dst
argument_list|)
operator|)
condition|)
block|{
name|ren2
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (rename/rename): Rename %s->%s in %s. "
literal|"Rename %s->%s in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|conflict_rename_rename_2
argument_list|(
name|ren1
argument_list|,
name|branch1
argument_list|,
name|ren2
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
block|}
else|else
name|try_merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|try_merge
condition|)
block|{
name|struct
name|diff_filespec
modifier|*
name|o
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|src_other
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ren1_src
expr_stmt|;
name|o
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
expr_stmt|;
if|if
condition|(
name|a_renames
operator|==
name|renames1
condition|)
block|{
name|a
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|b
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|a
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
name|mfi
operator|=
name|merge_file
argument_list|(
name|o
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|a_branch
argument_list|,
name|b_branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
operator|||
operator|!
name|mfi
operator|.
name|clean
condition|)
name|output
argument_list|(
literal|"Renaming %s => %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
condition|)
name|output
argument_list|(
literal|"Auto-merging %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
name|output
argument_list|(
literal|"CONFLICT (rename/modify): Merge conflict in %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|index_only
condition|)
name|update_stages
argument_list|(
name|ren1_dst
argument_list|,
name|o
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update_file
argument_list|(
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|path_list_clear
argument_list|(
operator|&
name|a_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
operator|&
name|b_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_dirty
condition|)
name|flush_cache
argument_list|()
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|has_sha
specifier|static
name|unsigned
name|char
modifier|*
name|has_sha
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|)
block|{
return|return
name|memcmp
argument_list|(
name|sha
argument_list|,
name|null_sha1
argument_list|,
literal|20
argument_list|)
operator|==
literal|0
condition|?
name|NULL
else|:
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sha
return|;
block|}
end_function
begin_comment
comment|/* Per entry merge function */
end_comment
begin_function
DECL|function|process_entry
specifier|static
name|int
name|process_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stage_data
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
comment|/* 	printf("processing entry, clean cache: %s\n", index_only ? "yes": "no"); 	print_index_entry("\tpath: ", entry); 	*/
name|int
name|clean_merge
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|o_sha
init|=
name|has_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|a_sha
init|=
name|has_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b_sha
init|=
name|has_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|)
decl_stmt|;
name|unsigned
name|o_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|a_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|b_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|o_sha
operator|&&
operator|(
operator|!
name|a_sha
operator|||
operator|!
name|b_sha
operator|)
condition|)
block|{
comment|/* Case A: Deleted in one */
if|if
condition|(
operator|(
operator|!
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
name|sha_eq
argument_list|(
name|a_sha
argument_list|,
name|o_sha
argument_list|)
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|a_sha
operator|&&
name|sha_eq
argument_list|(
name|b_sha
argument_list|,
name|o_sha
argument_list|)
operator|)
condition|)
block|{
comment|/* Deleted in both or deleted in one and 			 * unchanged in the other */
if|if
condition|(
name|a_sha
condition|)
name|output
argument_list|(
literal|"Removing %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|1
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Deleted in one and changed in the other */
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|a_sha
condition|)
block|{
name|output
argument_list|(
literal|"CONFLICT (delete/modify): %s deleted in %s "
literal|"and modified in %s. Version %s of %s left in tree."
argument_list|,
name|path
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
name|branch2
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
literal|"CONFLICT (delete/modify): %s deleted in %s "
literal|"and modified in %s. Version %s of %s left in tree."
argument_list|,
name|path
argument_list|,
name|branch2
argument_list|,
name|branch1
argument_list|,
name|branch1
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|o_sha
operator|&&
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|o_sha
operator|&&
operator|!
name|a_sha
operator|&&
name|b_sha
operator|)
condition|)
block|{
comment|/* Case B: Added in one. */
specifier|const
name|char
modifier|*
name|add_branch
decl_stmt|;
specifier|const
name|char
modifier|*
name|other_branch
decl_stmt|;
name|unsigned
name|mode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha
decl_stmt|;
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
if|if
condition|(
name|a_sha
condition|)
block|{
name|add_branch
operator|=
name|branch1
expr_stmt|;
name|other_branch
operator|=
name|branch2
expr_stmt|;
name|mode
operator|=
name|a_mode
expr_stmt|;
name|sha
operator|=
name|a_sha
expr_stmt|;
name|conf
operator|=
literal|"file/directory"
expr_stmt|;
block|}
else|else
block|{
name|add_branch
operator|=
name|branch2
expr_stmt|;
name|other_branch
operator|=
name|branch1
expr_stmt|;
name|mode
operator|=
name|b_mode
expr_stmt|;
name|sha
operator|=
name|b_sha
expr_stmt|;
name|conf
operator|=
literal|"directory/file"
expr_stmt|;
block|}
if|if
condition|(
name|path_list_has_path
argument_list|(
operator|&
name|current_directory_set
argument_list|,
name|path
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|path
argument_list|,
name|add_branch
argument_list|)
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (%s): There is a directory with name %s in %s. "
literal|"Adding %s as %s"
argument_list|,
name|conf
argument_list|,
name|path
argument_list|,
name|other_branch
argument_list|,
name|path
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
literal|"Adding %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|1
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|o_sha
operator|&&
name|a_sha
operator|&&
name|b_sha
condition|)
block|{
comment|/* Case C: Added in both (check for same permissions). */
if|if
condition|(
name|sha_eq
argument_list|(
name|a_sha
argument_list|,
name|b_sha
argument_list|)
condition|)
block|{
if|if
condition|(
name|a_mode
operator|!=
name|b_mode
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT: File %s added identically in both branches, "
literal|"but permissions conflict %06o->%06o"
argument_list|,
name|path
argument_list|,
name|a_mode
argument_list|,
name|b_mode
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT: adding with permission: %06o"
argument_list|,
name|a_mode
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This case is handled by git-read-tree */
name|assert
argument_list|(
literal|0
operator|&&
literal|"This case must be handled by git-read-tree"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|new_path1
decl_stmt|,
modifier|*
name|new_path2
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|new_path1
operator|=
name|unique_path
argument_list|(
name|path
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
name|new_path2
operator|=
name|unique_path
argument_list|(
name|path
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (add/add): File %s added non-identically "
literal|"in both branches. Adding as %s and %s instead."
argument_list|,
name|path
argument_list|,
name|new_path1
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
literal|0
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|new_path1
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
literal|0
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|o_sha
operator|&&
name|a_sha
operator|&&
name|b_sha
condition|)
block|{
comment|/* case D: Modified in both, but differently. */
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|struct
name|diff_filespec
name|o
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|output
argument_list|(
literal|"Auto-merging %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|o
operator|.
name|path
operator|=
name|a
operator|.
name|path
operator|=
name|b
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|path
expr_stmt|;
name|memcpy
argument_list|(
name|o
operator|.
name|sha1
argument_list|,
name|o_sha
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|o
operator|.
name|mode
operator|=
name|o_mode
expr_stmt|;
name|memcpy
argument_list|(
name|a
operator|.
name|sha1
argument_list|,
name|a_sha
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|a
operator|.
name|mode
operator|=
name|a_mode
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|.
name|sha1
argument_list|,
name|b_sha
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|b
operator|.
name|mode
operator|=
name|b_mode
expr_stmt|;
name|mfi
operator|=
name|merge_file
argument_list|(
operator|&
name|o
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|clean
condition|)
name|update_file
argument_list|(
literal|1
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
literal|"CONFLICT (content): Merge conflict in %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
name|update_file
argument_list|(
literal|0
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
name|update_file_flags
argument_list|(
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|,
literal|0
comment|/* update_cache */
argument_list|,
literal|1
comment|/* update_working_directory */
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|die
argument_list|(
literal|"Fatal merge failure, shouldn't happen."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_dirty
condition|)
name|flush_cache
argument_list|()
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|merge_trees
specifier|static
name|int
name|merge_trees
parameter_list|(
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|,
name|struct
name|tree
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|clean
decl_stmt|;
if|if
condition|(
name|sha_eq
argument_list|(
name|common
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|output
argument_list|(
literal|"Already uptodate!"
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|head
expr_stmt|;
return|return
literal|1
return|;
block|}
name|code
operator|=
name|git_merge_trees
argument_list|(
name|index_only
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"merging of trees %s and %s failed"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|git_write_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|result
condition|)
block|{
name|struct
name|path_list
modifier|*
name|entries
decl_stmt|,
modifier|*
name|re_head
decl_stmt|,
modifier|*
name|re_merge
decl_stmt|;
name|int
name|i
decl_stmt|;
name|path_list_clear
argument_list|(
operator|&
name|current_file_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
operator|&
name|current_directory_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|merge
argument_list|)
expr_stmt|;
name|entries
operator|=
name|get_unmerged
argument_list|()
expr_stmt|;
name|re_head
operator|=
name|get_renames
argument_list|(
name|head
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|re_merge
operator|=
name|get_renames
argument_list|(
name|merge
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|clean
operator|=
name|process_renames
argument_list|(
name|re_head
argument_list|,
name|re_merge
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|path
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|processed
condition|)
continue|continue;
if|if
condition|(
operator|!
name|process_entry
argument_list|(
name|path
argument_list|,
name|e
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
block|}
name|path_list_clear
argument_list|(
name|re_merge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
name|re_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|path_list_clear
argument_list|(
name|entries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|clean
operator|||
name|index_only
condition|)
operator|*
name|result
operator|=
name|git_write_tree
argument_list|()
expr_stmt|;
else|else
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|clean
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"merging of trees %s and %s resulted in %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
operator|(
operator|*
name|result
operator|)
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|clean
return|;
block|}
end_function
begin_comment
comment|/*  * Merge the commits h1 and h2, return the resulting virtual  * commit object and a flag indicating the cleaness of the merge.  */
end_comment
begin_function
specifier|static
DECL|function|merge
name|int
name|merge
parameter_list|(
name|struct
name|commit
modifier|*
name|h1
parameter_list|,
name|struct
name|commit
modifier|*
name|h2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|,
name|int
name|call_depth
comment|/* =0 */
parameter_list|,
name|struct
name|commit
modifier|*
name|ancestor
comment|/* =None */
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|ca
init|=
name|NULL
decl_stmt|,
modifier|*
name|iter
decl_stmt|;
name|struct
name|commit
modifier|*
name|merged_common_ancestors
decl_stmt|;
name|struct
name|tree
modifier|*
name|mrtree
decl_stmt|;
name|int
name|clean
decl_stmt|;
name|output
argument_list|(
literal|"Merging:"
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|h1
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|h2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ancestor
condition|)
name|commit_list_insert
argument_list|(
name|ancestor
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
else|else
name|ca
operator|=
name|get_merge_bases
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|"found %u common ancestor(s):"
argument_list|,
name|commit_list_count
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
name|output_commit_title
argument_list|(
name|iter
operator|->
name|item
argument_list|)
expr_stmt|;
name|merged_common_ancestors
operator|=
name|pop_commit
argument_list|(
operator|&
name|ca
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
name|output_indent
operator|=
name|call_depth
operator|+
literal|1
expr_stmt|;
comment|/* 		 * When the merge fails, the result contains files 		 * with conflict markers. The cleanness flag is 		 * ignored, it was never acutally used, as result of 		 * merge_trees has always overwritten it: the commited 		 * "conflicts" were already resolved. 		 */
name|merge
argument_list|(
name|merged_common_ancestors
argument_list|,
name|iter
operator|->
name|item
argument_list|,
literal|"Temporary merge branch 1"
argument_list|,
literal|"Temporary merge branch 2"
argument_list|,
name|call_depth
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|merged_common_ancestors
argument_list|)
expr_stmt|;
name|output_indent
operator|=
name|call_depth
expr_stmt|;
if|if
condition|(
operator|!
name|merged_common_ancestors
condition|)
name|die
argument_list|(
literal|"merge returned no commit"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call_depth
operator|==
literal|0
condition|)
block|{
name|setup_index
argument_list|(
literal|0
comment|/* $GIT_DIR/index */
argument_list|)
expr_stmt|;
name|index_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|setup_index
argument_list|(
literal|1
comment|/* temporary index */
argument_list|)
expr_stmt|;
name|git_read_tree
argument_list|(
name|h1
operator|->
name|tree
argument_list|)
expr_stmt|;
name|index_only
operator|=
literal|1
expr_stmt|;
block|}
name|clean
operator|=
name|merge_trees
argument_list|(
name|h1
operator|->
name|tree
argument_list|,
name|h2
operator|->
name|tree
argument_list|,
name|merged_common_ancestors
operator|->
name|tree
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
operator|&
name|mrtree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ancestor
operator|&&
operator|(
name|clean
operator|||
name|index_only
operator|)
condition|)
block|{
operator|*
name|result
operator|=
name|make_virtual_commit
argument_list|(
name|mrtree
argument_list|,
literal|"merged tree"
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h1
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h2
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|get_ref
specifier|static
name|struct
name|commit
modifier|*
name|get_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|object
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|ref
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not resolve ref '%s'"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|object
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|ref
argument_list|,
name|strlen
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|parse_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not parse commit '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|bases
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|unsigned
name|bases_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clean
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch1
decl_stmt|,
modifier|*
name|branch2
decl_stmt|;
name|struct
name|commit
modifier|*
name|result
decl_stmt|,
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h2
decl_stmt|;
name|original_index_file
operator|=
name|getenv
argument_list|(
literal|"GIT_INDEX_FILE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|original_index_file
condition|)
name|original_index_file
operator|=
name|strdup
argument_list|(
name|git_path
argument_list|(
literal|"index"
argument_list|)
argument_list|)
expr_stmt|;
name|temporary_index_file
operator|=
name|strdup
argument_list|(
name|git_path
argument_list|(
literal|"mrg-rcrsv-tmp-idx"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
name|die
argument_list|(
literal|"Usage: %s<base>... --<head><remote> ...\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|bases_count
operator|<
sizeof|sizeof
argument_list|(
name|bases
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|bases
argument_list|)
condition|)
name|bases
index|[
name|bases_count
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|-
name|i
operator|!=
literal|3
condition|)
comment|/* "--" "<head>" "<remote>" */
name|die
argument_list|(
literal|"Not handling anything other than two heads merge."
argument_list|)
expr_stmt|;
name|branch1
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|branch2
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"Merging %s with %s\n"
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|h1
operator|=
name|get_ref
argument_list|(
name|branch1
argument_list|)
expr_stmt|;
name|h2
operator|=
name|get_ref
argument_list|(
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bases_count
operator|==
literal|1
condition|)
block|{
name|struct
name|commit
modifier|*
name|ancestor
init|=
name|get_ref
argument_list|(
name|bases
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|clean
operator|=
name|merge
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
literal|0
argument_list|,
name|ancestor
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|clean
operator|=
name|merge
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_dirty
condition|)
name|flush_cache
argument_list|()
expr_stmt|;
return|return
name|clean
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
begin_comment
comment|/* vim: sw=8 noet */
end_comment
end_unit
