begin_unit
begin_comment
comment|/*  * Recursive Merge algorithm stolen from git-merge-recursive.py by  * Fredrik Kuivinen.  * The thieves were Alex Riesen and Johannes Schindelin, in June/July 2006  */
end_comment
begin_include
include|#
directive|include
file|"advice.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"ll-merge.h"
end_include
begin_include
include|#
directive|include
file|"attr.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"submodule.h"
end_include
begin_function
DECL|function|shift_tree_object
specifier|static
name|struct
name|tree
modifier|*
name|shift_tree_object
parameter_list|(
name|struct
name|tree
modifier|*
name|one
parameter_list|,
name|struct
name|tree
modifier|*
name|two
parameter_list|,
specifier|const
name|char
modifier|*
name|subtree_shift
parameter_list|)
block|{
name|unsigned
name|char
name|shifted
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|subtree_shift
condition|)
block|{
name|shift_tree
argument_list|(
name|one
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|two
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|shifted
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift_tree_by
argument_list|(
name|one
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|two
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|shifted
argument_list|,
name|subtree_shift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|two
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|shifted
argument_list|)
condition|)
return|return
name|two
return|;
return|return
name|lookup_tree
argument_list|(
name|shifted
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|make_virtual_commit
specifier|static
name|struct
name|commit
modifier|*
name|make_virtual_commit
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|alloc_commit_node
argument_list|()
decl_stmt|;
name|struct
name|merge_remote_desc
modifier|*
name|desc
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
decl_stmt|;
name|desc
operator|->
name|name
operator|=
name|comment
expr_stmt|;
name|desc
operator|->
name|obj
operator|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|commit
expr_stmt|;
name|commit
operator|->
name|tree
operator|=
name|tree
expr_stmt|;
name|commit
operator|->
name|util
operator|=
name|desc
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
return|return
name|commit
return|;
block|}
end_function
begin_comment
comment|/*  * Since we use get_tree_entry(), which does not put the read object into  * the object pool, we cannot rely on a == b.  */
end_comment
begin_function
DECL|function|sha_eq
specifier|static
name|int
name|sha_eq
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|&&
operator|!
name|b
condition|)
return|return
literal|2
return|;
return|return
name|a
operator|&&
name|b
operator|&&
name|hashcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_enum
DECL|enum|rename_type
enum|enum
name|rename_type
block|{
DECL|enumerator|RENAME_NORMAL
name|RENAME_NORMAL
init|=
literal|0
block|,
DECL|enumerator|RENAME_DELETE
name|RENAME_DELETE
block|,
DECL|enumerator|RENAME_ONE_FILE_TO_ONE
name|RENAME_ONE_FILE_TO_ONE
block|,
DECL|enumerator|RENAME_ONE_FILE_TO_TWO
name|RENAME_ONE_FILE_TO_TWO
block|,
DECL|enumerator|RENAME_TWO_FILES_TO_ONE
name|RENAME_TWO_FILES_TO_ONE
block|}
enum|;
end_enum
begin_struct
DECL|struct|rename_conflict_info
struct|struct
name|rename_conflict_info
block|{
DECL|member|rename_type
name|enum
name|rename_type
name|rename_type
decl_stmt|;
DECL|member|pair1
name|struct
name|diff_filepair
modifier|*
name|pair1
decl_stmt|;
DECL|member|pair2
name|struct
name|diff_filepair
modifier|*
name|pair2
decl_stmt|;
DECL|member|branch1
specifier|const
name|char
modifier|*
name|branch1
decl_stmt|;
DECL|member|branch2
specifier|const
name|char
modifier|*
name|branch2
decl_stmt|;
DECL|member|dst_entry1
name|struct
name|stage_data
modifier|*
name|dst_entry1
decl_stmt|;
DECL|member|dst_entry2
name|struct
name|stage_data
modifier|*
name|dst_entry2
decl_stmt|;
DECL|member|ren1_other
name|struct
name|diff_filespec
name|ren1_other
decl_stmt|;
DECL|member|ren2_other
name|struct
name|diff_filespec
name|ren2_other
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Since we want to write the index eventually, we cannot reuse the index  * for these (temporary) data.  */
end_comment
begin_struct
DECL|struct|stage_data
struct|struct
name|stage_data
block|{
struct|struct
block|{
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
block|}
DECL|member|stages
name|stages
index|[
literal|4
index|]
struct|;
DECL|member|rename_conflict_info
name|struct
name|rename_conflict_info
modifier|*
name|rename_conflict_info
decl_stmt|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|setup_rename_conflict_info
specifier|static
specifier|inline
name|void
name|setup_rename_conflict_info
parameter_list|(
name|enum
name|rename_type
name|rename_type
parameter_list|,
name|struct
name|diff_filepair
modifier|*
name|pair1
parameter_list|,
name|struct
name|diff_filepair
modifier|*
name|pair2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|,
name|struct
name|stage_data
modifier|*
name|dst_entry1
parameter_list|,
name|struct
name|stage_data
modifier|*
name|dst_entry2
parameter_list|,
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|stage_data
modifier|*
name|src_entry1
parameter_list|,
name|struct
name|stage_data
modifier|*
name|src_entry2
parameter_list|)
block|{
name|struct
name|rename_conflict_info
modifier|*
name|ci
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rename_conflict_info
argument_list|)
argument_list|)
decl_stmt|;
name|ci
operator|->
name|rename_type
operator|=
name|rename_type
expr_stmt|;
name|ci
operator|->
name|pair1
operator|=
name|pair1
expr_stmt|;
name|ci
operator|->
name|branch1
operator|=
name|branch1
expr_stmt|;
name|ci
operator|->
name|branch2
operator|=
name|branch2
expr_stmt|;
name|ci
operator|->
name|dst_entry1
operator|=
name|dst_entry1
expr_stmt|;
name|dst_entry1
operator|->
name|rename_conflict_info
operator|=
name|ci
expr_stmt|;
name|dst_entry1
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
operator|!
name|pair2
operator|==
operator|!
name|dst_entry2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_entry2
condition|)
block|{
name|ci
operator|->
name|dst_entry2
operator|=
name|dst_entry2
expr_stmt|;
name|ci
operator|->
name|pair2
operator|=
name|pair2
expr_stmt|;
name|dst_entry2
operator|->
name|rename_conflict_info
operator|=
name|ci
expr_stmt|;
block|}
if|if
condition|(
name|rename_type
operator|==
name|RENAME_TWO_FILES_TO_ONE
condition|)
block|{
comment|/* 		 * For each rename, there could have been 		 * modifications on the side of history where that 		 * file was not renamed. 		 */
name|int
name|ostage1
init|=
name|o
operator|->
name|branch1
operator|==
name|branch1
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|int
name|ostage2
init|=
name|ostage1
operator|^
literal|1
decl_stmt|;
name|ci
operator|->
name|ren1_other
operator|.
name|path
operator|=
name|pair1
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|hashcpy
argument_list|(
name|ci
operator|->
name|ren1_other
operator|.
name|sha1
argument_list|,
name|src_entry1
operator|->
name|stages
index|[
name|ostage1
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ren1_other
operator|.
name|mode
operator|=
name|src_entry1
operator|->
name|stages
index|[
name|ostage1
index|]
operator|.
name|mode
expr_stmt|;
name|ci
operator|->
name|ren2_other
operator|.
name|path
operator|=
name|pair2
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|hashcpy
argument_list|(
name|ci
operator|->
name|ren2_other
operator|.
name|sha1
argument_list|,
name|src_entry2
operator|->
name|stages
index|[
name|ostage2
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ren2_other
operator|.
name|mode
operator|=
name|src_entry2
operator|->
name|stages
index|[
name|ostage2
index|]
operator|.
name|mode
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|show
specifier|static
name|int
name|show
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
operator|(
operator|!
name|o
operator|->
name|call_depth
operator|&&
name|o
operator|->
name|verbosity
operator|>=
name|v
operator|)
operator|||
name|o
operator|->
name|verbosity
operator|>=
literal|5
return|;
block|}
end_function
begin_function
DECL|function|flush_output
specifier|static
name|void
name|flush_output
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|obuf
operator|.
name|len
condition|)
block|{
name|fputs
argument_list|(
name|o
operator|->
name|obuf
operator|.
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|__attribute__
argument_list|(
argument|(format (printf,
literal|3
argument|,
literal|4
argument|))
argument_list|)
end_macro
begin_function
DECL|function|output
specifier|static
name|void
name|output
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|show
argument_list|(
name|o
argument_list|,
name|v
argument_list|)
condition|)
return|return;
name|strbuf_grow
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
name|o
operator|->
name|call_depth
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|o
operator|->
name|obuf
operator|.
name|buf
operator|+
name|o
operator|->
name|obuf
operator|.
name|len
argument_list|,
literal|' '
argument_list|,
name|o
operator|->
name|call_depth
operator|*
literal|2
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
name|o
operator|->
name|obuf
operator|.
name|len
operator|+
name|o
operator|->
name|call_depth
operator|*
literal|2
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|strbuf_vaddf
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|buffer_output
condition|)
name|flush_output
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_commit_title
specifier|static
name|void
name|output_commit_title
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|flush_output
argument_list|(
name|o
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|o
operator|->
name|call_depth
init|;
name|i
operator|--
condition|;
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|util
condition|)
name|printf
argument_list|(
literal|"virtual %s\n"
argument_list|,
name|merge_remote_util
argument_list|(
name|commit
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"(bad commit)\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|title
decl_stmt|;
name|int
name|len
init|=
name|find_commit_subject
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
operator|&
name|title
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
condition|)
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
name|len
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|add_cacheinfo
specifier|static
name|int
name|add_cacheinfo
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|stage
parameter_list|,
name|int
name|refresh
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|make_cache_entry
argument_list|(
name|mode
argument_list|,
name|sha1
condition|?
name|sha1
else|:
name|null_sha1
argument_list|,
name|path
argument_list|,
name|stage
argument_list|,
operator|(
name|refresh
condition|?
operator|(
name|CE_MATCH_REFRESH
operator||
name|CE_MATCH_IGNORE_MISSING
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"addinfo_cache failed for path '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
return|return
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init_tree_desc_from_tree
specifier|static
name|void
name|init_tree_desc_from_tree
parameter_list|(
name|struct
name|tree_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
name|desc
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_merge_trees
specifier|static
name|int
name|git_merge_trees
parameter_list|(
name|int
name|index_only
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|tree_desc
name|t
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
name|opts
operator|.
name|index_only
operator|=
literal|1
expr_stmt|;
else|else
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|2
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|threeway_merge
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|setup_unpack_trees_porcelain
argument_list|(
operator|&
name|opts
argument_list|,
literal|"merge"
argument_list|)
expr_stmt|;
name|init_tree_desc_from_tree
argument_list|(
name|t
operator|+
literal|0
argument_list|,
name|common
argument_list|)
expr_stmt|;
name|init_tree_desc_from_tree
argument_list|(
name|t
operator|+
literal|1
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|init_tree_desc_from_tree
argument_list|(
name|t
operator|+
literal|2
argument_list|,
name|merge
argument_list|)
expr_stmt|;
name|rc
operator|=
name|unpack_trees
argument_list|(
literal|3
argument_list|,
name|t
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|cache_tree_free
argument_list|(
operator|&
name|active_cache_tree
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|write_tree_from_memory
name|struct
name|tree
modifier|*
name|write_tree_from_memory
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BUG: There are unmerged index entries:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BUG: %d %.*s\n"
argument_list|,
name|ce_stage
argument_list|(
name|ce
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|die
argument_list|(
literal|"Bug in merge-recursive.c"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|active_cache_tree
condition|)
name|active_cache_tree
operator|=
name|cache_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cache_tree_fully_valid
argument_list|(
name|active_cache_tree
argument_list|)
operator|&&
name|cache_tree_update
argument_list|(
name|active_cache_tree
argument_list|,
operator|(
specifier|const
expr|struct
name|cache_entry
operator|*
specifier|const
operator|*
operator|)
name|active_cache
argument_list|,
name|active_nr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"error building trees"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup_tree
argument_list|(
name|active_cache_tree
operator|->
name|sha1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|save_files_dirs
specifier|static
name|int
name|save_files_dirs
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|int
name|stage
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newpath
init|=
name|xmalloc
argument_list|(
name|baselen
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|merge_options
modifier|*
name|o
init|=
name|context
decl_stmt|;
name|memcpy
argument_list|(
name|newpath
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newpath
operator|+
name|baselen
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newpath
index|[
name|baselen
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|string_list_insert
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
else|else
name|string_list_insert
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|?
name|READ_TREE_RECURSIVE
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|get_files_dirs
specifier|static
name|int
name|get_files_dirs
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|struct
name|pathspec
name|match_all
decl_stmt|;
name|memset
argument_list|(
operator|&
name|match_all
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|match_all
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_tree_recursive
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|match_all
argument_list|,
name|save_files_dirs
argument_list|,
name|o
argument_list|)
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|o
operator|->
name|current_file_set
operator|.
name|nr
operator|+
name|o
operator|->
name|current_directory_set
operator|.
name|nr
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*  * Returns an index_entry instance which doesn't have to correspond to  * a real cache entry in Git's index.  */
end_comment
begin_function
DECL|function|insert_stage_data
specifier|static
name|struct
name|stage_data
modifier|*
name|insert_stage_data
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|tree
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|a
parameter_list|,
name|struct
name|tree
modifier|*
name|b
parameter_list|,
name|struct
name|string_list
modifier|*
name|entries
parameter_list|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
decl_stmt|;
name|get_tree_entry
argument_list|(
name|o
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|a
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|b
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|item
operator|=
name|string_list_insert
argument_list|(
name|entries
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|e
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_comment
comment|/*  * Create a dictionary mapping file names to stage_data objects. The  * dictionary contains one entry for every path with a non-zero stage entry.  */
end_comment
begin_function
DECL|function|get_unmerged
specifier|static
name|struct
name|string_list
modifier|*
name|get_unmerged
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|unmerged
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unmerged
operator|->
name|strdup_strings
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
decl_stmt|;
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
continue|continue;
name|item
operator|=
name|string_list_lookup
argument_list|(
name|unmerged
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|item
operator|=
name|string_list_insert
argument_list|(
name|unmerged
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|mode
operator|=
name|ce
operator|->
name|ce_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|sha
argument_list|,
name|ce
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
return|return
name|unmerged
return|;
block|}
end_function
begin_function
DECL|function|string_list_df_name_compare
specifier|static
name|int
name|string_list_df_name_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|string_list_item
modifier|*
name|one
init|=
name|a
decl_stmt|;
specifier|const
name|struct
name|string_list_item
modifier|*
name|two
init|=
name|b
decl_stmt|;
name|int
name|onelen
init|=
name|strlen
argument_list|(
name|one
operator|->
name|string
argument_list|)
decl_stmt|;
name|int
name|twolen
init|=
name|strlen
argument_list|(
name|two
operator|->
name|string
argument_list|)
decl_stmt|;
comment|/* 	 * Here we only care that entries for D/F conflicts are 	 * adjacent, in particular with the file of the D/F conflict 	 * appearing before files below the corresponding directory. 	 * The order of the rest of the list is irrelevant for us. 	 * 	 * To achieve this, we sort with df_name_compare and provide 	 * the mode S_IFDIR so that D/F conflicts will sort correctly. 	 * We use the mode S_IFDIR for everything else for simplicity, 	 * since in other cases any changes in their order due to 	 * sorting cause no problems for us. 	 */
name|int
name|cmp
init|=
name|df_name_compare
argument_list|(
name|one
operator|->
name|string
argument_list|,
name|onelen
argument_list|,
name|S_IFDIR
argument_list|,
name|two
operator|->
name|string
argument_list|,
name|twolen
argument_list|,
name|S_IFDIR
argument_list|)
decl_stmt|;
comment|/* 	 * Now that 'foo' and 'foo/bar' compare equal, we have to make sure 	 * that 'foo' comes before 'foo/bar'. 	 */
if|if
condition|(
name|cmp
condition|)
return|return
name|cmp
return|;
return|return
name|onelen
operator|-
name|twolen
return|;
block|}
end_function
begin_function
DECL|function|record_df_conflict_files
specifier|static
name|void
name|record_df_conflict_files
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|string_list
modifier|*
name|entries
parameter_list|)
block|{
comment|/* If there is a D/F conflict and the file for such a conflict 	 * currently exist in the working tree, we want to allow it to be 	 * removed to make room for the corresponding directory if needed. 	 * The files underneath the directories of such D/F conflicts will 	 * be processed before the corresponding file involved in the D/F 	 * conflict.  If the D/F directory ends up being removed by the 	 * merge, then we won't have to touch the D/F file.  If the D/F 	 * directory needs to be written to the working copy, then the D/F 	 * file will simply be removed (in make_room_for_path()) to make 	 * room for the necessary paths.  Note that if both the directory 	 * and the file need to be present, then the D/F file will be 	 * reinstated with a new unique name at the time it is processed. 	 */
name|struct
name|string_list
name|df_sorted_entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_file
init|=
name|NULL
decl_stmt|;
name|int
name|last_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * If we're merging merge-bases, we don't want to bother with 	 * any working directory changes. 	 */
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
return|return;
comment|/* Ensure D/F conflicts are adjacent in the entries list. */
name|memset
argument_list|(
operator|&
name|df_sorted_entries
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|next
init|=
operator|&
name|entries
operator|->
name|items
index|[
name|i
index|]
decl_stmt|;
name|string_list_append
argument_list|(
operator|&
name|df_sorted_entries
argument_list|,
name|next
operator|->
name|string
argument_list|)
operator|->
name|util
operator|=
name|next
operator|->
name|util
expr_stmt|;
block|}
name|qsort
argument_list|(
name|df_sorted_entries
operator|.
name|items
argument_list|,
name|entries
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entries
operator|->
name|items
argument_list|)
argument_list|,
name|string_list_df_name_compare
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|o
operator|->
name|df_conflict_file_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df_sorted_entries
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|df_sorted_entries
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|df_sorted_entries
operator|.
name|items
index|[
name|i
index|]
operator|.
name|util
decl_stmt|;
comment|/* 		 * Check if last_file& path correspond to a D/F conflict; 		 * i.e. whether path is last_file+'/'+<something>. 		 * If so, record that it's okay to remove last_file to make 		 * room for path and friends if needed. 		 */
if|if
condition|(
name|last_file
operator|&&
name|len
operator|>
name|last_len
operator|&&
name|memcmp
argument_list|(
name|path
argument_list|,
name|last_file
argument_list|,
name|last_len
argument_list|)
operator|==
literal|0
operator|&&
name|path
index|[
name|last_len
index|]
operator|==
literal|'/'
condition|)
block|{
name|string_list_insert
argument_list|(
operator|&
name|o
operator|->
name|df_conflict_file_set
argument_list|,
name|last_file
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Determine whether path could exist as a file in the 		 * working directory as a possible D/F conflict.  This 		 * will only occur when it exists in stage 2 as a 		 * file. 		 */
if|if
condition|(
name|S_ISREG
argument_list|(
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
operator|||
name|S_ISLNK
argument_list|(
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
condition|)
block|{
name|last_file
operator|=
name|path
expr_stmt|;
name|last_len
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|last_file
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|string_list_clear
argument_list|(
operator|&
name|df_sorted_entries
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|rename
struct|struct
name|rename
block|{
DECL|member|pair
name|struct
name|diff_filepair
modifier|*
name|pair
decl_stmt|;
DECL|member|src_entry
name|struct
name|stage_data
modifier|*
name|src_entry
decl_stmt|;
DECL|member|dst_entry
name|struct
name|stage_data
modifier|*
name|dst_entry
decl_stmt|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Get information of all renames which occurred between 'o_tree' and  * 'tree'. We need the three trees in the merge ('o_tree', 'a_tree' and  * 'b_tree') to be able to associate the correct cache entries with  * the rename information. 'tree' is always equal to either a_tree or b_tree.  */
end_comment
begin_function
DECL|function|get_renames
specifier|static
name|struct
name|string_list
modifier|*
name|get_renames
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|struct
name|tree
modifier|*
name|o_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|a_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|b_tree
parameter_list|,
name|struct
name|string_list
modifier|*
name|entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|string_list
modifier|*
name|renames
decl_stmt|;
name|struct
name|diff_options
name|opts
decl_stmt|;
name|renames
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|DIFF_OPT_CLR
argument_list|(
operator|&
name|opts
argument_list|,
name|RENAME_EMPTY
argument_list|)
expr_stmt|;
name|opts
operator|.
name|detect_rename
operator|=
name|DIFF_DETECT_RENAME
expr_stmt|;
name|opts
operator|.
name|rename_limit
operator|=
name|o
operator|->
name|merge_rename_limit
operator|>=
literal|0
condition|?
name|o
operator|->
name|merge_rename_limit
else|:
name|o
operator|->
name|diff_rename_limit
operator|>=
literal|0
condition|?
name|o
operator|->
name|diff_rename_limit
else|:
literal|1000
expr_stmt|;
name|opts
operator|.
name|rename_score
operator|=
name|o
operator|->
name|rename_score
expr_stmt|;
name|opts
operator|.
name|show_rename_progress
operator|=
name|o
operator|->
name|show_rename_progress
expr_stmt|;
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|o_tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|.
name|needed_rename_limit
operator|>
name|o
operator|->
name|needed_rename_limit
condition|)
name|o
operator|->
name|needed_rename_limit
operator|=
name|opts
operator|.
name|needed_rename_limit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|rename
modifier|*
name|re
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|pair
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pair
operator|->
name|status
operator|!=
literal|'R'
condition|)
block|{
name|diff_free_filepair
argument_list|(
name|pair
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|re
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|re
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|pair
operator|=
name|pair
expr_stmt|;
name|item
operator|=
name|string_list_lookup
argument_list|(
name|entries
argument_list|,
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|src_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|src_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|string_list_lookup
argument_list|(
name|entries
argument_list|,
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|dst_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|dst_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|string_list_insert
argument_list|(
name|renames
argument_list|,
name|pair
operator|->
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|re
expr_stmt|;
block|}
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_queued_diff
operator|.
name|nr
operator|=
literal|0
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
return|return
name|renames
return|;
block|}
end_function
begin_function
DECL|function|update_stages
specifier|static
name|int
name|update_stages
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|)
block|{
comment|/* 	 * NOTE: It is usually a bad idea to call update_stages on a path 	 * before calling update_file on that same path, since it can 	 * sometimes lead to spurious "refusing to lose untracked file..." 	 * messages from update_file (via make_room_for path via 	 * would_lose_untracked).  Instead, reverse the order of the calls 	 * (executing update_file first and then update_stages). 	 */
name|int
name|clear
init|=
literal|1
decl_stmt|;
name|int
name|options
init|=
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_SKIP_DFCHECK
decl_stmt|;
if|if
condition|(
name|clear
condition|)
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|o
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|o
operator|->
name|mode
argument_list|,
name|o
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|a
operator|->
name|mode
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|b
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|b
operator|->
name|mode
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|update_entry
specifier|static
name|void
name|update_entry
parameter_list|(
name|struct
name|stage_data
modifier|*
name|entry
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|)
block|{
name|entry
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|o
operator|->
name|mode
expr_stmt|;
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
operator|=
name|b
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
name|o
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove_file
specifier|static
name|int
name|remove_file
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|clean
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|no_wd
parameter_list|)
block|{
name|int
name|update_cache
init|=
name|o
operator|->
name|call_depth
operator|||
name|clean
decl_stmt|;
name|int
name|update_working_directory
init|=
operator|!
name|o
operator|->
name|call_depth
operator|&&
operator|!
name|no_wd
decl_stmt|;
if|if
condition|(
name|update_cache
condition|)
block|{
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|update_working_directory
condition|)
block|{
if|if
condition|(
name|remove_path
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unique_path
specifier|static
name|char
modifier|*
name|unique_path
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|branch
parameter_list|)
block|{
name|char
modifier|*
name|newpath
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|8
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|suffix
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|newpath
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'~'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|branch
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
literal|'/'
operator|==
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
while|while
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|lstat
argument_list|(
name|newpath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"_%d"
argument_list|,
name|suffix
operator|++
argument_list|)
expr_stmt|;
name|string_list_insert
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
return|return
name|newpath
return|;
block|}
end_function
begin_function
DECL|function|dir_in_way
specifier|static
name|int
name|dir_in_way
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|check_working_copy
parameter_list|)
block|{
name|int
name|pos
decl_stmt|,
name|pathlen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dirpath
init|=
name|xmalloc
argument_list|(
name|pathlen
operator|+
literal|2
argument_list|)
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|strcpy
argument_list|(
name|dirpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|dirpath
index|[
name|pathlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|dirpath
index|[
name|pathlen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|dirpath
argument_list|,
name|pathlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
literal|1
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strncmp
argument_list|(
name|dirpath
argument_list|,
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|,
name|pathlen
operator|+
literal|1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dirpath
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|free
argument_list|(
name|dirpath
argument_list|)
expr_stmt|;
return|return
name|check_working_copy
operator|&&
operator|!
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|was_tracked
specifier|static
name|int
name|was_tracked
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|pos
init|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
literal|1
operator|-
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|path
argument_list|,
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* 		 * If stage #0, it is definitely tracked. 		 * If it has stage #2 then it was tracked 		 * before this merge started.  All other 		 * cases the path was not tracked. 		 */
switch|switch
condition|(
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
return|return
literal|1
return|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|would_lose_untracked
specifier|static
name|int
name|would_lose_untracked
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|!
name|was_tracked
argument_list|(
name|path
argument_list|)
operator|&&
name|file_exists
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|make_room_for_path
specifier|static
name|int
name|make_room_for_path
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|_
argument_list|(
literal|"failed to create path '%s'%s"
argument_list|)
decl_stmt|;
comment|/* Unlink any D/F conflict files that are in the way */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|df_conflict_file_set
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|df_path
init|=
name|o
operator|->
name|df_conflict_file_set
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
name|size_t
name|pathlen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|size_t
name|df_pathlen
init|=
name|strlen
argument_list|(
name|df_path
argument_list|)
decl_stmt|;
if|if
condition|(
name|df_pathlen
operator|<
name|pathlen
operator|&&
name|path
index|[
name|df_pathlen
index|]
operator|==
literal|'/'
operator|&&
name|strncmp
argument_list|(
name|path
argument_list|,
name|df_path
argument_list|,
name|df_pathlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|3
argument_list|,
name|_
argument_list|(
literal|"Removing %s to make room for subdirectory\n"
argument_list|)
argument_list|,
name|df_path
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|df_path
argument_list|)
expr_stmt|;
name|unsorted_string_list_delete_item
argument_list|(
operator|&
name|o
operator|->
name|df_conflict_file_set
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Make sure leading directories are created */
name|status
operator|=
name|safe_create_leading_directories_const
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|SCLD_EXISTS
condition|)
block|{
comment|/* something else exists */
name|error
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
name|_
argument_list|(
literal|": perhaps a D/F conflict?"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|die
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do not unlink a file in the work tree if we are not 	 * tracking it. 	 */
if|if
condition|(
name|would_lose_untracked
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"refusing to lose untracked file at '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
comment|/* Successful unlink is good.. */
if|if
condition|(
operator|!
name|unlink
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* .. and so is no existing file */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
comment|/* .. but not some other error (who really cares what?) */
return|return
name|error
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
name|_
argument_list|(
literal|": perhaps a D/F conflict?"
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|update_file_flags
specifier|static
name|void
name|update_file_flags
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|update_cache
parameter_list|,
name|int
name|update_wd
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
name|update_wd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|update_wd
condition|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* 			 * We may later decide to recursively descend into 			 * the submodule directory and update its index 			 * and/or work tree, but we do not do that now. 			 */
name|update_wd
operator|=
literal|0
expr_stmt|;
goto|goto
name|update_index
goto|;
block|}
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot read object %s '%s'"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"blob expected for %s '%s'"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|strbuf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|convert_to_working_tree
argument_list|(
name|path
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|strbuf
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|size
operator|=
name|strbuf
operator|.
name|len
expr_stmt|;
name|buf
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|strbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|make_room_for_path
argument_list|(
name|o
argument_list|,
name|path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|update_wd
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|update_index
goto|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
operator|!
name|has_symlinks
operator|&&
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|mode
operator|&
literal|0100
condition|)
name|mode
operator|=
literal|0777
expr_stmt|;
else|else
name|mode
operator|=
literal|0666
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to open '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|lnk
init|=
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|safe_create_leading_directories_const
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|lnk
argument_list|,
name|path
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to symlink '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"do not know what to do with %06o %s '%s'"
argument_list|)
argument_list|,
name|mode
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|update_index
label|:
if|if
condition|(
name|update_cache
condition|)
name|add_cacheinfo
argument_list|(
name|mode
argument_list|,
name|sha
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|update_wd
argument_list|,
name|ADD_CACHE_OK_TO_ADD
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_file
specifier|static
name|void
name|update_file
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|clean
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|update_file_flags
argument_list|(
name|o
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|call_depth
operator|||
name|clean
argument_list|,
operator|!
name|o
operator|->
name|call_depth
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Low level file merging, update and removal */
end_comment
begin_struct
DECL|struct|merge_file_info
struct|struct
name|merge_file_info
block|{
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|clean
name|unsigned
name|clean
range|:
literal|1
decl_stmt|,
DECL|member|merge
name|merge
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|merge_3way
specifier|static
name|int
name|merge_3way
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|mmbuffer_t
modifier|*
name|result_buf
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|one
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|mmfile_t
name|orig
decl_stmt|,
name|src1
decl_stmt|,
name|src2
decl_stmt|;
name|struct
name|ll_merge_options
name|ll_opts
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|base_name
decl_stmt|,
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|int
name|merge_status
decl_stmt|;
name|ll_opts
operator|.
name|renormalize
operator|=
name|o
operator|->
name|renormalize
expr_stmt|;
name|ll_opts
operator|.
name|xdl_opts
operator|=
name|o
operator|->
name|xdl_opts
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
name|ll_opts
operator|.
name|virtual_ancestor
operator|=
literal|1
expr_stmt|;
name|ll_opts
operator|.
name|variant
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|o
operator|->
name|recursive_variant
condition|)
block|{
case|case
name|MERGE_RECURSIVE_OURS
case|:
name|ll_opts
operator|.
name|variant
operator|=
name|XDL_MERGE_FAVOR_OURS
expr_stmt|;
break|break;
case|case
name|MERGE_RECURSIVE_THEIRS
case|:
name|ll_opts
operator|.
name|variant
operator|=
name|XDL_MERGE_FAVOR_THEIRS
expr_stmt|;
break|break;
default|default:
name|ll_opts
operator|.
name|variant
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|path
argument_list|,
name|b
operator|->
name|path
argument_list|)
operator|||
operator|(
name|o
operator|->
name|ancestor
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|a
operator|->
name|path
argument_list|,
name|one
operator|->
name|path
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|base_name
operator|=
name|o
operator|->
name|ancestor
operator|==
name|NULL
condition|?
name|NULL
else|:
name|mkpathdup
argument_list|(
literal|"%s:%s"
argument_list|,
name|o
operator|->
name|ancestor
argument_list|,
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
name|name1
operator|=
name|mkpathdup
argument_list|(
literal|"%s:%s"
argument_list|,
name|branch1
argument_list|,
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
name|name2
operator|=
name|mkpathdup
argument_list|(
literal|"%s:%s"
argument_list|,
name|branch2
argument_list|,
name|b
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_name
operator|=
name|o
operator|->
name|ancestor
operator|==
name|NULL
condition|?
name|NULL
else|:
name|mkpathdup
argument_list|(
literal|"%s"
argument_list|,
name|o
operator|->
name|ancestor
argument_list|)
expr_stmt|;
name|name1
operator|=
name|mkpathdup
argument_list|(
literal|"%s"
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
name|name2
operator|=
name|mkpathdup
argument_list|(
literal|"%s"
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
block|}
name|read_mmblob
argument_list|(
operator|&
name|orig
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|src1
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|src2
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|merge_status
operator|=
name|ll_merge
argument_list|(
name|result_buf
argument_list|,
name|a
operator|->
name|path
argument_list|,
operator|&
name|orig
argument_list|,
name|base_name
argument_list|,
operator|&
name|src1
argument_list|,
name|name1
argument_list|,
operator|&
name|src2
argument_list|,
name|name2
argument_list|,
operator|&
name|ll_opts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|orig
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src1
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src2
operator|.
name|ptr
argument_list|)
expr_stmt|;
return|return
name|merge_status
return|;
block|}
end_function
begin_function
DECL|function|merge_file_1
specifier|static
name|struct
name|merge_file_info
name|merge_file_1
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|one
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|struct
name|merge_file_info
name|result
decl_stmt|;
name|result
operator|.
name|merge
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|S_IFMT
operator|&
name|a
operator|->
name|mode
operator|)
operator|!=
operator|(
name|S_IFMT
operator|&
name|b
operator|->
name|mode
operator|)
condition|)
block|{
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|mode
operator|=
name|b
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
operator|&&
operator|!
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Merge modes 		 */
if|if
condition|(
name|a
operator|->
name|mode
operator|==
name|b
operator|->
name|mode
operator|||
name|a
operator|->
name|mode
operator|==
name|one
operator|->
name|mode
condition|)
name|result
operator|.
name|mode
operator|=
name|b
operator|->
name|mode
expr_stmt|;
else|else
block|{
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|mode
operator|!=
name|one
operator|->
name|mode
condition|)
block|{
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
operator|||
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|mmbuffer_t
name|result_buf
decl_stmt|;
name|int
name|merge_status
decl_stmt|;
name|merge_status
operator|=
name|merge_3way
argument_list|(
name|o
argument_list|,
operator|&
name|result_buf
argument_list|,
name|one
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|merge_status
operator|<
literal|0
operator|)
operator|||
operator|!
name|result_buf
operator|.
name|ptr
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to execute internal merge"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_sha1_file
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|,
name|result_buf
operator|.
name|size
argument_list|,
name|blob_type
argument_list|,
name|result
operator|.
name|sha
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unable to add %s to database"
argument_list|)
argument_list|,
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|result
operator|.
name|clean
operator|=
operator|(
name|merge_status
operator|==
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|result
operator|.
name|clean
operator|=
name|merge_submodule
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|one
operator|->
name|path
argument_list|,
name|one
operator|->
name|sha1
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
operator|!
name|o
operator|->
name|call_depth
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|die
argument_list|(
name|_
argument_list|(
literal|"unsupported object type in the tree"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
specifier|static
name|struct
name|merge_file_info
DECL|function|merge_file_special_markers
name|merge_file_special_markers
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|one
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|filename1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|,
specifier|const
name|char
modifier|*
name|filename2
parameter_list|)
block|{
name|char
modifier|*
name|side1
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|side2
init|=
name|NULL
decl_stmt|;
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
if|if
condition|(
name|filename1
condition|)
block|{
name|side1
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|branch1
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename1
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|side1
argument_list|,
literal|"%s:%s"
argument_list|,
name|branch1
argument_list|,
name|filename1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filename2
condition|)
block|{
name|side2
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|branch2
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename2
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|side2
argument_list|,
literal|"%s:%s"
argument_list|,
name|branch2
argument_list|,
name|filename2
argument_list|)
expr_stmt|;
block|}
name|mfi
operator|=
name|merge_file_1
argument_list|(
name|o
argument_list|,
name|one
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|side1
condition|?
name|side1
else|:
name|branch1
argument_list|,
name|side2
condition|?
name|side2
else|:
name|branch2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|side1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|side2
argument_list|)
expr_stmt|;
return|return
name|mfi
return|;
block|}
end_function
begin_function
DECL|function|merge_file_one
specifier|static
name|struct
name|merge_file_info
name|merge_file_one
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|o_sha
parameter_list|,
name|int
name|o_mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|a_sha
parameter_list|,
name|int
name|a_mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b_sha
parameter_list|,
name|int
name|b_mode
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|struct
name|diff_filespec
name|one
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|one
operator|.
name|path
operator|=
name|a
operator|.
name|path
operator|=
name|b
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|path
expr_stmt|;
name|hashcpy
argument_list|(
name|one
operator|.
name|sha1
argument_list|,
name|o_sha
argument_list|)
expr_stmt|;
name|one
operator|.
name|mode
operator|=
name|o_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|a
operator|.
name|sha1
argument_list|,
name|a_sha
argument_list|)
expr_stmt|;
name|a
operator|.
name|mode
operator|=
name|a_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|.
name|sha1
argument_list|,
name|b_sha
argument_list|)
expr_stmt|;
name|b
operator|.
name|mode
operator|=
name|b_mode
expr_stmt|;
return|return
name|merge_file_1
argument_list|(
name|o
argument_list|,
operator|&
name|one
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|handle_change_delete
specifier|static
name|void
name|handle_change_delete
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|o_sha
parameter_list|,
name|int
name|o_mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|a_sha
parameter_list|,
name|int
name|a_mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b_sha
parameter_list|,
name|int
name|b_mode
parameter_list|,
specifier|const
name|char
modifier|*
name|change
parameter_list|,
specifier|const
name|char
modifier|*
name|change_past
parameter_list|)
block|{
name|char
modifier|*
name|renamed
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dir_in_way
argument_list|(
name|path
argument_list|,
operator|!
name|o
operator|->
name|call_depth
argument_list|)
condition|)
block|{
name|renamed
operator|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|a_sha
condition|?
name|o
operator|->
name|branch1
else|:
name|o
operator|->
name|branch2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
comment|/* 		 * We cannot arbitrarily accept either a_sha or b_sha as 		 * correct; since there is no true "middle point" between 		 * them, simply reuse the base version for virtual merge base. 		 */
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|o_sha
argument_list|,
name|o_mode
argument_list|,
name|renamed
condition|?
name|renamed
else|:
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|a_sha
condition|)
block|{
if|if
condition|(
operator|!
name|renamed
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (%s/delete): %s deleted in %s "
literal|"and %s in %s. Version %s of %s left in tree."
argument_list|)
argument_list|,
name|change
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|change_past
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (%s/delete): %s deleted in %s "
literal|"and %s in %s. Version %s of %s left in tree at %s."
argument_list|)
argument_list|,
name|change
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|change_past
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|path
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|renamed
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (%s/delete): %s deleted in %s "
literal|"and %s in %s. Version %s of %s left in tree."
argument_list|)
argument_list|,
name|change
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|change_past
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (%s/delete): %s deleted in %s "
literal|"and %s in %s. Version %s of %s left in tree at %s."
argument_list|)
argument_list|,
name|change
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|change_past
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|path
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * No need to call update_file() on path when !renamed, since 		 * that would needlessly touch path.  We could call 		 * update_file_flags() with update_cache=0 and update_wd=0, 		 * but that's a no-op. 		 */
block|}
name|free
argument_list|(
name|renamed
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_delete
specifier|static
name|void
name|conflict_rename_delete
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filepair
modifier|*
name|pair
parameter_list|,
specifier|const
name|char
modifier|*
name|rename_branch
parameter_list|,
specifier|const
name|char
modifier|*
name|other_branch
parameter_list|)
block|{
specifier|const
name|struct
name|diff_filespec
modifier|*
name|orig
init|=
name|pair
operator|->
name|one
decl_stmt|;
specifier|const
name|struct
name|diff_filespec
modifier|*
name|dest
init|=
name|pair
operator|->
name|two
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|a_sha
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|b_sha
init|=
name|NULL
decl_stmt|;
name|int
name|a_mode
init|=
literal|0
decl_stmt|;
name|int
name|b_mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rename_branch
operator|==
name|o
operator|->
name|branch1
condition|)
block|{
name|a_sha
operator|=
name|dest
operator|->
name|sha1
expr_stmt|;
name|a_mode
operator|=
name|dest
operator|->
name|mode
expr_stmt|;
block|}
else|else
block|{
name|b_sha
operator|=
name|dest
operator|->
name|sha1
expr_stmt|;
name|b_mode
operator|=
name|dest
operator|->
name|mode
expr_stmt|;
block|}
name|handle_change_delete
argument_list|(
name|o
argument_list|,
name|o
operator|->
name|call_depth
condition|?
name|orig
operator|->
name|path
else|:
name|dest
operator|->
name|path
argument_list|,
name|orig
operator|->
name|sha1
argument_list|,
name|orig
operator|->
name|mode
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|_
argument_list|(
literal|"rename"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"renamed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
name|remove_file_from_cache
argument_list|(
name|dest
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|update_stages
argument_list|(
name|dest
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|rename_branch
operator|==
name|o
operator|->
name|branch1
condition|?
name|dest
else|:
name|NULL
argument_list|,
name|rename_branch
operator|==
name|o
operator|->
name|branch1
condition|?
name|NULL
else|:
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|filespec_from_entry
specifier|static
name|struct
name|diff_filespec
modifier|*
name|filespec_from_entry
parameter_list|(
name|struct
name|diff_filespec
modifier|*
name|target
parameter_list|,
name|struct
name|stage_data
modifier|*
name|entry
parameter_list|,
name|int
name|stage
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|sha
init|=
name|entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|sha
decl_stmt|;
name|unsigned
name|mode
init|=
name|entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
operator|||
name|is_null_sha1
argument_list|(
name|sha
argument_list|)
condition|)
return|return
name|NULL
return|;
name|hashcpy
argument_list|(
name|target
operator|->
name|sha1
argument_list|,
name|sha
argument_list|)
expr_stmt|;
name|target
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
return|return
name|target
return|;
block|}
end_function
begin_function
DECL|function|handle_file
specifier|static
name|void
name|handle_file
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|rename
parameter_list|,
name|int
name|stage
parameter_list|,
name|struct
name|rename_conflict_info
modifier|*
name|ci
parameter_list|)
block|{
name|char
modifier|*
name|dst_name
init|=
name|rename
operator|->
name|path
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|dst_entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|cur_branch
decl_stmt|,
modifier|*
name|other_branch
decl_stmt|;
name|struct
name|diff_filespec
name|other
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|add
decl_stmt|;
if|if
condition|(
name|stage
operator|==
literal|2
condition|)
block|{
name|dst_entry
operator|=
name|ci
operator|->
name|dst_entry1
expr_stmt|;
name|cur_branch
operator|=
name|ci
operator|->
name|branch1
expr_stmt|;
name|other_branch
operator|=
name|ci
operator|->
name|branch2
expr_stmt|;
block|}
else|else
block|{
name|dst_entry
operator|=
name|ci
operator|->
name|dst_entry2
expr_stmt|;
name|cur_branch
operator|=
name|ci
operator|->
name|branch2
expr_stmt|;
name|other_branch
operator|=
name|ci
operator|->
name|branch1
expr_stmt|;
block|}
name|add
operator|=
name|filespec_from_entry
argument_list|(
operator|&
name|other
argument_list|,
name|dst_entry
argument_list|,
name|stage
operator|^
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|char
modifier|*
name|add_name
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|rename
operator|->
name|path
argument_list|,
name|other_branch
argument_list|)
decl_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|add
operator|->
name|sha1
argument_list|,
name|add
operator|->
name|mode
argument_list|,
name|add_name
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|rename
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst_name
operator|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|rename
operator|->
name|path
argument_list|,
name|cur_branch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dir_in_way
argument_list|(
name|rename
operator|->
name|path
argument_list|,
operator|!
name|o
operator|->
name|call_depth
argument_list|)
condition|)
block|{
name|dst_name
operator|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|rename
operator|->
name|path
argument_list|,
name|cur_branch
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"%s is a directory in %s adding as %s instead"
argument_list|)
argument_list|,
name|rename
operator|->
name|path
argument_list|,
name|other_branch
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
block|}
block|}
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|rename
operator|->
name|sha1
argument_list|,
name|rename
operator|->
name|mode
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stage
operator|==
literal|2
condition|)
name|update_stages
argument_list|(
name|rename
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|rename
argument_list|,
name|add
argument_list|)
expr_stmt|;
else|else
name|update_stages
argument_list|(
name|rename
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|add
argument_list|,
name|rename
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_name
operator|!=
name|rename
operator|->
name|path
condition|)
name|free
argument_list|(
name|dst_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_rename_1to2
specifier|static
name|void
name|conflict_rename_rename_1to2
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|rename_conflict_info
modifier|*
name|ci
parameter_list|)
block|{
comment|/* One file was renamed in both branches, but to different names. */
name|struct
name|diff_filespec
modifier|*
name|one
init|=
name|ci
operator|->
name|pair1
operator|->
name|one
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|a
init|=
name|ci
operator|->
name|pair1
operator|->
name|two
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|b
init|=
name|ci
operator|->
name|pair2
operator|->
name|two
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (rename/rename): "
literal|"Rename \"%s\"->\"%s\" in branch \"%s\" "
literal|"rename \"%s\"->\"%s\" in \"%s\"%s"
argument_list|)
argument_list|,
name|one
operator|->
name|path
argument_list|,
name|a
operator|->
name|path
argument_list|,
name|ci
operator|->
name|branch1
argument_list|,
name|one
operator|->
name|path
argument_list|,
name|b
operator|->
name|path
argument_list|,
name|ci
operator|->
name|branch2
argument_list|,
name|o
operator|->
name|call_depth
condition|?
name|_
argument_list|(
literal|" (left unresolved)"
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|struct
name|diff_filespec
name|other
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|add
decl_stmt|;
name|mfi
operator|=
name|merge_file_one
argument_list|(
name|o
argument_list|,
name|one
operator|->
name|path
argument_list|,
name|one
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|mode
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
name|a
operator|->
name|mode
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|mode
argument_list|,
name|ci
operator|->
name|branch1
argument_list|,
name|ci
operator|->
name|branch2
argument_list|)
expr_stmt|;
comment|/* 		 * FIXME: For rename/add-source conflicts (if we could detect 		 * such), this is wrong.  We should instead find a unique 		 * pathname and then either rename the add-source file to that 		 * unique path, or use that unique path instead of src here. 		 */
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 		 * Above, we put the merged content at the merge-base's 		 * path.  Now we usually need to delete both a->path and 		 * b->path.  However, the rename on each side of the merge 		 * could also be involved in a rename/add conflict.  In 		 * such cases, we should keep the added file around, 		 * resolving the conflict at that path in its favor. 		 */
name|add
operator|=
name|filespec_from_entry
argument_list|(
operator|&
name|other
argument_list|,
name|ci
operator|->
name|dst_entry1
argument_list|,
literal|2
operator|^
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|add
operator|->
name|sha1
argument_list|,
name|add
operator|->
name|mode
argument_list|,
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|remove_file_from_cache
argument_list|(
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
name|add
operator|=
name|filespec_from_entry
argument_list|(
operator|&
name|other
argument_list|,
name|ci
operator|->
name|dst_entry2
argument_list|,
literal|3
operator|^
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|add
operator|->
name|sha1
argument_list|,
name|add
operator|->
name|mode
argument_list|,
name|b
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|remove_file_from_cache
argument_list|(
name|b
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handle_file
argument_list|(
name|o
argument_list|,
name|a
argument_list|,
literal|2
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|handle_file
argument_list|(
name|o
argument_list|,
name|b
argument_list|,
literal|3
argument_list|,
name|ci
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|conflict_rename_rename_2to1
specifier|static
name|void
name|conflict_rename_rename_2to1
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|rename_conflict_info
modifier|*
name|ci
parameter_list|)
block|{
comment|/* Two files, a& b, were renamed to the same thing, c. */
name|struct
name|diff_filespec
modifier|*
name|a
init|=
name|ci
operator|->
name|pair1
operator|->
name|one
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|b
init|=
name|ci
operator|->
name|pair2
operator|->
name|one
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|c1
init|=
name|ci
operator|->
name|pair1
operator|->
name|two
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|c2
init|=
name|ci
operator|->
name|pair2
operator|->
name|two
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|c1
operator|->
name|path
decl_stmt|;
comment|/* == c2->path */
name|struct
name|merge_file_info
name|mfi_c1
decl_stmt|;
name|struct
name|merge_file_info
name|mfi_c2
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (rename/rename): "
literal|"Rename %s->%s in %s. "
literal|"Rename %s->%s in %s"
argument_list|)
argument_list|,
name|a
operator|->
name|path
argument_list|,
name|c1
operator|->
name|path
argument_list|,
name|ci
operator|->
name|branch1
argument_list|,
name|b
operator|->
name|path
argument_list|,
name|c2
operator|->
name|path
argument_list|,
name|ci
operator|->
name|branch2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|a
operator|->
name|path
argument_list|,
name|would_lose_untracked
argument_list|(
name|a
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|b
operator|->
name|path
argument_list|,
name|would_lose_untracked
argument_list|(
name|b
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|mfi_c1
operator|=
name|merge_file_special_markers
argument_list|(
name|o
argument_list|,
name|a
argument_list|,
name|c1
argument_list|,
operator|&
name|ci
operator|->
name|ren1_other
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|c1
operator|->
name|path
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|ci
operator|->
name|ren1_other
operator|.
name|path
argument_list|)
expr_stmt|;
name|mfi_c2
operator|=
name|merge_file_special_markers
argument_list|(
name|o
argument_list|,
name|b
argument_list|,
operator|&
name|ci
operator|->
name|ren2_other
argument_list|,
name|c2
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|ci
operator|->
name|ren2_other
operator|.
name|path
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|c2
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
comment|/* 		 * If mfi_c1.clean&& mfi_c2.clean, then it might make 		 * sense to do a two-way merge of those results.  But, I 		 * think in all cases, it makes sense to have the virtual 		 * merge base just undo the renames; they can be detected 		 * again later for the non-recursive merge. 		 */
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|mfi_c1
operator|.
name|sha
argument_list|,
name|mfi_c1
operator|.
name|mode
argument_list|,
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|mfi_c2
operator|.
name|sha
argument_list|,
name|mfi_c2
operator|.
name|mode
argument_list|,
name|b
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|new_path1
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|ci
operator|->
name|branch1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_path2
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|ci
operator|->
name|branch2
argument_list|)
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"Renaming %s to %s and %s to %s instead"
argument_list|)
argument_list|,
name|a
operator|->
name|path
argument_list|,
name|new_path1
argument_list|,
name|b
operator|->
name|path
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|mfi_c1
operator|.
name|sha
argument_list|,
name|mfi_c1
operator|.
name|mode
argument_list|,
name|new_path1
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|mfi_c2
operator|.
name|sha
argument_list|,
name|mfi_c2
operator|.
name|mode
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|process_renames
specifier|static
name|int
name|process_renames
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|string_list
modifier|*
name|a_renames
parameter_list|,
name|struct
name|string_list
modifier|*
name|b_renames
parameter_list|)
block|{
name|int
name|clean_merge
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|string_list
name|a_by_dst
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|struct
name|string_list
name|b_by_dst
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
specifier|const
name|struct
name|rename
modifier|*
name|sre
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|string_list_insert
argument_list|(
operator|&
name|a_by_dst
argument_list|,
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
operator|->
name|util
operator|=
operator|(
name|void
operator|*
operator|)
name|sre
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|b_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|string_list_insert
argument_list|(
operator|&
name|b_by_dst
argument_list|,
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
operator|->
name|util
operator|=
operator|(
name|void
operator|*
operator|)
name|sre
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
operator|||
name|j
operator|<
name|b_renames
operator|->
name|nr
condition|;
control|)
block|{
name|struct
name|string_list
modifier|*
name|renames1
decl_stmt|,
modifier|*
name|renames2Dst
decl_stmt|;
name|struct
name|rename
modifier|*
name|ren1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ren2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch1
decl_stmt|,
modifier|*
name|branch2
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren1_src
decl_stmt|,
modifier|*
name|ren1_dst
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|lookup
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|a_renames
operator|->
name|nr
condition|)
block|{
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>=
name|b_renames
operator|->
name|nr
condition|)
block|{
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
else|else
block|{
name|int
name|compare
init|=
name|strcmp
argument_list|(
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|b_renames
operator|->
name|items
index|[
name|j
index|]
operator|.
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|<=
literal|0
condition|)
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
if|if
condition|(
name|compare
operator|>=
literal|0
condition|)
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
comment|/* TODO: refactor, so that 1/2 are not needed */
if|if
condition|(
name|ren1
condition|)
block|{
name|renames1
operator|=
name|a_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|b_by_dst
expr_stmt|;
name|branch1
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|branch2
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
block|}
else|else
block|{
name|struct
name|rename
modifier|*
name|tmp
decl_stmt|;
name|renames1
operator|=
name|b_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|a_by_dst
expr_stmt|;
name|branch1
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|branch2
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|tmp
operator|=
name|ren2
expr_stmt|;
name|ren2
operator|=
name|ren1
expr_stmt|;
name|ren1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|ren1
operator|->
name|processed
condition|)
continue|continue;
name|ren1
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
comment|/* BUG: We should only mark src_entry as processed if we 		 * are not dealing with a rename + add-source case. 		 */
name|ren1
operator|->
name|src_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1_src
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|ren1_dst
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|ren2
condition|)
block|{
comment|/* One file renamed on both sides */
specifier|const
name|char
modifier|*
name|ren2_src
init|=
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren2_dst
init|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
name|enum
name|rename_type
name|rename_type
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_src
argument_list|,
name|ren2_src
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"ren1_src != ren2_src"
argument_list|)
expr_stmt|;
name|ren2
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_dst
argument_list|,
name|ren2_dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rename_type
operator|=
name|RENAME_ONE_FILE_TO_TWO
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rename_type
operator|=
name|RENAME_ONE_FILE_TO_ONE
expr_stmt|;
comment|/* BUG: We should only remove ren1_src in 				 * the base stage (think of rename + 				 * add-source cases). 				 */
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|ren1_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_entry
argument_list|(
name|ren1
operator|->
name|dst_entry
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|)
expr_stmt|;
block|}
name|setup_rename_conflict_info
argument_list|(
name|rename_type
argument_list|,
name|ren1
operator|->
name|pair
argument_list|,
name|ren2
operator|->
name|pair
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
name|ren1
operator|->
name|dst_entry
argument_list|,
name|ren2
operator|->
name|dst_entry
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lookup
operator|=
name|string_list_lookup
argument_list|(
name|renames2Dst
argument_list|,
name|ren1_dst
argument_list|)
operator|)
condition|)
block|{
comment|/* Two different files renamed to the same thing */
name|char
modifier|*
name|ren2_dst
decl_stmt|;
name|ren2
operator|=
name|lookup
operator|->
name|util
expr_stmt|;
name|ren2_dst
operator|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_dst
argument_list|,
name|ren2_dst
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"ren1_dst != ren2_dst"
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
comment|/* 			 * BUG: We should only mark src_entry as processed 			 * if we are not dealing with a rename + add-source 			 * case. 			 */
name|ren2
operator|->
name|src_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|setup_rename_conflict_info
argument_list|(
name|RENAME_TWO_FILES_TO_ONE
argument_list|,
name|ren1
operator|->
name|pair
argument_list|,
name|ren2
operator|->
name|pair
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
name|ren1
operator|->
name|dst_entry
argument_list|,
name|ren2
operator|->
name|dst_entry
argument_list|,
name|o
argument_list|,
name|ren1
operator|->
name|src_entry
argument_list|,
name|ren2
operator|->
name|src_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Renamed in 1, maybe changed in 2 */
comment|/* we only use sha1 and mode of these */
name|struct
name|diff_filespec
name|src_other
decl_stmt|,
name|dst_other
decl_stmt|;
name|int
name|try_merge
decl_stmt|;
comment|/* 			 * unpack_trees loads entries from common-commit 			 * into stage 1, from head-commit into stage 2, and 			 * from merge-commit into stage 3.  We keep track 			 * of which side corresponds to the rename. 			 */
name|int
name|renamed_stage
init|=
name|a_renames
operator|==
name|renames1
condition|?
literal|2
else|:
literal|3
decl_stmt|;
name|int
name|other_stage
init|=
name|a_renames
operator|==
name|renames1
condition|?
literal|3
else|:
literal|2
decl_stmt|;
comment|/* BUG: We should only remove ren1_src in the base 			 * stage and in other_stage (think of rename + 			 * add-source case). 			 */
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|ren1_src
argument_list|,
name|renamed_stage
operator|==
literal|2
operator|||
operator|!
name|was_tracked
argument_list|(
name|ren1_src
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|other_stage
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|src_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|other_stage
index|]
operator|.
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|other_stage
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|dst_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|other_stage
index|]
operator|.
name|mode
expr_stmt|;
name|try_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sha_eq
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
name|setup_rename_conflict_info
argument_list|(
name|RENAME_DELETE
argument_list|,
name|ren1
operator|->
name|pair
argument_list|,
name|NULL
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|,
name|ren1
operator|->
name|dst_entry
argument_list|,
name|NULL
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dst_other
operator|.
name|mode
operator|==
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
operator|)
operator|&&
name|sha_eq
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* 				 * Added file on the other side identical to 				 * the file being renamed: clean merge. 				 * Also, there is no need to overwrite the 				 * file already in the working copy, so call 				 * update_file_flags() instead of 				 * update_file(). 				 */
name|update_file_flags
argument_list|(
name|o
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|ren1_dst
argument_list|,
literal|1
argument_list|,
comment|/* update_cache */
literal|0
comment|/* update_wd    */
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|try_merge
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (rename/add): Rename %s->%s in %s. "
literal|"%s added in %s"
argument_list|)
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|mfi
operator|=
name|merge_file_one
argument_list|(
name|o
argument_list|,
name|ren1_dst
argument_list|,
name|null_sha1
argument_list|,
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|dst_other
operator|.
name|sha1
argument_list|,
name|dst_other
operator|.
name|mode
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"Adding merged %s"
argument_list|)
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|try_merge
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"Adding as %s instead"
argument_list|)
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|dst_other
operator|.
name|sha1
argument_list|,
name|dst_other
operator|.
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|try_merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|try_merge
condition|)
block|{
name|struct
name|diff_filespec
modifier|*
name|one
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|src_other
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ren1_src
expr_stmt|;
name|one
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
expr_stmt|;
if|if
condition|(
name|a_renames
operator|==
name|renames1
condition|)
block|{
name|a
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|b
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|a
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
name|update_entry
argument_list|(
name|ren1
operator|->
name|dst_entry
argument_list|,
name|one
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|setup_rename_conflict_info
argument_list|(
name|RENAME_NORMAL
argument_list|,
name|ren1
operator|->
name|pair
argument_list|,
name|NULL
argument_list|,
name|branch1
argument_list|,
name|NULL
argument_list|,
name|ren1
operator|->
name|dst_entry
argument_list|,
name|NULL
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|string_list_clear
argument_list|(
operator|&
name|a_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|b_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|stage_sha
specifier|static
name|unsigned
name|char
modifier|*
name|stage_sha
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|)
block|{
return|return
operator|(
name|is_null_sha1
argument_list|(
name|sha
argument_list|)
operator|||
name|mode
operator|==
literal|0
operator|)
condition|?
name|NULL
else|:
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sha
return|;
block|}
end_function
begin_function
DECL|function|read_sha1_strbuf
specifier|static
name|int
name|read_sha1_strbuf
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|strbuf
modifier|*
name|dst
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot read object %s"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"object %s is not a blob"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
block|}
name|strbuf_attach
argument_list|(
name|dst
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|blob_unchanged
specifier|static
name|int
name|blob_unchanged
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|o_sha
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|a_sha
parameter_list|,
name|int
name|renormalize
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|strbuf
name|o
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|a
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* assume changed for safety */
if|if
condition|(
name|sha_eq
argument_list|(
name|o_sha
argument_list|,
name|a_sha
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|renormalize
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|o_sha
operator|&&
name|a_sha
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_sha1_strbuf
argument_list|(
name|o_sha
argument_list|,
operator|&
name|o
argument_list|)
operator|||
name|read_sha1_strbuf
argument_list|(
name|a_sha
argument_list|,
operator|&
name|a
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* 	 * Note: binary | is used so that both renormalizations are 	 * performed.  Comparison can be skipped if both files are 	 * unchanged since their sha1s have already been compared. 	 */
if|if
condition|(
name|renormalize_buffer
argument_list|(
name|path
argument_list|,
name|o
operator|.
name|buf
argument_list|,
name|o
operator|.
name|len
argument_list|,
operator|&
name|o
argument_list|)
operator||
name|renormalize_buffer
argument_list|(
name|path
argument_list|,
name|a
operator|.
name|buf
argument_list|,
name|o
operator|.
name|len
argument_list|,
operator|&
name|a
argument_list|)
condition|)
name|ret
operator|=
operator|(
name|o
operator|.
name|len
operator|==
name|a
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|o
operator|.
name|buf
argument_list|,
name|a
operator|.
name|buf
argument_list|,
name|o
operator|.
name|len
argument_list|)
operator|)
expr_stmt|;
name|error_return
label|:
name|strbuf_release
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|handle_modify_delete
specifier|static
name|void
name|handle_modify_delete
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|char
modifier|*
name|o_sha
parameter_list|,
name|int
name|o_mode
parameter_list|,
name|unsigned
name|char
modifier|*
name|a_sha
parameter_list|,
name|int
name|a_mode
parameter_list|,
name|unsigned
name|char
modifier|*
name|b_sha
parameter_list|,
name|int
name|b_mode
parameter_list|)
block|{
name|handle_change_delete
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|o_sha
argument_list|,
name|o_mode
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|_
argument_list|(
literal|"modify"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"modified"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_content
specifier|static
name|int
name|merge_content
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|char
modifier|*
name|o_sha
parameter_list|,
name|int
name|o_mode
parameter_list|,
name|unsigned
name|char
modifier|*
name|a_sha
parameter_list|,
name|int
name|a_mode
parameter_list|,
name|unsigned
name|char
modifier|*
name|b_sha
parameter_list|,
name|int
name|b_mode
parameter_list|,
name|struct
name|rename_conflict_info
modifier|*
name|rename_conflict_info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|reason
init|=
name|_
argument_list|(
literal|"content"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path1
init|=
name|NULL
decl_stmt|,
modifier|*
name|path2
init|=
name|NULL
decl_stmt|;
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|struct
name|diff_filespec
name|one
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|unsigned
name|df_conflict_remains
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|o_sha
condition|)
block|{
name|reason
operator|=
name|_
argument_list|(
literal|"add/add"
argument_list|)
expr_stmt|;
name|o_sha
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|null_sha1
expr_stmt|;
block|}
name|one
operator|.
name|path
operator|=
name|a
operator|.
name|path
operator|=
name|b
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|path
expr_stmt|;
name|hashcpy
argument_list|(
name|one
operator|.
name|sha1
argument_list|,
name|o_sha
argument_list|)
expr_stmt|;
name|one
operator|.
name|mode
operator|=
name|o_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|a
operator|.
name|sha1
argument_list|,
name|a_sha
argument_list|)
expr_stmt|;
name|a
operator|.
name|mode
operator|=
name|a_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|.
name|sha1
argument_list|,
name|b_sha
argument_list|)
expr_stmt|;
name|b
operator|.
name|mode
operator|=
name|b_mode
expr_stmt|;
if|if
condition|(
name|rename_conflict_info
condition|)
block|{
name|struct
name|diff_filepair
modifier|*
name|pair1
init|=
name|rename_conflict_info
operator|->
name|pair1
decl_stmt|;
name|path1
operator|=
operator|(
name|o
operator|->
name|branch1
operator|==
name|rename_conflict_info
operator|->
name|branch1
operator|)
condition|?
name|pair1
operator|->
name|two
operator|->
name|path
else|:
name|pair1
operator|->
name|one
operator|->
name|path
expr_stmt|;
comment|/* If rename_conflict_info->pair2 != NULL, we are in 		 * RENAME_ONE_FILE_TO_ONE case.  Otherwise, we have a 		 * normal rename. 		 */
name|path2
operator|=
operator|(
name|rename_conflict_info
operator|->
name|pair2
operator|||
name|o
operator|->
name|branch2
operator|==
name|rename_conflict_info
operator|->
name|branch1
operator|)
condition|?
name|pair1
operator|->
name|two
operator|->
name|path
else|:
name|pair1
operator|->
name|one
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|dir_in_way
argument_list|(
name|path
argument_list|,
operator|!
name|o
operator|->
name|call_depth
argument_list|)
condition|)
name|df_conflict_remains
operator|=
literal|1
expr_stmt|;
block|}
name|mfi
operator|=
name|merge_file_special_markers
argument_list|(
name|o
argument_list|,
operator|&
name|one
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|path1
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|clean
operator|&&
operator|!
name|df_conflict_remains
operator|&&
name|sha_eq
argument_list|(
name|mfi
operator|.
name|sha
argument_list|,
name|a_sha
argument_list|)
operator|&&
name|mfi
operator|.
name|mode
operator|==
name|a_mode
condition|)
block|{
name|int
name|path_renamed_outside_HEAD
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|3
argument_list|,
name|_
argument_list|(
literal|"Skipped %s (merged same as existing)"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 		 * The content merge resulted in the same file contents we 		 * already had.  We can return early if those file contents 		 * are recorded at the correct path (which may not be true 		 * if the merge involves a rename). 		 */
name|path_renamed_outside_HEAD
operator|=
operator|!
name|path2
operator|||
operator|!
name|strcmp
argument_list|(
name|path
argument_list|,
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_renamed_outside_HEAD
condition|)
block|{
name|add_cacheinfo
argument_list|(
name|mfi
operator|.
name|mode
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
operator|(
operator|!
name|o
operator|->
name|call_depth
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|mfi
operator|.
name|clean
return|;
block|}
block|}
else|else
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"Auto-merging %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mfi
operator|.
name|mode
argument_list|)
condition|)
name|reason
operator|=
name|_
argument_list|(
literal|"submodule"
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (%s): Merge conflict in %s"
argument_list|)
argument_list|,
name|reason
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename_conflict_info
operator|&&
operator|!
name|df_conflict_remains
condition|)
name|update_stages
argument_list|(
name|path
argument_list|,
operator|&
name|one
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|df_conflict_remains
condition|)
block|{
name|char
modifier|*
name|new_path
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
name|update_stages
argument_list|(
name|path
argument_list|,
operator|&
name|one
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|file_from_stage2
init|=
name|was_tracked
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|struct
name|diff_filespec
name|merged
decl_stmt|;
name|hashcpy
argument_list|(
name|merged
operator|.
name|sha1
argument_list|,
name|mfi
operator|.
name|sha
argument_list|)
expr_stmt|;
name|merged
operator|.
name|mode
operator|=
name|mfi
operator|.
name|mode
expr_stmt|;
name|update_stages
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
name|file_from_stage2
condition|?
operator|&
name|merged
else|:
name|NULL
argument_list|,
name|file_from_stage2
condition|?
name|NULL
else|:
operator|&
name|merged
argument_list|)
expr_stmt|;
block|}
block|}
name|new_path
operator|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|rename_conflict_info
operator|->
name|branch1
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"Adding as %s instead"
argument_list|)
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
name|mfi
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|update_file
argument_list|(
name|o
argument_list|,
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
return|return
name|mfi
operator|.
name|clean
return|;
block|}
end_function
begin_comment
comment|/* Per entry merge function */
end_comment
begin_function
DECL|function|process_entry
specifier|static
name|int
name|process_entry
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stage_data
modifier|*
name|entry
parameter_list|)
block|{
comment|/* 	printf("processing entry, clean cache: %s\n", index_only ? "yes": "no"); 	print_index_entry("\tpath: ", entry); 	*/
name|int
name|clean_merge
init|=
literal|1
decl_stmt|;
name|int
name|normalize
init|=
name|o
operator|->
name|renormalize
decl_stmt|;
name|unsigned
name|o_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|a_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|b_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|o_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
name|o_mode
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|a_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
name|a_mode
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
name|b_mode
argument_list|)
decl_stmt|;
name|entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|rename_conflict_info
condition|)
block|{
name|struct
name|rename_conflict_info
modifier|*
name|conflict_info
init|=
name|entry
operator|->
name|rename_conflict_info
decl_stmt|;
switch|switch
condition|(
name|conflict_info
operator|->
name|rename_type
condition|)
block|{
case|case
name|RENAME_NORMAL
case|:
case|case
name|RENAME_ONE_FILE_TO_ONE
case|:
name|clean_merge
operator|=
name|merge_content
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|o_sha
argument_list|,
name|o_mode
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|conflict_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|RENAME_DELETE
case|:
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|conflict_rename_delete
argument_list|(
name|o
argument_list|,
name|conflict_info
operator|->
name|pair1
argument_list|,
name|conflict_info
operator|->
name|branch1
argument_list|,
name|conflict_info
operator|->
name|branch2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RENAME_ONE_FILE_TO_TWO
case|:
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|conflict_rename_rename_1to2
argument_list|(
name|o
argument_list|,
name|conflict_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|RENAME_TWO_FILES_TO_ONE
case|:
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|conflict_rename_rename_2to1
argument_list|(
name|o
argument_list|,
name|conflict_info
argument_list|)
expr_stmt|;
break|break;
default|default:
name|entry
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|o_sha
operator|&&
operator|(
operator|!
name|a_sha
operator|||
operator|!
name|b_sha
operator|)
condition|)
block|{
comment|/* Case A: Deleted in one */
if|if
condition|(
operator|(
operator|!
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|b_sha
operator|&&
name|blob_unchanged
argument_list|(
name|o_sha
argument_list|,
name|a_sha
argument_list|,
name|normalize
argument_list|,
name|path
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|a_sha
operator|&&
name|blob_unchanged
argument_list|(
name|o_sha
argument_list|,
name|b_sha
argument_list|,
name|normalize
argument_list|,
name|path
argument_list|)
operator|)
condition|)
block|{
comment|/* Deleted in both or deleted in one and 			 * unchanged in the other */
if|if
condition|(
name|a_sha
condition|)
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"Removing %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* do not touch working file if it did not exist */
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|path
argument_list|,
operator|!
name|a_sha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Modify/delete; deleted side may have put a directory in the way */
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|handle_modify_delete
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|o_sha
argument_list|,
name|o_mode
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|o_sha
operator|&&
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|o_sha
operator|&&
operator|!
name|a_sha
operator|&&
name|b_sha
operator|)
condition|)
block|{
comment|/* Case B: Added in one. */
comment|/* [nothing|directory] -> ([nothing|directory], file) */
specifier|const
name|char
modifier|*
name|add_branch
decl_stmt|;
specifier|const
name|char
modifier|*
name|other_branch
decl_stmt|;
name|unsigned
name|mode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha
decl_stmt|;
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
if|if
condition|(
name|a_sha
condition|)
block|{
name|add_branch
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|other_branch
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|mode
operator|=
name|a_mode
expr_stmt|;
name|sha
operator|=
name|a_sha
expr_stmt|;
name|conf
operator|=
name|_
argument_list|(
literal|"file/directory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_branch
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|other_branch
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|mode
operator|=
name|b_mode
expr_stmt|;
name|sha
operator|=
name|b_sha
expr_stmt|;
name|conf
operator|=
name|_
argument_list|(
literal|"directory/file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir_in_way
argument_list|(
name|path
argument_list|,
operator|!
name|o
operator|->
name|call_depth
argument_list|)
condition|)
block|{
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|add_branch
argument_list|)
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"CONFLICT (%s): There is a directory with name %s in %s. "
literal|"Adding %s as %s"
argument_list|)
argument_list|,
name|conf
argument_list|,
name|path
argument_list|,
name|other_branch
argument_list|,
name|path
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
name|_
argument_list|(
literal|"Adding %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* do not overwrite file if already present */
name|update_file_flags
argument_list|(
name|o
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|,
literal|1
argument_list|,
operator|!
name|a_sha
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|a_sha
operator|&&
name|b_sha
condition|)
block|{
comment|/* Case C: Added in both (check for same permissions) and */
comment|/* case D: Modified in both, but differently. */
name|clean_merge
operator|=
name|merge_content
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|o_sha
argument_list|,
name|o_mode
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|o_sha
operator|&&
operator|!
name|a_sha
operator|&&
operator|!
name|b_sha
condition|)
block|{
comment|/* 		 * this entry was deleted altogether. a_mode == 0 means 		 * we had that path and want to actively remove it. 		 */
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|path
argument_list|,
operator|!
name|a_mode
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"Fatal merge failure, shouldn't happen."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|merge_trees
name|int
name|merge_trees
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
name|struct
name|tree
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|clean
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|subtree_shift
condition|)
block|{
name|merge
operator|=
name|shift_tree_object
argument_list|(
name|head
argument_list|,
name|merge
argument_list|,
name|o
operator|->
name|subtree_shift
argument_list|)
expr_stmt|;
name|common
operator|=
name|shift_tree_object
argument_list|(
name|head
argument_list|,
name|common
argument_list|,
name|o
operator|->
name|subtree_shift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sha_eq
argument_list|(
name|common
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Already up-to-date!"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|head
expr_stmt|;
return|return
literal|1
return|;
block|}
name|code
operator|=
name|git_merge_trees
argument_list|(
name|o
operator|->
name|call_depth
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|show
argument_list|(
name|o
argument_list|,
literal|4
argument_list|)
operator|||
name|o
operator|->
name|call_depth
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"merging of trees %s and %s failed"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|struct
name|string_list
modifier|*
name|entries
decl_stmt|,
modifier|*
name|re_head
decl_stmt|,
modifier|*
name|re_merge
decl_stmt|;
name|int
name|i
decl_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|o
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|o
argument_list|,
name|merge
argument_list|)
expr_stmt|;
name|entries
operator|=
name|get_unmerged
argument_list|()
expr_stmt|;
name|record_df_conflict_files
argument_list|(
name|o
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|re_head
operator|=
name|get_renames
argument_list|(
name|o
argument_list|,
name|head
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|re_merge
operator|=
name|get_renames
argument_list|(
name|o
argument_list|,
name|merge
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|clean
operator|=
name|process_renames
argument_list|(
name|o
argument_list|,
name|re_head
argument_list|,
name|re_merge
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|entries
operator|->
name|nr
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|processed
operator|&&
operator|!
name|process_entry
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|stage_data
modifier|*
name|e
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|processed
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unprocessed path??? %s"
argument_list|)
argument_list|,
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
name|re_merge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
name|re_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
name|entries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
operator|*
name|result
operator|=
name|write_tree_from_memory
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|reverse_commit_list
specifier|static
name|struct
name|commit_list
modifier|*
name|reverse_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
name|NULL
decl_stmt|,
modifier|*
name|current
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
for|for
control|(
name|current
operator|=
name|list
init|;
name|current
condition|;
name|current
operator|=
name|backup
control|)
block|{
name|backup
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|current
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|current
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function
begin_comment
comment|/*  * Merge the commits h1 and h2, return the resulting virtual  * commit object and a flag indicating the cleanness of the merge.  */
end_comment
begin_function
DECL|function|merge_recursive
name|int
name|merge_recursive
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|commit
modifier|*
name|h1
parameter_list|,
name|struct
name|commit
modifier|*
name|h2
parameter_list|,
name|struct
name|commit_list
modifier|*
name|ca
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|iter
decl_stmt|;
name|struct
name|commit
modifier|*
name|merged_common_ancestors
decl_stmt|;
name|struct
name|tree
modifier|*
name|mrtree
init|=
name|mrtree
decl_stmt|;
name|int
name|clean
decl_stmt|;
if|if
condition|(
name|show
argument_list|(
name|o
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
name|_
argument_list|(
literal|"Merging:"
argument_list|)
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|o
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|o
argument_list|,
name|h2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ca
condition|)
block|{
name|ca
operator|=
name|get_merge_bases
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ca
operator|=
name|reverse_commit_list
argument_list|(
name|ca
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show
argument_list|(
name|o
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|unsigned
name|cnt
init|=
name|commit_list_count
argument_list|(
name|ca
argument_list|)
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|5
argument_list|,
name|Q_
argument_list|(
literal|"found %u common ancestor:"
argument_list|,
literal|"found %u common ancestors:"
argument_list|,
name|cnt
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
name|output_commit_title
argument_list|(
name|o
argument_list|,
name|iter
operator|->
name|item
argument_list|)
expr_stmt|;
block|}
name|merged_common_ancestors
operator|=
name|pop_commit
argument_list|(
operator|&
name|ca
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_common_ancestors
operator|==
name|NULL
condition|)
block|{
comment|/* if there is no common ancestor, use an empty tree */
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|tree
operator|=
name|lookup_tree
argument_list|(
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
name|merged_common_ancestors
operator|=
name|make_virtual_commit
argument_list|(
name|tree
argument_list|,
literal|"ancestor"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|saved_b1
decl_stmt|,
modifier|*
name|saved_b2
decl_stmt|;
name|o
operator|->
name|call_depth
operator|++
expr_stmt|;
comment|/* 		 * When the merge fails, the result contains files 		 * with conflict markers. The cleanness flag is 		 * ignored, it was never actually used, as result of 		 * merge_trees has always overwritten it: the committed 		 * "conflicts" were already resolved. 		 */
name|discard_cache
argument_list|()
expr_stmt|;
name|saved_b1
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|saved_b2
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|o
operator|->
name|branch1
operator|=
literal|"Temporary merge branch 1"
expr_stmt|;
name|o
operator|->
name|branch2
operator|=
literal|"Temporary merge branch 2"
expr_stmt|;
name|merge_recursive
argument_list|(
name|o
argument_list|,
name|merged_common_ancestors
argument_list|,
name|iter
operator|->
name|item
argument_list|,
name|NULL
argument_list|,
operator|&
name|merged_common_ancestors
argument_list|)
expr_stmt|;
name|o
operator|->
name|branch1
operator|=
name|saved_b1
expr_stmt|;
name|o
operator|->
name|branch2
operator|=
name|saved_b2
expr_stmt|;
name|o
operator|->
name|call_depth
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|merged_common_ancestors
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"merge returned no commit"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|call_depth
condition|)
name|read_cache
argument_list|()
expr_stmt|;
name|o
operator|->
name|ancestor
operator|=
literal|"merged common ancestors"
expr_stmt|;
name|clean
operator|=
name|merge_trees
argument_list|(
name|o
argument_list|,
name|h1
operator|->
name|tree
argument_list|,
name|h2
operator|->
name|tree
argument_list|,
name|merged_common_ancestors
operator|->
name|tree
argument_list|,
operator|&
name|mrtree
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
operator|*
name|result
operator|=
name|make_virtual_commit
argument_list|(
name|mrtree
argument_list|,
literal|"merged tree"
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h1
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h2
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
name|flush_output
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
argument_list|(
name|o
argument_list|,
literal|2
argument_list|)
condition|)
name|diff_warn_rename_limit
argument_list|(
literal|"merge.renamelimit"
argument_list|,
name|o
operator|->
name|needed_rename_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|get_ref
specifier|static
name|struct
name|commit
modifier|*
name|get_ref
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|object
decl_stmt|;
name|object
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJ_TREE
condition|)
return|return
name|make_virtual_commit
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|object
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|parse_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
return|;
block|}
end_function
begin_function
DECL|function|merge_recursive_generic
name|int
name|merge_recursive_generic
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|merge
parameter_list|,
name|int
name|num_base_list
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|base_list
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|clean
decl_stmt|,
name|index_fd
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|head_commit
init|=
name|get_ref
argument_list|(
name|head
argument_list|,
name|o
operator|->
name|branch1
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|next_commit
init|=
name|get_ref
argument_list|(
name|merge
argument_list|,
name|o
operator|->
name|branch2
argument_list|)
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|ca
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|base_list
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_base_list
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|commit
modifier|*
name|base
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|base
operator|=
name|get_ref
argument_list|(
name|base_list
index|[
name|i
index|]
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_list
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse object '%s'"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_list
index|[
name|i
index|]
argument_list|)
argument_list|)
return|;
name|commit_list_insert
argument_list|(
name|base
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
block|}
block|}
name|index_fd
operator|=
name|hold_locked_index
argument_list|(
name|lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clean
operator|=
name|merge_recursive
argument_list|(
name|o
argument_list|,
name|head_commit
argument_list|,
name|next_commit
argument_list|,
name|ca
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|&&
operator|(
name|write_cache
argument_list|(
name|index_fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock
argument_list|)
operator|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to write index."
argument_list|)
argument_list|)
return|;
return|return
name|clean
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|merge_recursive_config
specifier|static
name|int
name|merge_recursive_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|merge_options
modifier|*
name|o
init|=
name|cb
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"merge.verbosity"
argument_list|)
condition|)
block|{
name|o
operator|->
name|verbosity
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"diff.renamelimit"
argument_list|)
condition|)
block|{
name|o
operator|->
name|diff_rename_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"merge.renamelimit"
argument_list|)
condition|)
block|{
name|o
operator|->
name|merge_rename_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_xmerge_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init_merge_options
name|void
name|init_merge_options
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|)
block|{
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|merge_options
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|verbosity
operator|=
literal|2
expr_stmt|;
name|o
operator|->
name|buffer_output
operator|=
literal|1
expr_stmt|;
name|o
operator|->
name|diff_rename_limit
operator|=
operator|-
literal|1
expr_stmt|;
name|o
operator|->
name|merge_rename_limit
operator|=
operator|-
literal|1
expr_stmt|;
name|o
operator|->
name|renormalize
operator|=
literal|0
expr_stmt|;
name|git_config
argument_list|(
name|merge_recursive_config
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GIT_MERGE_VERBOSITY"
argument_list|)
condition|)
name|o
operator|->
name|verbosity
operator|=
name|strtol
argument_list|(
name|getenv
argument_list|(
literal|"GIT_MERGE_VERBOSITY"
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|5
condition|)
name|o
operator|->
name|buffer_output
operator|=
literal|0
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|current_file_set
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|current_directory_set
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|o
operator|->
name|df_conflict_file_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|df_conflict_file_set
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_merge_opt
name|int
name|parse_merge_opt
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s
operator|||
operator|!
operator|*
name|s
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ours"
argument_list|)
condition|)
name|o
operator|->
name|recursive_variant
operator|=
name|MERGE_RECURSIVE_OURS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"theirs"
argument_list|)
condition|)
name|o
operator|->
name|recursive_variant
operator|=
name|MERGE_RECURSIVE_THEIRS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"subtree"
argument_list|)
condition|)
name|o
operator|->
name|subtree_shift
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|s
argument_list|,
literal|"subtree="
argument_list|)
condition|)
name|o
operator|->
name|subtree_shift
operator|=
name|s
operator|+
name|strlen
argument_list|(
literal|"subtree="
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"patience"
argument_list|)
condition|)
name|o
operator|->
name|xdl_opts
operator|=
name|DIFF_WITH_ALG
argument_list|(
name|o
argument_list|,
name|PATIENCE_DIFF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"histogram"
argument_list|)
condition|)
name|o
operator|->
name|xdl_opts
operator|=
name|DIFF_WITH_ALG
argument_list|(
name|o
argument_list|,
name|HISTOGRAM_DIFF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|s
argument_list|,
literal|"diff-algorithm="
argument_list|)
condition|)
block|{
name|long
name|value
init|=
name|parse_algorithm_value
argument_list|(
name|s
operator|+
name|strlen
argument_list|(
literal|"diff-algorithm="
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* clear out previous settings */
name|DIFF_XDL_CLR
argument_list|(
name|o
argument_list|,
name|NEED_MINIMAL
argument_list|)
expr_stmt|;
name|o
operator|->
name|xdl_opts
operator|&=
operator|~
name|XDF_DIFF_ALGORITHM_MASK
expr_stmt|;
name|o
operator|->
name|xdl_opts
operator||=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ignore-space-change"
argument_list|)
condition|)
name|o
operator|->
name|xdl_opts
operator||=
name|XDF_IGNORE_WHITESPACE_CHANGE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ignore-all-space"
argument_list|)
condition|)
name|o
operator|->
name|xdl_opts
operator||=
name|XDF_IGNORE_WHITESPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ignore-space-at-eol"
argument_list|)
condition|)
name|o
operator|->
name|xdl_opts
operator||=
name|XDF_IGNORE_WHITESPACE_AT_EOL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"renormalize"
argument_list|)
condition|)
name|o
operator|->
name|renormalize
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"no-renormalize"
argument_list|)
condition|)
name|o
operator|->
name|renormalize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|s
argument_list|,
literal|"rename-threshold="
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|score
init|=
name|s
operator|+
name|strlen
argument_list|(
literal|"rename-threshold="
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|rename_score
operator|=
name|parse_rename_score
argument_list|(
operator|&
name|score
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|*
name|score
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
end_unit
