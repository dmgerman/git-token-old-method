begin_unit
begin_comment
comment|/*  * Recursive Merge algorithm stolen from git-merge-recursive.py by  * Fredrik Kuivinen.  * The thieves were Alex Riesen and Johannes Schindelin, in June/July 2006  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"ll-merge.h"
end_include
begin_include
include|#
directive|include
file|"attr.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_function
DECL|function|shift_tree_object
specifier|static
name|struct
name|tree
modifier|*
name|shift_tree_object
parameter_list|(
name|struct
name|tree
modifier|*
name|one
parameter_list|,
name|struct
name|tree
modifier|*
name|two
parameter_list|)
block|{
name|unsigned
name|char
name|shifted
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * NEEDSWORK: this limits the recursion depth to hardcoded 	 * value '2' to avoid excessive overhead. 	 */
name|shift_tree
argument_list|(
name|one
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|two
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|shifted
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|two
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|shifted
argument_list|)
condition|)
return|return
name|two
return|;
return|return
name|lookup_tree
argument_list|(
name|shifted
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * A virtual commit has (const char *)commit->util set to the name.  */
end_comment
begin_function
DECL|function|make_virtual_commit
name|struct
name|commit
modifier|*
name|make_virtual_commit
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commit
argument_list|)
argument_list|)
decl_stmt|;
name|commit
operator|->
name|tree
operator|=
name|tree
expr_stmt|;
name|commit
operator|->
name|util
operator|=
operator|(
name|void
operator|*
operator|)
name|comment
expr_stmt|;
comment|/* avoid warnings */
name|commit
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
return|return
name|commit
return|;
block|}
end_function
begin_comment
comment|/*  * Since we use get_tree_entry(), which does not put the read object into  * the object pool, we cannot rely on a == b.  */
end_comment
begin_function
DECL|function|sha_eq
specifier|static
name|int
name|sha_eq
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|&&
operator|!
name|b
condition|)
return|return
literal|2
return|;
return|return
name|a
operator|&&
name|b
operator|&&
name|hashcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Since we want to write the index eventually, we cannot reuse the index  * for these (temporary) data.  */
end_comment
begin_struct
DECL|struct|stage_data
struct|struct
name|stage_data
block|{
struct|struct
block|{
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
block|}
DECL|member|stages
name|stages
index|[
literal|4
index|]
struct|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|show
specifier|static
name|int
name|show
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|v
parameter_list|)
block|{
return|return
operator|(
operator|!
name|o
operator|->
name|call_depth
operator|&&
name|o
operator|->
name|verbosity
operator|>=
name|v
operator|)
operator|||
name|o
operator|->
name|verbosity
operator|>=
literal|5
return|;
block|}
end_function
begin_function
DECL|function|flush_output
specifier|static
name|void
name|flush_output
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|obuf
operator|.
name|len
condition|)
block|{
name|fputs
argument_list|(
name|o
operator|->
name|obuf
operator|.
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|output
specifier|static
name|void
name|output
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|show
argument_list|(
name|o
argument_list|,
name|v
argument_list|)
condition|)
return|return;
name|strbuf_grow
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
name|o
operator|->
name|call_depth
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|o
operator|->
name|obuf
operator|.
name|buf
operator|+
name|o
operator|->
name|obuf
operator|.
name|len
argument_list|,
literal|' '
argument_list|,
name|o
operator|->
name|call_depth
operator|*
literal|2
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
name|o
operator|->
name|obuf
operator|.
name|len
operator|+
name|o
operator|->
name|call_depth
operator|*
literal|2
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|o
operator|->
name|obuf
operator|.
name|buf
operator|+
name|o
operator|->
name|obuf
operator|.
name|len
argument_list|,
name|strbuf_avail
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|strbuf_avail
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|)
condition|)
block|{
name|strbuf_grow
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|o
operator|->
name|obuf
operator|.
name|buf
operator|+
name|o
operator|->
name|obuf
operator|.
name|len
argument_list|,
name|strbuf_avail
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|strbuf_avail
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|)
condition|)
block|{
name|die
argument_list|(
literal|"this should not happen, your snprintf is broken"
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_setlen
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
name|o
operator|->
name|obuf
operator|.
name|len
operator|+
name|len
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|buffer_output
condition|)
name|flush_output
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_commit_title
specifier|static
name|void
name|output_commit_title
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|flush_output
argument_list|(
name|o
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|o
operator|->
name|call_depth
init|;
name|i
operator|--
condition|;
control|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|util
condition|)
name|printf
argument_list|(
literal|"virtual %s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|commit
operator|->
name|util
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"(bad commit)\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|commit
operator|->
name|buffer
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|s
index|[
name|len
index|]
operator|&&
literal|'\n'
operator|!=
name|s
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
name|len
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|add_cacheinfo
specifier|static
name|int
name|add_cacheinfo
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|stage
parameter_list|,
name|int
name|refresh
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|make_cache_entry
argument_list|(
name|mode
argument_list|,
name|sha1
condition|?
name|sha1
else|:
name|null_sha1
argument_list|,
name|path
argument_list|,
name|stage
argument_list|,
name|refresh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
name|error
argument_list|(
literal|"addinfo_cache failed for path '%s'"
argument_list|,
name|path
argument_list|)
return|;
return|return
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init_tree_desc_from_tree
specifier|static
name|void
name|init_tree_desc_from_tree
parameter_list|(
name|struct
name|tree_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
name|desc
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_merge_trees
specifier|static
name|int
name|git_merge_trees
parameter_list|(
name|int
name|index_only
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|tree_desc
name|t
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_only
condition|)
name|opts
operator|.
name|index_only
operator|=
literal|1
expr_stmt|;
else|else
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|2
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|threeway_merge
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|init_tree_desc_from_tree
argument_list|(
name|t
operator|+
literal|0
argument_list|,
name|common
argument_list|)
expr_stmt|;
name|init_tree_desc_from_tree
argument_list|(
name|t
operator|+
literal|1
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|init_tree_desc_from_tree
argument_list|(
name|t
operator|+
literal|2
argument_list|,
name|merge
argument_list|)
expr_stmt|;
name|rc
operator|=
name|unpack_trees
argument_list|(
literal|3
argument_list|,
name|t
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|cache_tree_free
argument_list|(
operator|&
name|active_cache_tree
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|write_tree_from_memory
name|struct
name|tree
modifier|*
name|write_tree_from_memory
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
literal|"There are unmerged index entries:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
name|output
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
literal|"%d %.*s"
argument_list|,
name|ce_stage
argument_list|(
name|ce
argument_list|)
argument_list|,
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|active_cache_tree
condition|)
name|active_cache_tree
operator|=
name|cache_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cache_tree_fully_valid
argument_list|(
name|active_cache_tree
argument_list|)
operator|&&
name|cache_tree_update
argument_list|(
name|active_cache_tree
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"error building trees"
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup_tree
argument_list|(
name|active_cache_tree
operator|->
name|sha1
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|save_files_dirs
specifier|static
name|int
name|save_files_dirs
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|int
name|stage
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newpath
init|=
name|xmalloc
argument_list|(
name|baselen
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|merge_options
modifier|*
name|o
init|=
name|context
decl_stmt|;
name|memcpy
argument_list|(
name|newpath
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newpath
operator|+
name|baselen
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newpath
index|[
name|baselen
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|string_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|o
operator|->
name|current_directory_set
argument_list|)
expr_stmt|;
else|else
name|string_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|o
operator|->
name|current_file_set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|?
name|READ_TREE_RECURSIVE
else|:
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|get_files_dirs
specifier|static
name|int
name|get_files_dirs
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|read_tree_recursive
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|save_files_dirs
argument_list|,
name|o
argument_list|)
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|o
operator|->
name|current_file_set
operator|.
name|nr
operator|+
name|o
operator|->
name|current_directory_set
operator|.
name|nr
expr_stmt|;
return|return
name|n
return|;
block|}
end_function
begin_comment
comment|/*  * Returns an index_entry instance which doesn't have to correspond to  * a real cache entry in Git's index.  */
end_comment
begin_function
DECL|function|insert_stage_data
specifier|static
name|struct
name|stage_data
modifier|*
name|insert_stage_data
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|tree
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|a
parameter_list|,
name|struct
name|tree
modifier|*
name|b
parameter_list|,
name|struct
name|string_list
modifier|*
name|entries
parameter_list|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
decl_stmt|;
name|get_tree_entry
argument_list|(
name|o
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|a
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|get_tree_entry
argument_list|(
name|b
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|path
argument_list|,
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
operator|&
name|e
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|item
operator|=
name|string_list_insert
argument_list|(
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|e
expr_stmt|;
return|return
name|e
return|;
block|}
end_function
begin_comment
comment|/*  * Create a dictionary mapping file names to stage_data objects. The  * dictionary contains one entry for every path with a non-zero stage entry.  */
end_comment
begin_function
DECL|function|get_unmerged
specifier|static
name|struct
name|string_list
modifier|*
name|get_unmerged
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|unmerged
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unmerged
operator|->
name|strdup_strings
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
continue|continue;
name|item
operator|=
name|string_list_lookup
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|unmerged
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|item
operator|=
name|string_list_insert
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|unmerged
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stage_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|mode
operator|=
name|ce
operator|->
name|ce_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|stages
index|[
name|ce_stage
argument_list|(
name|ce
argument_list|)
index|]
operator|.
name|sha
argument_list|,
name|ce
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
return|return
name|unmerged
return|;
block|}
end_function
begin_struct
DECL|struct|rename
struct|struct
name|rename
block|{
DECL|member|pair
name|struct
name|diff_filepair
modifier|*
name|pair
decl_stmt|;
DECL|member|src_entry
name|struct
name|stage_data
modifier|*
name|src_entry
decl_stmt|;
DECL|member|dst_entry
name|struct
name|stage_data
modifier|*
name|dst_entry
decl_stmt|;
DECL|member|processed
name|unsigned
name|processed
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Get information of all renames which occurred between 'o_tree' and  * 'tree'. We need the three trees in the merge ('o_tree', 'a_tree' and  * 'b_tree') to be able to associate the correct cache entries with  * the rename information. 'tree' is always equal to either a_tree or b_tree.  */
end_comment
begin_function
DECL|function|get_renames
specifier|static
name|struct
name|string_list
modifier|*
name|get_renames
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|struct
name|tree
modifier|*
name|o_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|a_tree
parameter_list|,
name|struct
name|tree
modifier|*
name|b_tree
parameter_list|,
name|struct
name|string_list
modifier|*
name|entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|string_list
modifier|*
name|renames
decl_stmt|;
name|struct
name|diff_options
name|opts
decl_stmt|;
name|renames
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|opts
operator|.
name|detect_rename
operator|=
name|DIFF_DETECT_RENAME
expr_stmt|;
name|opts
operator|.
name|rename_limit
operator|=
name|o
operator|->
name|merge_rename_limit
operator|>=
literal|0
condition|?
name|o
operator|->
name|merge_rename_limit
else|:
name|o
operator|->
name|diff_rename_limit
operator|>=
literal|0
condition|?
name|o
operator|->
name|diff_rename_limit
else|:
literal|500
expr_stmt|;
name|opts
operator|.
name|warn_on_too_large_rename
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff setup failed"
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|o_tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|rename
modifier|*
name|re
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|pair
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pair
operator|->
name|status
operator|!=
literal|'R'
condition|)
block|{
name|diff_free_filepair
argument_list|(
name|pair
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|re
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|re
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|processed
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|pair
operator|=
name|pair
expr_stmt|;
name|item
operator|=
name|string_list_lookup
argument_list|(
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|src_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|src_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|string_list_lookup
argument_list|(
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
name|re
operator|->
name|dst_entry
operator|=
name|insert_stage_data
argument_list|(
name|re
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|o_tree
argument_list|,
name|a_tree
argument_list|,
name|b_tree
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|re
operator|->
name|dst_entry
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|item
operator|=
name|string_list_insert
argument_list|(
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|renames
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|re
expr_stmt|;
block|}
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_queued_diff
operator|.
name|nr
operator|=
literal|0
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
return|return
name|renames
return|;
block|}
end_function
begin_function
DECL|function|update_stages
specifier|static
name|int
name|update_stages
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
name|int
name|options
init|=
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_OK_TO_REPLACE
decl_stmt|;
if|if
condition|(
name|clear
condition|)
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|o
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|o
operator|->
name|mode
argument_list|,
name|o
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|a
operator|->
name|mode
argument_list|,
name|a
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|b
condition|)
if|if
condition|(
name|add_cacheinfo
argument_list|(
name|b
operator|->
name|mode
argument_list|,
name|b
operator|->
name|sha1
argument_list|,
name|path
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|remove_file
specifier|static
name|int
name|remove_file
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|clean
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|no_wd
parameter_list|)
block|{
name|int
name|update_cache
init|=
name|o
operator|->
name|call_depth
operator|||
name|clean
decl_stmt|;
name|int
name|update_working_directory
init|=
operator|!
name|o
operator|->
name|call_depth
operator|&&
operator|!
name|no_wd
decl_stmt|;
if|if
condition|(
name|update_cache
condition|)
block|{
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|update_working_directory
condition|)
block|{
if|if
condition|(
name|remove_path
argument_list|(
name|path
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unique_path
specifier|static
name|char
modifier|*
name|unique_path
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|branch
parameter_list|)
block|{
name|char
modifier|*
name|newpath
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|8
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|suffix
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|newpath
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'~'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|branch
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
literal|'/'
operator|==
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
while|while
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
name|newpath
argument_list|)
operator|||
name|lstat
argument_list|(
name|newpath
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"_%d"
argument_list|,
name|suffix
operator|++
argument_list|)
expr_stmt|;
name|string_list_insert
argument_list|(
name|newpath
argument_list|,
operator|&
name|o
operator|->
name|current_file_set
argument_list|)
expr_stmt|;
return|return
name|newpath
return|;
block|}
end_function
begin_function
DECL|function|flush_buffer
specifier|static
name|void
name|flush_buffer
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|long
name|ret
init|=
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Ignore epipe */
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
break|break;
name|die_errno
argument_list|(
literal|"merge-recursive"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|die
argument_list|(
literal|"merge-recursive: disk full?"
argument_list|)
expr_stmt|;
block|}
name|size
operator|-=
name|ret
expr_stmt|;
name|buf
operator|+=
name|ret
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|would_lose_untracked
specifier|static
name|int
name|would_lose_untracked
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|pos
init|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
literal|1
operator|-
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|path
argument_list|,
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* 		 * If stage #0, it is definitely tracked. 		 * If it has stage #2 then it was tracked 		 * before this merge started.  All other 		 * cases the path was not tracked. 		 */
switch|switch
condition|(
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
return|return
literal|0
return|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
return|return
name|file_exists
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|make_room_for_path
specifier|static
name|int
name|make_room_for_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"failed to create path '%s'%s"
decl_stmt|;
name|status
operator|=
name|safe_create_leading_directories_const
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|3
condition|)
block|{
comment|/* something else exists */
name|error
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
literal|": perhaps a D/F conflict?"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|die
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do not unlink a file in the work tree if we are not 	 * tracking it. 	 */
if|if
condition|(
name|would_lose_untracked
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"refusing to lose untracked file at '%s'"
argument_list|,
name|path
argument_list|)
return|;
comment|/* Successful unlink is good.. */
if|if
condition|(
operator|!
name|unlink
argument_list|(
name|path
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* .. and so is no existing file */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
comment|/* .. but not some other error (who really cares what?) */
return|return
name|error
argument_list|(
name|msg
argument_list|,
name|path
argument_list|,
literal|": perhaps a D/F conflict?"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|update_file_flags
specifier|static
name|void
name|update_file_flags
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|update_cache
parameter_list|,
name|int
name|update_wd
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
name|update_wd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|update_wd
condition|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|)
comment|/* 			 * We may later decide to recursively descend into 			 * the submodule directory and update its index 			 * and/or work tree, but we do not do that now. 			 */
goto|goto
name|update_index
goto|;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|sha
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"cannot read object %s '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"blob expected for %s '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|strbuf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|convert_to_working_tree
argument_list|(
name|path
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|strbuf
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|size
operator|=
name|strbuf
operator|.
name|len
expr_stmt|;
name|buf
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|strbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|make_room_for_path
argument_list|(
name|path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|update_wd
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|update_index
goto|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
operator|||
operator|(
operator|!
name|has_symlinks
operator|&&
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|mode
operator|&
literal|0100
condition|)
name|mode
operator|=
literal|0777
expr_stmt|;
else|else
name|mode
operator|=
literal|0666
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"failed to open '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|lnk
init|=
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|safe_create_leading_directories_const
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|lnk
argument_list|,
name|path
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"failed to symlink '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lnk
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"do not know what to do with %06o %s '%s'"
argument_list|,
name|mode
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|update_index
label|:
if|if
condition|(
name|update_cache
condition|)
name|add_cacheinfo
argument_list|(
name|mode
argument_list|,
name|sha
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|update_wd
argument_list|,
name|ADD_CACHE_OK_TO_ADD
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_file
specifier|static
name|void
name|update_file
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|int
name|clean
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|update_file_flags
argument_list|(
name|o
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|call_depth
operator|||
name|clean
argument_list|,
operator|!
name|o
operator|->
name|call_depth
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Low level file merging, update and removal */
end_comment
begin_struct
DECL|struct|merge_file_info
struct|struct
name|merge_file_info
block|{
DECL|member|sha
name|unsigned
name|char
name|sha
index|[
literal|20
index|]
decl_stmt|;
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|clean
name|unsigned
name|clean
range|:
literal|1
decl_stmt|,
DECL|member|merge
name|merge
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|fill_mm
specifier|static
name|void
name|fill_mm
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|mmfile_t
modifier|*
name|mm
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
name|mm
operator|->
name|ptr
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|mm
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|mm
operator|->
name|ptr
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mm
operator|->
name|ptr
operator|||
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"unable to read blob object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|mm
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_3way
specifier|static
name|int
name|merge_3way
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|mmbuffer_t
modifier|*
name|result_buf
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|one
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|mmfile_t
name|orig
decl_stmt|,
name|src1
decl_stmt|,
name|src2
decl_stmt|;
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
name|int
name|merge_status
decl_stmt|;
name|name1
operator|=
name|xstrdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s:%s"
argument_list|,
name|branch1
argument_list|,
name|a
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|name2
operator|=
name|xstrdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s:%s"
argument_list|,
name|branch2
argument_list|,
name|b
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|fill_mm
argument_list|(
name|one
operator|->
name|sha1
argument_list|,
operator|&
name|orig
argument_list|)
expr_stmt|;
name|fill_mm
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
operator|&
name|src1
argument_list|)
expr_stmt|;
name|fill_mm
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
operator|&
name|src2
argument_list|)
expr_stmt|;
name|merge_status
operator|=
name|ll_merge
argument_list|(
name|result_buf
argument_list|,
name|a
operator|->
name|path
argument_list|,
operator|&
name|orig
argument_list|,
operator|&
name|src1
argument_list|,
name|name1
argument_list|,
operator|&
name|src2
argument_list|,
name|name2
argument_list|,
name|o
operator|->
name|call_depth
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|orig
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src1
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src2
operator|.
name|ptr
argument_list|)
expr_stmt|;
return|return
name|merge_status
return|;
block|}
end_function
begin_function
DECL|function|merge_file
specifier|static
name|struct
name|merge_file_info
name|merge_file
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|one
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|a
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|struct
name|merge_file_info
name|result
decl_stmt|;
name|result
operator|.
name|merge
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|S_IFMT
operator|&
name|a
operator|->
name|mode
operator|)
operator|!=
operator|(
name|S_IFMT
operator|&
name|b
operator|->
name|mode
operator|)
condition|)
block|{
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|mode
operator|=
name|b
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
operator|&&
operator|!
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Merge modes 		 */
if|if
condition|(
name|a
operator|->
name|mode
operator|==
name|b
operator|->
name|mode
operator|||
name|a
operator|->
name|mode
operator|==
name|one
operator|->
name|mode
condition|)
name|result
operator|.
name|mode
operator|=
name|b
operator|->
name|mode
expr_stmt|;
else|else
block|{
name|result
operator|.
name|mode
operator|=
name|a
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|mode
operator|!=
name|one
operator|->
name|mode
condition|)
block|{
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
operator|||
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sha_eq
argument_list|(
name|b
operator|->
name|sha1
argument_list|,
name|one
operator|->
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|mmbuffer_t
name|result_buf
decl_stmt|;
name|int
name|merge_status
decl_stmt|;
name|merge_status
operator|=
name|merge_3way
argument_list|(
name|o
argument_list|,
operator|&
name|result_buf
argument_list|,
name|one
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|merge_status
operator|<
literal|0
operator|)
operator|||
operator|!
name|result_buf
operator|.
name|ptr
condition|)
name|die
argument_list|(
literal|"Failed to execute internal merge"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_sha1_file
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|,
name|result_buf
operator|.
name|size
argument_list|,
name|blob_type
argument_list|,
name|result
operator|.
name|sha
argument_list|)
condition|)
name|die
argument_list|(
literal|"Unable to add %s to database"
argument_list|,
name|a
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|result
operator|.
name|clean
operator|=
operator|(
name|merge_status
operator|==
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|a
operator|->
name|mode
argument_list|)
condition|)
block|{
name|hashcpy
argument_list|(
name|result
operator|.
name|sha
argument_list|,
name|a
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|a
operator|->
name|sha1
argument_list|,
name|b
operator|->
name|sha1
argument_list|)
condition|)
name|result
operator|.
name|clean
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|die
argument_list|(
literal|"unsupported object type in the tree"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|conflict_rename_rename
specifier|static
name|void
name|conflict_rename_rename
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
name|struct
name|rename
modifier|*
name|ren2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|char
modifier|*
name|del
index|[
literal|2
index|]
decl_stmt|;
name|int
name|delp
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren1_dst
init|=
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren2_dst
init|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_name1
init|=
name|ren1_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_name2
init|=
name|ren2_dst
decl_stmt|;
if|if
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
name|ren1_dst
argument_list|)
condition|)
block|{
name|dst_name1
operator|=
name|del
index|[
name|delp
operator|++
index|]
operator|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"%s is a directory in %s adding as %s instead"
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|,
name|dst_name1
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren1_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
name|ren2_dst
argument_list|)
condition|)
block|{
name|dst_name2
operator|=
name|del
index|[
name|delp
operator|++
index|]
operator|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|ren2_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"%s is a directory in %s adding as %s instead"
argument_list|,
name|ren2_dst
argument_list|,
name|branch1
argument_list|,
name|dst_name2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren2_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
name|remove_file_from_cache
argument_list|(
name|dst_name1
argument_list|)
expr_stmt|;
name|remove_file_from_cache
argument_list|(
name|dst_name2
argument_list|)
expr_stmt|;
comment|/* 		 * Uncomment to leave the conflicting names in the resulting tree 		 * 		 * update_file(o, 0, ren1->pair->two->sha1, ren1->pair->two->mode, dst_name1); 		 * update_file(o, 0, ren2->pair->two->sha1, ren2->pair->two->mode, dst_name2); 		 */
block|}
else|else
block|{
name|update_stages
argument_list|(
name|dst_name1
argument_list|,
name|NULL
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_stages
argument_list|(
name|dst_name2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|delp
operator|--
condition|)
name|free
argument_list|(
name|del
index|[
name|delp
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_dir
specifier|static
name|void
name|conflict_rename_dir
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|)
block|{
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch1
argument_list|)
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"Renaming %s to %s instead"
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|conflict_rename_rename_2
specifier|static
name|void
name|conflict_rename_rename_2
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|rename
modifier|*
name|ren1
parameter_list|,
specifier|const
name|char
modifier|*
name|branch1
parameter_list|,
name|struct
name|rename
modifier|*
name|ren2
parameter_list|,
specifier|const
name|char
modifier|*
name|branch2
parameter_list|)
block|{
name|char
modifier|*
name|new_path1
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_path2
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch2
argument_list|)
decl_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"Renaming %s to %s and %s to %s instead"
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path1
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_path1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|process_renames
specifier|static
name|int
name|process_renames
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|string_list
modifier|*
name|a_renames
parameter_list|,
name|struct
name|string_list
modifier|*
name|b_renames
parameter_list|)
block|{
name|int
name|clean_merge
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|string_list
name|a_by_dst
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|b_by_dst
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|struct
name|rename
modifier|*
name|sre
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|string_list_insert
argument_list|(
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
operator|&
name|a_by_dst
argument_list|)
operator|->
name|util
operator|=
name|sre
operator|->
name|dst_entry
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b_renames
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|sre
operator|=
name|b_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
expr_stmt|;
name|string_list_insert
argument_list|(
name|sre
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
operator|&
name|b_by_dst
argument_list|)
operator|->
name|util
operator|=
name|sre
operator|->
name|dst_entry
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|a_renames
operator|->
name|nr
operator|||
name|j
operator|<
name|b_renames
operator|->
name|nr
condition|;
control|)
block|{
name|char
modifier|*
name|src
decl_stmt|;
name|struct
name|string_list
modifier|*
name|renames1
decl_stmt|,
modifier|*
name|renames2Dst
decl_stmt|;
name|struct
name|rename
modifier|*
name|ren1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ren2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch1
decl_stmt|,
modifier|*
name|branch2
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren1_src
decl_stmt|,
modifier|*
name|ren1_dst
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|a_renames
operator|->
name|nr
condition|)
block|{
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>=
name|b_renames
operator|->
name|nr
condition|)
block|{
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
else|else
block|{
name|int
name|compare
init|=
name|strcmp
argument_list|(
name|a_renames
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|b_renames
operator|->
name|items
index|[
name|j
index|]
operator|.
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|<=
literal|0
condition|)
name|ren1
operator|=
name|a_renames
operator|->
name|items
index|[
name|i
operator|++
index|]
operator|.
name|util
expr_stmt|;
if|if
condition|(
name|compare
operator|>=
literal|0
condition|)
name|ren2
operator|=
name|b_renames
operator|->
name|items
index|[
name|j
operator|++
index|]
operator|.
name|util
expr_stmt|;
block|}
comment|/* TODO: refactor, so that 1/2 are not needed */
if|if
condition|(
name|ren1
condition|)
block|{
name|renames1
operator|=
name|a_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|b_by_dst
expr_stmt|;
name|branch1
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|branch2
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
block|}
else|else
block|{
name|struct
name|rename
modifier|*
name|tmp
decl_stmt|;
name|renames1
operator|=
name|b_renames
expr_stmt|;
name|renames2Dst
operator|=
operator|&
name|a_by_dst
expr_stmt|;
name|branch1
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|branch2
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|tmp
operator|=
name|ren2
expr_stmt|;
name|ren2
operator|=
name|ren1
expr_stmt|;
name|ren1
operator|=
name|tmp
expr_stmt|;
block|}
name|src
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|ren1
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1
operator|->
name|src_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ren1
operator|->
name|processed
condition|)
continue|continue;
name|ren1
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren1_src
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|path
expr_stmt|;
name|ren1_dst
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|ren2
condition|)
block|{
specifier|const
name|char
modifier|*
name|ren2_src
init|=
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|ren2_dst
init|=
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
decl_stmt|;
comment|/* Renamed in 1 and renamed in 2 */
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_src
argument_list|,
name|ren2_src
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"ren1.src != ren2.src"
argument_list|)
expr_stmt|;
name|ren2
operator|->
name|dst_entry
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ren1_dst
argument_list|,
name|ren2_dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (rename/rename): "
literal|"Rename \"%s\"->\"%s\" in branch \"%s\" "
literal|"rename \"%s\"->\"%s\" in \"%s\"%s"
argument_list|,
name|src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|src
argument_list|,
name|ren2_dst
argument_list|,
name|branch2
argument_list|,
name|o
operator|->
name|call_depth
condition|?
literal|" (left unresolved)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
name|remove_file_from_cache
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
operator|->
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|conflict_rename_rename
argument_list|(
name|o
argument_list|,
name|ren1
argument_list|,
name|branch1
argument_list|,
name|ren2
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|ren1_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mfi
operator|=
name|merge_file
argument_list|(
name|o
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
operator|||
operator|!
name|mfi
operator|.
name|clean
condition|)
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"Renaming %s->%s"
argument_list|,
name|src
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
condition|)
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Auto-merging %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (content): merge conflict in %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|call_depth
condition|)
name|update_stages
argument_list|(
name|ren1_dst
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|one
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
argument_list|,
literal|1
comment|/* clear */
argument_list|)
expr_stmt|;
block|}
name|update_file
argument_list|(
name|o
argument_list|,
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Renamed in 1, maybe changed in 2 */
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
comment|/* we only use sha1 and mode of these */
name|struct
name|diff_filespec
name|src_other
decl_stmt|,
name|dst_other
decl_stmt|;
name|int
name|try_merge
decl_stmt|,
name|stage
init|=
name|a_renames
operator|==
name|renames1
condition|?
literal|3
else|:
literal|2
decl_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|ren1_src
argument_list|,
name|o
operator|->
name|call_depth
operator|||
name|stage
operator|==
literal|3
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|src_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|src_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|sha
argument_list|)
expr_stmt|;
name|dst_other
operator|.
name|mode
operator|=
name|ren1
operator|->
name|dst_entry
operator|->
name|stages
index|[
name|stage
index|]
operator|.
name|mode
expr_stmt|;
name|try_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
name|ren1_dst
argument_list|)
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (rename/directory): Rename %s->%s in %s "
literal|" directory %s added in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|conflict_rename_dir
argument_list|(
name|o
argument_list|,
name|ren1
argument_list|,
name|branch1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sha_eq
argument_list|(
name|src_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (rename/delete): Rename %s->%s in %s "
literal|"and deleted in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|call_depth
condition|)
name|update_stages
argument_list|(
name|ren1_dst
argument_list|,
name|NULL
argument_list|,
name|branch1
operator|==
name|o
operator|->
name|branch1
condition|?
name|ren1
operator|->
name|pair
operator|->
name|two
else|:
name|NULL
argument_list|,
name|branch1
operator|==
name|o
operator|->
name|branch1
condition|?
name|NULL
else|:
name|ren1
operator|->
name|pair
operator|->
name|two
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sha_eq
argument_list|(
name|dst_other
operator|.
name|sha1
argument_list|,
name|null_sha1
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_path
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|try_merge
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (rename/add): Rename %s->%s in %s. "
literal|"%s added in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|new_path
operator|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|ren1_dst
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"Adding as %s instead"
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|dst_other
operator|.
name|sha1
argument_list|,
name|dst_other
operator|.
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|item
operator|=
name|string_list_lookup
argument_list|(
name|ren1_dst
argument_list|,
name|renames2Dst
argument_list|)
operator|)
condition|)
block|{
name|ren2
operator|=
name|item
operator|->
name|util
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|ren2
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (rename/rename): "
literal|"Rename %s->%s in %s. "
literal|"Rename %s->%s in %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|,
name|branch1
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|ren2
operator|->
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
name|conflict_rename_rename_2
argument_list|(
name|o
argument_list|,
name|ren1
argument_list|,
name|branch1
argument_list|,
name|ren2
argument_list|,
name|branch2
argument_list|)
expr_stmt|;
block|}
else|else
name|try_merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|try_merge
condition|)
block|{
name|struct
name|diff_filespec
modifier|*
name|one
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|src_other
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ren1_src
expr_stmt|;
name|one
operator|=
name|ren1
operator|->
name|pair
operator|->
name|one
expr_stmt|;
if|if
condition|(
name|a_renames
operator|==
name|renames1
condition|)
block|{
name|a
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|b
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|ren1
operator|->
name|pair
operator|->
name|two
expr_stmt|;
name|a
operator|=
operator|&
name|src_other
expr_stmt|;
block|}
name|mfi
operator|=
name|merge_file
argument_list|(
name|o
argument_list|,
name|one
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|o
operator|->
name|branch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|clean
operator|&&
name|sha_eq
argument_list|(
name|mfi
operator|.
name|sha
argument_list|,
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|)
operator|&&
name|mfi
operator|.
name|mode
operator|==
name|ren1
operator|->
name|pair
operator|->
name|two
operator|->
name|mode
condition|)
comment|/* 					 * This messaged is part of 					 * t6022 test. If you change 					 * it update the test too. 					 */
name|output
argument_list|(
name|o
argument_list|,
literal|3
argument_list|,
literal|"Skipped %s (merged same as existing)"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mfi
operator|.
name|merge
operator|||
operator|!
name|mfi
operator|.
name|clean
condition|)
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"Renaming %s => %s"
argument_list|,
name|ren1_src
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfi
operator|.
name|merge
condition|)
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Auto-merging %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (rename/modify): Merge conflict in %s"
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|call_depth
condition|)
name|update_stages
argument_list|(
name|ren1_dst
argument_list|,
name|one
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update_file
argument_list|(
name|o
argument_list|,
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|ren1_dst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|string_list_clear
argument_list|(
operator|&
name|a_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|b_by_dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|stage_sha
specifier|static
name|unsigned
name|char
modifier|*
name|stage_sha
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha
parameter_list|,
name|unsigned
name|mode
parameter_list|)
block|{
return|return
operator|(
name|is_null_sha1
argument_list|(
name|sha
argument_list|)
operator|||
name|mode
operator|==
literal|0
operator|)
condition|?
name|NULL
else|:
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sha
return|;
block|}
end_function
begin_comment
comment|/* Per entry merge function */
end_comment
begin_function
DECL|function|process_entry
specifier|static
name|int
name|process_entry
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stage_data
modifier|*
name|entry
parameter_list|)
block|{
comment|/* 	printf("processing entry, clean cache: %s\n", index_only ? "yes": "no"); 	print_index_entry("\tpath: ", entry); 	*/
name|int
name|clean_merge
init|=
literal|1
decl_stmt|;
name|unsigned
name|o_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|a_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|b_mode
init|=
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|mode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|o_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|1
index|]
operator|.
name|sha
argument_list|,
name|o_mode
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|a_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|2
index|]
operator|.
name|sha
argument_list|,
name|a_mode
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b_sha
init|=
name|stage_sha
argument_list|(
name|entry
operator|->
name|stages
index|[
literal|3
index|]
operator|.
name|sha
argument_list|,
name|b_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|o_sha
operator|&&
operator|(
operator|!
name|a_sha
operator|||
operator|!
name|b_sha
operator|)
condition|)
block|{
comment|/* Case A: Deleted in one */
if|if
condition|(
operator|(
operator|!
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
name|sha_eq
argument_list|(
name|a_sha
argument_list|,
name|o_sha
argument_list|)
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|a_sha
operator|&&
name|sha_eq
argument_list|(
name|b_sha
argument_list|,
name|o_sha
argument_list|)
operator|)
condition|)
block|{
comment|/* Deleted in both or deleted in one and 			 * unchanged in the other */
if|if
condition|(
name|a_sha
condition|)
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Removing %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* do not touch working file if it did not exist */
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|path
argument_list|,
operator|!
name|a_sha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Deleted in one and changed in the other */
name|clean_merge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|a_sha
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (delete/modify): %s deleted in %s "
literal|"and modified in %s. Version %s of %s left in tree."
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|b_sha
argument_list|,
name|b_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (delete/modify): %s deleted in %s "
literal|"and modified in %s. Version %s of %s left in tree."
argument_list|,
name|path
argument_list|,
name|o
operator|->
name|branch2
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|a_sha
argument_list|,
name|a_mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|o_sha
operator|&&
name|a_sha
operator|&&
operator|!
name|b_sha
operator|)
operator|||
operator|(
operator|!
name|o_sha
operator|&&
operator|!
name|a_sha
operator|&&
name|b_sha
operator|)
condition|)
block|{
comment|/* Case B: Added in one. */
specifier|const
name|char
modifier|*
name|add_branch
decl_stmt|;
specifier|const
name|char
modifier|*
name|other_branch
decl_stmt|;
name|unsigned
name|mode
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha
decl_stmt|;
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
if|if
condition|(
name|a_sha
condition|)
block|{
name|add_branch
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|other_branch
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|mode
operator|=
name|a_mode
expr_stmt|;
name|sha
operator|=
name|a_sha
expr_stmt|;
name|conf
operator|=
literal|"file/directory"
expr_stmt|;
block|}
else|else
block|{
name|add_branch
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|other_branch
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|mode
operator|=
name|b_mode
expr_stmt|;
name|sha
operator|=
name|b_sha
expr_stmt|;
name|conf
operator|=
literal|"directory/file"
expr_stmt|;
block|}
if|if
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
name|path
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_path
init|=
name|unique_path
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|add_branch
argument_list|)
decl_stmt|;
name|clean_merge
operator|=
literal|0
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (%s): There is a directory with name %s in %s. "
literal|"Adding %s as %s"
argument_list|,
name|conf
argument_list|,
name|path
argument_list|,
name|other_branch
argument_list|,
name|path
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
name|remove_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|new_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Adding %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|update_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|sha
argument_list|,
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|a_sha
operator|&&
name|b_sha
condition|)
block|{
comment|/* Case C: Added in both (check for same permissions) and */
comment|/* case D: Modified in both, but differently. */
specifier|const
name|char
modifier|*
name|reason
init|=
literal|"content"
decl_stmt|;
name|struct
name|merge_file_info
name|mfi
decl_stmt|;
name|struct
name|diff_filespec
name|one
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|o_sha
condition|)
block|{
name|reason
operator|=
literal|"add/add"
expr_stmt|;
name|o_sha
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|null_sha1
expr_stmt|;
block|}
name|output
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Auto-merging %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|one
operator|.
name|path
operator|=
name|a
operator|.
name|path
operator|=
name|b
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|path
expr_stmt|;
name|hashcpy
argument_list|(
name|one
operator|.
name|sha1
argument_list|,
name|o_sha
argument_list|)
expr_stmt|;
name|one
operator|.
name|mode
operator|=
name|o_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|a
operator|.
name|sha1
argument_list|,
name|a_sha
argument_list|)
expr_stmt|;
name|a
operator|.
name|mode
operator|=
name|a_mode
expr_stmt|;
name|hashcpy
argument_list|(
name|b
operator|.
name|sha1
argument_list|,
name|b_sha
argument_list|)
expr_stmt|;
name|b
operator|.
name|mode
operator|=
name|b_mode
expr_stmt|;
name|mfi
operator|=
name|merge_file
argument_list|(
name|o
argument_list|,
operator|&
name|one
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|o
operator|->
name|branch1
argument_list|,
name|o
operator|->
name|branch2
argument_list|)
expr_stmt|;
name|clean_merge
operator|=
name|mfi
operator|.
name|clean
expr_stmt|;
if|if
condition|(
operator|!
name|mfi
operator|.
name|clean
condition|)
block|{
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mfi
operator|.
name|mode
argument_list|)
condition|)
name|reason
operator|=
literal|"submodule"
expr_stmt|;
name|output
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
literal|"CONFLICT (%s): Merge conflict in %s"
argument_list|,
name|reason
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|update_file
argument_list|(
name|o
argument_list|,
name|mfi
operator|.
name|clean
argument_list|,
name|mfi
operator|.
name|sha
argument_list|,
name|mfi
operator|.
name|mode
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|o_sha
operator|&&
operator|!
name|a_sha
operator|&&
operator|!
name|b_sha
condition|)
block|{
comment|/* 		 * this entry was deleted altogether. a_mode == 0 means 		 * we had that path and want to actively remove it. 		 */
name|remove_file
argument_list|(
name|o
argument_list|,
literal|1
argument_list|,
name|path
argument_list|,
operator|!
name|a_mode
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"Fatal merge failure, shouldn't happen."
argument_list|)
expr_stmt|;
return|return
name|clean_merge
return|;
block|}
end_function
begin_function
DECL|function|merge_trees
name|int
name|merge_trees
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|merge
parameter_list|,
name|struct
name|tree
modifier|*
name|common
parameter_list|,
name|struct
name|tree
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|clean
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|subtree_merge
condition|)
block|{
name|merge
operator|=
name|shift_tree_object
argument_list|(
name|head
argument_list|,
name|merge
argument_list|)
expr_stmt|;
name|common
operator|=
name|shift_tree_object
argument_list|(
name|head
argument_list|,
name|common
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sha_eq
argument_list|(
name|common
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
literal|"Already uptodate!"
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|head
expr_stmt|;
return|return
literal|1
return|;
block|}
name|code
operator|=
name|git_merge_trees
argument_list|(
name|o
operator|->
name|call_depth
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"merging of trees %s and %s failed"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|merge
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|struct
name|string_list
modifier|*
name|entries
decl_stmt|,
modifier|*
name|re_head
decl_stmt|,
modifier|*
name|re_merge
decl_stmt|;
name|int
name|i
decl_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|o
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|get_files_dirs
argument_list|(
name|o
argument_list|,
name|merge
argument_list|)
expr_stmt|;
name|entries
operator|=
name|get_unmerged
argument_list|()
expr_stmt|;
name|re_head
operator|=
name|get_renames
argument_list|(
name|o
argument_list|,
name|head
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|re_merge
operator|=
name|get_renames
argument_list|(
name|o
argument_list|,
name|merge
argument_list|,
name|common
argument_list|,
name|head
argument_list|,
name|merge
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|clean
operator|=
name|process_renames
argument_list|(
name|o
argument_list|,
name|re_head
argument_list|,
name|re_merge
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
name|struct
name|stage_data
modifier|*
name|e
init|=
name|entries
operator|->
name|items
index|[
name|i
index|]
operator|.
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|processed
operator|&&
operator|!
name|process_entry
argument_list|(
name|o
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
name|re_merge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
name|re_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
name|entries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
operator|*
name|result
operator|=
name|write_tree_from_memory
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|reverse_commit_list
specifier|static
name|struct
name|commit_list
modifier|*
name|reverse_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
name|NULL
decl_stmt|,
modifier|*
name|current
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
for|for
control|(
name|current
operator|=
name|list
init|;
name|current
condition|;
name|current
operator|=
name|backup
control|)
block|{
name|backup
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|current
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|current
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function
begin_comment
comment|/*  * Merge the commits h1 and h2, return the resulting virtual  * commit object and a flag indicating the cleanness of the merge.  */
end_comment
begin_function
DECL|function|merge_recursive
name|int
name|merge_recursive
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|commit
modifier|*
name|h1
parameter_list|,
name|struct
name|commit
modifier|*
name|h2
parameter_list|,
name|struct
name|commit_list
modifier|*
name|ca
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|iter
decl_stmt|;
name|struct
name|commit
modifier|*
name|merged_common_ancestors
decl_stmt|;
name|struct
name|tree
modifier|*
name|mrtree
init|=
name|mrtree
decl_stmt|;
name|int
name|clean
decl_stmt|;
if|if
condition|(
name|show
argument_list|(
name|o
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"Merging:"
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|o
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|output_commit_title
argument_list|(
name|o
argument_list|,
name|h2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ca
condition|)
block|{
name|ca
operator|=
name|get_merge_bases
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ca
operator|=
name|reverse_commit_list
argument_list|(
name|ca
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show
argument_list|(
name|o
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|output
argument_list|(
name|o
argument_list|,
literal|5
argument_list|,
literal|"found %u common ancestor(s):"
argument_list|,
name|commit_list_count
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
name|output_commit_title
argument_list|(
name|o
argument_list|,
name|iter
operator|->
name|item
argument_list|)
expr_stmt|;
block|}
name|merged_common_ancestors
operator|=
name|pop_commit
argument_list|(
operator|&
name|ca
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_common_ancestors
operator|==
name|NULL
condition|)
block|{
comment|/* if there is no common ancestor, make an empty tree */
name|struct
name|tree
modifier|*
name|tree
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|tree
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|tree
operator|->
name|object
operator|.
name|type
operator|=
name|OBJ_TREE
expr_stmt|;
name|pretend_sha1_file
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|OBJ_TREE
argument_list|,
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|merged_common_ancestors
operator|=
name|make_virtual_commit
argument_list|(
name|tree
argument_list|,
literal|"ancestor"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|iter
operator|=
name|ca
init|;
name|iter
condition|;
name|iter
operator|=
name|iter
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|saved_b1
decl_stmt|,
modifier|*
name|saved_b2
decl_stmt|;
name|o
operator|->
name|call_depth
operator|++
expr_stmt|;
comment|/* 		 * When the merge fails, the result contains files 		 * with conflict markers. The cleanness flag is 		 * ignored, it was never actually used, as result of 		 * merge_trees has always overwritten it: the committed 		 * "conflicts" were already resolved. 		 */
name|discard_cache
argument_list|()
expr_stmt|;
name|saved_b1
operator|=
name|o
operator|->
name|branch1
expr_stmt|;
name|saved_b2
operator|=
name|o
operator|->
name|branch2
expr_stmt|;
name|o
operator|->
name|branch1
operator|=
literal|"Temporary merge branch 1"
expr_stmt|;
name|o
operator|->
name|branch2
operator|=
literal|"Temporary merge branch 2"
expr_stmt|;
name|merge_recursive
argument_list|(
name|o
argument_list|,
name|merged_common_ancestors
argument_list|,
name|iter
operator|->
name|item
argument_list|,
name|NULL
argument_list|,
operator|&
name|merged_common_ancestors
argument_list|)
expr_stmt|;
name|o
operator|->
name|branch1
operator|=
name|saved_b1
expr_stmt|;
name|o
operator|->
name|branch2
operator|=
name|saved_b2
expr_stmt|;
name|o
operator|->
name|call_depth
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|merged_common_ancestors
condition|)
name|die
argument_list|(
literal|"merge returned no commit"
argument_list|)
expr_stmt|;
block|}
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|call_depth
condition|)
name|read_cache
argument_list|()
expr_stmt|;
name|clean
operator|=
name|merge_trees
argument_list|(
name|o
argument_list|,
name|h1
operator|->
name|tree
argument_list|,
name|h2
operator|->
name|tree
argument_list|,
name|merged_common_ancestors
operator|->
name|tree
argument_list|,
operator|&
name|mrtree
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|call_depth
condition|)
block|{
operator|*
name|result
operator|=
name|make_virtual_commit
argument_list|(
name|mrtree
argument_list|,
literal|"merged tree"
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h1
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|h2
argument_list|,
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|parents
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
name|flush_output
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|clean
return|;
block|}
end_function
begin_function
DECL|function|get_ref
specifier|static
name|struct
name|commit
modifier|*
name|get_ref
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|object
decl_stmt|;
name|object
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJ_TREE
condition|)
return|return
name|make_virtual_commit
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|object
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|parse_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
return|;
block|}
end_function
begin_function
DECL|function|merge_recursive_generic
name|int
name|merge_recursive_generic
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|merge
parameter_list|,
name|int
name|num_base_list
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|base_list
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|clean
decl_stmt|,
name|index_fd
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|head_commit
init|=
name|get_ref
argument_list|(
name|head
argument_list|,
name|o
operator|->
name|branch1
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|next_commit
init|=
name|get_ref
argument_list|(
name|merge
argument_list|,
name|o
operator|->
name|branch2
argument_list|)
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|ca
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|base_list
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_base_list
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|commit
modifier|*
name|base
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|base
operator|=
name|get_ref
argument_list|(
name|base_list
index|[
name|i
index|]
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_list
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
argument_list|(
literal|"Could not parse object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_list
index|[
name|i
index|]
argument_list|)
argument_list|)
return|;
name|commit_list_insert
argument_list|(
name|base
argument_list|,
operator|&
name|ca
argument_list|)
expr_stmt|;
block|}
block|}
name|index_fd
operator|=
name|hold_locked_index
argument_list|(
name|lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clean
operator|=
name|merge_recursive
argument_list|(
name|o
argument_list|,
name|head_commit
argument_list|,
name|next_commit
argument_list|,
name|ca
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|&&
operator|(
name|write_cache
argument_list|(
name|index_fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock
argument_list|)
operator|)
condition|)
return|return
name|error
argument_list|(
literal|"Unable to write index."
argument_list|)
return|;
return|return
name|clean
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|merge_recursive_config
specifier|static
name|int
name|merge_recursive_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|merge_options
modifier|*
name|o
init|=
name|cb
decl_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
argument_list|,
literal|"merge.verbosity"
argument_list|)
condition|)
block|{
name|o
operator|->
name|verbosity
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
argument_list|,
literal|"diff.renamelimit"
argument_list|)
condition|)
block|{
name|o
operator|->
name|diff_rename_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
argument_list|,
literal|"merge.renamelimit"
argument_list|)
condition|)
block|{
name|o
operator|->
name|merge_rename_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_xmerge_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init_merge_options
name|void
name|init_merge_options
parameter_list|(
name|struct
name|merge_options
modifier|*
name|o
parameter_list|)
block|{
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|merge_options
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|verbosity
operator|=
literal|2
expr_stmt|;
name|o
operator|->
name|buffer_output
operator|=
literal|1
expr_stmt|;
name|o
operator|->
name|diff_rename_limit
operator|=
operator|-
literal|1
expr_stmt|;
name|o
operator|->
name|merge_rename_limit
operator|=
operator|-
literal|1
expr_stmt|;
name|git_config
argument_list|(
name|merge_recursive_config
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GIT_MERGE_VERBOSITY"
argument_list|)
condition|)
name|o
operator|->
name|verbosity
operator|=
name|strtol
argument_list|(
name|getenv
argument_list|(
literal|"GIT_MERGE_VERBOSITY"
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|5
condition|)
name|o
operator|->
name|buffer_output
operator|=
literal|0
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|o
operator|->
name|obuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|o
operator|->
name|current_file_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|current_file_set
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|o
operator|->
name|current_directory_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|current_directory_set
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
block|}
end_function
end_unit
