begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_decl_stmt
DECL|variable|alias_key
specifier|static
specifier|const
name|char
modifier|*
name|alias_key
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|alias_val
specifier|static
name|char
modifier|*
name|alias_val
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|alias_lookup_cb
specifier|static
name|int
name|alias_lookup_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|k
argument_list|,
literal|"alias."
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|k
operator|+
literal|6
argument_list|,
name|alias_key
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|v
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|k
argument_list|)
return|;
name|alias_val
operator|=
name|xstrdup
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|alias_lookup
name|char
modifier|*
name|alias_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|alias
parameter_list|)
block|{
name|alias_key
operator|=
name|alias
expr_stmt|;
name|alias_val
operator|=
name|NULL
expr_stmt|;
name|git_config
argument_list|(
name|alias_lookup_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|alias_val
return|;
block|}
end_function
begin_define
DECL|macro|SPLIT_CMDLINE_BAD_ENDING
define|#
directive|define
name|SPLIT_CMDLINE_BAD_ENDING
value|1
end_define
begin_define
DECL|macro|SPLIT_CMDLINE_UNCLOSED_QUOTE
define|#
directive|define
name|SPLIT_CMDLINE_UNCLOSED_QUOTE
value|2
end_define
begin_decl_stmt
DECL|variable|split_cmdline_errors
specifier|static
specifier|const
name|char
modifier|*
name|split_cmdline_errors
index|[]
init|=
block|{
literal|"cmdline ends with \\"
block|,
literal|"unclosed quote"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|split_cmdline
name|int
name|split_cmdline
parameter_list|(
name|char
modifier|*
name|cmdline
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|16
decl_stmt|;
name|char
name|quoted
init|=
literal|0
decl_stmt|;
operator|*
name|argv
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
comment|/* split alias_string */
operator|(
operator|*
name|argv
operator|)
index|[
name|count
operator|++
index|]
operator|=
name|cmdline
expr_stmt|;
for|for
control|(
name|src
operator|=
name|dst
operator|=
literal|0
init|;
name|cmdline
index|[
name|src
index|]
condition|;
control|)
block|{
name|char
name|c
init|=
name|cmdline
index|[
name|src
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|quoted
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cmdline
index|[
name|dst
operator|++
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cmdline
index|[
operator|++
name|src
index|]
operator|&&
name|isspace
argument_list|(
name|cmdline
index|[
name|src
index|]
argument_list|)
condition|)
empty_stmt|;
comment|/* skip */
name|ALLOC_GROW
argument_list|(
operator|*
name|argv
argument_list|,
name|count
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argv
operator|)
index|[
name|count
operator|++
index|]
operator|=
name|cmdline
operator|+
name|dst
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quoted
operator|&&
operator|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
operator|)
condition|)
block|{
name|quoted
operator|=
name|c
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|quoted
condition|)
block|{
name|quoted
operator|=
literal|0
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|quoted
operator|!=
literal|'\''
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|c
operator|=
name|cmdline
index|[
name|src
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|free
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
name|SPLIT_CMDLINE_BAD_ENDING
return|;
block|}
block|}
name|cmdline
index|[
name|dst
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|src
operator|++
expr_stmt|;
block|}
block|}
name|cmdline
index|[
name|dst
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
block|{
name|free
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
name|SPLIT_CMDLINE_UNCLOSED_QUOTE
return|;
block|}
name|ALLOC_GROW
argument_list|(
operator|*
name|argv
argument_list|,
name|count
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argv
operator|)
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|split_cmdline_strerror
specifier|const
name|char
modifier|*
name|split_cmdline_strerror
parameter_list|(
name|int
name|split_cmdline_errno
parameter_list|)
block|{
return|return
name|split_cmdline_errors
index|[
operator|-
name|split_cmdline_errno
operator|-
literal|1
index|]
return|;
block|}
end_function
end_unit
