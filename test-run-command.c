begin_unit
begin_comment
comment|/*  * test-run-command.c: test run command API.  *  * (C) 2009 Ilari Liusvaara<ilari.liusvaara@elisanet.fi>  *  * This code is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  */
end_comment
begin_include
include|#
directive|include
file|"git-compat-util.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"argv-array.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_decl_stmt
DECL|variable|number_callbacks
specifier|static
name|int
name|number_callbacks
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parallel_next
specifier|static
name|int
name|parallel_next
parameter_list|(
name|struct
name|child_process
modifier|*
name|cp
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
modifier|*
name|task_cb
parameter_list|)
block|{
name|struct
name|child_process
modifier|*
name|d
init|=
name|cb
decl_stmt|;
if|if
condition|(
name|number_callbacks
operator|>=
literal|4
condition|)
return|return
literal|0
return|;
name|argv_array_pushv
argument_list|(
operator|&
name|cp
operator|->
name|args
argument_list|,
name|d
operator|->
name|argv
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|err
argument_list|,
literal|"preloaded output of a child\n"
argument_list|)
expr_stmt|;
name|number_callbacks
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|no_job
specifier|static
name|int
name|no_job
parameter_list|(
name|struct
name|child_process
modifier|*
name|cp
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
modifier|*
name|task_cb
parameter_list|)
block|{
name|strbuf_addf
argument_list|(
name|err
argument_list|,
literal|"no further jobs available\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|task_finished
specifier|static
name|int
name|task_finished
parameter_list|(
name|int
name|result
parameter_list|,
name|struct
name|child_process
modifier|*
name|cp
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|pp_cb
parameter_list|,
name|void
modifier|*
name|pp_task_cb
parameter_list|)
block|{
name|strbuf_addf
argument_list|(
name|err
argument_list|,
literal|"asking for a quick stop\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|child_process
name|proc
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|int
name|jobs
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
return|return
literal|1
return|;
name|proc
operator|.
name|argv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|argv
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"start-command-ENOENT"
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|proc
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FAIL %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"run-command"
argument_list|)
condition|)
name|exit
argument_list|(
name|run_command
argument_list|(
operator|&
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|jobs
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|proc
operator|.
name|argv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|argv
operator|+
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"run-command-parallel"
argument_list|)
condition|)
name|exit
argument_list|(
name|run_processes_parallel
argument_list|(
name|jobs
argument_list|,
name|parallel_next
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"run-command-abort"
argument_list|)
condition|)
name|exit
argument_list|(
name|run_processes_parallel
argument_list|(
name|jobs
argument_list|,
name|parallel_next
argument_list|,
name|NULL
argument_list|,
name|task_finished
argument_list|,
operator|&
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"run-command-no-jobs"
argument_list|)
condition|)
name|exit
argument_list|(
name|run_processes_parallel
argument_list|(
name|jobs
argument_list|,
name|no_job
argument_list|,
name|NULL
argument_list|,
name|task_finished
argument_list|,
operator|&
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"check usage\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
end_unit
