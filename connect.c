begin_unit
begin_include
include|#
directive|include
file|"git-compat-util.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_decl_stmt
DECL|variable|server_capabilities
specifier|static
name|char
modifier|*
name|server_capabilities
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|check_ref
specifier|static
name|int
name|check_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flags
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<
literal|5
operator|||
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Skip the "refs/" part */
name|name
operator|+=
literal|5
expr_stmt|;
name|len
operator|-=
literal|5
expr_stmt|;
comment|/* REF_NORMAL means that we don't want the magic fake tag refs */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_NORMAL
operator|)
operator|&&
name|check_ref_format
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* REF_HEADS means that we want regular branch heads */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_HEADS
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REF_TAGS means that we want tags */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_TAGS
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* All type bits clear means that we are ok with anything */
return|return
operator|!
operator|(
name|flags
operator|&
operator|~
name|REF_NORMAL
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read all the refs from the other end  */
end_comment
begin_function
DECL|function|get_remote_heads
name|struct
name|ref
modifier|*
modifier|*
name|get_remote_heads
parameter_list|(
name|int
name|in
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|nr_match
parameter_list|,
name|char
modifier|*
modifier|*
name|match
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|unsigned
name|char
name|old_sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|,
name|name_len
decl_stmt|;
name|len
operator|=
name|packet_read_line
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
if|if
condition|(
name|buffer
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buffer
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|42
operator|||
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|old_sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"protocol error: expected sha/ref, got '%s'"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|name
operator|=
name|buffer
operator|+
literal|41
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|name_len
operator|+
literal|41
condition|)
block|{
if|if
condition|(
name|server_capabilities
condition|)
name|free
argument_list|(
name|server_capabilities
argument_list|)
expr_stmt|;
name|server_capabilities
operator|=
name|xstrdup
argument_list|(
name|name
operator|+
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_ref
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nr_match
operator|&&
operator|!
name|path_match
argument_list|(
name|name
argument_list|,
name|nr_match
argument_list|,
name|match
argument_list|)
condition|)
continue|continue;
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
operator|+
name|len
operator|-
literal|40
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|buffer
operator|+
literal|41
argument_list|,
name|len
operator|-
literal|40
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|ref
expr_stmt|;
name|list
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|server_supports
name|int
name|server_supports
parameter_list|(
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
block|{
return|return
name|server_capabilities
operator|&&
name|strstr
argument_list|(
name|server_capabilities
argument_list|,
name|feature
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|get_ack
name|int
name|get_ack
parameter_list|(
name|int
name|fd
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|len
init|=
name|packet_read_line
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|die
argument_list|(
literal|"git-fetch-pack: expected ACK/NAK, got EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"NAK"
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"ACK "
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|4
argument_list|,
name|result_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"continue"
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
block|}
name|die
argument_list|(
literal|"git-fetch_pack: expected ACK/NAK, got '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|path_match
name|int
name|path_match
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|nr
parameter_list|,
name|char
modifier|*
modifier|*
name|match
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|s
init|=
name|match
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|len
operator|>
name|pathlen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|path
operator|+
name|pathlen
operator|-
name|len
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pathlen
operator|>
name|len
operator|&&
name|path
index|[
name|pathlen
operator|-
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|refspec
struct|struct
name|refspec
block|{
DECL|member|src
name|char
modifier|*
name|src
decl_stmt|;
DECL|member|dst
name|char
modifier|*
name|dst
decl_stmt|;
DECL|member|force
name|char
name|force
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * A:B means fast forward remote B with local A.  * +A:B means overwrite remote B with local A.  * +A is a shorthand for +A:A.  * A is a shorthand for A:A.  * :B means delete remote B.  */
end_comment
begin_function
DECL|function|parse_ref_spec
specifier|static
name|struct
name|refspec
modifier|*
name|parse_ref_spec
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
name|char
modifier|*
modifier|*
name|refspec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|refspec
modifier|*
name|rs
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|,
operator|(
name|nr_refspec
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|sp
operator|=
name|refspec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'+'
condition|)
block|{
name|rs
index|[
name|i
index|]
operator|.
name|force
operator|=
literal|1
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
name|ep
operator|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
condition|)
block|{
name|dp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|dp
operator|=
name|sp
expr_stmt|;
name|rs
index|[
name|i
index|]
operator|.
name|src
operator|=
name|sp
expr_stmt|;
name|rs
index|[
name|i
index|]
operator|.
name|dst
operator|=
name|dp
expr_stmt|;
block|}
name|rs
index|[
name|nr_refspec
index|]
operator|.
name|src
operator|=
name|rs
index|[
name|nr_refspec
index|]
operator|.
name|dst
operator|=
name|NULL
expr_stmt|;
return|return
name|rs
return|;
block|}
end_function
begin_function
DECL|function|count_refspec_match
specifier|static
name|int
name|count_refspec_match
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|matched_ref
parameter_list|)
block|{
name|int
name|patlen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched_weak
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched
init|=
name|NULL
decl_stmt|;
name|int
name|weak_match
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
for|for
control|(
name|weak_match
operator|=
name|match
operator|=
literal|0
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|refs
operator|->
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|weak_match
decl_stmt|;
if|if
condition|(
name|namelen
operator|<
name|patlen
operator|||
name|memcmp
argument_list|(
name|name
operator|+
name|namelen
operator|-
name|patlen
argument_list|,
name|pattern
argument_list|,
name|patlen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|name
index|[
name|namelen
operator|-
name|patlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
comment|/* A match is "weak" if it is with refs outside 		 * heads or tags, and did not specify the pattern 		 * in full (e.g. "refs/remotes/origin/master") or at 		 * least from the toplevel (e.g. "remotes/origin/master"); 		 * otherwise "git push $URL master" would result in 		 * ambiguity between remotes/origin/master and heads/master 		 * at the remote site. 		 */
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|patlen
operator|!=
name|namelen
operator|-
literal|5
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
comment|/* We want to catch the case where only weak 			 * matches are found and there are multiple 			 * matches, and where more than one strong 			 * matches are found, as ambiguous.  One 			 * strong match with zero or more weak matches 			 * are acceptable as a unique match. 			 */
name|matched_weak
operator|=
name|refs
expr_stmt|;
name|weak_match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|matched
operator|=
name|refs
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
operator|*
name|matched_ref
operator|=
name|matched_weak
expr_stmt|;
return|return
name|weak_match
return|;
block|}
else|else
block|{
operator|*
name|matched_ref
operator|=
name|matched
expr_stmt|;
return|return
name|match
return|;
block|}
block|}
end_function
begin_function
DECL|function|link_dst_tail
specifier|static
name|void
name|link_dst_tail
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
operator|*
operator|*
name|tail
operator|=
name|ref
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
operator|*
operator|*
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|try_explicit_object_name
specifier|static
name|struct
name|ref
modifier|*
name|try_explicit_object_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
block|{
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"(delete)"
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|match_explicit_refs
specifier|static
name|int
name|match_explicit_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|struct
name|refspec
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|errs
decl_stmt|;
for|for
control|(
name|i
operator|=
name|errs
operator|=
literal|0
init|;
name|rs
index|[
name|i
index|]
operator|.
name|src
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ref
modifier|*
name|matched_src
decl_stmt|,
modifier|*
name|matched_dst
decl_stmt|;
name|matched_src
operator|=
name|matched_dst
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|src
argument_list|,
operator|&
name|matched_src
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
comment|/* The source could be in the get_sha1() format 			 * not a reference name.  :refs/other is a 			 * way to delete 'other' ref at the remote end. 			 */
name|matched_src
operator|=
name|try_explicit_object_name
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched_src
condition|)
break|break;
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"src refspec %s does not match any."
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"src refspec %s matches more than one."
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|,
name|dst
argument_list|,
operator|&
name|matched_dst
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|)
operator|+
literal|1
decl_stmt|;
name|matched_dst
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|matched_dst
operator|->
name|name
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|link_dst_tail
argument_list|(
name|matched_dst
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|)
operator|&&
name|matched_src
condition|)
block|{
comment|/* pushing "master:master" when 				 * remote does not have master yet. 				 */
name|int
name|len
init|=
name|strlen
argument_list|(
name|matched_src
operator|->
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|matched_dst
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|matched_dst
operator|->
name|name
argument_list|,
name|matched_src
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|link_dst_tail
argument_list|(
name|matched_dst
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"dst refspec %s does not match any "
literal|"existing ref on the remote and does "
literal|"not start with refs/."
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"dst refspec %s matches more than one."
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errs
condition|)
continue|continue;
if|if
condition|(
name|matched_dst
operator|->
name|peer_ref
condition|)
block|{
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"dst ref %s receives from more than one src."
argument_list|,
name|matched_dst
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matched_dst
operator|->
name|peer_ref
operator|=
name|matched_src
expr_stmt|;
name|matched_dst
operator|->
name|force
operator|=
name|rs
index|[
name|i
index|]
operator|.
name|force
expr_stmt|;
block|}
block|}
return|return
operator|-
name|errs
return|;
block|}
end_function
begin_function
DECL|function|find_ref_by_name
specifier|static
name|struct
name|ref
modifier|*
name|find_ref_by_name
parameter_list|(
name|struct
name|ref
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|list
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|match_refs
name|int
name|match_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|int
name|nr_refspec
parameter_list|,
name|char
modifier|*
modifier|*
name|refspec
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|struct
name|refspec
modifier|*
name|rs
init|=
name|parse_ref_spec
argument_list|(
name|nr_refspec
argument_list|,
name|refspec
argument_list|)
decl_stmt|;
if|if
condition|(
name|nr_refspec
condition|)
return|return
name|match_explicit_refs
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|dst_tail
argument_list|,
name|rs
argument_list|)
return|;
comment|/* pick the remainder */
for|for
control|(
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|dst_peer
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|peer_ref
condition|)
continue|continue;
name|dst_peer
operator|=
name|find_ref_by_name
argument_list|(
name|dst
argument_list|,
name|src
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst_peer
operator|&&
name|dst_peer
operator|->
name|peer_ref
operator|)
operator|||
operator|(
operator|!
name|dst_peer
operator|&&
operator|!
name|all
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dst_peer
condition|)
block|{
comment|/* Create a new one and link it */
name|int
name|len
init|=
name|strlen
argument_list|(
name|src
operator|->
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|dst_peer
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst_peer
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst_peer
operator|->
name|name
argument_list|,
name|src
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_peer
operator|->
name|new_sha1
argument_list|,
name|src
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|link_dst_tail
argument_list|(
name|dst_peer
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
block|}
name|dst_peer
operator|->
name|peer_ref
operator|=
name|src
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_enum
DECL|enum|protocol
enum|enum
name|protocol
block|{
DECL|enumerator|PROTO_LOCAL
name|PROTO_LOCAL
init|=
literal|1
block|,
DECL|enumerator|PROTO_SSH
name|PROTO_SSH
block|,
DECL|enumerator|PROTO_GIT
name|PROTO_GIT
block|, }
enum|;
end_enum
begin_function
DECL|function|get_protocol
specifier|static
name|enum
name|protocol
name|get_protocol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git"
argument_list|)
condition|)
return|return
name|PROTO_GIT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git+ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh+git"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
name|die
argument_list|(
literal|"I don't handle protocol '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|STR_
define|#
directive|define
name|STR_
parameter_list|(
name|s
parameter_list|)
value|# s
end_define
begin_define
DECL|macro|STR
define|#
directive|define
name|STR
parameter_list|(
name|s
parameter_list|)
value|STR_(s)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|NO_IPV6
end_ifndef
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|)
block|{
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|,
name|saved_errno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai0
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|int
name|gai
decl_stmt|;
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|gai
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|gai
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (%s)"
argument_list|,
name|host
argument_list|,
name|gai_strerror
argument_list|(
name|gai
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ai0
operator|=
name|ai
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|ai0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect a socket (%s)"
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|)
block|{
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|,
name|saved_errno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|unsigned
name|int
name|nport
decl_stmt|;
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
name|he
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (%s)"
argument_list|,
name|host
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
name|nport
operator|=
name|strtoul
argument_list|(
name|port
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|port
operator|||
operator|*
name|ep
condition|)
block|{
comment|/* Not numeric */
name|struct
name|servent
modifier|*
name|se
init|=
name|getservbyname
argument_list|(
name|port
argument_list|,
literal|"tcp"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|se
condition|)
name|die
argument_list|(
literal|"Unknown port %s\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|nport
operator|=
name|se
operator|->
name|s_port
expr_stmt|;
block|}
for|for
control|(
name|ap
operator|=
name|he
operator|->
name|h_addr_list
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
name|sockfd
operator|=
name|socket
argument_list|(
name|he
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
continue|continue;
block|}
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sin_family
operator|=
name|he
operator|->
name|h_addrtype
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|nport
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sa
operator|.
name|sin_addr
argument_list|,
operator|*
name|ap
argument_list|,
name|he
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect a socket (%s)"
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_function
DECL|function|git_tcp_connect
specifier|static
name|void
name|git_tcp_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|)
block|{
name|int
name|sockfd
init|=
name|git_tcp_connect_sock
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|sockfd
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|dup
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|git_proxy_command
specifier|static
name|char
modifier|*
name|git_proxy_command
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rhost_name
specifier|static
specifier|const
name|char
modifier|*
name|rhost_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rhost_len
specifier|static
name|int
name|rhost_len
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_proxy_command_options
specifier|static
name|int
name|git_proxy_command_options
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.gitproxy"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|for_pos
decl_stmt|;
name|int
name|matchlen
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hostlen
decl_stmt|;
if|if
condition|(
name|git_proxy_command
condition|)
return|return
literal|0
return|;
comment|/* [core] 		 * ;# matches www.kernel.org as well 		 * gitproxy = netcatter-1 for kernel.org 		 * gitproxy = netcatter-2 for sample.xz 		 * gitproxy = netcatter-default 		 */
name|for_pos
operator|=
name|strstr
argument_list|(
name|value
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_pos
condition|)
comment|/* matches everybody */
name|matchlen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|hostlen
operator|=
name|strlen
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhost_len
operator|<
name|hostlen
condition|)
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|,
name|rhost_name
operator|+
name|rhost_len
operator|-
name|hostlen
argument_list|,
name|hostlen
argument_list|)
operator|&&
operator|(
operator|(
name|rhost_len
operator|==
name|hostlen
operator|)
operator|||
name|rhost_name
index|[
name|rhost_len
operator|-
name|hostlen
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|matchlen
operator|=
name|for_pos
operator|-
name|value
expr_stmt|;
else|else
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|matchlen
condition|)
block|{
comment|/* core.gitproxy = none for kernel.org */
if|if
condition|(
name|matchlen
operator|==
literal|4
operator|&&
operator|!
name|memcmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|,
literal|4
argument_list|)
condition|)
name|matchlen
operator|=
literal|0
expr_stmt|;
name|git_proxy_command
operator|=
name|xmalloc
argument_list|(
name|matchlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|git_proxy_command
argument_list|,
name|value
argument_list|,
name|matchlen
argument_list|)
expr_stmt|;
name|git_proxy_command
index|[
name|matchlen
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_use_proxy
specifier|static
name|int
name|git_use_proxy
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|)
block|{
name|rhost_name
operator|=
name|host
expr_stmt|;
name|rhost_len
operator|=
name|strlen
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|git_proxy_command
operator|=
name|getenv
argument_list|(
literal|"GIT_PROXY_COMMAND"
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_proxy_command_options
argument_list|)
expr_stmt|;
name|rhost_name
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|git_proxy_command
operator|&&
operator|*
name|git_proxy_command
operator|)
return|;
block|}
end_function
begin_function
DECL|function|git_proxy_connect
specifier|static
name|void
name|git_proxy_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|child_process
name|proxy
decl_stmt|;
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
name|git_proxy_command
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|host
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|port
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|proxy
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|proxy
argument_list|)
argument_list|)
expr_stmt|;
name|proxy
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|proxy
operator|.
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|proxy
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|proxy
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot start proxy %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|proxy
operator|.
name|out
expr_stmt|;
comment|/* read from proxy stdout */
name|fd
index|[
literal|1
index|]
operator|=
name|proxy
operator|.
name|in
expr_stmt|;
comment|/* write to proxy stdin */
block|}
end_function
begin_define
DECL|macro|MAX_CMD_LEN
define|#
directive|define
name|MAX_CMD_LEN
value|1024
end_define
begin_comment
comment|/*  * This returns 0 if the transport protocol does not need fork(2),  * or a process id if it does.  Once done, finish the connection  * with finish_connect() with the value returned from this function  * (it is safe to call finish_connect() with 0 to support the former  * case).  *  * Does not return a negative value on error; it just dies.  */
end_comment
begin_function
DECL|function|git_connect
name|pid_t
name|git_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|prog
parameter_list|)
block|{
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|path
init|=
name|url
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|pipefd
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|enum
name|protocol
name|protocol
init|=
name|PROTO_LOCAL
decl_stmt|;
name|int
name|free_path
init|=
literal|0
decl_stmt|;
comment|/* Without this we cannot rely on waitpid() to tell 	 * what happened to our children. 	 */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|host
operator|=
name|strstr
argument_list|(
name|url
argument_list|,
literal|"://"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
block|{
operator|*
name|host
operator|=
literal|'\0'
expr_stmt|;
name|protocol
operator|=
name|get_protocol
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|host
operator|+=
literal|3
expr_stmt|;
name|c
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|url
expr_stmt|;
name|c
operator|=
literal|':'
expr_stmt|;
block|}
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|path
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|path
condition|)
block|{
name|protocol
operator|=
name|PROTO_SSH
expr_stmt|;
operator|*
name|path
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|path
operator|=
name|host
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|path
operator|||
operator|!
operator|*
name|path
condition|)
name|die
argument_list|(
literal|"No path specified. See 'man git-pull' for valid url syntax"
argument_list|)
expr_stmt|;
comment|/* 	 * null-terminate hostname and point path to ~ for URL's like this: 	 *    ssh://host.xz/~user/repo 	 */
if|if
condition|(
name|protocol
operator|!=
name|PROTO_LOCAL
operator|&&
name|host
operator|!=
name|url
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|path
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
name|path
operator|++
expr_stmt|;
else|else
block|{
name|path
operator|=
name|xstrdup
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|free_path
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|protocol
operator|==
name|PROTO_GIT
condition|)
block|{
comment|/* These underlying connection commands die() if they 		 * cannot connect. 		 */
name|char
modifier|*
name|target_host
init|=
name|xstrdup
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|git_use_proxy
argument_list|(
name|host
argument_list|)
condition|)
name|git_proxy_connect
argument_list|(
name|fd
argument_list|,
name|host
argument_list|)
expr_stmt|;
else|else
name|git_tcp_connect
argument_list|(
name|fd
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/* 		 * Separate original protocol components prog and path 		 * from extended components with a NUL byte. 		 */
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"%s %s%chost=%s%c"
argument_list|,
name|prog
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|target_host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|pipe
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to create pipe pair for communication"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to fork"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pid
condition|)
block|{
name|char
name|command
index|[
name|MAX_CMD_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|posn
init|=
name|command
decl_stmt|;
name|int
name|size
init|=
name|MAX_CMD_LEN
decl_stmt|;
name|int
name|of
init|=
literal|0
decl_stmt|;
name|of
operator||=
name|add_to_string
argument_list|(
operator|&
name|posn
argument_list|,
operator|&
name|size
argument_list|,
name|prog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|of
operator||=
name|add_to_string
argument_list|(
operator|&
name|posn
argument_list|,
operator|&
name|size
argument_list|,
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|of
operator||=
name|add_to_string
argument_list|(
operator|&
name|posn
argument_list|,
operator|&
name|size
argument_list|,
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|of
condition|)
name|die
argument_list|(
literal|"command line too long"
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pipefd
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pipefd
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PROTO_SSH
condition|)
block|{
specifier|const
name|char
modifier|*
name|ssh
decl_stmt|,
modifier|*
name|ssh_basename
decl_stmt|;
name|ssh
operator|=
name|getenv
argument_list|(
literal|"GIT_SSH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssh
condition|)
name|ssh
operator|=
literal|"ssh"
expr_stmt|;
name|ssh_basename
operator|=
name|strrchr
argument_list|(
name|ssh
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssh_basename
condition|)
name|ssh_basename
operator|=
name|ssh
expr_stmt|;
else|else
name|ssh_basename
operator|++
expr_stmt|;
name|execlp
argument_list|(
name|ssh
argument_list|,
name|ssh_basename
argument_list|,
name|host
argument_list|,
name|command
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsetenv
argument_list|(
name|ALTERNATE_DB_ENVIRONMENT
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
name|DB_ENVIRONMENT
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
name|GIT_DIR_ENVIRONMENT
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
name|GRAFT_ENVIRONMENT
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
name|INDEX_ENVIRONMENT
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|command
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|die
argument_list|(
literal|"exec failed"
argument_list|)
expr_stmt|;
block|}
name|fd
index|[
literal|0
index|]
operator|=
name|pipefd
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|pipefd
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function
begin_function
DECL|function|finish_connect
name|int
name|finish_connect
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
