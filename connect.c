begin_unit
begin_include
include|#
directive|include
file|"git-compat-util.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"url.h"
end_include
begin_decl_stmt
DECL|variable|server_capabilities
specifier|static
name|char
modifier|*
name|server_capabilities
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|check_ref
specifier|static
name|int
name|check_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flags
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<
literal|5
operator|||
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Skip the "refs/" part */
name|name
operator|+=
literal|5
expr_stmt|;
name|len
operator|-=
literal|5
expr_stmt|;
comment|/* REF_NORMAL means that we don't want the magic fake tag refs */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_NORMAL
operator|)
operator|&&
name|check_refname_format
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* REF_HEADS means that we want regular branch heads */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_HEADS
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REF_TAGS means that we want tags */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_TAGS
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* All type bits clear means that we are ok with anything */
return|return
operator|!
operator|(
name|flags
operator|&
operator|~
name|REF_NORMAL
operator|)
return|;
block|}
end_function
begin_function
DECL|function|check_ref_type
name|int
name|check_ref_type
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|check_ref
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|ref
operator|->
name|name
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|add_extra_have
specifier|static
name|void
name|add_extra_have
parameter_list|(
name|struct
name|extra_have_objects
modifier|*
name|extra
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|extra
operator|->
name|array
argument_list|,
name|extra
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|extra
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
operator|&
operator|(
name|extra
operator|->
name|array
index|[
name|extra
operator|->
name|nr
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|extra
operator|->
name|nr
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|die_initial_contact
specifier|static
name|void
name|die_initial_contact
parameter_list|(
name|int
name|got_at_least_one_head
parameter_list|)
block|{
if|if
condition|(
name|got_at_least_one_head
condition|)
name|die
argument_list|(
literal|"The remote end hung up upon initial contact"
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Could not read from remote repository.\n\n"
literal|"Please make sure you have the correct access rights\n"
literal|"and the repository exists."
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Read all the refs from the other end  */
end_comment
begin_function
DECL|function|get_remote_heads
name|struct
name|ref
modifier|*
modifier|*
name|get_remote_heads
parameter_list|(
name|int
name|in
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|struct
name|extra_have_objects
modifier|*
name|extra_have
parameter_list|)
block|{
name|int
name|got_at_least_one_head
init|=
literal|0
decl_stmt|;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|unsigned
name|char
name|old_sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|,
name|name_len
decl_stmt|;
name|len
operator|=
name|packet_read
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|die_initial_contact
argument_list|(
name|got_at_least_one_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
if|if
condition|(
name|buffer
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buffer
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"ERR "
argument_list|)
condition|)
name|die
argument_list|(
literal|"remote error: %s"
argument_list|,
name|buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|42
operator|||
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|old_sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"protocol error: expected sha/ref, got '%s'"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|name
operator|=
name|buffer
operator|+
literal|41
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|name_len
operator|+
literal|41
condition|)
block|{
name|free
argument_list|(
name|server_capabilities
argument_list|)
expr_stmt|;
name|server_capabilities
operator|=
name|xstrdup
argument_list|(
name|name
operator|+
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra_have
operator|&&
name|name_len
operator|==
literal|5
operator|&&
operator|!
name|memcmp
argument_list|(
literal|".have"
argument_list|,
name|name
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|add_extra_have
argument_list|(
name|extra_have
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|check_ref
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|buffer
operator|+
literal|41
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|ref
expr_stmt|;
name|list
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
name|got_at_least_one_head
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|parse_feature_value
specifier|const
name|char
modifier|*
name|parse_feature_value
parameter_list|(
specifier|const
name|char
modifier|*
name|feature_list
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|feature_list
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|feature
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|feature_list
condition|)
block|{
specifier|const
name|char
modifier|*
name|found
init|=
name|strstr
argument_list|(
name|feature_list
argument_list|,
name|feature
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|feature_list
operator|==
name|found
operator|||
name|isspace
argument_list|(
name|found
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|found
operator|+
name|len
decl_stmt|;
comment|/* feature with no value (e.g., "thin-pack") */
if|if
condition|(
operator|!
operator|*
name|value
operator|||
name|isspace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* feature with a value (e.g., "agent=git/1.2.3") */
elseif|else
if|if
condition|(
operator|*
name|value
operator|==
literal|'='
condition|)
block|{
name|value
operator|++
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|strcspn
argument_list|(
name|value
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* 			 * otherwise we matched a substring of another feature; 			 * keep looking 			 */
block|}
name|feature_list
operator|=
name|found
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|parse_feature_request
name|int
name|parse_feature_request
parameter_list|(
specifier|const
name|char
modifier|*
name|feature_list
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
block|{
return|return
operator|!
operator|!
name|parse_feature_value
argument_list|(
name|feature_list
argument_list|,
name|feature
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|server_feature_value
specifier|const
name|char
modifier|*
name|server_feature_value
parameter_list|(
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
return|return
name|parse_feature_value
argument_list|(
name|server_capabilities
argument_list|,
name|feature
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|server_supports
name|int
name|server_supports
parameter_list|(
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
block|{
return|return
operator|!
operator|!
name|server_feature_value
argument_list|(
name|feature
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_enum
DECL|enum|protocol
enum|enum
name|protocol
block|{
DECL|enumerator|PROTO_LOCAL
name|PROTO_LOCAL
init|=
literal|1
block|,
DECL|enumerator|PROTO_SSH
name|PROTO_SSH
block|,
DECL|enumerator|PROTO_GIT
name|PROTO_GIT
block|}
enum|;
end_enum
begin_function
DECL|function|get_protocol
specifier|static
name|enum
name|protocol
name|get_protocol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git"
argument_list|)
condition|)
return|return
name|PROTO_GIT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git+ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh+git"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file"
argument_list|)
condition|)
return|return
name|PROTO_LOCAL
return|;
name|die
argument_list|(
literal|"I don't handle protocol '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|STR_
define|#
directive|define
name|STR_
parameter_list|(
name|s
parameter_list|)
value|# s
end_define
begin_define
DECL|macro|STR
define|#
directive|define
name|STR
parameter_list|(
name|s
parameter_list|)
value|STR_(s)
end_define
begin_function
DECL|function|get_host_and_port
specifier|static
name|void
name|get_host_and_port
parameter_list|(
name|char
modifier|*
modifier|*
name|host
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|port
parameter_list|)
block|{
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|*
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
operator|*
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
operator|(
operator|*
name|host
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
operator|*
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
operator|*
name|host
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
operator|*
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|enable_keepalive
specifier|static
name|void
name|enable_keepalive
parameter_list|(
name|int
name|sockfd
parameter_list|)
block|{
name|int
name|ka
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|&
name|ka
argument_list|,
sizeof|sizeof
argument_list|(
name|ka
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to set SO_KEEPALIVE on socket: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_IPV6
end_ifndef
begin_function
DECL|function|ai_name
specifier|static
specifier|const
name|char
modifier|*
name|ai_name
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
specifier|static
name|char
name|addr
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|addr
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|strbuf
name|error_message
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai0
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|int
name|gai
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|get_host_and_port
argument_list|(
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|port
condition|)
name|port
operator|=
literal|"<none>"
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking up %s ... "
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|gai
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|gai
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (port %s) (%s)"
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|gai_strerror
argument_list|(
name|gai
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\nConnecting to %s (port %s) ... "
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|ai0
operator|=
name|ai
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
operator|,
name|cnt
operator|++
control|)
block|{
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sockfd
operator|<
literal|0
operator|)
operator|||
operator|(
name|connect
argument_list|(
name|sockfd
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|error_message
argument_list|,
literal|"%s[%d: %s]: errno=%s\n"
argument_list|,
name|host
argument_list|,
name|cnt
argument_list|,
name|ai_name
argument_list|(
name|ai
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|sockfd
condition|)
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|ai_name
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|ai0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect to %s:\n%s"
argument_list|,
name|host
argument_list|,
name|error_message
operator|.
name|buf
argument_list|)
expr_stmt|;
name|enable_keepalive
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\n"
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|error_message
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|strbuf
name|error_message
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|unsigned
name|int
name|nport
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|get_host_and_port
argument_list|(
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking up %s ... "
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|he
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (%s)"
argument_list|,
name|host
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
name|nport
operator|=
name|strtoul
argument_list|(
name|port
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|port
operator|||
operator|*
name|ep
condition|)
block|{
comment|/* Not numeric */
name|struct
name|servent
modifier|*
name|se
init|=
name|getservbyname
argument_list|(
name|port
argument_list|,
literal|"tcp"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|se
condition|)
name|die
argument_list|(
literal|"Unknown port %s"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|nport
operator|=
name|se
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\nConnecting to %s (port %s) ... "
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|ap
operator|=
name|he
operator|->
name|h_addr_list
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|cnt
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sin_family
operator|=
name|he
operator|->
name|h_addrtype
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|nport
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sa
operator|.
name|sin_addr
argument_list|,
operator|*
name|ap
argument_list|,
name|he
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|sockfd
operator|=
name|socket
argument_list|(
name|he
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sockfd
operator|<
literal|0
operator|)
operator|||
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|error_message
argument_list|,
literal|"%s[%d: %s]: errno=%s\n"
argument_list|,
name|host
argument_list|,
name|cnt
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|sockfd
condition|)
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect to %s:\n%s"
argument_list|,
name|host
argument_list|,
name|error_message
operator|.
name|buf
argument_list|)
expr_stmt|;
name|enable_keepalive
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_function
DECL|function|git_tcp_connect
specifier|static
name|void
name|git_tcp_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|sockfd
init|=
name|git_tcp_connect_sock
argument_list|(
name|host
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|sockfd
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|dup
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|git_proxy_command
specifier|static
name|char
modifier|*
name|git_proxy_command
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_proxy_command_options
specifier|static
name|int
name|git_proxy_command_options
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.gitproxy"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|for_pos
decl_stmt|;
name|int
name|matchlen
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hostlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|rhost_name
init|=
name|cb
decl_stmt|;
name|int
name|rhost_len
init|=
name|strlen
argument_list|(
name|rhost_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|git_proxy_command
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
comment|/* [core] 		 * ;# matches www.kernel.org as well 		 * gitproxy = netcatter-1 for kernel.org 		 * gitproxy = netcatter-2 for sample.xz 		 * gitproxy = netcatter-default 		 */
name|for_pos
operator|=
name|strstr
argument_list|(
name|value
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_pos
condition|)
comment|/* matches everybody */
name|matchlen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|hostlen
operator|=
name|strlen
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhost_len
operator|<
name|hostlen
condition|)
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|,
name|rhost_name
operator|+
name|rhost_len
operator|-
name|hostlen
argument_list|,
name|hostlen
argument_list|)
operator|&&
operator|(
operator|(
name|rhost_len
operator|==
name|hostlen
operator|)
operator|||
name|rhost_name
index|[
name|rhost_len
operator|-
name|hostlen
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|matchlen
operator|=
name|for_pos
operator|-
name|value
expr_stmt|;
else|else
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|matchlen
condition|)
block|{
comment|/* core.gitproxy = none for kernel.org */
if|if
condition|(
name|matchlen
operator|==
literal|4
operator|&&
operator|!
name|memcmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|,
literal|4
argument_list|)
condition|)
name|matchlen
operator|=
literal|0
expr_stmt|;
name|git_proxy_command
operator|=
name|xmemdupz
argument_list|(
name|value
argument_list|,
name|matchlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_use_proxy
specifier|static
name|int
name|git_use_proxy
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|)
block|{
name|git_proxy_command
operator|=
name|getenv
argument_list|(
literal|"GIT_PROXY_COMMAND"
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_proxy_command_options
argument_list|,
operator|(
name|void
operator|*
operator|)
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
name|git_proxy_command
operator|&&
operator|*
name|git_proxy_command
operator|)
return|;
block|}
end_function
begin_function
DECL|function|git_proxy_connect
specifier|static
name|struct
name|child_process
modifier|*
name|git_proxy_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|child_process
modifier|*
name|proxy
decl_stmt|;
name|get_host_and_port
argument_list|(
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
name|argv
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|git_proxy_command
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|host
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|port
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|proxy
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|proxy
argument_list|)
argument_list|)
expr_stmt|;
name|proxy
operator|->
name|argv
operator|=
name|argv
expr_stmt|;
name|proxy
operator|->
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|proxy
operator|->
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
name|proxy
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot start proxy %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|proxy
operator|->
name|out
expr_stmt|;
comment|/* read from proxy stdout */
name|fd
index|[
literal|1
index|]
operator|=
name|proxy
operator|->
name|in
expr_stmt|;
comment|/* write to proxy stdin */
return|return
name|proxy
return|;
block|}
end_function
begin_define
DECL|macro|MAX_CMD_LEN
define|#
directive|define
name|MAX_CMD_LEN
value|1024
end_define
begin_function
DECL|function|get_port
specifier|static
name|char
modifier|*
name|get_port
parameter_list|(
name|char
modifier|*
name|host
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|long
name|port
init|=
name|strtol
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|p
operator|+
literal|1
operator|&&
operator|*
name|end
operator|==
literal|'\0'
operator|&&
literal|0
operator|<=
name|port
operator|&&
name|port
operator|<
literal|65536
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|no_fork
specifier|static
name|struct
name|child_process
name|no_fork
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * This returns a dummy child_process if the transport protocol does not  * need fork(2), or a struct child_process object if it does.  Once done,  * finish the connection with finish_connect() with the value returned from  * this function (it is safe to call finish_connect() with NULL to support  * the former case).  *  * If it returns, the connect is successful; it just dies on errors (this  * will hopefully be changed in a libification effort, to return NULL when  * the connection failed).  */
end_comment
begin_function
DECL|function|git_connect
name|struct
name|child_process
modifier|*
name|git_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|url_orig
parameter_list|,
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|url
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|child_process
modifier|*
name|conn
init|=
operator|&
name|no_fork
decl_stmt|;
name|enum
name|protocol
name|protocol
init|=
name|PROTO_LOCAL
decl_stmt|;
name|int
name|free_path
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
name|struct
name|strbuf
name|cmd
decl_stmt|;
comment|/* Without this we cannot rely on waitpid() to tell 	 * what happened to our children. 	 */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_url
argument_list|(
name|url_orig
argument_list|)
condition|)
name|url
operator|=
name|url_decode
argument_list|(
name|url_orig
argument_list|)
expr_stmt|;
else|else
name|url
operator|=
name|xstrdup
argument_list|(
name|url_orig
argument_list|)
expr_stmt|;
name|host
operator|=
name|strstr
argument_list|(
name|url
argument_list|,
literal|"://"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
block|{
operator|*
name|host
operator|=
literal|'\0'
expr_stmt|;
name|protocol
operator|=
name|get_protocol
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|host
operator|+=
literal|3
expr_stmt|;
name|c
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|url
expr_stmt|;
name|c
operator|=
literal|':'
expr_stmt|;
block|}
comment|/* 	 * Don't do destructive transforms with git:// as that 	 * protocol code does '[]' unwrapping of its own. 	 */
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|protocol
operator|!=
name|PROTO_GIT
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
name|end
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|path
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|&&
operator|!
name|has_dos_drive_prefix
argument_list|(
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|path
operator|<
name|strchrnul
argument_list|(
name|host
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|protocol
operator|=
name|PROTO_SSH
expr_stmt|;
operator|*
name|path
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* '/' in the host part, assume local path */
name|path
operator|=
name|end
expr_stmt|;
block|}
block|}
else|else
name|path
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|!
operator|*
name|path
condition|)
name|die
argument_list|(
literal|"No path specified. See 'man git-pull' for valid url syntax"
argument_list|)
expr_stmt|;
comment|/* 	 * null-terminate hostname and point path to ~ for URL's like this: 	 *    ssh://host.xz/~user/repo 	 */
if|if
condition|(
name|protocol
operator|!=
name|PROTO_LOCAL
operator|&&
name|host
operator|!=
name|url
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|path
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
name|path
operator|++
expr_stmt|;
else|else
block|{
name|path
operator|=
name|xstrdup
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|free_path
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Add support for ssh port: ssh://host.xy:<port>/... 	 */
if|if
condition|(
name|protocol
operator|==
name|PROTO_SSH
operator|&&
name|host
operator|!=
name|url
condition|)
name|port
operator|=
name|get_port
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PROTO_GIT
condition|)
block|{
comment|/* These underlying connection commands die() if they 		 * cannot connect. 		 */
name|char
modifier|*
name|target_host
init|=
name|xstrdup
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|git_use_proxy
argument_list|(
name|host
argument_list|)
condition|)
name|conn
operator|=
name|git_proxy_connect
argument_list|(
name|fd
argument_list|,
name|host
argument_list|)
expr_stmt|;
else|else
name|git_tcp_connect
argument_list|(
name|fd
argument_list|,
name|host
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Separate original protocol components prog and path 		 * from extended host header with a NUL byte. 		 * 		 * Note: Do not add any other headers here!  Doing so 		 * will cause older git-daemon servers to crash. 		 */
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"%s %s%chost=%s%c"
argument_list|,
name|prog
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|target_host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target_host
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|conn
return|;
block|}
name|conn
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conn
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|cmd
argument_list|,
name|MAX_CMD_LEN
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|cmd
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|cmd
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|cmd
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|len
operator|>=
name|MAX_CMD_LEN
condition|)
name|die
argument_list|(
literal|"command line too long"
argument_list|)
expr_stmt|;
name|conn
operator|->
name|in
operator|=
name|conn
operator|->
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|conn
operator|->
name|argv
operator|=
name|arg
operator|=
name|xcalloc
argument_list|(
literal|7
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PROTO_SSH
condition|)
block|{
specifier|const
name|char
modifier|*
name|ssh
init|=
name|getenv
argument_list|(
literal|"GIT_SSH"
argument_list|)
decl_stmt|;
name|int
name|putty
init|=
name|ssh
operator|&&
name|strcasestr
argument_list|(
name|ssh
argument_list|,
literal|"plink"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ssh
condition|)
name|ssh
operator|=
literal|"ssh"
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|ssh
expr_stmt|;
if|if
condition|(
name|putty
operator|&&
operator|!
name|strcasestr
argument_list|(
name|ssh
argument_list|,
literal|"tortoiseplink"
argument_list|)
condition|)
operator|*
name|arg
operator|++
operator|=
literal|"-batch"
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
comment|/* P is for PuTTY, p is for OpenSSH */
operator|*
name|arg
operator|++
operator|=
name|putty
condition|?
literal|"-P"
else|:
literal|"-p"
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|port
expr_stmt|;
block|}
operator|*
name|arg
operator|++
operator|=
name|host
expr_stmt|;
block|}
else|else
block|{
comment|/* remove repo-local variables from the environment */
name|conn
operator|->
name|env
operator|=
name|local_repo_env
expr_stmt|;
name|conn
operator|->
name|use_shell
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|arg
operator|++
operator|=
name|cmd
operator|.
name|buf
expr_stmt|;
operator|*
name|arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
name|conn
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to fork"
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|conn
operator|->
name|out
expr_stmt|;
comment|/* read from child's stdout */
name|fd
index|[
literal|1
index|]
operator|=
name|conn
operator|->
name|in
expr_stmt|;
comment|/* write to child's stdin */
name|strbuf_release
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|conn
return|;
block|}
end_function
begin_function
DECL|function|git_connection_is_socket
name|int
name|git_connection_is_socket
parameter_list|(
name|struct
name|child_process
modifier|*
name|conn
parameter_list|)
block|{
return|return
name|conn
operator|==
operator|&
name|no_fork
return|;
block|}
end_function
begin_function
DECL|function|finish_connect
name|int
name|finish_connect
parameter_list|(
name|struct
name|child_process
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|conn
operator|||
name|git_connection_is_socket
argument_list|(
name|conn
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|finish_command
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|conn
operator|->
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
end_unit
