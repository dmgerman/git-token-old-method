begin_unit
begin_include
include|#
directive|include
file|"git-compat-util.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"connect.h"
end_include
begin_include
include|#
directive|include
file|"url.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"sha1-array.h"
end_include
begin_decl_stmt
DECL|variable|server_capabilities
specifier|static
name|char
modifier|*
name|server_capabilities
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|parse_feature_value
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|check_ref
specifier|static
name|int
name|check_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flags
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|,
operator|&
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* REF_NORMAL means that we don't want the magic fake tag refs */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_NORMAL
operator|)
operator|&&
name|check_refname_format
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* REF_HEADS means that we want regular branch heads */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_HEADS
operator|)
operator|&&
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REF_TAGS means that we want tags */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_TAGS
operator|)
operator|&&
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* All type bits clear means that we are ok with anything */
return|return
operator|!
operator|(
name|flags
operator|&
operator|~
name|REF_NORMAL
operator|)
return|;
block|}
end_function
begin_function
DECL|function|check_ref_type
name|int
name|check_ref_type
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|check_ref
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|die_initial_contact
specifier|static
name|void
name|die_initial_contact
parameter_list|(
name|int
name|got_at_least_one_head
parameter_list|)
block|{
if|if
condition|(
name|got_at_least_one_head
condition|)
name|die
argument_list|(
literal|"The remote end hung up upon initial contact"
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Could not read from remote repository.\n\n"
literal|"Please make sure you have the correct access rights\n"
literal|"and the repository exists."
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_one_symref_info
specifier|static
name|void
name|parse_one_symref_info
parameter_list|(
name|struct
name|string_list
modifier|*
name|symref
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|sym
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return;
comment|/* just "symref" */
comment|/* e.g. "symref=HEAD:refs/heads/master" */
name|sym
operator|=
name|xmemdupz
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|target
operator|=
name|strchr
argument_list|(
name|sym
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
comment|/* just "symref=something" */
goto|goto
name|reject
goto|;
operator|*
operator|(
name|target
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|check_refname_format
argument_list|(
name|sym
argument_list|,
name|REFNAME_ALLOW_ONELEVEL
argument_list|)
operator|||
name|check_refname_format
argument_list|(
name|target
argument_list|,
name|REFNAME_ALLOW_ONELEVEL
argument_list|)
condition|)
comment|/* "symref=bogus:pair */
goto|goto
name|reject
goto|;
name|item
operator|=
name|string_list_append
argument_list|(
name|symref
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|target
expr_stmt|;
return|return;
name|reject
label|:
name|free
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|annotate_refs_with_symref_info
specifier|static
name|void
name|annotate_refs_with_symref_info
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|string_list
name|symref
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
specifier|const
name|char
modifier|*
name|feature_list
init|=
name|server_capabilities
decl_stmt|;
while|while
condition|(
name|feature_list
condition|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|parse_feature_value
argument_list|(
name|feature_list
argument_list|,
literal|"symref"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
break|break;
name|parse_one_symref_info
argument_list|(
operator|&
name|symref
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|feature_list
operator|=
name|val
operator|+
literal|1
expr_stmt|;
block|}
name|string_list_sort
argument_list|(
operator|&
name|symref
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|string_list_lookup
argument_list|(
operator|&
name|symref
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
continue|continue;
name|ref
operator|->
name|symref
operator|=
name|xstrdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|item
operator|->
name|util
argument_list|)
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
operator|&
name|symref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Read all the refs from the other end  */
end_comment
begin_function
DECL|function|get_remote_heads
name|struct
name|ref
modifier|*
modifier|*
name|get_remote_heads
parameter_list|(
name|int
name|in
parameter_list|,
name|char
modifier|*
name|src_buf
parameter_list|,
name|size_t
name|src_len
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|struct
name|sha1_array
modifier|*
name|extra_have
parameter_list|,
name|struct
name|sha1_array
modifier|*
name|shallow_points
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|orig_list
init|=
name|list
decl_stmt|;
name|int
name|got_at_least_one_head
init|=
literal|0
decl_stmt|;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|unsigned
name|char
name|old_sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|,
name|name_len
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|packet_buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|len
operator|=
name|packet_read
argument_list|(
name|in
argument_list|,
operator|&
name|src_buf
argument_list|,
operator|&
name|src_len
argument_list|,
name|packet_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|packet_buffer
argument_list|)
argument_list|,
name|PACKET_READ_GENTLE_ON_EOF
operator||
name|PACKET_READ_CHOMP_NEWLINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|die_initial_contact
argument_list|(
name|got_at_least_one_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"ERR "
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
name|die
argument_list|(
literal|"remote error: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|48
operator|&&
name|skip_prefix
argument_list|(
name|buffer
argument_list|,
literal|"shallow "
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|arg
argument_list|,
name|old_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"protocol error: expected shallow sha-1, got '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shallow_points
condition|)
name|die
argument_list|(
literal|"repository on the other end cannot be shallow"
argument_list|)
expr_stmt|;
name|sha1_array_append
argument_list|(
name|shallow_points
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|<
literal|42
operator|||
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|old_sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"protocol error: expected sha/ref, got '%s'"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|name
operator|=
name|buffer
operator|+
literal|41
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|name_len
operator|+
literal|41
condition|)
block|{
name|free
argument_list|(
name|server_capabilities
argument_list|)
expr_stmt|;
name|server_capabilities
operator|=
name|xstrdup
argument_list|(
name|name
operator|+
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra_have
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".have"
argument_list|)
condition|)
block|{
name|sha1_array_append
argument_list|(
name|extra_have
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|check_ref
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|buffer
operator|+
literal|41
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|ref
expr_stmt|;
name|list
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
name|got_at_least_one_head
operator|=
literal|1
expr_stmt|;
block|}
name|annotate_refs_with_symref_info
argument_list|(
operator|*
name|orig_list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|parse_feature_value
specifier|static
specifier|const
name|char
modifier|*
name|parse_feature_value
parameter_list|(
specifier|const
name|char
modifier|*
name|feature_list
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|feature_list
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|feature
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|feature_list
condition|)
block|{
specifier|const
name|char
modifier|*
name|found
init|=
name|strstr
argument_list|(
name|feature_list
argument_list|,
name|feature
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|feature_list
operator|==
name|found
operator|||
name|isspace
argument_list|(
name|found
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|found
operator|+
name|len
decl_stmt|;
comment|/* feature with no value (e.g., "thin-pack") */
if|if
condition|(
operator|!
operator|*
name|value
operator|||
name|isspace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* feature with a value (e.g., "agent=git/1.2.3") */
elseif|else
if|if
condition|(
operator|*
name|value
operator|==
literal|'='
condition|)
block|{
name|value
operator|++
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|strcspn
argument_list|(
name|value
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* 			 * otherwise we matched a substring of another feature; 			 * keep looking 			 */
block|}
name|feature_list
operator|=
name|found
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|parse_feature_request
name|int
name|parse_feature_request
parameter_list|(
specifier|const
name|char
modifier|*
name|feature_list
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
block|{
return|return
operator|!
operator|!
name|parse_feature_value
argument_list|(
name|feature_list
argument_list|,
name|feature
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|server_feature_value
specifier|const
name|char
modifier|*
name|server_feature_value
parameter_list|(
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
return|return
name|parse_feature_value
argument_list|(
name|server_capabilities
argument_list|,
name|feature
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|server_supports
name|int
name|server_supports
parameter_list|(
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
block|{
return|return
operator|!
operator|!
name|server_feature_value
argument_list|(
name|feature
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_enum
DECL|enum|protocol
enum|enum
name|protocol
block|{
DECL|enumerator|PROTO_LOCAL
name|PROTO_LOCAL
init|=
literal|1
block|,
DECL|enumerator|PROTO_FILE
name|PROTO_FILE
block|,
DECL|enumerator|PROTO_SSH
name|PROTO_SSH
block|,
DECL|enumerator|PROTO_GIT
name|PROTO_GIT
block|}
enum|;
end_enum
begin_function
DECL|function|url_is_local_not_ssh
name|int
name|url_is_local_not_ssh
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|colon
init|=
name|strchr
argument_list|(
name|url
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash
init|=
name|strchr
argument_list|(
name|url
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
return|return
operator|!
name|colon
operator|||
operator|(
name|slash
operator|&&
name|slash
operator|<
name|colon
operator|)
operator|||
name|has_dos_drive_prefix
argument_list|(
name|url
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|prot_name
specifier|static
specifier|const
name|char
modifier|*
name|prot_name
parameter_list|(
name|enum
name|protocol
name|protocol
parameter_list|)
block|{
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|PROTO_LOCAL
case|:
case|case
name|PROTO_FILE
case|:
return|return
literal|"file"
return|;
case|case
name|PROTO_SSH
case|:
return|return
literal|"ssh"
return|;
case|case
name|PROTO_GIT
case|:
return|return
literal|"git"
return|;
default|default:
return|return
literal|"unkown protocol"
return|;
block|}
block|}
end_function
begin_function
DECL|function|get_protocol
specifier|static
name|enum
name|protocol
name|get_protocol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git"
argument_list|)
condition|)
return|return
name|PROTO_GIT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git+ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh+git"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file"
argument_list|)
condition|)
return|return
name|PROTO_FILE
return|;
name|die
argument_list|(
literal|"I don't handle protocol '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|host_end
specifier|static
name|char
modifier|*
name|host_end
parameter_list|(
name|char
modifier|*
modifier|*
name|hoststart
parameter_list|,
name|int
name|removebrackets
parameter_list|)
block|{
name|char
modifier|*
name|host
init|=
operator|*
name|hoststart
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|strstr
argument_list|(
name|host
argument_list|,
literal|"@["
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
condition|)
name|start
operator|++
expr_stmt|;
comment|/* Jump over '@' */
else|else
name|start
operator|=
name|host
expr_stmt|;
if|if
condition|(
name|start
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|start
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|removebrackets
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|memmove
argument_list|(
name|start
argument_list|,
name|start
operator|+
literal|1
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
block|}
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
return|return
name|end
return|;
block|}
end_function
begin_define
DECL|macro|STR_
define|#
directive|define
name|STR_
parameter_list|(
name|s
parameter_list|)
value|# s
end_define
begin_define
DECL|macro|STR
define|#
directive|define
name|STR
parameter_list|(
name|s
parameter_list|)
value|STR_(s)
end_define
begin_function
DECL|function|get_host_and_port
specifier|static
name|void
name|get_host_and_port
parameter_list|(
name|char
modifier|*
modifier|*
name|host
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|port
parameter_list|)
block|{
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|host_end
argument_list|(
name|host
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
name|long
name|portnr
init|=
name|strtol
argument_list|(
name|colon
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|colon
operator|+
literal|1
operator|&&
operator|*
name|end
operator|==
literal|'\0'
operator|&&
literal|0
operator|<=
name|portnr
operator|&&
name|portnr
operator|<
literal|65536
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
operator|*
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|enable_keepalive
specifier|static
name|void
name|enable_keepalive
parameter_list|(
name|int
name|sockfd
parameter_list|)
block|{
name|int
name|ka
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|&
name|ka
argument_list|,
sizeof|sizeof
argument_list|(
name|ka
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to set SO_KEEPALIVE on socket: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_IPV6
end_ifndef
begin_function
DECL|function|ai_name
specifier|static
specifier|const
name|char
modifier|*
name|ai_name
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
specifier|static
name|char
name|addr
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
if|if
condition|(
name|getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|addr
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|strbuf
name|error_message
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai0
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|int
name|gai
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|get_host_and_port
argument_list|(
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|port
condition|)
name|port
operator|=
literal|"<none>"
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking up %s ... "
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|gai
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|gai
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (port %s) (%s)"
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|gai_strerror
argument_list|(
name|gai
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\nConnecting to %s (port %s) ... "
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|ai0
operator|=
name|ai
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
operator|,
name|cnt
operator|++
control|)
block|{
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sockfd
operator|<
literal|0
operator|)
operator|||
operator|(
name|connect
argument_list|(
name|sockfd
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|error_message
argument_list|,
literal|"%s[%d: %s]: errno=%s\n"
argument_list|,
name|host
argument_list|,
name|cnt
argument_list|,
name|ai_name
argument_list|(
name|ai
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|sockfd
condition|)
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|ai_name
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|ai0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect to %s:\n%s"
argument_list|,
name|host
argument_list|,
name|error_message
operator|.
name|buf
argument_list|)
expr_stmt|;
name|enable_keepalive
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\n"
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|error_message
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|strbuf
name|error_message
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|unsigned
name|int
name|nport
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|get_host_and_port
argument_list|(
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking up %s ... "
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|he
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (%s)"
argument_list|,
name|host
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
name|nport
operator|=
name|strtoul
argument_list|(
name|port
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|port
operator|||
operator|*
name|ep
condition|)
block|{
comment|/* Not numeric */
name|struct
name|servent
modifier|*
name|se
init|=
name|getservbyname
argument_list|(
name|port
argument_list|,
literal|"tcp"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|se
condition|)
name|die
argument_list|(
literal|"Unknown port %s"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|nport
operator|=
name|se
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\nConnecting to %s (port %s) ... "
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|ap
operator|=
name|he
operator|->
name|h_addr_list
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|cnt
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sin_family
operator|=
name|he
operator|->
name|h_addrtype
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|nport
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sa
operator|.
name|sin_addr
argument_list|,
operator|*
name|ap
argument_list|,
name|he
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|sockfd
operator|=
name|socket
argument_list|(
name|he
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sockfd
operator|<
literal|0
operator|)
operator|||
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|error_message
argument_list|,
literal|"%s[%d: %s]: errno=%s\n"
argument_list|,
name|host
argument_list|,
name|cnt
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|sockfd
condition|)
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect to %s:\n%s"
argument_list|,
name|host
argument_list|,
name|error_message
operator|.
name|buf
argument_list|)
expr_stmt|;
name|enable_keepalive
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_function
DECL|function|git_tcp_connect
specifier|static
name|void
name|git_tcp_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|sockfd
init|=
name|git_tcp_connect_sock
argument_list|(
name|host
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|sockfd
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|dup
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|git_proxy_command
specifier|static
name|char
modifier|*
name|git_proxy_command
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_proxy_command_options
specifier|static
name|int
name|git_proxy_command_options
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.gitproxy"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|for_pos
decl_stmt|;
name|int
name|matchlen
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hostlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|rhost_name
init|=
name|cb
decl_stmt|;
name|int
name|rhost_len
init|=
name|strlen
argument_list|(
name|rhost_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|git_proxy_command
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
comment|/* [core] 		 * ;# matches www.kernel.org as well 		 * gitproxy = netcatter-1 for kernel.org 		 * gitproxy = netcatter-2 for sample.xz 		 * gitproxy = netcatter-default 		 */
name|for_pos
operator|=
name|strstr
argument_list|(
name|value
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_pos
condition|)
comment|/* matches everybody */
name|matchlen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|hostlen
operator|=
name|strlen
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhost_len
operator|<
name|hostlen
condition|)
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|,
name|rhost_name
operator|+
name|rhost_len
operator|-
name|hostlen
argument_list|,
name|hostlen
argument_list|)
operator|&&
operator|(
operator|(
name|rhost_len
operator|==
name|hostlen
operator|)
operator|||
name|rhost_name
index|[
name|rhost_len
operator|-
name|hostlen
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|matchlen
operator|=
name|for_pos
operator|-
name|value
expr_stmt|;
else|else
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|matchlen
condition|)
block|{
comment|/* core.gitproxy = none for kernel.org */
if|if
condition|(
name|matchlen
operator|==
literal|4
operator|&&
operator|!
name|memcmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|,
literal|4
argument_list|)
condition|)
name|matchlen
operator|=
literal|0
expr_stmt|;
name|git_proxy_command
operator|=
name|xmemdupz
argument_list|(
name|value
argument_list|,
name|matchlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_use_proxy
specifier|static
name|int
name|git_use_proxy
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|)
block|{
name|git_proxy_command
operator|=
name|getenv
argument_list|(
literal|"GIT_PROXY_COMMAND"
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_proxy_command_options
argument_list|,
operator|(
name|void
operator|*
operator|)
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
name|git_proxy_command
operator|&&
operator|*
name|git_proxy_command
operator|)
return|;
block|}
end_function
begin_function
DECL|function|git_proxy_connect
specifier|static
name|struct
name|child_process
modifier|*
name|git_proxy_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|struct
name|child_process
modifier|*
name|proxy
decl_stmt|;
name|get_host_and_port
argument_list|(
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
name|proxy
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|proxy
argument_list|)
argument_list|)
expr_stmt|;
name|child_process_init
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|proxy
operator|->
name|args
argument_list|,
name|git_proxy_command
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|proxy
operator|->
name|args
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|proxy
operator|->
name|args
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|proxy
operator|->
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|proxy
operator|->
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
name|proxy
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot start proxy %s"
argument_list|,
name|git_proxy_command
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|proxy
operator|->
name|out
expr_stmt|;
comment|/* read from proxy stdout */
name|fd
index|[
literal|1
index|]
operator|=
name|proxy
operator|->
name|in
expr_stmt|;
comment|/* write to proxy stdin */
return|return
name|proxy
return|;
block|}
end_function
begin_function
DECL|function|get_port
specifier|static
name|char
modifier|*
name|get_port
parameter_list|(
name|char
modifier|*
name|host
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|long
name|port
init|=
name|strtol
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|p
operator|+
literal|1
operator|&&
operator|*
name|end
operator|==
literal|'\0'
operator|&&
literal|0
operator|<=
name|port
operator|&&
name|port
operator|<
literal|65536
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Extract protocol and relevant parts from the specified connection URL.  * The caller must free() the returned strings.  */
end_comment
begin_function
DECL|function|parse_connect_url
specifier|static
name|enum
name|protocol
name|parse_connect_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url_orig
parameter_list|,
name|char
modifier|*
modifier|*
name|ret_host
parameter_list|,
name|char
modifier|*
modifier|*
name|ret_path
parameter_list|)
block|{
name|char
modifier|*
name|url
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|separator
init|=
literal|'/'
decl_stmt|;
name|enum
name|protocol
name|protocol
init|=
name|PROTO_LOCAL
decl_stmt|;
if|if
condition|(
name|is_url
argument_list|(
name|url_orig
argument_list|)
condition|)
name|url
operator|=
name|url_decode
argument_list|(
name|url_orig
argument_list|)
expr_stmt|;
else|else
name|url
operator|=
name|xstrdup
argument_list|(
name|url_orig
argument_list|)
expr_stmt|;
name|host
operator|=
name|strstr
argument_list|(
name|url
argument_list|,
literal|"://"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
block|{
operator|*
name|host
operator|=
literal|'\0'
expr_stmt|;
name|protocol
operator|=
name|get_protocol
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|host
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|url
expr_stmt|;
if|if
condition|(
operator|!
name|url_is_local_not_ssh
argument_list|(
name|url
argument_list|)
condition|)
block|{
name|protocol
operator|=
name|PROTO_SSH
expr_stmt|;
name|separator
operator|=
literal|':'
expr_stmt|;
block|}
block|}
comment|/* 	 * Don't do destructive transforms as protocol code does 	 * '[]' unwrapping in get_host_and_port() 	 */
name|end
operator|=
name|host_end
argument_list|(
operator|&
name|host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PROTO_LOCAL
condition|)
name|path
operator|=
name|end
expr_stmt|;
elseif|else
if|if
condition|(
name|protocol
operator|==
name|PROTO_FILE
operator|&&
name|has_dos_drive_prefix
argument_list|(
name|end
argument_list|)
condition|)
name|path
operator|=
name|end
expr_stmt|;
comment|/* "file://$(pwd)" may be "file://C:/projects/repo" */
else|else
name|path
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
name|separator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|!
operator|*
name|path
condition|)
name|die
argument_list|(
literal|"No path specified. See 'man git-pull' for valid url syntax"
argument_list|)
expr_stmt|;
comment|/* 	 * null-terminate hostname and point path to ~ for URL's like this: 	 *    ssh://host.xz/~user/repo 	 */
name|end
operator|=
name|path
expr_stmt|;
comment|/* Need to \0 terminate host here */
if|if
condition|(
name|separator
operator|==
literal|':'
condition|)
name|path
operator|++
expr_stmt|;
comment|/* path starts after ':' */
if|if
condition|(
name|protocol
operator|==
name|PROTO_GIT
operator|||
name|protocol
operator|==
name|PROTO_SSH
condition|)
block|{
if|if
condition|(
name|path
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
name|path
operator|++
expr_stmt|;
block|}
name|path
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ret_host
operator|=
name|xstrdup
argument_list|(
name|host
argument_list|)
expr_stmt|;
operator|*
name|ret_path
operator|=
name|path
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|protocol
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|no_fork
specifier|static
name|struct
name|child_process
name|no_fork
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * This returns a dummy child_process if the transport protocol does not  * need fork(2), or a struct child_process object if it does.  Once done,  * finish the connection with finish_connect() with the value returned from  * this function (it is safe to call finish_connect() with NULL to support  * the former case).  *  * If it returns, the connect is successful; it just dies on errors (this  * will hopefully be changed in a libification effort, to return NULL when  * the connection failed).  */
end_comment
begin_function
DECL|function|git_connect
name|struct
name|child_process
modifier|*
name|git_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|hostandport
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|struct
name|child_process
modifier|*
name|conn
init|=
operator|&
name|no_fork
decl_stmt|;
name|enum
name|protocol
name|protocol
decl_stmt|;
name|struct
name|strbuf
name|cmd
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* Without this we cannot rely on waitpid() to tell 	 * what happened to our children. 	 */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|protocol
operator|=
name|parse_connect_url
argument_list|(
name|url
argument_list|,
operator|&
name|hostandport
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CONNECT_DIAG_URL
operator|)
operator|&&
operator|(
name|protocol
operator|!=
name|PROTO_SSH
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Diag: url=%s\n"
argument_list|,
name|url
condition|?
name|url
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Diag: protocol=%s\n"
argument_list|,
name|prot_name
argument_list|(
name|protocol
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Diag: hostandport=%s\n"
argument_list|,
name|hostandport
condition|?
name|hostandport
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Diag: path=%s\n"
argument_list|,
name|path
condition|?
name|path
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|conn
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|==
name|PROTO_GIT
condition|)
block|{
comment|/* 		 * Set up virtual host information based on where we will 		 * connect, unless the user has overridden us in 		 * the environment. 		 */
name|char
modifier|*
name|target_host
init|=
name|getenv
argument_list|(
literal|"GIT_OVERRIDE_VIRTUAL_HOST"
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_host
condition|)
name|target_host
operator|=
name|xstrdup
argument_list|(
name|target_host
argument_list|)
expr_stmt|;
else|else
name|target_host
operator|=
name|xstrdup
argument_list|(
name|hostandport
argument_list|)
expr_stmt|;
comment|/* These underlying connection commands die() if they 		 * cannot connect. 		 */
if|if
condition|(
name|git_use_proxy
argument_list|(
name|hostandport
argument_list|)
condition|)
name|conn
operator|=
name|git_proxy_connect
argument_list|(
name|fd
argument_list|,
name|hostandport
argument_list|)
expr_stmt|;
else|else
name|git_tcp_connect
argument_list|(
name|fd
argument_list|,
name|hostandport
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Separate original protocol components prog and path 		 * from extended host header with a NUL byte. 		 * 		 * Note: Do not add any other headers here!  Doing so 		 * will cause older git-daemon servers to crash. 		 */
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"%s %s%chost=%s%c"
argument_list|,
name|prog
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|target_host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target_host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conn
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|conn
argument_list|)
argument_list|)
expr_stmt|;
name|child_process_init
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|cmd
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|cmd
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|cmd
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|conn
operator|->
name|in
operator|=
name|conn
operator|->
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PROTO_SSH
condition|)
block|{
specifier|const
name|char
modifier|*
name|ssh
decl_stmt|;
name|int
name|putty
decl_stmt|,
name|tortoiseplink
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ssh_host
init|=
name|hostandport
decl_stmt|;
specifier|const
name|char
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|get_host_and_port
argument_list|(
operator|&
name|ssh_host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
name|port
operator|=
name|get_port
argument_list|(
name|ssh_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_DIAG_URL
condition|)
block|{
name|printf
argument_list|(
literal|"Diag: url=%s\n"
argument_list|,
name|url
condition|?
name|url
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Diag: protocol=%s\n"
argument_list|,
name|prot_name
argument_list|(
name|protocol
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Diag: userandhost=%s\n"
argument_list|,
name|ssh_host
condition|?
name|ssh_host
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Diag: port=%s\n"
argument_list|,
name|port
condition|?
name|port
else|:
literal|"NONE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Diag: path=%s\n"
argument_list|,
name|path
condition|?
name|path
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostandport
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ssh
operator|=
name|getenv
argument_list|(
literal|"GIT_SSH_COMMAND"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssh
condition|)
block|{
name|conn
operator|->
name|use_shell
operator|=
literal|1
expr_stmt|;
name|putty
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|ssh_dup
decl_stmt|;
name|ssh
operator|=
name|getenv
argument_list|(
literal|"GIT_SSH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssh
condition|)
name|ssh
operator|=
literal|"ssh"
expr_stmt|;
name|ssh_dup
operator|=
name|xstrdup
argument_list|(
name|ssh
argument_list|)
expr_stmt|;
name|base
operator|=
name|basename
argument_list|(
name|ssh_dup
argument_list|)
expr_stmt|;
name|tortoiseplink
operator|=
operator|!
name|strcasecmp
argument_list|(
name|base
argument_list|,
literal|"tortoiseplink"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|base
argument_list|,
literal|"tortoiseplink.exe"
argument_list|)
expr_stmt|;
name|putty
operator|=
operator|!
name|strcasecmp
argument_list|(
name|base
argument_list|,
literal|"plink"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|base
argument_list|,
literal|"plink.exe"
argument_list|)
operator|||
name|tortoiseplink
expr_stmt|;
name|free
argument_list|(
name|ssh_dup
argument_list|)
expr_stmt|;
block|}
name|argv_array_push
argument_list|(
operator|&
name|conn
operator|->
name|args
argument_list|,
name|ssh
argument_list|)
expr_stmt|;
if|if
condition|(
name|tortoiseplink
condition|)
name|argv_array_push
argument_list|(
operator|&
name|conn
operator|->
name|args
argument_list|,
literal|"-batch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
comment|/* P is for PuTTY, p is for OpenSSH */
name|argv_array_push
argument_list|(
operator|&
name|conn
operator|->
name|args
argument_list|,
name|putty
condition|?
literal|"-P"
else|:
literal|"-p"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|conn
operator|->
name|args
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|argv_array_push
argument_list|(
operator|&
name|conn
operator|->
name|args
argument_list|,
name|ssh_host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* remove repo-local variables from the environment */
name|conn
operator|->
name|env
operator|=
name|local_repo_env
expr_stmt|;
name|conn
operator|->
name|use_shell
operator|=
literal|1
expr_stmt|;
block|}
name|argv_array_push
argument_list|(
operator|&
name|conn
operator|->
name|args
argument_list|,
name|cmd
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
name|conn
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to fork"
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|conn
operator|->
name|out
expr_stmt|;
comment|/* read from child's stdout */
name|fd
index|[
literal|1
index|]
operator|=
name|conn
operator|->
name|in
expr_stmt|;
comment|/* write to child's stdin */
name|strbuf_release
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hostandport
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|conn
return|;
block|}
end_function
begin_function
DECL|function|git_connection_is_socket
name|int
name|git_connection_is_socket
parameter_list|(
name|struct
name|child_process
modifier|*
name|conn
parameter_list|)
block|{
return|return
name|conn
operator|==
operator|&
name|no_fork
return|;
block|}
end_function
begin_function
DECL|function|finish_connect
name|int
name|finish_connect
parameter_list|(
name|struct
name|child_process
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|conn
operator|||
name|git_connection_is_socket
argument_list|(
name|conn
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|finish_command
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
end_unit
