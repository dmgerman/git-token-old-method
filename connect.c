begin_unit
begin_include
include|#
directive|include
file|"git-compat-util.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_decl_stmt
DECL|variable|server_capabilities
specifier|static
name|char
modifier|*
name|server_capabilities
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|check_ref
specifier|static
name|int
name|check_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flags
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<
literal|5
operator|||
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Skip the "refs/" part */
name|name
operator|+=
literal|5
expr_stmt|;
name|len
operator|-=
literal|5
expr_stmt|;
comment|/* REF_NORMAL means that we don't want the magic fake tag refs */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_NORMAL
operator|)
operator|&&
name|check_ref_format
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* REF_HEADS means that we want regular branch heads */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_HEADS
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REF_TAGS means that we want tags */
if|if
condition|(
operator|(
name|flags
operator|&
name|REF_TAGS
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* All type bits clear means that we are ok with anything */
return|return
operator|!
operator|(
name|flags
operator|&
operator|~
name|REF_NORMAL
operator|)
return|;
block|}
end_function
begin_function
DECL|function|check_ref_type
name|int
name|check_ref_type
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|check_ref
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|ref
operator|->
name|name
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read all the refs from the other end  */
end_comment
begin_function
DECL|function|get_remote_heads
name|struct
name|ref
modifier|*
modifier|*
name|get_remote_heads
parameter_list|(
name|int
name|in
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|nr_match
parameter_list|,
name|char
modifier|*
modifier|*
name|match
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|unsigned
name|char
name|old_sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|,
name|name_len
decl_stmt|;
name|len
operator|=
name|packet_read_line
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
if|if
condition|(
name|buffer
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buffer
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|42
operator|||
name|get_sha1_hex
argument_list|(
name|buffer
argument_list|,
name|old_sha1
argument_list|)
operator|||
name|buffer
index|[
literal|40
index|]
operator|!=
literal|' '
condition|)
name|die
argument_list|(
literal|"protocol error: expected sha/ref, got '%s'"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|name
operator|=
name|buffer
operator|+
literal|41
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|name_len
operator|+
literal|41
condition|)
block|{
name|free
argument_list|(
name|server_capabilities
argument_list|)
expr_stmt|;
name|server_capabilities
operator|=
name|xstrdup
argument_list|(
name|name
operator|+
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_ref
argument_list|(
name|name
argument_list|,
name|name_len
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nr_match
operator|&&
operator|!
name|path_match
argument_list|(
name|name
argument_list|,
name|nr_match
argument_list|,
name|match
argument_list|)
condition|)
continue|continue;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|old_sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|buffer
operator|+
literal|41
argument_list|,
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|ref
expr_stmt|;
name|list
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function
begin_function
DECL|function|server_supports
name|int
name|server_supports
parameter_list|(
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
block|{
return|return
name|server_capabilities
operator|&&
name|strstr
argument_list|(
name|server_capabilities
argument_list|,
name|feature
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|get_ack
name|int
name|get_ack
parameter_list|(
name|int
name|fd
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|len
init|=
name|packet_read_line
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|die
argument_list|(
literal|"git-fetch-pack: expected ACK/NAK, got EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"NAK"
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"ACK "
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|4
argument_list|,
name|result_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"continue"
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
block|}
name|die
argument_list|(
literal|"git-fetch_pack: expected ACK/NAK, got '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|path_match
name|int
name|path_match
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|nr
parameter_list|,
name|char
modifier|*
modifier|*
name|match
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|s
init|=
name|match
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|len
operator|>
name|pathlen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|path
operator|+
name|pathlen
operator|-
name|len
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pathlen
operator|>
name|len
operator|&&
name|path
index|[
name|pathlen
operator|-
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_enum
DECL|enum|protocol
enum|enum
name|protocol
block|{
DECL|enumerator|PROTO_LOCAL
name|PROTO_LOCAL
init|=
literal|1
block|,
DECL|enumerator|PROTO_SSH
name|PROTO_SSH
block|,
DECL|enumerator|PROTO_GIT
name|PROTO_GIT
block|, }
enum|;
end_enum
begin_function
DECL|function|get_protocol
specifier|static
name|enum
name|protocol
name|get_protocol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git"
argument_list|)
condition|)
return|return
name|PROTO_GIT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"git+ssh"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ssh+git"
argument_list|)
condition|)
return|return
name|PROTO_SSH
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"file"
argument_list|)
condition|)
return|return
name|PROTO_LOCAL
return|;
name|die
argument_list|(
literal|"I don't handle protocol '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|STR_
define|#
directive|define
name|STR_
parameter_list|(
name|s
parameter_list|)
value|# s
end_define
begin_define
DECL|macro|STR
define|#
directive|define
name|STR
parameter_list|(
name|s
parameter_list|)
value|STR_(s)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|NO_IPV6
end_ifndef
begin_function
DECL|function|ai_name
specifier|static
specifier|const
name|char
modifier|*
name|ai_name
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
specifier|static
name|char
name|addr
index|[
name|INET_ADDRSTRLEN
index|]
decl_stmt|;
if|if
condition|(
name|AF_INET
operator|==
name|ai
operator|->
name|ai_family
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|in
decl_stmt|;
name|in
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
expr_stmt|;
name|inet_ntop
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
operator|&
name|in
operator|->
name|sin_addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AF_INET6
operator|==
name|ai
operator|->
name|ai_family
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|in
decl_stmt|;
name|in
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
expr_stmt|;
name|inet_ntop
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
operator|&
name|in
operator|->
name|sin6_addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|addr
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|,
name|saved_errno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai0
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|int
name|gai
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|port
condition|)
name|port
operator|=
literal|"<none>"
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking up %s ... "
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|gai
operator|=
name|getaddrinfo
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|gai
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (port %s) (%s)"
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|gai_strerror
argument_list|(
name|gai
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\nConnecting to %s (port %s) ... "
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|ai0
operator|=
name|ai
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d: %s]: errno=%s\n"
argument_list|,
name|host
argument_list|,
name|cnt
argument_list|,
name|ai_name
argument_list|(
name|ai
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|ai_name
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|ai0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect a socket (%s)"
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_comment
comment|/*  * Returns a connected socket() fd, or else die()s.  */
end_comment
begin_function
DECL|function|git_tcp_connect_sock
specifier|static
name|int
name|git_tcp_connect_sock
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|,
name|saved_errno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|unsigned
name|int
name|nport
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking up %s ... "
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|he
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
name|die
argument_list|(
literal|"Unable to look up %s (%s)"
argument_list|,
name|host
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
name|nport
operator|=
name|strtoul
argument_list|(
name|port
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|port
operator|||
operator|*
name|ep
condition|)
block|{
comment|/* Not numeric */
name|struct
name|servent
modifier|*
name|se
init|=
name|getservbyname
argument_list|(
name|port
argument_list|,
literal|"tcp"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|se
condition|)
name|die
argument_list|(
literal|"Unknown port %s\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|nport
operator|=
name|se
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\nConnecting to %s (port %s) ... "
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|ap
operator|=
name|he
operator|->
name|h_addr_list
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|cnt
operator|++
control|)
block|{
name|sockfd
operator|=
name|socket
argument_list|(
name|he
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
continue|continue;
block|}
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sin_family
operator|=
name|he
operator|->
name|h_addrtype
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|nport
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sa
operator|.
name|sin_addr
argument_list|,
operator|*
name|ap
argument_list|,
name|he
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|<
literal|0
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s[%d: %s]: errno=%s\n"
argument_list|,
name|host
argument_list|,
name|cnt
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to connect a socket (%s)"
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONNECT_VERBOSE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
name|sockfd
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_function
DECL|function|git_tcp_connect
specifier|static
name|void
name|git_tcp_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|sockfd
init|=
name|git_tcp_connect_sock
argument_list|(
name|host
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|sockfd
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|dup
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|git_proxy_command
specifier|static
name|char
modifier|*
name|git_proxy_command
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rhost_name
specifier|static
specifier|const
name|char
modifier|*
name|rhost_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rhost_len
specifier|static
name|int
name|rhost_len
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_proxy_command_options
specifier|static
name|int
name|git_proxy_command_options
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.gitproxy"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|for_pos
decl_stmt|;
name|int
name|matchlen
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hostlen
decl_stmt|;
if|if
condition|(
name|git_proxy_command
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
comment|/* [core] 		 * ;# matches www.kernel.org as well 		 * gitproxy = netcatter-1 for kernel.org 		 * gitproxy = netcatter-2 for sample.xz 		 * gitproxy = netcatter-default 		 */
name|for_pos
operator|=
name|strstr
argument_list|(
name|value
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_pos
condition|)
comment|/* matches everybody */
name|matchlen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|hostlen
operator|=
name|strlen
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhost_len
operator|<
name|hostlen
condition|)
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|for_pos
operator|+
literal|5
argument_list|,
name|rhost_name
operator|+
name|rhost_len
operator|-
name|hostlen
argument_list|,
name|hostlen
argument_list|)
operator|&&
operator|(
operator|(
name|rhost_len
operator|==
name|hostlen
operator|)
operator|||
name|rhost_name
index|[
name|rhost_len
operator|-
name|hostlen
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|matchlen
operator|=
name|for_pos
operator|-
name|value
expr_stmt|;
else|else
name|matchlen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|matchlen
condition|)
block|{
comment|/* core.gitproxy = none for kernel.org */
if|if
condition|(
name|matchlen
operator|==
literal|4
operator|&&
operator|!
name|memcmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|,
literal|4
argument_list|)
condition|)
name|matchlen
operator|=
literal|0
expr_stmt|;
name|git_proxy_command
operator|=
name|xmemdupz
argument_list|(
name|value
argument_list|,
name|matchlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_use_proxy
specifier|static
name|int
name|git_use_proxy
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|)
block|{
name|rhost_name
operator|=
name|host
expr_stmt|;
name|rhost_len
operator|=
name|strlen
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|git_proxy_command
operator|=
name|getenv
argument_list|(
literal|"GIT_PROXY_COMMAND"
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_proxy_command_options
argument_list|)
expr_stmt|;
name|rhost_name
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|git_proxy_command
operator|&&
operator|*
name|git_proxy_command
operator|)
return|;
block|}
end_function
begin_function
DECL|function|git_proxy_connect
specifier|static
name|void
name|git_proxy_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
name|host
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|port
init|=
name|STR
argument_list|(
name|DEFAULT_GIT_PORT
argument_list|)
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|child_process
name|proxy
decl_stmt|;
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
condition|)
block|{
operator|*
name|colon
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
name|git_proxy_command
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|host
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|port
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|proxy
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|proxy
argument_list|)
argument_list|)
expr_stmt|;
name|proxy
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|proxy
operator|.
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|proxy
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|proxy
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot start proxy %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|proxy
operator|.
name|out
expr_stmt|;
comment|/* read from proxy stdout */
name|fd
index|[
literal|1
index|]
operator|=
name|proxy
operator|.
name|in
expr_stmt|;
comment|/* write to proxy stdin */
block|}
end_function
begin_define
DECL|macro|MAX_CMD_LEN
define|#
directive|define
name|MAX_CMD_LEN
value|1024
end_define
begin_function
DECL|function|get_port
name|char
modifier|*
name|get_port
parameter_list|(
name|char
modifier|*
name|host
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|strtol
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|no_fork
specifier|static
name|struct
name|child_process
name|no_fork
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * This returns a dummy child_process if the transport protocol does not  * need fork(2), or a struct child_process object if it does.  Once done,  * finish the connection with finish_connect() with the value returned from  * this function (it is safe to call finish_connect() with NULL to support  * the former case).  *  * If it returns, the connect is successful; it just dies on errors (this  * will hopefully be changed in a libification effort, to return NULL when  * the connection failed).  */
end_comment
begin_function
DECL|function|git_connect
name|struct
name|child_process
modifier|*
name|git_connect
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|url_orig
parameter_list|,
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|url
init|=
name|xstrdup
argument_list|(
name|url_orig
argument_list|)
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|path
init|=
name|url
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|child_process
modifier|*
name|conn
decl_stmt|;
name|enum
name|protocol
name|protocol
init|=
name|PROTO_LOCAL
decl_stmt|;
name|int
name|free_path
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
name|struct
name|strbuf
name|cmd
decl_stmt|;
comment|/* Without this we cannot rely on waitpid() to tell 	 * what happened to our children. 	 */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|host
operator|=
name|strstr
argument_list|(
name|url
argument_list|,
literal|"://"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
block|{
operator|*
name|host
operator|=
literal|'\0'
expr_stmt|;
name|protocol
operator|=
name|get_protocol
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|host
operator|+=
literal|3
expr_stmt|;
name|c
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|url
expr_stmt|;
name|c
operator|=
literal|':'
expr_stmt|;
block|}
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|host
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|end
operator|++
expr_stmt|;
name|host
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
block|}
else|else
name|end
operator|=
name|host
expr_stmt|;
name|path
operator|=
name|strchr
argument_list|(
name|end
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|protocol
operator|=
name|PROTO_SSH
expr_stmt|;
operator|*
name|path
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
name|path
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|!
operator|*
name|path
condition|)
name|die
argument_list|(
literal|"No path specified. See 'man git-pull' for valid url syntax"
argument_list|)
expr_stmt|;
comment|/* 	 * null-terminate hostname and point path to ~ for URL's like this: 	 *    ssh://host.xz/~user/repo 	 */
if|if
condition|(
name|protocol
operator|!=
name|PROTO_LOCAL
operator|&&
name|host
operator|!=
name|url
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|path
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
name|path
operator|++
expr_stmt|;
else|else
block|{
name|path
operator|=
name|xstrdup
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|free_path
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Add support for ssh port: ssh://host.xy:<port>/... 	 */
if|if
condition|(
name|protocol
operator|==
name|PROTO_SSH
operator|&&
name|host
operator|!=
name|url
condition|)
name|port
operator|=
name|get_port
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PROTO_GIT
condition|)
block|{
comment|/* These underlying connection commands die() if they 		 * cannot connect. 		 */
name|char
modifier|*
name|target_host
init|=
name|xstrdup
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|git_use_proxy
argument_list|(
name|host
argument_list|)
condition|)
name|git_proxy_connect
argument_list|(
name|fd
argument_list|,
name|host
argument_list|)
expr_stmt|;
else|else
name|git_tcp_connect
argument_list|(
name|fd
argument_list|,
name|host
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Separate original protocol components prog and path 		 * from extended components with a NUL byte. 		 */
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"%s %s%chost=%s%c"
argument_list|,
name|prog
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|target_host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target_host
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|&
name|no_fork
return|;
block|}
name|conn
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conn
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|cmd
argument_list|,
name|MAX_CMD_LEN
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|cmd
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|cmd
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|cmd
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|len
operator|>=
name|MAX_CMD_LEN
condition|)
name|die
argument_list|(
literal|"command line too long"
argument_list|)
expr_stmt|;
name|conn
operator|->
name|in
operator|=
name|conn
operator|->
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|conn
operator|->
name|argv
operator|=
name|arg
operator|=
name|xcalloc
argument_list|(
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PROTO_SSH
condition|)
block|{
specifier|const
name|char
modifier|*
name|ssh
init|=
name|getenv
argument_list|(
literal|"GIT_SSH"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ssh
condition|)
name|ssh
operator|=
literal|"ssh"
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|ssh
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
operator|*
name|arg
operator|++
operator|=
literal|"-p"
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|port
expr_stmt|;
block|}
operator|*
name|arg
operator|++
operator|=
name|host
expr_stmt|;
block|}
else|else
block|{
comment|/* remove these from the environment */
specifier|const
name|char
modifier|*
name|env
index|[]
init|=
block|{
name|ALTERNATE_DB_ENVIRONMENT
block|,
name|DB_ENVIRONMENT
block|,
name|GIT_DIR_ENVIRONMENT
block|,
name|GIT_WORK_TREE_ENVIRONMENT
block|,
name|GRAFT_ENVIRONMENT
block|,
name|INDEX_ENVIRONMENT
block|,
name|NULL
block|}
decl_stmt|;
name|conn
operator|->
name|env
operator|=
name|env
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
literal|"sh"
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
literal|"-c"
expr_stmt|;
block|}
operator|*
name|arg
operator|++
operator|=
name|cmd
operator|.
name|buf
expr_stmt|;
operator|*
name|arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
name|conn
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to fork"
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|conn
operator|->
name|out
expr_stmt|;
comment|/* read from child's stdout */
name|fd
index|[
literal|1
index|]
operator|=
name|conn
operator|->
name|in
expr_stmt|;
comment|/* write to child's stdin */
name|strbuf_release
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|conn
return|;
block|}
end_function
begin_function
DECL|function|finish_connect
name|int
name|finish_connect
parameter_list|(
name|struct
name|child_process
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|conn
operator|||
name|conn
operator|==
operator|&
name|no_fork
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|finish_command
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|conn
operator|->
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
end_unit
