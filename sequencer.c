begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"sequencer.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"rerere.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"argv-array.h"
end_include
begin_define
DECL|macro|GIT_REFLOG_ACTION
define|#
directive|define
name|GIT_REFLOG_ACTION
value|"GIT_REFLOG_ACTION"
end_define
begin_decl_stmt
DECL|variable|sign_off_header
specifier|const
name|char
name|sign_off_header
index|[]
init|=
literal|"Signed-off-by: "
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cherry_picked_prefix
specifier|static
specifier|const
name|char
name|cherry_picked_prefix
index|[]
init|=
literal|"(cherry picked from commit "
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|remove_sequencer_state
specifier|static
name|void
name|remove_sequencer_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|strbuf
name|seq_dir
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|seq_dir
argument_list|,
literal|"%s"
argument_list|,
name|git_path
argument_list|(
name|SEQ_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|remove_dir_recursively
argument_list|(
operator|&
name|seq_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|seq_dir
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|action_name
specifier|static
specifier|const
name|char
modifier|*
name|action_name
parameter_list|(
specifier|const
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
return|return
name|opts
operator|->
name|action
operator|==
name|REPLAY_REVERT
condition|?
literal|"revert"
else|:
literal|"cherry-pick"
return|;
block|}
end_function
begin_function_decl
specifier|static
name|char
modifier|*
name|get_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
function_decl|;
end_function_decl
begin_struct
DECL|struct|commit_message
struct|struct
name|commit_message
block|{
DECL|member|parent_label
name|char
modifier|*
name|parent_label
decl_stmt|;
DECL|member|label
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
DECL|member|subject
specifier|const
name|char
modifier|*
name|subject
decl_stmt|;
DECL|member|reencoded_message
name|char
modifier|*
name|reencoded_message
decl_stmt|;
DECL|member|message
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|get_message
specifier|static
name|int
name|get_message
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_message
modifier|*
name|out
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|char
modifier|*
name|abbrev
decl_stmt|,
modifier|*
name|subject
decl_stmt|;
name|int
name|abbrev_len
decl_stmt|,
name|subject_len
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|buffer
condition|)
return|return
operator|-
literal|1
return|;
name|encoding
operator|=
name|get_encoding
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
condition|)
name|encoding
operator|=
literal|"UTF-8"
expr_stmt|;
if|if
condition|(
operator|!
name|git_commit_encoding
condition|)
name|git_commit_encoding
operator|=
literal|"UTF-8"
expr_stmt|;
name|out
operator|->
name|reencoded_message
operator|=
name|NULL
expr_stmt|;
name|out
operator|->
name|message
operator|=
name|commit
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|same_encoding
argument_list|(
name|encoding
argument_list|,
name|git_commit_encoding
argument_list|)
condition|)
name|out
operator|->
name|reencoded_message
operator|=
name|reencode_string
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
name|git_commit_encoding
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|->
name|reencoded_message
condition|)
name|out
operator|->
name|message
operator|=
name|out
operator|->
name|reencoded_message
expr_stmt|;
name|abbrev
operator|=
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
expr_stmt|;
name|abbrev_len
operator|=
name|strlen
argument_list|(
name|abbrev
argument_list|)
expr_stmt|;
name|subject_len
operator|=
name|find_commit_subject
argument_list|(
name|out
operator|->
name|message
argument_list|,
operator|&
name|subject
argument_list|)
expr_stmt|;
name|out
operator|->
name|parent_label
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
literal|"parent of "
argument_list|)
operator|+
name|abbrev_len
operator|+
name|strlen
argument_list|(
literal|"... "
argument_list|)
operator|+
name|subject_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|q
operator|=
name|out
operator|->
name|parent_label
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
literal|"parent of "
argument_list|,
name|strlen
argument_list|(
literal|"parent of "
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|label
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
name|abbrev
argument_list|,
name|abbrev_len
argument_list|)
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
literal|"... "
argument_list|,
name|strlen
argument_list|(
literal|"... "
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|subject
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
name|subject
argument_list|,
name|subject_len
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|free_message
specifier|static
name|void
name|free_message
parameter_list|(
name|struct
name|commit_message
modifier|*
name|msg
parameter_list|)
block|{
name|free
argument_list|(
name|msg
operator|->
name|parent_label
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
operator|->
name|reencoded_message
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_encoding
specifier|static
name|char
modifier|*
name|get_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|message
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
block|{
for|for
control|(
name|eol
operator|=
name|p
operator|+
literal|1
init|;
operator|*
name|eol
operator|&&
operator|*
name|eol
operator|!=
literal|'\n'
condition|;
name|eol
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|p
argument_list|,
literal|"encoding "
argument_list|)
condition|)
block|{
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|eol
operator|-
literal|8
operator|-
name|p
argument_list|)
decl_stmt|;
name|strlcpy
argument_list|(
name|result
argument_list|,
name|p
operator|+
literal|9
argument_list|,
name|eol
operator|-
literal|8
operator|-
name|p
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|p
operator|=
name|eol
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|write_cherry_pick_head
specifier|static
name|void
name|write_cherry_pick_head
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|pseudoref
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
literal|"%s"
argument_list|,
name|pseudoref
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
operator|!=
name|buf
operator|.
name|len
operator|||
name|close
argument_list|(
name|fd
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|print_advice
specifier|static
name|void
name|print_advice
parameter_list|(
name|int
name|show_hint
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
name|getenv
argument_list|(
literal|"GIT_CHERRY_PICK_HELP"
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 		 * A conflict has occured but the porcelain 		 * (typically rebase --interactive) wants to take care 		 * of the commit itself so remove CHERRY_PICK_HEAD 		 */
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|show_hint
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|no_commit
condition|)
name|advise
argument_list|(
name|_
argument_list|(
literal|"after resolving the conflicts, mark the corrected paths\n"
literal|"with 'git add<paths>' or 'git rm<paths>'"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|_
argument_list|(
literal|"after resolving the conflicts, mark the corrected paths\n"
literal|"with 'git add<paths>' or 'git rm<paths>'\n"
literal|"and commit the result with 'git commit'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|write_message
specifier|static
name|void
name|write_message
parameter_list|(
name|struct
name|strbuf
modifier|*
name|msgbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|static
name|struct
name|lock_file
name|msg_file
decl_stmt|;
name|int
name|msg_fd
init|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|msg_file
argument_list|,
name|filename
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
decl_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|msg_fd
argument_list|,
name|msgbuf
operator|->
name|buf
argument_list|,
name|msgbuf
operator|->
name|len
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_lock_file
argument_list|(
operator|&
name|msg_file
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Error wrapping up %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|empty_tree
specifier|static
name|struct
name|tree
modifier|*
name|empty_tree
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|lookup_tree
argument_list|(
name|EMPTY_TREE_SHA1_BIN
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|error_dirty_index
specifier|static
name|int
name|error_dirty_index
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
if|if
condition|(
name|read_cache_unmerged
argument_list|()
condition|)
return|return
name|error_resolve_conflict
argument_list|(
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|)
return|;
comment|/* Different translation strings for cherry-pick and revert */
if|if
condition|(
name|opts
operator|->
name|action
operator|==
name|REPLAY_PICK
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Your local changes would be overwritten by cherry-pick."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|_
argument_list|(
literal|"Your local changes would be overwritten by revert."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_commit_before_merge
condition|)
name|advise
argument_list|(
name|_
argument_list|(
literal|"Commit your changes or stash them to proceed."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|fast_forward_to
specifier|static
name|int
name|fast_forward_to
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|ref_lock
modifier|*
name|ref_lock
decl_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkout_fast_forward
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* the callee should have complained already */
name|ref_lock
operator|=
name|lock_any_ref_for_update
argument_list|(
literal|"HEAD"
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|write_ref_sha1
argument_list|(
name|ref_lock
argument_list|,
name|to
argument_list|,
literal|"cherry-pick"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|do_recursive_merge
specifier|static
name|int
name|do_recursive_merge
parameter_list|(
name|struct
name|commit
modifier|*
name|base
parameter_list|,
name|struct
name|commit
modifier|*
name|next
parameter_list|,
specifier|const
name|char
modifier|*
name|base_label
parameter_list|,
specifier|const
name|char
modifier|*
name|next_label
parameter_list|,
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
name|struct
name|strbuf
modifier|*
name|msgbuf
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|merge_options
name|o
decl_stmt|;
name|struct
name|tree
modifier|*
name|result
decl_stmt|,
modifier|*
name|next_tree
decl_stmt|,
modifier|*
name|base_tree
decl_stmt|,
modifier|*
name|head_tree
decl_stmt|;
name|int
name|clean
decl_stmt|,
name|index_fd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|xopt
decl_stmt|;
specifier|static
name|struct
name|lock_file
name|index_lock
decl_stmt|;
name|index_fd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
name|init_merge_options
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|ancestor
operator|=
name|base
condition|?
name|base_label
else|:
literal|"(empty tree)"
expr_stmt|;
name|o
operator|.
name|branch1
operator|=
literal|"HEAD"
expr_stmt|;
name|o
operator|.
name|branch2
operator|=
name|next
condition|?
name|next_label
else|:
literal|"(empty tree)"
expr_stmt|;
name|head_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|next_tree
operator|=
name|next
condition|?
name|next
operator|->
name|tree
else|:
name|empty_tree
argument_list|()
expr_stmt|;
name|base_tree
operator|=
name|base
condition|?
name|base
operator|->
name|tree
else|:
name|empty_tree
argument_list|()
expr_stmt|;
for|for
control|(
name|xopt
operator|=
name|opts
operator|->
name|xopts
init|;
name|xopt
operator|!=
name|opts
operator|->
name|xopts
operator|+
name|opts
operator|->
name|xopts_nr
condition|;
name|xopt
operator|++
control|)
name|parse_merge_opt
argument_list|(
operator|&
name|o
argument_list|,
operator|*
name|xopt
argument_list|)
expr_stmt|;
name|clean
operator|=
name|merge_trees
argument_list|(
operator|&
name|o
argument_list|,
name|head_tree
argument_list|,
name|next_tree
argument_list|,
name|base_tree
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|&&
operator|(
name|write_cache
argument_list|(
name|index_fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|)
operator|)
condition|)
comment|/* TRANSLATORS: %s will be "revert" or "cherry-pick" */
name|die
argument_list|(
name|_
argument_list|(
literal|"%s: Unable to write new index file"
argument_list|)
argument_list|,
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|signoff
condition|)
name|append_signoff
argument_list|(
name|msgbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clean
condition|)
block|{
name|int
name|i
decl_stmt|;
name|strbuf_addstr
argument_list|(
name|msgbuf
argument_list|,
literal|"\nConflicts:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
block|{
name|strbuf_addch
argument_list|(
name|msgbuf
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|msgbuf
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|msgbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|active_cache
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|!
name|clean
return|;
block|}
end_function
begin_function
DECL|function|is_index_unchanged
specifier|static
name|int
name|is_index_unchanged
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|head_commit
decl_stmt|;
if|if
condition|(
operator|!
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not resolve HEAD commit\n"
argument_list|)
argument_list|)
return|;
name|head_commit
operator|=
name|lookup_commit
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
comment|/* 	 * If head_commit is NULL, check_commit, called from 	 * lookup_commit, would have indicated that head_commit is not 	 * a commit object already.  parse_commit() will return failure 	 * without further complaints in such a case.  Otherwise, if 	 * the commit is invalid, parse_commit() will complain.  So 	 * there is nothing for us to say here.  Just return failure. 	 */
if|if
condition|(
name|parse_commit
argument_list|(
name|head_commit
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|active_cache_tree
condition|)
name|active_cache_tree
operator|=
name|cache_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cache_tree_fully_valid
argument_list|(
name|active_cache_tree
argument_list|)
condition|)
if|if
condition|(
name|cache_tree_update
argument_list|(
name|active_cache_tree
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to update cache tree\n"
argument_list|)
argument_list|)
return|;
return|return
operator|!
name|hashcmp
argument_list|(
name|active_cache_tree
operator|->
name|sha1
argument_list|,
name|head_commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * If we are cherry-pick, and if the merge did not result in  * hand-editing, we will hit this commit and inherit the original  * author date and name.  * If we are revert, or if our cherry-pick results in a hand merge,  * we had better say that the current user is responsible for that.  */
end_comment
begin_function
DECL|function|run_git_commit
specifier|static
name|int
name|run_git_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|defmsg
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|,
name|int
name|allow_empty
parameter_list|)
block|{
name|struct
name|argv_array
name|array
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|argv_array_init
argument_list|(
operator|&
name|array
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|array
argument_list|,
literal|"commit"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|array
argument_list|,
literal|"-n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|signoff
condition|)
name|argv_array_push
argument_list|(
operator|&
name|array
argument_list|,
literal|"-s"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|edit
condition|)
block|{
name|argv_array_push
argument_list|(
operator|&
name|array
argument_list|,
literal|"-F"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|array
argument_list|,
name|defmsg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allow_empty
condition|)
name|argv_array_push
argument_list|(
operator|&
name|array
argument_list|,
literal|"--allow-empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|allow_empty_message
condition|)
name|argv_array_push
argument_list|(
operator|&
name|array
argument_list|,
literal|"--allow-empty-message"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|run_command_v_opt
argument_list|(
name|array
operator|.
name|argv
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
name|argv_array_clear
argument_list|(
operator|&
name|array
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|is_original_commit_empty
specifier|static
name|int
name|is_original_commit_empty
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ptree_sha1
decl_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse commit %s\n"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|commit
operator|->
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|commit
operator|->
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse parent commit %s\n"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|ptree_sha1
operator|=
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
block|}
else|else
block|{
name|ptree_sha1
operator|=
name|EMPTY_TREE_SHA1_BIN
expr_stmt|;
comment|/* commit is root */
block|}
return|return
operator|!
name|hashcmp
argument_list|(
name|ptree_sha1
argument_list|,
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Do we run "git commit" with "--allow-empty"?  */
end_comment
begin_function
DECL|function|allow_empty
specifier|static
name|int
name|allow_empty
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|index_unchanged
decl_stmt|,
name|empty_commit
decl_stmt|;
comment|/* 	 * Three cases: 	 * 	 * (1) we do not allow empty at all and error out. 	 * 	 * (2) we allow ones that were initially empty, but 	 * forbid the ones that become empty; 	 * 	 * (3) we allow both. 	 */
if|if
condition|(
operator|!
name|opts
operator|->
name|allow_empty
condition|)
return|return
literal|0
return|;
comment|/* let "git commit" barf as necessary */
name|index_unchanged
operator|=
name|is_index_unchanged
argument_list|()
expr_stmt|;
if|if
condition|(
name|index_unchanged
operator|<
literal|0
condition|)
return|return
name|index_unchanged
return|;
if|if
condition|(
operator|!
name|index_unchanged
condition|)
return|return
literal|0
return|;
comment|/* we do not have to say --allow-empty */
if|if
condition|(
name|opts
operator|->
name|keep_redundant_commits
condition|)
return|return
literal|1
return|;
name|empty_commit
operator|=
name|is_original_commit_empty
argument_list|(
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty_commit
operator|<
literal|0
condition|)
return|return
name|empty_commit
return|;
if|if
condition|(
operator|!
name|empty_commit
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|do_pick_commit
specifier|static
name|int
name|do_pick_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|unsigned
name|char
name|head
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|base
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_label
decl_stmt|,
modifier|*
name|next_label
decl_stmt|;
name|struct
name|commit_message
name|msg
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
name|defmsg
init|=
name|NULL
decl_stmt|;
name|struct
name|strbuf
name|msgbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|no_commit
condition|)
block|{
comment|/* 		 * We do not intend to commit immediately.  We just want to 		 * merge the differences in, so let's compute the tree 		 * that represents the "current" state for merge-recursive 		 * to work on. 		 */
if|if
condition|(
name|write_cache_as_tree
argument_list|(
name|head
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Your index file is unmerged."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"You do not have a valid HEAD"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|index_differs_from
argument_list|(
literal|"HEAD"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error_dirty_index
argument_list|(
name|opts
argument_list|)
return|;
block|}
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|parents
condition|)
block|{
name|parent
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commit
operator|->
name|parents
operator|->
name|next
condition|)
block|{
comment|/* Reverting or cherry-picking a merge commit */
name|int
name|cnt
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|mainline
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Commit %s is a merge but no -m option was given."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|cnt
operator|!=
name|opts
operator|->
name|mainline
operator|&&
name|p
condition|;
name|cnt
operator|++
control|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|opts
operator|->
name|mainline
operator|||
operator|!
name|p
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Commit %s does not have parent %d"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|opts
operator|->
name|mainline
argument_list|)
return|;
name|parent
operator|=
name|p
operator|->
name|item
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|<
name|opts
operator|->
name|mainline
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Mainline was specified but commit %s is not a merge."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
else|else
name|parent
operator|=
name|commit
operator|->
name|parents
operator|->
name|item
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|allow_ff
operator|&&
name|parent
operator|&&
operator|!
name|hashcmp
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head
argument_list|)
condition|)
return|return
name|fast_forward_to
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head
argument_list|)
return|;
if|if
condition|(
name|parent
operator|&&
name|parse_commit
argument_list|(
name|parent
argument_list|)
operator|<
literal|0
condition|)
comment|/* TRANSLATORS: The first %s will be "revert" or 		   "cherry-pick", the second %s a SHA1 */
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: cannot parse parent commit %s"
argument_list|)
argument_list|,
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|get_message
argument_list|(
name|commit
argument_list|,
operator|&
name|msg
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot get commit message for %s"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
comment|/* 	 * "commit" is an existing commit.  We would want to apply 	 * the difference it introduces since its first parent "prev" 	 * on top of the current HEAD if we are cherry-pick.  Or the 	 * reverse of it if we are revert. 	 */
name|defmsg
operator|=
name|git_pathdup
argument_list|(
literal|"MERGE_MSG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|action
operator|==
name|REPLAY_REVERT
condition|)
block|{
name|base
operator|=
name|commit
expr_stmt|;
name|base_label
operator|=
name|msg
operator|.
name|label
expr_stmt|;
name|next
operator|=
name|parent
expr_stmt|;
name|next_label
operator|=
name|msg
operator|.
name|parent_label
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|"Revert \""
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|msg
operator|.
name|subject
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|"\"\n\nThis reverts commit "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|parents
operator|&&
name|commit
operator|->
name|parents
operator|->
name|next
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|", reversing\nchanges made to "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|base
operator|=
name|parent
expr_stmt|;
name|base_label
operator|=
name|msg
operator|.
name|parent_label
expr_stmt|;
name|next
operator|=
name|commit
expr_stmt|;
name|next_label
operator|=
name|msg
operator|.
name|label
expr_stmt|;
comment|/* 		 * Append the commit log message to msgbuf; it starts 		 * after the tree, parent, author, committer 		 * information followed by "\n\n". 		 */
name|p
operator|=
name|strstr
argument_list|(
name|msg
operator|.
name|message
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|->
name|record_origin
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|cherry_picked_prefix
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|opts
operator|->
name|strategy
operator|||
operator|!
name|strcmp
argument_list|(
name|opts
operator|->
name|strategy
argument_list|,
literal|"recursive"
argument_list|)
operator|||
name|opts
operator|->
name|action
operator|==
name|REPLAY_REVERT
condition|)
block|{
name|res
operator|=
name|do_recursive_merge
argument_list|(
name|base
argument_list|,
name|next
argument_list|,
name|base_label
argument_list|,
name|next_label
argument_list|,
name|head
argument_list|,
operator|&
name|msgbuf
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|write_message
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|defmsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|commit_list
modifier|*
name|common
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|remotes
init|=
name|NULL
decl_stmt|;
name|write_message
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|defmsg
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|base
argument_list|,
operator|&
name|common
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|next
argument_list|,
operator|&
name|remotes
argument_list|)
expr_stmt|;
name|res
operator|=
name|try_merge_command
argument_list|(
name|opts
operator|->
name|strategy
argument_list|,
name|opts
operator|->
name|xopts_nr
argument_list|,
name|opts
operator|->
name|xopts
argument_list|,
name|common
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
argument_list|)
argument_list|,
name|remotes
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|remotes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the merge was clean or if it failed due to conflict, we write 	 * CHERRY_PICK_HEAD for the subsequent invocation of commit to use. 	 * However, if the merge did not even start, then we don't want to 	 * write it at all. 	 */
if|if
condition|(
name|opts
operator|->
name|action
operator|==
name|REPLAY_PICK
operator|&&
operator|!
name|opts
operator|->
name|no_commit
operator|&&
operator|(
name|res
operator|==
literal|0
operator|||
name|res
operator|==
literal|1
operator|)
condition|)
name|write_cherry_pick_head
argument_list|(
name|commit
argument_list|,
literal|"CHERRY_PICK_HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|action
operator|==
name|REPLAY_REVERT
operator|&&
operator|(
operator|(
name|opts
operator|->
name|no_commit
operator|&&
name|res
operator|==
literal|0
operator|)
operator|||
name|res
operator|==
literal|1
operator|)
condition|)
name|write_cherry_pick_head
argument_list|(
name|commit
argument_list|,
literal|"REVERT_HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|error
argument_list|(
name|opts
operator|->
name|action
operator|==
name|REPLAY_REVERT
condition|?
name|_
argument_list|(
literal|"could not revert %s... %s"
argument_list|)
else|:
name|_
argument_list|(
literal|"could not apply %s... %s"
argument_list|)
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|,
name|msg
operator|.
name|subject
argument_list|)
expr_stmt|;
name|print_advice
argument_list|(
name|res
operator|==
literal|1
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|rerere
argument_list|(
name|opts
operator|->
name|allow_rerere_auto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|allow
init|=
name|allow_empty
argument_list|(
name|opts
argument_list|,
name|commit
argument_list|)
decl_stmt|;
if|if
condition|(
name|allow
operator|<
literal|0
condition|)
return|return
name|allow
return|;
if|if
condition|(
operator|!
name|opts
operator|->
name|no_commit
condition|)
name|res
operator|=
name|run_git_commit
argument_list|(
name|defmsg
argument_list|,
name|opts
argument_list|,
name|allow
argument_list|)
expr_stmt|;
block|}
name|free_message
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defmsg
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|prepare_revs
specifier|static
name|void
name|prepare_revs
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
comment|/* 	 * picking (but not reverting) ranges (but not individual revisions) 	 * should be done in reverse 	 */
if|if
condition|(
name|opts
operator|->
name|action
operator|==
name|REPLAY_PICK
operator|&&
operator|!
name|opts
operator|->
name|revs
operator|->
name|no_walk
condition|)
name|opts
operator|->
name|revs
operator|->
name|reverse
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
name|opts
operator|->
name|revs
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|revs
operator|->
name|commits
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"empty commit set passed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_and_refresh_cache
specifier|static
name|void
name|read_and_refresh_cache
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
specifier|static
name|struct
name|lock_file
name|index_lock
decl_stmt|;
name|int
name|index_fd
init|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|read_index_preload
argument_list|(
operator|&
name|the_index
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git %s: failed to read the index"
argument_list|)
argument_list|,
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|refresh_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|REFRESH_QUIET
operator||
name|REFRESH_UNMERGED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_index
operator|.
name|cache_changed
condition|)
block|{
if|if
condition|(
name|write_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|index_fd
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git %s: failed to refresh the index"
argument_list|)
argument_list|,
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_todo
specifier|static
name|int
name|format_todo
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|commit_list
modifier|*
name|todo_list
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sha1_abbrev
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|action_str
init|=
name|opts
operator|->
name|action
operator|==
name|REPLAY_REVERT
condition|?
literal|"revert"
else|:
literal|"pick"
decl_stmt|;
specifier|const
name|char
modifier|*
name|subject
decl_stmt|;
name|int
name|subject_len
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|todo_list
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|sha1_abbrev
operator|=
name|find_unique_abbrev
argument_list|(
name|cur
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
expr_stmt|;
name|subject_len
operator|=
name|find_commit_subject
argument_list|(
name|cur
operator|->
name|item
operator|->
name|buffer
argument_list|,
operator|&
name|subject
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %.*s\n"
argument_list|,
name|action_str
argument_list|,
name|sha1_abbrev
argument_list|,
name|subject_len
argument_list|,
name|subject
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_insn_line
specifier|static
name|struct
name|commit
modifier|*
name|parse_insn_line
parameter_list|(
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|unsigned
name|char
name|commit_sha1
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|replay_action
name|action
decl_stmt|;
name|char
modifier|*
name|end_of_object_name
decl_stmt|;
name|int
name|saved
decl_stmt|,
name|status
decl_stmt|,
name|padding
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|bol
argument_list|,
literal|"pick"
argument_list|)
condition|)
block|{
name|action
operator|=
name|REPLAY_PICK
expr_stmt|;
name|bol
operator|+=
name|strlen
argument_list|(
literal|"pick"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|bol
argument_list|,
literal|"revert"
argument_list|)
condition|)
block|{
name|action
operator|=
name|REPLAY_REVERT
expr_stmt|;
name|bol
operator|+=
name|strlen
argument_list|(
literal|"revert"
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL
return|;
comment|/* Eat up extra spaces/ tabs before object name */
name|padding
operator|=
name|strspn
argument_list|(
name|bol
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|padding
condition|)
return|return
name|NULL
return|;
name|bol
operator|+=
name|padding
expr_stmt|;
name|end_of_object_name
operator|=
name|bol
operator|+
name|strcspn
argument_list|(
name|bol
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
name|saved
operator|=
operator|*
name|end_of_object_name
expr_stmt|;
operator|*
name|end_of_object_name
operator|=
literal|'\0'
expr_stmt|;
name|status
operator|=
name|get_sha1
argument_list|(
name|bol
argument_list|,
name|commit_sha1
argument_list|)
expr_stmt|;
operator|*
name|end_of_object_name
operator|=
name|saved
expr_stmt|;
comment|/* 	 * Verify that the action matches up with the one in 	 * opts; we don't support arbitrary instructions 	 */
if|if
condition|(
name|action
operator|!=
name|opts
operator|->
name|action
condition|)
block|{
specifier|const
name|char
modifier|*
name|action_str
decl_stmt|;
name|action_str
operator|=
name|action
operator|==
name|REPLAY_REVERT
condition|?
literal|"revert"
else|:
literal|"cherry-pick"
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot %s during a %s"
argument_list|)
argument_list|,
name|action_str
argument_list|,
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|lookup_commit_reference
argument_list|(
name|commit_sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_insn_buffer
specifier|static
name|int
name|parse_insn_buffer
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|todo_list
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
modifier|*
name|next
init|=
name|todo_list
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|p
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|eol
init|=
name|strchrnul
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|commit
operator|=
name|parse_insn_line
argument_list|(
name|p
argument_list|,
name|eol
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse line %d."
argument_list|)
argument_list|,
name|i
argument_list|)
return|;
name|next
operator|=
name|commit_list_append
argument_list|(
name|commit
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|eol
condition|?
name|eol
operator|+
literal|1
else|:
name|eol
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|todo_list
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"No commits parsed."
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_populate_todo
specifier|static
name|void
name|read_populate_todo
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|todo_list
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|todo_file
init|=
name|git_path
argument_list|(
name|SEQ_TODO_FILE
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|res
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|todo_file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open %s"
argument_list|)
argument_list|,
name|todo_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|buf
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"Could not read %s."
argument_list|)
argument_list|,
name|todo_file
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|res
operator|=
name|parse_insn_buffer
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|todo_list
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unusable instruction sheet: %s"
argument_list|)
argument_list|,
name|todo_file
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|populate_opts_cb
specifier|static
name|int
name|populate_opts_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|replay_opts
modifier|*
name|opts
init|=
name|data
decl_stmt|;
name|int
name|error_flag
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|error_flag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.no-commit"
argument_list|)
condition|)
name|opts
operator|->
name|no_commit
operator|=
name|git_config_bool_or_int
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.edit"
argument_list|)
condition|)
name|opts
operator|->
name|edit
operator|=
name|git_config_bool_or_int
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.signoff"
argument_list|)
condition|)
name|opts
operator|->
name|signoff
operator|=
name|git_config_bool_or_int
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.record-origin"
argument_list|)
condition|)
name|opts
operator|->
name|record_origin
operator|=
name|git_config_bool_or_int
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.allow-ff"
argument_list|)
condition|)
name|opts
operator|->
name|allow_ff
operator|=
name|git_config_bool_or_int
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.mainline"
argument_list|)
condition|)
name|opts
operator|->
name|mainline
operator|=
name|git_config_int
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.strategy"
argument_list|)
condition|)
name|git_config_string
argument_list|(
operator|&
name|opts
operator|->
name|strategy
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"options.strategy-option"
argument_list|)
condition|)
block|{
name|ALLOC_GROW
argument_list|(
name|opts
operator|->
name|xopts
argument_list|,
name|opts
operator|->
name|xopts_nr
operator|+
literal|1
argument_list|,
name|opts
operator|->
name|xopts_alloc
argument_list|)
expr_stmt|;
name|opts
operator|->
name|xopts
index|[
name|opts
operator|->
name|xopts_nr
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid key: %s"
argument_list|)
argument_list|,
name|key
argument_list|)
return|;
if|if
condition|(
operator|!
name|error_flag
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid value for %s: %s"
argument_list|)
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_populate_opts
specifier|static
name|void
name|read_populate_opts
parameter_list|(
name|struct
name|replay_opts
modifier|*
modifier|*
name|opts_ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opts_file
init|=
name|git_path
argument_list|(
name|SEQ_OPTS_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|opts_file
argument_list|)
condition|)
return|return;
if|if
condition|(
name|git_config_from_file
argument_list|(
name|populate_opts_cb
argument_list|,
name|opts_file
argument_list|,
operator|*
name|opts_ptr
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Malformed options sheet: %s"
argument_list|)
argument_list|,
name|opts_file
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|walk_revs_populate_todo
specifier|static
name|void
name|walk_revs_populate_todo
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|todo_list
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|next
decl_stmt|;
name|prepare_revs
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|next
operator|=
name|todo_list
expr_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
name|opts
operator|->
name|revs
argument_list|)
operator|)
condition|)
name|next
operator|=
name|commit_list_append
argument_list|(
name|commit
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|create_seq_dir
specifier|static
name|int
name|create_seq_dir
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|seq_dir
init|=
name|git_path
argument_list|(
name|SEQ_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|seq_dir
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"a cherry-pick or revert is already in progress"
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|_
argument_list|(
literal|"try \"git cherry-pick (--continue | --quit | --abort)\""
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|mkdir
argument_list|(
name|seq_dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not create sequencer directory %s"
argument_list|)
argument_list|,
name|seq_dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|save_head
specifier|static
name|void
name|save_head
parameter_list|(
specifier|const
name|char
modifier|*
name|head
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|head_file
init|=
name|git_path
argument_list|(
name|SEQ_HEAD_FILE
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|lock_file
name|head_lock
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|head_lock
argument_list|,
name|head_file
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to %s"
argument_list|)
argument_list|,
name|head_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_lock_file
argument_list|(
operator|&
name|head_lock
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Error wrapping up %s."
argument_list|)
argument_list|,
name|head_file
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reset_for_rollback
specifier|static
name|int
name|reset_for_rollback
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
comment|/* reset --merge<arg> + NULL */
name|argv
index|[
literal|0
index|]
operator|=
literal|"reset"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
literal|"--merge"
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|run_command_v_opt
argument_list|(
name|argv
argument_list|,
name|RUN_GIT_CMD
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|rollback_single_pick
specifier|static
name|int
name|rollback_single_pick
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
operator|&&
operator|!
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"REVERT_HEAD"
argument_list|)
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"no cherry-pick or revert in progress"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|read_ref_full
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot resolve HEAD"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|head_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot abort from a branch yet to be born"
argument_list|)
argument_list|)
return|;
return|return
name|reset_for_rollback
argument_list|(
name|head_sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sequencer_rollback
specifier|static
name|int
name|sequencer_rollback
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
name|SEQ_HEAD_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* 		 * There is no multiple-cherry-pick in progress. 		 * If CHERRY_PICK_HEAD or REVERT_HEAD indicates 		 * a single-cherry-pick in progress, abort that. 		 */
return|return
name|rollback_single_pick
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot open %s: %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|buf
argument_list|,
name|f
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot read %s: %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|ferror
argument_list|(
name|f
argument_list|)
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
name|_
argument_list|(
literal|"unexpected end of file"
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|sha1
argument_list|)
operator|||
name|buf
operator|.
name|buf
index|[
literal|40
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"stored pre-cherry-pick HEAD file '%s' is corrupt"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|reset_for_rollback
argument_list|(
name|sha1
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|remove_sequencer_state
argument_list|()
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|save_todo
specifier|static
name|void
name|save_todo
parameter_list|(
name|struct
name|commit_list
modifier|*
name|todo_list
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|todo_file
init|=
name|git_path
argument_list|(
name|SEQ_TODO_FILE
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|lock_file
name|todo_lock
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|todo_lock
argument_list|,
name|todo_file
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_todo
argument_list|(
operator|&
name|buf
argument_list|,
name|todo_list
argument_list|,
name|opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Could not format %s."
argument_list|)
argument_list|,
name|todo_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to %s"
argument_list|)
argument_list|,
name|todo_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit_lock_file
argument_list|(
operator|&
name|todo_lock
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"Error wrapping up %s."
argument_list|)
argument_list|,
name|todo_file
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|save_opts
specifier|static
name|void
name|save_opts
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opts_file
init|=
name|git_path
argument_list|(
name|SEQ_OPTS_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|no_commit
condition|)
name|git_config_set_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.no-commit"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|edit
condition|)
name|git_config_set_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.edit"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|signoff
condition|)
name|git_config_set_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.signoff"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|record_origin
condition|)
name|git_config_set_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.record-origin"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|allow_ff
condition|)
name|git_config_set_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.allow-ff"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|mainline
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|opts
operator|->
name|mainline
argument_list|)
expr_stmt|;
name|git_config_set_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.mainline"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|->
name|strategy
condition|)
name|git_config_set_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.strategy"
argument_list|,
name|opts
operator|->
name|strategy
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|xopts
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opts
operator|->
name|xopts_nr
condition|;
name|i
operator|++
control|)
name|git_config_set_multivar_in_file
argument_list|(
name|opts_file
argument_list|,
literal|"options.strategy-option"
argument_list|,
name|opts
operator|->
name|xopts
index|[
name|i
index|]
argument_list|,
literal|"^$"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pick_commits
specifier|static
name|int
name|pick_commits
parameter_list|(
name|struct
name|commit_list
modifier|*
name|todo_list
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|cur
decl_stmt|;
name|int
name|res
decl_stmt|;
name|setenv
argument_list|(
name|GIT_REFLOG_ACTION
argument_list|,
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|allow_ff
condition|)
name|assert
argument_list|(
operator|!
operator|(
name|opts
operator|->
name|signoff
operator|||
name|opts
operator|->
name|no_commit
operator|||
name|opts
operator|->
name|record_origin
operator|||
name|opts
operator|->
name|edit
operator|)
argument_list|)
expr_stmt|;
name|read_and_refresh_cache
argument_list|(
name|opts
argument_list|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|todo_list
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|save_todo
argument_list|(
name|cur
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|res
operator|=
name|do_pick_commit
argument_list|(
name|cur
operator|->
name|item
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
block|}
comment|/* 	 * Sequence of picks finished successfully; cleanup by 	 * removing the .git/sequencer directory 	 */
name|remove_sequencer_state
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|continue_single_pick
specifier|static
name|int
name|continue_single_pick
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|argv
index|[]
init|=
block|{
literal|"commit"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
operator|&&
operator|!
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"REVERT_HEAD"
argument_list|)
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"no cherry-pick or revert in progress"
argument_list|)
argument_list|)
return|;
return|return
name|run_command_v_opt
argument_list|(
name|argv
argument_list|,
name|RUN_GIT_CMD
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sequencer_continue
specifier|static
name|int
name|sequencer_continue
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|todo_list
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|git_path
argument_list|(
name|SEQ_TODO_FILE
argument_list|)
argument_list|)
condition|)
return|return
name|continue_single_pick
argument_list|()
return|;
name|read_populate_opts
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|read_populate_todo
argument_list|(
operator|&
name|todo_list
argument_list|,
name|opts
argument_list|)
expr_stmt|;
comment|/* Verify that the conflict has been resolved */
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
operator|||
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"REVERT_HEAD"
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|ret
init|=
name|continue_single_pick
argument_list|()
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|index_differs_from
argument_list|(
literal|"HEAD"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error_dirty_index
argument_list|(
name|opts
argument_list|)
return|;
name|todo_list
operator|=
name|todo_list
operator|->
name|next
expr_stmt|;
return|return
name|pick_commits
argument_list|(
name|todo_list
argument_list|,
name|opts
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|single_pick
specifier|static
name|int
name|single_pick
parameter_list|(
name|struct
name|commit
modifier|*
name|cmit
parameter_list|,
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|setenv
argument_list|(
name|GIT_REFLOG_ACTION
argument_list|,
name|action_name
argument_list|(
name|opts
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|do_pick_commit
argument_list|(
name|cmit
argument_list|,
name|opts
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sequencer_pick_revisions
name|int
name|sequencer_pick_revisions
parameter_list|(
name|struct
name|replay_opts
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|todo_list
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|subcommand
operator|==
name|REPLAY_NONE
condition|)
name|assert
argument_list|(
name|opts
operator|->
name|revs
argument_list|)
expr_stmt|;
name|read_and_refresh_cache
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/* 	 * Decide what to do depending on the arguments; a fresh 	 * cherry-pick should be handled differently from an existing 	 * one that is being continued 	 */
if|if
condition|(
name|opts
operator|->
name|subcommand
operator|==
name|REPLAY_REMOVE_STATE
condition|)
block|{
name|remove_sequencer_state
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|opts
operator|->
name|subcommand
operator|==
name|REPLAY_ROLLBACK
condition|)
return|return
name|sequencer_rollback
argument_list|(
name|opts
argument_list|)
return|;
if|if
condition|(
name|opts
operator|->
name|subcommand
operator|==
name|REPLAY_CONTINUE
condition|)
return|return
name|sequencer_continue
argument_list|(
name|opts
argument_list|)
return|;
comment|/* 	 * If we were called as "git cherry-pick<commit>", just 	 * cherry-pick/revert it, set CHERRY_PICK_HEAD / 	 * REVERT_HEAD, and don't touch the sequencer state. 	 * This means it is possible to cherry-pick in the middle 	 * of a cherry-pick sequence. 	 */
if|if
condition|(
name|opts
operator|->
name|revs
operator|->
name|cmdline
operator|.
name|nr
operator|==
literal|1
operator|&&
name|opts
operator|->
name|revs
operator|->
name|cmdline
operator|.
name|rev
operator|->
name|whence
operator|==
name|REV_CMD_REV
operator|&&
name|opts
operator|->
name|revs
operator|->
name|no_walk
operator|&&
operator|!
name|opts
operator|->
name|revs
operator|->
name|cmdline
operator|.
name|rev
operator|->
name|flags
condition|)
block|{
name|struct
name|commit
modifier|*
name|cmit
decl_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
name|opts
operator|->
name|revs
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
name|cmit
operator|=
name|get_revision
argument_list|(
name|opts
operator|->
name|revs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmit
operator|||
name|get_revision
argument_list|(
name|opts
operator|->
name|revs
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: expected exactly one commit from walk"
argument_list|)
expr_stmt|;
return|return
name|single_pick
argument_list|(
name|cmit
argument_list|,
name|opts
argument_list|)
return|;
block|}
comment|/* 	 * Start a new cherry-pick/ revert sequence; but 	 * first, make sure that an existing one isn't in 	 * progress 	 */
name|walk_revs_populate_todo
argument_list|(
operator|&
name|todo_list
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|create_seq_dir
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|action
operator|==
name|REPLAY_REVERT
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Can't revert as initial commit"
argument_list|)
argument_list|)
return|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Can't cherry-pick into empty head"
argument_list|)
argument_list|)
return|;
block|}
name|save_head
argument_list|(
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|save_opts
argument_list|(
name|opts
argument_list|)
expr_stmt|;
return|return
name|pick_commits
argument_list|(
name|todo_list
argument_list|,
name|opts
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|is_rfc2822_line
specifier|static
name|int
name|is_rfc2822_line
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|buf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|&&
name|ch
operator|!=
literal|'-'
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_cherry_picked_from_line
specifier|static
name|int
name|is_cherry_picked_from_line
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* 	 * We only care that it looks roughly like (cherry picked from ...) 	 */
return|return
name|len
operator|>
name|strlen
argument_list|(
name|cherry_picked_prefix
argument_list|)
operator|+
literal|1
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|buf
argument_list|,
name|cherry_picked_prefix
argument_list|)
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|')'
return|;
block|}
end_function
begin_function
DECL|function|has_conforming_footer
specifier|static
name|int
name|has_conforming_footer
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|ignore_footer
parameter_list|)
block|{
name|char
name|prev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|len
init|=
name|sb
operator|->
name|len
operator|-
name|ignore_footer
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
name|sb
operator|->
name|buf
decl_stmt|;
comment|/* footer must end with newline */
if|if
condition|(
operator|!
name|len
operator|||
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
return|return
literal|0
return|;
name|prev
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
name|ch
init|=
name|buf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|prev
operator|==
literal|'\n'
operator|&&
name|ch
operator|==
literal|'\n'
condition|)
comment|/* paragraph break */
break|break;
name|prev
operator|=
name|ch
expr_stmt|;
block|}
comment|/* require at least one blank line */
if|if
condition|(
name|prev
operator|!=
literal|'\n'
operator|||
name|buf
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|)
return|return
literal|0
return|;
comment|/* advance to start of last paragraph */
while|while
condition|(
name|i
operator|<
name|len
operator|-
literal|1
operator|&&
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|=
name|k
control|)
block|{
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|len
operator|&&
name|buf
index|[
name|k
index|]
operator|!=
literal|'\n'
condition|;
name|k
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|is_rfc2822_line
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|k
operator|-
name|i
operator|-
literal|1
argument_list|)
operator|&&
operator|!
name|is_cherry_picked_from_line
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|k
operator|-
name|i
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|append_signoff
name|void
name|append_signoff
parameter_list|(
name|struct
name|strbuf
modifier|*
name|msgbuf
parameter_list|,
name|int
name|ignore_footer
parameter_list|)
block|{
name|struct
name|strbuf
name|sob
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|i
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sob
argument_list|,
name|sign_off_header
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sob
argument_list|,
name|fmt_name
argument_list|(
name|getenv
argument_list|(
literal|"GIT_COMMITTER_NAME"
argument_list|)
argument_list|,
name|getenv
argument_list|(
literal|"GIT_COMMITTER_EMAIL"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sob
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|msgbuf
operator|->
name|len
operator|-
literal|1
operator|-
name|ignore_footer
init|;
name|i
operator|>
literal|0
operator|&&
name|msgbuf
operator|->
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|--
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|prefixcmp
argument_list|(
name|msgbuf
operator|->
name|buf
operator|+
name|i
argument_list|,
name|sob
operator|.
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|has_conforming_footer
argument_list|(
name|msgbuf
argument_list|,
name|ignore_footer
argument_list|)
condition|)
name|strbuf_splice
argument_list|(
name|msgbuf
argument_list|,
name|msgbuf
operator|->
name|len
operator|-
name|ignore_footer
argument_list|,
literal|0
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_splice
argument_list|(
name|msgbuf
argument_list|,
name|msgbuf
operator|->
name|len
operator|-
name|ignore_footer
argument_list|,
literal|0
argument_list|,
name|sob
operator|.
name|buf
argument_list|,
name|sob
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sob
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
