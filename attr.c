begin_unit
begin_comment
comment|/*  * Handle git attributes.  See gitattributes(5) for a description of  * the file syntax, and Documentation/technical/api-gitattributes.txt  * for a description of the API.  *  * One basic design decision here is that we are not going to support  * an insanely large number of attributes.  */
end_comment
begin_define
DECL|macro|NO_THE_INDEX_COMPATIBILITY_MACROS
define|#
directive|define
name|NO_THE_INDEX_COMPATIBILITY_MACROS
end_define
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"attr.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_decl_stmt
DECL|variable|git_attr__true
specifier|const
name|char
name|git_attr__true
index|[]
init|=
literal|"(builtin)true"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_attr__false
specifier|const
name|char
name|git_attr__false
index|[]
init|=
literal|"\0(builtin)false"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_attr__unknown
specifier|static
specifier|const
name|char
name|git_attr__unknown
index|[]
init|=
literal|"(builtin)unknown"
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|ATTR__TRUE
define|#
directive|define
name|ATTR__TRUE
value|git_attr__true
end_define
begin_define
DECL|macro|ATTR__FALSE
define|#
directive|define
name|ATTR__FALSE
value|git_attr__false
end_define
begin_define
DECL|macro|ATTR__UNSET
define|#
directive|define
name|ATTR__UNSET
value|NULL
end_define
begin_define
DECL|macro|ATTR__UNKNOWN
define|#
directive|define
name|ATTR__UNKNOWN
value|git_attr__unknown
end_define
begin_comment
comment|/* This is a randomly chosen prime. */
end_comment
begin_define
DECL|macro|HASHSIZE
define|#
directive|define
name|HASHSIZE
value|257
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ATTR
end_ifndef
begin_define
DECL|macro|DEBUG_ATTR
define|#
directive|define
name|DEBUG_ATTR
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|git_attr
struct|struct
name|git_attr
block|{
DECL|member|next
name|struct
name|git_attr
modifier|*
name|next
decl_stmt|;
DECL|member|h
name|unsigned
name|h
decl_stmt|;
DECL|member|attr_nr
name|int
name|attr_nr
decl_stmt|;
DECL|member|name
name|char
name|name
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|attr_nr
specifier|static
name|int
name|attr_nr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|check_all_attr
specifier|static
name|struct
name|git_attr_check
modifier|*
name|check_all_attr
decl_stmt|;
end_decl_stmt
begin_function_decl
DECL|variable|git_attr_hash
specifier|static
name|struct
name|git_attr
modifier|*
function_decl|(
name|git_attr_hash
function_decl|[
name|HASHSIZE
function_decl|]
end_function_decl
begin_empty_stmt
DECL|variable|git_attr_hash
unit|)
empty_stmt|;
end_empty_stmt
begin_function
DECL|function|git_attr_name
name|char
modifier|*
name|git_attr_name
parameter_list|(
name|struct
name|git_attr
modifier|*
name|attr
parameter_list|)
block|{
return|return
name|attr
operator|->
name|name
return|;
block|}
end_function
begin_function
DECL|function|hash_name
specifier|static
name|unsigned
name|hash_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|unsigned
name|val
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
name|namelen
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|name
operator|++
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|<<
literal|7
operator|)
operator||
operator|(
name|val
operator|>>
literal|22
operator|)
operator|)
operator|^
name|c
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_function
DECL|function|invalid_attr_name
specifier|static
name|int
name|invalid_attr_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
comment|/* 	 * Attribute name cannot begin with '-' and must consist of 	 * characters from [-A-Za-z0-9_.]. 	 */
if|if
condition|(
name|namelen
operator|<=
literal|0
operator|||
operator|*
name|name
operator|==
literal|'-'
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|namelen
operator|--
condition|)
block|{
name|char
name|ch
init|=
operator|*
name|name
operator|++
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'.'
operator|||
name|ch
operator|==
literal|'_'
operator|||
operator|(
literal|'0'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
literal|'a'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_attr_internal
specifier|static
name|struct
name|git_attr
modifier|*
name|git_attr_internal
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|hval
init|=
name|hash_name
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|unsigned
name|pos
init|=
name|hval
operator|%
name|HASHSIZE
decl_stmt|;
name|struct
name|git_attr
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|git_attr_hash
index|[
name|pos
index|]
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
if|if
condition|(
name|a
operator|->
name|h
operator|==
name|hval
operator|&&
operator|!
name|memcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|a
operator|->
name|name
index|[
name|len
index|]
condition|)
return|return
name|a
return|;
block|}
if|if
condition|(
name|invalid_attr_name
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
name|a
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|h
operator|=
name|hval
expr_stmt|;
name|a
operator|->
name|next
operator|=
name|git_attr_hash
index|[
name|pos
index|]
expr_stmt|;
name|a
operator|->
name|attr_nr
operator|=
name|attr_nr
operator|++
expr_stmt|;
name|git_attr_hash
index|[
name|pos
index|]
operator|=
name|a
expr_stmt|;
name|check_all_attr
operator|=
name|xrealloc
argument_list|(
name|check_all_attr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|check_all_attr
argument_list|)
operator|*
name|attr_nr
argument_list|)
expr_stmt|;
name|check_all_attr
index|[
name|a
operator|->
name|attr_nr
index|]
operator|.
name|attr
operator|=
name|a
expr_stmt|;
name|check_all_attr
index|[
name|a
operator|->
name|attr_nr
index|]
operator|.
name|value
operator|=
name|ATTR__UNKNOWN
expr_stmt|;
return|return
name|a
return|;
block|}
end_function
begin_function
DECL|function|git_attr
name|struct
name|git_attr
modifier|*
name|git_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|git_attr_internal
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* What does a matched pattern decide? */
end_comment
begin_struct
DECL|struct|attr_state
struct|struct
name|attr_state
block|{
DECL|member|attr
name|struct
name|git_attr
modifier|*
name|attr
decl_stmt|;
DECL|member|setto
specifier|const
name|char
modifier|*
name|setto
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * One rule, as from a .gitattributes file.  *  * If is_macro is true, then u.attr is a pointer to the git_attr being  * defined.  *  * If is_macro is false, then u.pattern points at the filename pattern  * to which the rule applies.  (The memory pointed to is part of the  * memory block allocated for the match_attr instance.)  *  * In either case, num_attr is the number of attributes affected by  * this rule, and state is an array listing them.  The attributes are  * listed as they appear in the file (macros unexpanded).  */
end_comment
begin_struct
DECL|struct|match_attr
struct|struct
name|match_attr
block|{
union|union
block|{
DECL|member|pattern
name|char
modifier|*
name|pattern
decl_stmt|;
DECL|member|attr
name|struct
name|git_attr
modifier|*
name|attr
decl_stmt|;
block|}
DECL|member|u
name|u
union|;
DECL|member|is_macro
name|char
name|is_macro
decl_stmt|;
DECL|member|num_attr
name|unsigned
name|num_attr
decl_stmt|;
DECL|member|state
name|struct
name|attr_state
name|state
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|blank
specifier|static
specifier|const
name|char
name|blank
index|[]
init|=
literal|" \t\r\n"
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Parse a whitespace-delimited attribute state (i.e., "attr",  * "-attr", "!attr", or "attr=value") from the string starting at src.  * If e is not NULL, write the results to *e.  Return a pointer to the  * remainder of the string (with leading whitespace removed), or NULL  * if there was an error.  */
end_comment
begin_function
DECL|function|parse_attr
specifier|static
specifier|const
name|char
modifier|*
name|parse_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|attr_state
modifier|*
name|e
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|equals
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ep
operator|=
name|cp
operator|+
name|strcspn
argument_list|(
name|cp
argument_list|,
name|blank
argument_list|)
expr_stmt|;
name|equals
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|equals
operator|&&
name|ep
operator|<
name|equals
condition|)
name|equals
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|equals
condition|)
name|len
operator|=
name|equals
operator|-
name|cp
expr_stmt|;
else|else
name|len
operator|=
name|ep
operator|-
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
operator|||
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|invalid_attr_name
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.*s is not a valid attribute name: %s:%d\n"
argument_list|,
name|len
argument_list|,
name|cp
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
operator|||
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|e
operator|->
name|setto
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|?
name|ATTR__FALSE
else|:
name|ATTR__UNSET
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|equals
condition|)
name|e
operator|->
name|setto
operator|=
name|ATTR__TRUE
expr_stmt|;
else|else
block|{
name|e
operator|->
name|setto
operator|=
name|xmemdupz
argument_list|(
name|equals
operator|+
literal|1
argument_list|,
name|ep
operator|-
name|equals
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|attr
operator|=
name|git_attr_internal
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|ep
operator|+
name|strspn
argument_list|(
name|ep
argument_list|,
name|blank
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_attr_line
specifier|static
name|struct
name|match_attr
modifier|*
name|parse_attr_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|lineno
parameter_list|,
name|int
name|macro_ok
parameter_list|)
block|{
name|int
name|namelen
decl_stmt|;
name|int
name|num_attr
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|states
decl_stmt|;
name|struct
name|match_attr
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|is_macro
decl_stmt|;
name|cp
operator|=
name|line
operator|+
name|strspn
argument_list|(
name|line
argument_list|,
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|||
operator|*
name|cp
operator|==
literal|'#'
condition|)
return|return
name|NULL
return|;
name|name
operator|=
name|cp
expr_stmt|;
name|namelen
operator|=
name|strcspn
argument_list|(
name|name
argument_list|,
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ATTRIBUTE_MACRO_PREFIX
argument_list|)
operator|<
name|namelen
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
name|ATTRIBUTE_MACRO_PREFIX
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|macro_ok
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s not allowed: %s:%d\n"
argument_list|,
name|name
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|is_macro
operator|=
literal|1
expr_stmt|;
name|name
operator|+=
name|strlen
argument_list|(
name|ATTRIBUTE_MACRO_PREFIX
argument_list|)
expr_stmt|;
name|name
operator|+=
name|strspn
argument_list|(
name|name
argument_list|,
name|blank
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strcspn
argument_list|(
name|name
argument_list|,
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalid_attr_name
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.*s is not a valid attribute name: %s:%d\n"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
name|is_macro
operator|=
literal|0
expr_stmt|;
name|states
operator|=
name|name
operator|+
name|namelen
expr_stmt|;
name|states
operator|+=
name|strspn
argument_list|(
name|states
argument_list|,
name|blank
argument_list|)
expr_stmt|;
comment|/* First pass to count the attr_states */
for|for
control|(
name|cp
operator|=
name|states
operator|,
name|num_attr
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|num_attr
operator|++
control|)
block|{
name|cp
operator|=
name|parse_attr
argument_list|(
name|src
argument_list|,
name|lineno
argument_list|,
name|cp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|NULL
return|;
block|}
name|res
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|attr_state
argument_list|)
operator|*
name|num_attr
operator|+
operator|(
name|is_macro
condition|?
literal|0
else|:
name|namelen
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_macro
condition|)
name|res
operator|->
name|u
operator|.
name|attr
operator|=
name|git_attr_internal
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
else|else
block|{
name|res
operator|->
name|u
operator|.
name|pattern
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|res
operator|->
name|state
index|[
name|num_attr
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|u
operator|.
name|pattern
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|pattern
index|[
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|res
operator|->
name|is_macro
operator|=
name|is_macro
expr_stmt|;
name|res
operator|->
name|num_attr
operator|=
name|num_attr
expr_stmt|;
comment|/* Second pass to fill the attr_states */
for|for
control|(
name|cp
operator|=
name|states
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
name|parse_attr
argument_list|(
name|src
argument_list|,
name|lineno
argument_list|,
name|cp
argument_list|,
operator|&
operator|(
name|res
operator|->
name|state
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_comment
comment|/*  * Like info/exclude and .gitignore, the attribute information can  * come from many places.  *  * (1) .gitattribute file of the same directory;  * (2) .gitattribute file of the parent directory if (1) does not have  *      any match; this goes recursively upwards, just like .gitignore.  * (3) $GIT_DIR/info/attributes, which overrides both of the above.  *  * In the same file, later entries override the earlier match, so in the  * global list, we would have entries from info/attributes the earliest  * (reading the file from top to bottom), .gitattribute of the root  * directory (again, reading the file from top to bottom) down to the  * current directory, and then scan the list backwards to find the first match.  * This is exactly the same as what excluded() does in dir.c to deal with  * .gitignore  */
end_comment
begin_struct
DECL|struct|attr_stack
specifier|static
struct|struct
name|attr_stack
block|{
DECL|member|prev
name|struct
name|attr_stack
modifier|*
name|prev
decl_stmt|;
DECL|member|origin
name|char
modifier|*
name|origin
decl_stmt|;
DECL|member|num_matches
name|unsigned
name|num_matches
decl_stmt|;
DECL|member|alloc
name|unsigned
name|alloc
decl_stmt|;
DECL|member|attrs
name|struct
name|match_attr
modifier|*
modifier|*
name|attrs
decl_stmt|;
block|}
DECL|variable|attr_stack
modifier|*
name|attr_stack
struct|;
end_struct
begin_function
DECL|function|free_attr_elem
specifier|static
name|void
name|free_attr_elem
parameter_list|(
name|struct
name|attr_stack
modifier|*
name|e
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|e
operator|->
name|origin
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|match_attr
modifier|*
name|a
init|=
name|e
operator|->
name|attrs
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|a
operator|->
name|num_attr
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|setto
init|=
name|a
operator|->
name|state
index|[
name|j
index|]
operator|.
name|setto
decl_stmt|;
if|if
condition|(
name|setto
operator|==
name|ATTR__TRUE
operator|||
name|setto
operator|==
name|ATTR__FALSE
operator|||
name|setto
operator|==
name|ATTR__UNSET
operator|||
name|setto
operator|==
name|ATTR__UNKNOWN
condition|)
empty_stmt|;
else|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|setto
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|e
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|builtin_attr
specifier|static
specifier|const
name|char
modifier|*
name|builtin_attr
index|[]
init|=
block|{
literal|"[attr]binary -diff -merge -text"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|handle_attr_line
specifier|static
name|void
name|handle_attr_line
parameter_list|(
name|struct
name|attr_stack
modifier|*
name|res
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|lineno
parameter_list|,
name|int
name|macro_ok
parameter_list|)
block|{
name|struct
name|match_attr
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|parse_attr_line
argument_list|(
name|line
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
return|return;
if|if
condition|(
name|res
operator|->
name|alloc
operator|<=
name|res
operator|->
name|num_matches
condition|)
block|{
name|res
operator|->
name|alloc
operator|=
name|alloc_nr
argument_list|(
name|res
operator|->
name|num_matches
argument_list|)
expr_stmt|;
name|res
operator|->
name|attrs
operator|=
name|xrealloc
argument_list|(
name|res
operator|->
name|attrs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|match_attr
operator|*
argument_list|)
operator|*
name|res
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|attrs
index|[
name|res
operator|->
name|num_matches
operator|++
index|]
operator|=
name|a
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_attr_from_array
specifier|static
name|struct
name|attr_stack
modifier|*
name|read_attr_from_array
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|attr_stack
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
operator|*
operator|(
name|list
operator|++
operator|)
operator|)
operator|!=
name|NULL
condition|)
name|handle_attr_line
argument_list|(
name|res
argument_list|,
name|line
argument_list|,
literal|"[builtin]"
argument_list|,
operator|++
name|lineno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|direction
specifier|static
name|enum
name|git_attr_direction
name|direction
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_index
specifier|static
name|struct
name|index_state
modifier|*
name|use_index
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|read_attr_from_file
specifier|static
name|struct
name|attr_stack
modifier|*
name|read_attr_from_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|macro_ok
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|struct
name|attr_stack
modifier|*
name|res
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|NULL
return|;
name|res
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
name|handle_attr_line
argument_list|(
name|res
argument_list|,
name|buf
argument_list|,
name|path
argument_list|,
operator|++
name|lineno
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|read_index_data
specifier|static
name|void
modifier|*
name|read_index_data
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|pos
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|index_state
modifier|*
name|istate
init|=
name|use_index
condition|?
name|use_index
else|:
operator|&
name|the_index
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|pos
operator|=
name|index_name_pos
argument_list|(
name|istate
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
comment|/* 		 * We might be in the middle of a merge, in which 		 * case we would read stage #2 (ours). 		 */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|pos
operator|-
literal|1
init|;
operator|(
name|pos
operator|<
literal|0
operator|&&
name|i
operator|<
name|istate
operator|->
name|cache_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|istate
operator|->
name|cache
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|path
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ce_stage
argument_list|(
name|istate
operator|->
name|cache
index|[
name|i
index|]
argument_list|)
operator|==
literal|2
condition|)
name|pos
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|data
operator|=
name|read_sha1_file
argument_list|(
name|istate
operator|->
name|cache
index|[
name|pos
index|]
operator|->
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
name|type
operator|!=
name|OBJ_BLOB
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|read_attr_from_index
specifier|static
name|struct
name|attr_stack
modifier|*
name|read_attr_from_index
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|macro_ok
parameter_list|)
block|{
name|struct
name|attr_stack
modifier|*
name|res
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|buf
operator|=
name|read_index_data
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|NULL
return|;
name|res
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|buf
init|;
operator|*
name|sp
condition|;
control|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|more
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|sp
init|;
operator|*
name|ep
operator|&&
operator|*
name|ep
operator|!=
literal|'\n'
condition|;
name|ep
operator|++
control|)
empty_stmt|;
name|more
operator|=
operator|(
operator|*
name|ep
operator|==
literal|'\n'
operator|)
expr_stmt|;
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
name|handle_attr_line
argument_list|(
name|res
argument_list|,
name|sp
argument_list|,
name|path
argument_list|,
operator|++
name|lineno
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
name|sp
operator|=
name|ep
operator|+
name|more
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|read_attr
specifier|static
name|struct
name|attr_stack
modifier|*
name|read_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|macro_ok
parameter_list|)
block|{
name|struct
name|attr_stack
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|GIT_ATTR_CHECKOUT
condition|)
block|{
name|res
operator|=
name|read_attr_from_index
argument_list|(
name|path
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
name|res
operator|=
name|read_attr_from_file
argument_list|(
name|path
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|direction
operator|==
name|GIT_ATTR_CHECKIN
condition|)
block|{
name|res
operator|=
name|read_attr_from_file
argument_list|(
name|path
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
comment|/* 			 * There is no checked out .gitattributes file there, but 			 * we might have it in the index.  We allow operation in a 			 * sparsely checked out work tree, so read from it. 			 */
name|res
operator|=
name|read_attr_from_index
argument_list|(
name|path
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|read_attr_from_index
argument_list|(
name|path
argument_list|,
name|macro_ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
name|res
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_if
if|#
directive|if
name|DEBUG_ATTR
end_if
begin_function
DECL|function|debug_info
specifier|static
name|void
name|debug_info
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|struct
name|attr_stack
modifier|*
name|elem
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|what
argument_list|,
name|elem
operator|->
name|origin
condition|?
name|elem
operator|->
name|origin
else|:
literal|"()"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|debug_set
specifier|static
name|void
name|debug_set
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|match
parameter_list|,
name|struct
name|git_attr
modifier|*
name|attr
parameter_list|,
specifier|const
name|void
modifier|*
name|v
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|v
decl_stmt|;
if|if
condition|(
name|ATTR_TRUE
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
literal|"set"
expr_stmt|;
elseif|else
if|if
condition|(
name|ATTR_FALSE
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
literal|"unset"
expr_stmt|;
elseif|else
if|if
condition|(
name|ATTR_UNSET
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
literal|"unspecified"
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s => %s (%s)\n"
argument_list|,
name|what
argument_list|,
name|attr
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|value
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|debug_push
define|#
directive|define
name|debug_push
parameter_list|(
name|a
parameter_list|)
value|debug_info("push", (a))
end_define
begin_define
DECL|macro|debug_pop
define|#
directive|define
name|debug_pop
parameter_list|(
name|a
parameter_list|)
value|debug_info("pop", (a))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|debug_push
define|#
directive|define
name|debug_push
parameter_list|(
name|a
parameter_list|)
value|do { ; } while (0)
end_define
begin_define
DECL|macro|debug_pop
define|#
directive|define
name|debug_pop
parameter_list|(
name|a
parameter_list|)
value|do { ; } while (0)
end_define
begin_define
DECL|macro|debug_set
define|#
directive|define
name|debug_set
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|do { ; } while (0)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|drop_attr_stack
specifier|static
name|void
name|drop_attr_stack
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|attr_stack
condition|)
block|{
name|struct
name|attr_stack
modifier|*
name|elem
init|=
name|attr_stack
decl_stmt|;
name|attr_stack
operator|=
name|elem
operator|->
name|prev
expr_stmt|;
name|free_attr_elem
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|git_etc_gitattributes
specifier|static
specifier|const
name|char
modifier|*
name|git_etc_gitattributes
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|system_wide
decl_stmt|;
if|if
condition|(
operator|!
name|system_wide
condition|)
name|system_wide
operator|=
name|system_path
argument_list|(
name|ETC_GITATTRIBUTES
argument_list|)
expr_stmt|;
return|return
name|system_wide
return|;
block|}
end_function
begin_function
DECL|function|git_attr_system
specifier|static
name|int
name|git_attr_system
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|!
name|git_env_bool
argument_list|(
literal|"GIT_ATTR_NOSYSTEM"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|bootstrap_attr_stack
specifier|static
name|void
name|bootstrap_attr_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|attr_stack
modifier|*
name|elem
decl_stmt|;
if|if
condition|(
name|attr_stack
condition|)
return|return;
name|elem
operator|=
name|read_attr_from_array
argument_list|(
name|builtin_attr
argument_list|)
expr_stmt|;
name|elem
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
name|elem
operator|->
name|prev
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|elem
expr_stmt|;
if|if
condition|(
name|git_attr_system
argument_list|()
condition|)
block|{
name|elem
operator|=
name|read_attr_from_file
argument_list|(
name|git_etc_gitattributes
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|elem
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
name|elem
operator|->
name|prev
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|elem
expr_stmt|;
block|}
block|}
if|if
condition|(
name|git_attributes_file
condition|)
block|{
name|elem
operator|=
name|read_attr_from_file
argument_list|(
name|git_attributes_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|elem
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
name|elem
operator|->
name|prev
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|elem
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|is_bare_repository
argument_list|()
operator|||
name|direction
operator|==
name|GIT_ATTR_INDEX
condition|)
block|{
name|elem
operator|=
name|read_attr
argument_list|(
name|GITATTRIBUTES_FILE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elem
operator|->
name|origin
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|elem
operator|->
name|prev
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|elem
expr_stmt|;
name|debug_push
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
name|elem
operator|=
name|read_attr_from_file
argument_list|(
name|git_path
argument_list|(
name|INFOATTRIBUTES_FILE
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elem
condition|)
name|elem
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|elem
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
name|elem
operator|->
name|prev
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|elem
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_attr_stack
specifier|static
name|void
name|prepare_attr_stack
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|attr_stack
modifier|*
name|elem
decl_stmt|,
modifier|*
name|info
decl_stmt|;
name|int
name|dirlen
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|dirlen
operator|=
literal|0
expr_stmt|;
else|else
name|dirlen
operator|=
name|cp
operator|-
name|path
expr_stmt|;
comment|/* 	 * At the bottom of the attribute stack is the built-in 	 * set of attribute definitions, followed by the contents 	 * of $(prefix)/etc/gitattributes and a file specified by 	 * core.attributesfile.  Then, contents from 	 * .gitattribute files from directories closer to the 	 * root to the ones in deeper directories are pushed 	 * to the stack.  Finally, at the very top of the stack 	 * we always keep the contents of $GIT_DIR/info/attributes. 	 * 	 * When checking, we use entries from near the top of the 	 * stack, preferring $GIT_DIR/info/attributes, then 	 * .gitattributes in deeper directories to shallower ones, 	 * and finally use the built-in set as the default. 	 */
name|bootstrap_attr_stack
argument_list|()
expr_stmt|;
comment|/* 	 * Pop the "info" one that is always at the top of the stack. 	 */
name|info
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|info
operator|->
name|prev
expr_stmt|;
comment|/* 	 * Pop the ones from directories that are not the prefix of 	 * the path we are checking. Break out of the loop when we see 	 * the root one (whose origin is an empty string "") or the builtin 	 * one (whose origin is NULL) without popping it. 	 */
while|while
condition|(
name|attr_stack
operator|->
name|origin
condition|)
block|{
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|attr_stack
operator|->
name|origin
argument_list|)
decl_stmt|;
name|elem
operator|=
name|attr_stack
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
name|dirlen
operator|&&
operator|!
name|strncmp
argument_list|(
name|elem
operator|->
name|origin
argument_list|,
name|path
argument_list|,
name|namelen
argument_list|)
operator|&&
operator|(
operator|!
name|namelen
operator|||
name|path
index|[
name|namelen
index|]
operator|==
literal|'/'
operator|)
condition|)
break|break;
name|debug_pop
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|attr_stack
operator|=
name|elem
operator|->
name|prev
expr_stmt|;
name|free_attr_elem
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read from parent directories and push them down 	 */
if|if
condition|(
operator|!
name|is_bare_repository
argument_list|()
operator|||
name|direction
operator|==
name|GIT_ATTR_INDEX
condition|)
block|{
comment|/* 		 * bootstrap_attr_stack() should have added, and the 		 * above loop should have stopped before popping, the 		 * root element whose attr_stack->origin is set to an 		 * empty string. 		 */
name|struct
name|strbuf
name|pathbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|assert
argument_list|(
name|attr_stack
operator|->
name|origin
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|attr_stack
operator|->
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirlen
operator|<=
name|len
condition|)
break|break;
name|cp
operator|=
name|memchr
argument_list|(
name|path
operator|+
name|len
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|,
name|dirlen
operator|-
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|cp
operator|=
name|path
operator|+
name|dirlen
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|pathbuf
argument_list|,
name|path
argument_list|,
name|cp
operator|-
name|path
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|pathbuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|pathbuf
argument_list|,
name|GITATTRIBUTES_FILE
argument_list|)
expr_stmt|;
name|elem
operator|=
name|read_attr
argument_list|(
name|pathbuf
operator|.
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|pathbuf
argument_list|,
name|cp
operator|-
name|path
argument_list|)
expr_stmt|;
name|elem
operator|->
name|origin
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|pathbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|elem
operator|->
name|prev
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|elem
expr_stmt|;
name|debug_push
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|pathbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finally push the "info" one at the top of the stack. 	 */
name|info
operator|->
name|prev
operator|=
name|attr_stack
expr_stmt|;
name|attr_stack
operator|=
name|info
expr_stmt|;
block|}
end_function
begin_function
DECL|function|path_matches
specifier|static
name|int
name|path_matches
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|pattern
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
comment|/* match basename */
specifier|const
name|char
modifier|*
name|basename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|basename
operator|=
name|basename
condition|?
name|basename
operator|+
literal|1
else|:
name|pathname
expr_stmt|;
return|return
operator|(
name|fnmatch_icase
argument_list|(
name|pattern
argument_list|,
name|basename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/* 	 * match with FNM_PATHNAME; the pattern has base implicitly 	 * in front of it. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'/'
condition|)
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
name|pathlen
operator|<
name|baselen
operator|||
operator|(
name|baselen
operator|&&
name|pathname
index|[
name|baselen
index|]
operator|!=
literal|'/'
operator|)
operator|||
name|strncmp
argument_list|(
name|pathname
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|baselen
operator|!=
literal|0
condition|)
name|baselen
operator|++
expr_stmt|;
return|return
name|fnmatch_icase
argument_list|(
name|pattern
argument_list|,
name|pathname
operator|+
name|baselen
argument_list|,
name|FNM_PATHNAME
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function_decl
specifier|static
name|int
name|macroexpand_one
parameter_list|(
name|int
name|attr_nr
parameter_list|,
name|int
name|rem
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|fill_one
specifier|static
name|int
name|fill_one
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|struct
name|match_attr
modifier|*
name|a
parameter_list|,
name|int
name|rem
parameter_list|)
block|{
name|struct
name|git_attr_check
modifier|*
name|check
init|=
name|check_all_attr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|a
operator|->
name|num_attr
operator|-
literal|1
init|;
literal|0
operator|<
name|rem
operator|&&
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|git_attr
modifier|*
name|attr
init|=
name|a
operator|->
name|state
index|[
name|i
index|]
operator|.
name|attr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|n
init|=
operator|&
operator|(
name|check
index|[
name|attr
operator|->
name|attr_nr
index|]
operator|.
name|value
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|v
init|=
name|a
operator|->
name|state
index|[
name|i
index|]
operator|.
name|setto
decl_stmt|;
if|if
condition|(
operator|*
name|n
operator|==
name|ATTR__UNKNOWN
condition|)
block|{
name|debug_set
argument_list|(
name|what
argument_list|,
name|a
operator|->
name|is_macro
condition|?
name|a
operator|->
name|u
operator|.
name|attr
operator|->
name|name
else|:
name|a
operator|->
name|u
operator|.
name|pattern
argument_list|,
name|attr
argument_list|,
name|v
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
name|v
expr_stmt|;
name|rem
operator|--
expr_stmt|;
name|rem
operator|=
name|macroexpand_one
argument_list|(
name|attr
operator|->
name|attr_nr
argument_list|,
name|rem
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rem
return|;
block|}
end_function
begin_function
DECL|function|fill
specifier|static
name|int
name|fill
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|pathlen
parameter_list|,
name|struct
name|attr_stack
modifier|*
name|stk
parameter_list|,
name|int
name|rem
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
init|=
name|stk
operator|->
name|origin
condition|?
name|stk
operator|->
name|origin
else|:
literal|""
decl_stmt|;
for|for
control|(
name|i
operator|=
name|stk
operator|->
name|num_matches
operator|-
literal|1
init|;
literal|0
operator|<
name|rem
operator|&&
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|match_attr
modifier|*
name|a
init|=
name|stk
operator|->
name|attrs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|is_macro
condition|)
continue|continue;
if|if
condition|(
name|path_matches
argument_list|(
name|path
argument_list|,
name|pathlen
argument_list|,
name|a
operator|->
name|u
operator|.
name|pattern
argument_list|,
name|base
argument_list|,
name|strlen
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
name|rem
operator|=
name|fill_one
argument_list|(
literal|"fill"
argument_list|,
name|a
argument_list|,
name|rem
argument_list|)
expr_stmt|;
block|}
return|return
name|rem
return|;
block|}
end_function
begin_function
DECL|function|macroexpand_one
specifier|static
name|int
name|macroexpand_one
parameter_list|(
name|int
name|attr_nr
parameter_list|,
name|int
name|rem
parameter_list|)
block|{
name|struct
name|attr_stack
modifier|*
name|stk
decl_stmt|;
name|struct
name|match_attr
modifier|*
name|a
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|check_all_attr
index|[
name|attr_nr
index|]
operator|.
name|value
operator|!=
name|ATTR__TRUE
condition|)
return|return
name|rem
return|;
for|for
control|(
name|stk
operator|=
name|attr_stack
init|;
operator|!
name|a
operator|&&
name|stk
condition|;
name|stk
operator|=
name|stk
operator|->
name|prev
control|)
for|for
control|(
name|i
operator|=
name|stk
operator|->
name|num_matches
operator|-
literal|1
init|;
operator|!
name|a
operator|&&
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|match_attr
modifier|*
name|ma
init|=
name|stk
operator|->
name|attrs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ma
operator|->
name|is_macro
condition|)
continue|continue;
if|if
condition|(
name|ma
operator|->
name|u
operator|.
name|attr
operator|->
name|attr_nr
operator|==
name|attr_nr
condition|)
name|a
operator|=
name|ma
expr_stmt|;
block|}
if|if
condition|(
name|a
condition|)
name|rem
operator|=
name|fill_one
argument_list|(
literal|"expand"
argument_list|,
name|a
argument_list|,
name|rem
argument_list|)
expr_stmt|;
return|return
name|rem
return|;
block|}
end_function
begin_comment
comment|/*  * Collect all attributes for path into the array pointed to by  * check_all_attr.  */
end_comment
begin_function
DECL|function|collect_all_attrs
specifier|static
name|void
name|collect_all_attrs
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|attr_stack
modifier|*
name|stk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pathlen
decl_stmt|,
name|rem
decl_stmt|;
name|prepare_attr_stack
argument_list|(
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attr_nr
condition|;
name|i
operator|++
control|)
name|check_all_attr
index|[
name|i
index|]
operator|.
name|value
operator|=
name|ATTR__UNKNOWN
expr_stmt|;
name|pathlen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|rem
operator|=
name|attr_nr
expr_stmt|;
for|for
control|(
name|stk
operator|=
name|attr_stack
init|;
literal|0
operator|<
name|rem
operator|&&
name|stk
condition|;
name|stk
operator|=
name|stk
operator|->
name|prev
control|)
name|rem
operator|=
name|fill
argument_list|(
name|path
argument_list|,
name|pathlen
argument_list|,
name|stk
argument_list|,
name|rem
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_check_attr
name|int
name|git_check_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|num
parameter_list|,
name|struct
name|git_attr_check
modifier|*
name|check
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|collect_all_attrs
argument_list|(
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|check_all_attr
index|[
name|check
index|[
name|i
index|]
operator|.
name|attr
operator|->
name|attr_nr
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|ATTR__UNKNOWN
condition|)
name|value
operator|=
name|ATTR__UNSET
expr_stmt|;
name|check
index|[
name|i
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_all_attrs
name|int
name|git_all_attrs
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
modifier|*
name|num
parameter_list|,
name|struct
name|git_attr_check
modifier|*
modifier|*
name|check
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|j
decl_stmt|;
name|collect_all_attrs
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Count the number of attributes that are set. */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attr_nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|check_all_attr
index|[
name|i
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|ATTR__UNSET
operator|&&
name|value
operator|!=
name|ATTR__UNKNOWN
condition|)
operator|++
name|count
expr_stmt|;
block|}
operator|*
name|num
operator|=
name|count
expr_stmt|;
operator|*
name|check
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|check
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attr_nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|check_all_attr
index|[
name|i
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|ATTR__UNSET
operator|&&
name|value
operator|!=
name|ATTR__UNKNOWN
condition|)
block|{
operator|(
operator|*
name|check
operator|)
index|[
name|j
index|]
operator|.
name|attr
operator|=
name|check_all_attr
index|[
name|i
index|]
operator|.
name|attr
expr_stmt|;
operator|(
operator|*
name|check
operator|)
index|[
name|j
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_attr_set_direction
name|void
name|git_attr_set_direction
parameter_list|(
name|enum
name|git_attr_direction
name|new
parameter_list|,
name|struct
name|index_state
modifier|*
name|istate
parameter_list|)
block|{
name|enum
name|git_attr_direction
name|old
init|=
name|direction
decl_stmt|;
if|if
condition|(
name|is_bare_repository
argument_list|()
operator|&&
name|new
operator|!=
name|GIT_ATTR_INDEX
condition|)
name|die
argument_list|(
literal|"BUG: non-INDEX attr direction in a bare repo"
argument_list|)
expr_stmt|;
name|direction
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|old
condition|)
name|drop_attr_stack
argument_list|()
expr_stmt|;
name|use_index
operator|=
name|istate
expr_stmt|;
block|}
end_function
end_unit
