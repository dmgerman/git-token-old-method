begin_unit
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"wildmatch.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"ref-filter.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_typedef
DECL|enumerator|FIELD_STR
DECL|enumerator|FIELD_ULONG
DECL|enumerator|FIELD_TIME
DECL|typedef|cmp_type
typedef|typedef
enum|enum
block|{
name|FIELD_STR
block|,
name|FIELD_ULONG
block|,
name|FIELD_TIME
block|}
name|cmp_type
typedef|;
end_typedef
begin_struct
specifier|static
struct|struct
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|cmp_type
name|cmp_type
name|cmp_type
decl_stmt|;
block|}
DECL|variable|valid_atom
name|valid_atom
index|[]
init|=
block|{
block|{
literal|"refname"
block|}
block|,
block|{
literal|"objecttype"
block|}
block|,
block|{
literal|"objectsize"
block|,
name|FIELD_ULONG
block|}
block|,
block|{
literal|"objectname"
block|}
block|,
block|{
literal|"tree"
block|}
block|,
block|{
literal|"parent"
block|}
block|,
block|{
literal|"numparent"
block|,
name|FIELD_ULONG
block|}
block|,
block|{
literal|"object"
block|}
block|,
block|{
literal|"type"
block|}
block|,
block|{
literal|"tag"
block|}
block|,
block|{
literal|"author"
block|}
block|,
block|{
literal|"authorname"
block|}
block|,
block|{
literal|"authoremail"
block|}
block|,
block|{
literal|"authordate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"committer"
block|}
block|,
block|{
literal|"committername"
block|}
block|,
block|{
literal|"committeremail"
block|}
block|,
block|{
literal|"committerdate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"tagger"
block|}
block|,
block|{
literal|"taggername"
block|}
block|,
block|{
literal|"taggeremail"
block|}
block|,
block|{
literal|"taggerdate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"creator"
block|}
block|,
block|{
literal|"creatordate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"subject"
block|}
block|,
block|{
literal|"body"
block|}
block|,
block|{
literal|"contents"
block|}
block|,
block|{
literal|"contents:subject"
block|}
block|,
block|{
literal|"contents:body"
block|}
block|,
block|{
literal|"contents:signature"
block|}
block|,
block|{
literal|"upstream"
block|}
block|,
block|{
literal|"push"
block|}
block|,
block|{
literal|"symref"
block|}
block|,
block|{
literal|"flag"
block|}
block|,
block|{
literal|"HEAD"
block|}
block|,
block|{
literal|"color"
block|}
block|,
block|{
literal|"align"
block|}
block|,
block|{
literal|"end"
block|}
block|, }
struct|;
end_struct
begin_define
DECL|macro|REF_FORMATTING_STATE_INIT
define|#
directive|define
name|REF_FORMATTING_STATE_INIT
value|{ 0, NULL }
end_define
begin_struct
DECL|struct|align
struct|struct
name|align
block|{
DECL|member|position
name|align_type
name|position
decl_stmt|;
DECL|member|width
name|unsigned
name|int
name|width
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|ref_formatting_stack
struct|struct
name|ref_formatting_stack
block|{
DECL|member|prev
name|struct
name|ref_formatting_stack
modifier|*
name|prev
decl_stmt|;
DECL|member|output
name|struct
name|strbuf
name|output
decl_stmt|;
DECL|member|at_end
name|void
function_decl|(
modifier|*
name|at_end
function_decl|)
parameter_list|(
name|struct
name|ref_formatting_stack
modifier|*
name|stack
parameter_list|)
function_decl|;
DECL|member|at_end_data
name|void
modifier|*
name|at_end_data
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|ref_formatting_state
struct|struct
name|ref_formatting_state
block|{
DECL|member|quote_style
name|int
name|quote_style
decl_stmt|;
DECL|member|stack
name|struct
name|ref_formatting_stack
modifier|*
name|stack
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|atom_value
struct|struct
name|atom_value
block|{
DECL|member|s
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
union|union
block|{
DECL|member|align
name|struct
name|align
name|align
decl_stmt|;
block|}
DECL|member|u
name|u
union|;
DECL|member|handler
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|struct
name|atom_value
modifier|*
name|atomv
parameter_list|,
name|struct
name|ref_formatting_state
modifier|*
name|state
parameter_list|)
function_decl|;
DECL|member|ul
name|unsigned
name|long
name|ul
decl_stmt|;
comment|/* used for sorting when not FIELD_STR */
block|}
struct|;
end_struct
begin_comment
comment|/*  * An atom is a valid field atom listed above, possibly prefixed with  * a "*" to denote deref_tag().  *  * We parse given format string and sort specifiers, and make a list  * of properties that we need to extract out of objects.  ref_array_item  * structure will hold an array of values extracted that can be  * indexed with the "atom number", which is an index into this  * array.  */
end_comment
begin_decl_stmt
DECL|variable|used_atom
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|used_atom
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|used_atom_type
specifier|static
name|cmp_type
modifier|*
name|used_atom_type
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|used_atom_cnt
DECL|variable|need_tagged
DECL|variable|need_symref
specifier|static
name|int
name|used_atom_cnt
decl_stmt|,
name|need_tagged
decl_stmt|,
name|need_symref
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|need_color_reset_at_eol
specifier|static
name|int
name|need_color_reset_at_eol
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Used to parse format string and sort specifiers  */
end_comment
begin_function
DECL|function|parse_ref_filter_atom
name|int
name|parse_ref_filter_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|atom
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|at
decl_stmt|;
name|sp
operator|=
name|atom
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'*'
operator|&&
name|sp
operator|<
name|ep
condition|)
name|sp
operator|++
expr_stmt|;
comment|/* deref */
if|if
condition|(
name|ep
operator|<=
name|sp
condition|)
name|die
argument_list|(
literal|"malformed field name: %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|atom
argument_list|)
argument_list|,
name|atom
argument_list|)
expr_stmt|;
comment|/* Do we have the atom already used elsewhere? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|used_atom
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|ep
operator|-
name|atom
operator|&&
operator|!
name|memcmp
argument_list|(
name|used_atom
index|[
name|i
index|]
argument_list|,
name|atom
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|i
return|;
block|}
comment|/* Is the atom a valid one? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|valid_atom
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|valid_atom
index|[
name|i
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
comment|/* 		 * If the atom name has a colon, strip it and everything after 		 * it off - it specifies the format for this entry, and 		 * shouldn't be used for checking against the valid_atom 		 * table. 		 */
specifier|const
name|char
modifier|*
name|formatp
init|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatp
operator|||
name|ep
operator|<
name|formatp
condition|)
name|formatp
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|formatp
operator|-
name|sp
operator|&&
operator|!
name|memcmp
argument_list|(
name|valid_atom
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|valid_atom
argument_list|)
operator|<=
name|i
condition|)
name|die
argument_list|(
literal|"unknown field name: %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|atom
argument_list|)
argument_list|,
name|atom
argument_list|)
expr_stmt|;
comment|/* Add it in, including the deref prefix */
name|at
operator|=
name|used_atom_cnt
expr_stmt|;
name|used_atom_cnt
operator|++
expr_stmt|;
name|REALLOC_ARRAY
argument_list|(
name|used_atom
argument_list|,
name|used_atom_cnt
argument_list|)
expr_stmt|;
name|REALLOC_ARRAY
argument_list|(
name|used_atom_type
argument_list|,
name|used_atom_cnt
argument_list|)
expr_stmt|;
name|used_atom
index|[
name|at
index|]
operator|=
name|xmemdupz
argument_list|(
name|atom
argument_list|,
name|ep
operator|-
name|atom
argument_list|)
expr_stmt|;
name|used_atom_type
index|[
name|at
index|]
operator|=
name|valid_atom
index|[
name|i
index|]
operator|.
name|cmp_type
expr_stmt|;
if|if
condition|(
operator|*
name|atom
operator|==
literal|'*'
condition|)
name|need_tagged
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|used_atom
index|[
name|at
index|]
argument_list|,
literal|"symref"
argument_list|)
condition|)
name|need_symref
operator|=
literal|1
expr_stmt|;
return|return
name|at
return|;
block|}
end_function
begin_function
DECL|function|quote_formatting
specifier|static
name|void
name|quote_formatting
parameter_list|(
name|struct
name|strbuf
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quote_style
parameter_list|)
block|{
switch|switch
condition|(
name|quote_style
condition|)
block|{
case|case
name|QUOTE_NONE
case|:
name|strbuf_addstr
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_SHELL
case|:
name|sq_quote_buf
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_PERL
case|:
name|perl_quote_buf
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_PYTHON
case|:
name|python_quote_buf
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_TCL
case|:
name|tcl_quote_buf
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|append_atom
specifier|static
name|void
name|append_atom
parameter_list|(
name|struct
name|atom_value
modifier|*
name|v
parameter_list|,
name|struct
name|ref_formatting_state
modifier|*
name|state
parameter_list|)
block|{
comment|/* 	 * Quote formatting is only done when the stack has a single 	 * element. Otherwise quote formatting is done on the 	 * element's entire output strbuf when the %(end) atom is 	 * encountered. 	 */
if|if
condition|(
operator|!
name|state
operator|->
name|stack
operator|->
name|prev
condition|)
name|quote_formatting
argument_list|(
operator|&
name|state
operator|->
name|stack
operator|->
name|output
argument_list|,
name|v
operator|->
name|s
argument_list|,
name|state
operator|->
name|quote_style
argument_list|)
expr_stmt|;
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|state
operator|->
name|stack
operator|->
name|output
argument_list|,
name|v
operator|->
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|push_stack_element
specifier|static
name|void
name|push_stack_element
parameter_list|(
name|struct
name|ref_formatting_stack
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|ref_formatting_stack
modifier|*
name|s
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref_formatting_stack
argument_list|)
argument_list|)
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|s
operator|->
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|prev
operator|=
operator|*
name|stack
expr_stmt|;
operator|*
name|stack
operator|=
name|s
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pop_stack_element
specifier|static
name|void
name|pop_stack_element
parameter_list|(
name|struct
name|ref_formatting_stack
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|ref_formatting_stack
modifier|*
name|current
init|=
operator|*
name|stack
decl_stmt|;
name|struct
name|ref_formatting_stack
modifier|*
name|prev
init|=
name|current
operator|->
name|prev
decl_stmt|;
if|if
condition|(
name|prev
condition|)
name|strbuf_addbuf
argument_list|(
operator|&
name|prev
operator|->
name|output
argument_list|,
operator|&
name|current
operator|->
name|output
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|current
operator|->
name|output
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|current
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|prev
expr_stmt|;
block|}
end_function
begin_function
DECL|function|end_align_handler
specifier|static
name|void
name|end_align_handler
parameter_list|(
name|struct
name|ref_formatting_stack
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|align
modifier|*
name|align
init|=
operator|(
expr|struct
name|align
operator|*
operator|)
name|stack
operator|->
name|at_end_data
decl_stmt|;
name|struct
name|strbuf
name|s
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_utf8_align
argument_list|(
operator|&
name|s
argument_list|,
name|align
operator|->
name|position
argument_list|,
name|align
operator|->
name|width
argument_list|,
name|stack
operator|->
name|output
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_swap
argument_list|(
operator|&
name|stack
operator|->
name|output
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|align_atom_handler
specifier|static
name|void
name|align_atom_handler
parameter_list|(
name|struct
name|atom_value
modifier|*
name|atomv
parameter_list|,
name|struct
name|ref_formatting_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|ref_formatting_stack
modifier|*
name|new
decl_stmt|;
name|push_stack_element
argument_list|(
operator|&
name|state
operator|->
name|stack
argument_list|)
expr_stmt|;
name|new
operator|=
name|state
operator|->
name|stack
expr_stmt|;
name|new
operator|->
name|at_end
operator|=
name|end_align_handler
expr_stmt|;
name|new
operator|->
name|at_end_data
operator|=
operator|&
name|atomv
operator|->
name|u
operator|.
name|align
expr_stmt|;
block|}
end_function
begin_function
DECL|function|end_atom_handler
specifier|static
name|void
name|end_atom_handler
parameter_list|(
name|struct
name|atom_value
modifier|*
name|atomv
parameter_list|,
name|struct
name|ref_formatting_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|ref_formatting_stack
modifier|*
name|current
init|=
name|state
operator|->
name|stack
decl_stmt|;
name|struct
name|strbuf
name|s
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|current
operator|->
name|at_end
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"format: %%(end) atom used without corresponding atom"
argument_list|)
argument_list|)
expr_stmt|;
name|current
operator|->
name|at_end
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* 	 * Perform quote formatting when the stack element is that of 	 * a supporting atom. If nested then perform quote formatting 	 * only on the topmost supporting atom. 	 */
if|if
condition|(
operator|!
name|state
operator|->
name|stack
operator|->
name|prev
operator|->
name|prev
condition|)
block|{
name|quote_formatting
argument_list|(
operator|&
name|s
argument_list|,
name|current
operator|->
name|output
operator|.
name|buf
argument_list|,
name|state
operator|->
name|quote_style
argument_list|)
expr_stmt|;
name|strbuf_swap
argument_list|(
operator|&
name|current
operator|->
name|output
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|pop_stack_element
argument_list|(
operator|&
name|state
operator|->
name|stack
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|match_atom_name
specifier|static
name|int
name|match_atom_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|atom_name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|val
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|body
decl_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|name
argument_list|,
name|atom_name
argument_list|,
operator|&
name|body
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* doesn't even begin with "atom_name" */
if|if
condition|(
operator|!
name|body
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|val
operator|=
name|NULL
expr_stmt|;
comment|/* %(atom_name) and no customization */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|body
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
return|return
literal|0
return|;
comment|/* "atom_namefoo" is not "atom_name" or "atom_name:..." */
operator|*
name|val
operator|=
name|body
operator|+
literal|1
expr_stmt|;
comment|/* "atom_name:val" */
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * In a format string, find the next occurrence of %(atom).  */
end_comment
begin_function
DECL|function|find_next
specifier|static
specifier|const
name|char
modifier|*
name|find_next
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
comment|/* 			 * %( is the start of an atom; 			 * %% is a quoted per-cent. 			 */
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
return|return
name|cp
return|;
elseif|else
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* skip over two % */
comment|/* otherwise this is a singleton, literal % */
block|}
name|cp
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Make sure the format string is well formed, and parse out  * the used atoms.  */
end_comment
begin_function
DECL|function|verify_ref_format
name|int
name|verify_ref_format
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|need_color_reset_at_eol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|format
init|;
operator|*
name|cp
operator|&&
operator|(
name|sp
operator|=
name|find_next
argument_list|(
name|cp
argument_list|)
operator|)
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|color
decl_stmt|,
modifier|*
name|ep
init|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
name|int
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
return|return
name|error
argument_list|(
literal|"malformed format string %s"
argument_list|,
name|sp
argument_list|)
return|;
comment|/* sp points at "%(" and ep points at the closing ")" */
name|at
operator|=
name|parse_ref_filter_atom
argument_list|(
name|sp
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|skip_prefix
argument_list|(
name|used_atom
index|[
name|at
index|]
argument_list|,
literal|"color:"
argument_list|,
operator|&
name|color
argument_list|)
condition|)
name|need_color_reset_at_eol
operator|=
operator|!
operator|!
name|strcmp
argument_list|(
name|color
argument_list|,
literal|"reset"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given an object name, read the object data and size, and return a  * "struct object".  If the object data we are returning is also borrowed  * by the "struct object" representation, set *eaten as well---it is a  * signal from parse_object_buffer to us not to free the buffer.  */
end_comment
begin_function
DECL|function|get_obj
specifier|static
name|void
modifier|*
name|get_obj
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|object
modifier|*
modifier|*
name|obj
parameter_list|,
name|unsigned
name|long
modifier|*
name|sz
parameter_list|,
name|int
modifier|*
name|eaten
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
condition|)
operator|*
name|obj
operator|=
name|parse_object_buffer
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
operator|*
name|sz
argument_list|,
name|buf
argument_list|,
name|eaten
argument_list|)
expr_stmt|;
else|else
operator|*
name|obj
operator|=
name|NULL
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_function
DECL|function|grab_objectname
specifier|static
name|int
name|grab_objectname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|atom_value
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objectname"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objectname:short"
argument_list|)
condition|)
block|{
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|find_unique_abbrev
argument_list|(
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_common_values
specifier|static
name|void
name|grab_common_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objecttype"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|typename
argument_list|(
name|obj
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objectsize"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|40
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|v
operator|->
name|ul
operator|=
name|sz
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|deref
condition|)
name|grab_objectname
argument_list|(
name|name
argument_list|,
name|obj
operator|->
name|sha1
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_tag_values
specifier|static
name|void
name|grab_tag_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tag
modifier|*
name|tag
init|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|obj
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"tag"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|tag
operator|->
name|tag
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"type"
argument_list|)
operator|&&
name|tag
operator|->
name|tagged
condition|)
name|v
operator|->
name|s
operator|=
name|typename
argument_list|(
name|tag
operator|->
name|tagged
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"object"
argument_list|)
operator|&&
name|tag
operator|->
name|tagged
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|sha1_to_hex
argument_list|(
name|tag
operator|->
name|tagged
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_commit_values
specifier|static
name|void
name|grab_commit_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"tree"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"numparent"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|40
argument_list|)
decl_stmt|;
name|v
operator|->
name|ul
operator|=
name|commit_list_count
argument_list|(
name|commit
operator|->
name|parents
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|v
operator|->
name|ul
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"parent"
argument_list|)
condition|)
block|{
name|int
name|num
init|=
name|commit_list_count
argument_list|(
name|commit
operator|->
name|parents
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
operator|*
name|num
operator|+
literal|1
argument_list|)
decl_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
operator|,
name|i
operator|=
name|i
operator|+
literal|41
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
name|i
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parents
operator|->
name|next
condition|)
name|s
index|[
name|i
operator|+
literal|40
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|find_wholine
specifier|static
specifier|const
name|char
modifier|*
name|find_wholine
parameter_list|(
specifier|const
name|char
modifier|*
name|who
parameter_list|,
name|int
name|wholen
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
while|while
condition|(
operator|*
name|buf
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|who
argument_list|,
name|wholen
argument_list|)
operator|&&
name|buf
index|[
name|wholen
index|]
operator|==
literal|' '
condition|)
return|return
name|buf
operator|+
name|wholen
operator|+
literal|1
return|;
name|eol
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
return|return
literal|""
return|;
name|eol
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|eol
operator|==
literal|'\n'
condition|)
return|return
literal|""
return|;
comment|/* end of header */
name|buf
operator|=
name|eol
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function
begin_function
DECL|function|copy_line
specifier|static
specifier|const
name|char
modifier|*
name|copy_line
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
init|=
name|strchrnul
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
return|return
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|eol
operator|-
name|buf
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|copy_name
specifier|static
specifier|const
name|char
modifier|*
name|copy_name
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"<"
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|buf
argument_list|)
return|;
block|}
return|return
literal|""
return|;
block|}
end_function
begin_function
DECL|function|copy_email
specifier|static
specifier|const
name|char
modifier|*
name|copy_email
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|email
init|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'<'
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|eoemail
decl_stmt|;
if|if
condition|(
operator|!
name|email
condition|)
return|return
literal|""
return|;
name|eoemail
operator|=
name|strchr
argument_list|(
name|email
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eoemail
condition|)
return|return
literal|""
return|;
return|return
name|xmemdupz
argument_list|(
name|email
argument_list|,
name|eoemail
operator|+
literal|1
operator|-
name|email
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|copy_subject
specifier|static
name|char
modifier|*
name|copy_subject
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|char
modifier|*
name|r
init|=
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|r
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|grab_date
specifier|static
name|void
name|grab_date
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|struct
name|atom_value
modifier|*
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|atomname
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eoemail
init|=
name|strstr
argument_list|(
name|buf
argument_list|,
literal|"> "
argument_list|)
decl_stmt|;
name|char
modifier|*
name|zone
decl_stmt|;
name|unsigned
name|long
name|timestamp
decl_stmt|;
name|long
name|tz
decl_stmt|;
name|struct
name|date_mode
name|date_mode
init|=
block|{
name|DATE_NORMAL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|formatp
decl_stmt|;
comment|/* 	 * We got here because atomname ends in "date" or "date<something>"; 	 * it's not possible that<something> is not ":<format>" because 	 * parse_ref_filter_atom() wouldn't have allowed it, so we can assume that no 	 * ":" means no format is specified, and use the default. 	 */
name|formatp
operator|=
name|strchr
argument_list|(
name|atomname
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatp
operator|!=
name|NULL
condition|)
block|{
name|formatp
operator|++
expr_stmt|;
name|parse_date_format
argument_list|(
name|formatp
argument_list|,
operator|&
name|date_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eoemail
condition|)
goto|goto
name|bad
goto|;
name|timestamp
operator|=
name|strtoul
argument_list|(
name|eoemail
operator|+
literal|2
argument_list|,
operator|&
name|zone
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp
operator|==
name|ULONG_MAX
condition|)
goto|goto
name|bad
goto|;
name|tz
operator|=
name|strtol
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tz
operator|==
name|LONG_MIN
operator|||
name|tz
operator|==
name|LONG_MAX
operator|)
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
goto|goto
name|bad
goto|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|show_date
argument_list|(
name|timestamp
argument_list|,
name|tz
argument_list|,
operator|&
name|date_mode
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|ul
operator|=
name|timestamp
expr_stmt|;
return|return;
name|bad
label|:
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
name|v
operator|->
name|ul
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_person
specifier|static
name|void
name|grab_person
parameter_list|(
specifier|const
name|char
modifier|*
name|who
parameter_list|,
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|wholen
init|=
name|strlen
argument_list|(
name|who
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|wholine
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|who
argument_list|,
name|name
argument_list|,
name|wholen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|name
index|[
name|wholen
index|]
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"name"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"email"
argument_list|)
operator|&&
operator|!
name|starts_with
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"date"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|wholine
condition|)
name|wholine
operator|=
name|find_wholine
argument_list|(
name|who
argument_list|,
name|wholen
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wholine
condition|)
return|return;
comment|/* no point looking for it */
if|if
condition|(
name|name
index|[
name|wholen
index|]
operator|==
literal|0
condition|)
name|v
operator|->
name|s
operator|=
name|copy_line
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"name"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_name
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"email"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_email
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"date"
argument_list|)
condition|)
name|grab_date
argument_list|(
name|wholine
argument_list|,
name|v
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For a tag or a commit object, if "creator" or "creatordate" is 	 * requested, do something special. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|who
argument_list|,
literal|"tagger"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|who
argument_list|,
literal|"committer"
argument_list|)
condition|)
return|return;
comment|/* "author" for commit object is not wanted */
if|if
condition|(
operator|!
name|wholine
condition|)
name|wholine
operator|=
name|find_wholine
argument_list|(
name|who
argument_list|,
name|wholen
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wholine
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"creatordate"
argument_list|)
condition|)
name|grab_date
argument_list|(
name|wholine
argument_list|,
name|v
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creator"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_line
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|find_subpos
specifier|static
name|void
name|find_subpos
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sub
parameter_list|,
name|unsigned
name|long
modifier|*
name|sublen
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|body
parameter_list|,
name|unsigned
name|long
modifier|*
name|bodylen
parameter_list|,
name|unsigned
name|long
modifier|*
name|nonsiglen
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sig
parameter_list|,
name|unsigned
name|long
modifier|*
name|siglen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
comment|/* skip past header until we hit empty line */
while|while
condition|(
operator|*
name|buf
operator|&&
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
name|eol
operator|=
name|strchrnul
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eol
condition|)
name|eol
operator|++
expr_stmt|;
name|buf
operator|=
name|eol
expr_stmt|;
block|}
comment|/* skip any empty lines */
while|while
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
name|buf
operator|++
expr_stmt|;
comment|/* parse signature first; we might not even have a subject line */
operator|*
name|sig
operator|=
name|buf
operator|+
name|parse_signature
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|siglen
operator|=
name|strlen
argument_list|(
operator|*
name|sig
argument_list|)
expr_stmt|;
comment|/* subject is first non-empty line */
operator|*
name|sub
operator|=
name|buf
expr_stmt|;
comment|/* subject goes to first empty line */
while|while
condition|(
name|buf
operator|<
operator|*
name|sig
operator|&&
operator|*
name|buf
operator|&&
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
name|eol
operator|=
name|strchrnul
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eol
condition|)
name|eol
operator|++
expr_stmt|;
name|buf
operator|=
name|eol
expr_stmt|;
block|}
operator|*
name|sublen
operator|=
name|buf
operator|-
operator|*
name|sub
expr_stmt|;
comment|/* drop trailing newline, if present */
if|if
condition|(
operator|*
name|sublen
operator|&&
operator|(
operator|*
name|sub
operator|)
index|[
operator|*
name|sublen
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|*
name|sublen
operator|-=
literal|1
expr_stmt|;
comment|/* skip any empty lines */
while|while
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
name|buf
operator|++
expr_stmt|;
operator|*
name|body
operator|=
name|buf
expr_stmt|;
operator|*
name|bodylen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|nonsiglen
operator|=
operator|*
name|sig
operator|-
name|buf
expr_stmt|;
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_sub_body_contents
specifier|static
name|void
name|grab_sub_body_contents
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|subpos
init|=
name|NULL
decl_stmt|,
modifier|*
name|bodypos
init|=
name|NULL
decl_stmt|,
modifier|*
name|sigpos
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|sublen
init|=
literal|0
decl_stmt|,
name|bodylen
init|=
literal|0
decl_stmt|,
name|nonsiglen
init|=
literal|0
decl_stmt|,
name|siglen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"subject"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"body"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:subject"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:body"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:signature"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|subpos
condition|)
name|find_subpos
argument_list|(
name|buf
argument_list|,
name|sz
argument_list|,
operator|&
name|subpos
argument_list|,
operator|&
name|sublen
argument_list|,
operator|&
name|bodypos
argument_list|,
operator|&
name|bodylen
argument_list|,
operator|&
name|nonsiglen
argument_list|,
operator|&
name|sigpos
argument_list|,
operator|&
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"subject"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_subject
argument_list|(
name|subpos
argument_list|,
name|sublen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:subject"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_subject
argument_list|(
name|subpos
argument_list|,
name|sublen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"body"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xmemdupz
argument_list|(
name|bodypos
argument_list|,
name|bodylen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:body"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xmemdupz
argument_list|(
name|bodypos
argument_list|,
name|nonsiglen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:signature"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xmemdupz
argument_list|(
name|sigpos
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|subpos
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * We want to have empty print-string for field requests  * that do not apply (e.g. "authordate" for a tag object)  */
end_comment
begin_function
DECL|function|fill_missing_values
specifier|static
name|void
name|fill_missing_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|s
operator|==
name|NULL
condition|)
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * val is a list of atom_value to hold returned values.  Extract  * the values for atoms in used_atom array out of (obj, buf, sz).  * when deref is false, (obj, buf, sz) is the object that is  * pointed at by the ref itself; otherwise it is the object the  * ref (which is a tag) refers to.  */
end_comment
begin_function
DECL|function|grab_values
specifier|static
name|void
name|grab_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|grab_common_values
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|OBJ_TAG
case|:
name|grab_tag_values
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_sub_body_contents
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_person
argument_list|(
literal|"tagger"
argument_list|,
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
name|grab_commit_values
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_sub_body_contents
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_person
argument_list|(
literal|"author"
argument_list|,
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_person
argument_list|(
literal|"committer"
argument_list|,
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_TREE
case|:
comment|/* grab_tree_values(val, deref, obj, buf, sz); */
break|break;
case|case
name|OBJ_BLOB
case|:
comment|/* grab_blob_values(val, deref, obj, buf, sz); */
break|break;
default|default:
name|die
argument_list|(
literal|"Eh?  Object of type %d?"
argument_list|,
name|obj
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copy_advance
specifier|static
specifier|inline
name|char
modifier|*
name|copy_advance
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
while|while
condition|(
operator|*
name|src
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function
begin_comment
comment|/*  * Parse the object referred by ref, and grab needed value.  */
end_comment
begin_function
DECL|function|populate_value
specifier|static
name|void
name|populate_value
parameter_list|(
name|struct
name|ref_array_item
modifier|*
name|ref
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
name|int
name|eaten
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|tagged
decl_stmt|;
name|ref
operator|->
name|value
operator|=
name|xcalloc
argument_list|(
name|used_atom_cnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atom_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_symref
operator|&&
operator|(
name|ref
operator|->
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
operator|!
name|ref
operator|->
name|symref
condition|)
block|{
name|unsigned
name|char
name|unused1
index|[
literal|20
index|]
decl_stmt|;
name|ref
operator|->
name|symref
operator|=
name|resolve_refdup
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|unused1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|->
name|symref
condition|)
name|ref
operator|->
name|symref
operator|=
literal|""
expr_stmt|;
block|}
comment|/* Fill in specials first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|ref
operator|->
name|value
index|[
name|i
index|]
decl_stmt|;
name|int
name|deref
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|refname
decl_stmt|;
specifier|const
name|char
modifier|*
name|formatp
decl_stmt|;
specifier|const
name|char
modifier|*
name|valp
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
name|v
operator|->
name|handler
operator|=
name|append_atom
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'*'
condition|)
block|{
name|deref
operator|=
literal|1
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"refname"
argument_list|)
condition|)
name|refname
operator|=
name|ref
operator|->
name|refname
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"symref"
argument_list|)
condition|)
name|refname
operator|=
name|ref
operator|->
name|symref
condition|?
name|ref
operator|->
name|symref
else|:
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"upstream"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|branch_name
decl_stmt|;
comment|/* only local branches may have an upstream */
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|,
operator|&
name|branch_name
argument_list|)
condition|)
continue|continue;
name|branch
operator|=
name|branch_get
argument_list|(
name|branch_name
argument_list|)
expr_stmt|;
name|refname
operator|=
name|branch_get_upstream
argument_list|(
name|branch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refname
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"push"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|branch_name
decl_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|,
operator|&
name|branch_name
argument_list|)
condition|)
continue|continue;
name|branch
operator|=
name|branch_get
argument_list|(
name|branch_name
argument_list|)
expr_stmt|;
name|refname
operator|=
name|branch_get_push
argument_list|(
name|branch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refname
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|match_atom_name
argument_list|(
name|name
argument_list|,
literal|"color"
argument_list|,
operator|&
name|valp
argument_list|)
condition|)
block|{
name|char
name|color
index|[
name|COLOR_MAXLEN
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|valp
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"expected format: %%(color:<color>)"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_parse
argument_list|(
name|valp
argument_list|,
name|color
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to parse format"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|color
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"flag"
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|ref
operator|->
name|flag
operator|&
name|REF_ISSYMREF
condition|)
name|cp
operator|=
name|copy_advance
argument_list|(
name|cp
argument_list|,
literal|",symref"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|flag
operator|&
name|REF_ISPACKED
condition|)
name|cp
operator|=
name|copy_advance
argument_list|(
name|cp
argument_list|,
literal|",packed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
else|else
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|deref
operator|&&
name|grab_objectname
argument_list|(
name|name
argument_list|,
name|ref
operator|->
name|objectname
argument_list|,
name|v
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|head
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|head
operator|=
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
name|head
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
literal|"*"
expr_stmt|;
else|else
name|v
operator|->
name|s
operator|=
literal|" "
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|match_atom_name
argument_list|(
name|name
argument_list|,
literal|"align"
argument_list|,
operator|&
name|valp
argument_list|)
condition|)
block|{
name|struct
name|align
modifier|*
name|align
init|=
operator|&
name|v
operator|->
name|u
operator|.
name|align
decl_stmt|;
name|struct
name|strbuf
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|to_free
decl_stmt|;
name|int
name|width
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|valp
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"expected format: %%(align:<width>,<position>)"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * TODO: Implement a function similar to strbuf_split_str() 			 * which would omit the separator from the end of each value. 			 */
name|s
operator|=
name|to_free
operator|=
name|strbuf_split_str
argument_list|(
name|valp
argument_list|,
literal|','
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|align
operator|->
name|position
operator|=
name|ALIGN_LEFT
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
comment|/*  Strip trailing comma */
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
name|strbuf_setlen
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|0
index|]
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strtoul_ui
argument_list|(
name|s
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
literal|10
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|width
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
literal|"left"
argument_list|)
condition|)
name|align
operator|->
name|position
operator|=
name|ALIGN_LEFT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
literal|"right"
argument_list|)
condition|)
name|align
operator|->
name|position
operator|=
name|ALIGN_RIGHT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
literal|"middle"
argument_list|)
condition|)
name|align
operator|->
name|position
operator|=
name|ALIGN_MIDDLE
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"improper format entered align:%s"
argument_list|)
argument_list|,
name|s
index|[
literal|0
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"positive width expected with the %%(align) atom"
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|strbuf_list_free
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
name|v
operator|->
name|handler
operator|=
name|align_atom_handler
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"end"
argument_list|)
condition|)
block|{
name|v
operator|->
name|handler
operator|=
name|end_atom_handler
expr_stmt|;
continue|continue;
block|}
else|else
continue|continue;
name|formatp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatp
condition|)
block|{
name|int
name|num_ours
decl_stmt|,
name|num_theirs
decl_stmt|;
name|formatp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|formatp
argument_list|,
literal|"short"
argument_list|)
condition|)
name|refname
operator|=
name|shorten_unambiguous_ref
argument_list|(
name|refname
argument_list|,
name|warn_ambiguous_refs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|formatp
argument_list|,
literal|"track"
argument_list|)
operator|&&
operator|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"upstream"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"push"
argument_list|)
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|num_ours
argument_list|,
operator|&
name|num_theirs
argument_list|,
name|NULL
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|num_ours
operator|&&
operator|!
name|num_theirs
condition|)
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num_ours
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[behind %d]"
argument_list|,
name|num_theirs
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|num_theirs
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[ahead %d]"
argument_list|,
name|num_ours
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[ahead %d, behind %d]"
argument_list|,
name|num_ours
argument_list|,
name|num_theirs
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|formatp
argument_list|,
literal|"trackshort"
argument_list|)
operator|&&
operator|(
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"upstream"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|name
argument_list|,
literal|"push"
argument_list|)
operator|)
condition|)
block|{
name|assert
argument_list|(
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|num_ours
argument_list|,
operator|&
name|num_theirs
argument_list|,
name|NULL
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|num_ours
operator|&&
operator|!
name|num_theirs
condition|)
name|v
operator|->
name|s
operator|=
literal|"="
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num_ours
condition|)
name|v
operator|->
name|s
operator|=
literal|"<"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num_theirs
condition|)
name|v
operator|->
name|s
operator|=
literal|">"
expr_stmt|;
else|else
name|v
operator|->
name|s
operator|=
literal|"<>"
expr_stmt|;
continue|continue;
block|}
else|else
name|die
argument_list|(
literal|"unknown %.*s format %s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|formatp
operator|-
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|formatp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|deref
condition|)
name|v
operator|->
name|s
operator|=
name|refname
expr_stmt|;
else|else
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|4
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s^{}"
argument_list|,
name|refname
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|ref
operator|->
name|value
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|s
operator|==
name|NULL
condition|)
goto|goto
name|need_obj
goto|;
block|}
return|return;
name|need_obj
label|:
name|buf
operator|=
name|get_obj
argument_list|(
name|ref
operator|->
name|objectname
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|eaten
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"missing object %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|objectname
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|die
argument_list|(
literal|"parse_object_buffer failed on %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|objectname
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
name|grab_values
argument_list|(
name|ref
operator|->
name|value
argument_list|,
literal|0
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eaten
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no atom that wants to know about tagged 	 * object, we are done. 	 */
if|if
condition|(
operator|!
name|need_tagged
operator|||
operator|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_TAG
operator|)
condition|)
return|return;
comment|/* 	 * If it is a tag object, see if we use a value that derefs 	 * the object, and if we do grab the object it refers to. 	 */
name|tagged
operator|=
operator|(
operator|(
expr|struct
name|tag
operator|*
operator|)
name|obj
operator|)
operator|->
name|tagged
operator|->
name|sha1
expr_stmt|;
comment|/* 	 * NEEDSWORK: This derefs tag only once, which 	 * is good to deal with chains of trust, but 	 * is not consistent with what deref_tag() does 	 * which peels the onion to the core. 	 */
name|buf
operator|=
name|get_obj
argument_list|(
name|tagged
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|eaten
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"missing object %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tagged
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|die
argument_list|(
literal|"parse_object_buffer failed on %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tagged
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
name|grab_values
argument_list|(
name|ref
operator|->
name|value
argument_list|,
literal|1
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eaten
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Given a ref, return the value for the atom.  This lazily gets value  * out of the object by calling populate value.  */
end_comment
begin_function
DECL|function|get_ref_atom_value
specifier|static
name|void
name|get_ref_atom_value
parameter_list|(
name|struct
name|ref_array_item
modifier|*
name|ref
parameter_list|,
name|int
name|atom
parameter_list|,
name|struct
name|atom_value
modifier|*
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ref
operator|->
name|value
condition|)
block|{
name|populate_value
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|fill_missing_values
argument_list|(
name|ref
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
operator|*
name|v
operator|=
operator|&
name|ref
operator|->
name|value
index|[
name|atom
index|]
expr_stmt|;
block|}
end_function
begin_enum
DECL|enum|contains_result
enum|enum
name|contains_result
block|{
DECL|enumerator|CONTAINS_UNKNOWN
name|CONTAINS_UNKNOWN
init|=
operator|-
literal|1
block|,
DECL|enumerator|CONTAINS_NO
name|CONTAINS_NO
init|=
literal|0
block|,
DECL|enumerator|CONTAINS_YES
name|CONTAINS_YES
init|=
literal|1
block|}
enum|;
end_enum
begin_comment
comment|/*  * Mimicking the real stack, this stack lives on the heap, avoiding stack  * overflows.  *  * At each recursion step, the stack items points to the commits whose  * ancestors are to be inspected.  */
end_comment
begin_struct
DECL|struct|contains_stack
struct|struct
name|contains_stack
block|{
DECL|member|nr
DECL|member|alloc
name|int
name|nr
decl_stmt|,
name|alloc
decl_stmt|;
DECL|struct|contains_stack_entry
struct|struct
name|contains_stack_entry
block|{
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
DECL|member|parents
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
block|}
DECL|member|contains_stack
modifier|*
name|contains_stack
struct|;
block|}
struct|;
end_struct
begin_function
DECL|function|in_commit_list
specifier|static
name|int
name|in_commit_list
parameter_list|(
specifier|const
name|struct
name|commit_list
modifier|*
name|want
parameter_list|,
name|struct
name|commit
modifier|*
name|c
parameter_list|)
block|{
for|for
control|(
init|;
name|want
condition|;
name|want
operator|=
name|want
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|want
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|c
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Test whether the candidate or one of its parents is contained in the list.  * Do not recurse to find out, though, but return -1 if inconclusive.  */
end_comment
begin_function
DECL|function|contains_test
specifier|static
name|enum
name|contains_result
name|contains_test
parameter_list|(
name|struct
name|commit
modifier|*
name|candidate
parameter_list|,
specifier|const
name|struct
name|commit_list
modifier|*
name|want
parameter_list|)
block|{
comment|/* was it previously marked as containing a want commit? */
if|if
condition|(
name|candidate
operator|->
name|object
operator|.
name|flags
operator|&
name|TMP_MARK
condition|)
return|return
literal|1
return|;
comment|/* or marked as not possibly containing a want commit? */
if|if
condition|(
name|candidate
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
return|return
literal|0
return|;
comment|/* or are we it? */
if|if
condition|(
name|in_commit_list
argument_list|(
name|want
argument_list|,
name|candidate
argument_list|)
condition|)
block|{
name|candidate
operator|->
name|object
operator|.
name|flags
operator||=
name|TMP_MARK
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|parse_commit
argument_list|(
name|candidate
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|push_to_contains_stack
specifier|static
name|void
name|push_to_contains_stack
parameter_list|(
name|struct
name|commit
modifier|*
name|candidate
parameter_list|,
name|struct
name|contains_stack
modifier|*
name|contains_stack
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|contains_stack
operator|->
name|contains_stack
argument_list|,
name|contains_stack
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|contains_stack
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|contains_stack
operator|->
name|contains_stack
index|[
name|contains_stack
operator|->
name|nr
index|]
operator|.
name|commit
operator|=
name|candidate
expr_stmt|;
name|contains_stack
operator|->
name|contains_stack
index|[
name|contains_stack
operator|->
name|nr
operator|++
index|]
operator|.
name|parents
operator|=
name|candidate
operator|->
name|parents
expr_stmt|;
block|}
end_function
begin_function
DECL|function|contains_tag_algo
specifier|static
name|enum
name|contains_result
name|contains_tag_algo
parameter_list|(
name|struct
name|commit
modifier|*
name|candidate
parameter_list|,
specifier|const
name|struct
name|commit_list
modifier|*
name|want
parameter_list|)
block|{
name|struct
name|contains_stack
name|contains_stack
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|result
init|=
name|contains_test
argument_list|(
name|candidate
argument_list|,
name|want
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|CONTAINS_UNKNOWN
condition|)
return|return
name|result
return|;
name|push_to_contains_stack
argument_list|(
name|candidate
argument_list|,
operator|&
name|contains_stack
argument_list|)
expr_stmt|;
while|while
condition|(
name|contains_stack
operator|.
name|nr
condition|)
block|{
name|struct
name|contains_stack_entry
modifier|*
name|entry
init|=
operator|&
name|contains_stack
operator|.
name|contains_stack
index|[
name|contains_stack
operator|.
name|nr
operator|-
literal|1
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|entry
operator|->
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|entry
operator|->
name|parents
decl_stmt|;
if|if
condition|(
operator|!
name|parents
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|contains_stack
operator|.
name|nr
operator|--
expr_stmt|;
block|}
comment|/* 		 * If we just popped the stack, parents->item has been marked, 		 * therefore contains_test will return a meaningful 0 or 1. 		 */
else|else
switch|switch
condition|(
name|contains_test
argument_list|(
name|parents
operator|->
name|item
argument_list|,
name|want
argument_list|)
condition|)
block|{
case|case
name|CONTAINS_YES
case|:
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|TMP_MARK
expr_stmt|;
name|contains_stack
operator|.
name|nr
operator|--
expr_stmt|;
break|break;
case|case
name|CONTAINS_NO
case|:
name|entry
operator|->
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|CONTAINS_UNKNOWN
case|:
name|push_to_contains_stack
argument_list|(
name|parents
operator|->
name|item
argument_list|,
operator|&
name|contains_stack
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|contains_stack
operator|.
name|contains_stack
argument_list|)
expr_stmt|;
return|return
name|contains_test
argument_list|(
name|candidate
argument_list|,
name|want
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|commit_contains
specifier|static
name|int
name|commit_contains
parameter_list|(
name|struct
name|ref_filter
modifier|*
name|filter
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|->
name|with_commit_tag_algo
condition|)
return|return
name|contains_tag_algo
argument_list|(
name|commit
argument_list|,
name|filter
operator|->
name|with_commit
argument_list|)
return|;
return|return
name|is_descendant_of
argument_list|(
name|commit
argument_list|,
name|filter
operator|->
name|with_commit
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return 1 if the refname matches one of the patterns, otherwise 0.  * A pattern can be path prefix (e.g. a refname "refs/heads/master"  * matches a pattern "refs/heads/") or a wildcard (e.g. the same ref  * matches "refs/heads/m*",too).  */
end_comment
begin_function
DECL|function|match_name_as_path
specifier|static
name|int
name|match_name_as_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|*
name|pattern
condition|;
name|pattern
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pattern
decl_stmt|;
name|int
name|plen
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|plen
operator|<=
name|namelen
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|refname
argument_list|,
name|p
argument_list|,
name|plen
argument_list|)
operator|&&
operator|(
name|refname
index|[
name|plen
index|]
operator|==
literal|'\0'
operator|||
name|refname
index|[
name|plen
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
name|plen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|wildmatch
argument_list|(
name|p
argument_list|,
name|refname
argument_list|,
name|WM_PATHNAME
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given a ref (sha1, refname), check if the ref belongs to the array  * of sha1s. If the given ref is a tag, check if the given tag points  * at one of the sha1s in the given sha1 array.  * the given sha1_array.  * NEEDSWORK:  * 1. Only a single level of inderection is obtained, we might want to  * change this to account for multiple levels (e.g. annotated tags  * pointing to annotated tags pointing to a commit.)  * 2. As the refs are cached we might know what refname peels to without  * the need to parse the object via parse_object(). peel_ref() might be a  * more efficient alternative to obtain the pointee.  */
end_comment
begin_function
DECL|function|match_points_at
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|match_points_at
parameter_list|(
name|struct
name|sha1_array
modifier|*
name|points_at
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|tagged_sha1
init|=
name|NULL
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
name|sha1_array_lookup
argument_list|(
name|points_at
argument_list|,
name|sha1
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|sha1
return|;
name|obj
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"malformed object at '%s'"
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
name|tagged_sha1
operator|=
operator|(
operator|(
expr|struct
name|tag
operator|*
operator|)
name|obj
operator|)
operator|->
name|tagged
operator|->
name|sha1
expr_stmt|;
if|if
condition|(
name|tagged_sha1
operator|&&
name|sha1_array_lookup
argument_list|(
name|points_at
argument_list|,
name|tagged_sha1
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|tagged_sha1
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/* Allocate space for a new ref_array_item and copy the objectname and flag to it */
end_comment
begin_function
DECL|function|new_ref_array_item
specifier|static
name|struct
name|ref_array_item
modifier|*
name|new_ref_array_item
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|objectname
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
decl_stmt|;
name|struct
name|ref_array_item
modifier|*
name|ref
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref_array_item
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
name|refname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ref
operator|->
name|refname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|objectname
argument_list|,
name|objectname
argument_list|)
expr_stmt|;
name|ref
operator|->
name|flag
operator|=
name|flag
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_comment
comment|/*  * A call-back given to for_each_ref().  Filter refs and keep them for  * later object processing.  */
end_comment
begin_function
DECL|function|ref_filter_handler
specifier|static
name|int
name|ref_filter_handler
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|struct
name|object_id
modifier|*
name|oid
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|ref_filter_cbdata
modifier|*
name|ref_cbdata
init|=
name|cb_data
decl_stmt|;
name|struct
name|ref_filter
modifier|*
name|filter
init|=
name|ref_cbdata
operator|->
name|filter
decl_stmt|;
name|struct
name|ref_array_item
modifier|*
name|ref
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|flag
operator|&
name|REF_BAD_NAME
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring ref with broken name %s"
argument_list|,
name|refname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flag
operator|&
name|REF_ISBROKEN
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring broken ref %s"
argument_list|,
name|refname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|filter
operator|->
name|name_patterns
operator|&&
operator|!
name|match_name_as_path
argument_list|(
name|filter
operator|->
name|name_patterns
argument_list|,
name|refname
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|filter
operator|->
name|points_at
operator|.
name|nr
operator|&&
operator|!
name|match_points_at
argument_list|(
operator|&
name|filter
operator|->
name|points_at
argument_list|,
name|oid
operator|->
name|hash
argument_list|,
name|refname
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * A merge filter is applied on refs pointing to commits. Hence 	 * obtain the commit using the 'oid' available and discard all 	 * non-commits early. The actual filtering is done later. 	 */
if|if
condition|(
name|filter
operator|->
name|merge_commit
operator|||
name|filter
operator|->
name|with_commit
condition|)
block|{
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|oid
operator|->
name|hash
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
return|return
literal|0
return|;
comment|/* We perform the filtering for the '--contains' option */
if|if
condition|(
name|filter
operator|->
name|with_commit
operator|&&
operator|!
name|commit_contains
argument_list|(
name|filter
argument_list|,
name|commit
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* 	 * We do not open the object yet; sort may only need refname 	 * to do its job and the resulting list may yet to be pruned 	 * by maxcount logic. 	 */
name|ref
operator|=
name|new_ref_array_item
argument_list|(
name|refname
argument_list|,
name|oid
operator|->
name|hash
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|ref
operator|->
name|commit
operator|=
name|commit
expr_stmt|;
name|REALLOC_ARRAY
argument_list|(
name|ref_cbdata
operator|->
name|array
operator|->
name|items
argument_list|,
name|ref_cbdata
operator|->
name|array
operator|->
name|nr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ref_cbdata
operator|->
name|array
operator|->
name|items
index|[
name|ref_cbdata
operator|->
name|array
operator|->
name|nr
operator|++
index|]
operator|=
name|ref
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  Free memory allocated for a ref_array_item */
end_comment
begin_function
DECL|function|free_array_item
specifier|static
name|void
name|free_array_item
parameter_list|(
name|struct
name|ref_array_item
modifier|*
name|item
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|item
operator|->
name|symref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Free all memory allocated for ref_array */
end_comment
begin_function
DECL|function|ref_array_clear
name|void
name|ref_array_clear
parameter_list|(
name|struct
name|ref_array
modifier|*
name|array
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|->
name|nr
condition|;
name|i
operator|++
control|)
name|free_array_item
argument_list|(
name|array
operator|->
name|items
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
operator|->
name|items
argument_list|)
expr_stmt|;
name|array
operator|->
name|items
operator|=
name|NULL
expr_stmt|;
name|array
operator|->
name|nr
operator|=
name|array
operator|->
name|alloc
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|do_merge_filter
specifier|static
name|void
name|do_merge_filter
parameter_list|(
name|struct
name|ref_filter_cbdata
modifier|*
name|ref_cbdata
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|old_nr
decl_stmt|;
name|struct
name|ref_filter
modifier|*
name|filter
init|=
name|ref_cbdata
operator|->
name|filter
decl_stmt|;
name|struct
name|ref_array
modifier|*
name|array
init|=
name|ref_cbdata
operator|->
name|array
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|to_clear
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit
operator|*
argument_list|)
argument_list|,
name|array
operator|->
name|nr
argument_list|)
decl_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ref_array_item
modifier|*
name|item
init|=
name|array
operator|->
name|items
index|[
name|i
index|]
decl_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
operator|&
name|item
operator|->
name|commit
operator|->
name|object
argument_list|,
name|item
operator|->
name|refname
argument_list|)
expr_stmt|;
name|to_clear
index|[
name|i
index|]
operator|=
name|item
operator|->
name|commit
expr_stmt|;
block|}
name|filter
operator|->
name|merge_commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
operator|&
name|filter
operator|->
name|merge_commit
operator|->
name|object
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|revs
operator|.
name|limited
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
name|old_nr
operator|=
name|array
operator|->
name|nr
expr_stmt|;
name|array
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ref_array_item
modifier|*
name|item
init|=
name|array
operator|->
name|items
index|[
name|i
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|item
operator|->
name|commit
decl_stmt|;
name|int
name|is_merged
init|=
operator|!
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
decl_stmt|;
if|if
condition|(
name|is_merged
operator|==
operator|(
name|filter
operator|->
name|merge
operator|==
name|REF_FILTER_MERGED_INCLUDE
operator|)
condition|)
name|array
operator|->
name|items
index|[
name|array
operator|->
name|nr
operator|++
index|]
operator|=
name|array
operator|->
name|items
index|[
name|i
index|]
expr_stmt|;
else|else
name|free_array_item
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_nr
condition|;
name|i
operator|++
control|)
name|clear_commit_marks
argument_list|(
name|to_clear
index|[
name|i
index|]
argument_list|,
name|ALL_REV_FLAGS
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|filter
operator|->
name|merge_commit
argument_list|,
name|ALL_REV_FLAGS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to_clear
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * API for filtering a set of refs. Based on the type of refs the user  * has requested, we iterate through those refs and apply filters  * as per the given ref_filter structure and finally store the  * filtered refs in the ref_array structure.  */
end_comment
begin_function
DECL|function|filter_refs
name|int
name|filter_refs
parameter_list|(
name|struct
name|ref_array
modifier|*
name|array
parameter_list|,
name|struct
name|ref_filter
modifier|*
name|filter
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
name|struct
name|ref_filter_cbdata
name|ref_cbdata
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ref_cbdata
operator|.
name|array
operator|=
name|array
expr_stmt|;
name|ref_cbdata
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
comment|/*  Simple per-ref filtering */
if|if
condition|(
name|type
operator|&
operator|(
name|FILTER_REFS_ALL
operator||
name|FILTER_REFS_INCLUDE_BROKEN
operator|)
condition|)
name|ret
operator|=
name|for_each_rawref
argument_list|(
name|ref_filter_handler
argument_list|,
operator|&
name|ref_cbdata
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&
name|FILTER_REFS_ALL
condition|)
name|ret
operator|=
name|for_each_ref
argument_list|(
name|ref_filter_handler
argument_list|,
operator|&
name|ref_cbdata
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
condition|)
name|die
argument_list|(
literal|"filter_refs: invalid type"
argument_list|)
expr_stmt|;
comment|/*  Filters that need revision walking */
if|if
condition|(
name|filter
operator|->
name|merge_commit
condition|)
name|do_merge_filter
argument_list|(
operator|&
name|ref_cbdata
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|cmp_ref_sorting
specifier|static
name|int
name|cmp_ref_sorting
parameter_list|(
name|struct
name|ref_sorting
modifier|*
name|s
parameter_list|,
name|struct
name|ref_array_item
modifier|*
name|a
parameter_list|,
name|struct
name|ref_array_item
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|atom_value
modifier|*
name|va
decl_stmt|,
modifier|*
name|vb
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|cmp_type
name|cmp_type
init|=
name|used_atom_type
index|[
name|s
operator|->
name|atom
index|]
decl_stmt|;
name|get_ref_atom_value
argument_list|(
name|a
argument_list|,
name|s
operator|->
name|atom
argument_list|,
operator|&
name|va
argument_list|)
expr_stmt|;
name|get_ref_atom_value
argument_list|(
name|b
argument_list|,
name|s
operator|->
name|atom
argument_list|,
operator|&
name|vb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmp_type
condition|)
block|{
case|case
name|FIELD_STR
case|:
name|cmp
operator|=
name|strcmp
argument_list|(
name|va
operator|->
name|s
argument_list|,
name|vb
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|va
operator|->
name|ul
operator|<
name|vb
operator|->
name|ul
condition|)
name|cmp
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|va
operator|->
name|ul
operator|==
name|vb
operator|->
name|ul
condition|)
name|cmp
operator|=
literal|0
expr_stmt|;
else|else
name|cmp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|s
operator|->
name|reverse
operator|)
condition|?
operator|-
name|cmp
else|:
name|cmp
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ref_sorting
specifier|static
name|struct
name|ref_sorting
modifier|*
name|ref_sorting
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compare_refs
specifier|static
name|int
name|compare_refs
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|)
block|{
name|struct
name|ref_array_item
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
expr|struct
name|ref_array_item
operator|*
operator|*
operator|)
name|a_
operator|)
decl_stmt|;
name|struct
name|ref_array_item
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
expr|struct
name|ref_array_item
operator|*
operator|*
operator|)
name|b_
operator|)
decl_stmt|;
name|struct
name|ref_sorting
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|ref_sorting
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|int
name|cmp
init|=
name|cmp_ref_sorting
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
condition|)
return|return
name|cmp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|ref_array_sort
name|void
name|ref_array_sort
parameter_list|(
name|struct
name|ref_sorting
modifier|*
name|sorting
parameter_list|,
name|struct
name|ref_array
modifier|*
name|array
parameter_list|)
block|{
name|ref_sorting
operator|=
name|sorting
expr_stmt|;
name|qsort
argument_list|(
name|array
operator|->
name|items
argument_list|,
name|array
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref_array_item
operator|*
argument_list|)
argument_list|,
name|compare_refs
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hex1
specifier|static
name|int
name|hex1
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
literal|'0'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|hex2
specifier|static
name|int
name|hex2
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|&&
name|cp
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|hex1
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hex1
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|append_literal
specifier|static
name|void
name|append_literal
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|,
name|struct
name|ref_formatting_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|s
init|=
operator|&
name|state
operator|->
name|stack
operator|->
name|output
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|!
name|ep
operator|||
name|cp
operator|<
name|ep
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
name|int
name|ch
init|=
name|hex2
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|ch
condition|)
block|{
name|strbuf_addch
argument_list|(
name|s
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|strbuf_addch
argument_list|(
name|s
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|show_ref_array_item
name|void
name|show_ref_array_item
parameter_list|(
name|struct
name|ref_array_item
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quote_style
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|final_buf
decl_stmt|;
name|struct
name|ref_formatting_state
name|state
init|=
name|REF_FORMATTING_STATE_INIT
decl_stmt|;
name|state
operator|.
name|quote_style
operator|=
name|quote_style
expr_stmt|;
name|push_stack_element
argument_list|(
operator|&
name|state
operator|.
name|stack
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|format
init|;
operator|*
name|cp
operator|&&
operator|(
name|sp
operator|=
name|find_next
argument_list|(
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|=
name|ep
operator|+
literal|1
control|)
block|{
name|struct
name|atom_value
modifier|*
name|atomv
decl_stmt|;
name|ep
operator|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|sp
condition|)
name|append_literal
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|get_ref_atom_value
argument_list|(
name|info
argument_list|,
name|parse_ref_filter_atom
argument_list|(
name|sp
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
argument_list|,
operator|&
name|atomv
argument_list|)
expr_stmt|;
name|atomv
operator|->
name|handler
argument_list|(
name|atomv
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|sp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|append_literal
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_color_reset_at_eol
condition|)
block|{
name|struct
name|atom_value
name|resetv
decl_stmt|;
name|char
name|color
index|[
name|COLOR_MAXLEN
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|color_parse
argument_list|(
literal|"reset"
argument_list|,
name|color
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"BUG: couldn't parse 'reset' as a color"
argument_list|)
expr_stmt|;
name|resetv
operator|.
name|s
operator|=
name|color
expr_stmt|;
name|append_atom
argument_list|(
operator|&
name|resetv
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|.
name|stack
operator|->
name|prev
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"format: %%(end) atom missing"
argument_list|)
argument_list|)
expr_stmt|;
name|final_buf
operator|=
operator|&
name|state
operator|.
name|stack
operator|->
name|output
expr_stmt|;
name|fwrite
argument_list|(
name|final_buf
operator|->
name|buf
argument_list|,
literal|1
argument_list|,
name|final_buf
operator|->
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|pop_stack_element
argument_list|(
operator|&
name|state
operator|.
name|stack
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  If no sorting option is given, use refname to sort as default */
end_comment
begin_function
DECL|function|ref_default_sorting
name|struct
name|ref_sorting
modifier|*
name|ref_default_sorting
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|cstr_name
index|[]
init|=
literal|"refname"
decl_stmt|;
name|struct
name|ref_sorting
modifier|*
name|sorting
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sorting
argument_list|)
argument_list|)
decl_stmt|;
name|sorting
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sorting
operator|->
name|atom
operator|=
name|parse_ref_filter_atom
argument_list|(
name|cstr_name
argument_list|,
name|cstr_name
operator|+
name|strlen
argument_list|(
name|cstr_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sorting
return|;
block|}
end_function
begin_function
DECL|function|parse_opt_ref_sorting
name|int
name|parse_opt_ref_sorting
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|ref_sorting
modifier|*
modifier|*
name|sorting_tail
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|struct
name|ref_sorting
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
comment|/* should --no-sort void the list ? */
return|return
operator|-
literal|1
return|;
name|s
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
operator|*
name|sorting_tail
expr_stmt|;
operator|*
name|sorting_tail
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
name|s
operator|->
name|reverse
operator|=
literal|1
expr_stmt|;
name|arg
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|atom
operator|=
name|parse_ref_filter_atom
argument_list|(
name|arg
argument_list|,
name|arg
operator|+
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_opt_merge_filter
name|int
name|parse_opt_merge_filter
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|ref_filter
modifier|*
name|rf
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|rf
operator|->
name|merge
operator|=
name|starts_with
argument_list|(
name|opt
operator|->
name|long_name
argument_list|,
literal|"no"
argument_list|)
condition|?
name|REF_FILTER_MERGED_OMIT
else|:
name|REF_FILTER_MERGED_INCLUDE
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|arg
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"malformed object name %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rf
operator|->
name|merge_commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rf
operator|->
name|merge_commit
condition|)
return|return
name|opterror
argument_list|(
name|opt
argument_list|,
literal|"must point to a commit"
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
end_unit
