begin_unit
begin_comment
comment|/*  * GIT - The information manager from hell  *  * Copyright (C) Linus Torvalds, 2005  * Copyright (C) Johannes Schindelin, 2005  *  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_typedef
DECL|struct|config_file
typedef|typedef
struct|struct
name|config_file
block|{
DECL|member|prev
name|struct
name|config_file
modifier|*
name|prev
decl_stmt|;
DECL|member|f
name|FILE
modifier|*
name|f
decl_stmt|;
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|linenr
name|int
name|linenr
decl_stmt|;
DECL|member|eof
name|int
name|eof
decl_stmt|;
DECL|member|value
name|struct
name|strbuf
name|value
decl_stmt|;
DECL|member|var
name|struct
name|strbuf
name|var
decl_stmt|;
block|}
DECL|typedef|config_file
name|config_file
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|cf
specifier|static
name|config_file
modifier|*
name|cf
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|zlib_compression_seen
specifier|static
name|int
name|zlib_compression_seen
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|MAX_INCLUDE_DEPTH
define|#
directive|define
name|MAX_INCLUDE_DEPTH
value|10
end_define
begin_decl_stmt
DECL|variable|include_depth_advice
specifier|static
specifier|const
name|char
name|include_depth_advice
index|[]
init|=
literal|"exceeded maximum include depth (%d) while including\n"
literal|"	%s\n"
literal|"from\n"
literal|"	%s\n"
literal|"Do you have circular includes?"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|handle_path_include
specifier|static
name|int
name|handle_path_include
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|config_include_data
modifier|*
name|inc
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|expanded
init|=
name|expand_user_path
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expanded
condition|)
return|return
name|error
argument_list|(
literal|"Could not expand include path '%s'"
argument_list|,
name|path
argument_list|)
return|;
name|path
operator|=
name|expanded
expr_stmt|;
comment|/* 	 * Use an absolute path as-is, but interpret relative paths 	 * based on the including config file. 	 */
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
operator|!
name|cf
operator|||
operator|!
name|cf
operator|->
name|name
condition|)
return|return
name|error
argument_list|(
literal|"relative config includes must come from files"
argument_list|)
return|;
name|slash
operator|=
name|find_last_dir_sep
argument_list|(
name|cf
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|cf
operator|->
name|name
argument_list|,
name|slash
operator|-
name|cf
operator|->
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|access_or_die
argument_list|(
name|path
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|inc
operator|->
name|depth
operator|>
name|MAX_INCLUDE_DEPTH
condition|)
name|die
argument_list|(
name|include_depth_advice
argument_list|,
name|MAX_INCLUDE_DEPTH
argument_list|,
name|path
argument_list|,
name|cf
operator|&&
name|cf
operator|->
name|name
condition|?
name|cf
operator|->
name|name
else|:
literal|"the command line"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|git_config_from_file
argument_list|(
name|git_config_include
argument_list|,
name|path
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|inc
operator|->
name|depth
operator|--
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config_include
name|int
name|git_config_include
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|config_include_data
modifier|*
name|inc
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Pass along all values, including "include" directives; this makes it 	 * possible to query information on the includes themselves. 	 */
name|ret
operator|=
name|inc
operator|->
name|fn
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|inc
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|type
operator|=
name|skip_prefix
argument_list|(
name|var
argument_list|,
literal|"include."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"path"
argument_list|)
condition|)
name|ret
operator|=
name|handle_path_include
argument_list|(
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|lowercase
specifier|static
name|void
name|lowercase
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_config_push_parameter
name|void
name|git_config_push_parameter
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
name|struct
name|strbuf
name|env
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|old
init|=
name|getenv
argument_list|(
name|CONFIG_DATA_ENVIRONMENT
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|env
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|env
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|sq_quote_buf
argument_list|(
operator|&
name|env
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|CONFIG_DATA_ENVIRONMENT
argument_list|,
name|env
operator|.
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|env
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_config_parse_parameter
name|int
name|git_config_parse_parameter
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|config_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
modifier|*
name|pair
decl_stmt|;
name|pair
operator|=
name|strbuf_split_str
argument_list|(
name|text
argument_list|,
literal|'='
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pair
index|[
literal|0
index|]
condition|)
return|return
name|error
argument_list|(
literal|"bogus config parameter: %s"
argument_list|,
name|text
argument_list|)
return|;
if|if
condition|(
name|pair
index|[
literal|0
index|]
operator|->
name|len
operator|&&
name|pair
index|[
literal|0
index|]
operator|->
name|buf
index|[
name|pair
index|[
literal|0
index|]
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'='
condition|)
name|strbuf_setlen
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|pair
index|[
literal|0
index|]
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strbuf_trim
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pair
index|[
literal|0
index|]
operator|->
name|len
condition|)
block|{
name|strbuf_list_free
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"bogus config parameter: %s"
argument_list|,
name|text
argument_list|)
return|;
block|}
name|lowercase
argument_list|(
name|pair
index|[
literal|0
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
argument_list|(
name|pair
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
name|pair
index|[
literal|1
index|]
condition|?
name|pair
index|[
literal|1
index|]
operator|->
name|buf
else|:
name|NULL
argument_list|,
name|data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_list_free
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strbuf_list_free
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_config_from_parameters
name|int
name|git_config_from_parameters
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
name|CONFIG_DATA_ENVIRONMENT
argument_list|)
decl_stmt|;
name|char
modifier|*
name|envw
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|argv
init|=
name|NULL
decl_stmt|;
name|int
name|nr
init|=
literal|0
decl_stmt|,
name|alloc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
return|return
literal|0
return|;
comment|/* sq_dequote will write over it */
name|envw
operator|=
name|xstrdup
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dequote_to_argv
argument_list|(
name|envw
argument_list|,
operator|&
name|argv
argument_list|,
operator|&
name|nr
argument_list|,
operator|&
name|alloc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|envw
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"bogus format in "
name|CONFIG_DATA_ENVIRONMENT
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|git_config_parse_parameter
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|fn
argument_list|,
name|data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|envw
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|envw
argument_list|)
expr_stmt|;
return|return
name|nr
operator|>
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_next_char
specifier|static
name|int
name|get_next_char
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|cf
operator|&&
operator|(
operator|(
name|f
operator|=
name|cf
operator|->
name|f
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* DOS like systems */
name|c
operator|=
name|fgetc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|cf
operator|->
name|linenr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|cf
operator|->
name|eof
operator|=
literal|1
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|parse_value
specifier|static
name|char
modifier|*
name|parse_value
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|quote
init|=
literal|0
decl_stmt|,
name|comment
init|=
literal|0
decl_stmt|,
name|space
init|=
literal|0
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|cf
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|quote
condition|)
block|{
name|cf
operator|->
name|linenr
operator|--
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|cf
operator|->
name|value
operator|.
name|buf
return|;
block|}
if|if
condition|(
name|comment
condition|)
continue|continue;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|quote
condition|)
block|{
if|if
condition|(
name|cf
operator|->
name|value
operator|.
name|len
condition|)
name|space
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|quote
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'#'
condition|)
block|{
name|comment
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
init|;
name|space
condition|;
name|space
operator|--
control|)
name|strbuf_addch
argument_list|(
operator|&
name|cf
operator|->
name|value
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
continue|continue;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
comment|/* Some characters escape as themselves */
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
comment|/* Reject unknown escape sequences */
default|default:
return|return
name|NULL
return|;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|cf
operator|->
name|value
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|quote
operator|=
literal|1
operator|-
name|quote
expr_stmt|;
continue|continue;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|cf
operator|->
name|value
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|iskeychar
specifier|static
specifier|inline
name|int
name|iskeychar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
return|;
block|}
end_function
begin_function
DECL|function|get_value
specifier|static
name|int
name|get_value
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|strbuf
modifier|*
name|name
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Get the full name */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|cf
operator|->
name|eof
condition|)
break|break;
if|if
condition|(
operator|!
name|iskeychar
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|strbuf_addch
argument_list|(
name|name
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'='
condition|)
return|return
operator|-
literal|1
return|;
name|value
operator|=
name|parse_value
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|fn
argument_list|(
name|name
operator|->
name|buf
argument_list|,
name|value
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_extended_base_var
specifier|static
name|int
name|get_extended_base_var
parameter_list|(
name|struct
name|strbuf
modifier|*
name|name
parameter_list|,
name|int
name|c
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
goto|goto
name|error_incomplete_line
goto|;
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* We require the format to be '[base "extension"]' */
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
return|return
operator|-
literal|1
return|;
name|strbuf_addch
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
goto|goto
name|error_incomplete_line
goto|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
goto|goto
name|error_incomplete_line
goto|;
block|}
name|strbuf_addch
argument_list|(
name|name
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Final ']' */
if|if
condition|(
name|get_next_char
argument_list|()
operator|!=
literal|']'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
name|error_incomplete_line
label|:
name|cf
operator|->
name|linenr
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|get_base_var
specifier|static
name|int
name|get_base_var
parameter_list|(
name|struct
name|strbuf
modifier|*
name|name
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|cf
operator|->
name|eof
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|get_extended_base_var
argument_list|(
name|name
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
operator|!
name|iskeychar
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
name|strbuf_addch
argument_list|(
name|name
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|git_parse_file
specifier|static
name|int
name|git_parse_file
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|comment
init|=
literal|0
decl_stmt|;
name|int
name|baselen
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|var
init|=
operator|&
name|cf
operator|->
name|var
decl_stmt|;
comment|/* U+FEFF Byte Order Mark in UTF8 */
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|utf8_bom
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"\xef\xbb\xbf"
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|bomptr
init|=
name|utf8_bom
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|bomptr
operator|&&
operator|*
name|bomptr
condition|)
block|{
comment|/* We are at the file beginning; skip UTF8-encoded BOM 			 * if present. Sane editors won't put this in on their 			 * own, but e.g. Windows Notepad will do it happily. */
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|c
operator|==
operator|*
name|bomptr
condition|)
block|{
name|bomptr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Do not tolerate partial BOM. */
if|if
condition|(
name|bomptr
operator|!=
name|utf8_bom
condition|)
break|break;
comment|/* No BOM at file beginning. Cool. */
name|bomptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|cf
operator|->
name|eof
condition|)
return|return
literal|0
return|;
name|comment
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|comment
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|';'
condition|)
block|{
name|comment
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
comment|/* Reset prior to determining a new stem */
name|strbuf_reset
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_base_var
argument_list|(
name|var
argument_list|)
operator|<
literal|0
operator|||
name|var
operator|->
name|len
operator|<
literal|1
condition|)
break|break;
name|strbuf_addch
argument_list|(
name|var
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|baselen
operator|=
name|var
operator|->
name|len
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
break|break;
comment|/* 		 * Truncate the var name back to the section header 		 * stem prior to grabbing the suffix part of the name 		 * and the value. 		 */
name|strbuf_setlen
argument_list|(
name|var
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|var
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_value
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|var
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
name|die
argument_list|(
literal|"bad config file line %d in %s"
argument_list|,
name|cf
operator|->
name|linenr
argument_list|,
name|cf
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_unit_factor
specifier|static
name|int
name|parse_unit_factor
parameter_list|(
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|uintmax_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|end
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|end
argument_list|,
literal|"k"
argument_list|)
condition|)
block|{
operator|*
name|val
operator|*=
literal|1024
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|end
argument_list|,
literal|"m"
argument_list|)
condition|)
block|{
operator|*
name|val
operator|*=
literal|1024
operator|*
literal|1024
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|end
argument_list|,
literal|"g"
argument_list|)
condition|)
block|{
operator|*
name|val
operator|*=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_parse_long
specifier|static
name|int
name|git_parse_long
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|long
modifier|*
name|ret
parameter_list|)
block|{
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|intmax_t
name|val
decl_stmt|;
name|uintmax_t
name|uval
decl_stmt|;
name|uintmax_t
name|factor
init|=
literal|1
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|strtoimax
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|parse_unit_factor
argument_list|(
name|end
argument_list|,
operator|&
name|factor
argument_list|)
condition|)
return|return
literal|0
return|;
name|uval
operator|=
name|abs
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|uval
operator|*=
name|factor
expr_stmt|;
if|if
condition|(
operator|(
name|uval
operator|>
name|maximum_signed_value_of_type
argument_list|(
name|long
argument_list|)
operator|)
operator|||
operator|(
name|abs
argument_list|(
name|val
argument_list|)
operator|>
name|uval
operator|)
condition|)
return|return
literal|0
return|;
name|val
operator|*=
name|factor
expr_stmt|;
operator|*
name|ret
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_parse_ulong
name|int
name|git_parse_ulong
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|unsigned
name|long
modifier|*
name|ret
parameter_list|)
block|{
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|uintmax_t
name|val
decl_stmt|;
name|uintmax_t
name|oldval
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|strtoumax
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
return|return
literal|0
return|;
name|oldval
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|!
name|parse_unit_factor
argument_list|(
name|end
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|val
operator|>
name|maximum_unsigned_value_of_type
argument_list|(
name|long
argument_list|)
operator|)
operator|||
operator|(
name|oldval
operator|>
name|val
operator|)
condition|)
return|return
literal|0
return|;
operator|*
name|ret
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|die_bad_config
specifier|static
name|void
name|die_bad_config
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|cf
operator|&&
name|cf
operator|->
name|name
condition|)
name|die
argument_list|(
literal|"bad config value for '%s' in %s"
argument_list|,
name|name
argument_list|,
name|cf
operator|->
name|name
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"bad config value for '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_config_int
name|int
name|git_config_int
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|long
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|git_parse_long
argument_list|(
name|value
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
name|die_bad_config
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config_ulong
name|unsigned
name|long
name|git_config_ulong
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|git_parse_ulong
argument_list|(
name|value
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
name|die_bad_config
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config_maybe_bool_text
specifier|static
name|int
name|git_config_maybe_bool_text
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|value
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"yes"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"no"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|git_config_maybe_bool
name|int
name|git_config_maybe_bool
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|long
name|v
init|=
name|git_config_maybe_bool_text
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|v
condition|)
return|return
name|v
return|;
if|if
condition|(
name|git_parse_long
argument_list|(
name|value
argument_list|,
operator|&
name|v
argument_list|)
condition|)
return|return
operator|!
operator|!
name|v
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|git_config_bool_or_int
name|int
name|git_config_bool_or_int
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|is_bool
parameter_list|)
block|{
name|int
name|v
init|=
name|git_config_maybe_bool_text
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|v
condition|)
block|{
operator|*
name|is_bool
operator|=
literal|1
expr_stmt|;
return|return
name|v
return|;
block|}
operator|*
name|is_bool
operator|=
literal|0
expr_stmt|;
return|return
name|git_config_int
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_config_bool
name|int
name|git_config_bool
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|discard
decl_stmt|;
return|return
operator|!
operator|!
name|git_config_bool_or_int
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
operator|&
name|discard
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_config_string
name|int
name|git_config_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
operator|*
name|dest
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_config_pathname
name|int
name|git_config_pathname
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
operator|*
name|dest
operator|=
name|expand_user_path
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|dest
condition|)
name|die
argument_list|(
literal|"Failed to expand user dir in: '%s'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_default_core_config
specifier|static
name|int
name|git_default_core_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
comment|/* This needs a better name */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.filemode"
argument_list|)
condition|)
block|{
name|trust_executable_bit
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.trustctime"
argument_list|)
condition|)
block|{
name|trust_ctime
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.quotepath"
argument_list|)
condition|)
block|{
name|quote_path_fully
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.symlinks"
argument_list|)
condition|)
block|{
name|has_symlinks
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.ignorecase"
argument_list|)
condition|)
block|{
name|ignore_case
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.attributesfile"
argument_list|)
condition|)
return|return
name|git_config_pathname
argument_list|(
operator|&
name|git_attributes_file
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.bare"
argument_list|)
condition|)
block|{
name|is_bare_repository_cfg
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.ignorestat"
argument_list|)
condition|)
block|{
name|assume_unchanged
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.prefersymlinkrefs"
argument_list|)
condition|)
block|{
name|prefer_symlink_refs
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.logallrefupdates"
argument_list|)
condition|)
block|{
name|log_all_ref_updates
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.warnambiguousrefs"
argument_list|)
condition|)
block|{
name|warn_ambiguous_refs
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.abbrev"
argument_list|)
condition|)
block|{
name|int
name|abbrev
init|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|abbrev
operator|<
name|minimum_abbrev
operator|||
name|abbrev
operator|>
literal|40
condition|)
return|return
operator|-
literal|1
return|;
name|default_abbrev
operator|=
name|abbrev
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.loosecompression"
argument_list|)
condition|)
block|{
name|int
name|level
init|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|Z_BEST_COMPRESSION
condition|)
name|die
argument_list|(
literal|"bad zlib compression level %d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|zlib_compression_level
operator|=
name|level
expr_stmt|;
name|zlib_compression_seen
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.compression"
argument_list|)
condition|)
block|{
name|int
name|level
init|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|Z_BEST_COMPRESSION
condition|)
name|die
argument_list|(
literal|"bad zlib compression level %d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|core_compression_level
operator|=
name|level
expr_stmt|;
name|core_compression_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|zlib_compression_seen
condition|)
name|zlib_compression_level
operator|=
name|level
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.packedgitwindowsize"
argument_list|)
condition|)
block|{
name|int
name|pgsz_x2
init|=
name|getpagesize
argument_list|()
operator|*
literal|2
decl_stmt|;
name|packed_git_window_size
operator|=
name|git_config_ulong
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* This value must be multiple of (pagesize * 2) */
name|packed_git_window_size
operator|/=
name|pgsz_x2
expr_stmt|;
if|if
condition|(
name|packed_git_window_size
operator|<
literal|1
condition|)
name|packed_git_window_size
operator|=
literal|1
expr_stmt|;
name|packed_git_window_size
operator|*=
name|pgsz_x2
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.bigfilethreshold"
argument_list|)
condition|)
block|{
name|big_file_threshold
operator|=
name|git_config_ulong
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.packedgitlimit"
argument_list|)
condition|)
block|{
name|packed_git_limit
operator|=
name|git_config_ulong
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.deltabasecachelimit"
argument_list|)
condition|)
block|{
name|delta_base_cache_limit
operator|=
name|git_config_ulong
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.logpackaccess"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|log_pack_access
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.autocrlf"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"input"
argument_list|)
condition|)
block|{
if|if
condition|(
name|core_eol
operator|==
name|EOL_CRLF
condition|)
return|return
name|error
argument_list|(
literal|"core.autocrlf=input conflicts with core.eol=crlf"
argument_list|)
return|;
name|auto_crlf
operator|=
name|AUTO_CRLF_INPUT
expr_stmt|;
return|return
literal|0
return|;
block|}
name|auto_crlf
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.safecrlf"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"warn"
argument_list|)
condition|)
block|{
name|safe_crlf
operator|=
name|SAFE_CRLF_WARN
expr_stmt|;
return|return
literal|0
return|;
block|}
name|safe_crlf
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.eol"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"lf"
argument_list|)
condition|)
name|core_eol
operator|=
name|EOL_LF
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"crlf"
argument_list|)
condition|)
name|core_eol
operator|=
name|EOL_CRLF
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"native"
argument_list|)
condition|)
name|core_eol
operator|=
name|EOL_NATIVE
expr_stmt|;
else|else
name|core_eol
operator|=
name|EOL_UNSET
expr_stmt|;
if|if
condition|(
name|core_eol
operator|==
name|EOL_CRLF
operator|&&
name|auto_crlf
operator|==
name|AUTO_CRLF_INPUT
condition|)
return|return
name|error
argument_list|(
literal|"core.autocrlf=input conflicts with core.eol=crlf"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.notesref"
argument_list|)
condition|)
block|{
name|notes_ref_name
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.pager"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|pager_program
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.editor"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|editor_program
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.askpass"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|askpass_program
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.excludesfile"
argument_list|)
condition|)
return|return
name|git_config_pathname
argument_list|(
operator|&
name|excludes_file
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.whitespace"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
name|whitespace_rule_cfg
operator|=
name|parse_whitespace_rule
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.fsyncobjectfiles"
argument_list|)
condition|)
block|{
name|fsync_object_files
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.preloadindex"
argument_list|)
condition|)
block|{
name|core_preload_index
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.createobject"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"rename"
argument_list|)
condition|)
name|object_creation_mode
operator|=
name|OBJECT_CREATION_USES_RENAMES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"link"
argument_list|)
condition|)
name|object_creation_mode
operator|=
name|OBJECT_CREATION_USES_HARDLINKS
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Invalid mode for object creation: %s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.sparsecheckout"
argument_list|)
condition|)
block|{
name|core_apply_sparse_checkout
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.precomposeunicode"
argument_list|)
condition|)
block|{
name|precomposed_unicode
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Add other config variables here and to Documentation/config.txt. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_default_i18n_config
specifier|static
name|int
name|git_default_i18n_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"i18n.commitencoding"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|git_commit_encoding
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"i18n.logoutputencoding"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|git_log_output_encoding
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
comment|/* Add other config variables here and to Documentation/config.txt. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_default_branch_config
specifier|static
name|int
name|git_default_branch_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"branch.autosetupmerge"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"always"
argument_list|)
condition|)
block|{
name|git_branch_track
operator|=
name|BRANCH_TRACK_ALWAYS
expr_stmt|;
return|return
literal|0
return|;
block|}
name|git_branch_track
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"branch.autosetuprebase"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"never"
argument_list|)
condition|)
name|autorebase
operator|=
name|AUTOREBASE_NEVER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"local"
argument_list|)
condition|)
name|autorebase
operator|=
name|AUTOREBASE_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"remote"
argument_list|)
condition|)
name|autorebase
operator|=
name|AUTOREBASE_REMOTE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"always"
argument_list|)
condition|)
name|autorebase
operator|=
name|AUTOREBASE_ALWAYS
expr_stmt|;
else|else
return|return
name|error
argument_list|(
literal|"Malformed value for %s"
argument_list|,
name|var
argument_list|)
return|;
return|return
literal|0
return|;
block|}
comment|/* Add other config variables here and to Documentation/config.txt. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_default_push_config
specifier|static
name|int
name|git_default_push_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"push.default"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"nothing"
argument_list|)
condition|)
name|push_default
operator|=
name|PUSH_DEFAULT_NOTHING
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"matching"
argument_list|)
condition|)
name|push_default
operator|=
name|PUSH_DEFAULT_MATCHING
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"simple"
argument_list|)
condition|)
name|push_default
operator|=
name|PUSH_DEFAULT_SIMPLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"upstream"
argument_list|)
condition|)
name|push_default
operator|=
name|PUSH_DEFAULT_UPSTREAM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"tracking"
argument_list|)
condition|)
comment|/* deprecated */
name|push_default
operator|=
name|PUSH_DEFAULT_UPSTREAM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"current"
argument_list|)
condition|)
name|push_default
operator|=
name|PUSH_DEFAULT_CURRENT
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"Malformed value for %s: %s"
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Must be one of nothing, matching, simple, "
literal|"upstream or current."
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Add other config variables here and to Documentation/config.txt. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_default_mailmap_config
specifier|static
name|int
name|git_default_mailmap_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"mailmap.file"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|git_mailmap_file
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
comment|/* Add other config variables here and to Documentation/config.txt. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_default_config
name|int
name|git_default_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"core."
argument_list|)
condition|)
return|return
name|git_default_core_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"user."
argument_list|)
condition|)
return|return
name|git_ident_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|dummy
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"i18n."
argument_list|)
condition|)
return|return
name|git_default_i18n_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"branch."
argument_list|)
condition|)
return|return
name|git_default_branch_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"push."
argument_list|)
condition|)
return|return
name|git_default_push_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"mailmap."
argument_list|)
condition|)
return|return
name|git_default_mailmap_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"advice."
argument_list|)
condition|)
return|return
name|git_default_advice_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"pager.color"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"color.pager"
argument_list|)
condition|)
block|{
name|pager_use_color
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"pack.packsizelimit"
argument_list|)
condition|)
block|{
name|pack_size_limit_cfg
operator|=
name|git_config_ulong
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Add other config variables here and to Documentation/config.txt. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_config_from_file
name|int
name|git_config_from_file
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|config_file
name|top
decl_stmt|;
comment|/* push config-file parsing state stack */
name|top
operator|.
name|prev
operator|=
name|cf
expr_stmt|;
name|top
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|top
operator|.
name|name
operator|=
name|filename
expr_stmt|;
name|top
operator|.
name|linenr
operator|=
literal|1
expr_stmt|;
name|top
operator|.
name|eof
operator|=
literal|0
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|top
operator|.
name|value
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|top
operator|.
name|var
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|cf
operator|=
operator|&
name|top
expr_stmt|;
name|ret
operator|=
name|git_parse_file
argument_list|(
name|fn
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* pop config-file parsing state stack */
name|strbuf_release
argument_list|(
operator|&
name|top
operator|.
name|value
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|top
operator|.
name|var
argument_list|)
expr_stmt|;
name|cf
operator|=
name|top
operator|.
name|prev
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_etc_gitconfig
specifier|const
name|char
modifier|*
name|git_etc_gitconfig
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|system_wide
decl_stmt|;
if|if
condition|(
operator|!
name|system_wide
condition|)
name|system_wide
operator|=
name|system_path
argument_list|(
name|ETC_GITCONFIG
argument_list|)
expr_stmt|;
return|return
name|system_wide
return|;
block|}
end_function
begin_function
DECL|function|git_env_bool
name|int
name|git_env_bool
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
name|int
name|def
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|v
init|=
name|getenv
argument_list|(
name|k
argument_list|)
decl_stmt|;
return|return
name|v
condition|?
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
else|:
name|def
return|;
block|}
end_function
begin_function
DECL|function|git_config_system
name|int
name|git_config_system
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|!
name|git_env_bool
argument_list|(
literal|"GIT_CONFIG_NOSYSTEM"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_config_early
name|int
name|git_config_early
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|repo_config
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|xdg_config
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|user_config
init|=
name|NULL
decl_stmt|;
name|home_config_paths
argument_list|(
operator|&
name|user_config
argument_list|,
operator|&
name|xdg_config
argument_list|,
literal|"config"
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_system
argument_list|()
operator|&&
operator|!
name|access_or_die
argument_list|(
name|git_etc_gitconfig
argument_list|()
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
name|ret
operator|+=
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|git_etc_gitconfig
argument_list|()
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|found
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|xdg_config
operator|&&
operator|!
name|access_or_die
argument_list|(
name|xdg_config
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
name|ret
operator|+=
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|xdg_config
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|found
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|user_config
operator|&&
operator|!
name|access_or_die
argument_list|(
name|user_config
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
name|ret
operator|+=
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|user_config
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|found
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|repo_config
operator|&&
operator|!
name|access_or_die
argument_list|(
name|repo_config
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
name|ret
operator|+=
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|repo_config
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|found
operator|+=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|git_config_from_parameters
argument_list|(
name|fn
argument_list|,
name|data
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* error */
name|die
argument_list|(
literal|"unable to parse command-line config"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* found nothing */
break|break;
default|default:
comment|/* found at least one item */
name|found
operator|++
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|xdg_config
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|user_config
argument_list|)
expr_stmt|;
return|return
name|ret
operator|==
literal|0
condition|?
name|found
else|:
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config_with_options
name|int
name|git_config_with_options
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|respect_includes
parameter_list|)
block|{
name|char
modifier|*
name|repo_config
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|config_include_data
name|inc
init|=
name|CONFIG_INCLUDE_INIT
decl_stmt|;
if|if
condition|(
name|respect_includes
condition|)
block|{
name|inc
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|inc
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|fn
operator|=
name|git_config_include
expr_stmt|;
name|data
operator|=
operator|&
name|inc
expr_stmt|;
block|}
comment|/* 	 * If we have a specific filename, use it. Otherwise, follow the 	 * regular lookup sequence. 	 */
if|if
condition|(
name|filename
condition|)
return|return
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|filename
argument_list|,
name|data
argument_list|)
return|;
name|repo_config
operator|=
name|git_pathdup
argument_list|(
literal|"config"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|git_config_early
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|repo_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|repo_config
condition|)
name|free
argument_list|(
name|repo_config
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config
name|int
name|git_config
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|git_config_with_options
argument_list|(
name|fn
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Find all the stuff for git_config_set() below.  */
end_comment
begin_define
DECL|macro|MAX_MATCHES
define|#
directive|define
name|MAX_MATCHES
value|512
end_define
begin_struct
specifier|static
struct|struct
block|{
DECL|member|baselen
name|int
name|baselen
decl_stmt|;
DECL|member|key
name|char
modifier|*
name|key
decl_stmt|;
DECL|member|do_not_match
name|int
name|do_not_match
decl_stmt|;
DECL|member|value_regex
name|regex_t
modifier|*
name|value_regex
decl_stmt|;
DECL|member|multi_replace
name|int
name|multi_replace
decl_stmt|;
DECL|member|offset
name|size_t
name|offset
index|[
name|MAX_MATCHES
index|]
decl_stmt|;
DECL|enumerator|START
DECL|enumerator|SECTION_SEEN
DECL|enumerator|SECTION_END_SEEN
DECL|enumerator|KEY_SEEN
DECL|member|state
enum|enum
block|{
name|START
block|,
name|SECTION_SEEN
block|,
name|SECTION_END_SEEN
block|,
name|KEY_SEEN
block|}
name|state
enum|;
DECL|member|seen
name|int
name|seen
decl_stmt|;
block|}
DECL|variable|store
name|store
struct|;
end_struct
begin_function
DECL|function|matches
specifier|static
name|int
name|matches
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|store
operator|.
name|key
argument_list|)
operator|&&
operator|(
name|store
operator|.
name|value_regex
operator|==
name|NULL
operator|||
operator|(
name|store
operator|.
name|do_not_match
operator|^
operator|!
name|regexec
argument_list|(
name|store
operator|.
name|value_regex
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|store_aux
specifier|static
name|int
name|store_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ep
decl_stmt|;
name|size_t
name|section_len
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|cf
operator|->
name|f
decl_stmt|;
switch|switch
condition|(
name|store
operator|.
name|state
condition|)
block|{
case|case
name|KEY_SEEN
case|:
if|if
condition|(
name|matches
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|store
operator|.
name|seen
operator|==
literal|1
operator|&&
name|store
operator|.
name|multi_replace
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"%s has multiple values"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|store
operator|.
name|seen
operator|>=
name|MAX_MATCHES
condition|)
block|{
name|error
argument_list|(
literal|"too many matches for %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|store
operator|.
name|seen
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SECTION_SEEN
case|:
comment|/* 		 * What we are looking for is in store.key (both 		 * section and var), and its section part is baselen 		 * long.  We found key (again, both section and var). 		 * We would want to know if this key is in the same 		 * section as what we are looking for.  We already 		 * know we are in the same section as what should 		 * hold store.key. 		 */
name|ep
operator|=
name|strrchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|section_len
operator|=
name|ep
operator|-
name|key
expr_stmt|;
if|if
condition|(
operator|(
name|section_len
operator|!=
name|store
operator|.
name|baselen
operator|)
operator|||
name|memcmp
argument_list|(
name|key
argument_list|,
name|store
operator|.
name|key
argument_list|,
name|section_len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|store
operator|.
name|state
operator|=
name|SECTION_END_SEEN
expr_stmt|;
break|break;
block|}
comment|/* 		 * Do not increment matches: this is no match, but we 		 * just made sure we are in the desired section. 		 */
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* fallthru */
case|case
name|SECTION_END_SEEN
case|:
case|case
name|START
case|:
if|if
condition|(
name|matches
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|store
operator|.
name|state
operator|=
name|KEY_SEEN
expr_stmt|;
name|store
operator|.
name|seen
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strrchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|)
operator|-
name|key
operator|==
name|store
operator|.
name|baselen
operator|&&
operator|!
name|strncmp
argument_list|(
name|key
argument_list|,
name|store
operator|.
name|key
argument_list|,
name|store
operator|.
name|baselen
argument_list|)
condition|)
block|{
name|store
operator|.
name|state
operator|=
name|SECTION_SEEN
expr_stmt|;
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_error
specifier|static
name|int
name|write_error
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|error
argument_list|(
literal|"failed to write new configuration file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Same error code as "failed to rename". */
return|return
literal|4
return|;
block|}
end_function
begin_function
DECL|function|store_write_section
specifier|static
name|int
name|store_write_section
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dot
decl_stmt|;
name|int
name|i
decl_stmt|,
name|success
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|dot
operator|=
name|memchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|,
name|store
operator|.
name|baselen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"[%.*s \""
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dot
operator|-
name|key
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dot
operator|-
name|key
operator|+
literal|1
init|;
name|i
operator|<
name|store
operator|.
name|baselen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|key
index|[
name|i
index|]
operator|==
literal|'"'
operator|||
name|key
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\"]\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"[%.*s]\n"
argument_list|,
name|store
operator|.
name|baselen
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|==
name|sb
operator|.
name|len
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_function
DECL|function|store_write_pair
specifier|static
name|int
name|store_write_pair
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|success
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|key
operator|+
name|store
operator|.
name|baselen
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|quote
init|=
literal|""
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* 	 * Check to see if the value needs to be surrounded with a dq pair. 	 * Note that problematic characters are always backslash-quoted; this 	 * check is about not losing leading or trailing SP and strings that 	 * follow beginning-of-comment characters (i.e. ';' and '#') by the 	 * configuration parser. 	 */
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|quote
operator|=
literal|"\""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|value
index|[
name|i
index|]
operator|==
literal|';'
operator|||
name|value
index|[
name|i
index|]
operator|==
literal|'#'
condition|)
name|quote
operator|=
literal|"\""
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|value
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|quote
operator|=
literal|"\""
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\t%.*s = %s"
argument_list|,
name|length
argument_list|,
name|key
operator|+
name|store
operator|.
name|baselen
operator|+
literal|1
argument_list|,
name|quote
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|value
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\n'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
default|default:
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s\n"
argument_list|,
name|quote
argument_list|)
expr_stmt|;
name|success
operator|=
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|==
name|sb
operator|.
name|len
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_function
DECL|function|find_beginning_of_line
specifier|static
name|ssize_t
name|find_beginning_of_line
parameter_list|(
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|offset_
parameter_list|,
name|int
modifier|*
name|found_bracket
parameter_list|)
block|{
name|size_t
name|equal_offset
init|=
name|size
decl_stmt|,
name|bracket_offset
init|=
name|size
decl_stmt|;
name|ssize_t
name|offset
decl_stmt|;
name|contline
label|:
for|for
control|(
name|offset
operator|=
name|offset_
operator|-
literal|2
init|;
name|offset
operator|>
literal|0
operator|&&
name|contents
index|[
name|offset
index|]
operator|!=
literal|'\n'
condition|;
name|offset
operator|--
control|)
switch|switch
condition|(
name|contents
index|[
name|offset
index|]
condition|)
block|{
case|case
literal|'='
case|:
name|equal_offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|bracket_offset
operator|=
name|offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|contents
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|offset_
operator|=
name|offset
expr_stmt|;
goto|goto
name|contline
goto|;
block|}
if|if
condition|(
name|bracket_offset
operator|<
name|equal_offset
condition|)
block|{
operator|*
name|found_bracket
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|bracket_offset
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|offset
operator|++
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_function
DECL|function|git_config_set_in_file
name|int
name|git_config_set_in_file
parameter_list|(
specifier|const
name|char
modifier|*
name|config_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
name|git_config_set_multivar_in_file
argument_list|(
name|config_filename
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_config_set
name|int
name|git_config_set
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
name|git_config_set_multivar
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Auxiliary function to sanity-check and split the key into the section  * identifier and variable name.  *  * Returns 0 on success, -1 when there is an invalid character in the key and  * -2 if there is no section name in the key.  *  * store_key - pointer to char* which will hold a copy of the key with  *             lowercase section and variable name  * baselen - pointer to int which will hold the length of the  *           section + subsection part, can be NULL  */
end_comment
begin_function
DECL|function|git_config_parse_key
name|int
name|git_config_parse_key
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|char
modifier|*
modifier|*
name|store_key
parameter_list|,
name|int
modifier|*
name|baselen_
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|dot
decl_stmt|,
name|baselen
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_dot
init|=
name|strrchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
comment|/* 	 * Since "key" actually contains the section name and the real 	 * key name separated by a dot, we have to know where the dot is. 	 */
if|if
condition|(
name|last_dot
operator|==
name|NULL
operator|||
name|last_dot
operator|==
name|key
condition|)
block|{
name|error
argument_list|(
literal|"key does not contain a section: %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|-
name|CONFIG_NO_SECTION_OR_NAME
return|;
block|}
if|if
condition|(
operator|!
name|last_dot
index|[
literal|1
index|]
condition|)
block|{
name|error
argument_list|(
literal|"key does not contain variable name: %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|-
name|CONFIG_NO_SECTION_OR_NAME
return|;
block|}
name|baselen
operator|=
name|last_dot
operator|-
name|key
expr_stmt|;
if|if
condition|(
name|baselen_
condition|)
operator|*
name|baselen_
operator|=
name|baselen
expr_stmt|;
comment|/* 	 * Validate the key and while at it, lower case it for matching. 	 */
operator|*
name|store_key
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|key
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
name|key
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|dot
operator|=
literal|1
expr_stmt|;
comment|/* Leave the extended basename untouched.. */
if|if
condition|(
operator|!
name|dot
operator|||
name|i
operator|>
name|baselen
condition|)
block|{
if|if
condition|(
operator|!
name|iskeychar
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|i
operator|==
name|baselen
operator|+
literal|1
operator|&&
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid key: %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|out_free_ret_1
goto|;
block|}
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|error
argument_list|(
literal|"invalid key (newline): %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|out_free_ret_1
goto|;
block|}
operator|(
operator|*
name|store_key
operator|)
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
operator|(
operator|*
name|store_key
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
name|out_free_ret_1
label|:
name|free
argument_list|(
operator|*
name|store_key
argument_list|)
expr_stmt|;
operator|*
name|store_key
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
name|CONFIG_INVALID_KEY
return|;
block|}
end_function
begin_comment
comment|/*  * If value==NULL, unset in (remove from) config,  * if value_regex!=NULL, disregard key/value pairs where value does not match.  * if multi_replace==0, nothing, or only one matching key/value is replaced,  *     else all matching key/values (regardless how many) are removed,  *     before the new pair is written.  *  * Returns 0 on success.  *  * This function does this:  *  * - it locks the config file by creating ".git/config.lock"  *  * - it then parses the config using store_aux() as validator to find  *   the position on the key/value pair to replace. If it is to be unset,  *   it must be found exactly once.  *  * - the config file is mmap()ed and the part before the match (if any) is  *   written to the lock file, then the changed part and the rest.  *  * - the config file is removed and the lock file rename()d to it.  *  */
end_comment
begin_function
DECL|function|git_config_set_multivar_in_file
name|int
name|git_config_set_multivar_in_file
parameter_list|(
specifier|const
name|char
modifier|*
name|config_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|value_regex
parameter_list|,
name|int
name|multi_replace
parameter_list|)
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|,
name|in_fd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename_buf
init|=
name|NULL
decl_stmt|;
comment|/* parse-key returns negative; flip the sign to feed exit(3) */
name|ret
operator|=
literal|0
operator|-
name|git_config_parse_key
argument_list|(
name|key
argument_list|,
operator|&
name|store
operator|.
name|key
argument_list|,
operator|&
name|store
operator|.
name|baselen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_free
goto|;
name|store
operator|.
name|multi_replace
operator|=
name|multi_replace
expr_stmt|;
if|if
condition|(
operator|!
name|config_filename
condition|)
name|config_filename
operator|=
name|filename_buf
operator|=
name|git_pathdup
argument_list|(
literal|"config"
argument_list|)
expr_stmt|;
comment|/* 	 * The lock serves a purpose in addition to locking: the new 	 * contents of .git/config will be written into it. 	 */
name|lock
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
name|lock
argument_list|,
name|config_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"could not lock config file %s: %s"
argument_list|,
name|config_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CONFIG_NO_LOCK
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
comment|/* 	 * If .git/config does not exist yet, write a minimal version. 	 */
name|in_fd
operator|=
name|open
argument_list|(
name|config_filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_fd
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENOENT
operator|!=
name|errno
condition|)
block|{
name|error
argument_list|(
literal|"opening %s: %s"
argument_list|,
name|config_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CONFIG_INVALID_FILE
expr_stmt|;
comment|/* same as "invalid config file" */
goto|goto
name|out_free
goto|;
block|}
comment|/* if nothing to unset, error out */
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|CONFIG_NOTHING_SET
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|store
operator|.
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|key
expr_stmt|;
if|if
condition|(
operator|!
name|store_write_section
argument_list|(
name|fd
argument_list|,
name|key
argument_list|)
operator|||
operator|!
name|store_write_pair
argument_list|(
name|fd
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|write_err_out
goto|;
block|}
else|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|size_t
name|contents_sz
decl_stmt|,
name|copy_begin
decl_stmt|,
name|copy_end
decl_stmt|;
name|int
name|i
decl_stmt|,
name|new_line
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value_regex
operator|==
name|NULL
condition|)
name|store
operator|.
name|value_regex
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|value_regex
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
name|store
operator|.
name|do_not_match
operator|=
literal|1
expr_stmt|;
name|value_regex
operator|++
expr_stmt|;
block|}
else|else
name|store
operator|.
name|do_not_match
operator|=
literal|0
expr_stmt|;
name|store
operator|.
name|value_regex
operator|=
operator|(
name|regex_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|regex_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
name|store
operator|.
name|value_regex
argument_list|,
name|value_regex
argument_list|,
name|REG_EXTENDED
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid pattern: %s"
argument_list|,
name|value_regex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CONFIG_INVALID_PATTERN
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
block|}
name|store
operator|.
name|offset
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|store
operator|.
name|state
operator|=
name|START
expr_stmt|;
name|store
operator|.
name|seen
operator|=
literal|0
expr_stmt|;
comment|/* 		 * After this, store.offset will contain the *end* offset 		 * of the last match, or remain at 0 if no match was found. 		 * As a side effect, we make sure to transform only a valid 		 * existing config file. 		 */
if|if
condition|(
name|git_config_from_file
argument_list|(
name|store_aux
argument_list|,
name|config_filename
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid config file %s"
argument_list|,
name|config_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|value_regex
operator|!=
name|NULL
condition|)
block|{
name|regfree
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|CONFIG_INVALID_FILE
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|value_regex
operator|!=
name|NULL
condition|)
block|{
name|regfree
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
block|}
comment|/* if nothing to unset, or too many matches, error out */
if|if
condition|(
operator|(
name|store
operator|.
name|seen
operator|==
literal|0
operator|&&
name|value
operator|==
name|NULL
operator|)
operator|||
operator|(
name|store
operator|.
name|seen
operator|>
literal|1
operator|&&
name|multi_replace
operator|==
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
name|CONFIG_NOTHING_SET
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|fstat
argument_list|(
name|in_fd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|contents_sz
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|contents
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|contents_sz
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|in_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|seen
operator|==
literal|0
condition|)
name|store
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|copy_begin
operator|=
literal|0
init|;
name|i
operator|<
name|store
operator|.
name|seen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|store
operator|.
name|offset
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|store
operator|.
name|offset
index|[
name|i
index|]
operator|=
name|copy_end
operator|=
name|contents_sz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|store
operator|.
name|state
operator|!=
name|KEY_SEEN
condition|)
block|{
name|copy_end
operator|=
name|store
operator|.
name|offset
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|copy_end
operator|=
name|find_beginning_of_line
argument_list|(
name|contents
argument_list|,
name|contents_sz
argument_list|,
name|store
operator|.
name|offset
index|[
name|i
index|]
operator|-
literal|2
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_end
operator|>
literal|0
operator|&&
name|contents
index|[
name|copy_end
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|new_line
operator|=
literal|1
expr_stmt|;
comment|/* write the first part of the config */
if|if
condition|(
name|copy_end
operator|>
name|copy_begin
condition|)
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|contents
operator|+
name|copy_begin
argument_list|,
name|copy_end
operator|-
name|copy_begin
argument_list|)
operator|<
name|copy_end
operator|-
name|copy_begin
condition|)
goto|goto
name|write_err_out
goto|;
if|if
condition|(
name|new_line
operator|&&
name|write_str_in_full
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|write_err_out
goto|;
block|}
name|copy_begin
operator|=
name|store
operator|.
name|offset
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* write the pair (value == NULL means unset) */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|store
operator|.
name|state
operator|==
name|START
condition|)
block|{
if|if
condition|(
operator|!
name|store_write_section
argument_list|(
name|fd
argument_list|,
name|key
argument_list|)
condition|)
goto|goto
name|write_err_out
goto|;
block|}
if|if
condition|(
operator|!
name|store_write_pair
argument_list|(
name|fd
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|write_err_out
goto|;
block|}
comment|/* write the rest of the config */
if|if
condition|(
name|copy_begin
operator|<
name|contents_sz
condition|)
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|contents
operator|+
name|copy_begin
argument_list|,
name|contents_sz
operator|-
name|copy_begin
argument_list|)
operator|<
name|contents_sz
operator|-
name|copy_begin
condition|)
goto|goto
name|write_err_out
goto|;
name|munmap
argument_list|(
name|contents
argument_list|,
name|contents_sz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit_lock_file
argument_list|(
name|lock
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"could not commit config file %s"
argument_list|,
name|config_filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|CONFIG_NO_WRITE
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
comment|/* 	 * lock is committed, so don't try to roll it back below. 	 * NOTE: Since lockfile.c keeps a linked list of all created 	 * lock_file structures, it isn't safe to free(lock).  It's 	 * better to just leave it hanging around. 	 */
name|lock
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out_free
label|:
if|if
condition|(
name|lock
condition|)
name|rollback_lock_file
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename_buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
name|write_err_out
label|:
name|ret
operator|=
name|write_error
argument_list|(
name|lock
operator|->
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
end_function
begin_function
DECL|function|git_config_set_multivar
name|int
name|git_config_set_multivar
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|value_regex
parameter_list|,
name|int
name|multi_replace
parameter_list|)
block|{
return|return
name|git_config_set_multivar_in_file
argument_list|(
name|NULL
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|value_regex
argument_list|,
name|multi_replace
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|section_name_match
specifier|static
name|int
name|section_name_match
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|dot
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|'['
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|buf
index|[
name|i
index|]
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
literal|']'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dot
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|dot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|name
index|[
name|j
operator|++
index|]
operator|!=
literal|'.'
condition|)
break|break;
for|for
control|(
name|i
operator|++
init|;
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|'"'
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|dot
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'"'
operator|&&
name|dot
condition|)
block|{
for|for
control|(
name|i
operator|++
init|;
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* do_nothing */
break|break;
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
name|name
index|[
name|j
operator|++
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|']'
operator|&&
name|name
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We match, now just find the right length offset by 		 * gobbling up any whitespace after it, as well 		 */
name|i
operator|++
expr_stmt|;
for|for
control|(
init|;
name|buf
index|[
name|i
index|]
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
return|return
name|i
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|section_name_is_ok
specifier|static
name|int
name|section_name_is_ok
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Empty section names are bogus. */
if|if
condition|(
operator|!
operator|*
name|name
condition|)
return|return
literal|0
return|;
comment|/* 	 * Before a dot, we must be alphanumeric or dash. After the first dot, 	 * anything goes, so we can stop checking. 	 */
for|for
control|(
init|;
operator|*
name|name
operator|&&
operator|*
name|name
operator|!=
literal|'.'
condition|;
name|name
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|!=
literal|'-'
operator|&&
operator|!
name|isalnum
argument_list|(
operator|*
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* if new_name == NULL, the section is removed instead */
end_comment
begin_function
DECL|function|git_config_rename_section_in_file
name|int
name|git_config_rename_section_in_file
parameter_list|(
specifier|const
name|char
modifier|*
name|config_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|old_name
parameter_list|,
specifier|const
name|char
modifier|*
name|new_name
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|remove
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|filename_buf
init|=
name|NULL
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
decl_stmt|;
name|int
name|out_fd
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|config_file
decl_stmt|;
if|if
condition|(
name|new_name
operator|&&
operator|!
name|section_name_is_ok
argument_list|(
name|new_name
argument_list|)
condition|)
block|{
name|ret
operator|=
name|error
argument_list|(
literal|"invalid section name: %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|config_filename
condition|)
name|config_filename
operator|=
name|filename_buf
operator|=
name|git_pathdup
argument_list|(
literal|"config"
argument_list|)
expr_stmt|;
name|lock
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out_fd
operator|=
name|hold_lock_file_for_update
argument_list|(
name|lock
argument_list|,
name|config_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_fd
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|error
argument_list|(
literal|"could not lock config file %s"
argument_list|,
name|config_filename
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|config_file
operator|=
name|fopen
argument_list|(
name|config_filename
argument_list|,
literal|"rb"
argument_list|)
operator|)
condition|)
block|{
comment|/* no config file means nothing to rename, no error */
goto|goto
name|unlock_and_out
goto|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|config_file
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|buf
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'['
condition|)
block|{
comment|/* it's a section */
name|int
name|offset
init|=
name|section_name_match
argument_list|(
operator|&
name|buf
index|[
name|i
index|]
argument_list|,
name|old_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
name|NULL
condition|)
block|{
name|remove
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|store
operator|.
name|baselen
operator|=
name|strlen
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store_write_section
argument_list|(
name|out_fd
argument_list|,
name|new_name
argument_list|)
condition|)
block|{
name|ret
operator|=
name|write_error
argument_list|(
name|lock
operator|->
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 				 * We wrote out the new section, with 				 * a newline, now skip the old 				 * section's length 				 */
name|output
operator|+=
name|offset
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|output
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 					 * More content means there's 					 * a declaration to put on the 					 * next line; indent with a 					 * tab 					 */
name|output
operator|-=
literal|1
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
literal|'\t'
expr_stmt|;
block|}
block|}
name|remove
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
continue|continue;
name|length
operator|=
name|strlen
argument_list|(
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|out_fd
argument_list|,
name|output
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
block|{
name|ret
operator|=
name|write_error
argument_list|(
name|lock
operator|->
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|fclose
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
name|unlock_and_out
label|:
if|if
condition|(
name|commit_lock_file
argument_list|(
name|lock
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
name|error
argument_list|(
literal|"could not commit config file %s"
argument_list|,
name|config_filename
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|filename_buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config_rename_section
name|int
name|git_config_rename_section
parameter_list|(
specifier|const
name|char
modifier|*
name|old_name
parameter_list|,
specifier|const
name|char
modifier|*
name|new_name
parameter_list|)
block|{
return|return
name|git_config_rename_section_in_file
argument_list|(
name|NULL
argument_list|,
name|old_name
argument_list|,
name|new_name
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Call this to report error for your variable that should not  * get a boolean value (i.e. "[my] var" means "true").  */
end_comment
begin_function
DECL|function|config_error_nonbool
name|int
name|config_error_nonbool
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|)
block|{
return|return
name|error
argument_list|(
literal|"Missing value for '%s'"
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function
end_unit
