begin_unit
begin_comment
comment|/*  * GIT - The information manager from hell  *  * Copyright (C) Linus Torvalds, 2005  * Copyright (C) Johannes Schindelin, 2005  *  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_define
DECL|macro|MAXNAME
define|#
directive|define
name|MAXNAME
value|(256)
end_define
begin_decl_stmt
DECL|variable|config_file
specifier|static
name|FILE
modifier|*
name|config_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|config_file_name
specifier|static
specifier|const
name|char
modifier|*
name|config_file_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|config_linenr
specifier|static
name|int
name|config_linenr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|config_file_eof
specifier|static
name|int
name|config_file_eof
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|zlib_compression_seen
specifier|static
name|int
name|zlib_compression_seen
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_next_char
specifier|static
name|int
name|get_next_char
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|config_file
operator|)
operator|!=
name|NULL
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* DOS like systems */
name|c
operator|=
name|fgetc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|config_linenr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|config_file_eof
operator|=
literal|1
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|parse_value
specifier|static
name|char
modifier|*
name|parse_value
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|value
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|quote
init|=
literal|0
decl_stmt|,
name|comment
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|space
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|quote
condition|)
return|return
name|NULL
return|;
name|value
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|comment
condition|)
continue|continue;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|quote
condition|)
block|{
name|space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|quote
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'#'
condition|)
block|{
name|comment
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|space
condition|)
block|{
if|if
condition|(
name|len
condition|)
name|value
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
continue|continue;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
comment|/* Some characters escape as themselves */
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
comment|/* Reject unknown escape sequences */
default|default:
return|return
name|NULL
return|;
block|}
name|value
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|quote
operator|=
literal|1
operator|-
name|quote
expr_stmt|;
continue|continue;
block|}
name|value
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|iskeychar
specifier|static
specifier|inline
name|int
name|iskeychar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
return|;
block|}
end_function
begin_function
DECL|function|get_value
specifier|static
name|int
name|get_value
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Get the full name */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_file_eof
condition|)
break|break;
if|if
condition|(
operator|!
name|iskeychar
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|name
index|[
name|len
operator|++
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MAXNAME
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'='
condition|)
return|return
operator|-
literal|1
return|;
name|value
operator|=
name|parse_value
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|fn
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_extended_base_var
specifier|static
name|int
name|get_extended_base_var
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|baselen
parameter_list|,
name|int
name|c
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|-
literal|1
return|;
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* We require the format to be '[base "extension"]' */
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
return|return
operator|-
literal|1
return|;
name|name
index|[
name|baselen
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|get_next_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|name
index|[
name|baselen
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|baselen
operator|>
name|MAXNAME
operator|/
literal|2
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Final ']' */
if|if
condition|(
name|get_next_char
argument_list|()
operator|!=
literal|']'
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|baselen
return|;
block|}
end_function
begin_function
DECL|function|get_base_var
specifier|static
name|int
name|get_base_var
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|baselen
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|config_file_eof
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
return|return
name|baselen
return|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|get_extended_base_var
argument_list|(
name|name
argument_list|,
name|baselen
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
operator|!
name|iskeychar
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|baselen
operator|>
name|MAXNAME
operator|/
literal|2
condition|)
return|return
operator|-
literal|1
return|;
name|name
index|[
name|baselen
operator|++
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|git_parse_file
specifier|static
name|int
name|git_parse_file
parameter_list|(
name|config_fn_t
name|fn
parameter_list|)
block|{
name|int
name|comment
init|=
literal|0
decl_stmt|;
name|int
name|baselen
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|var
index|[
name|MAXNAME
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|get_next_char
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|config_file_eof
condition|)
return|return
literal|0
return|;
name|comment
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|comment
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|';'
condition|)
block|{
name|comment
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|baselen
operator|=
name|get_base_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|baselen
operator|<=
literal|0
condition|)
break|break;
name|var
index|[
name|baselen
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|var
index|[
name|baselen
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|var
index|[
name|baselen
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_value
argument_list|(
name|fn
argument_list|,
name|var
argument_list|,
name|baselen
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
name|die
argument_list|(
literal|"bad config file line %d in %s"
argument_list|,
name|config_linenr
argument_list|,
name|config_file_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_unit_factor
specifier|static
name|int
name|parse_unit_factor
parameter_list|(
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|unsigned
name|long
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|end
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|end
argument_list|,
literal|"k"
argument_list|)
condition|)
block|{
operator|*
name|val
operator|*=
literal|1024
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|end
argument_list|,
literal|"m"
argument_list|)
condition|)
block|{
operator|*
name|val
operator|*=
literal|1024
operator|*
literal|1024
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|end
argument_list|,
literal|"g"
argument_list|)
condition|)
block|{
operator|*
name|val
operator|*=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_parse_long
name|int
name|git_parse_long
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|long
modifier|*
name|ret
parameter_list|)
block|{
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|long
name|val
init|=
name|strtol
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|factor
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|parse_unit_factor
argument_list|(
name|end
argument_list|,
operator|&
name|factor
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|ret
operator|=
name|val
operator|*
name|factor
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_parse_ulong
name|int
name|git_parse_ulong
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|unsigned
name|long
modifier|*
name|ret
parameter_list|)
block|{
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parse_unit_factor
argument_list|(
name|end
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|ret
operator|=
name|val
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_config_int
name|int
name|git_config_int
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|git_parse_long
argument_list|(
name|value
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
name|die
argument_list|(
literal|"bad config value for '%s' in %s"
argument_list|,
name|name
argument_list|,
name|config_file_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config_ulong
name|unsigned
name|long
name|git_config_ulong
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|git_parse_ulong
argument_list|(
name|value
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
name|die
argument_list|(
literal|"bad config value for '%s' in %s"
argument_list|,
name|name
argument_list|,
name|config_file_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_config_bool
name|int
name|git_config_bool
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|value
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"yes"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"no"
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|git_config_int
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_default_config
name|int
name|git_default_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
comment|/* This needs a better name */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.filemode"
argument_list|)
condition|)
block|{
name|trust_executable_bit
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.quotepath"
argument_list|)
condition|)
block|{
name|quote_path_fully
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.symlinks"
argument_list|)
condition|)
block|{
name|has_symlinks
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.bare"
argument_list|)
condition|)
block|{
name|is_bare_repository_cfg
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.ignorestat"
argument_list|)
condition|)
block|{
name|assume_unchanged
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.prefersymlinkrefs"
argument_list|)
condition|)
block|{
name|prefer_symlink_refs
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.logallrefupdates"
argument_list|)
condition|)
block|{
name|log_all_ref_updates
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.warnambiguousrefs"
argument_list|)
condition|)
block|{
name|warn_ambiguous_refs
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.loosecompression"
argument_list|)
condition|)
block|{
name|int
name|level
init|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|Z_BEST_COMPRESSION
condition|)
name|die
argument_list|(
literal|"bad zlib compression level %d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|zlib_compression_level
operator|=
name|level
expr_stmt|;
name|zlib_compression_seen
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.compression"
argument_list|)
condition|)
block|{
name|int
name|level
init|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|level
operator|=
name|Z_DEFAULT_COMPRESSION
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|Z_BEST_COMPRESSION
condition|)
name|die
argument_list|(
literal|"bad zlib compression level %d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|core_compression_level
operator|=
name|level
expr_stmt|;
name|core_compression_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|zlib_compression_seen
condition|)
name|zlib_compression_level
operator|=
name|level
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.packedgitwindowsize"
argument_list|)
condition|)
block|{
name|int
name|pgsz_x2
init|=
name|getpagesize
argument_list|()
operator|*
literal|2
decl_stmt|;
name|packed_git_window_size
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* This value must be multiple of (pagesize * 2) */
name|packed_git_window_size
operator|/=
name|pgsz_x2
expr_stmt|;
if|if
condition|(
name|packed_git_window_size
operator|<
literal|1
condition|)
name|packed_git_window_size
operator|=
literal|1
expr_stmt|;
name|packed_git_window_size
operator|*=
name|pgsz_x2
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.packedgitlimit"
argument_list|)
condition|)
block|{
name|packed_git_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.deltabasecachelimit"
argument_list|)
condition|)
block|{
name|delta_base_cache_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.autocrlf"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"input"
argument_list|)
condition|)
block|{
name|auto_crlf
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|auto_crlf
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"user.name"
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|git_default_name
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|git_default_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"user.email"
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|git_default_email
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|git_default_email
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"i18n.commitencoding"
argument_list|)
condition|)
block|{
name|git_commit_encoding
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"i18n.logoutputencoding"
argument_list|)
condition|)
block|{
name|git_log_output_encoding
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"pager.color"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"color.pager"
argument_list|)
condition|)
block|{
name|pager_use_color
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.pager"
argument_list|)
condition|)
block|{
name|pager_program
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.editor"
argument_list|)
condition|)
block|{
name|editor_program
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.excludesfile"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
name|die
argument_list|(
literal|"core.excludesfile without value"
argument_list|)
expr_stmt|;
name|excludes_file
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"core.whitespace"
argument_list|)
condition|)
block|{
name|whitespace_rule_cfg
operator|=
name|parse_whitespace_rule
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Add other config variables here and to Documentation/config.txt. */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_config_from_file
name|int
name|git_config_from_file
parameter_list|(
name|config_fn_t
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|config_file
operator|=
name|f
expr_stmt|;
name|config_file_name
operator|=
name|filename
expr_stmt|;
name|config_linenr
operator|=
literal|1
expr_stmt|;
name|config_file_eof
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|git_parse_file
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|config_file_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|git_etc_gitconfig
specifier|const
name|char
modifier|*
name|git_etc_gitconfig
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|system_wide
decl_stmt|;
if|if
condition|(
operator|!
name|system_wide
condition|)
block|{
name|system_wide
operator|=
name|ETC_GITCONFIG
expr_stmt|;
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|system_wide
argument_list|)
condition|)
block|{
comment|/* interpret path relative to exec-dir */
specifier|const
name|char
modifier|*
name|exec_path
init|=
name|git_exec_path
argument_list|()
decl_stmt|;
name|system_wide
operator|=
name|prefix_path
argument_list|(
name|exec_path
argument_list|,
name|strlen
argument_list|(
name|exec_path
argument_list|)
argument_list|,
name|system_wide
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|system_wide
return|;
block|}
end_function
begin_function
DECL|function|git_config
name|int
name|git_config
parameter_list|(
name|config_fn_t
name|fn
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|repo_config
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|home
init|=
name|NULL
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
comment|/* $GIT_CONFIG makes git read _only_ the given config file, 	 * $GIT_CONFIG_LOCAL will make it process it in addition to the 	 * global config file, the same way it would the per-repository 	 * config file otherwise. */
name|filename
operator|=
name|getenv
argument_list|(
name|CONFIG_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
if|if
condition|(
operator|!
name|access
argument_list|(
name|git_etc_gitconfig
argument_list|()
argument_list|,
name|R_OK
argument_list|)
condition|)
name|ret
operator|+=
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|git_etc_gitconfig
argument_list|()
argument_list|)
expr_stmt|;
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
name|filename
operator|=
name|getenv
argument_list|(
name|CONFIG_LOCAL_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|repo_config
operator|=
name|xstrdup
argument_list|(
name|git_path
argument_list|(
literal|"config"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|home
condition|)
block|{
name|char
modifier|*
name|user_config
init|=
name|xstrdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s/.gitconfig"
argument_list|,
name|home
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|user_config
argument_list|,
name|R_OK
argument_list|)
condition|)
name|ret
operator|=
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|user_config
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|user_config
argument_list|)
expr_stmt|;
block|}
name|ret
operator|+=
name|git_config_from_file
argument_list|(
name|fn
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repo_config
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Find all the stuff for git_config_set() below.  */
end_comment
begin_define
DECL|macro|MAX_MATCHES
define|#
directive|define
name|MAX_MATCHES
value|512
end_define
begin_struct
specifier|static
struct|struct
block|{
DECL|member|baselen
name|int
name|baselen
decl_stmt|;
DECL|member|key
name|char
modifier|*
name|key
decl_stmt|;
DECL|member|do_not_match
name|int
name|do_not_match
decl_stmt|;
DECL|member|value_regex
name|regex_t
modifier|*
name|value_regex
decl_stmt|;
DECL|member|multi_replace
name|int
name|multi_replace
decl_stmt|;
DECL|member|offset
name|size_t
name|offset
index|[
name|MAX_MATCHES
index|]
decl_stmt|;
DECL|enumerator|START
DECL|enumerator|SECTION_SEEN
DECL|enumerator|SECTION_END_SEEN
DECL|enumerator|KEY_SEEN
DECL|member|state
enum|enum
block|{
name|START
block|,
name|SECTION_SEEN
block|,
name|SECTION_END_SEEN
block|,
name|KEY_SEEN
block|}
name|state
enum|;
DECL|member|seen
name|int
name|seen
decl_stmt|;
block|}
DECL|variable|store
name|store
struct|;
end_struct
begin_function
DECL|function|matches
specifier|static
name|int
name|matches
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|store
operator|.
name|key
argument_list|)
operator|&&
operator|(
name|store
operator|.
name|value_regex
operator|==
name|NULL
operator|||
operator|(
name|store
operator|.
name|do_not_match
operator|^
operator|!
name|regexec
argument_list|(
name|store
operator|.
name|value_regex
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|store_aux
specifier|static
name|int
name|store_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ep
decl_stmt|;
name|size_t
name|section_len
decl_stmt|;
switch|switch
condition|(
name|store
operator|.
name|state
condition|)
block|{
case|case
name|KEY_SEEN
case|:
if|if
condition|(
name|matches
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|store
operator|.
name|seen
operator|==
literal|1
operator|&&
name|store
operator|.
name|multi_replace
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: %s has multiple values\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|store
operator|.
name|seen
operator|>=
name|MAX_MATCHES
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many matches\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
name|store
operator|.
name|seen
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SECTION_SEEN
case|:
comment|/* 		 * What we are looking for is in store.key (both 		 * section and var), and its section part is baselen 		 * long.  We found key (again, both section and var). 		 * We would want to know if this key is in the same 		 * section as what we are looking for.  We already 		 * know we are in the same section as what should 		 * hold store.key. 		 */
name|ep
operator|=
name|strrchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|section_len
operator|=
name|ep
operator|-
name|key
expr_stmt|;
if|if
condition|(
operator|(
name|section_len
operator|!=
name|store
operator|.
name|baselen
operator|)
operator|||
name|memcmp
argument_list|(
name|key
argument_list|,
name|store
operator|.
name|key
argument_list|,
name|section_len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|store
operator|.
name|state
operator|=
name|SECTION_END_SEEN
expr_stmt|;
break|break;
block|}
comment|/* 		 * Do not increment matches: this is no match, but we 		 * just made sure we are in the desired section. 		 */
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
comment|/* fallthru */
case|case
name|SECTION_END_SEEN
case|:
case|case
name|START
case|:
if|if
condition|(
name|matches
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
name|store
operator|.
name|state
operator|=
name|KEY_SEEN
expr_stmt|;
name|store
operator|.
name|seen
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strrchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|)
operator|-
name|key
operator|==
name|store
operator|.
name|baselen
operator|&&
operator|!
name|strncmp
argument_list|(
name|key
argument_list|,
name|store
operator|.
name|key
argument_list|,
name|store
operator|.
name|baselen
argument_list|)
condition|)
block|{
name|store
operator|.
name|state
operator|=
name|SECTION_SEEN
expr_stmt|;
name|store
operator|.
name|offset
index|[
name|store
operator|.
name|seen
index|]
operator|=
name|ftell
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_error
specifier|static
name|int
name|write_error
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to write new configuration file\n"
argument_list|)
expr_stmt|;
comment|/* Same error code as "failed to rename". */
return|return
literal|4
return|;
block|}
end_function
begin_function
DECL|function|store_write_section
specifier|static
name|int
name|store_write_section
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dot
decl_stmt|;
name|int
name|i
decl_stmt|,
name|success
decl_stmt|;
name|struct
name|strbuf
name|sb
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dot
operator|=
name|memchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|,
name|store
operator|.
name|baselen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"[%.*s \""
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dot
operator|-
name|key
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dot
operator|-
name|key
operator|+
literal|1
init|;
name|i
operator|<
name|store
operator|.
name|baselen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|key
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\"]\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"[%.*s]\n"
argument_list|,
name|store
operator|.
name|baselen
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|==
name|sb
operator|.
name|len
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_function
DECL|function|store_write_pair
specifier|static
name|int
name|store_write_pair
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|success
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|key
operator|+
name|store
operator|.
name|baselen
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|quote
init|=
literal|""
decl_stmt|;
name|struct
name|strbuf
name|sb
decl_stmt|;
comment|/* 	 * Check to see if the value needs to be surrounded with a dq pair. 	 * Note that problematic characters are always backslash-quoted; this 	 * check is about not losing leading or trailing SP and strings that 	 * follow beginning-of-comment characters (i.e. ';' and '#') by the 	 * configuration parser. 	 */
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|quote
operator|=
literal|"\""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|value
index|[
name|i
index|]
operator|==
literal|';'
operator|||
name|value
index|[
name|i
index|]
operator|==
literal|'#'
condition|)
name|quote
operator|=
literal|"\""
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|value
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|quote
operator|=
literal|"\""
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\t%.*s = %s"
argument_list|,
name|length
argument_list|,
name|key
operator|+
name|store
operator|.
name|baselen
operator|+
literal|1
argument_list|,
name|quote
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|value
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\n'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
default|default:
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s\n"
argument_list|,
name|quote
argument_list|)
expr_stmt|;
name|success
operator|=
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|==
name|sb
operator|.
name|len
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function
begin_function
DECL|function|find_beginning_of_line
specifier|static
name|ssize_t
name|find_beginning_of_line
parameter_list|(
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|offset_
parameter_list|,
name|int
modifier|*
name|found_bracket
parameter_list|)
block|{
name|size_t
name|equal_offset
init|=
name|size
decl_stmt|,
name|bracket_offset
init|=
name|size
decl_stmt|;
name|ssize_t
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
name|offset_
operator|-
literal|2
init|;
name|offset
operator|>
literal|0
operator|&&
name|contents
index|[
name|offset
index|]
operator|!=
literal|'\n'
condition|;
name|offset
operator|--
control|)
switch|switch
condition|(
name|contents
index|[
name|offset
index|]
condition|)
block|{
case|case
literal|'='
case|:
name|equal_offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|bracket_offset
operator|=
name|offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bracket_offset
operator|<
name|equal_offset
condition|)
block|{
operator|*
name|found_bracket
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|bracket_offset
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|offset
operator|++
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_function
DECL|function|git_config_set
name|int
name|git_config_set
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
name|git_config_set_multivar
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * If value==NULL, unset in (remove from) config,  * if value_regex!=NULL, disregard key/value pairs where value does not match.  * if multi_replace==0, nothing, or only one matching key/value is replaced,  *     else all matching key/values (regardless how many) are removed,  *     before the new pair is written.  *  * Returns 0 on success.  *  * This function does this:  *  * - it locks the config file by creating ".git/config.lock"  *  * - it then parses the config using store_aux() as validator to find  *   the position on the key/value pair to replace. If it is to be unset,  *   it must be found exactly once.  *  * - the config file is mmap()ed and the part before the match (if any) is  *   written to the lock file, then the changed part and the rest.  *  * - the config file is removed and the lock file rename()d to it.  *  */
end_comment
begin_function
DECL|function|git_config_set_multivar
name|int
name|git_config_set_multivar
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|value_regex
parameter_list|,
name|int
name|multi_replace
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|dot
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|,
name|in_fd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|config_filename
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_dot
init|=
name|strrchr
argument_list|(
name|key
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|config_filename
operator|=
name|getenv
argument_list|(
name|CONFIG_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config_filename
condition|)
block|{
name|config_filename
operator|=
name|getenv
argument_list|(
name|CONFIG_LOCAL_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config_filename
condition|)
name|config_filename
operator|=
name|git_path
argument_list|(
literal|"config"
argument_list|)
expr_stmt|;
block|}
name|config_filename
operator|=
name|xstrdup
argument_list|(
name|config_filename
argument_list|)
expr_stmt|;
comment|/* 	 * Since "key" actually contains the section name and the real 	 * key name separated by a dot, we have to know where the dot is. 	 */
if|if
condition|(
name|last_dot
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"key does not contain a section: %s\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|2
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|store
operator|.
name|baselen
operator|=
name|last_dot
operator|-
name|key
expr_stmt|;
name|store
operator|.
name|multi_replace
operator|=
name|multi_replace
expr_stmt|;
comment|/* 	 * Validate the key and while at it, lower case it for matching. 	 */
name|store
operator|.
name|key
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|key
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
name|key
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|dot
operator|=
literal|1
expr_stmt|;
comment|/* Leave the extended basename untouched.. */
if|if
condition|(
operator|!
name|dot
operator|||
name|i
operator|>
name|store
operator|.
name|baselen
condition|)
block|{
if|if
condition|(
operator|!
name|iskeychar
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|i
operator|==
name|store
operator|.
name|baselen
operator|+
literal|1
operator|&&
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid key: %s\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid key (newline): %s\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|store
operator|.
name|key
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|store
operator|.
name|key
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The lock serves a purpose in addition to locking: the new 	 * contents of .git/config will be written into it. 	 */
name|lock
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
name|lock
argument_list|,
name|config_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not lock config file\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
comment|/* 	 * If .git/config does not exist yet, write a minimal version. 	 */
name|in_fd
operator|=
name|open
argument_list|(
name|config_filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_fd
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENOENT
operator|!=
name|errno
condition|)
block|{
name|error
argument_list|(
literal|"opening %s: %s"
argument_list|,
name|config_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|3
expr_stmt|;
comment|/* same as "invalid config file" */
goto|goto
name|out_free
goto|;
block|}
comment|/* if nothing to unset, error out */
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|5
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|store
operator|.
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|key
expr_stmt|;
if|if
condition|(
operator|!
name|store_write_section
argument_list|(
name|fd
argument_list|,
name|key
argument_list|)
operator|||
operator|!
name|store_write_pair
argument_list|(
name|fd
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|write_err_out
goto|;
block|}
else|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|size_t
name|contents_sz
decl_stmt|,
name|copy_begin
decl_stmt|,
name|copy_end
decl_stmt|;
name|int
name|i
decl_stmt|,
name|new_line
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value_regex
operator|==
name|NULL
condition|)
name|store
operator|.
name|value_regex
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|value_regex
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
name|store
operator|.
name|do_not_match
operator|=
literal|1
expr_stmt|;
name|value_regex
operator|++
expr_stmt|;
block|}
else|else
name|store
operator|.
name|do_not_match
operator|=
literal|0
expr_stmt|;
name|store
operator|.
name|value_regex
operator|=
operator|(
name|regex_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|regex_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
name|store
operator|.
name|value_regex
argument_list|,
name|value_regex
argument_list|,
name|REG_EXTENDED
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid pattern: %s\n"
argument_list|,
name|value_regex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|6
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
block|}
name|store
operator|.
name|offset
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|store
operator|.
name|state
operator|=
name|START
expr_stmt|;
name|store
operator|.
name|seen
operator|=
literal|0
expr_stmt|;
comment|/* 		 * After this, store.offset will contain the *end* offset 		 * of the last match, or remain at 0 if no match was found. 		 * As a side effect, we make sure to transform only a valid 		 * existing config file. 		 */
if|if
condition|(
name|git_config_from_file
argument_list|(
name|store_aux
argument_list|,
name|config_filename
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid config file\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|value_regex
operator|!=
name|NULL
condition|)
block|{
name|regfree
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|3
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|free
argument_list|(
name|store
operator|.
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|value_regex
operator|!=
name|NULL
condition|)
block|{
name|regfree
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|store
operator|.
name|value_regex
argument_list|)
expr_stmt|;
block|}
comment|/* if nothing to unset, or too many matches, error out */
if|if
condition|(
operator|(
name|store
operator|.
name|seen
operator|==
literal|0
operator|&&
name|value
operator|==
name|NULL
operator|)
operator|||
operator|(
name|store
operator|.
name|seen
operator|>
literal|1
operator|&&
name|multi_replace
operator|==
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
literal|5
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
name|fstat
argument_list|(
name|in_fd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|contents_sz
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|contents
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|contents_sz
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|in_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|seen
operator|==
literal|0
condition|)
name|store
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|copy_begin
operator|=
literal|0
init|;
name|i
operator|<
name|store
operator|.
name|seen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|store
operator|.
name|offset
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|store
operator|.
name|offset
index|[
name|i
index|]
operator|=
name|copy_end
operator|=
name|contents_sz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|store
operator|.
name|state
operator|!=
name|KEY_SEEN
condition|)
block|{
name|copy_end
operator|=
name|store
operator|.
name|offset
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|copy_end
operator|=
name|find_beginning_of_line
argument_list|(
name|contents
argument_list|,
name|contents_sz
argument_list|,
name|store
operator|.
name|offset
index|[
name|i
index|]
operator|-
literal|2
argument_list|,
operator|&
name|new_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_end
operator|>
literal|0
operator|&&
name|contents
index|[
name|copy_end
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|new_line
operator|=
literal|1
expr_stmt|;
comment|/* write the first part of the config */
if|if
condition|(
name|copy_end
operator|>
name|copy_begin
condition|)
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|contents
operator|+
name|copy_begin
argument_list|,
name|copy_end
operator|-
name|copy_begin
argument_list|)
operator|<
name|copy_end
operator|-
name|copy_begin
condition|)
goto|goto
name|write_err_out
goto|;
if|if
condition|(
name|new_line
operator|&&
name|write_in_full
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|write_err_out
goto|;
block|}
name|copy_begin
operator|=
name|store
operator|.
name|offset
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* write the pair (value == NULL means unset) */
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|store
operator|.
name|state
operator|==
name|START
condition|)
block|{
if|if
condition|(
operator|!
name|store_write_section
argument_list|(
name|fd
argument_list|,
name|key
argument_list|)
condition|)
goto|goto
name|write_err_out
goto|;
block|}
if|if
condition|(
operator|!
name|store_write_pair
argument_list|(
name|fd
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|write_err_out
goto|;
block|}
comment|/* write the rest of the config */
if|if
condition|(
name|copy_begin
operator|<
name|contents_sz
condition|)
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|contents
operator|+
name|copy_begin
argument_list|,
name|contents_sz
operator|-
name|copy_begin
argument_list|)
operator|<
name|contents_sz
operator|-
name|copy_begin
condition|)
goto|goto
name|write_err_out
goto|;
name|munmap
argument_list|(
name|contents
argument_list|,
name|contents_sz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit_lock_file
argument_list|(
name|lock
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot commit config file!\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|4
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
comment|/* 	 * lock is committed, so don't try to roll it back below. 	 * NOTE: Since lockfile.c keeps a linked list of all created 	 * lock_file structures, it isn't safe to free(lock).  It's 	 * better to just leave it hanging around. 	 */
name|lock
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out_free
label|:
if|if
condition|(
name|lock
condition|)
name|rollback_lock_file
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config_filename
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
name|write_err_out
label|:
name|ret
operator|=
name|write_error
argument_list|()
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
end_function
begin_function
DECL|function|section_name_match
specifier|static
name|int
name|section_name_match
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|dot
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|buf
index|[
name|i
index|]
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
literal|']'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dot
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|dot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|name
index|[
name|j
operator|++
index|]
operator|!=
literal|'.'
condition|)
break|break;
for|for
control|(
name|i
operator|++
init|;
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|'"'
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|dot
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'"'
operator|&&
name|dot
condition|)
block|{
for|for
control|(
name|i
operator|++
init|;
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* do_nothing */
break|break;
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
name|name
index|[
name|j
operator|++
index|]
condition|)
break|break;
block|}
return|return
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|']'
operator|&&
name|name
index|[
name|j
index|]
operator|==
literal|0
operator|)
return|;
block|}
end_function
begin_comment
comment|/* if new_name == NULL, the section is removed instead */
end_comment
begin_function
DECL|function|git_config_rename_section
name|int
name|git_config_rename_section
parameter_list|(
specifier|const
name|char
modifier|*
name|old_name
parameter_list|,
specifier|const
name|char
modifier|*
name|new_name
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|remove
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|config_filename
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|out_fd
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|config_filename
operator|=
name|getenv
argument_list|(
name|CONFIG_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config_filename
condition|)
block|{
name|config_filename
operator|=
name|getenv
argument_list|(
name|CONFIG_LOCAL_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config_filename
condition|)
name|config_filename
operator|=
name|git_path
argument_list|(
literal|"config"
argument_list|)
expr_stmt|;
block|}
name|config_filename
operator|=
name|xstrdup
argument_list|(
name|config_filename
argument_list|)
expr_stmt|;
name|out_fd
operator|=
name|hold_lock_file_for_update
argument_list|(
name|lock
argument_list|,
name|config_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_fd
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|error
argument_list|(
literal|"Could not lock config file!"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|config_file
operator|=
name|fopen
argument_list|(
name|config_filename
argument_list|,
literal|"rb"
argument_list|)
operator|)
condition|)
block|{
comment|/* no config file means nothing to rename, no error */
goto|goto
name|unlock_and_out
goto|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|config_file
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'['
condition|)
block|{
comment|/* it's a section */
if|if
condition|(
name|section_name_match
argument_list|(
operator|&
name|buf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|old_name
argument_list|)
condition|)
block|{
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
name|NULL
condition|)
block|{
name|remove
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|store
operator|.
name|baselen
operator|=
name|strlen
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store_write_section
argument_list|(
name|out_fd
argument_list|,
name|new_name
argument_list|)
condition|)
block|{
name|ret
operator|=
name|write_error
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
continue|continue;
block|}
name|remove
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
continue|continue;
name|length
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|out_fd
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
block|{
name|ret
operator|=
name|write_error
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|fclose
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
name|unlock_and_out
label|:
if|if
condition|(
name|commit_lock_file
argument_list|(
name|lock
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
name|error
argument_list|(
literal|"Cannot commit config file!"
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|config_filename
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
end_unit
