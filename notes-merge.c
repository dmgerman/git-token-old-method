begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"notes-merge.h"
end_include
begin_function
DECL|function|init_notes_merge_options
name|void
name|init_notes_merge_options
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_options
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|verbosity
operator|=
name|NOTES_MERGE_VERBOSITY_DEFAULT
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|OUTPUT
define|#
directive|define
name|OUTPUT
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do { \ 		if ((o)->verbosity>= (v)) { \ 			printf(__VA_ARGS__); \ 			puts(""); \ 		} \ 	} while (0)
end_define
begin_function
DECL|function|create_notes_commit
name|void
name|create_notes_commit
parameter_list|(
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|,
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
name|unsigned
name|char
name|tree_sha1
index|[
literal|20
index|]
decl_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|initialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_notes_tree
argument_list|(
name|t
argument_list|,
name|tree_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to write notes tree to database"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parents
condition|)
block|{
comment|/* Deduce parent commit from t->ref */
name|unsigned
name|char
name|parent_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|read_ref
argument_list|(
name|t
operator|->
name|ref
argument_list|,
name|parent_sha1
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|lookup_commit
argument_list|(
name|parent_sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|||
name|parse_commit
argument_list|(
name|parent
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to find/parse commit %s"
argument_list|,
name|t
operator|->
name|ref
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
block|}
comment|/* else: t->ref points to nothing, assume root/orphan commit */
block|}
if|if
condition|(
name|commit_tree
argument_list|(
name|msg
argument_list|,
name|tree_sha1
argument_list|,
name|parents
argument_list|,
name|result_sha1
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to commit notes tree to database"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|notes_merge
name|int
name|notes_merge
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
name|unsigned
name|char
name|local_sha1
index|[
literal|20
index|]
decl_stmt|,
name|remote_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|local
decl_stmt|,
modifier|*
name|remote
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|bases
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base_sha1
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|o
operator|->
name|local_ref
operator|&&
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|result_sha1
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"notes_merge(o->local_ref = %s, o->remote_ref = %s)\n"
argument_list|,
name|o
operator|->
name|local_ref
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
comment|/* Dereference o->local_ref into local_sha1 */
if|if
condition|(
operator|!
name|resolve_ref
argument_list|(
name|o
operator|->
name|local_ref
argument_list|,
name|local_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve local notes ref '%s'"
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_ref_format
argument_list|(
name|o
operator|->
name|local_ref
argument_list|)
operator|&&
name|is_null_sha1
argument_list|(
name|local_sha1
argument_list|)
condition|)
name|local
operator|=
name|NULL
expr_stmt|;
comment|/* local_sha1 == null_sha1 indicates unborn ref */
elseif|else
if|if
condition|(
operator|!
operator|(
name|local
operator|=
name|lookup_commit_reference
argument_list|(
name|local_sha1
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"Could not parse local commit %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|local_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"\tlocal commit: %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|local_sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dereference o->remote_ref into remote_sha1 */
if|if
condition|(
name|get_sha1
argument_list|(
name|o
operator|->
name|remote_ref
argument_list|,
name|remote_sha1
argument_list|)
condition|)
block|{
comment|/* 		 * Failed to get remote_sha1. If o->remote_ref looks like an 		 * unborn ref, perform the merge using an empty notes tree. 		 */
if|if
condition|(
operator|!
name|check_ref_format
argument_list|(
name|o
operator|->
name|remote_ref
argument_list|)
condition|)
block|{
name|hashclr
argument_list|(
name|remote_sha1
argument_list|)
expr_stmt|;
name|remote
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|die
argument_list|(
literal|"Failed to resolve remote notes ref '%s'"
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|remote
operator|=
name|lookup_commit_reference
argument_list|(
name|remote_sha1
argument_list|)
operator|)
condition|)
block|{
name|die
argument_list|(
literal|"Could not parse remote commit %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\tremote commit: %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
operator|&&
operator|!
name|remote
condition|)
name|die
argument_list|(
literal|"Cannot merge empty notes ref (%s) into empty notes ref "
literal|"(%s)"
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
comment|/* result == remote commit */
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|remote_sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
if|if
condition|(
operator|!
name|remote
condition|)
block|{
comment|/* result == local commit */
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|local_sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
name|assert
argument_list|(
name|local
operator|&&
name|remote
argument_list|)
expr_stmt|;
comment|/* Find merge bases */
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|local
argument_list|,
name|remote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bases
condition|)
block|{
name|base_sha1
operator|=
name|null_sha1
expr_stmt|;
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"No merge base found; doing history-less merge"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bases
operator|->
name|next
condition|)
block|{
name|base_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"One merge base found (%.7s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: How to handle multiple merge-bases? */
name|base_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|3
argument_list|,
literal|"Multiple merge bases found. Using the first "
literal|"(%.7s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"Merging remote commit %.7s into local commit %.7s with "
literal|"merge-base %.7s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|base_sha1
argument_list|)
condition|)
block|{
comment|/* Already merged; result == local commit */
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Already up-to-date!"
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|base_sha1
argument_list|)
condition|)
block|{
comment|/* Fast-forward; result == remote commit */
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Fast-forward"
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
comment|/* TODO: */
name|result
operator|=
name|error
argument_list|(
literal|"notes_merge() cannot yet handle real merges."
argument_list|)
expr_stmt|;
name|found_result
label|:
name|free_commit_list
argument_list|(
name|bases
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"notes_merge(): result = %i, result_sha1 = %.7s\n"
argument_list|,
name|result
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
end_unit
