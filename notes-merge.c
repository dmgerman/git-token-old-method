begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"ll-merge.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"notes-merge.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_struct
DECL|struct|notes_merge_pair
struct|struct
name|notes_merge_pair
block|{
DECL|member|obj
DECL|member|base
DECL|member|local
DECL|member|remote
name|unsigned
name|char
name|obj
index|[
literal|20
index|]
decl_stmt|,
name|base
index|[
literal|20
index|]
decl_stmt|,
name|local
index|[
literal|20
index|]
decl_stmt|,
name|remote
index|[
literal|20
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|init_notes_merge_options
name|void
name|init_notes_merge_options
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_options
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
operator|(
name|o
operator|->
name|commit_msg
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|o
operator|->
name|verbosity
operator|=
name|NOTES_MERGE_VERBOSITY_DEFAULT
expr_stmt|;
block|}
end_function
begin_function
DECL|function|path_to_sha1
specifier|static
name|int
name|path_to_sha1
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
name|hex_sha1
index|[
literal|40
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|path
operator|&&
name|i
operator|<
literal|40
condition|)
block|{
if|if
condition|(
operator|*
name|path
operator|!=
literal|'/'
condition|)
name|hex_sha1
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|path
expr_stmt|;
name|path
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|path
operator|||
name|i
operator|!=
literal|40
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|get_sha1_hex
argument_list|(
name|hex_sha1
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|verify_notes_filepair
specifier|static
name|int
name|verify_notes_filepair
parameter_list|(
name|struct
name|diff_filepair
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
switch|switch
condition|(
name|p
operator|->
name|status
condition|)
block|{
case|case
name|DIFF_STATUS_MODIFIED
case|:
name|assert
argument_list|(
name|p
operator|->
name|one
operator|->
name|mode
operator|==
name|p
operator|->
name|two
operator|->
name|mode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFF_STATUS_ADDED
case|:
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFF_STATUS_DELETED
case|:
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|p
operator|->
name|two
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|path_to_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|find_notes_merge_pair_pos
specifier|static
name|struct
name|notes_merge_pair
modifier|*
name|find_notes_merge_pair_pos
parameter_list|(
name|struct
name|notes_merge_pair
modifier|*
name|list
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|obj
parameter_list|,
name|int
name|insert_new
parameter_list|,
name|int
modifier|*
name|occupied
parameter_list|)
block|{
comment|/* 	 * Both diff_tree_remote() and diff_tree_local() tend to process 	 * merge_pairs in ascending order. Therefore, cache last returned 	 * index, and search sequentially from there until the appropriate 	 * position is found. 	 * 	 * Since inserts only happen from diff_tree_remote() (which mainly 	 * _appends_), we don't care that inserting into the middle of the 	 * list is expensive (using memmove()). 	 */
specifier|static
name|int
name|last_index
decl_stmt|;
name|int
name|i
init|=
name|last_index
operator|<
name|len
condition|?
name|last_index
else|:
name|len
operator|-
literal|1
decl_stmt|;
name|int
name|prev_cmp
init|=
literal|0
decl_stmt|,
name|cmp
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|len
condition|)
block|{
name|cmp
operator|=
name|hashcmp
argument_list|(
name|obj
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
comment|/* obj belongs @ i */
break|break;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
operator|&&
name|prev_cmp
operator|<=
literal|0
condition|)
comment|/* obj belongs< i */
name|i
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
comment|/* obj belongs between i-1 and i */
break|break;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
operator|&&
name|prev_cmp
operator|>=
literal|0
condition|)
comment|/* obj belongs> i */
name|i
operator|++
expr_stmt|;
else|else
comment|/* if (cmp> 0) */
block|{
comment|/* obj belongs between i and i+1 */
name|i
operator|++
expr_stmt|;
break|break;
block|}
name|prev_cmp
operator|=
name|cmp
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* obj belongs at, or immediately preceding, index i (0<= i<= len) */
if|if
condition|(
operator|!
name|cmp
condition|)
operator|*
name|occupied
operator|=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|occupied
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insert_new
operator|&&
name|i
operator|<
name|len
condition|)
block|{
name|memmove
argument_list|(
name|list
operator|+
name|i
operator|+
literal|1
argument_list|,
name|list
operator|+
name|i
argument_list|,
operator|(
name|len
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_pair
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|list
operator|+
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|last_index
operator|=
name|i
expr_stmt|;
return|return
name|list
operator|+
name|i
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|uninitialized
specifier|static
name|unsigned
name|char
name|uninitialized
index|[
literal|20
index|]
init|=
literal|"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
expr|\
literal|"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|diff_tree_remote
specifier|static
name|struct
name|notes_merge_pair
modifier|*
name|diff_tree_remote
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|remote
parameter_list|,
name|int
modifier|*
name|num_changes
parameter_list|)
block|{
name|struct
name|diff_options
name|opt
decl_stmt|;
name|struct
name|notes_merge_pair
modifier|*
name|changes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tdiff_tree_remote(base = %.7s, remote = %.7s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|opt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|base
argument_list|,
name|remote
argument_list|,
literal|""
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|changes
operator|=
name|xcalloc
argument_list|(
name|diff_queued_diff
operator|.
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_pair
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
name|struct
name|notes_merge_pair
modifier|*
name|mp
decl_stmt|;
name|int
name|occupied
decl_stmt|;
name|unsigned
name|char
name|obj
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|verify_notes_filepair
argument_list|(
name|p
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|trace_printf
argument_list|(
literal|"\t\tCannot merge entry '%s' (%c): "
literal|"%.7s -> %.7s. Skipping!\n"
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|p
operator|->
name|status
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mp
operator|=
name|find_notes_merge_pair_pos
argument_list|(
name|changes
argument_list|,
name|len
argument_list|,
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|occupied
argument_list|)
expr_stmt|;
if|if
condition|(
name|occupied
condition|)
block|{
comment|/* We've found an addition/deletion pair */
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|obj
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* addition */
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|mp
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|remote
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* deletion */
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|mp
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|base
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
name|assert
argument_list|(
operator|!
literal|"Invalid existing change recorded"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hashcpy
argument_list|(
name|mp
operator|->
name|obj
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|base
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|remote
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\t\tStored remote change for %s: %.7s -> %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diff_tree_release_paths
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
operator|*
name|num_changes
operator|=
name|len
expr_stmt|;
return|return
name|changes
return|;
block|}
end_function
begin_function
DECL|function|diff_tree_local
specifier|static
name|void
name|diff_tree_local
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|changes
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|local
parameter_list|)
block|{
name|struct
name|diff_options
name|opt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tdiff_tree_local(len = %i, base = %.7s, local = %.7s)\n"
argument_list|,
name|len
argument_list|,
name|sha1_to_hex
argument_list|(
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|opt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|base
argument_list|,
name|local
argument_list|,
literal|""
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
name|struct
name|notes_merge_pair
modifier|*
name|mp
decl_stmt|;
name|int
name|match
decl_stmt|;
name|unsigned
name|char
name|obj
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|verify_notes_filepair
argument_list|(
name|p
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|trace_printf
argument_list|(
literal|"\t\tCannot merge entry '%s' (%c): "
literal|"%.7s -> %.7s. Skipping!\n"
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|p
operator|->
name|status
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mp
operator|=
name|find_notes_merge_pair_pos
argument_list|(
name|changes
argument_list|,
name|len
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|trace_printf
argument_list|(
literal|"\t\tIgnoring local-only change for %s: "
literal|"%.7s -> %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|obj
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* deletion */
comment|/* 			 * Either this is a true deletion (1), or it is part 			 * of an A/D pair (2), or D/A pair (3): 			 * 			 * (1) mp->local is uninitialized; set it to null_sha1 			 * (2) mp->local is not uninitialized; don't touch it 			 * (3) mp->local is uninitialized; set it to null_sha1 			 *     (will be overwritten by following addition) 			 */
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
condition|)
name|hashclr
argument_list|(
name|mp
operator|->
name|local
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* addition */
comment|/* 			 * Either this is a true addition (1), or it is part 			 * of an A/D pair (2), or D/A pair (3): 			 * 			 * (1) mp->local is uninitialized; set to p->two->sha1 			 * (2) mp->local is uninitialized; set to p->two->sha1 			 * (3) mp->local is null_sha1;     set to p->two->sha1 			 */
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|mp
operator|->
name|local
argument_list|)
operator|||
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* modification */
comment|/* 			 * This is a true modification. p->one->sha1 shall 			 * match mp->base, and mp->local shall be uninitialized. 			 * Set mp->local to p->two->sha1. 			 */
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|,
name|mp
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\t\tStored local change for %s: %.7s -> %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diff_tree_release_paths
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_notes_merge_worktree
specifier|static
name|void
name|check_notes_merge_worktree
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
operator|->
name|has_worktree
condition|)
block|{
comment|/* 		 * Must establish NOTES_MERGE_WORKTREE. 		 * Abort if NOTES_MERGE_WORKTREE already exists 		 */
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|advice_resolve_conflict
condition|)
name|die
argument_list|(
literal|"You have not concluded your previous "
literal|"notes merge (%s exists).\nPlease, use "
literal|"'git notes merge --commit' or 'git notes "
literal|"merge --abort' to commit/abort the "
literal|"previous merge before you start a new "
literal|"notes merge."
argument_list|,
name|git_path
argument_list|(
literal|"NOTES_MERGE_*"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"You have not concluded your notes merge "
literal|"(%s exists)."
argument_list|,
name|git_path
argument_list|(
literal|"NOTES_MERGE_*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|safe_create_leading_directories
argument_list|(
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
literal|"/.test"
argument_list|)
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"unable to create directory %s"
argument_list|,
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|has_worktree
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
argument_list|)
argument_list|)
condition|)
comment|/* NOTES_MERGE_WORKTREE should already be established */
name|die
argument_list|(
literal|"missing '%s'. This should not happen"
argument_list|,
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write_buf_to_worktree
specifier|static
name|void
name|write_buf_to_worktree
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
literal|"/%s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_create_leading_directories
argument_list|(
name|path
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"unable to create directory for '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|path
argument_list|)
condition|)
name|die
argument_list|(
literal|"found existing file at '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"failed to open '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|long
name|ret
init|=
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Ignore epipe */
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
break|break;
name|die_errno
argument_list|(
literal|"notes-merge"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|die
argument_list|(
literal|"notes-merge: disk full?"
argument_list|)
expr_stmt|;
block|}
name|size
operator|-=
name|ret
expr_stmt|;
name|buf
operator|+=
name|ret
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write_note_to_worktree
specifier|static
name|void
name|write_note_to_worktree
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|obj
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|note
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|read_sha1_file
argument_list|(
name|note
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"cannot read note %s for object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|note
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"blob expected in note %s for object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|note
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|write_buf_to_worktree
argument_list|(
name|obj
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ll_merge_in_worktree
specifier|static
name|int
name|ll_merge_in_worktree
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|p
parameter_list|)
block|{
name|mmbuffer_t
name|result_buf
decl_stmt|;
name|mmfile_t
name|base
decl_stmt|,
name|local
decl_stmt|,
name|remote
decl_stmt|;
name|int
name|status
decl_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|base
argument_list|,
name|p
operator|->
name|base
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|local
argument_list|,
name|p
operator|->
name|local
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|remote
argument_list|,
name|p
operator|->
name|remote
argument_list|)
expr_stmt|;
name|status
operator|=
name|ll_merge
argument_list|(
operator|&
name|result_buf
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|,
operator|&
name|base
argument_list|,
name|NULL
argument_list|,
operator|&
name|local
argument_list|,
name|o
operator|->
name|local_ref
argument_list|,
operator|&
name|remote
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|local
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|<
literal|0
operator|)
operator|||
operator|!
name|result_buf
operator|.
name|ptr
condition|)
name|die
argument_list|(
literal|"Failed to execute internal merge"
argument_list|)
expr_stmt|;
name|write_buf_to_worktree
argument_list|(
name|p
operator|->
name|obj
argument_list|,
name|result_buf
operator|.
name|ptr
argument_list|,
name|result_buf
operator|.
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|merge_one_change_manual
specifier|static
name|int
name|merge_one_change_manual
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|p
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lref
init|=
name|o
operator|->
name|local_ref
condition|?
name|o
operator|->
name|local_ref
else|:
literal|"local version"
decl_stmt|;
specifier|const
name|char
modifier|*
name|rref
init|=
name|o
operator|->
name|remote_ref
condition|?
name|o
operator|->
name|remote_ref
else|:
literal|"remote version"
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\t\t\tmerge_one_change_manual(obj = %.7s, base = %.7s, "
literal|"local = %.7s, remote = %.7s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|local
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add "Conflicts:" section to commit message first time through */
if|if
condition|(
operator|!
name|o
operator|->
name|has_worktree
condition|)
name|strbuf_addstr
argument_list|(
operator|&
operator|(
name|o
operator|->
name|commit_msg
operator|)
argument_list|,
literal|"\n\nConflicts:\n"
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
operator|(
name|o
operator|->
name|commit_msg
operator|)
argument_list|,
literal|"\t%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Auto-merging notes for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|check_notes_merge_worktree
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|local
argument_list|)
condition|)
block|{
comment|/* D/F conflict, checkout p->remote */
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|1
condition|)
name|printf
argument_list|(
literal|"CONFLICT (delete/modify): Notes for object %s "
literal|"deleted in %s and modified in %s. Version from %s "
literal|"left in tree.\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|,
name|lref
argument_list|,
name|rref
argument_list|,
name|rref
argument_list|)
expr_stmt|;
name|write_note_to_worktree
argument_list|(
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|remote
argument_list|)
condition|)
block|{
comment|/* D/F conflict, checkout p->local */
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|1
condition|)
name|printf
argument_list|(
literal|"CONFLICT (delete/modify): Notes for object %s "
literal|"deleted in %s and modified in %s. Version from %s "
literal|"left in tree.\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|,
name|rref
argument_list|,
name|lref
argument_list|,
name|lref
argument_list|)
expr_stmt|;
name|write_note_to_worktree
argument_list|(
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|local
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "regular" conflict, checkout result of ll_merge() */
specifier|const
name|char
modifier|*
name|reason
init|=
literal|"content"
decl_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|base
argument_list|)
condition|)
name|reason
operator|=
literal|"add/add"
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|1
condition|)
name|printf
argument_list|(
literal|"CONFLICT (%s): Merge conflict in notes for "
literal|"object %s\n"
argument_list|,
name|reason
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|ll_merge_in_worktree
argument_list|(
name|o
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\t\t\tremoving from partial merge result\n"
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|merge_one_change
specifier|static
name|int
name|merge_one_change
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|p
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|)
block|{
comment|/* 	 * Return 0 if change is successfully resolved (stored in notes_tree). 	 * Return 1 is change results in a conflict (NOT stored in notes_tree, 	 * but instead written to NOTES_MERGE_WORKTREE with conflict markers). 	 */
switch|switch
condition|(
name|o
operator|->
name|strategy
condition|)
block|{
case|case
name|NOTES_MERGE_RESOLVE_MANUAL
case|:
return|return
name|merge_one_change_manual
argument_list|(
name|o
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
return|;
case|case
name|NOTES_MERGE_RESOLVE_OURS
case|:
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Using local notes for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* nothing to do */
return|return
literal|0
return|;
case|case
name|NOTES_MERGE_RESOLVE_THEIRS
case|:
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Using remote notes for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|NOTES_MERGE_RESOLVE_UNION
case|:
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Concatenating local and remote notes for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|,
name|combine_notes_concatenate
argument_list|)
condition|)
name|die
argument_list|(
literal|"failed to concatenate notes "
literal|"(combine_notes_concatenate)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|NOTES_MERGE_RESOLVE_CAT_SORT_UNIQ
case|:
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Concatenating unique lines in local and remote "
literal|"notes for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|,
name|combine_notes_cat_sort_uniq
argument_list|)
condition|)
name|die
argument_list|(
literal|"failed to concatenate notes "
literal|"(combine_notes_cat_sort_uniq)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|die
argument_list|(
literal|"Unknown strategy (%i)."
argument_list|,
name|o
operator|->
name|strategy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_changes
specifier|static
name|int
name|merge_changes
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|changes
parameter_list|,
name|int
modifier|*
name|num_changes
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|conflicts
init|=
literal|0
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tmerge_changes(num_changes = %i)\n"
argument_list|,
operator|*
name|num_changes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_changes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|notes_merge_pair
modifier|*
name|p
init|=
name|changes
operator|+
name|i
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\t\t%.7s: %.7s -> %.7s/%.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|local
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|base
argument_list|,
name|p
operator|->
name|remote
argument_list|)
condition|)
block|{
comment|/* no remote change; nothing to do */
name|trace_printf
argument_list|(
literal|"\t\t\tskipping (no remote change)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|local
argument_list|,
name|p
operator|->
name|remote
argument_list|)
condition|)
block|{
comment|/* same change in local and remote; nothing to do */
name|trace_printf
argument_list|(
literal|"\t\t\tskipping (local == remote)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
operator|||
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|local
argument_list|,
name|p
operator|->
name|base
argument_list|)
condition|)
block|{
comment|/* no local change; adopt remote change */
name|trace_printf
argument_list|(
literal|"\t\t\tno local change, adopted remote\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* need file-level merge between local and remote */
name|trace_printf
argument_list|(
literal|"\t\t\tneed content-level merge\n"
argument_list|)
expr_stmt|;
name|conflicts
operator|+=
name|merge_one_change
argument_list|(
name|o
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|conflicts
return|;
block|}
end_function
begin_function
DECL|function|merge_from_diffs
specifier|static
name|int
name|merge_from_diffs
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|local
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|remote
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|notes_merge_pair
modifier|*
name|changes
decl_stmt|;
name|int
name|num_changes
decl_stmt|,
name|conflicts
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tmerge_from_diffs(base = %.7s, local = %.7s, "
literal|"remote = %.7s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|local
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|changes
operator|=
name|diff_tree_remote
argument_list|(
name|o
argument_list|,
name|base
argument_list|,
name|remote
argument_list|,
operator|&
name|num_changes
argument_list|)
expr_stmt|;
name|diff_tree_local
argument_list|(
name|o
argument_list|,
name|changes
argument_list|,
name|num_changes
argument_list|,
name|base
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|conflicts
operator|=
name|merge_changes
argument_list|(
name|o
argument_list|,
name|changes
argument_list|,
operator|&
name|num_changes
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|changes
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"Merge result: %i unmerged notes and a %s notes tree\n"
argument_list|,
name|conflicts
argument_list|,
name|t
operator|->
name|dirty
condition|?
literal|"dirty"
else|:
literal|"clean"
argument_list|)
expr_stmt|;
return|return
name|conflicts
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|create_notes_commit
name|void
name|create_notes_commit
parameter_list|(
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|,
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
specifier|const
name|struct
name|strbuf
modifier|*
name|msg
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
name|unsigned
name|char
name|tree_sha1
index|[
literal|20
index|]
decl_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|initialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_notes_tree
argument_list|(
name|t
argument_list|,
name|tree_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to write notes tree to database"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parents
condition|)
block|{
comment|/* Deduce parent commit from t->ref */
name|unsigned
name|char
name|parent_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|read_ref
argument_list|(
name|t
operator|->
name|ref
argument_list|,
name|parent_sha1
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|lookup_commit
argument_list|(
name|parent_sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|||
name|parse_commit
argument_list|(
name|parent
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to find/parse commit %s"
argument_list|,
name|t
operator|->
name|ref
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
block|}
comment|/* else: t->ref points to nothing, assume root/orphan commit */
block|}
if|if
condition|(
name|commit_tree
argument_list|(
name|msg
argument_list|,
name|tree_sha1
argument_list|,
name|parents
argument_list|,
name|result_sha1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to commit notes tree to database"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|notes_merge
name|int
name|notes_merge
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|local_tree
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
name|unsigned
name|char
name|local_sha1
index|[
literal|20
index|]
decl_stmt|,
name|remote_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|local
decl_stmt|,
modifier|*
name|remote
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|bases
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base_sha1
decl_stmt|,
modifier|*
name|base_tree_sha1
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|o
operator|->
name|local_ref
operator|&&
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|strcmp
argument_list|(
name|o
operator|->
name|local_ref
argument_list|,
name|local_tree
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|result_sha1
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"notes_merge(o->local_ref = %s, o->remote_ref = %s)\n"
argument_list|,
name|o
operator|->
name|local_ref
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
comment|/* Dereference o->local_ref into local_sha1 */
if|if
condition|(
name|read_ref_full
argument_list|(
name|o
operator|->
name|local_ref
argument_list|,
name|local_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve local notes ref '%s'"
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_refname_format
argument_list|(
name|o
operator|->
name|local_ref
argument_list|,
literal|0
argument_list|)
operator|&&
name|is_null_sha1
argument_list|(
name|local_sha1
argument_list|)
condition|)
name|local
operator|=
name|NULL
expr_stmt|;
comment|/* local_sha1 == null_sha1 indicates unborn ref */
elseif|else
if|if
condition|(
operator|!
operator|(
name|local
operator|=
name|lookup_commit_reference
argument_list|(
name|local_sha1
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"Could not parse local commit %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|local_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"\tlocal commit: %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|local_sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dereference o->remote_ref into remote_sha1 */
if|if
condition|(
name|get_sha1
argument_list|(
name|o
operator|->
name|remote_ref
argument_list|,
name|remote_sha1
argument_list|)
condition|)
block|{
comment|/* 		 * Failed to get remote_sha1. If o->remote_ref looks like an 		 * unborn ref, perform the merge using an empty notes tree. 		 */
if|if
condition|(
operator|!
name|check_refname_format
argument_list|(
name|o
operator|->
name|remote_ref
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|hashclr
argument_list|(
name|remote_sha1
argument_list|)
expr_stmt|;
name|remote
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|die
argument_list|(
literal|"Failed to resolve remote notes ref '%s'"
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|remote
operator|=
name|lookup_commit_reference
argument_list|(
name|remote_sha1
argument_list|)
operator|)
condition|)
block|{
name|die
argument_list|(
literal|"Could not parse remote commit %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\tremote commit: %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
operator|&&
operator|!
name|remote
condition|)
name|die
argument_list|(
literal|"Cannot merge empty notes ref (%s) into empty notes ref "
literal|"(%s)"
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
comment|/* result == remote commit */
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|remote_sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
if|if
condition|(
operator|!
name|remote
condition|)
block|{
comment|/* result == local commit */
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|local_sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
name|assert
argument_list|(
name|local
operator|&&
name|remote
argument_list|)
expr_stmt|;
comment|/* Find merge bases */
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|local
argument_list|,
name|remote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bases
condition|)
block|{
name|base_sha1
operator|=
name|null_sha1
expr_stmt|;
name|base_tree_sha1
operator|=
name|EMPTY_TREE_SHA1_BIN
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"No merge base found; doing history-less merge\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bases
operator|->
name|next
condition|)
block|{
name|base_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|base_tree_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"One merge base found (%.7s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: How to handle multiple merge-bases? */
name|base_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|base_tree_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"Multiple merge bases found. Using the first "
literal|"(%.7s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"Merging remote commit %.7s into local commit %.7s with "
literal|"merge-base %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|base_sha1
argument_list|)
condition|)
block|{
comment|/* Already merged; result == local commit */
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Already up-to-date!\n"
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|base_sha1
argument_list|)
condition|)
block|{
comment|/* Fast-forward; result == remote commit */
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"Fast-forward\n"
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
name|result
operator|=
name|merge_from_diffs
argument_list|(
name|o
argument_list|,
name|base_tree_sha1
argument_list|,
name|local
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|remote
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|local_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
comment|/* non-trivial merge (with or without conflicts) */
comment|/* Commit (partial) result */
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|;
name|commit_list_insert
argument_list|(
name|remote
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
comment|/* LIFO order */
name|commit_list_insert
argument_list|(
name|local
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
name|create_notes_commit
argument_list|(
name|local_tree
argument_list|,
name|parents
argument_list|,
operator|&
name|o
operator|->
name|commit_msg
argument_list|,
name|result_sha1
argument_list|)
expr_stmt|;
block|}
name|found_result
label|:
name|free_commit_list
argument_list|(
name|bases
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
operator|(
name|o
operator|->
name|commit_msg
operator|)
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"notes_merge(): result = %i, result_sha1 = %.7s\n"
argument_list|,
name|result
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|notes_merge_commit
name|int
name|notes_merge_commit
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|partial_tree
parameter_list|,
name|struct
name|commit
modifier|*
name|partial_commit
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
comment|/* 	 * Iterate through files in .git/NOTES_MERGE_WORKTREE and add all 	 * found notes to 'partial_tree'. Write the updates notes tree to 	 * the DB, and commit the resulting tree object while reusing the 	 * commit message and parents from 'partial_commit'. 	 * Finally store the new commit object SHA1 into 'result_sha1'. 	 */
name|struct
name|dir_struct
name|dir
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|xstrdup
argument_list|(
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
literal|"/"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|path_len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|strstr
argument_list|(
name|partial_commit
operator|->
name|buffer
argument_list|,
literal|"\n\n"
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|sb_msg
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"Committing notes in notes merge worktree at %.*s\n"
argument_list|,
name|path_len
operator|-
literal|1
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|||
name|msg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|die
argument_list|(
literal|"partial notes commit has empty message"
argument_list|)
expr_stmt|;
name|msg
operator|+=
literal|2
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dir
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|read_directory
argument_list|(
operator|&
name|dir
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dir_entry
modifier|*
name|ent
init|=
name|dir
operator|.
name|entries
index|[
name|i
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|ent
operator|->
name|name
operator|+
name|path_len
decl_stmt|;
name|unsigned
name|char
name|obj_sha1
index|[
literal|20
index|]
decl_stmt|,
name|blob_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|len
operator|-
name|path_len
operator|!=
literal|40
operator|||
name|get_sha1_hex
argument_list|(
name|relpath
argument_list|,
name|obj_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"Skipping non-SHA1 entry '%s'\n"
argument_list|,
name|ent
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* write file as blob, and add to partial_tree */
if|if
condition|(
name|stat
argument_list|(
name|ent
operator|->
name|name
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"Failed to stat '%s'"
argument_list|,
name|ent
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_path
argument_list|(
name|blob_sha1
argument_list|,
name|ent
operator|->
name|name
argument_list|,
operator|&
name|st
argument_list|,
name|HASH_WRITE_OBJECT
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to write blob object from '%s'"
argument_list|,
name|ent
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|partial_tree
argument_list|,
name|obj_sha1
argument_list|,
name|blob_sha1
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to add resolved note '%s' to notes tree"
argument_list|,
name|ent
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"Added resolved note for object %s: %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj_sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|blob_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strbuf_attach
argument_list|(
operator|&
name|sb_msg
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|create_notes_commit
argument_list|(
name|partial_tree
argument_list|,
name|partial_commit
operator|->
name|parents
argument_list|,
operator|&
name|sb_msg
argument_list|,
name|result_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|4
condition|)
name|printf
argument_list|(
literal|"Finalized notes merge commit: %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|notes_merge_abort
name|int
name|notes_merge_abort
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
comment|/* Remove .git/NOTES_MERGE_WORKTREE directory and all files within */
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"Removing notes merge worktree at %s\n"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|remove_dir_recursively
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
end_unit
