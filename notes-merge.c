begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"notes-merge.h"
end_include
begin_struct
DECL|struct|notes_merge_pair
struct|struct
name|notes_merge_pair
block|{
DECL|member|obj
DECL|member|base
DECL|member|local
DECL|member|remote
name|unsigned
name|char
name|obj
index|[
literal|20
index|]
decl_stmt|,
name|base
index|[
literal|20
index|]
decl_stmt|,
name|local
index|[
literal|20
index|]
decl_stmt|,
name|remote
index|[
literal|20
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|init_notes_merge_options
name|void
name|init_notes_merge_options
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_options
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|verbosity
operator|=
name|NOTES_MERGE_VERBOSITY_DEFAULT
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|OUTPUT
define|#
directive|define
name|OUTPUT
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do { \ 		if ((o)->verbosity>= (v)) { \ 			printf(__VA_ARGS__); \ 			puts(""); \ 		} \ 	} while (0)
end_define
begin_function
DECL|function|path_to_sha1
specifier|static
name|int
name|path_to_sha1
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
name|hex_sha1
index|[
literal|40
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|path
operator|&&
name|i
operator|<
literal|40
condition|)
block|{
if|if
condition|(
operator|*
name|path
operator|!=
literal|'/'
condition|)
name|hex_sha1
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|path
expr_stmt|;
name|path
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|path
operator|||
name|i
operator|!=
literal|40
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|get_sha1_hex
argument_list|(
name|hex_sha1
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|verify_notes_filepair
specifier|static
name|int
name|verify_notes_filepair
parameter_list|(
name|struct
name|diff_filepair
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
switch|switch
condition|(
name|p
operator|->
name|status
condition|)
block|{
case|case
name|DIFF_STATUS_MODIFIED
case|:
name|assert
argument_list|(
name|p
operator|->
name|one
operator|->
name|mode
operator|==
name|p
operator|->
name|two
operator|->
name|mode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFF_STATUS_ADDED
case|:
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFF_STATUS_DELETED
case|:
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|assert
argument_list|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|p
operator|->
name|two
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|path_to_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|find_notes_merge_pair_pos
specifier|static
name|struct
name|notes_merge_pair
modifier|*
name|find_notes_merge_pair_pos
parameter_list|(
name|struct
name|notes_merge_pair
modifier|*
name|list
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|obj
parameter_list|,
name|int
name|insert_new
parameter_list|,
name|int
modifier|*
name|occupied
parameter_list|)
block|{
comment|/* 	 * Both diff_tree_remote() and diff_tree_local() tend to process 	 * merge_pairs in ascending order. Therefore, cache last returned 	 * index, and search sequentially from there until the appropriate 	 * position is found. 	 * 	 * Since inserts only happen from diff_tree_remote() (which mainly 	 * _appends_), we don't care that inserting into the middle of the 	 * list is expensive (using memmove()). 	 */
specifier|static
name|int
name|last_index
decl_stmt|;
name|int
name|i
init|=
name|last_index
operator|<
name|len
condition|?
name|last_index
else|:
name|len
operator|-
literal|1
decl_stmt|;
name|int
name|prev_cmp
init|=
literal|0
decl_stmt|,
name|cmp
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|len
condition|)
block|{
name|cmp
operator|=
name|hashcmp
argument_list|(
name|obj
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
comment|/* obj belongs @ i */
break|break;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
operator|&&
name|prev_cmp
operator|<=
literal|0
condition|)
comment|/* obj belongs< i */
name|i
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
comment|/* obj belongs between i-1 and i */
break|break;
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
operator|&&
name|prev_cmp
operator|>=
literal|0
condition|)
comment|/* obj belongs> i */
name|i
operator|++
expr_stmt|;
else|else
comment|/* if (cmp> 0) */
block|{
comment|/* obj belongs between i and i+1 */
name|i
operator|++
expr_stmt|;
break|break;
block|}
name|prev_cmp
operator|=
name|cmp
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* obj belongs at, or immediately preceding, index i (0<= i<= len) */
if|if
condition|(
operator|!
name|cmp
condition|)
operator|*
name|occupied
operator|=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|occupied
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insert_new
operator|&&
name|i
operator|<
name|len
condition|)
block|{
name|memmove
argument_list|(
name|list
operator|+
name|i
operator|+
literal|1
argument_list|,
name|list
operator|+
name|i
argument_list|,
operator|(
name|len
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_pair
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|list
operator|+
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|last_index
operator|=
name|i
expr_stmt|;
return|return
name|list
operator|+
name|i
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|uninitialized
specifier|static
name|unsigned
name|char
name|uninitialized
index|[
literal|20
index|]
init|=
literal|"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
expr|\
literal|"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|diff_tree_remote
specifier|static
name|struct
name|notes_merge_pair
modifier|*
name|diff_tree_remote
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|remote
parameter_list|,
name|int
modifier|*
name|num_changes
parameter_list|)
block|{
name|struct
name|diff_options
name|opt
decl_stmt|;
name|struct
name|notes_merge_pair
modifier|*
name|changes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tdiff_tree_remote(base = %.7s, remote = %.7s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|opt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|opt
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff_setup_done failed"
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|base
argument_list|,
name|remote
argument_list|,
literal|""
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|changes
operator|=
name|xcalloc
argument_list|(
name|diff_queued_diff
operator|.
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_merge_pair
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
name|struct
name|notes_merge_pair
modifier|*
name|mp
decl_stmt|;
name|int
name|occupied
decl_stmt|;
name|unsigned
name|char
name|obj
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|verify_notes_filepair
argument_list|(
name|p
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|trace_printf
argument_list|(
literal|"\t\tCannot merge entry '%s' (%c): "
literal|"%.7s -> %.7s. Skipping!\n"
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|p
operator|->
name|status
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mp
operator|=
name|find_notes_merge_pair_pos
argument_list|(
name|changes
argument_list|,
name|len
argument_list|,
name|obj
argument_list|,
literal|1
argument_list|,
operator|&
name|occupied
argument_list|)
expr_stmt|;
if|if
condition|(
name|occupied
condition|)
block|{
comment|/* We've found an addition/deletion pair */
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|obj
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* addition */
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|mp
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|remote
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* deletion */
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|mp
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|base
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
name|assert
argument_list|(
operator|!
literal|"Invalid existing change recorded"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hashcpy
argument_list|(
name|mp
operator|->
name|obj
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|base
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|remote
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\t\tStored remote change for %s: %.7s -> %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diff_tree_release_paths
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
operator|*
name|num_changes
operator|=
name|len
expr_stmt|;
return|return
name|changes
return|;
block|}
end_function
begin_function
DECL|function|diff_tree_local
specifier|static
name|void
name|diff_tree_local
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|changes
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|local
parameter_list|)
block|{
name|struct
name|diff_options
name|opt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tdiff_tree_local(len = %i, base = %.7s, local = %.7s)\n"
argument_list|,
name|len
argument_list|,
name|sha1_to_hex
argument_list|(
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|opt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|opt
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff_setup_done failed"
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|base
argument_list|,
name|local
argument_list|,
literal|""
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
name|struct
name|notes_merge_pair
modifier|*
name|mp
decl_stmt|;
name|int
name|match
decl_stmt|;
name|unsigned
name|char
name|obj
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|verify_notes_filepair
argument_list|(
name|p
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|trace_printf
argument_list|(
literal|"\t\tCannot merge entry '%s' (%c): "
literal|"%.7s -> %.7s. Skipping!\n"
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|p
operator|->
name|status
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mp
operator|=
name|find_notes_merge_pair_pos
argument_list|(
name|changes
argument_list|,
name|len
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
operator|&
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|trace_printf
argument_list|(
literal|"\t\tIgnoring local-only change for %s: "
literal|"%.7s -> %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|obj
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* deletion */
comment|/* 			 * Either this is a true deletion (1), or it is part 			 * of an A/D pair (2), or D/A pair (3): 			 * 			 * (1) mp->local is uninitialized; set it to null_sha1 			 * (2) mp->local is not uninitialized; don't touch it 			 * (3) mp->local is uninitialized; set it to null_sha1 			 *     (will be overwritten by following addition) 			 */
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
condition|)
name|hashclr
argument_list|(
name|mp
operator|->
name|local
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_null_sha1
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
condition|)
block|{
comment|/* addition */
comment|/* 			 * Either this is a true addition (1), or it is part 			 * of an A/D pair (2), or D/A pair (3): 			 * 			 * (1) mp->local is uninitialized; set to p->two->sha1 			 * (2) mp->local is uninitialized; set to p->two->sha1 			 * (3) mp->local is null_sha1;     set to p->two->sha1 			 */
name|assert
argument_list|(
name|is_null_sha1
argument_list|(
name|mp
operator|->
name|local
argument_list|)
operator|||
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* modification */
comment|/* 			 * This is a true modification. p->one->sha1 shall 			 * match mp->base, and mp->local shall be uninitialized. 			 * Set mp->local to p->two->sha1. 			 */
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|,
name|mp
operator|->
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|hashcmp
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|mp
operator|->
name|local
argument_list|,
name|p
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\t\tStored local change for %s: %.7s -> %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|mp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diff_tree_release_paths
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_one_change
specifier|static
name|int
name|merge_one_change
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|p
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|)
block|{
comment|/* 	 * Return 0 if change was resolved (and added to notes_tree), 	 * 1 if conflict 	 */
switch|switch
condition|(
name|o
operator|->
name|strategy
condition|)
block|{
case|case
name|NOTES_MERGE_RESOLVE_MANUAL
case|:
return|return
literal|1
return|;
case|case
name|NOTES_MERGE_RESOLVE_OURS
case|:
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Using local notes for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* nothing to do */
return|return
literal|0
return|;
case|case
name|NOTES_MERGE_RESOLVE_THEIRS
case|:
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Using remote notes for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|NOTES_MERGE_RESOLVE_UNION
case|:
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Concatenating local and remote notes for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|,
name|combine_notes_concatenate
argument_list|)
condition|)
name|die
argument_list|(
literal|"failed to concatenate notes "
literal|"(combine_notes_concatenate)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|die
argument_list|(
literal|"Unknown strategy (%i)."
argument_list|,
name|o
operator|->
name|strategy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_changes
specifier|static
name|int
name|merge_changes
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_merge_pair
modifier|*
name|changes
parameter_list|,
name|int
modifier|*
name|num_changes
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|conflicts
init|=
literal|0
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tmerge_changes(num_changes = %i)\n"
argument_list|,
operator|*
name|num_changes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_changes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|notes_merge_pair
modifier|*
name|p
init|=
name|changes
operator|+
name|i
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\t\t%.7s: %.7s -> %.7s/%.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|local
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|base
argument_list|,
name|p
operator|->
name|remote
argument_list|)
condition|)
block|{
comment|/* no remote change; nothing to do */
name|trace_printf
argument_list|(
literal|"\t\t\tskipping (no remote change)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|local
argument_list|,
name|p
operator|->
name|remote
argument_list|)
condition|)
block|{
comment|/* same change in local and remote; nothing to do */
name|trace_printf
argument_list|(
literal|"\t\t\tskipping (local == remote)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|local
argument_list|,
name|uninitialized
argument_list|)
operator|||
operator|!
name|hashcmp
argument_list|(
name|p
operator|->
name|local
argument_list|,
name|p
operator|->
name|base
argument_list|)
condition|)
block|{
comment|/* no local change; adopt remote change */
name|trace_printf
argument_list|(
literal|"\t\t\tno local change, adopted remote\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|obj
argument_list|,
name|p
operator|->
name|remote
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* need file-level merge between local and remote */
name|trace_printf
argument_list|(
literal|"\t\t\tneed content-level merge\n"
argument_list|)
expr_stmt|;
name|conflicts
operator|+=
name|merge_one_change
argument_list|(
name|o
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|conflicts
return|;
block|}
end_function
begin_function
DECL|function|merge_from_diffs
specifier|static
name|int
name|merge_from_diffs
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|local
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|remote
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|notes_merge_pair
modifier|*
name|changes
decl_stmt|;
name|int
name|num_changes
decl_stmt|,
name|conflicts
decl_stmt|;
name|trace_printf
argument_list|(
literal|"\tmerge_from_diffs(base = %.7s, local = %.7s, "
literal|"remote = %.7s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|local
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|changes
operator|=
name|diff_tree_remote
argument_list|(
name|o
argument_list|,
name|base
argument_list|,
name|remote
argument_list|,
operator|&
name|num_changes
argument_list|)
expr_stmt|;
name|diff_tree_local
argument_list|(
name|o
argument_list|,
name|changes
argument_list|,
name|num_changes
argument_list|,
name|base
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|conflicts
operator|=
name|merge_changes
argument_list|(
name|o
argument_list|,
name|changes
argument_list|,
operator|&
name|num_changes
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|changes
argument_list|)
expr_stmt|;
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"Merge result: %i unmerged notes and a %s notes tree"
argument_list|,
name|conflicts
argument_list|,
name|t
operator|->
name|dirty
condition|?
literal|"dirty"
else|:
literal|"clean"
argument_list|)
expr_stmt|;
return|return
name|conflicts
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|create_notes_commit
name|void
name|create_notes_commit
parameter_list|(
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|,
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
name|unsigned
name|char
name|tree_sha1
index|[
literal|20
index|]
decl_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|initialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_notes_tree
argument_list|(
name|t
argument_list|,
name|tree_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to write notes tree to database"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parents
condition|)
block|{
comment|/* Deduce parent commit from t->ref */
name|unsigned
name|char
name|parent_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|read_ref
argument_list|(
name|t
operator|->
name|ref
argument_list|,
name|parent_sha1
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|lookup_commit
argument_list|(
name|parent_sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|||
name|parse_commit
argument_list|(
name|parent
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to find/parse commit %s"
argument_list|,
name|t
operator|->
name|ref
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
block|}
comment|/* else: t->ref points to nothing, assume root/orphan commit */
block|}
if|if
condition|(
name|commit_tree
argument_list|(
name|msg
argument_list|,
name|tree_sha1
argument_list|,
name|parents
argument_list|,
name|result_sha1
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to commit notes tree to database"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|notes_merge
name|int
name|notes_merge
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|,
name|struct
name|notes_tree
modifier|*
name|local_tree
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
name|unsigned
name|char
name|local_sha1
index|[
literal|20
index|]
decl_stmt|,
name|remote_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|local
decl_stmt|,
modifier|*
name|remote
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|bases
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base_sha1
decl_stmt|,
modifier|*
name|base_tree_sha1
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|o
operator|->
name|local_ref
operator|&&
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|strcmp
argument_list|(
name|o
operator|->
name|local_ref
argument_list|,
name|local_tree
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|result_sha1
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"notes_merge(o->local_ref = %s, o->remote_ref = %s)\n"
argument_list|,
name|o
operator|->
name|local_ref
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
comment|/* Dereference o->local_ref into local_sha1 */
if|if
condition|(
operator|!
name|resolve_ref
argument_list|(
name|o
operator|->
name|local_ref
argument_list|,
name|local_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve local notes ref '%s'"
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|check_ref_format
argument_list|(
name|o
operator|->
name|local_ref
argument_list|)
operator|&&
name|is_null_sha1
argument_list|(
name|local_sha1
argument_list|)
condition|)
name|local
operator|=
name|NULL
expr_stmt|;
comment|/* local_sha1 == null_sha1 indicates unborn ref */
elseif|else
if|if
condition|(
operator|!
operator|(
name|local
operator|=
name|lookup_commit_reference
argument_list|(
name|local_sha1
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"Could not parse local commit %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|local_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"\tlocal commit: %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|local_sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Dereference o->remote_ref into remote_sha1 */
if|if
condition|(
name|get_sha1
argument_list|(
name|o
operator|->
name|remote_ref
argument_list|,
name|remote_sha1
argument_list|)
condition|)
block|{
comment|/* 		 * Failed to get remote_sha1. If o->remote_ref looks like an 		 * unborn ref, perform the merge using an empty notes tree. 		 */
if|if
condition|(
operator|!
name|check_ref_format
argument_list|(
name|o
operator|->
name|remote_ref
argument_list|)
condition|)
block|{
name|hashclr
argument_list|(
name|remote_sha1
argument_list|)
expr_stmt|;
name|remote
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|die
argument_list|(
literal|"Failed to resolve remote notes ref '%s'"
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|remote
operator|=
name|lookup_commit_reference
argument_list|(
name|remote_sha1
argument_list|)
operator|)
condition|)
block|{
name|die
argument_list|(
literal|"Could not parse remote commit %s (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|)
expr_stmt|;
block|}
name|trace_printf
argument_list|(
literal|"\tremote commit: %.7s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
operator|&&
operator|!
name|remote
condition|)
name|die
argument_list|(
literal|"Cannot merge empty notes ref (%s) into empty notes ref "
literal|"(%s)"
argument_list|,
name|o
operator|->
name|remote_ref
argument_list|,
name|o
operator|->
name|local_ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
comment|/* result == remote commit */
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|remote_sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
if|if
condition|(
operator|!
name|remote
condition|)
block|{
comment|/* result == local commit */
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|local_sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
name|assert
argument_list|(
name|local
operator|&&
name|remote
argument_list|)
expr_stmt|;
comment|/* Find merge bases */
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|local
argument_list|,
name|remote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bases
condition|)
block|{
name|base_sha1
operator|=
name|null_sha1
expr_stmt|;
name|base_tree_sha1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|EMPTY_TREE_SHA1_BIN
expr_stmt|;
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"No merge base found; doing history-less merge"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bases
operator|->
name|next
condition|)
block|{
name|base_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|base_tree_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"One merge base found (%.7s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: How to handle multiple merge-bases? */
name|base_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|base_tree_sha1
operator|=
name|bases
operator|->
name|item
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|3
argument_list|,
literal|"Multiple merge bases found. Using the first "
literal|"(%.7s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|4
argument_list|,
literal|"Merging remote commit %.7s into local commit %.7s with "
literal|"merge-base %.7s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|base_sha1
argument_list|)
condition|)
block|{
comment|/* Already merged; result == local commit */
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Already up-to-date!"
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|local
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|base_sha1
argument_list|)
condition|)
block|{
comment|/* Fast-forward; result == remote commit */
name|OUTPUT
argument_list|(
name|o
argument_list|,
literal|2
argument_list|,
literal|"Fast-forward"
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|result_sha1
argument_list|,
name|remote
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
goto|goto
name|found_result
goto|;
block|}
name|result
operator|=
name|merge_from_diffs
argument_list|(
name|o
argument_list|,
name|base_tree_sha1
argument_list|,
name|local
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|remote
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|local_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
comment|/* successful non-trivial merge */
comment|/* Commit result */
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|;
name|commit_list_insert
argument_list|(
name|remote
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
comment|/* LIFO order */
name|commit_list_insert
argument_list|(
name|local
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
name|create_notes_commit
argument_list|(
name|local_tree
argument_list|,
name|parents
argument_list|,
name|o
operator|->
name|commit_msg
argument_list|,
name|result_sha1
argument_list|)
expr_stmt|;
block|}
name|found_result
label|:
name|free_commit_list
argument_list|(
name|bases
argument_list|)
expr_stmt|;
name|trace_printf
argument_list|(
literal|"notes_merge(): result = %i, result_sha1 = %.7s\n"
argument_list|,
name|result
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
end_unit
