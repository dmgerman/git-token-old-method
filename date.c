begin_unit
begin_comment
comment|/*  * GIT - The information manager from hell  *  * Copyright (C) Linus Torvalds, 2005  */
end_comment
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_function
DECL|function|my_mktime
specifier|static
name|time_t
name|my_mktime
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|mdays
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|}
decl_stmt|;
name|int
name|year
init|=
name|tm
operator|->
name|tm_year
operator|-
literal|70
decl_stmt|;
name|int
name|month
init|=
name|tm
operator|->
name|tm_mon
decl_stmt|;
name|int
name|day
init|=
name|tm
operator|->
name|tm_mday
decl_stmt|;
if|if
condition|(
name|year
operator|<
literal|0
operator|||
name|year
operator|>
literal|129
condition|)
comment|/* algo only works for 1970-2099 */
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|month
operator|<
literal|0
operator|||
name|month
operator|>
literal|11
condition|)
comment|/* array bounds */
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|month
operator|<
literal|2
operator|||
operator|(
name|year
operator|+
literal|2
operator|)
operator|%
literal|4
condition|)
name|day
operator|--
expr_stmt|;
return|return
operator|(
name|year
operator|*
literal|365
operator|+
operator|(
name|year
operator|+
literal|1
operator|)
operator|/
literal|4
operator|+
name|mdays
index|[
name|month
index|]
operator|+
name|day
operator|)
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60UL
operator|+
name|tm
operator|->
name|tm_hour
operator|*
literal|60
operator|*
literal|60
operator|+
name|tm
operator|->
name|tm_min
operator|*
literal|60
operator|+
name|tm
operator|->
name|tm_sec
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|month_names
specifier|static
specifier|const
name|char
modifier|*
name|month_names
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|weekday_names
specifier|static
specifier|const
name|char
modifier|*
name|weekday_names
index|[]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|skipfws
specifier|static
name|char
modifier|*
name|skipfws
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/* Gr. strptime is crap for this; it doesn't have a way to require RFC2822    (i.e. English) day/month names, and it doesn't work correctly with %z. */
end_comment
begin_function
DECL|function|parse_date
name|void
name|parse_date
parameter_list|(
name|char
modifier|*
name|date
parameter_list|,
name|char
modifier|*
name|result
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|tz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|time_t
name|then
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip day-name */
name|p
operator|=
name|skipfws
argument_list|(
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|weekday_names
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|','
condition|)
block|{
name|p
operator|=
name|skipfws
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
goto|goto
name|day
goto|;
block|}
block|}
return|return;
block|}
comment|/* day */
name|day
label|:
name|tm
operator|.
name|tm_mday
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_mday
operator|<
literal|1
operator|||
name|tm
operator|.
name|tm_mday
operator|>
literal|31
condition|)
return|return;
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return;
name|p
operator|=
name|skipfws
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* month */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|month_names
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
operator|&&
name|isspace
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|tm
operator|.
name|tm_mon
operator|=
name|i
expr_stmt|;
name|p
operator|=
name|skipfws
argument_list|(
name|p
operator|+
name|strlen
argument_list|(
name|month_names
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|year
goto|;
block|}
block|}
return|return;
comment|/* Error -- bad month */
comment|/* year */
name|year
label|:
name|tm
operator|.
name|tm_year
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tm
operator|.
name|tm_year
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return;
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|>
literal|1900
condition|)
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|p
operator|=
name|skipfws
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* hour */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return;
name|tm
operator|.
name|tm_hour
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_hour
operator|>
literal|23
condition|)
return|return;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
return|return;
comment|/* Error -- bad time */
name|p
operator|++
expr_stmt|;
comment|/* minute */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return;
name|tm
operator|.
name|tm_min
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_min
operator|>
literal|59
condition|)
return|return;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
goto|goto
name|zone
goto|;
name|p
operator|++
expr_stmt|;
comment|/* second */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return;
name|tm
operator|.
name|tm_sec
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_sec
operator|>
literal|60
condition|)
return|return;
name|zone
label|:
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return;
name|p
operator|=
name|skipfws
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|offset
operator|=
operator|-
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|offset
operator|=
literal|60
expr_stmt|;
else|else
return|return;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
condition|)
return|return;
name|tz
operator|=
name|p
expr_stmt|;
name|i
operator|=
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|offset
operator|*=
operator|(
operator|(
name|i
operator|%
literal|100
operator|)
operator|+
operator|(
operator|(
name|i
operator|/
literal|100
operator|)
operator|*
literal|60
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|skipfws
argument_list|(
name|p
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'('
condition|)
comment|/* trailing comment like (EDT) is ok */
return|return;
name|then
operator|=
name|my_mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* mktime uses local timezone */
if|if
condition|(
name|then
operator|==
operator|-
literal|1
condition|)
return|return;
name|then
operator|-=
name|offset
expr_stmt|;
name|snprintf
argument_list|(
name|result
argument_list|,
name|maxlen
argument_list|,
literal|"%lu %5.5s"
argument_list|,
name|then
argument_list|,
name|tz
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|datestamp
name|void
name|datestamp
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|offset
operator|=
name|my_mktime
argument_list|(
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
operator|-
name|now
expr_stmt|;
name|offset
operator|/=
literal|60
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"%lu %+05d"
argument_list|,
name|now
argument_list|,
name|offset
operator|/
literal|60
operator|*
literal|100
operator|+
name|offset
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
