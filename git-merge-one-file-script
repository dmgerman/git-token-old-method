#!/bin/sh
#
# This is the git merge script, called with
#
#   $1 - original file SHA1 (or empty)
#   $2 - file in branch1 SHA1 (or empty)
#   $3 - file in branch2 SHA1 (or empty)
#   $4 - pathname in repository
#
#
# Handle some trivial cases.. The _really_ trivial cases have
# been handled already by read-tree, but that one doesn't
# do any merges that migth change the tree layout
#

# if the directory is newly added in a branch, it might not exist
# in the current tree
dir=$(dirname "$4")
mkdir -p "$dir"

case "${1:-.}${2:-.}${3:-.}" in
#
# deleted in both
#
"$1..")
	echo "ERROR: $4 is removed in both branches"
	echo "ERROR: This is a potential rename conflict"
	exit 1;;
#
# deleted in one and unchanged in the other
#
"$1.." | "$1.$1" | "$1$1.")
	rm -f -- "$4"
	echo "Removing $4"
	update-cache --remove -- "$4"
	exit 0
	;;

#
# added in one
#
".$2." | "..$3" )
	echo "Adding $4 with perm $6$7"
	mv $(unpack-file "$2$3") $4
	chmod "$6$7" $4
	update-cache --add -- $4
	exit 0
	;;
#
# Added in both (check for same permissions)
#
".$2$2")
	if [ "$6" != "$7" ]; then
		echo "ERROR: File $4 added in both branches, permissions conflict $6->$7"
		exit 1
	fi
	echo "Adding $4 with perm $6"
	mv $(unpack-file "$2") $4
	chmod "$6" $4
	update-cache --add -- $4
	exit 0;;
#
# Modified in both, but differently ;(
#
"$1$2$3")
	echo "Auto-merging $4"
	orig=$(unpack-file $1)
	src1=$(unpack-file $2)
	src2=$(unpack-file $3)
	merge "$src2" "$orig" "$src1"
	ret=$?
	if [ "$6" != "$7" ]; then
		echo "ERROR: Permissions $5->$6->$7 don't match merging $src2"
		if [ $ret -ne 0 ]; then
			echo "ERROR: Leaving conflict merge in $src2"
		fi
		exit 1
	fi
	chmod -- "$6" "$src2"
	if [ $ret -ne 0 ]; then
		echo "ERROR: Leaving conflict merge in $src2"
		exit 1
	fi
	cp -- "$src2" "$4" && chmod -- "$6" "$4" &&  update-cache --add -- "$4" && exit 0
	;;

*)
	echo "Not handling case $1 -> $2 -> $3"
	;;
esac
exit 1
