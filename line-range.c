begin_unit
begin_include
include|#
directive|include
file|"git-compat-util.h"
end_include
begin_include
include|#
directive|include
file|"line-range.h"
end_include
begin_comment
comment|/*  * Parse one item in the -L option  */
end_comment
begin_function
DECL|function|parse_loc
specifier|static
specifier|const
name|char
modifier|*
name|parse_loc
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|nth_line_fn_t
name|nth_line
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|long
name|lines
parameter_list|,
name|long
name|begin
parameter_list|,
name|long
modifier|*
name|ret
parameter_list|)
block|{
name|char
modifier|*
name|term
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|long
name|num
decl_stmt|;
name|int
name|reg_error
decl_stmt|;
name|regex_t
name|regexp
decl_stmt|;
name|regmatch_t
name|match
index|[
literal|1
index|]
decl_stmt|;
comment|/* Allow "-L<something>,+20" to mean starting at<something> 	 * for 20 lines, or "-L<something>,-5" for 5 lines ending at 	 *<something>. 	 */
if|if
condition|(
literal|1
operator|<
name|begin
operator|&&
operator|(
name|spec
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|spec
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
name|num
operator|=
name|strtol
argument_list|(
name|spec
operator|+
literal|1
argument_list|,
operator|&
name|term
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|!=
name|spec
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|term
return|;
if|if
condition|(
name|spec
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|num
operator|=
literal|0
operator|-
name|num
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|num
condition|)
operator|*
name|ret
operator|=
name|begin
operator|+
name|num
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num
condition|)
operator|*
name|ret
operator|=
name|begin
expr_stmt|;
else|else
operator|*
name|ret
operator|=
name|begin
operator|+
name|num
expr_stmt|;
return|return
name|term
return|;
block|}
return|return
name|spec
return|;
block|}
name|num
operator|=
name|strtol
argument_list|(
name|spec
argument_list|,
operator|&
name|term
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|!=
name|spec
condition|)
block|{
if|if
condition|(
name|ret
condition|)
operator|*
name|ret
operator|=
name|num
expr_stmt|;
return|return
name|term
return|;
block|}
if|if
condition|(
name|spec
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return
name|spec
return|;
comment|/* it could be a regexp of form /.../ */
for|for
control|(
name|term
operator|=
operator|(
name|char
operator|*
operator|)
name|spec
operator|+
literal|1
init|;
operator|*
name|term
operator|&&
operator|*
name|term
operator|!=
literal|'/'
condition|;
name|term
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|term
operator|==
literal|'\\'
condition|)
name|term
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|term
operator|!=
literal|'/'
condition|)
return|return
name|spec
return|;
comment|/* in the scan-only case we are not interested in the regex */
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|term
operator|+
literal|1
return|;
comment|/* try [spec+1 .. term-1] as regexp */
operator|*
name|term
operator|=
literal|0
expr_stmt|;
name|begin
operator|--
expr_stmt|;
comment|/* input is in human terms */
name|line
operator|=
name|nth_line
argument_list|(
name|data
argument_list|,
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg_error
operator|=
name|regcomp
argument_list|(
operator|&
name|regexp
argument_list|,
name|spec
operator|+
literal|1
argument_list|,
name|REG_NEWLINE
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|reg_error
operator|=
name|regexec
argument_list|(
operator|&
name|regexp
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
name|match
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
name|line
operator|+
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
decl_stmt|;
specifier|const
name|char
modifier|*
name|nline
decl_stmt|;
while|while
condition|(
name|begin
operator|++
operator|<
name|lines
condition|)
block|{
name|nline
operator|=
name|nth_line
argument_list|(
name|data
argument_list|,
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<=
name|cp
operator|&&
name|cp
operator|<
name|nline
condition|)
break|break;
name|line
operator|=
name|nline
expr_stmt|;
block|}
operator|*
name|ret
operator|=
name|begin
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|regexp
argument_list|)
expr_stmt|;
operator|*
name|term
operator|++
operator|=
literal|'/'
expr_stmt|;
return|return
name|term
return|;
block|}
else|else
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|regerror
argument_list|(
name|reg_error
argument_list|,
operator|&
name|regexp
argument_list|,
name|errbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"-L parameter '%s': %s"
argument_list|,
name|spec
operator|+
literal|1
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parse_range_arg
name|int
name|parse_range_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|nth_line_fn_t
name|nth_line_cb
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|long
name|lines
parameter_list|,
name|long
modifier|*
name|begin
parameter_list|,
name|long
modifier|*
name|end
parameter_list|)
block|{
name|arg
operator|=
name|parse_loc
argument_list|(
name|arg
argument_list|,
name|nth_line_cb
argument_list|,
name|cb_data
argument_list|,
name|lines
argument_list|,
literal|1
argument_list|,
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|','
condition|)
name|arg
operator|=
name|parse_loc
argument_list|(
name|arg
operator|+
literal|1
argument_list|,
name|nth_line_cb
argument_list|,
name|cb_data
argument_list|,
name|lines
argument_list|,
operator|*
name|begin
operator|+
literal|1
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|skip_range_arg
specifier|const
name|char
modifier|*
name|skip_range_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|arg
operator|=
name|parse_loc
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|','
condition|)
name|arg
operator|=
name|parse_loc
argument_list|(
name|arg
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function
end_unit
