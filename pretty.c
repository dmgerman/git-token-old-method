begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_struct
DECL|struct|cmt_fmt_map
specifier|static
struct|struct
name|cmt_fmt_map
block|{
DECL|member|n
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
DECL|member|cmp_len
name|size_t
name|cmp_len
decl_stmt|;
DECL|member|v
name|enum
name|cmit_fmt
name|v
decl_stmt|;
block|}
DECL|variable|cmt_fmts
name|cmt_fmts
index|[]
init|=
block|{
block|{
literal|"raw"
block|,
literal|1
block|,
name|CMIT_FMT_RAW
block|}
block|,
block|{
literal|"medium"
block|,
literal|1
block|,
name|CMIT_FMT_MEDIUM
block|}
block|,
block|{
literal|"short"
block|,
literal|1
block|,
name|CMIT_FMT_SHORT
block|}
block|,
block|{
literal|"email"
block|,
literal|1
block|,
name|CMIT_FMT_EMAIL
block|}
block|,
block|{
literal|"full"
block|,
literal|5
block|,
name|CMIT_FMT_FULL
block|}
block|,
block|{
literal|"fuller"
block|,
literal|5
block|,
name|CMIT_FMT_FULLER
block|}
block|,
block|{
literal|"oneline"
block|,
literal|1
block|,
name|CMIT_FMT_ONELINE
block|}
block|,
block|{
literal|"format:"
block|,
literal|7
block|,
name|CMIT_FMT_USERFORMAT
block|}
block|, }
struct|;
end_struct
begin_decl_stmt
DECL|variable|user_format
specifier|static
name|char
modifier|*
name|user_format
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_commit_format
name|enum
name|cmit_fmt
name|get_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
return|return
name|CMIT_FMT_DEFAULT
return|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'='
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"format:"
argument_list|)
condition|)
block|{
if|if
condition|(
name|user_format
condition|)
name|free
argument_list|(
name|user_format
argument_list|)
expr_stmt|;
name|user_format
operator|=
name|xstrdup
argument_list|(
name|arg
operator|+
literal|7
argument_list|)
expr_stmt|;
return|return
name|CMIT_FMT_USERFORMAT
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cmt_fmts
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
name|cmt_fmts
index|[
name|i
index|]
operator|.
name|n
argument_list|,
name|cmt_fmts
index|[
name|i
index|]
operator|.
name|cmp_len
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
name|cmt_fmts
index|[
name|i
index|]
operator|.
name|n
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
name|cmt_fmts
index|[
name|i
index|]
operator|.
name|v
return|;
block|}
name|die
argument_list|(
literal|"invalid --pretty format: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Generic support for pretty-printing the header  */
end_comment
begin_function
DECL|function|get_one_line
specifier|static
name|int
name|get_one_line
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|msg
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/* High bit set, or ISO-2022-INT */
end_comment
begin_function
DECL|function|non_ascii
name|int
name|non_ascii
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|ch
operator|=
operator|(
name|ch
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|||
operator|(
name|ch
operator|==
literal|0x1b
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|is_rfc2047_special
specifier|static
name|int
name|is_rfc2047_special
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'='
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'?'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'_'
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|add_rfc2047
specifier|static
name|void
name|add_rfc2047
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|line
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
goto|goto
name|needquote
goto|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|len
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|'='
operator|&&
name|line
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'?'
operator|)
condition|)
goto|goto
name|needquote
goto|;
block|}
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
name|needquote
label|:
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|len
operator|*
literal|3
operator|+
name|strlen
argument_list|(
name|encoding
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"=?%s?q?"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|last
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|ch
init|=
name|line
index|[
name|i
index|]
operator|&
literal|0xFF
decl_stmt|;
comment|/* 		 * We encode ' ' using '=20' even though rfc2047 		 * allows using '_' for readability.  Unfortunately, 		 * many programs do not understand this and just 		 * leave the underscore in place. 		 */
if|if
condition|(
name|is_rfc2047_special
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|' '
condition|)
block|{
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
operator|+
name|last
argument_list|,
name|i
operator|-
name|last
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"=%02X"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|last
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
operator|+
name|last
argument_list|,
name|len
operator|-
name|last
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"?="
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_user_info
specifier|static
name|void
name|add_user_info
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|enum
name|date_mode
name|dmode
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|unsigned
name|long
name|time
decl_stmt|;
name|int
name|tz
decl_stmt|;
specifier|const
name|char
modifier|*
name|filler
init|=
literal|"    "
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
condition|)
return|return;
name|date
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date
condition|)
return|return;
name|namelen
operator|=
operator|++
name|date
operator|-
name|line
expr_stmt|;
name|time
operator|=
name|strtoul
argument_list|(
name|date
argument_list|,
operator|&
name|date
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tz
operator|=
name|strtol
argument_list|(
name|date
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
name|char
modifier|*
name|name_tail
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'<'
argument_list|)
decl_stmt|;
name|int
name|display_name_length
decl_stmt|;
if|if
condition|(
operator|!
name|name_tail
condition|)
return|return;
while|while
condition|(
name|line
operator|<
name|name_tail
operator|&&
name|isspace
argument_list|(
name|name_tail
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|name_tail
operator|--
expr_stmt|;
name|display_name_length
operator|=
name|name_tail
operator|-
name|line
expr_stmt|;
name|filler
operator|=
literal|""
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"From: "
argument_list|)
expr_stmt|;
name|add_rfc2047
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|display_name_length
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|name_tail
argument_list|,
name|namelen
operator|-
name|display_name_length
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%s: %.*s%.*s\n"
argument_list|,
name|what
argument_list|,
operator|(
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|?
literal|4
else|:
literal|0
argument_list|,
name|filler
argument_list|,
name|namelen
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|CMIT_FMT_MEDIUM
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Date:   %s\n"
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|dmode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_EMAIL
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|DATE_RFC2822
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_FULLER
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%sDate: %s\n"
argument_list|,
name|what
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|dmode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* notin' */
break|break;
block|}
block|}
end_function
begin_function
DECL|function|is_empty_line
specifier|static
name|int
name|is_empty_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|len_p
parameter_list|)
block|{
name|int
name|len
init|=
operator|*
name|len_p
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
operator|*
name|len_p
operator|=
name|len
expr_stmt|;
return|return
operator|!
name|len
return|;
block|}
end_function
begin_function
DECL|function|add_merge_info
specifier|static
name|void
name|add_merge_info
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|abbrev
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
init|=
name|commit
operator|->
name|parents
decl_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|)
operator|||
operator|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|)
operator|||
operator|!
name|parent
operator|||
operator|!
name|parent
operator|->
name|next
condition|)
return|return;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"Merge:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parent
operator|->
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|dots
decl_stmt|;
if|if
condition|(
name|abbrev
condition|)
name|hex
operator|=
name|find_unique_abbrev
argument_list|(
name|p
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hex
condition|)
name|hex
operator|=
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|dots
operator|=
operator|(
name|abbrev
operator|&&
name|strlen
argument_list|(
name|hex
argument_list|)
operator|!=
literal|40
operator|)
condition|?
literal|"..."
else|:
literal|""
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|next
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|" %s%s"
argument_list|,
name|hex
argument_list|,
name|dots
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_header
specifier|static
name|char
modifier|*
name|get_header
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|int
name|key_len
init|=
name|strlen
argument_list|(
name|key
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
init|=
name|commit
operator|->
name|buffer
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|eol
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|line
operator|==
name|eol
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|eol
condition|)
block|{
name|eol
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|next
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|eol
operator|-
name|line
operator|>
name|key_len
operator|&&
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
operator|&&
name|line
index|[
name|key_len
index|]
operator|==
literal|' '
condition|)
block|{
return|return
name|xmemdupz
argument_list|(
name|line
operator|+
name|key_len
operator|+
literal|1
argument_list|,
name|eol
operator|-
name|line
operator|-
name|key_len
operator|-
literal|1
argument_list|)
return|;
block|}
name|line
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|replace_encoding_header
specifier|static
name|char
modifier|*
name|replace_encoding_header
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|struct
name|strbuf
name|tmp
decl_stmt|;
name|size_t
name|start
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
comment|/* guess if there is an encoding header before a \n\n */
while|while
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"encoding "
argument_list|,
name|strlen
argument_list|(
literal|"encoding "
argument_list|)
argument_list|)
condition|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|||
operator|*
operator|++
name|cp
operator|==
literal|'\n'
condition|)
return|return
name|buf
return|;
block|}
name|start
operator|=
name|cp
operator|-
name|buf
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|buf
return|;
comment|/* should not happen but be defensive */
name|len
operator|=
name|cp
operator|+
literal|1
operator|-
operator|(
name|buf
operator|+
name|start
operator|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_attach
argument_list|(
operator|&
name|tmp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_encoding_utf8
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
comment|/* we have re-coded to UTF-8; drop the header */
name|strbuf_remove
argument_list|(
operator|&
name|tmp
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just replaces XXXX in 'encoding XXXX\n' */
name|strbuf_splice
argument_list|(
operator|&
name|tmp
argument_list|,
name|start
operator|+
name|strlen
argument_list|(
literal|"encoding "
argument_list|)
argument_list|,
name|len
operator|-
name|strlen
argument_list|(
literal|"encoding \n"
argument_list|)
argument_list|,
name|encoding
argument_list|,
name|strlen
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|strbuf_detach
argument_list|(
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|logmsg_reencode
specifier|static
name|char
modifier|*
name|logmsg_reencode
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|output_encoding
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|utf8
init|=
literal|"utf-8"
decl_stmt|;
specifier|const
name|char
modifier|*
name|use_encoding
decl_stmt|;
name|char
modifier|*
name|encoding
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|output_encoding
condition|)
return|return
name|NULL
return|;
name|encoding
operator|=
name|get_header
argument_list|(
name|commit
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
name|use_encoding
operator|=
name|encoding
condition|?
name|encoding
else|:
name|utf8
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|use_encoding
argument_list|,
name|output_encoding
argument_list|)
condition|)
if|if
condition|(
name|encoding
condition|)
comment|/* we'll strip encoding header later */
name|out
operator|=
name|xstrdup
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/* nothing to do */
else|else
name|out
operator|=
name|reencode_string
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
name|output_encoding
argument_list|,
name|use_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|out
operator|=
name|replace_encoding_header
argument_list|(
name|out
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|format_person_part
specifier|static
name|size_t
name|format_person_part
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|char
name|part
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* currently all placeholders have same length */
specifier|const
name|int
name|placeholder_len
init|=
literal|2
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|tz
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|date
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
comment|/* advance 'end' to point to email start delimiter */
for|for
control|(
name|end
operator|=
literal|0
init|;
name|end
operator|<
name|len
operator|&&
name|msg
index|[
name|end
index|]
operator|!=
literal|'<'
condition|;
name|end
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
comment|/* 	 * When end points at the '<' that we found, it should have 	 * matching '>' later, which means 'end' must be strictly 	 * below len - 1. 	 */
if|if
condition|(
name|end
operator|>=
name|len
operator|-
literal|2
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|part
operator|==
literal|'n'
condition|)
block|{
comment|/* name */
while|while
condition|(
name|end
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|msg
index|[
name|end
operator|-
literal|1
index|]
argument_list|)
condition|)
name|end
operator|--
expr_stmt|;
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|msg
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
name|start
operator|=
operator|++
name|end
expr_stmt|;
comment|/* save email start position */
comment|/* advance 'end' to point to email end delimiter */
for|for
control|(
init|;
name|end
operator|<
name|len
operator|&&
name|msg
index|[
name|end
index|]
operator|!=
literal|'>'
condition|;
name|end
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|end
operator|>=
name|len
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|part
operator|==
literal|'e'
condition|)
block|{
comment|/* email */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
comment|/* advance 'start' to point to date start delimiter */
for|for
control|(
name|start
operator|=
name|end
operator|+
literal|1
init|;
name|start
operator|<
name|len
operator|&&
name|isspace
argument_list|(
name|msg
index|[
name|start
index|]
argument_list|)
condition|;
name|start
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|start
operator|>=
name|len
condition|)
goto|goto
name|skip
goto|;
name|date
operator|=
name|strtoul
argument_list|(
name|msg
operator|+
name|start
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|+
name|start
operator|==
name|ep
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|part
operator|==
literal|'t'
condition|)
block|{
comment|/* date, UNIX timestamp */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|start
argument_list|,
name|ep
operator|-
operator|(
name|msg
operator|+
name|start
operator|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
comment|/* parse tz */
for|for
control|(
name|start
operator|=
name|ep
operator|-
name|msg
operator|+
literal|1
init|;
name|start
operator|<
name|len
operator|&&
name|isspace
argument_list|(
name|msg
index|[
name|start
index|]
argument_list|)
condition|;
name|start
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|start
operator|+
literal|1
operator|<
name|len
condition|)
block|{
name|tz
operator|=
name|strtoul
argument_list|(
name|msg
operator|+
name|start
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
name|start
index|]
operator|==
literal|'-'
condition|)
name|tz
operator|=
operator|-
name|tz
expr_stmt|;
block|}
switch|switch
condition|(
name|part
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* date */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|DATE_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'D'
case|:
comment|/* date, RFC2822 style */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|DATE_RFC2822
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'r'
case|:
comment|/* date, relative */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|DATE_RELATIVE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'i'
case|:
comment|/* date, ISO 8601 */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|DATE_ISO8601
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
name|skip
label|:
comment|/* 	 * bogus commit, 'sb' cannot be updated, but we still need to 	 * compute a valid return value. 	 */
if|if
condition|(
name|part
operator|==
literal|'n'
operator|||
name|part
operator|==
literal|'e'
operator|||
name|part
operator|==
literal|'t'
operator|||
name|part
operator|==
literal|'d'
operator|||
name|part
operator|==
literal|'D'
operator|||
name|part
operator|==
literal|'r'
operator|||
name|part
operator|==
literal|'i'
condition|)
return|return
name|placeholder_len
return|;
return|return
literal|0
return|;
comment|/* unknown placeholder */
block|}
end_function
begin_struct
DECL|struct|chunk
struct|struct
name|chunk
block|{
DECL|member|off
name|size_t
name|off
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|format_commit_context
struct|struct
name|format_commit_context
block|{
DECL|member|commit
specifier|const
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
comment|/* These offsets are relative to the start of the commit message. */
DECL|member|commit_header_parsed
name|int
name|commit_header_parsed
decl_stmt|;
DECL|member|subject
name|struct
name|chunk
name|subject
decl_stmt|;
DECL|member|author
name|struct
name|chunk
name|author
decl_stmt|;
DECL|member|committer
name|struct
name|chunk
name|committer
decl_stmt|;
DECL|member|encoding
name|struct
name|chunk
name|encoding
decl_stmt|;
DECL|member|body_off
name|size_t
name|body_off
decl_stmt|;
comment|/* The following ones are relative to the result struct strbuf. */
DECL|member|abbrev_commit_hash
name|struct
name|chunk
name|abbrev_commit_hash
decl_stmt|;
DECL|member|abbrev_tree_hash
name|struct
name|chunk
name|abbrev_tree_hash
decl_stmt|;
DECL|member|abbrev_parent_hashes
name|struct
name|chunk
name|abbrev_parent_hashes
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|add_again
specifier|static
name|int
name|add_again
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|chunk
modifier|*
name|chunk
parameter_list|)
block|{
if|if
condition|(
name|chunk
operator|->
name|len
condition|)
block|{
name|strbuf_adddup
argument_list|(
name|sb
argument_list|,
name|chunk
operator|->
name|off
argument_list|,
name|chunk
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * We haven't seen this chunk before.  Our caller is surely 	 * going to add it the hard way now.  Remember the most likely 	 * start of the to-be-added chunk: the current end of the 	 * struct strbuf. 	 */
name|chunk
operator|->
name|off
operator|=
name|sb
operator|->
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_header
specifier|static
name|void
name|parse_commit_header
parameter_list|(
name|struct
name|format_commit_context
modifier|*
name|context
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|context
operator|->
name|commit
operator|->
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
enum|enum
block|{
name|HEADER
block|,
name|SUBJECT
block|,
name|BODY
block|}
name|state
enum|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|state
operator|=
name|HEADER
init|;
name|msg
index|[
name|i
index|]
operator|&&
name|state
operator|<
name|BODY
condition|;
name|i
operator|++
control|)
block|{
name|int
name|eol
decl_stmt|;
for|for
control|(
name|eol
operator|=
name|i
init|;
name|msg
index|[
name|eol
index|]
operator|&&
name|msg
index|[
name|eol
index|]
operator|!=
literal|'\n'
condition|;
name|eol
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|state
operator|==
name|SUBJECT
condition|)
block|{
name|context
operator|->
name|subject
operator|.
name|off
operator|=
name|i
expr_stmt|;
name|context
operator|->
name|subject
operator|.
name|len
operator|=
name|eol
operator|-
name|i
expr_stmt|;
name|i
operator|=
name|eol
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|eol
condition|)
block|{
name|state
operator|++
expr_stmt|;
comment|/* strip empty lines */
while|while
condition|(
name|msg
index|[
name|eol
index|]
operator|==
literal|'\n'
operator|&&
name|msg
index|[
name|eol
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|eol
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"author "
argument_list|)
condition|)
block|{
name|context
operator|->
name|author
operator|.
name|off
operator|=
name|i
operator|+
literal|7
expr_stmt|;
name|context
operator|->
name|author
operator|.
name|len
operator|=
name|eol
operator|-
name|i
operator|-
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"committer "
argument_list|)
condition|)
block|{
name|context
operator|->
name|committer
operator|.
name|off
operator|=
name|i
operator|+
literal|10
expr_stmt|;
name|context
operator|->
name|committer
operator|.
name|len
operator|=
name|eol
operator|-
name|i
operator|-
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"encoding "
argument_list|)
condition|)
block|{
name|context
operator|->
name|encoding
operator|.
name|off
operator|=
name|i
operator|+
literal|9
expr_stmt|;
name|context
operator|->
name|encoding
operator|.
name|len
operator|=
name|eol
operator|-
name|i
operator|-
literal|9
expr_stmt|;
block|}
name|i
operator|=
name|eol
expr_stmt|;
if|if
condition|(
operator|!
name|msg
index|[
name|i
index|]
condition|)
break|break;
block|}
name|context
operator|->
name|body_off
operator|=
name|i
expr_stmt|;
name|context
operator|->
name|commit_header_parsed
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_commit_item
specifier|static
name|size_t
name|format_commit_item
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|format_commit_context
modifier|*
name|c
init|=
name|context
decl_stmt|;
specifier|const
name|struct
name|commit
modifier|*
name|commit
init|=
name|c
operator|->
name|commit
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|commit
operator|->
name|buffer
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
comment|/* these are independent of the commit */
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"red"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"\033[31m"
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"green"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"\033[32m"
argument_list|)
expr_stmt|;
return|return
literal|6
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"blue"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"\033[34m"
argument_list|)
expr_stmt|;
return|return
literal|5
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"reset"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"\033[m"
argument_list|)
expr_stmt|;
return|return
literal|6
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
literal|'n'
case|:
comment|/* newline */
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* these depend on the commit */
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_object
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'H'
case|:
comment|/* commit hash */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'h'
case|:
comment|/* abbreviated commit hash */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_commit_hash
argument_list|)
condition|)
return|return
literal|1
return|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|abbrev_commit_hash
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_commit_hash
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'T'
case|:
comment|/* tree hash */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'t'
case|:
comment|/* abbreviated tree hash */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_tree_hash
argument_list|)
condition|)
return|return
literal|1
return|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|abbrev_tree_hash
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_tree_hash
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'P'
case|:
comment|/* parent hashes */
for|for
control|(
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|commit
operator|->
name|parents
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
literal|'p'
case|:
comment|/* abbreviated parent hashes */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_parent_hashes
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|commit
operator|->
name|parents
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|abbrev_parent_hashes
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_parent_hashes
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'m'
case|:
comment|/* left/right/bottom */
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|BOUNDARY
operator|)
condition|?
literal|'-'
else|:
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|SYMMETRIC_LEFT
operator|)
condition|?
literal|'<'
else|:
literal|'>'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* For the rest we have to parse the commit header. */
if|if
condition|(
operator|!
name|c
operator|->
name|commit_header_parsed
condition|)
name|parse_commit_header
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* subject */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|subject
operator|.
name|off
argument_list|,
name|c
operator|->
name|subject
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'a'
case|:
comment|/* author ... */
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|msg
operator|+
name|c
operator|->
name|author
operator|.
name|off
argument_list|,
name|c
operator|->
name|author
operator|.
name|len
argument_list|)
return|;
case|case
literal|'c'
case|:
comment|/* committer ... */
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|msg
operator|+
name|c
operator|->
name|committer
operator|.
name|off
argument_list|,
name|c
operator|->
name|committer
operator|.
name|len
argument_list|)
return|;
case|case
literal|'e'
case|:
comment|/* encoding */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|encoding
operator|.
name|off
argument_list|,
name|c
operator|->
name|encoding
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'b'
case|:
comment|/* body */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|body_off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* unknown placeholder */
block|}
end_function
begin_function
DECL|function|format_commit_message
name|void
name|format_commit_message
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|void
modifier|*
name|format
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|format_commit_context
name|context
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|commit
operator|=
name|commit
expr_stmt|;
name|strbuf_expand
argument_list|(
name|sb
argument_list|,
name|format
argument_list|,
name|format_commit_item
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_header
specifier|static
name|void
name|pp_header
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
name|int
name|abbrev
parameter_list|,
name|enum
name|date_mode
name|dmode
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|parents_shown
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
operator|*
name|msg_p
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
operator|*
name|msg_p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
return|return;
operator|*
name|msg_p
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
name|linelen
operator|==
literal|1
condition|)
comment|/* End of header */
return|return;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_RAW
condition|)
block|{
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
name|linelen
operator|!=
literal|48
condition|)
name|die
argument_list|(
literal|"bad parent line in commit"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|parents_shown
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
decl_stmt|;
name|int
name|num
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|commit
operator|->
name|parents
operator|,
name|num
operator|=
literal|0
init|;
name|parent
condition|;
name|parent
operator|=
name|parent
operator|->
name|next
operator|,
name|num
operator|++
control|)
empty_stmt|;
comment|/* with enough slop */
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|num
operator|*
literal|50
operator|+
literal|20
argument_list|)
expr_stmt|;
name|add_merge_info
argument_list|(
name|fmt
argument_list|,
name|sb
argument_list|,
name|commit
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
name|parents_shown
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * MEDIUM == DEFAULT shows only author with dates. 		 * FULL shows both authors but not dates. 		 * FULLER shows both authors and dates. 		 */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"author "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|80
argument_list|)
expr_stmt|;
name|add_user_info
argument_list|(
literal|"Author"
argument_list|,
name|fmt
argument_list|,
name|sb
argument_list|,
name|line
operator|+
literal|7
argument_list|,
name|dmode
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"committer "
argument_list|,
literal|10
argument_list|)
operator|&&
operator|(
name|fmt
operator|==
name|CMIT_FMT_FULL
operator|||
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|)
block|{
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|80
argument_list|)
expr_stmt|;
name|add_user_info
argument_list|(
literal|"Commit"
argument_list|,
name|fmt
argument_list|,
name|sb
argument_list|,
name|line
operator|+
literal|10
argument_list|,
name|dmode
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|pp_title_line
specifier|static
name|void
name|pp_title_line
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|subject
parameter_list|,
specifier|const
name|char
modifier|*
name|after_subject
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|int
name|plain_non_ascii
parameter_list|)
block|{
name|struct
name|strbuf
name|title
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|title
argument_list|,
literal|80
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
operator|*
name|msg_p
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|line
argument_list|)
decl_stmt|;
operator|*
name|msg_p
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
operator|!
name|linelen
operator|||
name|is_empty_line
argument_list|(
name|line
argument_list|,
operator|&
name|linelen
argument_list|)
condition|)
break|break;
name|strbuf_grow
argument_list|(
operator|&
name|title
argument_list|,
name|linelen
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|title
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
name|strbuf_addch
argument_list|(
operator|&
name|title
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|title
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|strbuf_add
argument_list|(
operator|&
name|title
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
block|}
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|len
operator|+
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|subject
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|subject
argument_list|)
expr_stmt|;
name|add_rfc2047
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|buf
argument_list|,
name|title
operator|.
name|len
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addbuf
argument_list|(
name|sb
argument_list|,
operator|&
name|title
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|plain_non_ascii
condition|)
block|{
specifier|const
name|char
modifier|*
name|header_fmt
init|=
literal|"MIME-Version: 1.0\n"
literal|"Content-Type: text/plain; charset=%s\n"
literal|"Content-Transfer-Encoding: 8bit\n"
decl_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|header_fmt
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|after_subject
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|after_subject
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_remainder
specifier|static
name|void
name|pp_remainder
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
operator|*
name|msg_p
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|line
argument_list|)
decl_stmt|;
operator|*
name|msg_p
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
break|break;
if|if
condition|(
name|is_empty_line
argument_list|(
name|line
argument_list|,
operator|&
name|linelen
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
continue|continue;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_SHORT
condition|)
break|break;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
name|indent
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
condition|)
block|{
name|memset
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|sb
operator|->
name|len
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|+
name|indent
argument_list|)
expr_stmt|;
block|}
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pretty_print_commit
name|void
name|pretty_print_commit
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|abbrev
parameter_list|,
specifier|const
name|char
modifier|*
name|subject
parameter_list|,
specifier|const
name|char
modifier|*
name|after_subject
parameter_list|,
name|enum
name|date_mode
name|dmode
parameter_list|,
name|int
name|plain_non_ascii
parameter_list|)
block|{
name|unsigned
name|long
name|beginning_of_body
decl_stmt|;
name|int
name|indent
init|=
literal|4
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|commit
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|reencoded
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_USERFORMAT
condition|)
block|{
name|format_commit_message
argument_list|(
name|commit
argument_list|,
name|user_format
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return;
block|}
name|encoding
operator|=
operator|(
name|git_log_output_encoding
condition|?
name|git_log_output_encoding
else|:
name|git_commit_encoding
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
condition|)
name|encoding
operator|=
literal|"utf-8"
expr_stmt|;
name|reencoded
operator|=
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|reencoded
condition|)
block|{
name|msg
operator|=
name|reencoded
expr_stmt|;
block|}
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|||
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
name|indent
operator|=
literal|0
expr_stmt|;
comment|/* After-subject is used to pass in Content-Type: multipart 	 * MIME header; in that case we do not have to do the 	 * plaintext content type even if the commit message has 	 * non 7-bit ASCII character.  Otherwise, check if we need 	 * to say this is not a 7-bit ASCII. 	 */
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
operator|!
name|after_subject
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|,
name|in_body
decl_stmt|;
for|for
control|(
name|in_body
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|msg
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|in_body
condition|)
block|{
comment|/* author could be non 7-bit ASCII but 				 * the log may be so; skip over the 				 * header part first. 				 */
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|&&
name|msg
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|in_body
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|plain_non_ascii
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|pp_header
argument_list|(
name|fmt
argument_list|,
name|abbrev
argument_list|,
name|dmode
argument_list|,
name|encoding
argument_list|,
name|commit
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
operator|&&
operator|!
name|subject
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Skip excess blank lines at the beginning of body, if any... */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|msg
argument_list|)
decl_stmt|;
name|int
name|ll
init|=
name|linelen
decl_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
break|break;
if|if
condition|(
operator|!
name|is_empty_line
argument_list|(
name|msg
argument_list|,
operator|&
name|ll
argument_list|)
condition|)
break|break;
name|msg
operator|+=
name|linelen
expr_stmt|;
block|}
comment|/* These formats treat the title line specially. */
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|||
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
name|pp_title_line
argument_list|(
name|fmt
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|,
name|subject
argument_list|,
name|after_subject
argument_list|,
name|encoding
argument_list|,
name|plain_non_ascii
argument_list|)
expr_stmt|;
name|beginning_of_body
operator|=
name|sb
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|pp_remainder
argument_list|(
name|fmt
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|strbuf_rtrim
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Make sure there is an EOLN for the non-oneline case */
if|if
condition|(
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* 	 * The caller may append additional body text in e-mail 	 * format.  Make sure we did not strip the blank line 	 * between the header and the body. 	 */
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
name|sb
operator|->
name|len
operator|<=
name|beginning_of_body
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reencoded
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
