begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"mailmap.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"reflog-walk.h"
end_include
begin_include
include|#
directive|include
file|"gpg-interface.h"
end_include
begin_decl_stmt
DECL|variable|user_format
specifier|static
name|char
modifier|*
name|user_format
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|cmt_fmt_map
specifier|static
struct|struct
name|cmt_fmt_map
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|format
name|enum
name|cmit_fmt
name|format
decl_stmt|;
DECL|member|is_tformat
name|int
name|is_tformat
decl_stmt|;
DECL|member|expand_tabs_in_log
name|int
name|expand_tabs_in_log
decl_stmt|;
DECL|member|is_alias
name|int
name|is_alias
decl_stmt|;
DECL|member|user_format
specifier|const
name|char
modifier|*
name|user_format
decl_stmt|;
block|}
DECL|variable|commit_formats
modifier|*
name|commit_formats
struct|;
end_struct
begin_decl_stmt
DECL|variable|builtin_formats_len
specifier|static
name|size_t
name|builtin_formats_len
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_formats_len
specifier|static
name|size_t
name|commit_formats_len
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_formats_alloc
specifier|static
name|size_t
name|commit_formats_alloc
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|struct
name|cmt_fmt_map
modifier|*
name|find_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|sought
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|commit_format_is_empty
name|int
name|commit_format_is_empty
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|)
block|{
return|return
name|fmt
operator|==
name|CMIT_FMT_USERFORMAT
operator|&&
operator|!
operator|*
name|user_format
return|;
block|}
end_function
begin_function
DECL|function|save_user_format
specifier|static
name|void
name|save_user_format
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|is_tformat
parameter_list|)
block|{
name|free
argument_list|(
name|user_format
argument_list|)
expr_stmt|;
name|user_format
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tformat
condition|)
name|rev
operator|->
name|use_terminator
operator|=
literal|1
expr_stmt|;
name|rev
operator|->
name|commit_format
operator|=
name|CMIT_FMT_USERFORMAT
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_pretty_formats_config
specifier|static
name|int
name|git_pretty_formats_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
modifier|*
name|commit_format
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|var
argument_list|,
literal|"pretty."
argument_list|,
operator|&
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|builtin_formats_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|builtin_formats_len
init|;
name|i
operator|<
name|commit_formats_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|commit_format
operator|=
operator|&
name|commit_formats
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|commit_format
condition|)
block|{
name|ALLOC_GROW
argument_list|(
name|commit_formats
argument_list|,
name|commit_formats_len
operator|+
literal|1
argument_list|,
name|commit_formats_alloc
argument_list|)
expr_stmt|;
name|commit_format
operator|=
operator|&
name|commit_formats
index|[
name|commit_formats_len
index|]
expr_stmt|;
name|memset
argument_list|(
name|commit_format
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit_format
argument_list|)
argument_list|)
expr_stmt|;
name|commit_formats_len
operator|++
expr_stmt|;
block|}
name|commit_format
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|commit_format
operator|->
name|format
operator|=
name|CMIT_FMT_USERFORMAT
expr_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|fmt
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|skip_prefix
argument_list|(
name|fmt
argument_list|,
literal|"format:"
argument_list|,
operator|&
name|fmt
argument_list|)
condition|)
name|commit_format
operator|->
name|is_tformat
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|fmt
argument_list|,
literal|"tformat:"
argument_list|,
operator|&
name|fmt
argument_list|)
operator|||
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'%'
argument_list|)
condition|)
name|commit_format
operator|->
name|is_tformat
operator|=
literal|1
expr_stmt|;
else|else
name|commit_format
operator|->
name|is_alias
operator|=
literal|1
expr_stmt|;
name|commit_format
operator|->
name|user_format
operator|=
name|fmt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setup_commit_formats
specifier|static
name|void
name|setup_commit_formats
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
name|builtin_formats
index|[]
init|=
block|{
block|{
literal|"raw"
block|,
name|CMIT_FMT_RAW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"medium"
block|,
name|CMIT_FMT_MEDIUM
block|,
literal|0
block|,
literal|8
block|}
block|,
block|{
literal|"short"
block|,
name|CMIT_FMT_SHORT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"email"
block|,
name|CMIT_FMT_EMAIL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"fuller"
block|,
name|CMIT_FMT_FULLER
block|,
literal|0
block|,
literal|8
block|}
block|,
block|{
literal|"full"
block|,
name|CMIT_FMT_FULL
block|,
literal|0
block|,
literal|8
block|}
block|,
block|{
literal|"oneline"
block|,
name|CMIT_FMT_ONELINE
block|,
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
name|commit_formats_len
operator|=
name|ARRAY_SIZE
argument_list|(
name|builtin_formats
argument_list|)
expr_stmt|;
name|builtin_formats_len
operator|=
name|commit_formats_len
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|commit_formats
argument_list|,
name|commit_formats_len
argument_list|,
name|commit_formats_alloc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|commit_formats
argument_list|,
name|builtin_formats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|builtin_formats
argument_list|)
operator|*
name|ARRAY_SIZE
argument_list|(
name|builtin_formats
argument_list|)
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_pretty_formats_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_commit_format_recursive
specifier|static
name|struct
name|cmt_fmt_map
modifier|*
name|find_commit_format_recursive
parameter_list|(
specifier|const
name|char
modifier|*
name|sought
parameter_list|,
specifier|const
name|char
modifier|*
name|original
parameter_list|,
name|int
name|num_redirections
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
modifier|*
name|found
init|=
name|NULL
decl_stmt|;
name|size_t
name|found_match_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_redirections
operator|>=
name|commit_formats_len
condition|)
name|die
argument_list|(
literal|"invalid --pretty format: "
literal|"'%s' references an alias which points to itself"
argument_list|,
name|original
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_formats_len
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|match_len
decl_stmt|;
if|if
condition|(
operator|!
name|starts_with
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|sought
argument_list|)
condition|)
continue|continue;
name|match_len
operator|=
name|strlen
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
operator|||
name|found_match_len
operator|>
name|match_len
condition|)
block|{
name|found
operator|=
operator|&
name|commit_formats
index|[
name|i
index|]
expr_stmt|;
name|found_match_len
operator|=
name|match_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|&&
name|found
operator|->
name|is_alias
condition|)
block|{
name|found
operator|=
name|find_commit_format_recursive
argument_list|(
name|found
operator|->
name|user_format
argument_list|,
name|original
argument_list|,
name|num_redirections
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function
begin_function
DECL|function|find_commit_format
specifier|static
name|struct
name|cmt_fmt_map
modifier|*
name|find_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|sought
parameter_list|)
block|{
if|if
condition|(
operator|!
name|commit_formats
condition|)
name|setup_commit_formats
argument_list|()
expr_stmt|;
return|return
name|find_commit_format_recursive
argument_list|(
name|sought
argument_list|,
name|sought
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_commit_format
name|void
name|get_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
modifier|*
name|commit_format
decl_stmt|;
name|rev
operator|->
name|use_terminator
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|rev
operator|->
name|commit_format
operator|=
name|CMIT_FMT_DEFAULT
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_prefix
argument_list|(
name|arg
argument_list|,
literal|"format:"
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
name|save_user_format
argument_list|(
name|rev
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|*
name|arg
operator|||
name|skip_prefix
argument_list|(
name|arg
argument_list|,
literal|"tformat:"
argument_list|,
operator|&
name|arg
argument_list|)
operator|||
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|save_user_format
argument_list|(
name|rev
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|commit_format
operator|=
name|find_commit_format
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit_format
condition|)
name|die
argument_list|(
literal|"invalid --pretty format: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rev
operator|->
name|commit_format
operator|=
name|commit_format
operator|->
name|format
expr_stmt|;
name|rev
operator|->
name|use_terminator
operator|=
name|commit_format
operator|->
name|is_tformat
expr_stmt|;
name|rev
operator|->
name|expand_tabs_in_log_default
operator|=
name|commit_format
operator|->
name|expand_tabs_in_log
expr_stmt|;
if|if
condition|(
name|commit_format
operator|->
name|format
operator|==
name|CMIT_FMT_USERFORMAT
condition|)
block|{
name|save_user_format
argument_list|(
name|rev
argument_list|,
name|commit_format
operator|->
name|user_format
argument_list|,
name|commit_format
operator|->
name|is_tformat
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Generic support for pretty-printing the header  */
end_comment
begin_function
DECL|function|get_one_line
specifier|static
name|int
name|get_one_line
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|msg
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/* High bit set, or ISO-2022-INT */
end_comment
begin_function
DECL|function|non_ascii
specifier|static
name|int
name|non_ascii
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|!
name|isascii
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'\033'
return|;
block|}
end_function
begin_function
DECL|function|has_non_ascii
name|int
name|has_non_ascii
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_rfc822_special
specifier|static
name|int
name|is_rfc822_special
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|':'
case|:
case|case
literal|';'
case|:
case|case
literal|'@'
case|:
case|case
literal|','
case|:
case|case
literal|'.'
case|:
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|needs_rfc822_quoting
specifier|static
name|int
name|needs_rfc822_quoting
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_rfc822_special
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|last_line_length
specifier|static
name|int
name|last_line_length
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* How many bytes are already used on the last line? */
for|for
control|(
name|i
operator|=
name|sb
operator|->
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|sb
operator|->
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
return|return
name|sb
operator|->
name|len
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
end_function
begin_function
DECL|function|add_rfc822_quoted
specifier|static
name|void
name|add_rfc822_quoted
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* just a guess, we may have to also backslash-quote */
name|strbuf_grow
argument_list|(
name|out
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|s
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
comment|/* fall through */
default|default:
name|strbuf_addch
argument_list|(
name|out
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function
begin_enum
DECL|enum|rfc2047_type
enum|enum
name|rfc2047_type
block|{
DECL|enumerator|RFC2047_SUBJECT
name|RFC2047_SUBJECT
block|,
DECL|enumerator|RFC2047_ADDRESS
name|RFC2047_ADDRESS
block|}
enum|;
end_enum
begin_function
DECL|function|is_rfc2047_special
specifier|static
name|int
name|is_rfc2047_special
parameter_list|(
name|char
name|ch
parameter_list|,
name|enum
name|rfc2047_type
name|type
parameter_list|)
block|{
comment|/* 	 * rfc2047, section 4.2: 	 * 	 *    8-bit values which correspond to printable ASCII characters other 	 *    than "=", "?", and "_" (underscore), MAY be represented as those 	 *    characters.  (But see section 5 for restrictions.)  In 	 *    particular, SPACE and TAB MUST NOT be represented as themselves 	 *    within encoded words. 	 */
comment|/* 	 * rule out non-ASCII characters and non-printable characters (the 	 * non-ASCII check should be redundant as isprint() is not localized 	 * and only knows about ASCII, but be defensive about that) 	 */
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* 	 * rule out special printable characters (' ' should be the only 	 * whitespace character considered printable, but be defensive and use 	 * isspace()) 	 */
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'='
operator|||
name|ch
operator|==
literal|'?'
operator|||
name|ch
operator|==
literal|'_'
condition|)
return|return
literal|1
return|;
comment|/* 	 * rfc2047, section 5.3: 	 * 	 *    As a replacement for a 'word' entity within a 'phrase', for example, 	 *    one that precedes an address in a From, To, or Cc header.  The ABNF 	 *    definition for 'phrase' from RFC 822 thus becomes: 	 * 	 *    phrase = 1*( encoded-word / word ) 	 * 	 *    In this case the set of characters that may be used in a "Q"-encoded 	 *    'encoded-word' is restricted to:<upper and lower case ASCII 	 *    letters, decimal digits, "!", "*", "+", "-", "/", "=", and "_" 	 *    (underscore, ASCII 95.)>.  An 'encoded-word' that appears within a 	 *    'phrase' MUST be separated from any adjacent 'word', 'text' or 	 *    'special' by 'linear-white-space'. 	 */
if|if
condition|(
name|type
operator|!=
name|RFC2047_ADDRESS
condition|)
return|return
literal|0
return|;
comment|/* '=' and '_' are special cases and have been checked above */
return|return
operator|!
operator|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'!'
operator|||
name|ch
operator|==
literal|'*'
operator|||
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'/'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|needs_rfc2047_encoding
specifier|static
name|int
name|needs_rfc2047_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|rfc2047_type
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|line
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'\n'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|len
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|'='
operator|&&
name|line
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'?'
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|add_rfc2047
specifier|static
name|void
name|add_rfc2047
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|enum
name|rfc2047_type
name|type
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|max_encoded_length
init|=
literal|76
decl_stmt|;
comment|/* per rfc2047 */
name|int
name|i
decl_stmt|;
name|int
name|line_len
init|=
name|last_line_length
argument_list|(
name|sb
argument_list|)
decl_stmt|;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|len
operator|*
literal|3
operator|+
name|strlen
argument_list|(
name|encoding
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"=?%s?q?"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|line_len
operator|+=
name|strlen
argument_list|(
name|encoding
argument_list|)
operator|+
literal|5
expr_stmt|;
comment|/* 5 for =??q? */
while|while
condition|(
name|len
condition|)
block|{
comment|/* 		 * RFC 2047, section 5 (3): 		 * 		 * Each 'encoded-word' MUST represent an integral number of 		 * characters.  A multi-octet character may not be split across 		 * adjacent 'encoded- word's. 		 */
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|line
decl_stmt|;
name|int
name|chrlen
init|=
name|mbs_chrlen
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|len
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
name|int
name|is_special
init|=
operator|(
name|chrlen
operator|>
literal|1
operator|)
operator|||
name|is_rfc2047_special
argument_list|(
operator|*
name|p
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* "=%02X" * chrlen, or the byte itself */
specifier|const
name|char
modifier|*
name|encoded_fmt
init|=
name|is_special
condition|?
literal|"=%02X"
else|:
literal|"%c"
decl_stmt|;
name|int
name|encoded_len
init|=
name|is_special
condition|?
literal|3
operator|*
name|chrlen
else|:
literal|1
decl_stmt|;
comment|/* 		 * According to RFC 2047, we could encode the special character 		 * ' ' (space) with '_' (underscore) for readability. But many 		 * programs do not understand this and just leave the 		 * underscore in place. Thus, we do nothing special here, which 		 * causes ' ' to be encoded as '=20', avoiding this problem. 		 */
if|if
condition|(
name|line_len
operator|+
name|encoded_len
operator|+
literal|2
operator|>
name|max_encoded_length
condition|)
block|{
comment|/* It won't fit with trailing "?=" --- break the line */
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"?=\n =?%s?q?"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|line_len
operator|=
name|strlen
argument_list|(
name|encoding
argument_list|)
operator|+
literal|5
operator|+
literal|1
expr_stmt|;
comment|/* =??q? plus SP */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chrlen
condition|;
name|i
operator|++
control|)
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|encoded_fmt
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|line_len
operator|+=
name|encoded_len
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"?="
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_ident_date
specifier|const
name|char
modifier|*
name|show_ident_date
parameter_list|(
specifier|const
name|struct
name|ident_split
modifier|*
name|ident
parameter_list|,
specifier|const
name|struct
name|date_mode
modifier|*
name|mode
parameter_list|)
block|{
name|unsigned
name|long
name|date
init|=
literal|0
decl_stmt|;
name|long
name|tz
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ident
operator|->
name|date_begin
operator|&&
name|ident
operator|->
name|date_end
condition|)
name|date
operator|=
name|strtoul
argument_list|(
name|ident
operator|->
name|date_begin
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|date_overflows
argument_list|(
name|date
argument_list|)
condition|)
name|date
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ident
operator|->
name|tz_begin
operator|&&
name|ident
operator|->
name|tz_end
condition|)
name|tz
operator|=
name|strtol
argument_list|(
name|ident
operator|->
name|tz_begin
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tz
operator|>=
name|INT_MAX
operator|||
name|tz
operator|<=
name|INT_MIN
condition|)
name|tz
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|pp_user_info
name|void
name|pp_user_info
parameter_list|(
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|struct
name|ident_split
name|ident
decl_stmt|;
name|char
modifier|*
name|line_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|mailbuf
decl_stmt|,
modifier|*
name|namebuf
decl_stmt|;
name|size_t
name|namelen
decl_stmt|,
name|maillen
decl_stmt|;
name|int
name|max_length
init|=
literal|78
decl_stmt|;
comment|/* per rfc2822 */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
condition|)
return|return;
name|line_end
operator|=
name|strchrnul
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|ident
argument_list|,
name|line
argument_list|,
name|line_end
operator|-
name|line
argument_list|)
condition|)
return|return;
name|mailbuf
operator|=
name|ident
operator|.
name|mail_begin
expr_stmt|;
name|maillen
operator|=
name|ident
operator|.
name|mail_end
operator|-
name|ident
operator|.
name|mail_begin
expr_stmt|;
name|namebuf
operator|=
name|ident
operator|.
name|name_begin
expr_stmt|;
name|namelen
operator|=
name|ident
operator|.
name|name_end
operator|-
name|ident
operator|.
name|name_begin
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|mailmap
condition|)
name|map_user
argument_list|(
name|pp
operator|->
name|mailmap
argument_list|,
operator|&
name|mailbuf
argument_list|,
operator|&
name|maillen
argument_list|,
operator|&
name|namebuf
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|from_ident
operator|&&
name|ident_cmp
argument_list|(
name|pp
operator|->
name|from_ident
argument_list|,
operator|&
name|ident
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"From: "
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|namebuf
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|mailbuf
argument_list|,
name|maillen
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|">\n"
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|pp
operator|->
name|in_body_headers
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|mailbuf
operator|=
name|pp
operator|->
name|from_ident
operator|->
name|mail_begin
expr_stmt|;
name|maillen
operator|=
name|pp
operator|->
name|from_ident
operator|->
name|mail_end
operator|-
name|mailbuf
expr_stmt|;
name|namebuf
operator|=
name|pp
operator|->
name|from_ident
operator|->
name|name_begin
expr_stmt|;
name|namelen
operator|=
name|pp
operator|->
name|from_ident
operator|->
name|name_end
operator|-
name|namebuf
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"From: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_rfc2047_encoding
argument_list|(
name|namebuf
argument_list|,
name|namelen
argument_list|,
name|RFC2047_ADDRESS
argument_list|)
condition|)
block|{
name|add_rfc2047
argument_list|(
name|sb
argument_list|,
name|namebuf
argument_list|,
name|namelen
argument_list|,
name|encoding
argument_list|,
name|RFC2047_ADDRESS
argument_list|)
expr_stmt|;
name|max_length
operator|=
literal|76
expr_stmt|;
comment|/* per rfc2047 */
block|}
elseif|else
if|if
condition|(
name|needs_rfc822_quoting
argument_list|(
name|namebuf
argument_list|,
name|namelen
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|quoted
init|=
name|STRBUF_INIT
decl_stmt|;
name|add_rfc822_quoted
argument_list|(
operator|&
name|quoted
argument_list|,
name|namebuf
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|strbuf_add_wrapped_bytes
argument_list|(
name|sb
argument_list|,
name|quoted
operator|.
name|buf
argument_list|,
name|quoted
operator|.
name|len
argument_list|,
operator|-
literal|6
argument_list|,
literal|1
argument_list|,
name|max_length
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|quoted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_add_wrapped_bytes
argument_list|(
name|sb
argument_list|,
name|namebuf
argument_list|,
name|namelen
argument_list|,
operator|-
literal|6
argument_list|,
literal|1
argument_list|,
name|max_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_length
operator|<
name|last_line_length
argument_list|(
name|sb
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"<"
argument_list|)
operator|+
name|maillen
operator|+
name|strlen
argument_list|(
literal|">"
argument_list|)
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"<%.*s>\n"
argument_list|,
operator|(
name|int
operator|)
name|maillen
argument_list|,
name|mailbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%s: %.*s%.*s<%.*s>\n"
argument_list|,
name|what
argument_list|,
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|?
literal|4
else|:
literal|0
argument_list|,
literal|"    "
argument_list|,
operator|(
name|int
operator|)
name|namelen
argument_list|,
name|namebuf
argument_list|,
operator|(
name|int
operator|)
name|maillen
argument_list|,
name|mailbuf
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|pp
operator|->
name|fmt
condition|)
block|{
case|case
name|CMIT_FMT_MEDIUM
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Date:   %s\n"
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|ident
argument_list|,
operator|&
name|pp
operator|->
name|date_mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_EMAIL
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|ident
argument_list|,
name|DATE_MODE
argument_list|(
name|RFC2822
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_FULLER
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%sDate: %s\n"
argument_list|,
name|what
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|ident
argument_list|,
operator|&
name|pp
operator|->
name|date_mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* notin' */
break|break;
block|}
block|}
end_function
begin_function
DECL|function|is_empty_line
specifier|static
name|int
name|is_empty_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|len_p
parameter_list|)
block|{
name|int
name|len
init|=
operator|*
name|len_p
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
operator|*
name|len_p
operator|=
name|len
expr_stmt|;
return|return
operator|!
name|len
return|;
block|}
end_function
begin_function
DECL|function|skip_empty_lines
specifier|static
specifier|const
name|char
modifier|*
name|skip_empty_lines
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|msg
argument_list|)
decl_stmt|;
name|int
name|ll
init|=
name|linelen
decl_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
break|break;
if|if
condition|(
operator|!
name|is_empty_line
argument_list|(
name|msg
argument_list|,
operator|&
name|ll
argument_list|)
condition|)
break|break;
name|msg
operator|+=
name|linelen
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
end_function
begin_function
DECL|function|add_merge_info
specifier|static
name|void
name|add_merge_info
parameter_list|(
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
init|=
name|commit
operator|->
name|parents
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|)
operator|||
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|)
operator|||
operator|!
name|parent
operator|||
operator|!
name|parent
operator|->
name|next
condition|)
return|return;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"Merge:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parent
operator|->
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|abbrev
condition|)
name|hex
operator|=
name|find_unique_abbrev
argument_list|(
name|p
operator|->
name|object
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|pp
operator|->
name|abbrev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hex
condition|)
name|hex
operator|=
name|oid_to_hex
argument_list|(
operator|&
name|p
operator|->
name|object
operator|.
name|oid
argument_list|)
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|next
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|" %s"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_header
specifier|static
name|char
modifier|*
name|get_header
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|v
init|=
name|find_commit_header
argument_list|(
name|msg
argument_list|,
name|key
argument_list|,
operator|&
name|len
argument_list|)
decl_stmt|;
return|return
name|v
condition|?
name|xmemdupz
argument_list|(
name|v
argument_list|,
name|len
argument_list|)
else|:
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|replace_encoding_header
specifier|static
name|char
modifier|*
name|replace_encoding_header
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|struct
name|strbuf
name|tmp
init|=
name|STRBUF_INIT
decl_stmt|;
name|size_t
name|start
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
comment|/* guess if there is an encoding header before a \n\n */
while|while
condition|(
operator|!
name|starts_with
argument_list|(
name|cp
argument_list|,
literal|"encoding "
argument_list|)
condition|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|||
operator|*
operator|++
name|cp
operator|==
literal|'\n'
condition|)
return|return
name|buf
return|;
block|}
name|start
operator|=
name|cp
operator|-
name|buf
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|buf
return|;
comment|/* should not happen but be defensive */
name|len
operator|=
name|cp
operator|+
literal|1
operator|-
operator|(
name|buf
operator|+
name|start
operator|)
expr_stmt|;
name|strbuf_attach
argument_list|(
operator|&
name|tmp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_encoding_utf8
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
comment|/* we have re-coded to UTF-8; drop the header */
name|strbuf_remove
argument_list|(
operator|&
name|tmp
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just replaces XXXX in 'encoding XXXX\n' */
name|strbuf_splice
argument_list|(
operator|&
name|tmp
argument_list|,
name|start
operator|+
name|strlen
argument_list|(
literal|"encoding "
argument_list|)
argument_list|,
name|len
operator|-
name|strlen
argument_list|(
literal|"encoding \n"
argument_list|)
argument_list|,
name|encoding
argument_list|,
name|strlen
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|strbuf_detach
argument_list|(
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|logmsg_reencode
specifier|const
name|char
modifier|*
name|logmsg_reencode
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|char
modifier|*
modifier|*
name|commit_encoding
parameter_list|,
specifier|const
name|char
modifier|*
name|output_encoding
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|utf8
init|=
literal|"UTF-8"
decl_stmt|;
specifier|const
name|char
modifier|*
name|use_encoding
decl_stmt|;
name|char
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|get_commit_buffer
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|output_encoding
operator|||
operator|!
operator|*
name|output_encoding
condition|)
block|{
if|if
condition|(
name|commit_encoding
condition|)
operator|*
name|commit_encoding
operator|=
name|get_header
argument_list|(
name|msg
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
name|encoding
operator|=
name|get_header
argument_list|(
name|msg
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_encoding
condition|)
operator|*
name|commit_encoding
operator|=
name|encoding
expr_stmt|;
name|use_encoding
operator|=
name|encoding
condition|?
name|encoding
else|:
name|utf8
expr_stmt|;
if|if
condition|(
name|same_encoding
argument_list|(
name|use_encoding
argument_list|,
name|output_encoding
argument_list|)
condition|)
block|{
comment|/* 		 * No encoding work to be done. If we have no encoding header 		 * at all, then there's nothing to do, and we can return the 		 * message verbatim (whether newly allocated or not). 		 */
if|if
condition|(
operator|!
name|encoding
condition|)
return|return
name|msg
return|;
comment|/* 		 * Otherwise, we still want to munge the encoding header in the 		 * result, which will be done by modifying the buffer. If we 		 * are using a fresh copy, we can reuse it. But if we are using 		 * the cached copy from get_commit_buffer, we need to duplicate it 		 * to avoid munging the cached copy. 		 */
if|if
condition|(
name|msg
operator|==
name|get_cached_commit_buffer
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|)
condition|)
name|out
operator|=
name|xstrdup
argument_list|(
name|msg
argument_list|)
expr_stmt|;
else|else
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There's actual encoding work to do. Do the reencoding, which 		 * still leaves the header to be replaced in the next step. At 		 * this point, we are done with msg. If we allocated a fresh 		 * copy, we can free it. 		 */
name|out
operator|=
name|reencode_string
argument_list|(
name|msg
argument_list|,
name|output_encoding
argument_list|,
name|use_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|unuse_commit_buffer
argument_list|(
name|commit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This replacement actually consumes the buffer we hand it, so we do 	 * not have to worry about freeing the old "out" here. 	 */
if|if
condition|(
name|out
condition|)
name|out
operator|=
name|replace_encoding_header
argument_list|(
name|out
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit_encoding
condition|)
name|free
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
comment|/* 	 * If the re-encoding failed, out might be NULL here; in that 	 * case we just return the commit message verbatim. 	 */
return|return
name|out
condition|?
name|out
else|:
name|msg
return|;
block|}
end_function
begin_function
DECL|function|mailmap_name
specifier|static
name|int
name|mailmap_name
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|email
parameter_list|,
name|size_t
modifier|*
name|email_len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|name_len
parameter_list|)
block|{
specifier|static
name|struct
name|string_list
modifier|*
name|mail_map
decl_stmt|;
if|if
condition|(
operator|!
name|mail_map
condition|)
block|{
name|mail_map
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mail_map
argument_list|)
argument_list|)
expr_stmt|;
name|read_mailmap
argument_list|(
name|mail_map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|mail_map
operator|->
name|nr
operator|&&
name|map_user
argument_list|(
name|mail_map
argument_list|,
name|email
argument_list|,
name|email_len
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|format_person_part
specifier|static
name|size_t
name|format_person_part
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|char
name|part
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|date_mode
modifier|*
name|dmode
parameter_list|)
block|{
comment|/* currently all placeholders have same length */
specifier|const
name|int
name|placeholder_len
init|=
literal|2
decl_stmt|;
name|struct
name|ident_split
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|mail
decl_stmt|;
name|size_t
name|maillen
decl_stmt|,
name|namelen
decl_stmt|;
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|s
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|skip
goto|;
name|name
operator|=
name|s
operator|.
name|name_begin
expr_stmt|;
name|namelen
operator|=
name|s
operator|.
name|name_end
operator|-
name|s
operator|.
name|name_begin
expr_stmt|;
name|mail
operator|=
name|s
operator|.
name|mail_begin
expr_stmt|;
name|maillen
operator|=
name|s
operator|.
name|mail_end
operator|-
name|s
operator|.
name|mail_begin
expr_stmt|;
if|if
condition|(
name|part
operator|==
literal|'N'
operator|||
name|part
operator|==
literal|'E'
condition|)
comment|/* mailmap lookup */
name|mailmap_name
argument_list|(
operator|&
name|mail
argument_list|,
operator|&
name|maillen
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|==
literal|'n'
operator|||
name|part
operator|==
literal|'N'
condition|)
block|{
comment|/* name */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
if|if
condition|(
name|part
operator|==
literal|'e'
operator|||
name|part
operator|==
literal|'E'
condition|)
block|{
comment|/* email */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|mail
argument_list|,
name|maillen
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|date_begin
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|part
operator|==
literal|'t'
condition|)
block|{
comment|/* date, UNIX timestamp */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|s
operator|.
name|date_begin
argument_list|,
name|s
operator|.
name|date_end
operator|-
name|s
operator|.
name|date_begin
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
switch|switch
condition|(
name|part
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* date */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|s
argument_list|,
name|dmode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'D'
case|:
comment|/* date, RFC2822 style */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|s
argument_list|,
name|DATE_MODE
argument_list|(
name|RFC2822
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'r'
case|:
comment|/* date, relative */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|s
argument_list|,
name|DATE_MODE
argument_list|(
name|RELATIVE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'i'
case|:
comment|/* date, ISO 8601-like */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|s
argument_list|,
name|DATE_MODE
argument_list|(
name|ISO8601
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'I'
case|:
comment|/* date, ISO 8601 strict */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|s
argument_list|,
name|DATE_MODE
argument_list|(
name|ISO8601_STRICT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
name|skip
label|:
comment|/* 	 * reading from either a bogus commit, or a reflog entry with 	 * %gn, %ge, etc.; 'sb' cannot be updated, but we still need 	 * to compute a valid return value. 	 */
if|if
condition|(
name|part
operator|==
literal|'n'
operator|||
name|part
operator|==
literal|'e'
operator|||
name|part
operator|==
literal|'t'
operator|||
name|part
operator|==
literal|'d'
operator|||
name|part
operator|==
literal|'D'
operator|||
name|part
operator|==
literal|'r'
operator|||
name|part
operator|==
literal|'i'
condition|)
return|return
name|placeholder_len
return|;
return|return
literal|0
return|;
comment|/* unknown placeholder */
block|}
end_function
begin_struct
DECL|struct|chunk
struct|struct
name|chunk
block|{
DECL|member|off
name|size_t
name|off
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct
begin_enum
DECL|enum|flush_type
enum|enum
name|flush_type
block|{
DECL|enumerator|no_flush
name|no_flush
block|,
DECL|enumerator|flush_right
name|flush_right
block|,
DECL|enumerator|flush_left
name|flush_left
block|,
DECL|enumerator|flush_left_and_steal
name|flush_left_and_steal
block|,
DECL|enumerator|flush_both
name|flush_both
block|}
enum|;
end_enum
begin_enum
DECL|enum|trunc_type
enum|enum
name|trunc_type
block|{
DECL|enumerator|trunc_none
name|trunc_none
block|,
DECL|enumerator|trunc_left
name|trunc_left
block|,
DECL|enumerator|trunc_middle
name|trunc_middle
block|,
DECL|enumerator|trunc_right
name|trunc_right
block|}
enum|;
end_enum
begin_struct
DECL|struct|format_commit_context
struct|struct
name|format_commit_context
block|{
DECL|member|commit
specifier|const
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
DECL|member|pretty_ctx
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pretty_ctx
decl_stmt|;
DECL|member|commit_header_parsed
name|unsigned
name|commit_header_parsed
range|:
literal|1
decl_stmt|;
DECL|member|commit_message_parsed
name|unsigned
name|commit_message_parsed
range|:
literal|1
decl_stmt|;
DECL|member|signature_check
name|struct
name|signature_check
name|signature_check
decl_stmt|;
DECL|member|flush_type
name|enum
name|flush_type
name|flush_type
decl_stmt|;
DECL|member|truncate
name|enum
name|trunc_type
name|truncate
decl_stmt|;
DECL|member|message
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
DECL|member|commit_encoding
name|char
modifier|*
name|commit_encoding
decl_stmt|;
DECL|member|width
DECL|member|indent1
DECL|member|indent2
name|size_t
name|width
decl_stmt|,
name|indent1
decl_stmt|,
name|indent2
decl_stmt|;
DECL|member|auto_color
name|int
name|auto_color
decl_stmt|;
DECL|member|padding
name|int
name|padding
decl_stmt|;
comment|/* These offsets are relative to the start of the commit message. */
DECL|member|author
name|struct
name|chunk
name|author
decl_stmt|;
DECL|member|committer
name|struct
name|chunk
name|committer
decl_stmt|;
DECL|member|message_off
name|size_t
name|message_off
decl_stmt|;
DECL|member|subject_off
name|size_t
name|subject_off
decl_stmt|;
DECL|member|body_off
name|size_t
name|body_off
decl_stmt|;
comment|/* The following ones are relative to the result struct strbuf. */
DECL|member|abbrev_commit_hash
name|struct
name|chunk
name|abbrev_commit_hash
decl_stmt|;
DECL|member|abbrev_tree_hash
name|struct
name|chunk
name|abbrev_tree_hash
decl_stmt|;
DECL|member|abbrev_parent_hashes
name|struct
name|chunk
name|abbrev_parent_hashes
decl_stmt|;
DECL|member|wrap_start
name|size_t
name|wrap_start
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|add_again
specifier|static
name|int
name|add_again
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|chunk
modifier|*
name|chunk
parameter_list|)
block|{
if|if
condition|(
name|chunk
operator|->
name|len
condition|)
block|{
name|strbuf_adddup
argument_list|(
name|sb
argument_list|,
name|chunk
operator|->
name|off
argument_list|,
name|chunk
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * We haven't seen this chunk before.  Our caller is surely 	 * going to add it the hard way now.  Remember the most likely 	 * start of the to-be-added chunk: the current end of the 	 * struct strbuf. 	 */
name|chunk
operator|->
name|off
operator|=
name|sb
operator|->
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_header
specifier|static
name|void
name|parse_commit_header
parameter_list|(
name|struct
name|format_commit_context
modifier|*
name|context
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|context
operator|->
name|message
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|msg
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|eol
decl_stmt|;
for|for
control|(
name|eol
operator|=
name|i
init|;
name|msg
index|[
name|eol
index|]
operator|&&
name|msg
index|[
name|eol
index|]
operator|!=
literal|'\n'
condition|;
name|eol
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|i
operator|==
name|eol
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"author "
argument_list|,
operator|&
name|name
argument_list|)
condition|)
block|{
name|context
operator|->
name|author
operator|.
name|off
operator|=
name|name
operator|-
name|msg
expr_stmt|;
name|context
operator|->
name|author
operator|.
name|len
operator|=
name|msg
operator|+
name|eol
operator|-
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"committer "
argument_list|,
operator|&
name|name
argument_list|)
condition|)
block|{
name|context
operator|->
name|committer
operator|.
name|off
operator|=
name|name
operator|-
name|msg
expr_stmt|;
name|context
operator|->
name|committer
operator|.
name|len
operator|=
name|msg
operator|+
name|eol
operator|-
name|name
expr_stmt|;
block|}
name|i
operator|=
name|eol
expr_stmt|;
block|}
name|context
operator|->
name|message_off
operator|=
name|i
expr_stmt|;
name|context
operator|->
name|commit_header_parsed
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|istitlechar
specifier|static
name|int
name|istitlechar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'_'
return|;
block|}
end_function
begin_function
DECL|function|format_sanitized_subject
specifier|static
name|void
name|format_sanitized_subject
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|size_t
name|trimlen
decl_stmt|;
name|size_t
name|start_len
init|=
name|sb
operator|->
name|len
decl_stmt|;
name|int
name|space
init|=
literal|2
decl_stmt|;
for|for
control|(
init|;
operator|*
name|msg
operator|&&
operator|*
name|msg
operator|!=
literal|'\n'
condition|;
name|msg
operator|++
control|)
block|{
if|if
condition|(
name|istitlechar
argument_list|(
operator|*
name|msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|space
operator|==
literal|1
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
literal|'.'
condition|)
while|while
condition|(
operator|*
operator|(
name|msg
operator|+
literal|1
operator|)
operator|==
literal|'.'
condition|)
name|msg
operator|++
expr_stmt|;
block|}
else|else
name|space
operator||=
literal|1
expr_stmt|;
block|}
comment|/* trim any trailing '.' or '-' characters */
name|trimlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sb
operator|->
name|len
operator|-
name|trimlen
operator|>
name|start_len
operator|&&
operator|(
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
operator|-
name|trimlen
index|]
operator|==
literal|'.'
operator|||
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
operator|-
name|trimlen
index|]
operator|==
literal|'-'
operator|)
condition|)
name|trimlen
operator|++
expr_stmt|;
name|strbuf_remove
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
name|trimlen
argument_list|,
name|trimlen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_subject
specifier|const
name|char
modifier|*
name|format_subject
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|line_separator
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
name|msg
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|msg
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
operator|!
name|linelen
operator|||
name|is_empty_line
argument_list|(
name|line
argument_list|,
operator|&
name|linelen
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|sb
condition|)
continue|continue;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|line_separator
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_message
specifier|static
name|void
name|parse_commit_message
parameter_list|(
name|struct
name|format_commit_context
modifier|*
name|c
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|c
operator|->
name|message
operator|+
name|c
operator|->
name|message_off
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|c
operator|->
name|message
decl_stmt|;
name|msg
operator|=
name|skip_empty_lines
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|c
operator|->
name|subject_off
operator|=
name|msg
operator|-
name|start
expr_stmt|;
name|msg
operator|=
name|format_subject
argument_list|(
name|NULL
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msg
operator|=
name|skip_empty_lines
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|c
operator|->
name|body_off
operator|=
name|msg
operator|-
name|start
expr_stmt|;
name|c
operator|->
name|commit_message_parsed
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|strbuf_wrap
specifier|static
name|void
name|strbuf_wrap
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|size_t
name|width
parameter_list|,
name|size_t
name|indent1
parameter_list|,
name|size_t
name|indent2
parameter_list|)
block|{
name|struct
name|strbuf
name|tmp
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|pos
condition|)
name|strbuf_add
argument_list|(
operator|&
name|tmp
argument_list|,
name|sb
operator|->
name|buf
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|strbuf_add_wrapped_text
argument_list|(
operator|&
name|tmp
argument_list|,
name|sb
operator|->
name|buf
operator|+
name|pos
argument_list|,
operator|(
name|int
operator|)
name|indent1
argument_list|,
operator|(
name|int
operator|)
name|indent2
argument_list|,
operator|(
name|int
operator|)
name|width
argument_list|)
expr_stmt|;
name|strbuf_swap
argument_list|(
operator|&
name|tmp
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rewrap_message_tail
specifier|static
name|void
name|rewrap_message_tail
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|format_commit_context
modifier|*
name|c
parameter_list|,
name|size_t
name|new_width
parameter_list|,
name|size_t
name|new_indent1
parameter_list|,
name|size_t
name|new_indent2
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|width
operator|==
name|new_width
operator|&&
name|c
operator|->
name|indent1
operator|==
name|new_indent1
operator|&&
name|c
operator|->
name|indent2
operator|==
name|new_indent2
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|wrap_start
operator|<
name|sb
operator|->
name|len
condition|)
name|strbuf_wrap
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|wrap_start
argument_list|,
name|c
operator|->
name|width
argument_list|,
name|c
operator|->
name|indent1
argument_list|,
name|c
operator|->
name|indent2
argument_list|)
expr_stmt|;
name|c
operator|->
name|wrap_start
operator|=
name|sb
operator|->
name|len
expr_stmt|;
name|c
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|c
operator|->
name|indent1
operator|=
name|new_indent1
expr_stmt|;
name|c
operator|->
name|indent2
operator|=
name|new_indent2
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_reflog_person
specifier|static
name|int
name|format_reflog_person
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|char
name|part
parameter_list|,
name|struct
name|reflog_walk_info
modifier|*
name|log
parameter_list|,
specifier|const
name|struct
name|date_mode
modifier|*
name|dmode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ident
decl_stmt|;
if|if
condition|(
operator|!
name|log
condition|)
return|return
literal|2
return|;
name|ident
operator|=
name|get_reflog_ident
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ident
condition|)
return|return
literal|2
return|;
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|part
argument_list|,
name|ident
argument_list|,
name|strlen
argument_list|(
name|ident
argument_list|)
argument_list|,
name|dmode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_color
specifier|static
name|size_t
name|parse_color
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
comment|/* in UTF-8 */
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|struct
name|format_commit_context
modifier|*
name|c
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|rest
init|=
name|placeholder
decl_stmt|;
if|if
condition|(
name|placeholder
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
specifier|const
name|char
modifier|*
name|begin
init|=
name|placeholder
operator|+
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|strchr
argument_list|(
name|begin
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
name|char
name|color
index|[
name|COLOR_MAXLEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|skip_prefix
argument_list|(
name|begin
argument_list|,
literal|"auto,"
argument_list|,
operator|&
name|begin
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|want_color
argument_list|(
name|c
operator|->
name|pretty_ctx
operator|->
name|color
argument_list|)
condition|)
return|return
name|end
operator|-
name|placeholder
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|color_parse_mem
argument_list|(
name|begin
argument_list|,
name|end
operator|-
name|begin
argument_list|,
name|color
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to parse --pretty format"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|color
argument_list|)
expr_stmt|;
return|return
name|end
operator|-
name|placeholder
operator|+
literal|1
return|;
block|}
if|if
condition|(
name|skip_prefix
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"red"
argument_list|,
operator|&
name|rest
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_RED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"green"
argument_list|,
operator|&
name|rest
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_GREEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"blue"
argument_list|,
operator|&
name|rest
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_BLUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"reset"
argument_list|,
operator|&
name|rest
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_RESET
argument_list|)
expr_stmt|;
return|return
name|rest
operator|-
name|placeholder
return|;
block|}
end_function
begin_function
DECL|function|parse_padding_placeholder
specifier|static
name|size_t
name|parse_padding_placeholder
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|struct
name|format_commit_context
modifier|*
name|c
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ch
init|=
name|placeholder
decl_stmt|;
name|enum
name|flush_type
name|flush_type
decl_stmt|;
name|int
name|to_column
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|*
name|ch
operator|++
condition|)
block|{
case|case
literal|'<'
case|:
name|flush_type
operator|=
name|flush_right
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
operator|*
name|ch
operator|==
literal|'<'
condition|)
block|{
name|flush_type
operator|=
name|flush_both
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ch
operator|==
literal|'>'
condition|)
block|{
name|flush_type
operator|=
name|flush_left_and_steal
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
else|else
name|flush_type
operator|=
name|flush_left
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* the next value means "wide enough to that column" */
if|if
condition|(
operator|*
name|ch
operator|==
literal|'|'
condition|)
block|{
name|to_column
operator|=
literal|1
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ch
operator|==
literal|'('
condition|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|ch
operator|+
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|strcspn
argument_list|(
name|start
argument_list|,
literal|",)"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|!
name|end
operator|||
name|end
operator|==
name|start
condition|)
return|return
literal|0
return|;
name|width
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|start
operator|||
name|width
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|c
operator|->
name|padding
operator|=
name|to_column
condition|?
operator|-
name|width
else|:
name|width
expr_stmt|;
name|c
operator|->
name|flush_type
operator|=
name|flush_type
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|','
condition|)
block|{
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
operator|||
name|end
operator|==
name|start
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|starts_with
argument_list|(
name|start
argument_list|,
literal|"trunc)"
argument_list|)
condition|)
name|c
operator|->
name|truncate
operator|=
name|trunc_right
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|start
argument_list|,
literal|"ltrunc)"
argument_list|)
condition|)
name|c
operator|->
name|truncate
operator|=
name|trunc_left
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|start
argument_list|,
literal|"mtrunc)"
argument_list|)
condition|)
name|c
operator|->
name|truncate
operator|=
name|trunc_middle
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
name|c
operator|->
name|truncate
operator|=
name|trunc_none
expr_stmt|;
return|return
name|end
operator|-
name|placeholder
operator|+
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|format_commit_one
specifier|static
name|size_t
name|format_commit_one
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
comment|/* in UTF-8 */
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|format_commit_context
modifier|*
name|c
init|=
name|context
decl_stmt|;
specifier|const
name|struct
name|commit
modifier|*
name|commit
init|=
name|c
operator|->
name|commit
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|c
operator|->
name|message
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
name|int
name|h1
decl_stmt|,
name|h2
decl_stmt|;
comment|/* these are independent of the commit */
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|starts_with
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"(auto)"
argument_list|)
condition|)
block|{
name|c
operator|->
name|auto_color
operator|=
name|want_color
argument_list|(
name|c
operator|->
name|pretty_ctx
operator|->
name|color
argument_list|)
expr_stmt|;
return|return
literal|7
return|;
comment|/* consumed 7 bytes, "C(auto)" */
block|}
else|else
block|{
name|int
name|ret
init|=
name|parse_color
argument_list|(
name|sb
argument_list|,
name|placeholder
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
name|c
operator|->
name|auto_color
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Otherwise, we decided to treat %C<unknown> 			 * as a literal string, and the previous 			 * %C(auto) is still valid. 			 */
return|return
name|ret
return|;
block|}
case|case
literal|'n'
case|:
comment|/* newline */
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'x'
case|:
comment|/* %x00 == NUL, %x0a == LF, etc. */
if|if
condition|(
literal|0
operator|<=
operator|(
name|h1
operator|=
name|hexval_table
index|[
literal|0xff
operator|&
name|placeholder
index|[
literal|1
index|]
index|]
operator|)
operator|&&
name|h1
operator|<=
literal|16
operator|&&
literal|0
operator|<=
operator|(
name|h2
operator|=
name|hexval_table
index|[
literal|0xff
operator|&
name|placeholder
index|[
literal|2
index|]
index|]
operator|)
operator|&&
name|h2
operator|<=
literal|16
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
operator|(
name|h1
operator|<<
literal|4
operator|)
operator||
name|h2
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
literal|'w'
case|:
if|if
condition|(
name|placeholder
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
name|unsigned
name|long
name|width
init|=
literal|0
decl_stmt|,
name|indent1
init|=
literal|0
decl_stmt|,
name|indent2
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|placeholder
operator|+
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|end
operator|>
name|start
condition|)
block|{
name|width
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|==
literal|','
condition|)
block|{
name|indent1
operator|=
name|strtoul
argument_list|(
name|next
operator|+
literal|1
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|==
literal|','
condition|)
block|{
name|indent2
operator|=
name|strtoul
argument_list|(
name|next
operator|+
literal|1
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|next
operator|!=
literal|')'
condition|)
return|return
literal|0
return|;
block|}
name|rewrap_message_tail
argument_list|(
name|sb
argument_list|,
name|c
argument_list|,
name|width
argument_list|,
name|indent1
argument_list|,
name|indent2
argument_list|)
expr_stmt|;
return|return
name|end
operator|-
name|placeholder
operator|+
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
return|return
name|parse_padding_placeholder
argument_list|(
name|sb
argument_list|,
name|placeholder
argument_list|,
name|c
argument_list|)
return|;
block|}
comment|/* these depend on the commit */
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_object
argument_list|(
name|commit
operator|->
name|object
operator|.
name|oid
operator|.
name|hash
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'H'
case|:
comment|/* commit hash */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|diff_get_color
argument_list|(
name|c
operator|->
name|auto_color
argument_list|,
name|DIFF_COMMIT
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|oid_to_hex
argument_list|(
operator|&
name|commit
operator|->
name|object
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|diff_get_color
argument_list|(
name|c
operator|->
name|auto_color
argument_list|,
name|DIFF_RESET
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'h'
case|:
comment|/* abbreviated commit hash */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|diff_get_color
argument_list|(
name|c
operator|->
name|auto_color
argument_list|,
name|DIFF_COMMIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_commit_hash
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|diff_get_color
argument_list|(
name|c
operator|->
name|auto_color
argument_list|,
name|DIFF_RESET
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|diff_get_color
argument_list|(
name|c
operator|->
name|auto_color
argument_list|,
name|DIFF_RESET
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|abbrev_commit_hash
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_commit_hash
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'T'
case|:
comment|/* tree hash */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|oid_to_hex
argument_list|(
operator|&
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'t'
case|:
comment|/* abbreviated tree hash */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_tree_hash
argument_list|)
condition|)
return|return
literal|1
return|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|abbrev_tree_hash
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_tree_hash
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'P'
case|:
comment|/* parent hashes */
for|for
control|(
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|commit
operator|->
name|parents
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|oid_to_hex
argument_list|(
operator|&
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
literal|'p'
case|:
comment|/* abbreviated parent hashes */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_parent_hashes
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|commit
operator|->
name|parents
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|abbrev_parent_hashes
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_parent_hashes
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'m'
case|:
comment|/* left/right/bottom */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|get_revision_mark
argument_list|(
name|NULL
argument_list|,
name|commit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'d'
case|:
name|load_ref_decorations
argument_list|(
name|DECORATE_SHORT_REFS
argument_list|)
expr_stmt|;
name|format_decorations
argument_list|(
name|sb
argument_list|,
name|commit
argument_list|,
name|c
operator|->
name|auto_color
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'D'
case|:
name|load_ref_decorations
argument_list|(
name|DECORATE_SHORT_REFS
argument_list|)
expr_stmt|;
name|format_decorations_extended
argument_list|(
name|sb
argument_list|,
name|commit
argument_list|,
name|c
operator|->
name|auto_color
argument_list|,
literal|""
argument_list|,
literal|", "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'g'
case|:
comment|/* reflog info */
switch|switch
condition|(
name|placeholder
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* reflog selector */
case|case
literal|'D'
case|:
if|if
condition|(
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
condition|)
name|get_reflog_selector
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
argument_list|,
operator|&
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode_explicit
argument_list|,
operator|(
name|placeholder
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'s'
case|:
comment|/* reflog message */
if|if
condition|(
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
condition|)
name|get_reflog_message
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
return|return
name|format_reflog_person
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
argument_list|,
operator|&
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
comment|/* unknown %g placeholder */
case|case
literal|'N'
case|:
if|if
condition|(
name|c
operator|->
name|pretty_ctx
operator|->
name|notes_message
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|notes_message
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|placeholder
index|[
literal|0
index|]
operator|==
literal|'G'
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|signature_check
operator|.
name|result
condition|)
name|check_commit_signature
argument_list|(
name|c
operator|->
name|commit
argument_list|,
operator|&
operator|(
name|c
operator|->
name|signature_check
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'G'
case|:
if|if
condition|(
name|c
operator|->
name|signature_check
operator|.
name|gpg_output
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|signature_check
operator|.
name|gpg_output
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
switch|switch
condition|(
name|c
operator|->
name|signature_check
operator|.
name|result
condition|)
block|{
case|case
literal|'G'
case|:
case|case
literal|'B'
case|:
case|case
literal|'U'
case|:
case|case
literal|'N'
case|:
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|signature_check
operator|.
name|result
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|c
operator|->
name|signature_check
operator|.
name|signer
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|signature_check
operator|.
name|signer
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|c
operator|->
name|signature_check
operator|.
name|key
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|signature_check
operator|.
name|key
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|2
return|;
block|}
comment|/* For the rest we have to parse the commit header. */
if|if
condition|(
operator|!
name|c
operator|->
name|commit_header_parsed
condition|)
name|parse_commit_header
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* author ... */
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|msg
operator|+
name|c
operator|->
name|author
operator|.
name|off
argument_list|,
name|c
operator|->
name|author
operator|.
name|len
argument_list|,
operator|&
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|)
return|;
case|case
literal|'c'
case|:
comment|/* committer ... */
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|msg
operator|+
name|c
operator|->
name|committer
operator|.
name|off
argument_list|,
name|c
operator|->
name|committer
operator|.
name|len
argument_list|,
operator|&
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|)
return|;
case|case
literal|'e'
case|:
comment|/* encoding */
if|if
condition|(
name|c
operator|->
name|commit_encoding
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|commit_encoding
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'B'
case|:
comment|/* raw body */
comment|/* message_off is always left at the initial newline */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|message_off
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now we need to parse the commit message. */
if|if
condition|(
operator|!
name|c
operator|->
name|commit_message_parsed
condition|)
name|parse_commit_message
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* subject */
name|format_subject
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|subject_off
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'f'
case|:
comment|/* sanitized subject */
name|format_sanitized_subject
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|subject_off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'b'
case|:
comment|/* body */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|body_off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* unknown placeholder */
block|}
end_function
begin_function
DECL|function|format_and_pad_commit
specifier|static
name|size_t
name|format_and_pad_commit
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
comment|/* in UTF-8 */
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|struct
name|format_commit_context
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|strbuf
name|local_sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|total_consumed
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|padding
init|=
name|c
operator|->
name|padding
decl_stmt|;
if|if
condition|(
name|padding
operator|<
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|strrchr
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|int
name|occupied
decl_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
name|start
operator|=
name|sb
operator|->
name|buf
expr_stmt|;
name|occupied
operator|=
name|utf8_strnwidth
argument_list|(
name|start
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|padding
operator|=
operator|(
operator|-
name|padding
operator|)
operator|-
name|occupied
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|modifier
init|=
operator|*
name|placeholder
operator|==
literal|'C'
decl_stmt|;
name|int
name|consumed
init|=
name|format_commit_one
argument_list|(
operator|&
name|local_sb
argument_list|,
name|placeholder
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|total_consumed
operator|+=
name|consumed
expr_stmt|;
if|if
condition|(
operator|!
name|modifier
condition|)
break|break;
name|placeholder
operator|+=
name|consumed
expr_stmt|;
if|if
condition|(
operator|*
name|placeholder
operator|!=
literal|'%'
condition|)
break|break;
name|placeholder
operator|++
expr_stmt|;
name|total_consumed
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|utf8_strnwidth
argument_list|(
name|local_sb
operator|.
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flush_type
operator|==
name|flush_left_and_steal
condition|)
block|{
specifier|const
name|char
modifier|*
name|ch
init|=
name|sb
operator|->
name|buf
operator|+
name|sb
operator|->
name|len
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|len
operator|>
name|padding
operator|&&
name|ch
operator|>
name|sb
operator|->
name|buf
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|ch
operator|==
literal|' '
condition|)
block|{
name|ch
operator|--
expr_stmt|;
name|padding
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* check for trailing ansi sequences */
if|if
condition|(
operator|*
name|ch
operator|!=
literal|'m'
condition|)
break|break;
name|p
operator|=
name|ch
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ch
operator|-
name|p
operator|<
literal|10
operator|&&
operator|*
name|p
operator|!=
literal|'\033'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\033'
operator|||
name|ch
operator|+
literal|1
operator|-
name|p
operator|!=
name|display_mode_esc_sequence_len
argument_list|(
name|p
argument_list|)
condition|)
break|break;
comment|/* 			 * got a good ansi sequence, put it back to 			 * local_sb as we're cutting sb 			 */
name|strbuf_insert
argument_list|(
operator|&
name|local_sb
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|ch
operator|+
literal|1
operator|-
name|p
argument_list|)
expr_stmt|;
name|ch
operator|=
name|p
operator|-
literal|1
expr_stmt|;
block|}
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|ch
operator|+
literal|1
operator|-
name|sb
operator|->
name|buf
argument_list|)
expr_stmt|;
name|c
operator|->
name|flush_type
operator|=
name|flush_left
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|padding
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|truncate
condition|)
block|{
case|case
name|trunc_left
case|:
name|strbuf_utf8_replace
argument_list|(
operator|&
name|local_sb
argument_list|,
literal|0
argument_list|,
name|len
operator|-
operator|(
name|padding
operator|-
literal|2
operator|)
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
case|case
name|trunc_middle
case|:
name|strbuf_utf8_replace
argument_list|(
operator|&
name|local_sb
argument_list|,
name|padding
operator|/
literal|2
operator|-
literal|1
argument_list|,
name|len
operator|-
operator|(
name|padding
operator|-
literal|2
operator|)
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
case|case
name|trunc_right
case|:
name|strbuf_utf8_replace
argument_list|(
operator|&
name|local_sb
argument_list|,
name|padding
operator|-
literal|2
argument_list|,
name|len
operator|-
operator|(
name|padding
operator|-
literal|2
operator|)
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
case|case
name|trunc_none
case|:
break|break;
block|}
name|strbuf_addbuf
argument_list|(
name|sb
argument_list|,
operator|&
name|local_sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|sb_len
init|=
name|sb
operator|->
name|len
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|flush_type
operator|==
name|flush_left
condition|)
name|offset
operator|=
name|padding
operator|-
name|len
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|flush_type
operator|==
name|flush_both
condition|)
name|offset
operator|=
operator|(
name|padding
operator|-
name|len
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* 		 * we calculate padding in columns, now 		 * convert it back to chars 		 */
name|padding
operator|=
name|padding
operator|-
name|len
operator|+
name|local_sb
operator|.
name|len
expr_stmt|;
name|strbuf_addchars
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|sb_len
operator|+
name|offset
argument_list|,
name|local_sb
operator|.
name|buf
argument_list|,
name|local_sb
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|local_sb
argument_list|)
expr_stmt|;
name|c
operator|->
name|flush_type
operator|=
name|no_flush
expr_stmt|;
return|return
name|total_consumed
return|;
block|}
end_function
begin_function
DECL|function|format_commit_item
specifier|static
name|size_t
name|format_commit_item
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
comment|/* in UTF-8 */
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|consumed
decl_stmt|;
name|size_t
name|orig_len
decl_stmt|;
enum|enum
block|{
name|NO_MAGIC
block|,
name|ADD_LF_BEFORE_NON_EMPTY
block|,
name|DEL_LF_BEFORE_EMPTY
block|,
name|ADD_SP_BEFORE_NON_EMPTY
block|}
name|magic
init|=
name|NO_MAGIC
enum|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|magic
operator|=
name|DEL_LF_BEFORE_EMPTY
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|magic
operator|=
name|ADD_LF_BEFORE_NON_EMPTY
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|magic
operator|=
name|ADD_SP_BEFORE_NON_EMPTY
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|magic
operator|!=
name|NO_MAGIC
condition|)
name|placeholder
operator|++
expr_stmt|;
name|orig_len
operator|=
name|sb
operator|->
name|len
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|format_commit_context
operator|*
operator|)
name|context
operator|)
operator|->
name|flush_type
operator|!=
name|no_flush
condition|)
name|consumed
operator|=
name|format_and_pad_commit
argument_list|(
name|sb
argument_list|,
name|placeholder
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
name|consumed
operator|=
name|format_commit_one
argument_list|(
name|sb
argument_list|,
name|placeholder
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|==
name|NO_MAGIC
condition|)
return|return
name|consumed
return|;
if|if
condition|(
operator|(
name|orig_len
operator|==
name|sb
operator|->
name|len
operator|)
operator|&&
name|magic
operator|==
name|DEL_LF_BEFORE_EMPTY
condition|)
block|{
while|while
condition|(
name|sb
operator|->
name|len
operator|&&
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|orig_len
operator|!=
name|sb
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|magic
operator|==
name|ADD_LF_BEFORE_NON_EMPTY
condition|)
name|strbuf_insert
argument_list|(
name|sb
argument_list|,
name|orig_len
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|magic
operator|==
name|ADD_SP_BEFORE_NON_EMPTY
condition|)
name|strbuf_insert
argument_list|(
name|sb
argument_list|,
name|orig_len
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|consumed
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|userformat_want_item
specifier|static
name|size_t
name|userformat_want_item
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|userformat_want
modifier|*
name|w
init|=
name|context
decl_stmt|;
if|if
condition|(
operator|*
name|placeholder
operator|==
literal|'+'
operator|||
operator|*
name|placeholder
operator|==
literal|'-'
operator|||
operator|*
name|placeholder
operator|==
literal|' '
condition|)
name|placeholder
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|placeholder
condition|)
block|{
case|case
literal|'N'
case|:
name|w
operator|->
name|notes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|userformat_find_requirements
name|void
name|userformat_find_requirements
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|struct
name|userformat_want
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|strbuf
name|dummy
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|fmt
condition|)
block|{
if|if
condition|(
operator|!
name|user_format
condition|)
return|return;
name|fmt
operator|=
name|user_format
expr_stmt|;
block|}
name|strbuf_expand
argument_list|(
operator|&
name|dummy
argument_list|,
name|fmt
argument_list|,
name|userformat_want_item
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_commit_message
name|void
name|format_commit_message
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pretty_ctx
parameter_list|)
block|{
name|struct
name|format_commit_context
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_enc
init|=
name|pretty_ctx
operator|->
name|output_encoding
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8
init|=
literal|"UTF-8"
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|commit
operator|=
name|commit
expr_stmt|;
name|context
operator|.
name|pretty_ctx
operator|=
name|pretty_ctx
expr_stmt|;
name|context
operator|.
name|wrap_start
operator|=
name|sb
operator|->
name|len
expr_stmt|;
comment|/* 	 * convert a commit message to UTF-8 first 	 * as far as 'format_commit_item' assumes it in UTF-8 	 */
name|context
operator|.
name|message
operator|=
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
operator|&
name|context
operator|.
name|commit_encoding
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
name|strbuf_expand
argument_list|(
name|sb
argument_list|,
name|format
argument_list|,
name|format_commit_item
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|rewrap_message_tail
argument_list|(
name|sb
argument_list|,
operator|&
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* then convert a commit message to an actual output encoding */
if|if
condition|(
name|output_enc
condition|)
block|{
if|if
condition|(
name|same_encoding
argument_list|(
name|utf8
argument_list|,
name|output_enc
argument_list|)
condition|)
name|output_enc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|.
name|commit_encoding
operator|&&
operator|!
name|same_encoding
argument_list|(
name|context
operator|.
name|commit_encoding
argument_list|,
name|utf8
argument_list|)
condition|)
name|output_enc
operator|=
name|context
operator|.
name|commit_encoding
expr_stmt|;
block|}
if|if
condition|(
name|output_enc
condition|)
block|{
name|int
name|outsz
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|reencode_string_len
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
name|sb
operator|->
name|len
argument_list|,
name|output_enc
argument_list|,
name|utf8
argument_list|,
operator|&
name|outsz
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
condition|)
name|strbuf_attach
argument_list|(
name|sb
argument_list|,
name|out
argument_list|,
name|outsz
argument_list|,
name|outsz
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|context
operator|.
name|commit_encoding
argument_list|)
expr_stmt|;
name|unuse_commit_buffer
argument_list|(
name|commit
argument_list|,
name|context
operator|.
name|message
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_header
specifier|static
name|void
name|pp_header
parameter_list|(
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|parents_shown
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|line
init|=
operator|*
name|msg_p
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
operator|*
name|msg_p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
return|return;
operator|*
name|msg_p
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
name|linelen
operator|==
literal|1
condition|)
comment|/* End of header */
return|return;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_RAW
condition|)
block|{
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|starts_with
argument_list|(
name|line
argument_list|,
literal|"parent "
argument_list|)
condition|)
block|{
if|if
condition|(
name|linelen
operator|!=
literal|48
condition|)
name|die
argument_list|(
literal|"bad parent line in commit"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|parents_shown
condition|)
block|{
name|unsigned
name|num
init|=
name|commit_list_count
argument_list|(
name|commit
operator|->
name|parents
argument_list|)
decl_stmt|;
comment|/* with enough slop */
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|num
operator|*
literal|50
operator|+
literal|20
argument_list|)
expr_stmt|;
name|add_merge_info
argument_list|(
name|pp
argument_list|,
name|sb
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|parents_shown
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * MEDIUM == DEFAULT shows only author with dates. 		 * FULL shows both authors but not dates. 		 * FULLER shows both authors and dates. 		 */
if|if
condition|(
name|skip_prefix
argument_list|(
name|line
argument_list|,
literal|"author "
argument_list|,
operator|&
name|name
argument_list|)
condition|)
block|{
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|80
argument_list|)
expr_stmt|;
name|pp_user_info
argument_list|(
name|pp
argument_list|,
literal|"Author"
argument_list|,
name|sb
argument_list|,
name|name
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skip_prefix
argument_list|(
name|line
argument_list|,
literal|"committer "
argument_list|,
operator|&
name|name
argument_list|)
operator|&&
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_FULL
operator|||
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|)
block|{
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|80
argument_list|)
expr_stmt|;
name|pp_user_info
argument_list|(
name|pp
argument_list|,
literal|"Commit"
argument_list|,
name|sb
argument_list|,
name|name
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|pp_title_line
name|void
name|pp_title_line
parameter_list|(
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|int
name|need_8bit_cte
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|max_length
init|=
literal|78
decl_stmt|;
comment|/* per rfc2047 */
name|struct
name|strbuf
name|title
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|title
argument_list|,
literal|80
argument_list|)
expr_stmt|;
operator|*
name|msg_p
operator|=
name|format_subject
argument_list|(
operator|&
name|title
argument_list|,
operator|*
name|msg_p
argument_list|,
name|pp
operator|->
name|preserve_subject
condition|?
literal|"\n"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|len
operator|+
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|subject
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|pp
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_rfc2047_encoding
argument_list|(
name|title
operator|.
name|buf
argument_list|,
name|title
operator|.
name|len
argument_list|,
name|RFC2047_SUBJECT
argument_list|)
condition|)
name|add_rfc2047
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|buf
argument_list|,
name|title
operator|.
name|len
argument_list|,
name|encoding
argument_list|,
name|RFC2047_SUBJECT
argument_list|)
expr_stmt|;
else|else
name|strbuf_add_wrapped_bytes
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|buf
argument_list|,
name|title
operator|.
name|len
argument_list|,
operator|-
name|last_line_length
argument_list|(
name|sb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|max_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addbuf
argument_list|(
name|sb
argument_list|,
operator|&
name|title
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_8bit_cte
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pp
operator|->
name|in_body_headers
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|has_non_ascii
argument_list|(
name|pp
operator|->
name|in_body_headers
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
name|need_8bit_cte
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|need_8bit_cte
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|header_fmt
init|=
literal|"MIME-Version: 1.0\n"
literal|"Content-Type: text/plain; charset=%s\n"
literal|"Content-Transfer-Encoding: 8bit\n"
decl_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|header_fmt
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|after_subject
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|pp
operator|->
name|after_subject
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|in_body_headers
operator|.
name|nr
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pp
operator|->
name|in_body_headers
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|pp
operator|->
name|in_body_headers
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pp
operator|->
name|in_body_headers
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
operator|&
name|pp
operator|->
name|in_body_headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_utf8_width
specifier|static
name|int
name|pp_utf8_width
parameter_list|(
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|int
name|width
init|=
literal|0
decl_stmt|;
name|size_t
name|remain
init|=
name|end
operator|-
name|start
decl_stmt|;
while|while
condition|(
name|remain
condition|)
block|{
name|int
name|n
init|=
name|utf8_width
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|remain
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
operator|!
name|start
condition|)
return|return
operator|-
literal|1
return|;
name|width
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function
begin_function
DECL|function|strbuf_add_tabexpand
specifier|static
name|void
name|strbuf_add_tabexpand
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|tabwidth
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|linelen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tab
decl_stmt|;
while|while
condition|(
operator|(
name|tab
operator|=
name|memchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|,
name|linelen
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|width
init|=
name|pp_utf8_width
argument_list|(
name|line
argument_list|,
name|tab
argument_list|)
decl_stmt|;
comment|/* 		 * If it wasn't well-formed utf8, or it 		 * had characters with badly defined 		 * width (control characters etc), just 		 * give up on trying to align things. 		 */
if|if
condition|(
name|width
operator|<
literal|0
condition|)
break|break;
comment|/* Output the data .. */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|tab
operator|-
name|line
argument_list|)
expr_stmt|;
comment|/* .. and the de-tabified tab */
name|strbuf_addchars
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|,
name|tabwidth
operator|-
operator|(
name|width
operator|%
name|tabwidth
operator|)
argument_list|)
expr_stmt|;
comment|/* Skip over the printed part .. */
name|linelen
operator|-=
name|tab
operator|+
literal|1
operator|-
name|line
expr_stmt|;
name|line
operator|=
name|tab
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * Print out everything after the last tab without 	 * worrying about width - there's nothing more to 	 * align. 	 */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * pp_handle_indent() prints out the intendation, and  * the whole line (without the final newline), after  * de-tabifying.  */
end_comment
begin_function
DECL|function|pp_handle_indent
specifier|static
name|void
name|pp_handle_indent
parameter_list|(
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|indent
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|linelen
parameter_list|)
block|{
name|strbuf_addchars
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|expand_tabs_in_log
condition|)
name|strbuf_add_tabexpand
argument_list|(
name|sb
argument_list|,
name|pp
operator|->
name|expand_tabs_in_log
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
else|else
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_remainder
name|void
name|pp_remainder
parameter_list|(
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
operator|*
name|msg_p
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|line
argument_list|)
decl_stmt|;
operator|*
name|msg_p
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
break|break;
if|if
condition|(
name|is_empty_line
argument_list|(
name|line
argument_list|,
operator|&
name|linelen
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_SHORT
condition|)
break|break;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
name|indent
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
condition|)
name|pp_handle_indent
argument_list|(
name|pp
argument_list|,
name|sb
argument_list|,
name|indent
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|->
name|expand_tabs_in_log
condition|)
name|strbuf_add_tabexpand
argument_list|(
name|sb
argument_list|,
name|pp
operator|->
name|expand_tabs_in_log
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
else|else
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pretty_print_commit
name|void
name|pretty_print_commit
parameter_list|(
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|unsigned
name|long
name|beginning_of_body
decl_stmt|;
name|int
name|indent
init|=
literal|4
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
specifier|const
name|char
modifier|*
name|reencoded
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
name|int
name|need_8bit_cte
init|=
name|pp
operator|->
name|need_8bit_cte
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_USERFORMAT
condition|)
block|{
name|format_commit_message
argument_list|(
name|commit
argument_list|,
name|user_format
argument_list|,
name|sb
argument_list|,
name|pp
argument_list|)
expr_stmt|;
return|return;
block|}
name|encoding
operator|=
name|get_log_output_encoding
argument_list|()
expr_stmt|;
name|msg
operator|=
name|reencoded
operator|=
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|||
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
name|indent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We need to check and emit Content-type: to mark it 	 * as 8-bit if we haven't done so. 	 */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
name|need_8bit_cte
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|,
name|in_body
decl_stmt|;
for|for
control|(
name|in_body
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|msg
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|in_body
condition|)
block|{
comment|/* author could be non 7-bit ASCII but 				 * the log may be so; skip over the 				 * header part first. 				 */
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|&&
name|msg
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|in_body
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|need_8bit_cte
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|pp_header
argument_list|(
name|pp
argument_list|,
name|encoding
argument_list|,
name|commit
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
operator|&&
operator|!
name|pp
operator|->
name|subject
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Skip excess blank lines at the beginning of body, if any... */
name|msg
operator|=
name|skip_empty_lines
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* These formats treat the title line specially. */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|||
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
name|pp_title_line
argument_list|(
name|pp
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|,
name|encoding
argument_list|,
name|need_8bit_cte
argument_list|)
expr_stmt|;
name|beginning_of_body
operator|=
name|sb
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|pp_remainder
argument_list|(
name|pp
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|strbuf_rtrim
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Make sure there is an EOLN for the non-oneline case */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* 	 * The caller may append additional body text in e-mail 	 * format.  Make sure we did not strip the blank line 	 * between the header and the body. 	 */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
name|sb
operator|->
name|len
operator|<=
name|beginning_of_body
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|unuse_commit_buffer
argument_list|(
name|commit
argument_list|,
name|reencoded
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_commit_easy
name|void
name|pp_commit_easy
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|pretty_print_context
name|pp
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pp
operator|.
name|fmt
operator|=
name|fmt
expr_stmt|;
name|pretty_print_commit
argument_list|(
operator|&
name|pp
argument_list|,
name|commit
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
