begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"mailmap.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"reflog-walk.h"
end_include
begin_include
include|#
directive|include
file|"gpg-interface.h"
end_include
begin_decl_stmt
DECL|variable|user_format
specifier|static
name|char
modifier|*
name|user_format
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|cmt_fmt_map
specifier|static
struct|struct
name|cmt_fmt_map
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|format
name|enum
name|cmit_fmt
name|format
decl_stmt|;
DECL|member|is_tformat
name|int
name|is_tformat
decl_stmt|;
DECL|member|is_alias
name|int
name|is_alias
decl_stmt|;
DECL|member|user_format
specifier|const
name|char
modifier|*
name|user_format
decl_stmt|;
block|}
DECL|variable|commit_formats
modifier|*
name|commit_formats
struct|;
end_struct
begin_decl_stmt
DECL|variable|builtin_formats_len
specifier|static
name|size_t
name|builtin_formats_len
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_formats_len
specifier|static
name|size_t
name|commit_formats_len
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_formats_alloc
specifier|static
name|size_t
name|commit_formats_alloc
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|struct
name|cmt_fmt_map
modifier|*
name|find_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|sought
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|save_user_format
specifier|static
name|void
name|save_user_format
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|is_tformat
parameter_list|)
block|{
name|free
argument_list|(
name|user_format
argument_list|)
expr_stmt|;
name|user_format
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tformat
condition|)
name|rev
operator|->
name|use_terminator
operator|=
literal|1
expr_stmt|;
name|rev
operator|->
name|commit_format
operator|=
name|CMIT_FMT_USERFORMAT
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_pretty_formats_config
specifier|static
name|int
name|git_pretty_formats_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
modifier|*
name|commit_format
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"pretty."
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|var
operator|+
name|strlen
argument_list|(
literal|"pretty."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|builtin_formats_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|builtin_formats_len
init|;
name|i
operator|<
name|commit_formats_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|commit_format
operator|=
operator|&
name|commit_formats
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|commit_format
condition|)
block|{
name|ALLOC_GROW
argument_list|(
name|commit_formats
argument_list|,
name|commit_formats_len
operator|+
literal|1
argument_list|,
name|commit_formats_alloc
argument_list|)
expr_stmt|;
name|commit_format
operator|=
operator|&
name|commit_formats
index|[
name|commit_formats_len
index|]
expr_stmt|;
name|memset
argument_list|(
name|commit_format
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit_format
argument_list|)
argument_list|)
expr_stmt|;
name|commit_formats_len
operator|++
expr_stmt|;
block|}
name|commit_format
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|commit_format
operator|->
name|format
operator|=
name|CMIT_FMT_USERFORMAT
expr_stmt|;
name|git_config_string
argument_list|(
operator|&
name|fmt
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|fmt
argument_list|,
literal|"format:"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|fmt
argument_list|,
literal|"tformat:"
argument_list|)
condition|)
block|{
name|commit_format
operator|->
name|is_tformat
operator|=
name|fmt
index|[
literal|0
index|]
operator|==
literal|'t'
expr_stmt|;
name|fmt
operator|=
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|fmt
argument_list|,
literal|'%'
argument_list|)
condition|)
name|commit_format
operator|->
name|is_tformat
operator|=
literal|1
expr_stmt|;
else|else
name|commit_format
operator|->
name|is_alias
operator|=
literal|1
expr_stmt|;
name|commit_format
operator|->
name|user_format
operator|=
name|fmt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setup_commit_formats
specifier|static
name|void
name|setup_commit_formats
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
name|builtin_formats
index|[]
init|=
block|{
block|{
literal|"raw"
block|,
name|CMIT_FMT_RAW
block|,
literal|0
block|}
block|,
block|{
literal|"medium"
block|,
name|CMIT_FMT_MEDIUM
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|CMIT_FMT_SHORT
block|,
literal|0
block|}
block|,
block|{
literal|"email"
block|,
name|CMIT_FMT_EMAIL
block|,
literal|0
block|}
block|,
block|{
literal|"fuller"
block|,
name|CMIT_FMT_FULLER
block|,
literal|0
block|}
block|,
block|{
literal|"full"
block|,
name|CMIT_FMT_FULL
block|,
literal|0
block|}
block|,
block|{
literal|"oneline"
block|,
name|CMIT_FMT_ONELINE
block|,
literal|1
block|}
block|}
decl_stmt|;
name|commit_formats_len
operator|=
name|ARRAY_SIZE
argument_list|(
name|builtin_formats
argument_list|)
expr_stmt|;
name|builtin_formats_len
operator|=
name|commit_formats_len
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|commit_formats
argument_list|,
name|commit_formats_len
argument_list|,
name|commit_formats_alloc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|commit_formats
argument_list|,
name|builtin_formats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|builtin_formats
argument_list|)
operator|*
name|ARRAY_SIZE
argument_list|(
name|builtin_formats
argument_list|)
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_pretty_formats_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_commit_format_recursive
specifier|static
name|struct
name|cmt_fmt_map
modifier|*
name|find_commit_format_recursive
parameter_list|(
specifier|const
name|char
modifier|*
name|sought
parameter_list|,
specifier|const
name|char
modifier|*
name|original
parameter_list|,
name|int
name|num_redirections
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
modifier|*
name|found
init|=
name|NULL
decl_stmt|;
name|size_t
name|found_match_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_redirections
operator|>=
name|commit_formats_len
condition|)
name|die
argument_list|(
literal|"invalid --pretty format: "
literal|"'%s' references an alias which points to itself"
argument_list|,
name|original
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_formats_len
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|match_len
decl_stmt|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|sought
argument_list|)
condition|)
continue|continue;
name|match_len
operator|=
name|strlen
argument_list|(
name|commit_formats
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
operator|||
name|found_match_len
operator|>
name|match_len
condition|)
block|{
name|found
operator|=
operator|&
name|commit_formats
index|[
name|i
index|]
expr_stmt|;
name|found_match_len
operator|=
name|match_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|&&
name|found
operator|->
name|is_alias
condition|)
block|{
name|found
operator|=
name|find_commit_format_recursive
argument_list|(
name|found
operator|->
name|user_format
argument_list|,
name|original
argument_list|,
name|num_redirections
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function
begin_function
DECL|function|find_commit_format
specifier|static
name|struct
name|cmt_fmt_map
modifier|*
name|find_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|sought
parameter_list|)
block|{
if|if
condition|(
operator|!
name|commit_formats
condition|)
name|setup_commit_formats
argument_list|()
expr_stmt|;
return|return
name|find_commit_format_recursive
argument_list|(
name|sought
argument_list|,
name|sought
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_commit_format
name|void
name|get_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|cmt_fmt_map
modifier|*
name|commit_format
decl_stmt|;
name|rev
operator|->
name|use_terminator
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
block|{
name|rev
operator|->
name|commit_format
operator|=
name|CMIT_FMT_DEFAULT
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"format:"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"tformat:"
argument_list|)
condition|)
block|{
name|save_user_format
argument_list|(
name|rev
argument_list|,
name|strchr
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
argument_list|,
name|arg
index|[
literal|0
index|]
operator|==
literal|'t'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|save_user_format
argument_list|(
name|rev
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|commit_format
operator|=
name|find_commit_format
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit_format
condition|)
name|die
argument_list|(
literal|"invalid --pretty format: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rev
operator|->
name|commit_format
operator|=
name|commit_format
operator|->
name|format
expr_stmt|;
name|rev
operator|->
name|use_terminator
operator|=
name|commit_format
operator|->
name|is_tformat
expr_stmt|;
if|if
condition|(
name|commit_format
operator|->
name|format
operator|==
name|CMIT_FMT_USERFORMAT
condition|)
block|{
name|save_user_format
argument_list|(
name|rev
argument_list|,
name|commit_format
operator|->
name|user_format
argument_list|,
name|commit_format
operator|->
name|is_tformat
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Generic support for pretty-printing the header  */
end_comment
begin_function
DECL|function|get_one_line
specifier|static
name|int
name|get_one_line
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|msg
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/* High bit set, or ISO-2022-INT */
end_comment
begin_function
DECL|function|non_ascii
specifier|static
name|int
name|non_ascii
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|!
name|isascii
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'\033'
return|;
block|}
end_function
begin_function
DECL|function|has_non_ascii
name|int
name|has_non_ascii
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_rfc822_special
specifier|static
name|int
name|is_rfc822_special
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|':'
case|:
case|case
literal|';'
case|:
case|case
literal|'@'
case|:
case|case
literal|','
case|:
case|case
literal|'.'
case|:
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|needs_rfc822_quoting
specifier|static
name|int
name|needs_rfc822_quoting
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_rfc822_special
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|last_line_length
specifier|static
name|int
name|last_line_length
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* How many bytes are already used on the last line? */
for|for
control|(
name|i
operator|=
name|sb
operator|->
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|sb
operator|->
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
return|return
name|sb
operator|->
name|len
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
end_function
begin_function
DECL|function|add_rfc822_quoted
specifier|static
name|void
name|add_rfc822_quoted
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* just a guess, we may have to also backslash-quote */
name|strbuf_grow
argument_list|(
name|out
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|s
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
comment|/* fall through */
default|default:
name|strbuf_addch
argument_list|(
name|out
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function
begin_enum
DECL|enum|rfc2047_type
enum|enum
name|rfc2047_type
block|{
DECL|enumerator|RFC2047_SUBJECT
name|RFC2047_SUBJECT
block|,
DECL|enumerator|RFC2047_ADDRESS
name|RFC2047_ADDRESS
block|, }
enum|;
end_enum
begin_function
DECL|function|is_rfc2047_special
specifier|static
name|int
name|is_rfc2047_special
parameter_list|(
name|char
name|ch
parameter_list|,
name|enum
name|rfc2047_type
name|type
parameter_list|)
block|{
comment|/* 	 * rfc2047, section 4.2: 	 * 	 *    8-bit values which correspond to printable ASCII characters other 	 *    than "=", "?", and "_" (underscore), MAY be represented as those 	 *    characters.  (But see section 5 for restrictions.)  In 	 *    particular, SPACE and TAB MUST NOT be represented as themselves 	 *    within encoded words. 	 */
comment|/* 	 * rule out non-ASCII characters and non-printable characters (the 	 * non-ASCII check should be redundant as isprint() is not localized 	 * and only knows about ASCII, but be defensive about that) 	 */
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* 	 * rule out special printable characters (' ' should be the only 	 * whitespace character considered printable, but be defensive and use 	 * isspace()) 	 */
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'='
operator|||
name|ch
operator|==
literal|'?'
operator|||
name|ch
operator|==
literal|'_'
condition|)
return|return
literal|1
return|;
comment|/* 	 * rfc2047, section 5.3: 	 * 	 *    As a replacement for a 'word' entity within a 'phrase', for example, 	 *    one that precedes an address in a From, To, or Cc header.  The ABNF 	 *    definition for 'phrase' from RFC 822 thus becomes: 	 * 	 *    phrase = 1*( encoded-word / word ) 	 * 	 *    In this case the set of characters that may be used in a "Q"-encoded 	 *    'encoded-word' is restricted to:<upper and lower case ASCII 	 *    letters, decimal digits, "!", "*", "+", "-", "/", "=", and "_" 	 *    (underscore, ASCII 95.)>.  An 'encoded-word' that appears within a 	 *    'phrase' MUST be separated from any adjacent 'word', 'text' or 	 *    'special' by 'linear-white-space'. 	 */
if|if
condition|(
name|type
operator|!=
name|RFC2047_ADDRESS
condition|)
return|return
literal|0
return|;
comment|/* '=' and '_' are special cases and have been checked above */
return|return
operator|!
operator|(
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'!'
operator|||
name|ch
operator|==
literal|'*'
operator|||
name|ch
operator|==
literal|'+'
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'/'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|needs_rfc2047_encoding
specifier|static
name|int
name|needs_rfc2047_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|rfc2047_type
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|line
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'\n'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|len
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|'='
operator|&&
name|line
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'?'
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|add_rfc2047
specifier|static
name|void
name|add_rfc2047
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|enum
name|rfc2047_type
name|type
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|max_encoded_length
init|=
literal|76
decl_stmt|;
comment|/* per rfc2047 */
name|int
name|i
decl_stmt|;
name|int
name|line_len
init|=
name|last_line_length
argument_list|(
name|sb
argument_list|)
decl_stmt|;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|len
operator|*
literal|3
operator|+
name|strlen
argument_list|(
name|encoding
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"=?%s?q?"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|line_len
operator|+=
name|strlen
argument_list|(
name|encoding
argument_list|)
operator|+
literal|5
expr_stmt|;
comment|/* 5 for =??q? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|ch
init|=
name|line
index|[
name|i
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|is_special
init|=
name|is_rfc2047_special
argument_list|(
name|ch
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* 		 * According to RFC 2047, we could encode the special character 		 * ' ' (space) with '_' (underscore) for readability. But many 		 * programs do not understand this and just leave the 		 * underscore in place. Thus, we do nothing special here, which 		 * causes ' ' to be encoded as '=20', avoiding this problem. 		 */
if|if
condition|(
name|line_len
operator|+
literal|2
operator|+
operator|(
name|is_special
condition|?
literal|3
else|:
literal|1
operator|)
operator|>
name|max_encoded_length
condition|)
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"?=\n =?%s?q?"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|line_len
operator|=
name|strlen
argument_list|(
name|encoding
argument_list|)
operator|+
literal|5
operator|+
literal|1
expr_stmt|;
comment|/* =??q? plus SP */
block|}
if|if
condition|(
name|is_special
condition|)
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"=%02X"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|line_len
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|line_len
operator|++
expr_stmt|;
block|}
block|}
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"?="
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_user_info
name|void
name|pp_user_info
parameter_list|(
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|int
name|max_length
init|=
literal|78
decl_stmt|;
comment|/* per rfc2822 */
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|unsigned
name|long
name|time
decl_stmt|;
name|int
name|tz
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
condition|)
return|return;
name|date
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date
condition|)
return|return;
name|namelen
operator|=
operator|++
name|date
operator|-
name|line
expr_stmt|;
name|time
operator|=
name|strtoul
argument_list|(
name|date
argument_list|,
operator|&
name|date
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tz
operator|=
name|strtol
argument_list|(
name|date
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
name|char
modifier|*
name|name_tail
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'<'
argument_list|)
decl_stmt|;
name|int
name|display_name_length
decl_stmt|;
if|if
condition|(
operator|!
name|name_tail
condition|)
return|return;
while|while
condition|(
name|line
operator|<
name|name_tail
operator|&&
name|isspace
argument_list|(
name|name_tail
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|name_tail
operator|--
expr_stmt|;
name|display_name_length
operator|=
name|name_tail
operator|-
name|line
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"From: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_rfc2047_encoding
argument_list|(
name|line
argument_list|,
name|display_name_length
argument_list|,
name|RFC2047_ADDRESS
argument_list|)
condition|)
block|{
name|add_rfc2047
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|display_name_length
argument_list|,
name|encoding
argument_list|,
name|RFC2047_ADDRESS
argument_list|)
expr_stmt|;
name|max_length
operator|=
literal|76
expr_stmt|;
comment|/* per rfc2047 */
block|}
elseif|else
if|if
condition|(
name|needs_rfc822_quoting
argument_list|(
name|line
argument_list|,
name|display_name_length
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|quoted
init|=
name|STRBUF_INIT
decl_stmt|;
name|add_rfc822_quoted
argument_list|(
operator|&
name|quoted
argument_list|,
name|line
argument_list|,
name|display_name_length
argument_list|)
expr_stmt|;
name|strbuf_add_wrapped_bytes
argument_list|(
name|sb
argument_list|,
name|quoted
operator|.
name|buf
argument_list|,
name|quoted
operator|.
name|len
argument_list|,
operator|-
literal|6
argument_list|,
literal|1
argument_list|,
name|max_length
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|quoted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_add_wrapped_bytes
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|display_name_length
argument_list|,
operator|-
literal|6
argument_list|,
literal|1
argument_list|,
name|max_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namelen
operator|-
name|display_name_length
operator|+
name|last_line_length
argument_list|(
name|sb
argument_list|)
operator|>
name|max_length
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|name_tail
index|[
literal|0
index|]
argument_list|)
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|name_tail
argument_list|,
name|namelen
operator|-
name|display_name_length
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%s: %.*s%.*s\n"
argument_list|,
name|what
argument_list|,
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|?
literal|4
else|:
literal|0
argument_list|,
literal|"    "
argument_list|,
name|namelen
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|pp
operator|->
name|fmt
condition|)
block|{
case|case
name|CMIT_FMT_MEDIUM
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Date:   %s\n"
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|pp
operator|->
name|date_mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_EMAIL
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|DATE_RFC2822
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_FULLER
case|:
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%sDate: %s\n"
argument_list|,
name|what
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|pp
operator|->
name|date_mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* notin' */
break|break;
block|}
block|}
end_function
begin_function
DECL|function|is_empty_line
specifier|static
name|int
name|is_empty_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|len_p
parameter_list|)
block|{
name|int
name|len
init|=
operator|*
name|len_p
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
operator|*
name|len_p
operator|=
name|len
expr_stmt|;
return|return
operator|!
name|len
return|;
block|}
end_function
begin_function
DECL|function|skip_empty_lines
specifier|static
specifier|const
name|char
modifier|*
name|skip_empty_lines
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|msg
argument_list|)
decl_stmt|;
name|int
name|ll
init|=
name|linelen
decl_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
break|break;
if|if
condition|(
operator|!
name|is_empty_line
argument_list|(
name|msg
argument_list|,
operator|&
name|ll
argument_list|)
condition|)
break|break;
name|msg
operator|+=
name|linelen
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
end_function
begin_function
DECL|function|add_merge_info
specifier|static
name|void
name|add_merge_info
parameter_list|(
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
init|=
name|commit
operator|->
name|parents
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|)
operator|||
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|)
operator|||
operator|!
name|parent
operator|||
operator|!
name|parent
operator|->
name|next
condition|)
return|return;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"Merge:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parent
operator|->
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|abbrev
condition|)
name|hex
operator|=
name|find_unique_abbrev
argument_list|(
name|p
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|pp
operator|->
name|abbrev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hex
condition|)
name|hex
operator|=
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|next
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|" %s"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_header
specifier|static
name|char
modifier|*
name|get_header
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|int
name|key_len
init|=
name|strlen
argument_list|(
name|key
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
init|=
name|commit
operator|->
name|buffer
decl_stmt|;
while|while
condition|(
name|line
condition|)
block|{
specifier|const
name|char
modifier|*
name|eol
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|line
operator|==
name|eol
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|eol
condition|)
block|{
name|warning
argument_list|(
literal|"malformed commit (header is missing newline): %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|eol
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|next
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|eol
operator|-
name|line
operator|>
name|key_len
operator|&&
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
operator|&&
name|line
index|[
name|key_len
index|]
operator|==
literal|' '
condition|)
block|{
return|return
name|xmemdupz
argument_list|(
name|line
operator|+
name|key_len
operator|+
literal|1
argument_list|,
name|eol
operator|-
name|line
operator|-
name|key_len
operator|-
literal|1
argument_list|)
return|;
block|}
name|line
operator|=
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|replace_encoding_header
specifier|static
name|char
modifier|*
name|replace_encoding_header
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|struct
name|strbuf
name|tmp
init|=
name|STRBUF_INIT
decl_stmt|;
name|size_t
name|start
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
comment|/* guess if there is an encoding header before a \n\n */
while|while
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"encoding "
argument_list|,
name|strlen
argument_list|(
literal|"encoding "
argument_list|)
argument_list|)
condition|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|||
operator|*
operator|++
name|cp
operator|==
literal|'\n'
condition|)
return|return
name|buf
return|;
block|}
name|start
operator|=
name|cp
operator|-
name|buf
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|buf
return|;
comment|/* should not happen but be defensive */
name|len
operator|=
name|cp
operator|+
literal|1
operator|-
operator|(
name|buf
operator|+
name|start
operator|)
expr_stmt|;
name|strbuf_attach
argument_list|(
operator|&
name|tmp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_encoding_utf8
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
comment|/* we have re-coded to UTF-8; drop the header */
name|strbuf_remove
argument_list|(
operator|&
name|tmp
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just replaces XXXX in 'encoding XXXX\n' */
name|strbuf_splice
argument_list|(
operator|&
name|tmp
argument_list|,
name|start
operator|+
name|strlen
argument_list|(
literal|"encoding "
argument_list|)
argument_list|,
name|len
operator|-
name|strlen
argument_list|(
literal|"encoding \n"
argument_list|)
argument_list|,
name|encoding
argument_list|,
name|strlen
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|strbuf_detach
argument_list|(
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|logmsg_reencode
name|char
modifier|*
name|logmsg_reencode
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|output_encoding
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|utf8
init|=
literal|"UTF-8"
decl_stmt|;
specifier|const
name|char
modifier|*
name|use_encoding
decl_stmt|;
name|char
modifier|*
name|encoding
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|output_encoding
condition|)
return|return
name|NULL
return|;
name|encoding
operator|=
name|get_header
argument_list|(
name|commit
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
name|use_encoding
operator|=
name|encoding
condition|?
name|encoding
else|:
name|utf8
expr_stmt|;
if|if
condition|(
name|same_encoding
argument_list|(
name|use_encoding
argument_list|,
name|output_encoding
argument_list|)
condition|)
if|if
condition|(
name|encoding
condition|)
comment|/* we'll strip encoding header later */
name|out
operator|=
name|xstrdup
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/* nothing to do */
else|else
name|out
operator|=
name|reencode_string
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
name|output_encoding
argument_list|,
name|use_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|out
operator|=
name|replace_encoding_header
argument_list|(
name|out
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|mailmap_name
specifier|static
name|int
name|mailmap_name
parameter_list|(
name|char
modifier|*
name|email
parameter_list|,
name|int
name|email_len
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|name_len
parameter_list|)
block|{
specifier|static
name|struct
name|string_list
modifier|*
name|mail_map
decl_stmt|;
if|if
condition|(
operator|!
name|mail_map
condition|)
block|{
name|mail_map
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mail_map
argument_list|)
argument_list|)
expr_stmt|;
name|read_mailmap
argument_list|(
name|mail_map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|mail_map
operator|->
name|nr
operator|&&
name|map_user
argument_list|(
name|mail_map
argument_list|,
name|email
argument_list|,
name|email_len
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|format_person_part
specifier|static
name|size_t
name|format_person_part
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|char
name|part
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|date_mode
name|dmode
parameter_list|)
block|{
comment|/* currently all placeholders have same length */
specifier|const
name|int
name|placeholder_len
init|=
literal|2
decl_stmt|;
name|int
name|tz
decl_stmt|;
name|unsigned
name|long
name|date
init|=
literal|0
decl_stmt|;
name|char
name|person_name
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|person_mail
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|ident_split
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_start
decl_stmt|,
modifier|*
name|name_end
decl_stmt|,
modifier|*
name|mail_start
decl_stmt|,
modifier|*
name|mail_end
decl_stmt|;
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|s
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|skip
goto|;
name|name_start
operator|=
name|s
operator|.
name|name_begin
expr_stmt|;
name|name_end
operator|=
name|s
operator|.
name|name_end
expr_stmt|;
name|mail_start
operator|=
name|s
operator|.
name|mail_begin
expr_stmt|;
name|mail_end
operator|=
name|s
operator|.
name|mail_end
expr_stmt|;
if|if
condition|(
name|part
operator|==
literal|'N'
operator|||
name|part
operator|==
literal|'E'
condition|)
block|{
comment|/* mailmap lookup */
name|snprintf
argument_list|(
name|person_name
argument_list|,
sizeof|sizeof
argument_list|(
name|person_name
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|name_end
operator|-
name|name_start
argument_list|)
argument_list|,
name|name_start
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|person_mail
argument_list|,
sizeof|sizeof
argument_list|(
name|person_mail
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mail_end
operator|-
name|mail_start
argument_list|)
argument_list|,
name|mail_start
argument_list|)
expr_stmt|;
name|mailmap_name
argument_list|(
name|person_mail
argument_list|,
sizeof|sizeof
argument_list|(
name|person_mail
argument_list|)
argument_list|,
name|person_name
argument_list|,
sizeof|sizeof
argument_list|(
name|person_name
argument_list|)
argument_list|)
expr_stmt|;
name|name_start
operator|=
name|person_name
expr_stmt|;
name|name_end
operator|=
name|name_start
operator|+
name|strlen
argument_list|(
name|person_name
argument_list|)
expr_stmt|;
name|mail_start
operator|=
name|person_mail
expr_stmt|;
name|mail_end
operator|=
name|mail_start
operator|+
name|strlen
argument_list|(
name|person_mail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|part
operator|==
literal|'n'
operator|||
name|part
operator|==
literal|'N'
condition|)
block|{
comment|/* name */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|name_start
argument_list|,
name|name_end
operator|-
name|name_start
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
if|if
condition|(
name|part
operator|==
literal|'e'
operator|||
name|part
operator|==
literal|'E'
condition|)
block|{
comment|/* email */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|mail_start
argument_list|,
name|mail_end
operator|-
name|mail_start
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|.
name|date_begin
condition|)
goto|goto
name|skip
goto|;
name|date
operator|=
name|strtoul
argument_list|(
name|s
operator|.
name|date_begin
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|==
literal|'t'
condition|)
block|{
comment|/* date, UNIX timestamp */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|s
operator|.
name|date_begin
argument_list|,
name|s
operator|.
name|date_end
operator|-
name|s
operator|.
name|date_begin
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
comment|/* parse tz */
name|tz
operator|=
name|strtoul
argument_list|(
name|s
operator|.
name|tz_begin
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|.
name|tz_begin
operator|==
literal|'-'
condition|)
name|tz
operator|=
operator|-
name|tz
expr_stmt|;
switch|switch
condition|(
name|part
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* date */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|dmode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'D'
case|:
comment|/* date, RFC2822 style */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|DATE_RFC2822
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'r'
case|:
comment|/* date, relative */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|DATE_RELATIVE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
case|case
literal|'i'
case|:
comment|/* date, ISO 8601 */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|show_date
argument_list|(
name|date
argument_list|,
name|tz
argument_list|,
name|DATE_ISO8601
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|placeholder_len
return|;
block|}
name|skip
label|:
comment|/* 	 * reading from either a bogus commit, or a reflog entry with 	 * %gn, %ge, etc.; 'sb' cannot be updated, but we still need 	 * to compute a valid return value. 	 */
if|if
condition|(
name|part
operator|==
literal|'n'
operator|||
name|part
operator|==
literal|'e'
operator|||
name|part
operator|==
literal|'t'
operator|||
name|part
operator|==
literal|'d'
operator|||
name|part
operator|==
literal|'D'
operator|||
name|part
operator|==
literal|'r'
operator|||
name|part
operator|==
literal|'i'
condition|)
return|return
name|placeholder_len
return|;
return|return
literal|0
return|;
comment|/* unknown placeholder */
block|}
end_function
begin_struct
DECL|struct|chunk
struct|struct
name|chunk
block|{
DECL|member|off
name|size_t
name|off
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|format_commit_context
struct|struct
name|format_commit_context
block|{
DECL|member|commit
specifier|const
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
DECL|member|pretty_ctx
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pretty_ctx
decl_stmt|;
DECL|member|commit_header_parsed
name|unsigned
name|commit_header_parsed
range|:
literal|1
decl_stmt|;
DECL|member|commit_message_parsed
name|unsigned
name|commit_message_parsed
range|:
literal|1
decl_stmt|;
DECL|member|commit_signature_parsed
name|unsigned
name|commit_signature_parsed
range|:
literal|1
decl_stmt|;
struct|struct
block|{
DECL|member|gpg_output
name|char
modifier|*
name|gpg_output
decl_stmt|;
DECL|member|good_bad
name|char
name|good_bad
decl_stmt|;
DECL|member|signer
name|char
modifier|*
name|signer
decl_stmt|;
block|}
DECL|member|signature
name|signature
struct|;
DECL|member|message
name|char
modifier|*
name|message
decl_stmt|;
DECL|member|width
DECL|member|indent1
DECL|member|indent2
name|size_t
name|width
decl_stmt|,
name|indent1
decl_stmt|,
name|indent2
decl_stmt|;
comment|/* These offsets are relative to the start of the commit message. */
DECL|member|author
name|struct
name|chunk
name|author
decl_stmt|;
DECL|member|committer
name|struct
name|chunk
name|committer
decl_stmt|;
DECL|member|encoding
name|struct
name|chunk
name|encoding
decl_stmt|;
DECL|member|message_off
name|size_t
name|message_off
decl_stmt|;
DECL|member|subject_off
name|size_t
name|subject_off
decl_stmt|;
DECL|member|body_off
name|size_t
name|body_off
decl_stmt|;
comment|/* The following ones are relative to the result struct strbuf. */
DECL|member|abbrev_commit_hash
name|struct
name|chunk
name|abbrev_commit_hash
decl_stmt|;
DECL|member|abbrev_tree_hash
name|struct
name|chunk
name|abbrev_tree_hash
decl_stmt|;
DECL|member|abbrev_parent_hashes
name|struct
name|chunk
name|abbrev_parent_hashes
decl_stmt|;
DECL|member|wrap_start
name|size_t
name|wrap_start
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|add_again
specifier|static
name|int
name|add_again
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|chunk
modifier|*
name|chunk
parameter_list|)
block|{
if|if
condition|(
name|chunk
operator|->
name|len
condition|)
block|{
name|strbuf_adddup
argument_list|(
name|sb
argument_list|,
name|chunk
operator|->
name|off
argument_list|,
name|chunk
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * We haven't seen this chunk before.  Our caller is surely 	 * going to add it the hard way now.  Remember the most likely 	 * start of the to-be-added chunk: the current end of the 	 * struct strbuf. 	 */
name|chunk
operator|->
name|off
operator|=
name|sb
operator|->
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_header
specifier|static
name|void
name|parse_commit_header
parameter_list|(
name|struct
name|format_commit_context
modifier|*
name|context
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|context
operator|->
name|message
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|msg
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|eol
decl_stmt|;
for|for
control|(
name|eol
operator|=
name|i
init|;
name|msg
index|[
name|eol
index|]
operator|&&
name|msg
index|[
name|eol
index|]
operator|!=
literal|'\n'
condition|;
name|eol
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|i
operator|==
name|eol
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"author "
argument_list|)
condition|)
block|{
name|context
operator|->
name|author
operator|.
name|off
operator|=
name|i
operator|+
literal|7
expr_stmt|;
name|context
operator|->
name|author
operator|.
name|len
operator|=
name|eol
operator|-
name|i
operator|-
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"committer "
argument_list|)
condition|)
block|{
name|context
operator|->
name|committer
operator|.
name|off
operator|=
name|i
operator|+
literal|10
expr_stmt|;
name|context
operator|->
name|committer
operator|.
name|len
operator|=
name|eol
operator|-
name|i
operator|-
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|msg
operator|+
name|i
argument_list|,
literal|"encoding "
argument_list|)
condition|)
block|{
name|context
operator|->
name|encoding
operator|.
name|off
operator|=
name|i
operator|+
literal|9
expr_stmt|;
name|context
operator|->
name|encoding
operator|.
name|len
operator|=
name|eol
operator|-
name|i
operator|-
literal|9
expr_stmt|;
block|}
name|i
operator|=
name|eol
expr_stmt|;
block|}
name|context
operator|->
name|message_off
operator|=
name|i
expr_stmt|;
name|context
operator|->
name|commit_header_parsed
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|istitlechar
specifier|static
name|int
name|istitlechar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'_'
return|;
block|}
end_function
begin_function
DECL|function|format_sanitized_subject
specifier|static
name|void
name|format_sanitized_subject
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|size_t
name|trimlen
decl_stmt|;
name|size_t
name|start_len
init|=
name|sb
operator|->
name|len
decl_stmt|;
name|int
name|space
init|=
literal|2
decl_stmt|;
for|for
control|(
init|;
operator|*
name|msg
operator|&&
operator|*
name|msg
operator|!=
literal|'\n'
condition|;
name|msg
operator|++
control|)
block|{
if|if
condition|(
name|istitlechar
argument_list|(
operator|*
name|msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|space
operator|==
literal|1
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
literal|'.'
condition|)
while|while
condition|(
operator|*
operator|(
name|msg
operator|+
literal|1
operator|)
operator|==
literal|'.'
condition|)
name|msg
operator|++
expr_stmt|;
block|}
else|else
name|space
operator||=
literal|1
expr_stmt|;
block|}
comment|/* trim any trailing '.' or '-' characters */
name|trimlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sb
operator|->
name|len
operator|-
name|trimlen
operator|>
name|start_len
operator|&&
operator|(
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
operator|-
name|trimlen
index|]
operator|==
literal|'.'
operator|||
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
operator|-
name|trimlen
index|]
operator|==
literal|'-'
operator|)
condition|)
name|trimlen
operator|++
expr_stmt|;
name|strbuf_remove
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
name|trimlen
argument_list|,
name|trimlen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_subject
specifier|const
name|char
modifier|*
name|format_subject
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|line_separator
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
name|msg
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|msg
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
operator|!
name|linelen
operator|||
name|is_empty_line
argument_list|(
name|line
argument_list|,
operator|&
name|linelen
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|sb
condition|)
continue|continue;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|line_separator
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_message
specifier|static
name|void
name|parse_commit_message
parameter_list|(
name|struct
name|format_commit_context
modifier|*
name|c
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|c
operator|->
name|message
operator|+
name|c
operator|->
name|message_off
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|c
operator|->
name|message
decl_stmt|;
name|msg
operator|=
name|skip_empty_lines
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|c
operator|->
name|subject_off
operator|=
name|msg
operator|-
name|start
expr_stmt|;
name|msg
operator|=
name|format_subject
argument_list|(
name|NULL
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msg
operator|=
name|skip_empty_lines
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|c
operator|->
name|body_off
operator|=
name|msg
operator|-
name|start
expr_stmt|;
name|c
operator|->
name|commit_message_parsed
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_decoration
specifier|static
name|void
name|format_decoration
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|name_decoration
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|" ("
decl_stmt|;
name|load_ref_decorations
argument_list|(
name|DECORATE_SHORT_REFS
argument_list|)
expr_stmt|;
name|d
operator|=
name|lookup_decoration
argument_list|(
operator|&
name|name_decoration
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|", "
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|strbuf_wrap
specifier|static
name|void
name|strbuf_wrap
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|size_t
name|pos
parameter_list|,
name|size_t
name|width
parameter_list|,
name|size_t
name|indent1
parameter_list|,
name|size_t
name|indent2
parameter_list|)
block|{
name|struct
name|strbuf
name|tmp
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|pos
condition|)
name|strbuf_add
argument_list|(
operator|&
name|tmp
argument_list|,
name|sb
operator|->
name|buf
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|strbuf_add_wrapped_text
argument_list|(
operator|&
name|tmp
argument_list|,
name|sb
operator|->
name|buf
operator|+
name|pos
argument_list|,
operator|(
name|int
operator|)
name|indent1
argument_list|,
operator|(
name|int
operator|)
name|indent2
argument_list|,
operator|(
name|int
operator|)
name|width
argument_list|)
expr_stmt|;
name|strbuf_swap
argument_list|(
operator|&
name|tmp
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rewrap_message_tail
specifier|static
name|void
name|rewrap_message_tail
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|format_commit_context
modifier|*
name|c
parameter_list|,
name|size_t
name|new_width
parameter_list|,
name|size_t
name|new_indent1
parameter_list|,
name|size_t
name|new_indent2
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|width
operator|==
name|new_width
operator|&&
name|c
operator|->
name|indent1
operator|==
name|new_indent1
operator|&&
name|c
operator|->
name|indent2
operator|==
name|new_indent2
condition|)
return|return;
if|if
condition|(
name|c
operator|->
name|wrap_start
operator|<
name|sb
operator|->
name|len
condition|)
name|strbuf_wrap
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|wrap_start
argument_list|,
name|c
operator|->
name|width
argument_list|,
name|c
operator|->
name|indent1
argument_list|,
name|c
operator|->
name|indent2
argument_list|)
expr_stmt|;
name|c
operator|->
name|wrap_start
operator|=
name|sb
operator|->
name|len
expr_stmt|;
name|c
operator|->
name|width
operator|=
name|new_width
expr_stmt|;
name|c
operator|->
name|indent1
operator|=
name|new_indent1
expr_stmt|;
name|c
operator|->
name|indent2
operator|=
name|new_indent2
expr_stmt|;
block|}
end_function
begin_struct
specifier|static
struct|struct
block|{
DECL|member|result
name|char
name|result
decl_stmt|;
DECL|member|check
specifier|const
name|char
modifier|*
name|check
decl_stmt|;
block|}
DECL|variable|signature_check
name|signature_check
index|[]
init|=
block|{
block|{
literal|'G'
block|,
literal|": Good signature from "
block|}
block|,
block|{
literal|'B'
block|,
literal|": BAD signature from "
block|}
block|, }
struct|;
end_struct
begin_function
DECL|function|parse_signature_lines
specifier|static
name|void
name|parse_signature_lines
parameter_list|(
name|struct
name|format_commit_context
modifier|*
name|ctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buf
init|=
name|ctx
operator|->
name|signature
operator|.
name|gpg_output
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|signature_check
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|found
init|=
name|strstr
argument_list|(
name|buf
argument_list|,
name|signature_check
index|[
name|i
index|]
operator|.
name|check
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
continue|continue;
name|ctx
operator|->
name|signature
operator|.
name|good_bad
operator|=
name|signature_check
index|[
name|i
index|]
operator|.
name|result
expr_stmt|;
name|found
operator|+=
name|strlen
argument_list|(
name|signature_check
index|[
name|i
index|]
operator|.
name|check
argument_list|)
expr_stmt|;
name|next
operator|=
name|strchrnul
argument_list|(
name|found
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|signature
operator|.
name|signer
operator|=
name|xmemdupz
argument_list|(
name|found
argument_list|,
name|next
operator|-
name|found
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|parse_commit_signature
specifier|static
name|void
name|parse_commit_signature
parameter_list|(
name|struct
name|format_commit_context
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|strbuf
name|payload
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|signature
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|gpg_output
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|status
decl_stmt|;
name|ctx
operator|->
name|commit_signature_parsed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse_signed_commit
argument_list|(
name|ctx
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|payload
argument_list|,
operator|&
name|signature
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
name|status
operator|=
name|verify_signed_buffer
argument_list|(
name|payload
operator|.
name|buf
argument_list|,
name|payload
operator|.
name|len
argument_list|,
name|signature
operator|.
name|buf
argument_list|,
name|signature
operator|.
name|len
argument_list|,
operator|&
name|gpg_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
operator|!
name|gpg_output
operator|.
name|len
condition|)
goto|goto
name|out
goto|;
name|ctx
operator|->
name|signature
operator|.
name|gpg_output
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|gpg_output
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parse_signature_lines
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|out
label|:
name|strbuf_release
argument_list|(
operator|&
name|gpg_output
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|payload
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|signature
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_reflog_person
specifier|static
name|int
name|format_reflog_person
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|char
name|part
parameter_list|,
name|struct
name|reflog_walk_info
modifier|*
name|log
parameter_list|,
name|enum
name|date_mode
name|dmode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ident
decl_stmt|;
if|if
condition|(
operator|!
name|log
condition|)
return|return
literal|2
return|;
name|ident
operator|=
name|get_reflog_ident
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ident
condition|)
return|return
literal|2
return|;
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|part
argument_list|,
name|ident
argument_list|,
name|strlen
argument_list|(
name|ident
argument_list|)
argument_list|,
name|dmode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|format_commit_one
specifier|static
name|size_t
name|format_commit_one
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|format_commit_context
modifier|*
name|c
init|=
name|context
decl_stmt|;
specifier|const
name|struct
name|commit
modifier|*
name|commit
init|=
name|c
operator|->
name|commit
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|c
operator|->
name|message
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
name|int
name|h1
decl_stmt|,
name|h2
decl_stmt|;
comment|/* these are independent of the commit */
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|placeholder
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
specifier|const
name|char
modifier|*
name|begin
init|=
name|placeholder
operator|+
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|strchr
argument_list|(
name|begin
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
name|char
name|color
index|[
name|COLOR_MAXLEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|begin
argument_list|,
literal|"auto,"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|want_color
argument_list|(
name|c
operator|->
name|pretty_ctx
operator|->
name|color
argument_list|)
condition|)
return|return
name|end
operator|-
name|placeholder
operator|+
literal|1
return|;
name|begin
operator|+=
literal|5
expr_stmt|;
block|}
name|color_parse_mem
argument_list|(
name|begin
argument_list|,
name|end
operator|-
name|begin
argument_list|,
literal|"--pretty format"
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|color
argument_list|)
expr_stmt|;
return|return
name|end
operator|-
name|placeholder
operator|+
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"red"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_RED
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"green"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_GREEN
argument_list|)
expr_stmt|;
return|return
literal|6
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"blue"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_BLUE
argument_list|)
expr_stmt|;
return|return
literal|5
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|placeholder
operator|+
literal|1
argument_list|,
literal|"reset"
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|GIT_COLOR_RESET
argument_list|)
expr_stmt|;
return|return
literal|6
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
literal|'n'
case|:
comment|/* newline */
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'x'
case|:
comment|/* %x00 == NUL, %x0a == LF, etc. */
if|if
condition|(
literal|0
operator|<=
operator|(
name|h1
operator|=
name|hexval_table
index|[
literal|0xff
operator|&
name|placeholder
index|[
literal|1
index|]
index|]
operator|)
operator|&&
name|h1
operator|<=
literal|16
operator|&&
literal|0
operator|<=
operator|(
name|h2
operator|=
name|hexval_table
index|[
literal|0xff
operator|&
name|placeholder
index|[
literal|2
index|]
index|]
operator|)
operator|&&
name|h2
operator|<=
literal|16
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
operator|(
name|h1
operator|<<
literal|4
operator|)
operator||
name|h2
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
literal|'w'
case|:
if|if
condition|(
name|placeholder
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
name|unsigned
name|long
name|width
init|=
literal|0
decl_stmt|,
name|indent1
init|=
literal|0
decl_stmt|,
name|indent2
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|placeholder
operator|+
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|end
operator|>
name|start
condition|)
block|{
name|width
operator|=
name|strtoul
argument_list|(
name|start
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|==
literal|','
condition|)
block|{
name|indent1
operator|=
name|strtoul
argument_list|(
name|next
operator|+
literal|1
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|==
literal|','
condition|)
block|{
name|indent2
operator|=
name|strtoul
argument_list|(
name|next
operator|+
literal|1
argument_list|,
operator|&
name|next
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|next
operator|!=
literal|')'
condition|)
return|return
literal|0
return|;
block|}
name|rewrap_message_tail
argument_list|(
name|sb
argument_list|,
name|c
argument_list|,
name|width
argument_list|,
name|indent1
argument_list|,
name|indent2
argument_list|)
expr_stmt|;
return|return
name|end
operator|-
name|placeholder
operator|+
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* these depend on the commit */
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_object
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'H'
case|:
comment|/* commit hash */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'h'
case|:
comment|/* abbreviated commit hash */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_commit_hash
argument_list|)
condition|)
return|return
literal|1
return|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|abbrev_commit_hash
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_commit_hash
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'T'
case|:
comment|/* tree hash */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'t'
case|:
comment|/* abbreviated tree hash */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_tree_hash
argument_list|)
condition|)
return|return
literal|1
return|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|abbrev_tree_hash
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_tree_hash
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'P'
case|:
comment|/* parent hashes */
for|for
control|(
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|commit
operator|->
name|parents
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
literal|'p'
case|:
comment|/* abbreviated parent hashes */
if|if
condition|(
name|add_again
argument_list|(
name|sb
argument_list|,
operator|&
name|c
operator|->
name|abbrev_parent_hashes
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|commit
operator|->
name|parents
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|abbrev_parent_hashes
operator|.
name|len
operator|=
name|sb
operator|->
name|len
operator|-
name|c
operator|->
name|abbrev_parent_hashes
operator|.
name|off
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'m'
case|:
comment|/* left/right/bottom */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|get_revision_mark
argument_list|(
name|NULL
argument_list|,
name|commit
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'d'
case|:
name|format_decoration
argument_list|(
name|sb
argument_list|,
name|commit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'g'
case|:
comment|/* reflog info */
switch|switch
condition|(
name|placeholder
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* reflog selector */
case|case
literal|'D'
case|:
if|if
condition|(
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
condition|)
name|get_reflog_selector
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode_explicit
argument_list|,
operator|(
name|placeholder
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'s'
case|:
comment|/* reflog message */
if|if
condition|(
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
condition|)
name|get_reflog_message
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
return|return
name|format_reflog_person
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|reflog_info
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
comment|/* unknown %g placeholder */
case|case
literal|'N'
case|:
if|if
condition|(
name|c
operator|->
name|pretty_ctx
operator|->
name|show_notes
condition|)
block|{
name|format_display_notes
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|sb
argument_list|,
name|get_log_output_encoding
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|placeholder
index|[
literal|0
index|]
operator|==
literal|'G'
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|commit_signature_parsed
condition|)
name|parse_commit_signature
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'G'
case|:
if|if
condition|(
name|c
operator|->
name|signature
operator|.
name|gpg_output
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|signature
operator|.
name|gpg_output
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
switch|switch
condition|(
name|c
operator|->
name|signature
operator|.
name|good_bad
condition|)
block|{
case|case
literal|'G'
case|:
case|case
literal|'B'
case|:
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|signature
operator|.
name|good_bad
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|c
operator|->
name|signature
operator|.
name|signer
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|c
operator|->
name|signature
operator|.
name|signer
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|2
return|;
block|}
comment|/* For the rest we have to parse the commit header. */
if|if
condition|(
operator|!
name|c
operator|->
name|commit_header_parsed
condition|)
name|parse_commit_header
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* author ... */
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|msg
operator|+
name|c
operator|->
name|author
operator|.
name|off
argument_list|,
name|c
operator|->
name|author
operator|.
name|len
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|)
return|;
case|case
literal|'c'
case|:
comment|/* committer ... */
return|return
name|format_person_part
argument_list|(
name|sb
argument_list|,
name|placeholder
index|[
literal|1
index|]
argument_list|,
name|msg
operator|+
name|c
operator|->
name|committer
operator|.
name|off
argument_list|,
name|c
operator|->
name|committer
operator|.
name|len
argument_list|,
name|c
operator|->
name|pretty_ctx
operator|->
name|date_mode
argument_list|)
return|;
case|case
literal|'e'
case|:
comment|/* encoding */
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|encoding
operator|.
name|off
argument_list|,
name|c
operator|->
name|encoding
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'B'
case|:
comment|/* raw body */
comment|/* message_off is always left at the initial newline */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|message_off
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now we need to parse the commit message. */
if|if
condition|(
operator|!
name|c
operator|->
name|commit_message_parsed
condition|)
name|parse_commit_message
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* subject */
name|format_subject
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|subject_off
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'f'
case|:
comment|/* sanitized subject */
name|format_sanitized_subject
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|subject_off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'b'
case|:
comment|/* body */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|msg
operator|+
name|c
operator|->
name|body_off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* unknown placeholder */
block|}
end_function
begin_function
DECL|function|format_commit_item
specifier|static
name|size_t
name|format_commit_item
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|consumed
decl_stmt|;
name|size_t
name|orig_len
decl_stmt|;
enum|enum
block|{
name|NO_MAGIC
block|,
name|ADD_LF_BEFORE_NON_EMPTY
block|,
name|DEL_LF_BEFORE_EMPTY
block|,
name|ADD_SP_BEFORE_NON_EMPTY
block|}
name|magic
init|=
name|NO_MAGIC
enum|;
switch|switch
condition|(
name|placeholder
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|magic
operator|=
name|DEL_LF_BEFORE_EMPTY
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|magic
operator|=
name|ADD_LF_BEFORE_NON_EMPTY
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|magic
operator|=
name|ADD_SP_BEFORE_NON_EMPTY
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|magic
operator|!=
name|NO_MAGIC
condition|)
name|placeholder
operator|++
expr_stmt|;
name|orig_len
operator|=
name|sb
operator|->
name|len
expr_stmt|;
name|consumed
operator|=
name|format_commit_one
argument_list|(
name|sb
argument_list|,
name|placeholder
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|==
name|NO_MAGIC
condition|)
return|return
name|consumed
return|;
if|if
condition|(
operator|(
name|orig_len
operator|==
name|sb
operator|->
name|len
operator|)
operator|&&
name|magic
operator|==
name|DEL_LF_BEFORE_EMPTY
condition|)
block|{
while|while
condition|(
name|sb
operator|->
name|len
operator|&&
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|orig_len
operator|!=
name|sb
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|magic
operator|==
name|ADD_LF_BEFORE_NON_EMPTY
condition|)
name|strbuf_insert
argument_list|(
name|sb
argument_list|,
name|orig_len
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|magic
operator|==
name|ADD_SP_BEFORE_NON_EMPTY
condition|)
name|strbuf_insert
argument_list|(
name|sb
argument_list|,
name|orig_len
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|consumed
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|userformat_want_item
specifier|static
name|size_t
name|userformat_want_item
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|placeholder
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|userformat_want
modifier|*
name|w
init|=
name|context
decl_stmt|;
if|if
condition|(
operator|*
name|placeholder
operator|==
literal|'+'
operator|||
operator|*
name|placeholder
operator|==
literal|'-'
operator|||
operator|*
name|placeholder
operator|==
literal|' '
condition|)
name|placeholder
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|placeholder
condition|)
block|{
case|case
literal|'N'
case|:
name|w
operator|->
name|notes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|userformat_find_requirements
name|void
name|userformat_find_requirements
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|struct
name|userformat_want
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|strbuf
name|dummy
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|fmt
condition|)
block|{
if|if
condition|(
operator|!
name|user_format
condition|)
return|return;
name|fmt
operator|=
name|user_format
expr_stmt|;
block|}
name|strbuf_expand
argument_list|(
operator|&
name|dummy
argument_list|,
name|fmt
argument_list|,
name|userformat_want_item
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|format_commit_message
name|void
name|format_commit_message
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pretty_ctx
parameter_list|)
block|{
name|struct
name|format_commit_context
name|context
decl_stmt|;
specifier|static
specifier|const
name|char
name|utf8
index|[]
init|=
literal|"UTF-8"
decl_stmt|;
specifier|const
name|char
modifier|*
name|output_enc
init|=
name|pretty_ctx
operator|->
name|output_encoding
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|commit
operator|=
name|commit
expr_stmt|;
name|context
operator|.
name|pretty_ctx
operator|=
name|pretty_ctx
expr_stmt|;
name|context
operator|.
name|wrap_start
operator|=
name|sb
operator|->
name|len
expr_stmt|;
name|context
operator|.
name|message
operator|=
name|commit
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|output_enc
condition|)
block|{
name|char
modifier|*
name|enc
init|=
name|get_header
argument_list|(
name|commit
argument_list|,
literal|"encoding"
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|enc
condition|?
name|enc
else|:
name|utf8
argument_list|,
name|output_enc
argument_list|)
condition|)
block|{
name|context
operator|.
name|message
operator|=
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|output_enc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|.
name|message
condition|)
name|context
operator|.
name|message
operator|=
name|commit
operator|->
name|buffer
expr_stmt|;
block|}
name|free
argument_list|(
name|enc
argument_list|)
expr_stmt|;
block|}
name|strbuf_expand
argument_list|(
name|sb
argument_list|,
name|format
argument_list|,
name|format_commit_item
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|rewrap_message_tail
argument_list|(
name|sb
argument_list|,
operator|&
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|message
operator|!=
name|commit
operator|->
name|buffer
condition|)
name|free
argument_list|(
name|context
operator|.
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|context
operator|.
name|signature
operator|.
name|gpg_output
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|context
operator|.
name|signature
operator|.
name|signer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_header
specifier|static
name|void
name|pp_header
parameter_list|(
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|parents_shown
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
operator|*
name|msg_p
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
operator|*
name|msg_p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
return|return;
operator|*
name|msg_p
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
name|linelen
operator|==
literal|1
condition|)
comment|/* End of header */
return|return;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_RAW
condition|)
block|{
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"parent "
argument_list|)
condition|)
block|{
if|if
condition|(
name|linelen
operator|!=
literal|48
condition|)
name|die
argument_list|(
literal|"bad parent line in commit"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|parents_shown
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
decl_stmt|;
name|int
name|num
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|commit
operator|->
name|parents
operator|,
name|num
operator|=
literal|0
init|;
name|parent
condition|;
name|parent
operator|=
name|parent
operator|->
name|next
operator|,
name|num
operator|++
control|)
empty_stmt|;
comment|/* with enough slop */
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|num
operator|*
literal|50
operator|+
literal|20
argument_list|)
expr_stmt|;
name|add_merge_info
argument_list|(
name|pp
argument_list|,
name|sb
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|parents_shown
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * MEDIUM == DEFAULT shows only author with dates. 		 * FULL shows both authors but not dates. 		 * FULLER shows both authors and dates. 		 */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"author "
argument_list|)
condition|)
block|{
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|80
argument_list|)
expr_stmt|;
name|pp_user_info
argument_list|(
name|pp
argument_list|,
literal|"Author"
argument_list|,
name|sb
argument_list|,
name|line
operator|+
literal|7
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"committer "
argument_list|)
operator|&&
operator|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_FULL
operator|||
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|)
block|{
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
literal|80
argument_list|)
expr_stmt|;
name|pp_user_info
argument_list|(
name|pp
argument_list|,
literal|"Commit"
argument_list|,
name|sb
argument_list|,
name|line
operator|+
literal|10
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|pp_title_line
name|void
name|pp_title_line
parameter_list|(
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|int
name|need_8bit_cte
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|max_length
init|=
literal|78
decl_stmt|;
comment|/* per rfc2047 */
name|struct
name|strbuf
name|title
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|title
argument_list|,
literal|80
argument_list|)
expr_stmt|;
operator|*
name|msg_p
operator|=
name|format_subject
argument_list|(
operator|&
name|title
argument_list|,
operator|*
name|msg_p
argument_list|,
name|pp
operator|->
name|preserve_subject
condition|?
literal|"\n"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|len
operator|+
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|subject
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|pp
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_rfc2047_encoding
argument_list|(
name|title
operator|.
name|buf
argument_list|,
name|title
operator|.
name|len
argument_list|,
name|RFC2047_SUBJECT
argument_list|)
condition|)
name|add_rfc2047
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|buf
argument_list|,
name|title
operator|.
name|len
argument_list|,
name|encoding
argument_list|,
name|RFC2047_SUBJECT
argument_list|)
expr_stmt|;
else|else
name|strbuf_add_wrapped_bytes
argument_list|(
name|sb
argument_list|,
name|title
operator|.
name|buf
argument_list|,
name|title
operator|.
name|len
argument_list|,
operator|-
name|last_line_length
argument_list|(
name|sb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|max_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addbuf
argument_list|(
name|sb
argument_list|,
operator|&
name|title
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_8bit_cte
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|header_fmt
init|=
literal|"MIME-Version: 1.0\n"
literal|"Content-Type: text/plain; charset=%s\n"
literal|"Content-Transfer-Encoding: 8bit\n"
decl_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|header_fmt
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|after_subject
condition|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|pp
operator|->
name|after_subject
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|title
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_remainder
name|void
name|pp_remainder
parameter_list|(
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|msg_p
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
operator|*
name|msg_p
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|line
argument_list|)
decl_stmt|;
operator|*
name|msg_p
operator|+=
name|linelen
expr_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
break|break;
if|if
condition|(
name|is_empty_line
argument_list|(
name|line
argument_list|,
operator|&
name|linelen
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_SHORT
condition|)
break|break;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|linelen
operator|+
name|indent
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
condition|)
block|{
name|memset
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|sb
operator|->
name|len
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|+
name|indent
argument_list|)
expr_stmt|;
block|}
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|reencode_commit_message
name|char
modifier|*
name|reencode_commit_message
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|encoding_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
name|encoding
operator|=
name|get_log_output_encoding
argument_list|()
expr_stmt|;
if|if
condition|(
name|encoding_p
condition|)
operator|*
name|encoding_p
operator|=
name|encoding
expr_stmt|;
return|return
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|encoding
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|pretty_print_commit
name|void
name|pretty_print_commit
parameter_list|(
specifier|const
name|struct
name|pretty_print_context
modifier|*
name|pp
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|unsigned
name|long
name|beginning_of_body
decl_stmt|;
name|int
name|indent
init|=
literal|4
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|commit
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|reencoded
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
name|int
name|need_8bit_cte
init|=
name|pp
operator|->
name|need_8bit_cte
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_USERFORMAT
condition|)
block|{
name|format_commit_message
argument_list|(
name|commit
argument_list|,
name|user_format
argument_list|,
name|sb
argument_list|,
name|pp
argument_list|)
expr_stmt|;
return|return;
block|}
name|reencoded
operator|=
name|reencode_commit_message
argument_list|(
name|commit
argument_list|,
operator|&
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|reencoded
condition|)
block|{
name|msg
operator|=
name|reencoded
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|||
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
name|indent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We need to check and emit Content-type: to mark it 	 * as 8-bit if we haven't done so. 	 */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
name|need_8bit_cte
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|,
name|in_body
decl_stmt|;
for|for
control|(
name|in_body
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|msg
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|in_body
condition|)
block|{
comment|/* author could be non 7-bit ASCII but 				 * the log may be so; skip over the 				 * header part first. 				 */
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|&&
name|msg
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|in_body
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|need_8bit_cte
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|pp_header
argument_list|(
name|pp
argument_list|,
name|encoding
argument_list|,
name|commit
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
operator|&&
operator|!
name|pp
operator|->
name|subject
condition|)
block|{
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Skip excess blank lines at the beginning of body, if any... */
name|msg
operator|=
name|skip_empty_lines
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* These formats treat the title line specially. */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|||
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
name|pp_title_line
argument_list|(
name|pp
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|,
name|encoding
argument_list|,
name|need_8bit_cte
argument_list|)
expr_stmt|;
name|beginning_of_body
operator|=
name|sb
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|pp_remainder
argument_list|(
name|pp
argument_list|,
operator|&
name|msg
argument_list|,
name|sb
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|strbuf_rtrim
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Make sure there is an EOLN for the non-oneline case */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* 	 * The caller may append additional body text in e-mail 	 * format.  Make sure we did not strip the blank line 	 * between the header and the body. 	 */
if|if
condition|(
name|pp
operator|->
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
name|sb
operator|->
name|len
operator|<=
name|beginning_of_body
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|show_notes
condition|)
name|format_display_notes
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|sb
argument_list|,
name|encoding
argument_list|,
name|NOTES_SHOW_HEADER
operator||
name|NOTES_INDENT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reencoded
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pp_commit_easy
name|void
name|pp_commit_easy
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|pretty_print_context
name|pp
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pp
operator|.
name|fmt
operator|=
name|fmt
expr_stmt|;
name|pretty_print_commit
argument_list|(
operator|&
name|pp
argument_list|,
name|commit
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
