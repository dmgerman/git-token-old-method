begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"sideband.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"list-objects.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"sigchain.h"
end_include
begin_include
include|#
directive|include
file|"version.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_decl_stmt
DECL|variable|upload_pack_usage
specifier|static
specifier|const
name|char
name|upload_pack_usage
index|[]
init|=
literal|"git upload-pack [--strict] [--timeout=<n>]<dir>"
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* bits #0..7 in revision.h, #8..10 in commit.c */
end_comment
begin_define
DECL|macro|THEY_HAVE
define|#
directive|define
name|THEY_HAVE
value|(1u<< 11)
end_define
begin_define
DECL|macro|OUR_REF
define|#
directive|define
name|OUR_REF
value|(1u<< 12)
end_define
begin_define
DECL|macro|WANTED
define|#
directive|define
name|WANTED
value|(1u<< 13)
end_define
begin_define
DECL|macro|COMMON_KNOWN
define|#
directive|define
name|COMMON_KNOWN
value|(1u<< 14)
end_define
begin_define
DECL|macro|REACHABLE
define|#
directive|define
name|REACHABLE
value|(1u<< 15)
end_define
begin_define
DECL|macro|SHALLOW
define|#
directive|define
name|SHALLOW
value|(1u<< 16)
end_define
begin_define
DECL|macro|NOT_SHALLOW
define|#
directive|define
name|NOT_SHALLOW
value|(1u<< 17)
end_define
begin_define
DECL|macro|CLIENT_SHALLOW
define|#
directive|define
name|CLIENT_SHALLOW
value|(1u<< 18)
end_define
begin_define
DECL|macro|HIDDEN_REF
define|#
directive|define
name|HIDDEN_REF
value|(1u<< 19)
end_define
begin_decl_stmt
DECL|variable|oldest_have
specifier|static
name|unsigned
name|long
name|oldest_have
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|multi_ack
specifier|static
name|int
name|multi_ack
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_done
specifier|static
name|int
name|no_done
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_thin_pack
DECL|variable|use_ofs_delta
DECL|variable|use_include_tag
specifier|static
name|int
name|use_thin_pack
decl_stmt|,
name|use_ofs_delta
decl_stmt|,
name|use_include_tag
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_progress
DECL|variable|daemon_mode
specifier|static
name|int
name|no_progress
decl_stmt|,
name|daemon_mode
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allow_tip_sha1_in_want
specifier|static
name|int
name|allow_tip_sha1_in_want
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|shallow_nr
specifier|static
name|int
name|shallow_nr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|have_obj
specifier|static
name|struct
name|object_array
name|have_obj
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|want_obj
specifier|static
name|struct
name|object_array
name|want_obj
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|extra_edge_obj
specifier|static
name|struct
name|object_array
name|extra_edge_obj
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|timeout
specifier|static
name|unsigned
name|int
name|timeout
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* 0 for no sideband,  * otherwise maximum packet size (up to 65520 bytes).  */
end_comment
begin_decl_stmt
DECL|variable|use_sideband
specifier|static
name|int
name|use_sideband
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|debug_fd
specifier|static
name|int
name|debug_fd
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|advertise_refs
specifier|static
name|int
name|advertise_refs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|stateless_rpc
specifier|static
name|int
name|stateless_rpc
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|reset_timeout
specifier|static
name|void
name|reset_timeout
parameter_list|(
name|void
parameter_list|)
block|{
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|strip
specifier|static
name|int
name|strip
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|&&
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|send_client_data
specifier|static
name|ssize_t
name|send_client_data
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|ssize_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|use_sideband
condition|)
return|return
name|send_sideband
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
name|data
argument_list|,
name|sz
argument_list|,
name|use_sideband
argument_list|)
return|;
if|if
condition|(
name|fd
operator|==
literal|3
condition|)
comment|/* emergency quit */
name|fd
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|fd
operator|==
literal|2
condition|)
block|{
comment|/* XXX: are we happy to lose stuff here? */
name|xwrite
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
block|}
return|return
name|safe_write
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|pack_pipe
specifier|static
name|FILE
modifier|*
name|pack_pipe
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|show_commit
specifier|static
name|void
name|show_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|BOUNDARY
condition|)
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|pack_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|pack_pipe
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"broken output pipe"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|pack_pipe
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pack_pipe
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|commit
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_object
specifier|static
name|void
name|show_object
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
specifier|const
name|struct
name|name_path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|show_object_with_name
argument_list|(
name|pack_pipe
argument_list|,
name|obj
argument_list|,
name|path
argument_list|,
name|component
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_edge
specifier|static
name|void
name|show_edge
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|fprintf
argument_list|(
name|pack_pipe
argument_list|,
literal|"-%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|do_rev_list
specifier|static
name|int
name|do_rev_list
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|rev_info
name|revs
decl_stmt|;
name|pack_pipe
operator|=
name|xfdopen
argument_list|(
name|out
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|revs
operator|.
name|tag_objects
operator|=
literal|1
expr_stmt|;
name|revs
operator|.
name|tree_objects
operator|=
literal|1
expr_stmt|;
name|revs
operator|.
name|blob_objects
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|use_thin_pack
condition|)
name|revs
operator|.
name|edge_hint
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
comment|/* why??? */
name|o
operator|->
name|flags
operator|&=
operator|~
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|have_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|have_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
name|o
operator|->
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
literal|"revision walk setup failed"
argument_list|)
expr_stmt|;
name|mark_edges_uninteresting
argument_list|(
name|revs
operator|.
name|commits
argument_list|,
operator|&
name|revs
argument_list|,
name|show_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_thin_pack
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_edge_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|pack_pipe
argument_list|,
literal|"-%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|extra_edge_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|traverse_commit_list
argument_list|(
operator|&
name|revs
argument_list|,
name|show_commit
argument_list|,
name|show_object
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pack_pipe
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pack_pipe
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|create_pack_file
specifier|static
name|void
name|create_pack_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|async
name|rev_list
decl_stmt|;
name|struct
name|child_process
name|pack_objects
decl_stmt|;
name|char
name|data
index|[
literal|8193
index|]
decl_stmt|,
name|progress
index|[
literal|128
index|]
decl_stmt|;
name|char
name|abort_msg
index|[]
init|=
literal|"aborting due to possible repository "
literal|"corruption on the remote side."
decl_stmt|;
name|int
name|buffered
init|=
operator|-
literal|1
decl_stmt|;
name|ssize_t
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|10
index|]
decl_stmt|;
name|int
name|arg
init|=
literal|0
decl_stmt|;
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"pack-objects"
expr_stmt|;
if|if
condition|(
operator|!
name|shallow_nr
condition|)
block|{
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--revs"
expr_stmt|;
if|if
condition|(
name|use_thin_pack
condition|)
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--thin"
expr_stmt|;
block|}
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--stdout"
expr_stmt|;
if|if
condition|(
operator|!
name|no_progress
condition|)
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--progress"
expr_stmt|;
if|if
condition|(
name|use_ofs_delta
condition|)
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--delta-base-offset"
expr_stmt|;
if|if
condition|(
name|use_include_tag
condition|)
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--include-tag"
expr_stmt|;
name|argv
index|[
name|arg
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pack_objects
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pack_objects
argument_list|)
argument_list|)
expr_stmt|;
name|pack_objects
operator|.
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|pack_objects
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|pack_objects
operator|.
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|pack_objects
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|pack_objects
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|pack_objects
argument_list|)
condition|)
name|die
argument_list|(
literal|"git upload-pack: unable to fork git-pack-objects"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shallow_nr
condition|)
block|{
name|memset
argument_list|(
operator|&
name|rev_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rev_list
argument_list|)
argument_list|)
expr_stmt|;
name|rev_list
operator|.
name|proc
operator|=
name|do_rev_list
expr_stmt|;
name|rev_list
operator|.
name|out
operator|=
name|pack_objects
operator|.
name|in
expr_stmt|;
if|if
condition|(
name|start_async
argument_list|(
operator|&
name|rev_list
argument_list|)
condition|)
name|die
argument_list|(
literal|"git upload-pack: unable to fork git-rev-list"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FILE
modifier|*
name|pipe_fd
init|=
name|xfdopen
argument_list|(
name|pack_objects
operator|.
name|in
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|pipe_fd
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipe_fd
argument_list|,
literal|"--not\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|have_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|pipe_fd
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|have_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipe_fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pipe_fd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pipe_fd
argument_list|)
expr_stmt|;
block|}
comment|/* We read from pack_objects.err to capture stderr output for 	 * progress bar, and pack_objects.out to capture the pack data. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|pollfd
name|pfd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pe
decl_stmt|,
name|pu
decl_stmt|,
name|pollsize
decl_stmt|;
name|reset_timeout
argument_list|()
expr_stmt|;
name|pollsize
operator|=
literal|0
expr_stmt|;
name|pe
operator|=
name|pu
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pack_objects
operator|.
name|out
condition|)
block|{
name|pfd
index|[
name|pollsize
index|]
operator|.
name|fd
operator|=
name|pack_objects
operator|.
name|out
expr_stmt|;
name|pfd
index|[
name|pollsize
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pu
operator|=
name|pollsize
expr_stmt|;
name|pollsize
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|pack_objects
operator|.
name|err
condition|)
block|{
name|pfd
index|[
name|pollsize
index|]
operator|.
name|fd
operator|=
name|pack_objects
operator|.
name|err
expr_stmt|;
name|pfd
index|[
name|pollsize
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pe
operator|=
name|pollsize
expr_stmt|;
name|pollsize
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pollsize
condition|)
break|break;
if|if
condition|(
name|poll
argument_list|(
name|pfd
argument_list|,
name|pollsize
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|error
argument_list|(
literal|"poll failed, resuming: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
literal|0
operator|<=
name|pe
operator|&&
operator|(
name|pfd
index|[
name|pe
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLIN
operator||
name|POLLHUP
operator|)
operator|)
condition|)
block|{
comment|/* Status ready; we ship that in the side-band 			 * or dump to the standard error. 			 */
name|sz
operator|=
name|xread
argument_list|(
name|pack_objects
operator|.
name|err
argument_list|,
name|progress
argument_list|,
sizeof|sizeof
argument_list|(
name|progress
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sz
condition|)
name|send_client_data
argument_list|(
literal|2
argument_list|,
name|progress
argument_list|,
name|sz
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pack_objects
operator|.
name|err
argument_list|)
expr_stmt|;
name|pack_objects
operator|.
name|err
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
comment|/* give priority to status messages */
continue|continue;
block|}
if|if
condition|(
literal|0
operator|<=
name|pu
operator|&&
operator|(
name|pfd
index|[
name|pu
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLIN
operator||
name|POLLHUP
operator|)
operator|)
condition|)
block|{
comment|/* Data ready; we keep the last byte to ourselves 			 * in case we detect broken rev-list, so that we 			 * can leave the stream corrupted.  This is 			 * unfortunate -- unpack-objects would happily 			 * accept a valid packdata with trailing garbage, 			 * so appending garbage after we pass all the 			 * pack data is not good enough to signal 			 * breakage to downstream. 			 */
name|char
modifier|*
name|cp
init|=
name|data
decl_stmt|;
name|ssize_t
name|outsz
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|buffered
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|buffered
expr_stmt|;
name|outsz
operator|++
expr_stmt|;
block|}
name|sz
operator|=
name|xread
argument_list|(
name|pack_objects
operator|.
name|out
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|outsz
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sz
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pack_objects
operator|.
name|out
argument_list|)
expr_stmt|;
name|pack_objects
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
name|sz
operator|+=
name|outsz
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|sz
condition|)
block|{
name|buffered
operator|=
name|data
index|[
name|sz
operator|-
literal|1
index|]
operator|&
literal|0xFF
expr_stmt|;
name|sz
operator|--
expr_stmt|;
block|}
else|else
name|buffered
operator|=
operator|-
literal|1
expr_stmt|;
name|sz
operator|=
name|send_client_data
argument_list|(
literal|1
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|pack_objects
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"git upload-pack: git-pack-objects died with error."
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|shallow_nr
operator|&&
name|finish_async
argument_list|(
operator|&
name|rev_list
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* error was already reported */
comment|/* flush the data */
if|if
condition|(
literal|0
operator|<=
name|buffered
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|buffered
expr_stmt|;
name|sz
operator|=
name|send_client_data
argument_list|(
literal|1
argument_list|,
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"flushed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_sideband
condition|)
name|packet_flush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|send_client_data
argument_list|(
literal|3
argument_list|,
name|abort_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|abort_msg
argument_list|)
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"git upload-pack: %s"
argument_list|,
name|abort_msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|got_sha1
specifier|static
name|int
name|got_sha1
parameter_list|(
name|char
modifier|*
name|hex
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|int
name|we_knew_they_have
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|hex
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"git upload-pack: expected SHA1 object, got '%s'"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|o
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
name|die
argument_list|(
literal|"oops (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|THEY_HAVE
condition|)
name|we_knew_they_have
operator|=
literal|1
expr_stmt|;
else|else
name|o
operator|->
name|flags
operator||=
name|THEY_HAVE
expr_stmt|;
if|if
condition|(
operator|!
name|oldest_have
operator|||
operator|(
name|commit
operator|->
name|date
operator|<
name|oldest_have
operator|)
condition|)
name|oldest_have
operator|=
name|commit
operator|->
name|date
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|THEY_HAVE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|we_knew_they_have
condition|)
block|{
name|add_object_array
argument_list|(
name|o
argument_list|,
name|NULL
argument_list|,
operator|&
name|have_obj
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|reachable
specifier|static
name|int
name|reachable
parameter_list|(
name|struct
name|commit
modifier|*
name|want
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|work
init|=
name|NULL
decl_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|want
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
while|while
condition|(
name|work
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|work
operator|->
name|next
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|work
operator|->
name|item
decl_stmt|;
name|free
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|work
operator|=
name|list
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|THEY_HAVE
condition|)
block|{
name|want
operator|->
name|object
operator|.
name|flags
operator||=
name|COMMON_KNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_object
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|REACHABLE
condition|)
continue|continue;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|REACHABLE
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|date
operator|<
name|oldest_have
condition|)
continue|continue;
for|for
control|(
name|list
operator|=
name|commit
operator|->
name|parents
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|list
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|REACHABLE
operator|)
condition|)
name|commit_list_insert_by_date
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|want
operator|->
name|object
operator|.
name|flags
operator||=
name|REACHABLE
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|want
argument_list|,
name|REACHABLE
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
operator|(
name|want
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON_KNOWN
operator|)
return|;
block|}
end_function
begin_function
DECL|function|ok_to_give_up
specifier|static
name|int
name|ok_to_give_up
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|have_obj
operator|.
name|nr
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|want
init|=
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|want
operator|->
name|flags
operator|&
name|COMMON_KNOWN
condition|)
continue|continue;
name|want
operator|=
name|deref_tag
argument_list|(
name|want
argument_list|,
literal|"a want line"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|want
operator|||
name|want
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
comment|/* no way to tell if this is reachable by 			 * looking at the ancestry chain alone, so 			 * leave a note to ourselves not to worry about 			 * this object anymore. 			 */
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|->
name|flags
operator||=
name|COMMON_KNOWN
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|reachable
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|want
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|get_common_commits
specifier|static
name|int
name|get_common_commits
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|last_hex
index|[
literal|41
index|]
decl_stmt|;
name|int
name|got_common
init|=
literal|0
decl_stmt|;
name|int
name|got_other
init|=
literal|0
decl_stmt|;
name|int
name|sent_ready
init|=
literal|0
decl_stmt|;
name|save_commit_buffer
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|len
init|=
name|packet_read_line
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
decl_stmt|;
name|reset_timeout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
if|if
condition|(
name|multi_ack
operator|==
literal|2
operator|&&
name|got_common
operator|&&
operator|!
name|got_other
operator|&&
name|ok_to_give_up
argument_list|()
condition|)
block|{
name|sent_ready
operator|=
literal|1
expr_stmt|;
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s ready\n"
argument_list|,
name|last_hex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_obj
operator|.
name|nr
operator|==
literal|0
operator|||
name|multi_ack
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"NAK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_done
operator|&&
name|sent_ready
condition|)
block|{
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s\n"
argument_list|,
name|last_hex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|stateless_rpc
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|got_common
operator|=
literal|0
expr_stmt|;
name|got_other
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|strip
argument_list|(
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"have "
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|got_sha1
argument_list|(
name|line
operator|+
literal|5
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* they have what we do not */
name|got_other
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|multi_ack
operator|&&
name|ok_to_give_up
argument_list|()
condition|)
block|{
specifier|const
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|multi_ack
operator|==
literal|2
condition|)
block|{
name|sent_ready
operator|=
literal|1
expr_stmt|;
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s ready\n"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
block|}
else|else
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s continue\n"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|got_common
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|last_hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
literal|41
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_ack
operator|==
literal|2
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s common\n"
argument_list|,
name|last_hex
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|multi_ack
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s continue\n"
argument_list|,
name|last_hex
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|have_obj
operator|.
name|nr
operator|==
literal|1
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s\n"
argument_list|,
name|last_hex
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"done"
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_obj
operator|.
name|nr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|multi_ack
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s\n"
argument_list|,
name|last_hex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"NAK\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|die
argument_list|(
literal|"git upload-pack: expected SHA1 list, got '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|is_our_ref
specifier|static
name|int
name|is_our_ref
parameter_list|(
name|struct
name|object
modifier|*
name|o
parameter_list|)
block|{
return|return
name|o
operator|->
name|flags
operator|&
operator|(
operator|(
name|allow_tip_sha1_in_want
condition|?
name|HIDDEN_REF
else|:
literal|0
operator|)
operator||
name|OUR_REF
operator|)
return|;
block|}
end_function
begin_function
DECL|function|check_non_tip
specifier|static
name|void
name|check_non_tip
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|argv
index|[]
init|=
block|{
literal|"rev-list"
block|,
literal|"--stdin"
block|,
name|NULL
block|, 	}
decl_stmt|;
specifier|static
name|struct
name|child_process
name|cmd
decl_stmt|;
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|char
name|namebuf
index|[
literal|42
index|]
decl_stmt|;
comment|/* ^ + SHA-1 + LF */
name|int
name|i
decl_stmt|;
comment|/* In the normal in-process case non-tip request can never happen */
if|if
condition|(
operator|!
name|stateless_rpc
condition|)
goto|goto
name|error
goto|;
name|cmd
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|cmd
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|no_stderr
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|cmd
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|cmd
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * If rev-list --stdin encounters an unknown commit, it 	 * terminates, which will cause SIGPIPE in the write loop 	 * below. 	 */
name|sigchain_push
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|namebuf
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|namebuf
index|[
literal|41
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|get_max_object_index
argument_list|()
init|;
literal|0
operator|<
name|i
condition|;
control|)
block|{
name|o
operator|=
name|get_indexed_object
argument_list|(
operator|--
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_our_ref
argument_list|(
name|o
argument_list|)
condition|)
continue|continue;
name|memcpy
argument_list|(
name|namebuf
operator|+
literal|1
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|sha1
argument_list|)
argument_list|,
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|cmd
operator|.
name|in
argument_list|,
name|namebuf
argument_list|,
literal|42
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
name|namebuf
index|[
literal|40
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|=
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
expr_stmt|;
if|if
condition|(
name|is_our_ref
argument_list|(
name|o
argument_list|)
condition|)
continue|continue;
name|memcpy
argument_list|(
name|namebuf
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|sha1
argument_list|)
argument_list|,
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|cmd
operator|.
name|in
argument_list|,
name|namebuf
argument_list|,
literal|41
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
name|close
argument_list|(
name|cmd
operator|.
name|in
argument_list|)
expr_stmt|;
name|sigchain_pop
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
comment|/* 	 * The commits out of the rev-list are not ancestors of 	 * our ref. 	 */
name|i
operator|=
name|read_in_full
argument_list|(
name|cmd
operator|.
name|out
argument_list|,
name|namebuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
goto|goto
name|error
goto|;
name|close
argument_list|(
name|cmd
operator|.
name|out
argument_list|)
expr_stmt|;
comment|/* 	 * rev-list may have died by encountering a bad commit 	 * in the history, in which case we do want to bail out 	 * even when it showed no commit. 	 */
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|cmd
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* All the non-tip ones are ancestors of what we advertised */
return|return;
name|error
label|:
comment|/* Pick one of them (we know there at least is one) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|=
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
expr_stmt|;
if|if
condition|(
operator|!
name|is_our_ref
argument_list|(
name|o
argument_list|)
condition|)
name|die
argument_list|(
literal|"git upload-pack: not our ref %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|receive_needs
specifier|static
name|void
name|receive_needs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|object_array
name|shallows
init|=
name|OBJECT_ARRAY_INIT
decl_stmt|;
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|has_non_tip
init|=
literal|0
decl_stmt|;
name|shallow_nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_fd
condition|)
name|write_str_in_full
argument_list|(
name|debug_fd
argument_list|,
literal|"#S\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
specifier|const
name|char
modifier|*
name|features
decl_stmt|;
name|unsigned
name|char
name|sha1_buf
index|[
literal|20
index|]
decl_stmt|;
name|len
operator|=
name|packet_read_line
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|reset_timeout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
if|if
condition|(
name|debug_fd
condition|)
name|write_in_full
argument_list|(
name|debug_fd
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"shallow "
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|object
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|line
operator|+
literal|8
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid shallow line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|object
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
name|die
argument_list|(
literal|"did not find object for %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"invalid shallow object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator||=
name|CLIENT_SHALLOW
expr_stmt|;
name|add_object_array
argument_list|(
name|object
argument_list|,
name|NULL
argument_list|,
operator|&
name|shallows
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"deepen "
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|depth
operator|=
name|strtol
argument_list|(
name|line
operator|+
literal|7
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|line
operator|+
literal|7
operator|||
name|depth
operator|<=
literal|0
condition|)
name|die
argument_list|(
literal|"Invalid deepen: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"want "
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|5
argument_list|,
name|sha1_buf
argument_list|)
condition|)
name|die
argument_list|(
literal|"git upload-pack: protocol error, "
literal|"expected to get sha, not '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|features
operator|=
name|line
operator|+
literal|45
expr_stmt|;
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"multi_ack_detailed"
argument_list|)
condition|)
name|multi_ack
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"multi_ack"
argument_list|)
condition|)
name|multi_ack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"no-done"
argument_list|)
condition|)
name|no_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"thin-pack"
argument_list|)
condition|)
name|use_thin_pack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"ofs-delta"
argument_list|)
condition|)
name|use_ofs_delta
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"side-band-64k"
argument_list|)
condition|)
name|use_sideband
operator|=
name|LARGE_PACKET_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"side-band"
argument_list|)
condition|)
name|use_sideband
operator|=
name|DEFAULT_PACKET_MAX
expr_stmt|;
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"no-progress"
argument_list|)
condition|)
name|no_progress
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse_feature_request
argument_list|(
name|features
argument_list|,
literal|"include-tag"
argument_list|)
condition|)
name|use_include_tag
operator|=
literal|1
expr_stmt|;
name|o
operator|=
name|parse_object
argument_list|(
name|sha1_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
name|die
argument_list|(
literal|"git upload-pack: not our ref %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|WANTED
operator|)
condition|)
block|{
name|o
operator|->
name|flags
operator||=
name|WANTED
expr_stmt|;
if|if
condition|(
operator|!
name|is_our_ref
argument_list|(
name|o
argument_list|)
condition|)
name|has_non_tip
operator|=
literal|1
expr_stmt|;
name|add_object_array
argument_list|(
name|o
argument_list|,
name|NULL
argument_list|,
operator|&
name|want_obj
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_fd
condition|)
name|write_str_in_full
argument_list|(
name|debug_fd
argument_list|,
literal|"#E\n"
argument_list|)
expr_stmt|;
comment|/* 	 * We have sent all our refs already, and the other end 	 * should have chosen out of them. When we are operating 	 * in the stateless RPC mode, however, their choice may 	 * have been based on the set of older refs advertised 	 * by another process that handled the initial request. 	 */
if|if
condition|(
name|has_non_tip
condition|)
name|check_non_tip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|use_sideband
operator|&&
name|daemon_mode
condition|)
name|no_progress
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
operator|&&
name|shallows
operator|.
name|nr
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|backup
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|INFINITE_DEPTH
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shallows
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
name|shallows
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
name|object
operator|->
name|flags
operator||=
name|NOT_SHALLOW
expr_stmt|;
block|}
else|else
name|backup
operator|=
name|result
operator|=
name|get_shallow_commits
argument_list|(
operator|&
name|want_obj
argument_list|,
name|depth
argument_list|,
name|SHALLOW
argument_list|,
name|NOT_SHALLOW
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
operator|&
name|result
operator|->
name|item
operator|->
name|object
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|object
operator|->
name|flags
operator|&
operator|(
name|CLIENT_SHALLOW
operator||
name|NOT_SHALLOW
operator|)
operator|)
condition|)
block|{
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"shallow %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|register_shallow
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|shallow_nr
operator|++
expr_stmt|;
block|}
name|result
operator|=
name|result
operator|->
name|next
expr_stmt|;
block|}
name|free_commit_list
argument_list|(
name|backup
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shallows
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
name|shallows
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|flags
operator|&
name|NOT_SHALLOW
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"unshallow %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator|&=
operator|~
name|CLIENT_SHALLOW
expr_stmt|;
comment|/* make sure the real parents are parsed */
name|unregister_shallow
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|object
operator|->
name|parsed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid commit"
argument_list|)
expr_stmt|;
name|parents
operator|=
operator|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
operator|)
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|add_object_array
argument_list|(
operator|&
name|parents
operator|->
name|item
operator|->
name|object
argument_list|,
name|NULL
argument_list|,
operator|&
name|want_obj
argument_list|)
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
name|add_object_array
argument_list|(
name|object
argument_list|,
name|NULL
argument_list|,
operator|&
name|extra_edge_obj
argument_list|)
expr_stmt|;
block|}
comment|/* make sure commit traversal conforms to client */
name|register_shallow
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
name|packet_flush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shallows
operator|.
name|nr
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shallows
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|register_shallow
argument_list|(
name|shallows
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
name|shallow_nr
operator|+=
name|shallows
operator|.
name|nr
expr_stmt|;
name|free
argument_list|(
name|shallows
operator|.
name|objects
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* return non-zero if the ref is hidden, otherwise 0 */
end_comment
begin_function
DECL|function|mark_our_ref
specifier|static
name|int
name|mark_our_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|lookup_unknown_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref_is_hidden
argument_list|(
name|refname
argument_list|)
condition|)
block|{
name|o
operator|->
name|flags
operator||=
name|HIDDEN_REF
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|o
condition|)
name|die
argument_list|(
literal|"git upload-pack: cannot find object %s:"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|flags
operator||=
name|OUR_REF
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|send_ref
specifier|static
name|int
name|send_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|capabilities
init|=
literal|"multi_ack thin-pack side-band"
literal|" side-band-64k ofs-delta shallow no-progress"
literal|" include-tag multi_ack_detailed"
decl_stmt|;
specifier|const
name|char
modifier|*
name|refname_nons
init|=
name|strip_namespace
argument_list|(
name|refname
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|peeled
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|mark_our_ref
argument_list|(
name|refname
argument_list|,
name|sha1
argument_list|,
name|flag
argument_list|,
name|cb_data
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|capabilities
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"%s %s%c%s%s%s agent=%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|refname_nons
argument_list|,
literal|0
argument_list|,
name|capabilities
argument_list|,
name|allow_tip_sha1_in_want
condition|?
literal|" allow-tip-sha1-in-want"
else|:
literal|""
argument_list|,
name|stateless_rpc
condition|?
literal|" no-done"
else|:
literal|""
argument_list|,
name|git_user_agent_sanitized
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"%s %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|refname_nons
argument_list|)
expr_stmt|;
name|capabilities
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|peel_ref
argument_list|(
name|refname
argument_list|,
name|peeled
argument_list|)
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"%s %s^{}\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|peeled
argument_list|)
argument_list|,
name|refname_nons
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|upload_pack
specifier|static
name|void
name|upload_pack
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|advertise_refs
operator|||
operator|!
name|stateless_rpc
condition|)
block|{
name|reset_timeout
argument_list|()
expr_stmt|;
name|head_ref_namespaced
argument_list|(
name|send_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|for_each_namespaced_ref
argument_list|(
name|send_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|packet_flush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|head_ref_namespaced
argument_list|(
name|mark_our_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|for_each_namespaced_ref
argument_list|(
name|mark_our_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|advertise_refs
condition|)
return|return;
name|receive_needs
argument_list|()
expr_stmt|;
if|if
condition|(
name|want_obj
operator|.
name|nr
condition|)
block|{
name|get_common_commits
argument_list|()
expr_stmt|;
name|create_pack_file
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|upload_pack_config
specifier|static
name|int
name|upload_pack_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"uploadpack.allowtipsha1inwant"
argument_list|,
name|var
argument_list|)
condition|)
name|allow_tip_sha1_in_want
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|parse_hide_refs_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
literal|"uploadpack"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|strict
init|=
literal|0
decl_stmt|;
name|git_setup_gettext
argument_list|()
expr_stmt|;
name|packet_trace_identity
argument_list|(
literal|"upload-pack"
argument_list|)
expr_stmt|;
name|git_extract_argv0_path
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read_replace_refs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--advertise-refs"
argument_list|)
condition|)
block|{
name|advertise_refs
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--stateless-rpc"
argument_list|)
condition|)
block|{
name|stateless_rpc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--strict"
argument_list|)
condition|)
block|{
name|strict
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--timeout="
argument_list|)
condition|)
block|{
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
operator|+
literal|10
argument_list|)
expr_stmt|;
name|daemon_mode
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|upload_pack_usage
argument_list|)
expr_stmt|;
name|setup_path
argument_list|()
expr_stmt|;
name|dir
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|enter_repo
argument_list|(
name|dir
argument_list|,
name|strict
argument_list|)
condition|)
name|die
argument_list|(
literal|"'%s' does not appear to be a git repository"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_repository_shallow
argument_list|()
condition|)
name|die
argument_list|(
literal|"attempt to fetch/clone from a shallow repository"
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|upload_pack_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GIT_DEBUG_SEND_PACK"
argument_list|)
condition|)
name|debug_fd
operator|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"GIT_DEBUG_SEND_PACK"
argument_list|)
argument_list|)
expr_stmt|;
name|upload_pack
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
