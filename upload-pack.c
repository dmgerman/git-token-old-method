begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"sideband.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"list-objects.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_decl_stmt
DECL|variable|upload_pack_usage
specifier|static
specifier|const
name|char
name|upload_pack_usage
index|[]
init|=
literal|"git-upload-pack [--strict] [--timeout=nn]<dir>"
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* bits #0..7 in revision.h, #8..10 in commit.c */
end_comment
begin_define
DECL|macro|THEY_HAVE
define|#
directive|define
name|THEY_HAVE
value|(1u<< 11)
end_define
begin_define
DECL|macro|OUR_REF
define|#
directive|define
name|OUR_REF
value|(1u<< 12)
end_define
begin_define
DECL|macro|WANTED
define|#
directive|define
name|WANTED
value|(1u<< 13)
end_define
begin_define
DECL|macro|COMMON_KNOWN
define|#
directive|define
name|COMMON_KNOWN
value|(1u<< 14)
end_define
begin_define
DECL|macro|REACHABLE
define|#
directive|define
name|REACHABLE
value|(1u<< 15)
end_define
begin_define
DECL|macro|SHALLOW
define|#
directive|define
name|SHALLOW
value|(1u<< 16)
end_define
begin_define
DECL|macro|NOT_SHALLOW
define|#
directive|define
name|NOT_SHALLOW
value|(1u<< 17)
end_define
begin_define
DECL|macro|CLIENT_SHALLOW
define|#
directive|define
name|CLIENT_SHALLOW
value|(1u<< 18)
end_define
begin_decl_stmt
DECL|variable|oldest_have
specifier|static
name|unsigned
name|long
name|oldest_have
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|multi_ack
DECL|variable|nr_our_refs
specifier|static
name|int
name|multi_ack
decl_stmt|,
name|nr_our_refs
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_thin_pack
DECL|variable|use_ofs_delta
DECL|variable|no_progress
specifier|static
name|int
name|use_thin_pack
decl_stmt|,
name|use_ofs_delta
decl_stmt|,
name|no_progress
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|have_obj
specifier|static
name|struct
name|object_array
name|have_obj
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|want_obj
specifier|static
name|struct
name|object_array
name|want_obj
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|timeout
specifier|static
name|unsigned
name|int
name|timeout
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* 0 for no sideband,  * otherwise maximum packet size (up to 65520 bytes).  */
end_comment
begin_decl_stmt
DECL|variable|use_sideband
specifier|static
name|int
name|use_sideband
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|debug_fd
specifier|static
name|int
name|debug_fd
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|reset_timeout
specifier|static
name|void
name|reset_timeout
parameter_list|(
name|void
parameter_list|)
block|{
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|strip
specifier|static
name|int
name|strip
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|&&
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|send_client_data
specifier|static
name|ssize_t
name|send_client_data
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|ssize_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|use_sideband
condition|)
return|return
name|send_sideband
argument_list|(
literal|1
argument_list|,
name|fd
argument_list|,
name|data
argument_list|,
name|sz
argument_list|,
name|use_sideband
argument_list|)
return|;
if|if
condition|(
name|fd
operator|==
literal|3
condition|)
comment|/* emergency quit */
name|fd
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|fd
operator|==
literal|2
condition|)
block|{
comment|/* XXX: are we happy to lose stuff here? */
name|xwrite
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
block|}
return|return
name|safe_write
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|pack_pipe
specifier|static
name|FILE
modifier|*
name|pack_pipe
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|show_commit
specifier|static
name|void
name|show_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|BOUNDARY
condition|)
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|pack_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|pack_pipe
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"broken output pipe"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|pack_pipe
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pack_pipe
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|commit
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_object
specifier|static
name|void
name|show_object
parameter_list|(
name|struct
name|object_array_entry
modifier|*
name|p
parameter_list|)
block|{
comment|/* An object with name "foo\n0000000..." can be used to 	 * confuse downstream git-pack-objects very badly. 	 */
specifier|const
name|char
modifier|*
name|ep
init|=
name|strchr
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|ep
condition|)
block|{
name|fprintf
argument_list|(
name|pack_pipe
argument_list|,
literal|"%s %.*s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|item
operator|->
name|sha1
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|p
operator|->
name|name
argument_list|)
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|pack_pipe
argument_list|,
literal|"%s %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|item
operator|->
name|sha1
argument_list|)
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_edge
specifier|static
name|void
name|show_edge
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|fprintf
argument_list|(
name|pack_pipe
argument_list|,
literal|"-%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|do_rev_list
specifier|static
name|int
name|do_rev_list
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|create_full_pack
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|rev_info
name|revs
decl_stmt|;
name|pack_pipe
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|create_full_pack
condition|)
name|use_thin_pack
operator|=
literal|0
expr_stmt|;
comment|/* no point doing it */
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|revs
operator|.
name|tag_objects
operator|=
literal|1
expr_stmt|;
name|revs
operator|.
name|tree_objects
operator|=
literal|1
expr_stmt|;
name|revs
operator|.
name|blob_objects
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|use_thin_pack
condition|)
name|revs
operator|.
name|edge_hint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|create_full_pack
condition|)
block|{
specifier|const
name|char
modifier|*
name|args
index|[]
init|=
block|{
literal|"rev-list"
block|,
literal|"--all"
block|,
name|NULL
block|}
decl_stmt|;
name|setup_revisions
argument_list|(
literal|2
argument_list|,
name|args
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
comment|/* why??? */
name|o
operator|->
name|flags
operator|&=
operator|~
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|have_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|have_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
name|o
operator|->
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
literal|"revision walk setup failed"
argument_list|)
expr_stmt|;
name|mark_edges_uninteresting
argument_list|(
name|revs
operator|.
name|commits
argument_list|,
operator|&
name|revs
argument_list|,
name|show_edge
argument_list|)
expr_stmt|;
name|traverse_commit_list
argument_list|(
operator|&
name|revs
argument_list|,
name|show_commit
argument_list|,
name|show_object
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|create_pack_file
specifier|static
name|void
name|create_pack_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|async
name|rev_list
decl_stmt|;
name|struct
name|child_process
name|pack_objects
decl_stmt|;
name|int
name|create_full_pack
init|=
operator|(
name|nr_our_refs
operator|==
name|want_obj
operator|.
name|nr
operator|&&
operator|!
name|have_obj
operator|.
name|nr
operator|)
decl_stmt|;
name|char
name|data
index|[
literal|8193
index|]
decl_stmt|,
name|progress
index|[
literal|128
index|]
decl_stmt|;
name|char
name|abort_msg
index|[]
init|=
literal|"aborting due to possible repository "
literal|"corruption on the remote side."
decl_stmt|;
name|int
name|buffered
init|=
operator|-
literal|1
decl_stmt|;
name|ssize_t
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|10
index|]
decl_stmt|;
name|int
name|arg
init|=
literal|0
decl_stmt|;
name|rev_list
operator|.
name|proc
operator|=
name|do_rev_list
expr_stmt|;
comment|/* .data is just a boolean: any non-NULL value will do */
name|rev_list
operator|.
name|data
operator|=
name|create_full_pack
condition|?
operator|&
name|rev_list
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|start_async
argument_list|(
operator|&
name|rev_list
argument_list|)
condition|)
name|die
argument_list|(
literal|"git-upload-pack: unable to fork git-rev-list"
argument_list|)
expr_stmt|;
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"pack-objects"
expr_stmt|;
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--stdout"
expr_stmt|;
if|if
condition|(
operator|!
name|no_progress
condition|)
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--progress"
expr_stmt|;
if|if
condition|(
name|use_ofs_delta
condition|)
name|argv
index|[
name|arg
operator|++
index|]
operator|=
literal|"--delta-base-offset"
expr_stmt|;
name|argv
index|[
name|arg
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pack_objects
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pack_objects
argument_list|)
argument_list|)
expr_stmt|;
name|pack_objects
operator|.
name|in
operator|=
name|rev_list
operator|.
name|out
expr_stmt|;
comment|/* start_command closes it */
name|pack_objects
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|pack_objects
operator|.
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|pack_objects
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|pack_objects
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|pack_objects
argument_list|)
condition|)
name|die
argument_list|(
literal|"git-upload-pack: unable to fork git-pack-objects"
argument_list|)
expr_stmt|;
comment|/* We read from pack_objects.err to capture stderr output for 	 * progress bar, and pack_objects.out to capture the pack data. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|pollfd
name|pfd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pe
decl_stmt|,
name|pu
decl_stmt|,
name|pollsize
decl_stmt|;
name|reset_timeout
argument_list|()
expr_stmt|;
name|pollsize
operator|=
literal|0
expr_stmt|;
name|pe
operator|=
name|pu
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pack_objects
operator|.
name|out
condition|)
block|{
name|pfd
index|[
name|pollsize
index|]
operator|.
name|fd
operator|=
name|pack_objects
operator|.
name|out
expr_stmt|;
name|pfd
index|[
name|pollsize
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pu
operator|=
name|pollsize
expr_stmt|;
name|pollsize
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|pack_objects
operator|.
name|err
condition|)
block|{
name|pfd
index|[
name|pollsize
index|]
operator|.
name|fd
operator|=
name|pack_objects
operator|.
name|err
expr_stmt|;
name|pfd
index|[
name|pollsize
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pe
operator|=
name|pollsize
expr_stmt|;
name|pollsize
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pollsize
condition|)
break|break;
if|if
condition|(
name|poll
argument_list|(
name|pfd
argument_list|,
name|pollsize
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|error
argument_list|(
literal|"poll failed, resuming: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
literal|0
operator|<=
name|pu
operator|&&
operator|(
name|pfd
index|[
name|pu
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLIN
operator||
name|POLLHUP
operator|)
operator|)
condition|)
block|{
comment|/* Data ready; we keep the last byte to ourselves 			 * in case we detect broken rev-list, so that we 			 * can leave the stream corrupted.  This is 			 * unfortunate -- unpack-objects would happily 			 * accept a valid packdata with trailing garbage, 			 * so appending garbage after we pass all the 			 * pack data is not good enough to signal 			 * breakage to downstream. 			 */
name|char
modifier|*
name|cp
init|=
name|data
decl_stmt|;
name|ssize_t
name|outsz
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|buffered
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|buffered
expr_stmt|;
name|outsz
operator|++
expr_stmt|;
block|}
name|sz
operator|=
name|xread
argument_list|(
name|pack_objects
operator|.
name|out
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|outsz
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sz
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pack_objects
operator|.
name|out
argument_list|)
expr_stmt|;
name|pack_objects
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
name|sz
operator|+=
name|outsz
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|sz
condition|)
block|{
name|buffered
operator|=
name|data
index|[
name|sz
operator|-
literal|1
index|]
operator|&
literal|0xFF
expr_stmt|;
name|sz
operator|--
expr_stmt|;
block|}
else|else
name|buffered
operator|=
operator|-
literal|1
expr_stmt|;
name|sz
operator|=
name|send_client_data
argument_list|(
literal|1
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
literal|0
operator|<=
name|pe
operator|&&
operator|(
name|pfd
index|[
name|pe
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLIN
operator||
name|POLLHUP
operator|)
operator|)
condition|)
block|{
comment|/* Status ready; we ship that in the side-band 			 * or dump to the standard error. 			 */
name|sz
operator|=
name|xread
argument_list|(
name|pack_objects
operator|.
name|err
argument_list|,
name|progress
argument_list|,
sizeof|sizeof
argument_list|(
name|progress
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|sz
condition|)
name|send_client_data
argument_list|(
literal|2
argument_list|,
name|progress
argument_list|,
name|sz
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pack_objects
operator|.
name|err
argument_list|)
expr_stmt|;
name|pack_objects
operator|.
name|err
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|pack_objects
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"git-upload-pack: git-pack-objects died with error."
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|finish_async
argument_list|(
operator|&
name|rev_list
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* error was already reported */
comment|/* flush the data */
if|if
condition|(
literal|0
operator|<=
name|buffered
condition|)
block|{
name|data
index|[
literal|0
index|]
operator|=
name|buffered
expr_stmt|;
name|sz
operator|=
name|send_client_data
argument_list|(
literal|1
argument_list|,
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"flushed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_sideband
condition|)
name|packet_flush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|send_client_data
argument_list|(
literal|3
argument_list|,
name|abort_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|abort_msg
argument_list|)
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"git-upload-pack: %s"
argument_list|,
name|abort_msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|got_sha1
specifier|static
name|int
name|got_sha1
parameter_list|(
name|char
modifier|*
name|hex
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|int
name|we_knew_they_have
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|hex
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"git-upload-pack: expected SHA1 object, got '%s'"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|o
operator|=
name|lookup_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|&&
name|o
operator|->
name|parsed
operator|)
condition|)
name|o
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
name|die
argument_list|(
literal|"oops (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|THEY_HAVE
condition|)
name|we_knew_they_have
operator|=
literal|1
expr_stmt|;
else|else
name|o
operator|->
name|flags
operator||=
name|THEY_HAVE
expr_stmt|;
if|if
condition|(
operator|!
name|oldest_have
operator|||
operator|(
name|commit
operator|->
name|date
operator|<
name|oldest_have
operator|)
condition|)
name|oldest_have
operator|=
name|commit
operator|->
name|date
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|THEY_HAVE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|we_knew_they_have
condition|)
block|{
name|add_object_array
argument_list|(
name|o
argument_list|,
name|NULL
argument_list|,
operator|&
name|have_obj
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|reachable
specifier|static
name|int
name|reachable
parameter_list|(
name|struct
name|commit
modifier|*
name|want
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|work
init|=
name|NULL
decl_stmt|;
name|insert_by_date
argument_list|(
name|want
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
while|while
condition|(
name|work
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|work
operator|->
name|next
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|work
operator|->
name|item
decl_stmt|;
name|free
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|work
operator|=
name|list
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|THEY_HAVE
condition|)
block|{
name|want
operator|->
name|object
operator|.
name|flags
operator||=
name|COMMON_KNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_object
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|REACHABLE
condition|)
continue|continue;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|REACHABLE
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|date
operator|<
name|oldest_have
condition|)
continue|continue;
for|for
control|(
name|list
operator|=
name|commit
operator|->
name|parents
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|list
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|REACHABLE
operator|)
condition|)
name|insert_by_date
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|want
operator|->
name|object
operator|.
name|flags
operator||=
name|REACHABLE
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|want
argument_list|,
name|REACHABLE
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
operator|(
name|want
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON_KNOWN
operator|)
return|;
block|}
end_function
begin_function
DECL|function|ok_to_give_up
specifier|static
name|int
name|ok_to_give_up
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|have_obj
operator|.
name|nr
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|want_obj
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|want
init|=
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|want
operator|->
name|flags
operator|&
name|COMMON_KNOWN
condition|)
continue|continue;
name|want
operator|=
name|deref_tag
argument_list|(
name|want
argument_list|,
literal|"a want line"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|want
operator|||
name|want
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
comment|/* no way to tell if this is reachable by 			 * looking at the ancestry chain alone, so 			 * leave a note to ourselves not to worry about 			 * this object anymore. 			 */
name|want_obj
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|->
name|flags
operator||=
name|COMMON_KNOWN
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|reachable
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|want
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|get_common_commits
specifier|static
name|int
name|get_common_commits
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|hex
index|[
literal|41
index|]
decl_stmt|,
name|last_hex
index|[
literal|41
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|save_commit_buffer
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|packet_read_line
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|reset_timeout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
block|{
if|if
condition|(
name|have_obj
operator|.
name|nr
operator|==
literal|0
operator|||
name|multi_ack
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"NAK\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
name|strip
argument_list|(
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"have "
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|got_sha1
argument_list|(
name|line
operator|+
literal|5
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* they have what we do not */
if|if
condition|(
name|multi_ack
operator|&&
name|ok_to_give_up
argument_list|()
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s continue\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|memcpy
argument_list|(
name|hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
literal|41
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_ack
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"ACK %s continue\n"
decl_stmt|;
name|packet_write
argument_list|(
literal|1
argument_list|,
name|msg
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|last_hex
argument_list|,
name|hex
argument_list|,
literal|41
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_obj
operator|.
name|nr
operator|==
literal|1
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s\n"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"done"
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_obj
operator|.
name|nr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|multi_ack
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ACK %s\n"
argument_list|,
name|last_hex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"NAK\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|die
argument_list|(
literal|"git-upload-pack: expected SHA1 list, got '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|receive_needs
specifier|static
name|void
name|receive_needs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|object_array
name|shallows
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|depth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|debug_fd
condition|)
name|write_in_full
argument_list|(
name|debug_fd
argument_list|,
literal|"#S\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|unsigned
name|char
name|sha1_buf
index|[
literal|20
index|]
decl_stmt|;
name|len
operator|=
name|packet_read_line
argument_list|(
literal|0
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|reset_timeout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
if|if
condition|(
name|debug_fd
condition|)
name|write_in_full
argument_list|(
name|debug_fd
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"shallow "
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|object
decl_stmt|;
name|use_thin_pack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|line
operator|+
literal|8
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid shallow line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|object
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
name|die
argument_list|(
literal|"did not find object for %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator||=
name|CLIENT_SHALLOW
expr_stmt|;
name|add_object_array
argument_list|(
name|object
argument_list|,
name|NULL
argument_list|,
operator|&
name|shallows
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"deepen "
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|use_thin_pack
operator|=
literal|0
expr_stmt|;
name|depth
operator|=
name|strtol
argument_list|(
name|line
operator|+
literal|7
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|line
operator|+
literal|7
operator|||
name|depth
operator|<=
literal|0
condition|)
name|die
argument_list|(
literal|"Invalid deepen: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"want "
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|5
argument_list|,
name|sha1_buf
argument_list|)
condition|)
name|die
argument_list|(
literal|"git-upload-pack: protocol error, "
literal|"expected to get sha, not '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"multi_ack"
argument_list|)
condition|)
name|multi_ack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"thin-pack"
argument_list|)
condition|)
name|use_thin_pack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"ofs-delta"
argument_list|)
condition|)
name|use_ofs_delta
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"side-band-64k"
argument_list|)
condition|)
name|use_sideband
operator|=
name|LARGE_PACKET_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"side-band"
argument_list|)
condition|)
name|use_sideband
operator|=
name|DEFAULT_PACKET_MAX
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"no-progress"
argument_list|)
condition|)
name|no_progress
operator|=
literal|1
expr_stmt|;
comment|/* We have sent all our refs already, and the other end 		 * should have chosen out of them; otherwise they are 		 * asking for nonsense. 		 * 		 * Hmph.  We may later want to allow "want" line that 		 * asks for something like "master~10" (symbolic)... 		 * would it make sense?  I don't know. 		 */
name|o
operator|=
name|lookup_object
argument_list|(
name|sha1_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|OUR_REF
operator|)
condition|)
name|die
argument_list|(
literal|"git-upload-pack: not our ref %s"
argument_list|,
name|line
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|WANTED
operator|)
condition|)
block|{
name|o
operator|->
name|flags
operator||=
name|WANTED
expr_stmt|;
name|add_object_array
argument_list|(
name|o
argument_list|,
name|NULL
argument_list|,
operator|&
name|want_obj
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_fd
condition|)
name|write_in_full
argument_list|(
name|debug_fd
argument_list|,
literal|"#E\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
operator|&&
name|shallows
operator|.
name|nr
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|result
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
name|int
name|i
decl_stmt|;
name|backup
operator|=
name|result
operator|=
name|get_shallow_commits
argument_list|(
operator|&
name|want_obj
argument_list|,
name|depth
argument_list|,
name|SHALLOW
argument_list|,
name|NOT_SHALLOW
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
operator|&
name|result
operator|->
name|item
operator|->
name|object
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|object
operator|->
name|flags
operator|&
operator|(
name|CLIENT_SHALLOW
operator||
name|NOT_SHALLOW
operator|)
operator|)
condition|)
block|{
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"shallow %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|register_shallow
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|result
operator|->
name|next
expr_stmt|;
block|}
name|free_commit_list
argument_list|(
name|backup
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shallows
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
name|shallows
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|flags
operator|&
name|NOT_SHALLOW
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"unshallow %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator|&=
operator|~
name|CLIENT_SHALLOW
expr_stmt|;
comment|/* make sure the real parents are parsed */
name|unregister_shallow
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|object
operator|->
name|parsed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid commit"
argument_list|)
expr_stmt|;
name|parents
operator|=
operator|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|object
operator|)
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|add_object_array
argument_list|(
operator|&
name|parents
operator|->
name|item
operator|->
name|object
argument_list|,
name|NULL
argument_list|,
operator|&
name|want_obj
argument_list|)
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* make sure commit traversal conforms to client */
name|register_shallow
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
name|packet_flush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shallows
operator|.
name|nr
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shallows
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|register_shallow
argument_list|(
name|shallows
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shallows
operator|.
name|objects
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|send_ref
specifier|static
name|int
name|send_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|capabilities
init|=
literal|"multi_ack thin-pack side-band"
literal|" side-band-64k ofs-delta shallow no-progress"
decl_stmt|;
name|struct
name|object
modifier|*
name|o
init|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
name|die
argument_list|(
literal|"git-upload-pack: cannot find object %s:"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|capabilities
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"%s %s%c%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|refname
argument_list|,
literal|0
argument_list|,
name|capabilities
argument_list|)
expr_stmt|;
else|else
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"%s %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
name|capabilities
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|OUR_REF
operator|)
condition|)
block|{
name|o
operator|->
name|flags
operator||=
name|OUR_REF
expr_stmt|;
name|nr_our_refs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|o
operator|=
name|deref_tag
argument_list|(
name|o
argument_list|,
name|refname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
condition|)
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"%s %s^{}\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|sha1
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|upload_pack
specifier|static
name|void
name|upload_pack
parameter_list|(
name|void
parameter_list|)
block|{
name|reset_timeout
argument_list|()
expr_stmt|;
name|head_ref
argument_list|(
name|send_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|for_each_ref
argument_list|(
name|send_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|packet_flush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|receive_needs
argument_list|()
expr_stmt|;
if|if
condition|(
name|want_obj
operator|.
name|nr
condition|)
block|{
name|get_common_commits
argument_list|()
expr_stmt|;
name|create_pack_file
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|strict
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--strict"
argument_list|)
condition|)
block|{
name|strict
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--timeout="
argument_list|)
condition|)
block|{
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
operator|+
literal|10
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|upload_pack_usage
argument_list|)
expr_stmt|;
name|setup_path
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dir
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|enter_repo
argument_list|(
name|dir
argument_list|,
name|strict
argument_list|)
condition|)
name|die
argument_list|(
literal|"'%s': unable to chdir or not a git archive"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_repository_shallow
argument_list|()
condition|)
name|die
argument_list|(
literal|"attempt to fetch/clone from a shallow repository"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GIT_DEBUG_SEND_PACK"
argument_list|)
condition|)
name|debug_fd
operator|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"GIT_DEBUG_SEND_PACK"
argument_list|)
argument_list|)
expr_stmt|;
name|upload_pack
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
