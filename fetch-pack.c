begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"sideband.h"
end_include
begin_include
include|#
directive|include
file|<sys/wait.h>
end_include
begin_decl_stmt
DECL|variable|keep_pack
specifier|static
name|int
name|keep_pack
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|quiet
specifier|static
name|int
name|quiet
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|verbose
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fetch_all
specifier|static
name|int
name|fetch_all
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|depth
specifier|static
name|int
name|depth
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fetch_pack_usage
specifier|static
specifier|const
name|char
name|fetch_pack_usage
index|[]
init|=
literal|"git-fetch-pack [--all] [-q] [-v] [-k] [--thin] [--exec=upload-pack] [--depth=<n>] [host:]directory<refs>..."
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|exec
specifier|static
specifier|const
name|char
modifier|*
name|exec
init|=
literal|"git-upload-pack"
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|COMPLETE
define|#
directive|define
name|COMPLETE
value|(1U<< 0)
end_define
begin_define
DECL|macro|COMMON
define|#
directive|define
name|COMMON
value|(1U<< 1)
end_define
begin_define
DECL|macro|COMMON_REF
define|#
directive|define
name|COMMON_REF
value|(1U<< 2)
end_define
begin_define
DECL|macro|SEEN
define|#
directive|define
name|SEEN
value|(1U<< 3)
end_define
begin_define
DECL|macro|POPPED
define|#
directive|define
name|POPPED
value|(1U<< 4)
end_define
begin_comment
comment|/*  * After sending this many "have"s if we do not get any new ACK , we  * give up traversing our history.  */
end_comment
begin_define
DECL|macro|MAX_IN_VAIN
define|#
directive|define
name|MAX_IN_VAIN
value|256
end_define
begin_decl_stmt
DECL|variable|rev_list
specifier|static
name|struct
name|commit_list
modifier|*
name|rev_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|non_common_revs
DECL|variable|multi_ack
DECL|variable|use_thin_pack
DECL|variable|use_sideband
specifier|static
name|int
name|non_common_revs
decl_stmt|,
name|multi_ack
decl_stmt|,
name|use_thin_pack
decl_stmt|,
name|use_sideband
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|rev_list_push
specifier|static
name|void
name|rev_list_push
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|mark
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|mark
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|mark
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|parsed
operator|)
condition|)
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
name|insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|rev_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
operator|)
condition|)
name|non_common_revs
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|rev_list_insert_ref
specifier|static
name|int
name|rev_list_insert_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|rev_list_push
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
argument_list|,
name|SEEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*    This function marks a rev and its ancestors as common.    In some cases, it is desirable to mark only the ancestors (for example    when only the server does not yet know that they are common). */
end_comment
begin_function
DECL|function|mark_common
specifier|static
name|void
name|mark_common
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|ancestors_only
parameter_list|,
name|int
name|dont_parse
parameter_list|)
block|{
if|if
condition|(
name|commit
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
operator|)
condition|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|commit
decl_stmt|;
if|if
condition|(
operator|!
name|ancestors_only
condition|)
name|o
operator|->
name|flags
operator||=
name|COMMON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|SEEN
operator|)
condition|)
name|rev_list_push
argument_list|(
name|commit
argument_list|,
name|SEEN
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
operator|!
name|ancestors_only
operator|&&
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|POPPED
operator|)
condition|)
name|non_common_revs
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|parsed
operator|&&
operator|!
name|dont_parse
condition|)
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
name|mark_common
argument_list|(
name|parents
operator|->
name|item
argument_list|,
literal|0
argument_list|,
name|dont_parse
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*   Get the next rev to send, ignoring the common. */
end_comment
begin_function
DECL|function|get_rev
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|get_rev
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|commit
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|mark
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
name|rev_list
operator|==
name|NULL
operator|||
name|non_common_revs
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|commit
operator|=
name|rev_list
operator|->
name|item
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|parsed
operator|)
condition|)
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|POPPED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
operator|)
condition|)
name|non_common_revs
operator|--
expr_stmt|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
condition|)
block|{
comment|/* do not send "have", and ignore ancestors */
name|commit
operator|=
name|NULL
expr_stmt|;
name|mark
operator|=
name|COMMON
operator||
name|SEEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON_REF
condition|)
comment|/* send "have", and ignore ancestors */
name|mark
operator|=
name|COMMON
operator||
name|SEEN
expr_stmt|;
else|else
comment|/* send "have", also for its ancestors */
name|mark
operator|=
name|SEEN
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|SEEN
operator|)
condition|)
name|rev_list_push
argument_list|(
name|parents
operator|->
name|item
argument_list|,
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
operator|&
name|COMMON
condition|)
name|mark_common
argument_list|(
name|parents
operator|->
name|item
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
name|rev_list
operator|=
name|rev_list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|commit
operator|->
name|object
operator|.
name|sha1
return|;
block|}
end_function
begin_function
DECL|function|find_common
specifier|static
name|int
name|find_common
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|,
name|struct
name|ref
modifier|*
name|refs
parameter_list|)
block|{
name|int
name|fetching
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|flushes
init|=
literal|0
decl_stmt|,
name|retval
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|unsigned
name|in_vain
init|=
literal|0
decl_stmt|;
name|int
name|got_continue
init|=
literal|0
decl_stmt|;
name|for_each_ref
argument_list|(
name|rev_list_insert_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fetching
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|unsigned
name|char
modifier|*
name|remote
init|=
name|refs
operator|->
name|old_sha1
decl_stmt|;
name|struct
name|object
modifier|*
name|o
decl_stmt|;
comment|/* 		 * If that object is complete (i.e. it is an ancestor of a 		 * local ref), we tell them we have it but do not have to 		 * tell them about its ancestors, which they already know 		 * about. 		 * 		 * We use lookup_object here because we are only 		 * interested in the case we *know* the object is 		 * reachable and we have already scanned it. 		 */
if|if
condition|(
operator|(
operator|(
name|o
operator|=
name|lookup_object
argument_list|(
name|remote
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|COMPLETE
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|fetching
condition|)
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"want %s%s%s%s%s%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|,
operator|(
name|multi_ack
condition|?
literal|" multi_ack"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|use_sideband
operator|==
literal|2
condition|?
literal|" side-band-64k"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|use_sideband
operator|==
literal|1
condition|?
literal|" side-band"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|use_thin_pack
condition|?
literal|" thin-pack"
else|:
literal|""
operator|)
argument_list|,
literal|" ofs-delta"
argument_list|)
expr_stmt|;
else|else
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"want %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|fetching
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_repository_shallow
argument_list|()
condition|)
name|write_shallow_commits
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"deepen %d"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fetching
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|packet_read_line
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"shallow "
argument_list|,
name|line
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|8
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid shallow line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* no need making it shallow if we have it already */
if|if
condition|(
name|lookup_object
argument_list|(
name|sha1
argument_list|)
condition|)
continue|continue;
name|register_shallow
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"unshallow "
argument_list|,
name|line
argument_list|,
literal|10
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|10
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid unshallow line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_object
argument_list|(
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"object not found: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* make sure that it is parsed as shallow */
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unregister_shallow
argument_list|(
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"no shallow found: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"expected shallow/unshallow, got %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|flushes
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|sha1
operator|=
name|get_rev
argument_list|()
operator|)
condition|)
block|{
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"have %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"have %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|in_vain
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|31
operator|&
operator|++
name|count
operator|)
condition|)
block|{
name|int
name|ack
decl_stmt|;
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|flushes
operator|++
expr_stmt|;
comment|/* 			 * We keep one window "ahead" of the other side, and 			 * will wait for an ACK only on the next one 			 */
if|if
condition|(
name|count
operator|==
literal|32
condition|)
continue|continue;
do|do
block|{
name|ack
operator|=
name|get_ack
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|result_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|ack
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got ack %d %s\n"
argument_list|,
name|ack
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|==
literal|1
condition|)
block|{
name|flushes
operator|=
literal|0
expr_stmt|;
name|multi_ack
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|ack
operator|==
literal|2
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit
argument_list|(
name|result_sha1
argument_list|)
decl_stmt|;
name|mark_common
argument_list|(
name|commit
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|in_vain
operator|=
literal|0
expr_stmt|;
name|got_continue
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ack
condition|)
do|;
name|flushes
operator|--
expr_stmt|;
if|if
condition|(
name|got_continue
operator|&&
name|MAX_IN_VAIN
operator|<
name|in_vain
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"giving up\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* give up */
block|}
block|}
block|}
name|done
label|:
name|packet_write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|multi_ack
operator|=
literal|0
expr_stmt|;
name|flushes
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|flushes
operator|||
name|multi_ack
condition|)
block|{
name|int
name|ack
init|=
name|get_ack
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|result_sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ack
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got ack (%d) %s\n"
argument_list|,
name|ack
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|multi_ack
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|flushes
operator|--
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|complete
specifier|static
name|struct
name|commit_list
modifier|*
name|complete
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|mark_complete
specifier|static
name|int
name|mark_complete
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
while|while
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|struct
name|tag
modifier|*
name|t
init|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|tagged
condition|)
break|break;
comment|/* broken repository */
name|o
operator|->
name|flags
operator||=
name|COMPLETE
expr_stmt|;
name|o
operator|=
name|parse_object
argument_list|(
name|t
operator|->
name|tagged
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
decl_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|COMPLETE
expr_stmt|;
name|insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|complete
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|mark_recent_complete_commits
specifier|static
name|void
name|mark_recent_complete_commits
parameter_list|(
name|unsigned
name|long
name|cutoff
parameter_list|)
block|{
while|while
condition|(
name|complete
operator|&&
name|cutoff
operator|<=
name|complete
operator|->
name|item
operator|->
name|date
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Marking %s as complete\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|complete
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|pop_most_recent_commit
argument_list|(
operator|&
name|complete
argument_list|,
name|COMPLETE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|filter_refs
specifier|static
name|void
name|filter_refs
parameter_list|(
name|struct
name|ref
modifier|*
modifier|*
name|refs
parameter_list|,
name|int
name|nr_match
parameter_list|,
name|char
modifier|*
modifier|*
name|match
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|return_refs
decl_stmt|;
name|struct
name|ref
modifier|*
name|newlist
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|newtail
init|=
operator|&
name|newlist
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|ref
modifier|*
name|fastarray
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|nr_match
operator|&&
operator|!
name|fetch_all
condition|)
block|{
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|fastarray
argument_list|)
operator|<
name|nr_match
condition|)
name|return_refs
operator|=
name|xcalloc
argument_list|(
name|nr_match
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|return_refs
operator|=
name|fastarray
expr_stmt|;
name|memset
argument_list|(
name|return_refs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
operator|*
argument_list|)
operator|*
name|nr_match
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|return_refs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ref
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
operator|&&
name|check_ref_format
argument_list|(
name|ref
operator|->
name|name
operator|+
literal|5
argument_list|)
condition|)
empty_stmt|;
comment|/* trash */
elseif|else
if|if
condition|(
name|fetch_all
condition|)
block|{
operator|*
name|newtail
operator|=
name|ref
expr_stmt|;
name|ref
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newtail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|int
name|order
init|=
name|path_match
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|nr_match
argument_list|,
name|match
argument_list|)
decl_stmt|;
if|if
condition|(
name|order
condition|)
block|{
name|return_refs
index|[
name|order
operator|-
literal|1
index|]
operator|=
name|ref
expr_stmt|;
continue|continue;
comment|/* we will link it later */
block|}
block|}
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fetch_all
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_match
condition|;
name|i
operator|++
control|)
block|{
name|ref
operator|=
name|return_refs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ref
condition|)
block|{
operator|*
name|newtail
operator|=
name|ref
expr_stmt|;
name|ref
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newtail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|return_refs
operator|!=
name|fastarray
condition|)
name|free
argument_list|(
name|return_refs
argument_list|)
expr_stmt|;
block|}
operator|*
name|refs
operator|=
name|newlist
expr_stmt|;
block|}
end_function
begin_function
DECL|function|everything_local
specifier|static
name|int
name|everything_local
parameter_list|(
name|struct
name|ref
modifier|*
modifier|*
name|refs
parameter_list|,
name|int
name|nr_match
parameter_list|,
name|char
modifier|*
modifier|*
name|match
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|unsigned
name|long
name|cutoff
init|=
literal|0
decl_stmt|;
name|track_object_refs
operator|=
literal|0
expr_stmt|;
name|save_commit_buffer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|parse_object
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
continue|continue;
comment|/* We already have it -- which may mean that we were 		 * in sync with the other side at some time after 		 * that (it is OK if we guess wrong here). 		 */
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|cutoff
operator|||
name|cutoff
operator|<
name|commit
operator|->
name|date
condition|)
name|cutoff
operator|=
name|commit
operator|->
name|date
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|depth
condition|)
block|{
name|for_each_ref
argument_list|(
name|mark_complete
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cutoff
condition|)
name|mark_recent_complete_commits
argument_list|(
name|cutoff
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark all complete remote refs as common refs. 	 * Don't mark them common yet; the server has to be told so first. 	 */
for|for
control|(
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|deref_tag
argument_list|(
name|lookup_object
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|type
operator|!=
name|OBJ_COMMIT
operator|||
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|COMPLETE
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|SEEN
operator|)
condition|)
block|{
name|rev_list_push
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
argument_list|,
name|COMMON_REF
operator||
name|SEEN
argument_list|)
expr_stmt|;
name|mark_common
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|filter_refs
argument_list|(
name|refs
argument_list|,
name|nr_match
argument_list|,
name|match
argument_list|)
expr_stmt|;
for|for
control|(
name|retval
operator|=
literal|1
operator|,
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|remote
init|=
name|ref
operator|->
name|old_sha1
decl_stmt|;
name|unsigned
name|char
name|local
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|lookup_object
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|COMPLETE
operator|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"want %s (%s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"already have %s (%s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|setup_sideband
specifier|static
name|pid_t
name|setup_sideband
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|int
name|xd
index|[
literal|2
index|]
parameter_list|)
block|{
name|pid_t
name|side_pid
decl_stmt|;
if|if
condition|(
operator|!
name|use_sideband
condition|)
block|{
name|fd
index|[
literal|0
index|]
operator|=
name|xd
index|[
literal|0
index|]
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|xd
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* xd[] is talking with upload-pack; subprocess reads from 	 * xd[0], spits out band#2 to stderr, and feeds us band#1 	 * through our fd[0]. 	 */
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"fetch-pack: unable to set up pipe"
argument_list|)
expr_stmt|;
name|side_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|side_pid
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"fetch-pack: unable to fork off sideband demultiplexer"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|side_pid
condition|)
block|{
comment|/* subprocess */
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
index|[
literal|0
index|]
operator|!=
name|xd
index|[
literal|1
index|]
condition|)
name|close
argument_list|(
name|xd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|recv_sideband
argument_list|(
literal|"fetch-pack"
argument_list|,
name|xd
index|[
literal|0
index|]
argument_list|,
name|fd
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|xd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|xd
index|[
literal|1
index|]
expr_stmt|;
return|return
name|side_pid
return|;
block|}
end_function
begin_function
DECL|function|get_pack
specifier|static
name|int
name|get_pack
parameter_list|(
name|int
name|xd
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|,
name|side_pid
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|side_pid
operator|=
name|setup_sideband
argument_list|(
name|fd
argument_list|,
name|xd
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"fetch-pack: unable to fork off %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pid
condition|)
block|{
name|dup2
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv_git_cmd
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"%s exec failed"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|die
argument_list|(
literal|"waiting for %s: %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|code
init|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
name|die
argument_list|(
literal|"%s died with error code %d"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|die
argument_list|(
literal|"%s died of signal %d"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
name|die
argument_list|(
literal|"%s died of unnatural causes %d"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|explode_rx_pack
specifier|static
name|int
name|explode_rx_pack
parameter_list|(
name|int
name|xd
index|[
literal|2
index|]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|argv
index|[
literal|3
index|]
init|=
block|{
literal|"unpack-objects"
block|,
name|quiet
operator|?
literal|"-q"
operator|:
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|get_pack
argument_list|(
name|xd
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|keep_rx_pack
specifier|static
name|int
name|keep_rx_pack
parameter_list|(
name|int
name|xd
index|[
literal|2
index|]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|argv
index|[
literal|6
index|]
decl_stmt|;
name|char
name|keep_arg
index|[
literal|256
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|argv
index|[
name|n
operator|++
index|]
operator|=
literal|"index-pack"
expr_stmt|;
name|argv
index|[
name|n
operator|++
index|]
operator|=
literal|"--stdin"
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|argv
index|[
name|n
operator|++
index|]
operator|=
literal|"-v"
expr_stmt|;
if|if
condition|(
name|use_thin_pack
condition|)
name|argv
index|[
name|n
operator|++
index|]
operator|=
literal|"--fix-thin"
expr_stmt|;
if|if
condition|(
name|keep_pack
operator|>
literal|1
condition|)
block|{
name|int
name|s
init|=
name|sprintf
argument_list|(
name|keep_arg
argument_list|,
literal|"--keep=fetch-pack %i on "
argument_list|,
name|getpid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|keep_arg
operator|+
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|keep_arg
argument_list|)
operator|-
name|s
argument_list|)
condition|)
name|strcpy
argument_list|(
name|keep_arg
operator|+
name|s
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
name|argv
index|[
name|n
operator|++
index|]
operator|=
name|keep_arg
expr_stmt|;
block|}
name|argv
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|get_pack
argument_list|(
name|xd
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fetch_pack
specifier|static
name|int
name|fetch_pack
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|int
name|nr_match
parameter_list|,
name|char
modifier|*
modifier|*
name|match
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|get_remote_heads
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
operator|&
name|ref
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_repository_shallow
argument_list|()
operator|&&
operator|!
name|server_supports
argument_list|(
literal|"shallow"
argument_list|)
condition|)
name|die
argument_list|(
literal|"Server does not support shallow clients"
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_supports
argument_list|(
literal|"multi_ack"
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports multi_ack\n"
argument_list|)
expr_stmt|;
name|multi_ack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|server_supports
argument_list|(
literal|"side-band-64k"
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports side-band-64k\n"
argument_list|)
expr_stmt|;
name|use_sideband
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_supports
argument_list|(
literal|"side-band"
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports side-band\n"
argument_list|)
expr_stmt|;
name|use_sideband
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ref
condition|)
block|{
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"no matching remote head"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|everything_local
argument_list|(
operator|&
name|ref
argument_list|,
name|nr_match
argument_list|,
name|match
argument_list|)
condition|)
block|{
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|all_done
goto|;
block|}
if|if
condition|(
name|find_common
argument_list|(
name|fd
argument_list|,
name|sha1
argument_list|,
name|ref
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|keep_pack
operator|!=
literal|1
condition|)
comment|/* When cloning, it is not unusual to have 			 * no common commit. 			 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: no common commits\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|keep_pack
operator|)
condition|?
name|keep_rx_pack
argument_list|(
name|fd
argument_list|)
else|:
name|explode_rx_pack
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|die
argument_list|(
literal|"git-fetch-pack: fetch failed."
argument_list|)
expr_stmt|;
name|all_done
label|:
while|while
condition|(
name|ref
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|nr_heads
decl_stmt|;
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|heads
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|lock_file
name|lock
decl_stmt|;
name|setup_git_directory
argument_list|()
expr_stmt|;
name|nr_heads
operator|=
literal|0
expr_stmt|;
name|heads
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"--exec="
argument_list|,
name|arg
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|exec
operator|=
name|arg
operator|+
literal|7
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--quiet"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"-q"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|quiet
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--keep"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"-k"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|keep_pack
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--thin"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|use_thin_pack
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--all"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|fetch_all
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-v"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"--depth="
argument_list|,
name|arg
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|depth
operator|=
name|strtol
argument_list|(
name|arg
operator|+
literal|8
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|st
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|usage
argument_list|(
name|fetch_pack_usage
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|arg
expr_stmt|;
name|heads
operator|=
name|argv
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|nr_heads
operator|=
name|argc
operator|-
name|i
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|dest
condition|)
name|usage
argument_list|(
name|fetch_pack_usage
argument_list|)
expr_stmt|;
name|pid
operator|=
name|git_connect
argument_list|(
name|fd
argument_list|,
name|dest
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|ret
operator|=
name|fetch_pack
argument_list|(
name|fd
argument_list|,
name|nr_heads
argument_list|,
name|heads
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ret
operator||=
name|finish_connect
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|nr_heads
condition|)
block|{
comment|/* If the heads to pull were given, we should have 		 * consumed all of them by matching the remote. 		 * Otherwise, 'git-fetch remote no-such-ref' would 		 * silently succeed without issuing an error. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_heads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|heads
index|[
name|i
index|]
operator|&&
name|heads
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
name|error
argument_list|(
literal|"no such remote ref %s"
argument_list|,
name|heads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ret
operator|&&
name|depth
operator|>
literal|0
condition|)
block|{
name|struct
name|cache_time
name|mtime
decl_stmt|;
name|char
modifier|*
name|shallow
init|=
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|mtime
operator|.
name|sec
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_NSEC
name|mtime
operator|.
name|usec
operator|=
name|st
operator|.
name|st_mtim
operator|.
name|usec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|shallow
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
name|mtime
operator|.
name|sec
condition|)
name|die
argument_list|(
literal|"shallow file was removed during fetch"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|!=
name|mtime
operator|.
name|sec
ifdef|#
directive|ifdef
name|USE_NSEC
operator|||
name|st
operator|.
name|st_mtim
operator|.
name|usec
operator|!=
name|mtime
operator|.
name|usec
endif|#
directive|endif
condition|)
name|die
argument_list|(
literal|"shallow file was changed during fetch"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|lock
argument_list|,
name|shallow
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_shallow_commits
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|lock
operator|.
name|filename
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|commit_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|!
operator|!
name|ret
return|;
block|}
end_function
end_unit
