begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"sideband.h"
end_include
begin_include
include|#
directive|include
file|"fetch-pack.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"transport.h"
end_include
begin_include
include|#
directive|include
file|"version.h"
end_include
begin_decl_stmt
DECL|variable|transfer_unpack_limit
specifier|static
name|int
name|transfer_unpack_limit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fetch_unpack_limit
specifier|static
name|int
name|fetch_unpack_limit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|unpack_limit
specifier|static
name|int
name|unpack_limit
init|=
literal|100
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|prefer_ofs_delta
specifier|static
name|int
name|prefer_ofs_delta
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_done
specifier|static
name|int
name|no_done
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fetch_fsck_objects
specifier|static
name|int
name|fetch_fsck_objects
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|transfer_fsck_objects
specifier|static
name|int
name|transfer_fsck_objects
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|agent_supported
specifier|static
name|int
name|agent_supported
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|COMPLETE
define|#
directive|define
name|COMPLETE
value|(1U<< 0)
end_define
begin_define
DECL|macro|COMMON
define|#
directive|define
name|COMMON
value|(1U<< 1)
end_define
begin_define
DECL|macro|COMMON_REF
define|#
directive|define
name|COMMON_REF
value|(1U<< 2)
end_define
begin_define
DECL|macro|SEEN
define|#
directive|define
name|SEEN
value|(1U<< 3)
end_define
begin_define
DECL|macro|POPPED
define|#
directive|define
name|POPPED
value|(1U<< 4)
end_define
begin_decl_stmt
DECL|variable|marked
specifier|static
name|int
name|marked
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * After sending this many "have"s if we do not get any new ACK , we  * give up traversing our history.  */
end_comment
begin_define
DECL|macro|MAX_IN_VAIN
define|#
directive|define
name|MAX_IN_VAIN
value|256
end_define
begin_decl_stmt
DECL|variable|rev_list
specifier|static
name|struct
name|commit_list
modifier|*
name|rev_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|non_common_revs
DECL|variable|multi_ack
DECL|variable|use_sideband
specifier|static
name|int
name|non_common_revs
decl_stmt|,
name|multi_ack
decl_stmt|,
name|use_sideband
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|rev_list_push
specifier|static
name|void
name|rev_list_push
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|mark
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|mark
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|mark
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|parsed
operator|)
condition|)
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return;
name|commit_list_insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|rev_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
operator|)
condition|)
name|non_common_revs
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|rev_list_insert_ref
specifier|static
name|int
name|rev_list_insert_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|refname
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|rev_list_push
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
argument_list|,
name|SEEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|clear_marks
specifier|static
name|int
name|clear_marks
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|refname
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|clear_commit_marks
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
argument_list|,
name|COMMON
operator||
name|COMMON_REF
operator||
name|SEEN
operator||
name|POPPED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*    This function marks a rev and its ancestors as common.    In some cases, it is desirable to mark only the ancestors (for example    when only the server does not yet know that they are common). */
end_comment
begin_function
DECL|function|mark_common
specifier|static
name|void
name|mark_common
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|ancestors_only
parameter_list|,
name|int
name|dont_parse
parameter_list|)
block|{
if|if
condition|(
name|commit
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
operator|)
condition|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|commit
decl_stmt|;
if|if
condition|(
operator|!
name|ancestors_only
condition|)
name|o
operator|->
name|flags
operator||=
name|COMMON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|SEEN
operator|)
condition|)
name|rev_list_push
argument_list|(
name|commit
argument_list|,
name|SEEN
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
operator|!
name|ancestors_only
operator|&&
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|POPPED
operator|)
condition|)
name|non_common_revs
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|parsed
operator|&&
operator|!
name|dont_parse
condition|)
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
name|mark_common
argument_list|(
name|parents
operator|->
name|item
argument_list|,
literal|0
argument_list|,
name|dont_parse
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*   Get the next rev to send, ignoring the common. */
end_comment
begin_function
DECL|function|get_rev
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|get_rev
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|commit
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|mark
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
name|rev_list
operator|==
name|NULL
operator|||
name|non_common_revs
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|commit
operator|=
name|rev_list
operator|->
name|item
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|POPPED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
operator|)
condition|)
name|non_common_revs
operator|--
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
condition|)
block|{
comment|/* do not send "have", and ignore ancestors */
name|commit
operator|=
name|NULL
expr_stmt|;
name|mark
operator|=
name|COMMON
operator||
name|SEEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON_REF
condition|)
comment|/* send "have", and ignore ancestors */
name|mark
operator|=
name|COMMON
operator||
name|SEEN
expr_stmt|;
else|else
comment|/* send "have", also for its ancestors */
name|mark
operator|=
name|SEEN
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|SEEN
operator|)
condition|)
name|rev_list_push
argument_list|(
name|parents
operator|->
name|item
argument_list|,
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
operator|&
name|COMMON
condition|)
name|mark_common
argument_list|(
name|parents
operator|->
name|item
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
name|rev_list
operator|=
name|rev_list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|commit
operator|->
name|object
operator|.
name|sha1
return|;
block|}
end_function
begin_enum
DECL|enum|ack_type
enum|enum
name|ack_type
block|{
DECL|enumerator|NAK
name|NAK
init|=
literal|0
block|,
DECL|enumerator|ACK
name|ACK
block|,
DECL|enumerator|ACK_continue
name|ACK_continue
block|,
DECL|enumerator|ACK_common
name|ACK_common
block|,
DECL|enumerator|ACK_ready
name|ACK_ready
block|}
enum|;
end_enum
begin_function
DECL|function|consume_shallow_list
specifier|static
name|void
name|consume_shallow_list
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|args
operator|->
name|stateless_rpc
operator|&&
name|args
operator|->
name|depth
operator|>
literal|0
condition|)
block|{
comment|/* If we sent a depth we will get back "duplicate" 		 * shallow and unshallow commands every time there 		 * is a block of have lines exchanged. 		 */
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
while|while
condition|(
name|packet_read_line
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"shallow "
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"unshallow "
argument_list|)
condition|)
continue|continue;
name|die
argument_list|(
literal|"git fetch-pack: expected shallow list"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_struct
DECL|struct|write_shallow_data
struct|struct
name|write_shallow_data
block|{
DECL|member|out
name|struct
name|strbuf
modifier|*
name|out
decl_stmt|;
DECL|member|use_pack_protocol
name|int
name|use_pack_protocol
decl_stmt|;
DECL|member|count
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|write_one_shallow
specifier|static
name|int
name|write_one_shallow
parameter_list|(
specifier|const
name|struct
name|commit_graft
modifier|*
name|graft
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|write_shallow_data
modifier|*
name|data
init|=
name|cb_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|data
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|use_pack_protocol
condition|)
name|packet_buf_write
argument_list|(
name|data
operator|->
name|out
argument_list|,
literal|"shallow %s"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
else|else
block|{
name|strbuf_addstr
argument_list|(
name|data
operator|->
name|out
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|data
operator|->
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_shallow_commits
specifier|static
name|int
name|write_shallow_commits
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|int
name|use_pack_protocol
parameter_list|)
block|{
name|struct
name|write_shallow_data
name|data
decl_stmt|;
name|data
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|data
operator|.
name|use_pack_protocol
operator|=
name|use_pack_protocol
expr_stmt|;
name|data
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|for_each_commit_graft
argument_list|(
name|write_one_shallow
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|count
return|;
block|}
end_function
begin_function
DECL|function|get_ack
specifier|static
name|enum
name|ack_type
name|get_ack
parameter_list|(
name|int
name|fd
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|)
block|{
specifier|static
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|len
init|=
name|packet_read_line
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|die
argument_list|(
literal|"git fetch-pack: expected ACK/NAK, got EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"NAK"
argument_list|)
condition|)
return|return
name|NAK
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"ACK "
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|4
argument_list|,
name|result_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"continue"
argument_list|)
condition|)
return|return
name|ACK_continue
return|;
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"common"
argument_list|)
condition|)
return|return
name|ACK_common
return|;
if|if
condition|(
name|strstr
argument_list|(
name|line
operator|+
literal|45
argument_list|,
literal|"ready"
argument_list|)
condition|)
return|return
name|ACK_ready
return|;
return|return
name|ACK
return|;
block|}
block|}
name|die
argument_list|(
literal|"git fetch_pack: expected ACK/NAK, got '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|send_request
specifier|static
name|void
name|send_request
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|args
operator|->
name|stateless_rpc
condition|)
block|{
name|send_sideband
argument_list|(
name|fd
argument_list|,
operator|-
literal|1
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|LARGE_PACKET_MAX
argument_list|)
expr_stmt|;
name|packet_flush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
name|safe_write
argument_list|(
name|fd
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|insert_one_alternate_ref
specifier|static
name|void
name|insert_one_alternate_ref
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|rev_list_insert_ref
argument_list|(
name|NULL
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|INITIAL_FLUSH
define|#
directive|define
name|INITIAL_FLUSH
value|16
end_define
begin_define
DECL|macro|PIPESAFE_FLUSH
define|#
directive|define
name|PIPESAFE_FLUSH
value|32
end_define
begin_define
DECL|macro|LARGE_FLUSH
define|#
directive|define
name|LARGE_FLUSH
value|1024
end_define
begin_function
DECL|function|next_flush
specifier|static
name|int
name|next_flush
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|flush_limit
init|=
name|args
operator|->
name|stateless_rpc
condition|?
name|LARGE_FLUSH
else|:
name|PIPESAFE_FLUSH
decl_stmt|;
if|if
condition|(
name|count
operator|<
name|flush_limit
condition|)
name|count
operator|<<=
literal|1
expr_stmt|;
else|else
name|count
operator|+=
name|flush_limit
expr_stmt|;
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|find_common
specifier|static
name|int
name|find_common
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_sha1
parameter_list|,
name|struct
name|ref
modifier|*
name|refs
parameter_list|)
block|{
name|int
name|fetching
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|flushes
init|=
literal|0
decl_stmt|,
name|flush_at
init|=
name|INITIAL_FLUSH
decl_stmt|,
name|retval
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|unsigned
name|in_vain
init|=
literal|0
decl_stmt|;
name|int
name|got_continue
init|=
literal|0
decl_stmt|;
name|int
name|got_ready
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|req_buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|size_t
name|state_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|stateless_rpc
operator|&&
name|multi_ack
operator|==
literal|1
condition|)
name|die
argument_list|(
literal|"--stateless-rpc requires multi_ack_detailed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|marked
condition|)
name|for_each_ref
argument_list|(
name|clear_marks
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|marked
operator|=
literal|1
expr_stmt|;
name|for_each_ref
argument_list|(
name|rev_list_insert_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|for_each_alternate_ref
argument_list|(
name|insert_one_alternate_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fetching
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|unsigned
name|char
modifier|*
name|remote
init|=
name|refs
operator|->
name|old_sha1
decl_stmt|;
specifier|const
name|char
modifier|*
name|remote_hex
decl_stmt|;
name|struct
name|object
modifier|*
name|o
decl_stmt|;
comment|/* 		 * If that object is complete (i.e. it is an ancestor of a 		 * local ref), we tell them we have it but do not have to 		 * tell them about its ancestors, which they already know 		 * about. 		 * 		 * We use lookup_object here because we are only 		 * interested in the case we *know* the object is 		 * reachable and we have already scanned it. 		 */
if|if
condition|(
operator|(
operator|(
name|o
operator|=
name|lookup_object
argument_list|(
name|remote
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|COMPLETE
operator|)
condition|)
block|{
continue|continue;
block|}
name|remote_hex
operator|=
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fetching
condition|)
block|{
name|struct
name|strbuf
name|c
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|multi_ack
operator|==
literal|2
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" multi_ack_detailed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|multi_ack
operator|==
literal|1
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" multi_ack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_done
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" no-done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sideband
operator|==
literal|2
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" side-band-64k"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sideband
operator|==
literal|1
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" side-band"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|use_thin_pack
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" thin-pack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|no_progress
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" no-progress"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|include_tag
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" include-tag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefer_ofs_delta
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|c
argument_list|,
literal|" ofs-delta"
argument_list|)
expr_stmt|;
if|if
condition|(
name|agent_supported
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|c
argument_list|,
literal|" agent=%s"
argument_list|,
name|git_user_agent_sanitized
argument_list|()
argument_list|)
expr_stmt|;
name|packet_buf_write
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|"want %s%s\n"
argument_list|,
name|remote_hex
argument_list|,
name|c
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|packet_buf_write
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|"want %s\n"
argument_list|,
name|remote_hex
argument_list|)
expr_stmt|;
name|fetching
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fetching
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|req_buf
argument_list|)
expr_stmt|;
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|is_repository_shallow
argument_list|()
condition|)
name|write_shallow_commits
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|depth
operator|>
literal|0
condition|)
name|packet_buf_write
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|"deepen %d"
argument_list|,
name|args
operator|->
name|depth
argument_list|)
expr_stmt|;
name|packet_buf_flush
argument_list|(
operator|&
name|req_buf
argument_list|)
expr_stmt|;
name|state_len
operator|=
name|req_buf
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|depth
operator|>
literal|0
condition|)
block|{
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|send_request
argument_list|(
name|args
argument_list|,
name|fd
index|[
literal|1
index|]
argument_list|,
operator|&
name|req_buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|packet_read_line
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"shallow "
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|8
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid shallow line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|register_shallow
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"unshallow "
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|line
operator|+
literal|10
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid unshallow line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_object
argument_list|(
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"object not found: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* make sure that it is parsed as shallow */
if|if
condition|(
operator|!
name|parse_object
argument_list|(
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"error in object: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|unregister_shallow
argument_list|(
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"no shallow found: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|die
argument_list|(
literal|"expected shallow/unshallow, got %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|args
operator|->
name|stateless_rpc
condition|)
name|send_request
argument_list|(
name|args
argument_list|,
name|fd
index|[
literal|1
index|]
argument_list|,
operator|&
name|req_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|stateless_rpc
condition|)
block|{
comment|/* If we aren't using the stateless-rpc interface 		 * we don't need to retain the headers. 		 */
name|strbuf_setlen
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state_len
operator|=
literal|0
expr_stmt|;
block|}
name|flushes
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|sha1
operator|=
name|get_rev
argument_list|()
operator|)
condition|)
block|{
name|packet_buf_write
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|"have %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"have %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|in_vain
operator|++
expr_stmt|;
if|if
condition|(
name|flush_at
operator|<=
operator|++
name|count
condition|)
block|{
name|int
name|ack
decl_stmt|;
name|packet_buf_flush
argument_list|(
operator|&
name|req_buf
argument_list|)
expr_stmt|;
name|send_request
argument_list|(
name|args
argument_list|,
name|fd
index|[
literal|1
index|]
argument_list|,
operator|&
name|req_buf
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|req_buf
argument_list|,
name|state_len
argument_list|)
expr_stmt|;
name|flushes
operator|++
expr_stmt|;
name|flush_at
operator|=
name|next_flush
argument_list|(
name|args
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 			 * We keep one window "ahead" of the other side, and 			 * will wait for an ACK only on the next one 			 */
if|if
condition|(
operator|!
name|args
operator|->
name|stateless_rpc
operator|&&
name|count
operator|==
name|INITIAL_FLUSH
condition|)
continue|continue;
name|consume_shallow_list
argument_list|(
name|args
argument_list|,
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
do|do
block|{
name|ack
operator|=
name|get_ack
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|result_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|verbose
operator|&&
name|ack
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got ack %d %s\n"
argument_list|,
name|ack
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ack
condition|)
block|{
case|case
name|ACK
case|:
name|flushes
operator|=
literal|0
expr_stmt|;
name|multi_ack
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|ACK_common
case|:
case|case
name|ACK_ready
case|:
case|case
name|ACK_continue
case|:
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit
argument_list|(
name|result_sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|die
argument_list|(
literal|"invalid commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|stateless_rpc
operator|&&
name|ack
operator|==
name|ACK_common
operator|&&
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMMON
operator|)
condition|)
block|{
comment|/* We need to replay the have for this object 						 * on the next RPC request so the peer knows 						 * it is in common with us. 						 */
specifier|const
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
decl_stmt|;
name|packet_buf_write
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|"have %s\n"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
name|state_len
operator|=
name|req_buf
operator|.
name|len
expr_stmt|;
block|}
name|mark_common
argument_list|(
name|commit
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|in_vain
operator|=
literal|0
expr_stmt|;
name|got_continue
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ack
operator|==
name|ACK_ready
condition|)
block|{
name|rev_list
operator|=
name|NULL
expr_stmt|;
name|got_ready
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
do|while
condition|(
name|ack
condition|)
do|;
name|flushes
operator|--
expr_stmt|;
if|if
condition|(
name|got_continue
operator|&&
name|MAX_IN_VAIN
operator|<
name|in_vain
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"giving up\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* give up */
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
operator|!
name|got_ready
operator|||
operator|!
name|no_done
condition|)
block|{
name|packet_buf_write
argument_list|(
operator|&
name|req_buf
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|send_request
argument_list|(
name|args
argument_list|,
name|fd
index|[
literal|1
index|]
argument_list|,
operator|&
name|req_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|multi_ack
operator|=
literal|0
expr_stmt|;
name|flushes
operator|++
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|req_buf
argument_list|)
expr_stmt|;
name|consume_shallow_list
argument_list|(
name|args
argument_list|,
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|flushes
operator|||
name|multi_ack
condition|)
block|{
name|int
name|ack
init|=
name|get_ack
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|result_sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ack
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got ack (%d) %s\n"
argument_list|,
name|ack
argument_list|,
name|sha1_to_hex
argument_list|(
name|result_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|==
name|ACK
condition|)
return|return
literal|0
return|;
name|multi_ack
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|flushes
operator|--
expr_stmt|;
block|}
comment|/* it is no error to fetch into a completely empty repo */
return|return
name|count
condition|?
name|retval
else|:
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|complete
specifier|static
name|struct
name|commit_list
modifier|*
name|complete
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|mark_complete
specifier|static
name|int
name|mark_complete
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
while|while
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|struct
name|tag
modifier|*
name|t
init|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|tagged
condition|)
break|break;
comment|/* broken repository */
name|o
operator|->
name|flags
operator||=
name|COMPLETE
expr_stmt|;
name|o
operator|=
name|parse_object
argument_list|(
name|t
operator|->
name|tagged
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|COMPLETE
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|COMPLETE
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|complete
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|mark_recent_complete_commits
specifier|static
name|void
name|mark_recent_complete_commits
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|unsigned
name|long
name|cutoff
parameter_list|)
block|{
while|while
condition|(
name|complete
operator|&&
name|cutoff
operator|<=
name|complete
operator|->
name|item
operator|->
name|date
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Marking %s as complete\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|complete
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|pop_most_recent_commit
argument_list|(
operator|&
name|complete
argument_list|,
name|COMPLETE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|non_matching_ref
specifier|static
name|int
name|non_matching_ref
parameter_list|(
name|struct
name|string_list_item
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
name|item
operator|->
name|util
condition|)
block|{
name|item
operator|->
name|util
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|filter_refs
specifier|static
name|void
name|filter_refs
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|refs
parameter_list|,
name|struct
name|string_list
modifier|*
name|sought
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|newlist
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|newtail
init|=
operator|&
name|newlist
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|sought_pos
decl_stmt|;
name|sought_pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|next
control|)
block|{
name|int
name|keep
init|=
literal|0
decl_stmt|;
name|next
operator|=
name|ref
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
operator|&&
name|check_refname_format
argument_list|(
name|ref
operator|->
name|name
operator|+
literal|5
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
comment|/* trash */
else|else
block|{
while|while
condition|(
name|sought_pos
operator|<
name|sought
operator|->
name|nr
condition|)
block|{
name|int
name|cmp
init|=
name|strcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|sought
operator|->
name|items
index|[
name|sought_pos
index|]
operator|.
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
break|break;
comment|/* definitely do not have it */
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|keep
operator|=
literal|1
expr_stmt|;
comment|/* definitely have it */
name|sought
operator|->
name|items
index|[
name|sought_pos
operator|++
index|]
operator|.
name|util
operator|=
literal|"matched"
expr_stmt|;
break|break;
block|}
else|else
name|sought_pos
operator|++
expr_stmt|;
comment|/* might have it; keep looking */
block|}
block|}
if|if
condition|(
operator|!
name|keep
operator|&&
name|args
operator|->
name|fetch_all
operator|&&
operator|(
operator|!
name|args
operator|->
name|depth
operator|||
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
operator|)
condition|)
name|keep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|keep
condition|)
block|{
operator|*
name|newtail
operator|=
name|ref
expr_stmt|;
name|ref
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|newtail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
name|filter_string_list
argument_list|(
name|sought
argument_list|,
literal|0
argument_list|,
name|non_matching_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|refs
operator|=
name|newlist
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mark_alternate_complete
specifier|static
name|void
name|mark_alternate_complete
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|mark_complete
argument_list|(
name|NULL
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|everything_local
specifier|static
name|int
name|everything_local
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|refs
parameter_list|,
name|struct
name|string_list
modifier|*
name|sought
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|unsigned
name|long
name|cutoff
init|=
literal|0
decl_stmt|;
name|save_commit_buffer
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
continue|continue;
name|o
operator|=
name|parse_object
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
continue|continue;
comment|/* We already have it -- which may mean that we were 		 * in sync with the other side at some time after 		 * that (it is OK if we guess wrong here). 		 */
if|if
condition|(
name|o
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|cutoff
operator|||
name|cutoff
operator|<
name|commit
operator|->
name|date
condition|)
name|cutoff
operator|=
name|commit
operator|->
name|date
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|args
operator|->
name|depth
condition|)
block|{
name|for_each_ref
argument_list|(
name|mark_complete
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|for_each_alternate_ref
argument_list|(
name|mark_alternate_complete
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cutoff
condition|)
name|mark_recent_complete_commits
argument_list|(
name|args
argument_list|,
name|cutoff
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark all complete remote refs as common refs. 	 * Don't mark them common yet; the server has to be told so first. 	 */
for|for
control|(
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|deref_tag
argument_list|(
name|lookup_object
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|type
operator|!=
name|OBJ_COMMIT
operator|||
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|COMPLETE
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|SEEN
operator|)
condition|)
block|{
name|rev_list_push
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
argument_list|,
name|COMMON_REF
operator||
name|SEEN
argument_list|)
expr_stmt|;
name|mark_common
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|filter_refs
argument_list|(
name|args
argument_list|,
name|refs
argument_list|,
name|sought
argument_list|)
expr_stmt|;
for|for
control|(
name|retval
operator|=
literal|1
operator|,
name|ref
operator|=
operator|*
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|remote
init|=
name|ref
operator|->
name|old_sha1
decl_stmt|;
name|unsigned
name|char
name|local
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|lookup_object
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|COMPLETE
operator|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|verbose
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"want %s (%s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|verbose
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"already have %s (%s)\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|sideband_demux
specifier|static
name|int
name|sideband_demux
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|xd
init|=
name|data
decl_stmt|;
name|int
name|ret
init|=
name|recv_sideband
argument_list|(
literal|"fetch-pack"
argument_list|,
name|xd
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|get_pack
specifier|static
name|int
name|get_pack
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|int
name|xd
index|[
literal|2
index|]
parameter_list|,
name|char
modifier|*
modifier|*
name|pack_lockfile
parameter_list|)
block|{
name|struct
name|async
name|demux
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|20
index|]
decl_stmt|;
name|char
name|keep_arg
index|[
literal|256
index|]
decl_stmt|;
name|char
name|hdr_arg
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|do_keep
init|=
name|args
operator|->
name|keep_pack
decl_stmt|;
name|struct
name|child_process
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|demux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|demux
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sideband
condition|)
block|{
comment|/* xd[] is talking with upload-pack; subprocess reads from 		 * xd[0], spits out band#2 to stderr, and feeds us band#1 		 * through demux->out. 		 */
name|demux
operator|.
name|proc
operator|=
name|sideband_demux
expr_stmt|;
name|demux
operator|.
name|data
operator|=
name|xd
expr_stmt|;
name|demux
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_async
argument_list|(
operator|&
name|demux
argument_list|)
condition|)
name|die
argument_list|(
literal|"fetch-pack: unable to fork off sideband"
literal|" demultiplexer"
argument_list|)
expr_stmt|;
block|}
else|else
name|demux
operator|.
name|out
operator|=
name|xd
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
operator|*
name|hdr_arg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|keep_pack
operator|&&
name|unpack_limit
condition|)
block|{
name|struct
name|pack_header
name|header
decl_stmt|;
if|if
condition|(
name|read_pack_header
argument_list|(
name|demux
operator|.
name|out
argument_list|,
operator|&
name|header
argument_list|)
condition|)
name|die
argument_list|(
literal|"protocol error: bad pack header"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|hdr_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr_arg
argument_list|)
argument_list|,
literal|"--pack_header=%"
name|PRIu32
literal|",%"
name|PRIu32
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|hdr_version
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|header
operator|.
name|hdr_entries
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|header
operator|.
name|hdr_entries
argument_list|)
operator|<
name|unpack_limit
condition|)
name|do_keep
operator|=
literal|0
expr_stmt|;
else|else
name|do_keep
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_keep
condition|)
block|{
if|if
condition|(
name|pack_lockfile
condition|)
name|cmd
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|av
operator|++
operator|=
literal|"index-pack"
expr_stmt|;
operator|*
name|av
operator|++
operator|=
literal|"--stdin"
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|quiet
operator|&&
operator|!
name|args
operator|->
name|no_progress
condition|)
operator|*
name|av
operator|++
operator|=
literal|"-v"
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|use_thin_pack
condition|)
operator|*
name|av
operator|++
operator|=
literal|"--fix-thin"
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|lock_pack
operator|||
name|unpack_limit
condition|)
block|{
name|int
name|s
init|=
name|sprintf
argument_list|(
name|keep_arg
argument_list|,
literal|"--keep=fetch-pack %"
name|PRIuMAX
literal|" on "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getpid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|keep_arg
operator|+
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|keep_arg
argument_list|)
operator|-
name|s
argument_list|)
condition|)
name|strcpy
argument_list|(
name|keep_arg
operator|+
name|s
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
operator|*
name|av
operator|++
operator|=
name|keep_arg
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|av
operator|++
operator|=
literal|"unpack-objects"
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|quiet
operator|||
name|args
operator|->
name|no_progress
condition|)
operator|*
name|av
operator|++
operator|=
literal|"-q"
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|hdr_arg
condition|)
operator|*
name|av
operator|++
operator|=
name|hdr_arg
expr_stmt|;
if|if
condition|(
name|fetch_fsck_objects
operator|>=
literal|0
condition|?
name|fetch_fsck_objects
else|:
name|transfer_fsck_objects
operator|>=
literal|0
condition|?
name|transfer_fsck_objects
else|:
literal|0
condition|)
operator|*
name|av
operator|++
operator|=
literal|"--strict"
expr_stmt|;
operator|*
name|av
operator|++
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|.
name|in
operator|=
name|demux
operator|.
name|out
expr_stmt|;
name|cmd
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|cmd
argument_list|)
condition|)
name|die
argument_list|(
literal|"fetch-pack: unable to fork off %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_keep
operator|&&
name|pack_lockfile
condition|)
block|{
operator|*
name|pack_lockfile
operator|=
name|index_pack_lockfile
argument_list|(
name|cmd
operator|.
name|out
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cmd
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|cmd
argument_list|)
condition|)
name|die
argument_list|(
literal|"%s failed"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sideband
operator|&&
name|finish_async
argument_list|(
operator|&
name|demux
argument_list|)
condition|)
name|die
argument_list|(
literal|"error in sideband demultiplexer"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|do_fetch_pack
specifier|static
name|struct
name|ref
modifier|*
name|do_fetch_pack
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|int
name|fd
index|[
literal|2
index|]
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|orig_ref
parameter_list|,
name|struct
name|string_list
modifier|*
name|sought
parameter_list|,
name|char
modifier|*
modifier|*
name|pack_lockfile
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|copy_ref_list
argument_list|(
name|orig_ref
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|agent_feature
decl_stmt|;
name|int
name|agent_len
decl_stmt|;
name|sort_ref_list
argument_list|(
operator|&
name|ref
argument_list|,
name|ref_compare_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_repository_shallow
argument_list|()
operator|&&
operator|!
name|server_supports
argument_list|(
literal|"shallow"
argument_list|)
condition|)
name|die
argument_list|(
literal|"Server does not support shallow clients"
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_supports
argument_list|(
literal|"multi_ack_detailed"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports multi_ack_detailed\n"
argument_list|)
expr_stmt|;
name|multi_ack
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|server_supports
argument_list|(
literal|"no-done"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports no-done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|stateless_rpc
condition|)
name|no_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|server_supports
argument_list|(
literal|"multi_ack"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports multi_ack\n"
argument_list|)
expr_stmt|;
name|multi_ack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|server_supports
argument_list|(
literal|"side-band-64k"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports side-band-64k\n"
argument_list|)
expr_stmt|;
name|use_sideband
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_supports
argument_list|(
literal|"side-band"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports side-band\n"
argument_list|)
expr_stmt|;
name|use_sideband
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|server_supports
argument_list|(
literal|"thin-pack"
argument_list|)
condition|)
name|args
operator|->
name|use_thin_pack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|server_supports
argument_list|(
literal|"no-progress"
argument_list|)
condition|)
name|args
operator|->
name|no_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|server_supports
argument_list|(
literal|"include-tag"
argument_list|)
condition|)
name|args
operator|->
name|include_tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|server_supports
argument_list|(
literal|"ofs-delta"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server supports ofs-delta\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|prefer_ofs_delta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|agent_feature
operator|=
name|server_feature_value
argument_list|(
literal|"agent"
argument_list|,
operator|&
name|agent_len
argument_list|)
operator|)
condition|)
block|{
name|agent_supported
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|verbose
operator|&&
name|agent_len
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server version is %.*s\n"
argument_list|,
name|agent_len
argument_list|,
name|agent_feature
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|everything_local
argument_list|(
name|args
argument_list|,
operator|&
name|ref
argument_list|,
name|sought
argument_list|)
condition|)
block|{
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|all_done
goto|;
block|}
if|if
condition|(
name|find_common
argument_list|(
name|args
argument_list|,
name|fd
argument_list|,
name|sha1
argument_list|,
name|ref
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
operator|!
name|args
operator|->
name|keep_pack
condition|)
comment|/* When cloning, it is not unusual to have 			 * no common commit. 			 */
name|warning
argument_list|(
literal|"no common commits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|stateless_rpc
condition|)
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_pack
argument_list|(
name|args
argument_list|,
name|fd
argument_list|,
name|pack_lockfile
argument_list|)
condition|)
name|die
argument_list|(
literal|"git fetch-pack: fetch failed."
argument_list|)
expr_stmt|;
name|all_done
label|:
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|fetch_pack_config
specifier|static
name|int
name|fetch_pack_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"fetch.unpacklimit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fetch_unpack_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"transfer.unpacklimit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|transfer_unpack_limit
operator|=
name|git_config_int
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"repack.usedeltabaseoffset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prefer_ofs_delta
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"fetch.fsckobjects"
argument_list|)
condition|)
block|{
name|fetch_fsck_objects
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"transfer.fsckobjects"
argument_list|)
condition|)
block|{
name|transfer_fsck_objects
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|lock
specifier|static
name|struct
name|lock_file
name|lock
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|fetch_pack_setup
specifier|static
name|void
name|fetch_pack_setup
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|did_setup
decl_stmt|;
if|if
condition|(
name|did_setup
condition|)
return|return;
name|git_config
argument_list|(
name|fetch_pack_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|transfer_unpack_limit
condition|)
name|unpack_limit
operator|=
name|transfer_unpack_limit
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|<=
name|fetch_unpack_limit
condition|)
name|unpack_limit
operator|=
name|fetch_unpack_limit
expr_stmt|;
name|did_setup
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fetch_pack
name|struct
name|ref
modifier|*
name|fetch_pack
parameter_list|(
name|struct
name|fetch_pack_args
modifier|*
name|args
parameter_list|,
name|int
name|fd
index|[]
parameter_list|,
name|struct
name|child_process
modifier|*
name|conn
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
specifier|const
name|char
modifier|*
name|dest
parameter_list|,
name|struct
name|string_list
modifier|*
name|sought
parameter_list|,
name|char
modifier|*
modifier|*
name|pack_lockfile
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref_cpy
decl_stmt|;
name|fetch_pack_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|depth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|st
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sought
operator|->
name|nr
condition|)
block|{
name|sort_string_list
argument_list|(
name|sought
argument_list|)
expr_stmt|;
name|string_list_remove_duplicates
argument_list|(
name|sought
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ref
condition|)
block|{
name|packet_flush
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"no matching remote head"
argument_list|)
expr_stmt|;
block|}
name|ref_cpy
operator|=
name|do_fetch_pack
argument_list|(
name|args
argument_list|,
name|fd
argument_list|,
name|ref
argument_list|,
name|sought
argument_list|,
name|pack_lockfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|depth
operator|>
literal|0
condition|)
block|{
name|struct
name|cache_time
name|mtime
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|shallow
init|=
name|git_path
argument_list|(
literal|"shallow"
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|mtime
operator|.
name|sec
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|mtime
operator|.
name|nsec
operator|=
name|ST_MTIME_NSEC
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|shallow
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
name|mtime
operator|.
name|sec
condition|)
name|die
argument_list|(
literal|"shallow file was removed during fetch"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|!=
name|mtime
operator|.
name|sec
ifdef|#
directive|ifdef
name|USE_NSEC
operator|||
name|ST_MTIME_NSEC
argument_list|(
name|st
argument_list|)
operator|!=
name|mtime
operator|.
name|nsec
endif|#
directive|endif
condition|)
name|die
argument_list|(
literal|"shallow file was changed during fetch"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|lock
argument_list|,
name|shallow
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_shallow_commits
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
operator|||
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|)
operator|!=
name|sb
operator|.
name|len
condition|)
block|{
name|unlink_or_warn
argument_list|(
name|shallow
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commit_lock_file
argument_list|(
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
name|reprepare_packed_git
argument_list|()
expr_stmt|;
return|return
name|ref_cpy
return|;
block|}
end_function
end_unit
