begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|HOST_NAME_MAX
end_ifndef
begin_define
DECL|macro|HOST_NAME_MAX
define|#
directive|define
name|HOST_NAME_MAX
value|256
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|NO_INITGROUPS
end_ifdef
begin_define
DECL|macro|initgroups
define|#
directive|define
name|initgroups
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(0)
end_define
begin_comment
DECL|macro|initgroups
comment|/* nothing */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|log_syslog
specifier|static
name|int
name|log_syslog
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|verbose
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|reuseaddr
specifier|static
name|int
name|reuseaddr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|informative_errors
specifier|static
name|int
name|informative_errors
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|daemon_usage
specifier|static
specifier|const
name|char
name|daemon_usage
index|[]
init|=
literal|"git daemon [--verbose] [--syslog] [--export-all]\n"
literal|"           [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>]\n"
literal|"           [--strict-paths] [--base-path=<path>] [--base-path-relaxed]\n"
literal|"           [--user-path | --user-path=<path>]\n"
literal|"           [--interpolated-path=<path>]\n"
literal|"           [--reuseaddr] [--pid-file=<file>]\n"
literal|"           [--(enable|disable|allow-override|forbid-override)=<service>]\n"
literal|"           [--access-hook=<path>]\n"
literal|"           [--inetd | [--listen=<host_or_ipaddr>] [--port=<n>]\n"
literal|"                      [--detach] [--user=<user> [--group=<group>]]\n"
literal|"           [<directory>...]"
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* List of acceptable pathname prefixes */
end_comment
begin_decl_stmt
DECL|variable|ok_paths
specifier|static
name|char
modifier|*
modifier|*
name|ok_paths
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|strict_paths
specifier|static
name|int
name|strict_paths
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* If this is set, git-daemon-export-ok is not required */
end_comment
begin_decl_stmt
DECL|variable|export_all_trees
specifier|static
name|int
name|export_all_trees
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Take all paths relative to this one if non-NULL */
end_comment
begin_decl_stmt
DECL|variable|base_path
specifier|static
name|char
modifier|*
name|base_path
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|interpolated_path
specifier|static
name|char
modifier|*
name|interpolated_path
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|base_path_relaxed
specifier|static
name|int
name|base_path_relaxed
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Flag indicating client sent extra args. */
end_comment
begin_decl_stmt
DECL|variable|saw_extended_args
specifier|static
name|int
name|saw_extended_args
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* If defined, ~user notation is allowed and the string is inserted  * after ~user/.  E.g. a request to git://host/~alice/frotz would  * go to /home/alice/pub_git/frotz with --user-path=pub_git.  */
end_comment
begin_decl_stmt
DECL|variable|user_path
specifier|static
specifier|const
name|char
modifier|*
name|user_path
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Timeout, and initial timeout */
end_comment
begin_decl_stmt
DECL|variable|timeout
specifier|static
name|unsigned
name|int
name|timeout
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|init_timeout
specifier|static
name|unsigned
name|int
name|init_timeout
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|hostname
specifier|static
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|canon_hostname
specifier|static
name|char
modifier|*
name|canon_hostname
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ip_address
specifier|static
name|char
modifier|*
name|ip_address
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tcp_port
specifier|static
name|char
modifier|*
name|tcp_port
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|logreport
specifier|static
name|void
name|logreport
parameter_list|(
name|int
name|priority
parameter_list|,
specifier|const
name|char
modifier|*
name|err
parameter_list|,
name|va_list
name|params
parameter_list|)
block|{
if|if
condition|(
name|log_syslog
condition|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|err
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|priority
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Since stderr is set to buffered mode, the 		 * logging of different processes will not overlap 		 * unless they overflow the (rather big) buffers. 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%"
name|PRIuMAX
literal|"] "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|__attribute__
argument_list|(
argument|(format (printf,
literal|1
argument|,
literal|2
argument|))
argument_list|)
end_macro
begin_function
DECL|function|logerror
specifier|static
name|void
name|logerror
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|params
decl_stmt|;
name|va_start
argument_list|(
name|params
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|logreport
argument_list|(
name|LOG_ERR
argument_list|,
name|err
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|__attribute__
argument_list|(
argument|(format (printf,
literal|1
argument|,
literal|2
argument|))
argument_list|)
end_macro
begin_function
DECL|function|loginfo
specifier|static
name|void
name|loginfo
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|params
decl_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
return|return;
name|va_start
argument_list|(
name|params
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|logreport
argument_list|(
name|LOG_INFO
argument_list|,
name|err
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|daemon_die
specifier|static
name|void
name|NORETURN
name|daemon_die
parameter_list|(
specifier|const
name|char
modifier|*
name|err
parameter_list|,
name|va_list
name|params
parameter_list|)
block|{
name|logreport
argument_list|(
name|LOG_ERR
argument_list|,
name|err
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|path_ok
specifier|static
specifier|const
name|char
modifier|*
name|path_ok
parameter_list|(
name|char
modifier|*
name|directory
parameter_list|)
block|{
specifier|static
name|char
name|rpath
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|static
name|char
name|interp_path
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|directory
expr_stmt|;
if|if
condition|(
name|daemon_avoid_alias
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|logerror
argument_list|(
literal|"'%s': aliased"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|dir
operator|==
literal|'~'
condition|)
block|{
if|if
condition|(
operator|!
name|user_path
condition|)
block|{
name|logerror
argument_list|(
literal|"'%s': User-path not allowed"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|user_path
condition|)
block|{
comment|/* Got either "~alice" or "~alice/foo"; 			 * rewrite them to "~alice/%s" or 			 * "~alice/%s/foo". 			 */
name|int
name|namlen
decl_stmt|,
name|restlen
init|=
name|strlen
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|char
modifier|*
name|slash
init|=
name|strchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|slash
condition|)
name|slash
operator|=
name|dir
operator|+
name|restlen
expr_stmt|;
name|namlen
operator|=
name|slash
operator|-
name|dir
expr_stmt|;
name|restlen
operator|-=
name|namlen
expr_stmt|;
name|loginfo
argument_list|(
literal|"userpath<%s>, request<%s>, namlen %d, restlen %d, slash<%s>"
argument_list|,
name|user_path
argument_list|,
name|dir
argument_list|,
name|namlen
argument_list|,
name|restlen
argument_list|,
name|slash
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|rpath
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%.*s/%s%.*s"
argument_list|,
name|namlen
argument_list|,
name|dir
argument_list|,
name|user_path
argument_list|,
name|restlen
argument_list|,
name|slash
argument_list|)
expr_stmt|;
name|dir
operator|=
name|rpath
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|interpolated_path
operator|&&
name|saw_extended_args
condition|)
block|{
name|struct
name|strbuf
name|expanded_path
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf_expand_dict_entry
name|dict
index|[
literal|6
index|]
decl_stmt|;
name|dict
index|[
literal|0
index|]
operator|.
name|placeholder
operator|=
literal|"H"
expr_stmt|;
name|dict
index|[
literal|0
index|]
operator|.
name|value
operator|=
name|hostname
expr_stmt|;
name|dict
index|[
literal|1
index|]
operator|.
name|placeholder
operator|=
literal|"CH"
expr_stmt|;
name|dict
index|[
literal|1
index|]
operator|.
name|value
operator|=
name|canon_hostname
expr_stmt|;
name|dict
index|[
literal|2
index|]
operator|.
name|placeholder
operator|=
literal|"IP"
expr_stmt|;
name|dict
index|[
literal|2
index|]
operator|.
name|value
operator|=
name|ip_address
expr_stmt|;
name|dict
index|[
literal|3
index|]
operator|.
name|placeholder
operator|=
literal|"P"
expr_stmt|;
name|dict
index|[
literal|3
index|]
operator|.
name|value
operator|=
name|tcp_port
expr_stmt|;
name|dict
index|[
literal|4
index|]
operator|.
name|placeholder
operator|=
literal|"D"
expr_stmt|;
name|dict
index|[
literal|4
index|]
operator|.
name|value
operator|=
name|directory
expr_stmt|;
name|dict
index|[
literal|5
index|]
operator|.
name|placeholder
operator|=
name|NULL
expr_stmt|;
name|dict
index|[
literal|5
index|]
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|dir
operator|!=
literal|'/'
condition|)
block|{
comment|/* Allow only absolute */
name|logerror
argument_list|(
literal|"'%s': Non-absolute path denied (interpolated-path active)"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strbuf_expand
argument_list|(
operator|&
name|expanded_path
argument_list|,
name|interpolated_path
argument_list|,
name|strbuf_expand_dict_cb
argument_list|,
operator|&
name|dict
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|interp_path
argument_list|,
name|expanded_path
operator|.
name|buf
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|expanded_path
argument_list|)
expr_stmt|;
name|loginfo
argument_list|(
literal|"Interpolated dir '%s'"
argument_list|,
name|interp_path
argument_list|)
expr_stmt|;
name|dir
operator|=
name|interp_path
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base_path
condition|)
block|{
if|if
condition|(
operator|*
name|dir
operator|!=
literal|'/'
condition|)
block|{
comment|/* Allow only absolute */
name|logerror
argument_list|(
literal|"'%s': Non-absolute path denied (base-path active)"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|snprintf
argument_list|(
name|rpath
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%s%s"
argument_list|,
name|base_path
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|rpath
expr_stmt|;
block|}
name|path
operator|=
name|enter_repo
argument_list|(
name|dir
argument_list|,
name|strict_paths
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
operator|&&
name|base_path
operator|&&
name|base_path_relaxed
condition|)
block|{
comment|/* 		 * if we fail and base_path_relaxed is enabled, try without 		 * prefixing the base path 		 */
name|dir
operator|=
name|directory
expr_stmt|;
name|path
operator|=
name|enter_repo
argument_list|(
name|dir
argument_list|,
name|strict_paths
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|logerror
argument_list|(
literal|"'%s' does not appear to be a git repository"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ok_paths
operator|&&
operator|*
name|ok_paths
condition|)
block|{
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|/* The validation is done on the paths after enter_repo 		 * appends optional {.git,.git/.git} and friends, but 		 * it does not use getcwd().  So if your /pub is 		 * a symlink to /mnt/pub, you can whitelist /pub and 		 * do not have to say /mnt/pub. 		 * Do not say /pub/. 		 */
for|for
control|(
name|pp
operator|=
name|ok_paths
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
name|pathlen
operator|&&
operator|!
name|memcmp
argument_list|(
operator|*
name|pp
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|path
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|!
name|strict_paths
operator|&&
name|path
index|[
name|len
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
name|path
return|;
block|}
block|}
else|else
block|{
comment|/* be backwards compatible */
if|if
condition|(
operator|!
name|strict_paths
condition|)
return|return
name|path
return|;
block|}
name|logerror
argument_list|(
literal|"'%s': not in whitelist"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* Fallthrough. Deny by default */
block|}
end_function
begin_typedef
DECL|typedef|daemon_service_fn
typedef|typedef
name|int
function_decl|(
modifier|*
name|daemon_service_fn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef
begin_struct
DECL|struct|daemon_service
struct|struct
name|daemon_service
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|config_name
specifier|const
name|char
modifier|*
name|config_name
decl_stmt|;
DECL|member|fn
name|daemon_service_fn
name|fn
decl_stmt|;
DECL|member|enabled
name|int
name|enabled
decl_stmt|;
DECL|member|overridable
name|int
name|overridable
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|service_looking_at
specifier|static
name|struct
name|daemon_service
modifier|*
name|service_looking_at
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|service_enabled
specifier|static
name|int
name|service_enabled
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_daemon_config
specifier|static
name|int
name|git_daemon_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"daemon."
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|var
operator|+
literal|7
argument_list|,
name|service_looking_at
operator|->
name|config_name
argument_list|)
condition|)
block|{
name|service_enabled
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* we are not interested in parsing any other configuration here */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|daemon_error
specifier|static
name|int
name|daemon_error
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|informative_errors
condition|)
name|msg
operator|=
literal|"access denied or repository not exported"
expr_stmt|;
name|packet_write
argument_list|(
literal|1
argument_list|,
literal|"ERR %s: %s"
argument_list|,
name|msg
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|access_hook
specifier|static
name|char
modifier|*
name|access_hook
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|run_access_hook
specifier|static
name|int
name|run_access_hook
parameter_list|(
name|struct
name|daemon_service
modifier|*
name|service
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|child_process
name|child
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|8
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arg
init|=
name|argv
decl_stmt|;
name|char
modifier|*
name|eol
decl_stmt|;
name|int
name|seen_errors
init|=
literal|0
decl_stmt|;
DECL|macro|STRARG
define|#
directive|define
name|STRARG
parameter_list|(
name|x
parameter_list|)
value|((x) ? (x) : "")
operator|*
name|arg
operator|++
operator|=
name|access_hook
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|service
operator|->
name|name
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|path
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|STRARG
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|STRARG
argument_list|(
name|canon_hostname
argument_list|)
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|STRARG
argument_list|(
name|ip_address
argument_list|)
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
name|STRARG
argument_list|(
name|tcp_port
argument_list|)
expr_stmt|;
operator|*
name|arg
operator|=
name|NULL
expr_stmt|;
DECL|macro|STRARG
undef|#
directive|undef
name|STRARG
name|memset
argument_list|(
operator|&
name|child
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|.
name|use_shell
operator|=
literal|1
expr_stmt|;
name|child
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|child
operator|.
name|no_stdin
operator|=
literal|1
expr_stmt|;
name|child
operator|.
name|no_stderr
operator|=
literal|1
expr_stmt|;
name|child
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|child
argument_list|)
condition|)
block|{
name|logerror
argument_list|(
literal|"daemon access hook '%s' failed to start"
argument_list|,
name|access_hook
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|buf
argument_list|,
name|child
operator|.
name|out
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"failed to read from pipe to daemon access hook '%s'"
argument_list|,
name|access_hook
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|seen_errors
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|child
operator|.
name|out
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"failed to close pipe to daemon access hook '%s'"
argument_list|,
name|access_hook
argument_list|)
expr_stmt|;
name|seen_errors
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|child
argument_list|)
condition|)
name|seen_errors
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|seen_errors
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error_return
label|:
name|strbuf_ltrim
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|.
name|len
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"service rejected"
argument_list|)
expr_stmt|;
name|eol
operator|=
name|strchr
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
condition|)
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
name|errno
operator|=
name|EACCES
expr_stmt|;
name|daemon_error
argument_list|(
name|dir
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|run_service
specifier|static
name|int
name|run_service
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|struct
name|daemon_service
modifier|*
name|service
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|enabled
init|=
name|service
operator|->
name|enabled
decl_stmt|;
name|loginfo
argument_list|(
literal|"Request %s for '%s'"
argument_list|,
name|service
operator|->
name|name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enabled
operator|&&
operator|!
name|service
operator|->
name|overridable
condition|)
block|{
name|logerror
argument_list|(
literal|"'%s': service not enabled."
argument_list|,
name|service
operator|->
name|name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
name|daemon_error
argument_list|(
name|dir
argument_list|,
literal|"service not enabled"
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|path
operator|=
name|path_ok
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
return|return
name|daemon_error
argument_list|(
name|dir
argument_list|,
literal|"no such repository"
argument_list|)
return|;
comment|/* 	 * Security on the cheap. 	 * 	 * We want a readable HEAD, usable "objects" directory, and 	 * a "git-daemon-export-ok" flag that says that the other side 	 * is ok with us doing this. 	 * 	 * path_ok() uses enter_repo() and does whitelist checking. 	 * We only need to make sure the repository is exported. 	 */
if|if
condition|(
operator|!
name|export_all_trees
operator|&&
name|access
argument_list|(
literal|"git-daemon-export-ok"
argument_list|,
name|F_OK
argument_list|)
condition|)
block|{
name|logerror
argument_list|(
literal|"'%s': repository not exported."
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
name|daemon_error
argument_list|(
name|dir
argument_list|,
literal|"repository not exported"
argument_list|)
return|;
block|}
if|if
condition|(
name|service
operator|->
name|overridable
condition|)
block|{
name|service_looking_at
operator|=
name|service
expr_stmt|;
name|service_enabled
operator|=
operator|-
literal|1
expr_stmt|;
name|git_config
argument_list|(
name|git_daemon_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|service_enabled
condition|)
name|enabled
operator|=
name|service_enabled
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
name|logerror
argument_list|(
literal|"'%s': service not enabled for '%s'"
argument_list|,
name|service
operator|->
name|name
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
name|daemon_error
argument_list|(
name|dir
argument_list|,
literal|"service not enabled"
argument_list|)
return|;
block|}
comment|/* 	 * Optionally, a hook can choose to deny access to the 	 * repository depending on the phase of the moon. 	 */
if|if
condition|(
name|access_hook
operator|&&
name|run_access_hook
argument_list|(
name|service
argument_list|,
name|dir
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * We'll ignore SIGTERM from now on, we have a 	 * good client. 	 */
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
return|return
name|service
operator|->
name|fn
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|copy_to_log
specifier|static
name|void
name|copy_to_log
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|strbuf
name|line
init|=
name|STRBUF_INIT
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|logerror
argument_list|(
literal|"fdopen of error channel failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|line
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|logerror
argument_list|(
literal|"%s"
argument_list|,
name|line
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|run_service_command
specifier|static
name|int
name|run_service_command
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|child_process
name|cld
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cld
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cld
argument_list|)
argument_list|)
expr_stmt|;
name|cld
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|cld
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|cld
operator|.
name|err
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|cld
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copy_to_log
argument_list|(
name|cld
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
name|finish_command
argument_list|(
operator|&
name|cld
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|upload_pack
specifier|static
name|int
name|upload_pack
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Timeout as string */
name|char
name|timeout_buf
index|[
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[]
init|=
block|{
literal|"upload-pack"
block|,
literal|"--strict"
block|,
name|NULL
block|,
literal|"."
block|,
name|NULL
block|}
decl_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|timeout_buf
expr_stmt|;
name|snprintf
argument_list|(
name|timeout_buf
argument_list|,
sizeof|sizeof
name|timeout_buf
argument_list|,
literal|"--timeout=%u"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
name|run_service_command
argument_list|(
name|argv
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|upload_archive
specifier|static
name|int
name|upload_archive
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|argv
index|[]
init|=
block|{
literal|"upload-archive"
block|,
literal|"."
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|run_service_command
argument_list|(
name|argv
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|receive_pack
specifier|static
name|int
name|receive_pack
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|argv
index|[]
init|=
block|{
literal|"receive-pack"
block|,
literal|"."
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|run_service_command
argument_list|(
name|argv
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|daemon_service
specifier|static
name|struct
name|daemon_service
name|daemon_service
index|[]
init|=
block|{
block|{
literal|"upload-archive"
block|,
literal|"uploadarch"
block|,
name|upload_archive
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|"upload-pack"
block|,
literal|"uploadpack"
block|,
name|upload_pack
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"receive-pack"
block|,
literal|"receivepack"
block|,
name|receive_pack
block|,
literal|0
block|,
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|enable_service
specifier|static
name|void
name|enable_service
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|daemon_service
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|daemon_service
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|daemon_service
index|[
name|i
index|]
operator|.
name|enabled
operator|=
name|ena
expr_stmt|;
return|return;
block|}
block|}
name|die
argument_list|(
literal|"No such service %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_service_overridable
specifier|static
name|void
name|make_service_overridable
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|ena
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|daemon_service
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|daemon_service
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|daemon_service
index|[
name|i
index|]
operator|.
name|overridable
operator|=
name|ena
expr_stmt|;
return|return;
block|}
block|}
name|die
argument_list|(
literal|"No such service %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|xstrdup_tolower
specifier|static
name|char
modifier|*
name|xstrdup_tolower
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dup
init|=
name|xstrdup
argument_list|(
name|str
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|dup
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|dup
return|;
block|}
end_function
begin_function
DECL|function|parse_host_and_port
specifier|static
name|void
name|parse_host_and_port
parameter_list|(
name|char
modifier|*
name|hostport
parameter_list|,
name|char
modifier|*
modifier|*
name|host
parameter_list|,
name|char
modifier|*
modifier|*
name|port
parameter_list|)
block|{
if|if
condition|(
operator|*
name|hostport
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|hostport
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|die
argument_list|(
literal|"Invalid request ('[' without ']')"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|host
operator|=
name|hostport
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|end
index|[
literal|1
index|]
condition|)
operator|*
name|port
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|end
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
operator|*
name|port
operator|=
name|end
operator|+
literal|2
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Garbage after end of host part"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|host
operator|=
name|hostport
expr_stmt|;
operator|*
name|port
operator|=
name|strrchr
argument_list|(
name|hostport
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|port
condition|)
block|{
operator|*
operator|*
name|port
operator|=
literal|'\0'
expr_stmt|;
operator|++
operator|*
name|port
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * Read the host as supplied by the client connection.  */
end_comment
begin_function
DECL|function|parse_host_arg
specifier|static
name|void
name|parse_host_arg
parameter_list|(
name|char
modifier|*
name|extra_args
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|vallen
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|extra_args
operator|+
name|buflen
decl_stmt|;
if|if
condition|(
name|extra_args
operator|<
name|end
operator|&&
operator|*
name|extra_args
condition|)
block|{
name|saw_extended_args
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
literal|"host="
argument_list|,
name|extra_args
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|extra_args
operator|+
literal|5
expr_stmt|;
name|vallen
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|val
condition|)
block|{
comment|/* Split<host>:<port> at colon. */
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|port
decl_stmt|;
name|parse_host_and_port
argument_list|(
name|val
argument_list|,
operator|&
name|host
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|free
argument_list|(
name|tcp_port
argument_list|)
expr_stmt|;
name|tcp_port
operator|=
name|xstrdup
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|xstrdup_tolower
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
comment|/* On to the next one */
name|extra_args
operator|=
name|val
operator|+
name|vallen
expr_stmt|;
block|}
if|if
condition|(
name|extra_args
operator|<
name|end
operator|&&
operator|*
name|extra_args
condition|)
name|die
argument_list|(
literal|"Invalid request"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Locate canonical hostname and its IP address. 	 */
if|if
condition|(
name|hostname
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_IPV6
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|int
name|gai
decl_stmt|;
specifier|static
name|char
name|addrbuf
index|[
name|HOST_NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
name|gai
operator|=
name|getaddrinfo
argument_list|(
name|hostname
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gai
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin_addr
init|=
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
decl_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|sin_addr
operator|->
name|sin_addr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ip_address
argument_list|)
expr_stmt|;
name|ip_address
operator|=
name|xstrdup
argument_list|(
name|addrbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|canon_hostname
argument_list|)
expr_stmt|;
name|canon_hostname
operator|=
name|xstrdup
argument_list|(
name|ai
operator|->
name|ai_canonname
condition|?
name|ai
operator|->
name|ai_canonname
else|:
name|ip_address
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|struct
name|hostent
modifier|*
name|hent
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|static
name|char
name|addrbuf
index|[
name|HOST_NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|hent
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|ap
operator|=
name|hent
operator|->
name|h_addr_list
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sin_family
operator|=
name|hent
operator|->
name|h_addrtype
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sa
operator|.
name|sin_addr
argument_list|,
operator|*
name|ap
argument_list|,
name|hent
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|hent
operator|->
name|h_addrtype
argument_list|,
operator|&
name|sa
operator|.
name|sin_addr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|canon_hostname
argument_list|)
expr_stmt|;
name|canon_hostname
operator|=
name|xstrdup
argument_list|(
name|hent
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ip_address
argument_list|)
expr_stmt|;
name|ip_address
operator|=
name|xstrdup
argument_list|(
name|addrbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
DECL|function|execute
specifier|static
name|int
name|execute
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
init|=
name|packet_buffer
decl_stmt|;
name|int
name|pktlen
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|addr
init|=
name|getenv
argument_list|(
literal|"REMOTE_ADDR"
argument_list|)
decl_stmt|,
modifier|*
name|port
init|=
name|getenv
argument_list|(
literal|"REMOTE_PORT"
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
condition|)
name|loginfo
argument_list|(
literal|"Connection from %s:%s"
argument_list|,
name|addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|init_timeout
condition|?
name|init_timeout
else|:
name|timeout
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|packet_read
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|packet_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|packet_buffer
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|!=
name|len
condition|)
name|loginfo
argument_list|(
literal|"Extended attributes (%d bytes) exist<%.*s>"
argument_list|,
operator|(
name|int
operator|)
name|pktlen
operator|-
name|len
argument_list|,
operator|(
name|int
operator|)
name|pktlen
operator|-
name|len
argument_list|,
name|line
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|line
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|pktlen
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|canon_hostname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ip_address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tcp_port
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|canon_hostname
operator|=
name|ip_address
operator|=
name|tcp_port
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|pktlen
condition|)
name|parse_host_arg
argument_list|(
name|line
operator|+
name|len
operator|+
literal|1
argument_list|,
name|pktlen
operator|-
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|daemon_service
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|daemon_service
modifier|*
name|s
init|=
operator|&
operator|(
name|daemon_service
index|[
name|i
index|]
operator|)
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"git-"
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|line
operator|+
literal|4
argument_list|,
name|namelen
argument_list|)
operator|&&
name|line
index|[
name|namelen
operator|+
literal|4
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* 			 * Note: The directory here is probably context sensitive, 			 * and might depend on the actual service being performed. 			 */
return|return
name|run_service
argument_list|(
name|line
operator|+
name|namelen
operator|+
literal|5
argument_list|,
name|s
argument_list|)
return|;
block|}
block|}
name|logerror
argument_list|(
literal|"Protocol error: '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|addrcmp
specifier|static
name|int
name|addrcmp
parameter_list|(
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|s1
parameter_list|,
specifier|const
name|struct
name|sockaddr_storage
modifier|*
name|s2
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa1
init|=
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|s1
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa2
init|=
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|s2
decl_stmt|;
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
condition|)
return|return
name|sa1
operator|->
name|sa_family
operator|-
name|sa2
operator|->
name|sa_family
return|;
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
return|return
name|memcmp
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|s1
operator|)
operator|->
name|sin_addr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|s2
operator|)
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
return|;
ifndef|#
directive|ifndef
name|NO_IPV6
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
return|return
name|memcmp
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|s1
operator|)
operator|->
name|sin6_addr
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|s2
operator|)
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|max_connections
specifier|static
name|int
name|max_connections
init|=
literal|32
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|live_children
specifier|static
name|unsigned
name|int
name|live_children
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|child
specifier|static
struct|struct
name|child
block|{
DECL|member|next
name|struct
name|child
modifier|*
name|next
decl_stmt|;
DECL|member|cld
name|struct
name|child_process
name|cld
decl_stmt|;
DECL|member|address
name|struct
name|sockaddr_storage
name|address
decl_stmt|;
block|}
DECL|variable|firstborn
modifier|*
name|firstborn
struct|;
end_struct
begin_function
DECL|function|add_child
specifier|static
name|void
name|add_child
parameter_list|(
name|struct
name|child_process
modifier|*
name|cld
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|struct
name|child
modifier|*
name|newborn
decl_stmt|,
modifier|*
modifier|*
name|cradle
decl_stmt|;
name|newborn
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newborn
argument_list|)
argument_list|)
expr_stmt|;
name|live_children
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|newborn
operator|->
name|cld
argument_list|,
name|cld
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cld
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|newborn
operator|->
name|address
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
for|for
control|(
name|cradle
operator|=
operator|&
name|firstborn
init|;
operator|*
name|cradle
condition|;
name|cradle
operator|=
operator|&
operator|(
operator|*
name|cradle
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|addrcmp
argument_list|(
operator|&
operator|(
operator|*
name|cradle
operator|)
operator|->
name|address
argument_list|,
operator|&
name|newborn
operator|->
name|address
argument_list|)
condition|)
break|break;
name|newborn
operator|->
name|next
operator|=
operator|*
name|cradle
expr_stmt|;
operator|*
name|cradle
operator|=
name|newborn
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * This gets called if the number of connections grows  * past "max_connections".  *  * We kill the newest connection from a duplicate IP.  */
end_comment
begin_function
DECL|function|kill_some_child
specifier|static
name|void
name|kill_some_child
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|child
modifier|*
name|blanket
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|blanket
operator|=
name|firstborn
operator|)
condition|)
return|return;
for|for
control|(
init|;
operator|(
name|next
operator|=
name|blanket
operator|->
name|next
operator|)
condition|;
name|blanket
operator|=
name|next
control|)
if|if
condition|(
operator|!
name|addrcmp
argument_list|(
operator|&
name|blanket
operator|->
name|address
argument_list|,
operator|&
name|next
operator|->
name|address
argument_list|)
condition|)
block|{
name|kill
argument_list|(
name|blanket
operator|->
name|cld
operator|.
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|check_dead_children
specifier|static
name|void
name|check_dead_children
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|struct
name|child
modifier|*
modifier|*
name|cradle
decl_stmt|,
modifier|*
name|blanket
decl_stmt|;
for|for
control|(
name|cradle
operator|=
operator|&
name|firstborn
init|;
operator|(
name|blanket
operator|=
operator|*
name|cradle
operator|)
condition|;
control|)
if|if
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
name|blanket
operator|->
name|cld
operator|.
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|dead
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|status
condition|)
name|dead
operator|=
literal|" (with error)"
expr_stmt|;
name|loginfo
argument_list|(
literal|"[%"
name|PRIuMAX
literal|"] Disconnected%s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pid
argument_list|,
name|dead
argument_list|)
expr_stmt|;
comment|/* remove the child */
operator|*
name|cradle
operator|=
name|blanket
operator|->
name|next
expr_stmt|;
name|live_children
operator|--
expr_stmt|;
name|free
argument_list|(
name|blanket
argument_list|)
expr_stmt|;
block|}
else|else
name|cradle
operator|=
operator|&
name|blanket
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|cld_argv
specifier|static
name|char
modifier|*
modifier|*
name|cld_argv
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|handle
specifier|static
name|void
name|handle
parameter_list|(
name|int
name|incoming
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|struct
name|child_process
name|cld
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|char
name|addrbuf
index|[
literal|300
index|]
init|=
literal|"REMOTE_ADDR="
decl_stmt|,
name|portbuf
index|[
literal|300
index|]
decl_stmt|;
name|char
modifier|*
name|env
index|[]
init|=
block|{
name|addrbuf
block|,
name|portbuf
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|max_connections
operator|&&
name|live_children
operator|>=
name|max_connections
condition|)
block|{
name|kill_some_child
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* give it some time to die */
name|check_dead_children
argument_list|()
expr_stmt|;
if|if
condition|(
name|live_children
operator|>=
name|max_connections
condition|)
block|{
name|close
argument_list|(
name|incoming
argument_list|)
expr_stmt|;
name|logerror
argument_list|(
literal|"Too many children, dropping connection"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin_addr
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|inet_ntop
argument_list|(
name|addr
operator|->
name|sa_family
argument_list|,
operator|&
name|sin_addr
operator|->
name|sin_addr
argument_list|,
name|addrbuf
operator|+
literal|12
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
operator|-
literal|12
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|portbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|portbuf
argument_list|)
argument_list|,
literal|"REMOTE_PORT=%d"
argument_list|,
name|ntohs
argument_list|(
name|sin_addr
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_IPV6
block|}
elseif|else
if|if
condition|(
name|addr
operator|&&
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6_addr
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|addrbuf
operator|+
literal|12
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
comment|/* stpcpy() is cool */
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|sin6_addr
operator|->
name|sin6_addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
operator|-
literal|13
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|portbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|portbuf
argument_list|)
argument_list|,
literal|"REMOTE_PORT=%d"
argument_list|,
name|ntohs
argument_list|(
name|sin6_addr
operator|->
name|sin6_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|cld
operator|.
name|env
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|env
expr_stmt|;
name|cld
operator|.
name|argv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|cld_argv
expr_stmt|;
name|cld
operator|.
name|in
operator|=
name|incoming
expr_stmt|;
name|cld
operator|.
name|out
operator|=
name|dup
argument_list|(
name|incoming
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|cld
argument_list|)
condition|)
name|logerror
argument_list|(
literal|"unable to fork"
argument_list|)
expr_stmt|;
else|else
name|add_child
argument_list|(
operator|&
name|cld
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|incoming
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|child_handler
specifier|static
name|void
name|child_handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* 	 * Otherwise empty handler because systemcalls will get interrupted 	 * upon signal receipt 	 * SysV needs the handler to be rearmed 	 */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|child_handler
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_reuse_addr
specifier|static
name|int
name|set_reuse_addr
parameter_list|(
name|int
name|sockfd
parameter_list|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|reuseaddr
condition|)
return|return
literal|0
return|;
return|return
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_struct
DECL|struct|socketlist
struct|struct
name|socketlist
block|{
DECL|member|list
name|int
modifier|*
name|list
decl_stmt|;
DECL|member|nr
name|size_t
name|nr
decl_stmt|;
DECL|member|alloc
name|size_t
name|alloc
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|ip2str
specifier|static
specifier|const
name|char
modifier|*
name|ip2str
parameter_list|(
name|int
name|family
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sin
parameter_list|,
name|socklen_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NO_IPV6
specifier|static
name|char
name|ip
index|[
name|INET_ADDRSTRLEN
index|]
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|ip
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|family
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_IPV6
case|case
name|AF_INET6
case|:
name|inet_ntop
argument_list|(
name|family
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin6_addr
argument_list|,
name|ip
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
name|inet_ntop
argument_list|(
name|family
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin_addr
argument_list|,
name|ip
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|ip
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
block|}
return|return
name|ip
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_IPV6
end_ifndef
begin_function
DECL|function|setup_named_sock
specifier|static
name|int
name|setup_named_sock
parameter_list|(
name|char
modifier|*
name|listen_addr
parameter_list|,
name|int
name|listen_port
parameter_list|,
name|struct
name|socketlist
modifier|*
name|socklist
parameter_list|)
block|{
name|int
name|socknum
init|=
literal|0
decl_stmt|;
name|int
name|maxfd
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|pbuf
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai0
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|int
name|gai
decl_stmt|;
name|long
name|flags
decl_stmt|;
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
name|gai
operator|=
name|getaddrinfo
argument_list|(
name|listen_addr
argument_list|,
name|pbuf
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gai
condition|)
block|{
name|logerror
argument_list|(
literal|"getaddrinfo() for %s failed: %s"
argument_list|,
name|listen_addr
argument_list|,
name|gai_strerror
argument_list|(
name|gai
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|ai
operator|=
name|ai0
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
name|int
name|sockfd
decl_stmt|;
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sockfd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|logerror
argument_list|(
literal|"Socket descriptor too large"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: error is not fatal */
block|}
endif|#
directive|endif
if|if
condition|(
name|set_reuse_addr
argument_list|(
name|sockfd
argument_list|)
condition|)
block|{
name|logerror
argument_list|(
literal|"Could not set SO_REUSEADDR: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sockfd
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"Could not bind to %s: %s"
argument_list|,
name|ip2str
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not fatal */
block|}
if|if
condition|(
name|listen
argument_list|(
name|sockfd
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"Could not listen to %s: %s"
argument_list|,
name|ip2str
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not fatal */
block|}
name|flags
operator|=
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|>=
literal|0
condition|)
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFD
argument_list|,
name|flags
operator||
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|socklist
operator|->
name|list
argument_list|,
name|socklist
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|socklist
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|socklist
operator|->
name|list
index|[
name|socklist
operator|->
name|nr
operator|++
index|]
operator|=
name|sockfd
expr_stmt|;
name|socknum
operator|++
expr_stmt|;
if|if
condition|(
name|maxfd
operator|<
name|sockfd
condition|)
name|maxfd
operator|=
name|sockfd
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ai0
argument_list|)
expr_stmt|;
return|return
name|socknum
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* NO_IPV6 */
end_comment
begin_function
DECL|function|setup_named_sock
specifier|static
name|int
name|setup_named_sock
parameter_list|(
name|char
modifier|*
name|listen_addr
parameter_list|,
name|int
name|listen_port
parameter_list|,
name|struct
name|socketlist
modifier|*
name|socklist
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|sockfd
decl_stmt|;
name|long
name|flags
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|listen_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen_addr
condition|)
block|{
comment|/* Well, host better be an IP address here. */
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|listen_addr
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
block|}
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set_reuse_addr
argument_list|(
name|sockfd
argument_list|)
condition|)
block|{
name|logerror
argument_list|(
literal|"Could not set SO_REUSEADDR: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"Could not listen to %s: %s"
argument_list|,
name|ip2str
argument_list|(
name|AF_INET
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|sockfd
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"Could not listen to %s: %s"
argument_list|,
name|ip2str
argument_list|(
name|AF_INET
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|flags
operator|=
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|>=
literal|0
condition|)
name|fcntl
argument_list|(
name|sockfd
argument_list|,
name|F_SETFD
argument_list|,
name|flags
operator||
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|socklist
operator|->
name|list
argument_list|,
name|socklist
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|socklist
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|socklist
operator|->
name|list
index|[
name|socklist
operator|->
name|nr
operator|++
index|]
operator|=
name|sockfd
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|socksetup
specifier|static
name|void
name|socksetup
parameter_list|(
name|struct
name|string_list
modifier|*
name|listen_addr
parameter_list|,
name|int
name|listen_port
parameter_list|,
name|struct
name|socketlist
modifier|*
name|socklist
parameter_list|)
block|{
if|if
condition|(
operator|!
name|listen_addr
operator|->
name|nr
condition|)
name|setup_named_sock
argument_list|(
name|NULL
argument_list|,
name|listen_port
argument_list|,
name|socklist
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|socknum
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listen_addr
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|socknum
operator|=
name|setup_named_sock
argument_list|(
name|listen_addr
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|listen_port
argument_list|,
name|socklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|socknum
operator|==
literal|0
condition|)
name|logerror
argument_list|(
literal|"unable to allocate any listen sockets for host %s on port %u"
argument_list|,
name|listen_addr
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|service_loop
specifier|static
name|int
name|service_loop
parameter_list|(
name|struct
name|socketlist
modifier|*
name|socklist
parameter_list|)
block|{
name|struct
name|pollfd
modifier|*
name|pfd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pfd
operator|=
name|xcalloc
argument_list|(
name|socklist
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|socklist
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|pfd
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|socklist
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
name|pfd
index|[
name|i
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|child_handler
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|check_dead_children
argument_list|()
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
name|pfd
argument_list|,
name|socklist
operator|->
name|nr
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|logerror
argument_list|(
literal|"Poll failed, resuming: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|socklist
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|&
name|POLLIN
condition|)
block|{
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|sai
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_IPV6
name|struct
name|sockaddr_in6
name|sai6
decl_stmt|;
endif|#
directive|endif
block|}
name|ss
union|;
name|socklen_t
name|sslen
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|int
name|incoming
init|=
name|accept
argument_list|(
name|pfd
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|ss
operator|.
name|sa
argument_list|,
operator|&
name|sslen
argument_list|)
decl_stmt|;
if|if
condition|(
name|incoming
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EAGAIN
case|:
case|case
name|EINTR
case|:
case|case
name|ECONNABORTED
case|:
continue|continue;
default|default:
name|die_errno
argument_list|(
literal|"accept returned"
argument_list|)
expr_stmt|;
block|}
block|}
name|handle
argument_list|(
name|incoming
argument_list|,
operator|&
name|ss
operator|.
name|sa
argument_list|,
name|sslen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|NO_POSIX_GOODIES
end_ifdef
begin_struct_decl
struct_decl|struct
name|credentials
struct_decl|;
end_struct_decl
begin_function
DECL|function|drop_privileges
specifier|static
name|void
name|drop_privileges
parameter_list|(
name|struct
name|credentials
modifier|*
name|cred
parameter_list|)
block|{
comment|/* nothing */
block|}
end_function
begin_function
DECL|function|daemonize
specifier|static
name|void
name|daemonize
parameter_list|(
name|void
parameter_list|)
block|{
name|die
argument_list|(
literal|"--detach not supported on this platform"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_credentials
specifier|static
name|struct
name|credentials
modifier|*
name|prepare_credentials
parameter_list|(
specifier|const
name|char
modifier|*
name|user_name
parameter_list|,
specifier|const
name|char
modifier|*
name|group_name
parameter_list|)
block|{
name|die
argument_list|(
literal|"--user not supported on this platform"
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_struct
DECL|struct|credentials
struct|struct
name|credentials
block|{
DECL|member|pass
name|struct
name|passwd
modifier|*
name|pass
decl_stmt|;
DECL|member|gid
name|gid_t
name|gid
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|drop_privileges
specifier|static
name|void
name|drop_privileges
parameter_list|(
name|struct
name|credentials
modifier|*
name|cred
parameter_list|)
block|{
if|if
condition|(
name|cred
operator|&&
operator|(
name|initgroups
argument_list|(
name|cred
operator|->
name|pass
operator|->
name|pw_name
argument_list|,
name|cred
operator|->
name|gid
argument_list|)
operator|||
name|setgid
argument_list|(
name|cred
operator|->
name|gid
argument_list|)
operator|||
name|setuid
argument_list|(
name|cred
operator|->
name|pass
operator|->
name|pw_uid
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"cannot drop privileges"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_credentials
specifier|static
name|struct
name|credentials
modifier|*
name|prepare_credentials
parameter_list|(
specifier|const
name|char
modifier|*
name|user_name
parameter_list|,
specifier|const
name|char
modifier|*
name|group_name
parameter_list|)
block|{
specifier|static
name|struct
name|credentials
name|c
decl_stmt|;
name|c
operator|.
name|pass
operator|=
name|getpwnam
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|.
name|pass
condition|)
name|die
argument_list|(
literal|"user not found - %s"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|group_name
condition|)
name|c
operator|.
name|gid
operator|=
name|c
operator|.
name|pass
operator|->
name|pw_gid
expr_stmt|;
else|else
block|{
name|struct
name|group
modifier|*
name|group
init|=
name|getgrnam
argument_list|(
name|group_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|group
condition|)
name|die
argument_list|(
literal|"group not found - %s"
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
name|c
operator|.
name|gid
operator|=
name|group
operator|->
name|gr_gid
expr_stmt|;
block|}
return|return
operator|&
name|c
return|;
block|}
end_function
begin_function
DECL|function|daemonize
specifier|static
name|void
name|daemonize
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
operator|-
literal|1
case|:
name|die_errno
argument_list|(
literal|"fork failed"
argument_list|)
expr_stmt|;
default|default:
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsid
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|die_errno
argument_list|(
literal|"setsid failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sanitize_stdfds
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|store_pid
specifier|static
name|void
name|store_pid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|die_errno
argument_list|(
literal|"cannot open pid file '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%"
name|PRIuMAX
literal|"\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getpid
argument_list|()
argument_list|)
operator|<
literal|0
operator|||
name|fclose
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|die_errno
argument_list|(
literal|"failed to write pid file '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|serve
specifier|static
name|int
name|serve
parameter_list|(
name|struct
name|string_list
modifier|*
name|listen_addr
parameter_list|,
name|int
name|listen_port
parameter_list|,
name|struct
name|credentials
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|socketlist
name|socklist
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|socksetup
argument_list|(
name|listen_addr
argument_list|,
name|listen_port
argument_list|,
operator|&
name|socklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|socklist
operator|.
name|nr
operator|==
literal|0
condition|)
name|die
argument_list|(
literal|"unable to allocate any listen sockets on port %u"
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
name|drop_privileges
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|loginfo
argument_list|(
literal|"Ready to rumble"
argument_list|)
expr_stmt|;
return|return
name|service_loop
argument_list|(
operator|&
name|socklist
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|listen_port
init|=
literal|0
decl_stmt|;
name|struct
name|string_list
name|listen_addr
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|int
name|serve_mode
init|=
literal|0
decl_stmt|,
name|inetd_mode
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pid_file
init|=
name|NULL
decl_stmt|,
modifier|*
name|user_name
init|=
name|NULL
decl_stmt|,
modifier|*
name|group_name
init|=
name|NULL
decl_stmt|;
name|int
name|detach
init|=
literal|0
decl_stmt|;
name|struct
name|credentials
modifier|*
name|cred
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|git_setup_gettext
argument_list|()
expr_stmt|;
name|git_extract_argv0_path
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--listen="
argument_list|)
condition|)
block|{
name|string_list_append
argument_list|(
operator|&
name|listen_addr
argument_list|,
name|xstrdup_tolower
argument_list|(
name|arg
operator|+
literal|9
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--port="
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
name|n
operator|=
name|strtoul
argument_list|(
name|arg
operator|+
literal|7
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|7
index|]
operator|&&
operator|!
operator|*
name|end
condition|)
block|{
name|listen_port
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--serve"
argument_list|)
condition|)
block|{
name|serve_mode
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--inetd"
argument_list|)
condition|)
block|{
name|inetd_mode
operator|=
literal|1
expr_stmt|;
name|log_syslog
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--syslog"
argument_list|)
condition|)
block|{
name|log_syslog
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--export-all"
argument_list|)
condition|)
block|{
name|export_all_trees
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--access-hook="
argument_list|)
condition|)
block|{
name|access_hook
operator|=
name|arg
operator|+
literal|14
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--timeout="
argument_list|)
condition|)
block|{
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
operator|+
literal|10
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--init-timeout="
argument_list|)
condition|)
block|{
name|init_timeout
operator|=
name|atoi
argument_list|(
name|arg
operator|+
literal|15
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--max-connections="
argument_list|)
condition|)
block|{
name|max_connections
operator|=
name|atoi
argument_list|(
name|arg
operator|+
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_connections
operator|<
literal|0
condition|)
name|max_connections
operator|=
literal|0
expr_stmt|;
comment|/* unlimited */
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--strict-paths"
argument_list|)
condition|)
block|{
name|strict_paths
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--base-path="
argument_list|)
condition|)
block|{
name|base_path
operator|=
name|arg
operator|+
literal|12
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--base-path-relaxed"
argument_list|)
condition|)
block|{
name|base_path_relaxed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--interpolated-path="
argument_list|)
condition|)
block|{
name|interpolated_path
operator|=
name|arg
operator|+
literal|20
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--reuseaddr"
argument_list|)
condition|)
block|{
name|reuseaddr
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--user-path"
argument_list|)
condition|)
block|{
name|user_path
operator|=
literal|""
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--user-path="
argument_list|)
condition|)
block|{
name|user_path
operator|=
name|arg
operator|+
literal|12
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--pid-file="
argument_list|)
condition|)
block|{
name|pid_file
operator|=
name|arg
operator|+
literal|11
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--detach"
argument_list|)
condition|)
block|{
name|detach
operator|=
literal|1
expr_stmt|;
name|log_syslog
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--user="
argument_list|)
condition|)
block|{
name|user_name
operator|=
name|arg
operator|+
literal|7
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--group="
argument_list|)
condition|)
block|{
name|group_name
operator|=
name|arg
operator|+
literal|8
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--enable="
argument_list|)
condition|)
block|{
name|enable_service
argument_list|(
name|arg
operator|+
literal|9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--disable="
argument_list|)
condition|)
block|{
name|enable_service
argument_list|(
name|arg
operator|+
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--allow-override="
argument_list|)
condition|)
block|{
name|make_service_overridable
argument_list|(
name|arg
operator|+
literal|17
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--forbid-override="
argument_list|)
condition|)
block|{
name|make_service_overridable
argument_list|(
name|arg
operator|+
literal|18
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--informative-errors"
argument_list|)
condition|)
block|{
name|informative_errors
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"--no-informative-errors"
argument_list|)
condition|)
block|{
name|informative_errors
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|ok_paths
operator|=
operator|&
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|ok_paths
operator|=
operator|&
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|usage
argument_list|(
name|daemon_usage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_syslog
condition|)
block|{
name|openlog
argument_list|(
literal|"git-daemon"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|set_die_routine
argument_list|(
name|daemon_die
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* avoid splitting a message in the middle */
name|setvbuf
argument_list|(
name|stderr
argument_list|,
name|NULL
argument_list|,
name|_IOFBF
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|inetd_mode
operator|&&
operator|(
name|detach
operator|||
name|group_name
operator|||
name|user_name
operator|)
condition|)
name|die
argument_list|(
literal|"--detach, --user and --group are incompatible with --inetd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inetd_mode
operator|&&
operator|(
name|listen_port
operator|||
operator|(
name|listen_addr
operator|.
name|nr
operator|>
literal|0
operator|)
operator|)
condition|)
name|die
argument_list|(
literal|"--listen= and --port= are incompatible with --inetd"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|listen_port
operator|==
literal|0
condition|)
name|listen_port
operator|=
name|DEFAULT_GIT_PORT
expr_stmt|;
if|if
condition|(
name|group_name
operator|&&
operator|!
name|user_name
condition|)
name|die
argument_list|(
literal|"--group supplied without --user"
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_name
condition|)
name|cred
operator|=
name|prepare_credentials
argument_list|(
name|user_name
argument_list|,
name|group_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_paths
operator|&&
operator|(
operator|!
name|ok_paths
operator|||
operator|!
operator|*
name|ok_paths
operator|)
condition|)
name|die
argument_list|(
literal|"option --strict-paths requires a whitelist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_path
operator|&&
operator|!
name|is_directory
argument_list|(
name|base_path
argument_list|)
condition|)
name|die
argument_list|(
literal|"base-path '%s' does not exist or is not a directory"
argument_list|,
name|base_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|inetd_mode
condition|)
block|{
if|if
condition|(
operator|!
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"failed to redirect stderr to /dev/null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inetd_mode
operator|||
name|serve_mode
condition|)
return|return
name|execute
argument_list|()
return|;
if|if
condition|(
name|detach
condition|)
name|daemonize
argument_list|()
expr_stmt|;
else|else
name|sanitize_stdfds
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid_file
condition|)
name|store_pid
argument_list|(
name|pid_file
argument_list|)
expr_stmt|;
comment|/* prepare argv for serving-processes */
name|cld_argv
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|cld_argv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* git-daemon */
name|cld_argv
index|[
literal|1
index|]
operator|=
literal|"--serve"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|cld_argv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|cld_argv
index|[
name|argc
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|serve
argument_list|(
operator|&
name|listen_addr
argument_list|,
name|listen_port
argument_list|,
name|cred
argument_list|)
return|;
block|}
end_function
end_unit
