begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"graph.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_comment
comment|/* Internal API */
end_comment
begin_comment
comment|/*  * Output a padding line in the graph.  * This is similar to graph_next_line().  However, it is guaranteed to  * never print the current commit line.  Instead, if the commit line is  * next, it will simply output a line of vertical padding, extending the  * branch lines downwards, but leaving them otherwise unchanged.  */
end_comment
begin_function_decl
specifier|static
name|void
name|graph_padding_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * Print a strbuf to stdout.  If the graph is non-NULL, all lines but the  * first will be prefixed with the graph output.  *  * If the strbuf ends with a newline, the output will end after this  * newline.  A new graph line will not be printed after the final newline.  * If the strbuf is empty, no output will be printed.  *  * Since the first line will not include the graph output, the caller is  * responsible for printing this line's graph (perhaps via  * graph_show_commit() or graph_show_oneline()) before calling  * graph_show_strbuf().  */
end_comment
begin_function_decl
specifier|static
name|void
name|graph_show_strbuf
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
specifier|const
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * TODO:  * - Limit the number of columns, similar to the way gitk does.  *   If we reach more than a specified number of columns, omit  *   sections of some columns.  */
end_comment
begin_struct
DECL|struct|column
struct|struct
name|column
block|{
comment|/* 	 * The parent commit of this column. 	 */
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
comment|/* 	 * The color to (optionally) print this column in.  This is an 	 * index into column_colors. 	 */
DECL|member|color
name|unsigned
name|short
name|color
decl_stmt|;
block|}
struct|;
end_struct
begin_enum
DECL|enum|graph_state
enum|enum
name|graph_state
block|{
DECL|enumerator|GRAPH_PADDING
name|GRAPH_PADDING
block|,
DECL|enumerator|GRAPH_SKIP
name|GRAPH_SKIP
block|,
DECL|enumerator|GRAPH_PRE_COMMIT
name|GRAPH_PRE_COMMIT
block|,
DECL|enumerator|GRAPH_COMMIT
name|GRAPH_COMMIT
block|,
DECL|enumerator|GRAPH_POST_MERGE
name|GRAPH_POST_MERGE
block|,
DECL|enumerator|GRAPH_COLLAPSING
name|GRAPH_COLLAPSING
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|column_colors
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|column_colors
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|column_colors_max
specifier|static
name|unsigned
name|short
name|column_colors_max
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|graph_set_column_colors
name|void
name|graph_set_column_colors
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|colors
parameter_list|,
name|unsigned
name|short
name|colors_max
parameter_list|)
block|{
name|column_colors
operator|=
name|colors
expr_stmt|;
name|column_colors_max
operator|=
name|colors_max
expr_stmt|;
block|}
end_function
begin_function
DECL|function|column_get_color_code
specifier|static
specifier|const
name|char
modifier|*
name|column_get_color_code
parameter_list|(
name|unsigned
name|short
name|color
parameter_list|)
block|{
return|return
name|column_colors
index|[
name|color
index|]
return|;
block|}
end_function
begin_function
DECL|function|strbuf_write_column
specifier|static
name|void
name|strbuf_write_column
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|column
modifier|*
name|c
parameter_list|,
name|char
name|col_char
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|color
operator|<
name|column_colors_max
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|column_get_color_code
argument_list|(
name|c
operator|->
name|color
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
name|col_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|color
operator|<
name|column_colors_max
condition|)
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|column_get_color_code
argument_list|(
name|column_colors_max
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|git_graph
struct|struct
name|git_graph
block|{
comment|/* 	 * The commit currently being processed 	 */
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
comment|/* The rev-info used for the current traversal */
DECL|member|revs
name|struct
name|rev_info
modifier|*
name|revs
decl_stmt|;
comment|/* 	 * The number of interesting parents that this commit has. 	 * 	 * Note that this is not the same as the actual number of parents. 	 * This count excludes parents that won't be printed in the graph 	 * output, as determined by graph_is_interesting(). 	 */
DECL|member|num_parents
name|int
name|num_parents
decl_stmt|;
comment|/* 	 * The width of the graph output for this commit. 	 * All rows for this commit are padded to this width, so that 	 * messages printed after the graph output are aligned. 	 */
DECL|member|width
name|int
name|width
decl_stmt|;
comment|/* 	 * The next expansion row to print 	 * when state is GRAPH_PRE_COMMIT 	 */
DECL|member|expansion_row
name|int
name|expansion_row
decl_stmt|;
comment|/* 	 * The current output state. 	 * This tells us what kind of line graph_next_line() should output. 	 */
DECL|member|state
name|enum
name|graph_state
name|state
decl_stmt|;
comment|/* 	 * The output state for the previous line of output. 	 * This is primarily used to determine how the first merge line 	 * should appear, based on the last line of the previous commit. 	 */
DECL|member|prev_state
name|enum
name|graph_state
name|prev_state
decl_stmt|;
comment|/* 	 * The index of the column that refers to this commit. 	 * 	 * If none of the incoming columns refer to this commit, 	 * this will be equal to num_columns. 	 */
DECL|member|commit_index
name|int
name|commit_index
decl_stmt|;
comment|/* 	 * The commit_index for the previously displayed commit. 	 * 	 * This is used to determine how the first line of a merge 	 * graph output should appear, based on the last line of the 	 * previous commit. 	 */
DECL|member|prev_commit_index
name|int
name|prev_commit_index
decl_stmt|;
comment|/* 	 * The maximum number of columns that can be stored in the columns 	 * and new_columns arrays.  This is also half the number of entries 	 * that can be stored in the mapping and new_mapping arrays. 	 */
DECL|member|column_capacity
name|int
name|column_capacity
decl_stmt|;
comment|/* 	 * The number of columns (also called "branch lines" in some places) 	 */
DECL|member|num_columns
name|int
name|num_columns
decl_stmt|;
comment|/* 	 * The number of columns in the new_columns array 	 */
DECL|member|num_new_columns
name|int
name|num_new_columns
decl_stmt|;
comment|/* 	 * The number of entries in the mapping array 	 */
DECL|member|mapping_size
name|int
name|mapping_size
decl_stmt|;
comment|/* 	 * The column state before we output the current commit. 	 */
DECL|member|columns
name|struct
name|column
modifier|*
name|columns
decl_stmt|;
comment|/* 	 * The new column state after we output the current commit. 	 * Only valid when state is GRAPH_COLLAPSING. 	 */
DECL|member|new_columns
name|struct
name|column
modifier|*
name|new_columns
decl_stmt|;
comment|/* 	 * An array that tracks the current state of each 	 * character in the output line during state GRAPH_COLLAPSING. 	 * Each entry is -1 if this character is empty, or a non-negative 	 * integer if the character contains a branch line.  The value of 	 * the integer indicates the target position for this branch line. 	 * (I.e., this array maps the current column positions to their 	 * desired positions.) 	 * 	 * The maximum capacity of this array is always 	 * sizeof(int) * 2 * column_capacity. 	 */
DECL|member|mapping
name|int
modifier|*
name|mapping
decl_stmt|;
comment|/* 	 * A temporary array for computing the next mapping state 	 * while we are outputting a mapping line.  This is stored as part 	 * of the git_graph simply so we don't have to allocate a new 	 * temporary array each time we have to output a collapsing line. 	 */
DECL|member|new_mapping
name|int
modifier|*
name|new_mapping
decl_stmt|;
comment|/* 	 * The current default column color being used.  This is 	 * stored as an index into the array column_colors. 	 */
DECL|member|default_column_color
name|unsigned
name|short
name|default_column_color
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|diff_output_prefix_callback
specifier|static
name|struct
name|strbuf
modifier|*
name|diff_output_prefix_callback
parameter_list|(
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|git_graph
modifier|*
name|graph
init|=
name|data
decl_stmt|;
specifier|static
name|struct
name|strbuf
name|msgbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|assert
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output_prefix_length
operator|=
name|graph
operator|->
name|width
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|graph_padding_line
argument_list|(
name|graph
argument_list|,
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
return|return
operator|&
name|msgbuf
return|;
block|}
end_function
begin_function
DECL|function|graph_init
name|struct
name|git_graph
modifier|*
name|graph_init
parameter_list|(
name|struct
name|rev_info
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|git_graph
modifier|*
name|graph
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|git_graph
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|column_colors
condition|)
name|graph_set_column_colors
argument_list|(
name|column_colors_ansi
argument_list|,
name|column_colors_ansi_max
argument_list|)
expr_stmt|;
name|graph
operator|->
name|commit
operator|=
name|NULL
expr_stmt|;
name|graph
operator|->
name|revs
operator|=
name|opt
expr_stmt|;
name|graph
operator|->
name|num_parents
operator|=
literal|0
expr_stmt|;
name|graph
operator|->
name|expansion_row
operator|=
literal|0
expr_stmt|;
name|graph
operator|->
name|state
operator|=
name|GRAPH_PADDING
expr_stmt|;
name|graph
operator|->
name|prev_state
operator|=
name|GRAPH_PADDING
expr_stmt|;
name|graph
operator|->
name|commit_index
operator|=
literal|0
expr_stmt|;
name|graph
operator|->
name|prev_commit_index
operator|=
literal|0
expr_stmt|;
name|graph
operator|->
name|num_columns
operator|=
literal|0
expr_stmt|;
name|graph
operator|->
name|num_new_columns
operator|=
literal|0
expr_stmt|;
name|graph
operator|->
name|mapping_size
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Start the column color at the maximum value, since we'll 	 * always increment it for the first commit we output. 	 * This way we start at 0 for the first commit. 	 */
name|graph
operator|->
name|default_column_color
operator|=
name|column_colors_max
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Allocate a reasonably large default number of columns 	 * We'll automatically grow columns later if we need more room. 	 */
name|graph
operator|->
name|column_capacity
operator|=
literal|30
expr_stmt|;
name|graph
operator|->
name|columns
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|column
argument_list|)
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
name|graph
operator|->
name|new_columns
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|column
argument_list|)
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
name|graph
operator|->
name|mapping
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
name|graph
operator|->
name|new_mapping
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
comment|/* 	 * The diff output prefix callback, with this we can make 	 * all the diff output to align with the graph lines. 	 */
name|opt
operator|->
name|diffopt
operator|.
name|output_prefix
operator|=
name|diff_output_prefix_callback
expr_stmt|;
name|opt
operator|->
name|diffopt
operator|.
name|output_prefix_data
operator|=
name|graph
expr_stmt|;
name|opt
operator|->
name|diffopt
operator|.
name|output_prefix_length
operator|=
literal|0
expr_stmt|;
return|return
name|graph
return|;
block|}
end_function
begin_function
DECL|function|graph_update_state
specifier|static
name|void
name|graph_update_state
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|enum
name|graph_state
name|s
parameter_list|)
block|{
name|graph
operator|->
name|prev_state
operator|=
name|graph
operator|->
name|state
expr_stmt|;
name|graph
operator|->
name|state
operator|=
name|s
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_ensure_capacity
specifier|static
name|void
name|graph_ensure_capacity
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|int
name|num_columns
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|->
name|column_capacity
operator|>=
name|num_columns
condition|)
return|return;
do|do
block|{
name|graph
operator|->
name|column_capacity
operator|*=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|graph
operator|->
name|column_capacity
operator|<
name|num_columns
condition|)
do|;
name|graph
operator|->
name|columns
operator|=
name|xrealloc
argument_list|(
name|graph
operator|->
name|columns
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|column
argument_list|)
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
name|graph
operator|->
name|new_columns
operator|=
name|xrealloc
argument_list|(
name|graph
operator|->
name|new_columns
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|column
argument_list|)
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
name|graph
operator|->
name|mapping
operator|=
name|xrealloc
argument_list|(
name|graph
operator|->
name|mapping
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
name|graph
operator|->
name|new_mapping
operator|=
name|xrealloc
argument_list|(
name|graph
operator|->
name|new_mapping
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|*
name|graph
operator|->
name|column_capacity
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Returns 1 if the commit will be printed in the graph output,  * and 0 otherwise.  */
end_comment
begin_function
DECL|function|graph_is_interesting
specifier|static
name|int
name|graph_is_interesting
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
comment|/* 	 * If revs->boundary is set, commits whose children have 	 * been shown are always interesting, even if they have the 	 * UNINTERESTING or TREESAME flags set. 	 */
if|if
condition|(
name|graph
operator|->
name|revs
operator|&&
name|graph
operator|->
name|revs
operator|->
name|boundary
condition|)
block|{
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|CHILD_SHOWN
condition|)
return|return
literal|1
return|;
block|}
comment|/* 	 * Otherwise, use get_commit_action() to see if this commit is 	 * interesting 	 */
return|return
name|get_commit_action
argument_list|(
name|graph
operator|->
name|revs
argument_list|,
name|commit
argument_list|)
operator|==
name|commit_show
return|;
block|}
end_function
begin_function
DECL|function|next_interesting_parent
specifier|static
name|struct
name|commit_list
modifier|*
name|next_interesting_parent
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|commit_list
modifier|*
name|orig
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
decl_stmt|;
comment|/* 	 * If revs->first_parent_only is set, only the first 	 * parent is interesting.  None of the others are. 	 */
if|if
condition|(
name|graph
operator|->
name|revs
operator|->
name|first_parent_only
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Return the next interesting commit after orig 	 */
for|for
control|(
name|list
operator|=
name|orig
operator|->
name|next
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|graph_is_interesting
argument_list|(
name|graph
argument_list|,
name|list
operator|->
name|item
argument_list|)
condition|)
return|return
name|list
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|first_interesting_parent
specifier|static
name|struct
name|commit_list
modifier|*
name|first_interesting_parent
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|graph
operator|->
name|commit
operator|->
name|parents
decl_stmt|;
comment|/* 	 * If this commit has no parents, ignore it 	 */
if|if
condition|(
operator|!
name|parents
condition|)
return|return
name|NULL
return|;
comment|/* 	 * If the first parent is interesting, return it 	 */
if|if
condition|(
name|graph_is_interesting
argument_list|(
name|graph
argument_list|,
name|parents
operator|->
name|item
argument_list|)
condition|)
return|return
name|parents
return|;
comment|/* 	 * Otherwise, call next_interesting_parent() to get 	 * the next interesting parent 	 */
return|return
name|next_interesting_parent
argument_list|(
name|graph
argument_list|,
name|parents
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|graph_get_current_column_color
specifier|static
name|unsigned
name|short
name|graph_get_current_column_color
parameter_list|(
specifier|const
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
if|if
condition|(
operator|!
name|want_color
argument_list|(
name|graph
operator|->
name|revs
operator|->
name|diffopt
operator|.
name|use_color
argument_list|)
condition|)
return|return
name|column_colors_max
return|;
return|return
name|graph
operator|->
name|default_column_color
return|;
block|}
end_function
begin_comment
comment|/*  * Update the graph's default column color.  */
end_comment
begin_function
DECL|function|graph_increment_column_color
specifier|static
name|void
name|graph_increment_column_color
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|graph
operator|->
name|default_column_color
operator|=
operator|(
name|graph
operator|->
name|default_column_color
operator|+
literal|1
operator|)
operator|%
name|column_colors_max
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_find_commit_color
specifier|static
name|unsigned
name|short
name|graph_find_commit_color
parameter_list|(
specifier|const
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|num_columns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|graph
operator|->
name|columns
index|[
name|i
index|]
operator|.
name|commit
operator|==
name|commit
condition|)
return|return
name|graph
operator|->
name|columns
index|[
name|i
index|]
operator|.
name|color
return|;
block|}
return|return
name|graph_get_current_column_color
argument_list|(
name|graph
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|graph_insert_into_new_columns
specifier|static
name|void
name|graph_insert_into_new_columns
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
modifier|*
name|mapping_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * If the commit is already in the new_columns list, we don't need to 	 * add it.  Just update the mapping correctly. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|num_new_columns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|graph
operator|->
name|new_columns
index|[
name|i
index|]
operator|.
name|commit
operator|==
name|commit
condition|)
block|{
name|graph
operator|->
name|mapping
index|[
operator|*
name|mapping_index
index|]
operator|=
name|i
expr_stmt|;
operator|*
name|mapping_index
operator|+=
literal|2
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * This commit isn't already in new_columns.  Add it. 	 */
name|graph
operator|->
name|new_columns
index|[
name|graph
operator|->
name|num_new_columns
index|]
operator|.
name|commit
operator|=
name|commit
expr_stmt|;
name|graph
operator|->
name|new_columns
index|[
name|graph
operator|->
name|num_new_columns
index|]
operator|.
name|color
operator|=
name|graph_find_commit_color
argument_list|(
name|graph
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|graph
operator|->
name|mapping
index|[
operator|*
name|mapping_index
index|]
operator|=
name|graph
operator|->
name|num_new_columns
expr_stmt|;
operator|*
name|mapping_index
operator|+=
literal|2
expr_stmt|;
name|graph
operator|->
name|num_new_columns
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_update_width
specifier|static
name|void
name|graph_update_width
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|int
name|is_commit_in_existing_columns
parameter_list|)
block|{
comment|/* 	 * Compute the width needed to display the graph for this commit. 	 * This is the maximum width needed for any row.  All other rows 	 * will be padded to this width. 	 * 	 * Compute the number of columns in the widest row: 	 * Count each existing column (graph->num_columns), and each new 	 * column added by this commit. 	 */
name|int
name|max_cols
init|=
name|graph
operator|->
name|num_columns
operator|+
name|graph
operator|->
name|num_parents
decl_stmt|;
comment|/* 	 * Even if the current commit has no parents to be printed, it 	 * still takes up a column for itself. 	 */
if|if
condition|(
name|graph
operator|->
name|num_parents
operator|<
literal|1
condition|)
name|max_cols
operator|++
expr_stmt|;
comment|/* 	 * We added a column for the current commit as part of 	 * graph->num_parents.  If the current commit was already in 	 * graph->columns, then we have double counted it. 	 */
if|if
condition|(
name|is_commit_in_existing_columns
condition|)
name|max_cols
operator|--
expr_stmt|;
comment|/* 	 * Each column takes up 2 spaces 	 */
name|graph
operator|->
name|width
operator|=
name|max_cols
operator|*
literal|2
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_update_columns
specifier|static
name|void
name|graph_update_columns
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
decl_stmt|;
name|struct
name|column
modifier|*
name|tmp_columns
decl_stmt|;
name|int
name|max_new_columns
decl_stmt|;
name|int
name|mapping_idx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|seen_this
decl_stmt|,
name|is_commit_in_columns
decl_stmt|;
comment|/* 	 * Swap graph->columns with graph->new_columns 	 * graph->columns contains the state for the previous commit, 	 * and new_columns now contains the state for our commit. 	 * 	 * We'll re-use the old columns array as storage to compute the new 	 * columns list for the commit after this one. 	 */
name|tmp_columns
operator|=
name|graph
operator|->
name|columns
expr_stmt|;
name|graph
operator|->
name|columns
operator|=
name|graph
operator|->
name|new_columns
expr_stmt|;
name|graph
operator|->
name|num_columns
operator|=
name|graph
operator|->
name|num_new_columns
expr_stmt|;
name|graph
operator|->
name|new_columns
operator|=
name|tmp_columns
expr_stmt|;
name|graph
operator|->
name|num_new_columns
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now update new_columns and mapping with the information for the 	 * commit after this one. 	 * 	 * First, make sure we have enough room.  At most, there will 	 * be graph->num_columns + graph->num_parents columns for the next 	 * commit. 	 */
name|max_new_columns
operator|=
name|graph
operator|->
name|num_columns
operator|+
name|graph
operator|->
name|num_parents
expr_stmt|;
name|graph_ensure_capacity
argument_list|(
name|graph
argument_list|,
name|max_new_columns
argument_list|)
expr_stmt|;
comment|/* 	 * Clear out graph->mapping 	 */
name|graph
operator|->
name|mapping_size
operator|=
literal|2
operator|*
name|max_new_columns
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|mapping_size
condition|;
name|i
operator|++
control|)
name|graph
operator|->
name|mapping
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Populate graph->new_columns and graph->mapping 	 * 	 * Some of the parents of this commit may already be in 	 * graph->columns.  If so, graph->new_columns should only contain a 	 * single entry for each such commit.  graph->mapping should 	 * contain information about where each current branch line is 	 * supposed to end up after the collapsing is performed. 	 */
name|seen_this
operator|=
literal|0
expr_stmt|;
name|mapping_idx
operator|=
literal|0
expr_stmt|;
name|is_commit_in_columns
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|graph
operator|->
name|num_columns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|commit
modifier|*
name|col_commit
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|graph
operator|->
name|num_columns
condition|)
block|{
if|if
condition|(
name|seen_this
condition|)
break|break;
name|is_commit_in_columns
operator|=
literal|0
expr_stmt|;
name|col_commit
operator|=
name|graph
operator|->
name|commit
expr_stmt|;
block|}
else|else
block|{
name|col_commit
operator|=
name|graph
operator|->
name|columns
index|[
name|i
index|]
operator|.
name|commit
expr_stmt|;
block|}
if|if
condition|(
name|col_commit
operator|==
name|graph
operator|->
name|commit
condition|)
block|{
name|int
name|old_mapping_idx
init|=
name|mapping_idx
decl_stmt|;
name|seen_this
operator|=
literal|1
expr_stmt|;
name|graph
operator|->
name|commit_index
operator|=
name|i
expr_stmt|;
for|for
control|(
name|parent
operator|=
name|first_interesting_parent
argument_list|(
name|graph
argument_list|)
init|;
name|parent
condition|;
name|parent
operator|=
name|next_interesting_parent
argument_list|(
name|graph
argument_list|,
name|parent
argument_list|)
control|)
block|{
comment|/* 				 * If this is a merge, or the start of a new 				 * childless column, increment the current 				 * color. 				 */
if|if
condition|(
name|graph
operator|->
name|num_parents
operator|>
literal|1
operator|||
operator|!
name|is_commit_in_columns
condition|)
block|{
name|graph_increment_column_color
argument_list|(
name|graph
argument_list|)
expr_stmt|;
block|}
name|graph_insert_into_new_columns
argument_list|(
name|graph
argument_list|,
name|parent
operator|->
name|item
argument_list|,
operator|&
name|mapping_idx
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We always need to increment mapping_idx by at 			 * least 2, even if it has no interesting parents. 			 * The current commit always takes up at least 2 			 * spaces. 			 */
if|if
condition|(
name|mapping_idx
operator|==
name|old_mapping_idx
condition|)
name|mapping_idx
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|graph_insert_into_new_columns
argument_list|(
name|graph
argument_list|,
name|col_commit
argument_list|,
operator|&
name|mapping_idx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Shrink mapping_size to be the minimum necessary 	 */
while|while
condition|(
name|graph
operator|->
name|mapping_size
operator|>
literal|1
operator|&&
name|graph
operator|->
name|mapping
index|[
name|graph
operator|->
name|mapping_size
operator|-
literal|1
index|]
operator|<
literal|0
condition|)
name|graph
operator|->
name|mapping_size
operator|--
expr_stmt|;
comment|/* 	 * Compute graph->width for this commit 	 */
name|graph_update_width
argument_list|(
name|graph
argument_list|,
name|is_commit_in_columns
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_update
name|void
name|graph_update
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
decl_stmt|;
comment|/* 	 * Set the new commit 	 */
name|graph
operator|->
name|commit
operator|=
name|commit
expr_stmt|;
comment|/* 	 * Count how many interesting parents this commit has 	 */
name|graph
operator|->
name|num_parents
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parent
operator|=
name|first_interesting_parent
argument_list|(
name|graph
argument_list|)
init|;
name|parent
condition|;
name|parent
operator|=
name|next_interesting_parent
argument_list|(
name|graph
argument_list|,
name|parent
argument_list|)
control|)
block|{
name|graph
operator|->
name|num_parents
operator|++
expr_stmt|;
block|}
comment|/* 	 * Store the old commit_index in prev_commit_index. 	 * graph_update_columns() will update graph->commit_index for this 	 * commit. 	 */
name|graph
operator|->
name|prev_commit_index
operator|=
name|graph
operator|->
name|commit_index
expr_stmt|;
comment|/* 	 * Call graph_update_columns() to update 	 * columns, new_columns, and mapping. 	 */
name|graph_update_columns
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|graph
operator|->
name|expansion_row
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Update graph->state. 	 * Note that we don't call graph_update_state() here, since 	 * we don't want to update graph->prev_state.  No line for 	 * graph->state was ever printed. 	 * 	 * If the previous commit didn't get to the GRAPH_PADDING state, 	 * it never finished its output.  Goto GRAPH_SKIP, to print out 	 * a line to indicate that portion of the graph is missing. 	 * 	 * If there are 3 or more parents, we may need to print extra rows 	 * before the commit, to expand the branch lines around it and make 	 * room for it.  We need to do this only if there is a branch row 	 * (or more) to the right of this commit. 	 * 	 * If there are less than 3 parents, we can immediately print the 	 * commit line. 	 */
if|if
condition|(
name|graph
operator|->
name|state
operator|!=
name|GRAPH_PADDING
condition|)
name|graph
operator|->
name|state
operator|=
name|GRAPH_SKIP
expr_stmt|;
elseif|else
if|if
condition|(
name|graph
operator|->
name|num_parents
operator|>=
literal|3
operator|&&
name|graph
operator|->
name|commit_index
operator|<
operator|(
name|graph
operator|->
name|num_columns
operator|-
literal|1
operator|)
condition|)
name|graph
operator|->
name|state
operator|=
name|GRAPH_PRE_COMMIT
expr_stmt|;
else|else
name|graph
operator|->
name|state
operator|=
name|GRAPH_COMMIT
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_is_mapping_correct
specifier|static
name|int
name|graph_is_mapping_correct
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * The mapping is up to date if each entry is at its target, 	 * or is 1 greater than its target. 	 * (If it is 1 greater than the target, '/' will be printed, so it 	 * will look correct on the next row.) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|mapping_size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|target
init|=
name|graph
operator|->
name|mapping
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|target
operator|==
operator|(
name|i
operator|/
literal|2
operator|)
condition|)
continue|continue;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|graph_pad_horizontally
specifier|static
name|void
name|graph_pad_horizontally
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|chars_written
parameter_list|)
block|{
comment|/* 	 * Add additional spaces to the end of the strbuf, so that all 	 * lines for a particular commit have the same width. 	 * 	 * This way, fields printed to the right of the graph will remain 	 * aligned for the entire commit. 	 */
name|int
name|extra
decl_stmt|;
if|if
condition|(
name|chars_written
operator|>=
name|graph
operator|->
name|width
condition|)
return|return;
name|extra
operator|=
name|graph
operator|->
name|width
operator|-
name|chars_written
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%*s"
argument_list|,
operator|(
name|int
operator|)
name|extra
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_output_padding_line
specifier|static
name|void
name|graph_output_padding_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * We could conceivable be called with a NULL commit 	 * if our caller has a bug, and invokes graph_next_line() 	 * immediately after graph_init(), without first calling 	 * graph_update().  Return without outputting anything in this 	 * case. 	 */
if|if
condition|(
operator|!
name|graph
operator|->
name|commit
condition|)
return|return;
comment|/* 	 * Output a padding row, that leaves all branch lines unchanged 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|num_new_columns
condition|;
name|i
operator|++
control|)
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
operator|&
name|graph
operator|->
name|new_columns
index|[
name|i
index|]
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|graph_pad_horizontally
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|,
name|graph
operator|->
name|num_new_columns
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_output_skip_line
specifier|static
name|void
name|graph_output_skip_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
comment|/* 	 * Output an ellipsis to indicate that a portion 	 * of the graph is missing. 	 */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|graph_pad_horizontally
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|num_parents
operator|>=
literal|3
operator|&&
name|graph
operator|->
name|commit_index
operator|<
operator|(
name|graph
operator|->
name|num_columns
operator|-
literal|1
operator|)
condition|)
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_PRE_COMMIT
argument_list|)
expr_stmt|;
else|else
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_COMMIT
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_output_pre_commit_line
specifier|static
name|void
name|graph_output_pre_commit_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|num_expansion_rows
decl_stmt|;
name|int
name|i
decl_stmt|,
name|seen_this
decl_stmt|;
name|int
name|chars_written
decl_stmt|;
comment|/* 	 * This function formats a row that increases the space around a commit 	 * with multiple parents, to make room for it.  It should only be 	 * called when there are 3 or more parents. 	 * 	 * We need 2 extra rows for every parent over 2. 	 */
name|assert
argument_list|(
name|graph
operator|->
name|num_parents
operator|>=
literal|3
argument_list|)
expr_stmt|;
name|num_expansion_rows
operator|=
operator|(
name|graph
operator|->
name|num_parents
operator|-
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
comment|/* 	 * graph->expansion_row tracks the current expansion row we are on. 	 * It should be in the range [0, num_expansion_rows - 1] 	 */
name|assert
argument_list|(
literal|0
operator|<=
name|graph
operator|->
name|expansion_row
operator|&&
name|graph
operator|->
name|expansion_row
operator|<
name|num_expansion_rows
argument_list|)
expr_stmt|;
comment|/* 	 * Output the row 	 */
name|seen_this
operator|=
literal|0
expr_stmt|;
name|chars_written
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|num_columns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|column
modifier|*
name|col
init|=
operator|&
name|graph
operator|->
name|columns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|col
operator|->
name|commit
operator|==
name|graph
operator|->
name|commit
condition|)
block|{
name|seen_this
operator|=
literal|1
expr_stmt|;
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"%*s"
argument_list|,
name|graph
operator|->
name|expansion_row
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|chars_written
operator|+=
literal|1
operator|+
name|graph
operator|->
name|expansion_row
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_this
operator|&&
operator|(
name|graph
operator|->
name|expansion_row
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * This is the first line of the pre-commit output. 			 * If the previous commit was a merge commit and 			 * ended in the GRAPH_POST_MERGE state, all branch 			 * lines after graph->prev_commit_index were 			 * printed as "\" on the previous line.  Continue 			 * to print them as "\" on this line.  Otherwise, 			 * print the branch lines as "|". 			 */
if|if
condition|(
name|graph
operator|->
name|prev_state
operator|==
name|GRAPH_POST_MERGE
operator|&&
name|graph
operator|->
name|prev_commit_index
operator|<
name|i
condition|)
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
else|else
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_this
operator|&&
operator|(
name|graph
operator|->
name|expansion_row
operator|>
literal|0
operator|)
condition|)
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
else|else
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
name|graph_pad_horizontally
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|,
name|chars_written
argument_list|)
expr_stmt|;
comment|/* 	 * Increment graph->expansion_row, 	 * and move to state GRAPH_COMMIT if necessary 	 */
name|graph
operator|->
name|expansion_row
operator|++
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|expansion_row
operator|>=
name|num_expansion_rows
condition|)
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_COMMIT
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_output_commit_char
specifier|static
name|void
name|graph_output_commit_char
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
comment|/* 	 * For boundary commits, print 'o' 	 * (We should only see boundary commits when revs->boundary is set.) 	 */
if|if
condition|(
name|graph
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|BOUNDARY
condition|)
block|{
name|assert
argument_list|(
name|graph
operator|->
name|revs
operator|->
name|boundary
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * get_revision_mark() handles all other cases without assert() 	 */
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|get_revision_mark
argument_list|(
name|graph
operator|->
name|revs
argument_list|,
name|graph
operator|->
name|commit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Draw an octopus merge and return the number of characters written.  */
end_comment
begin_function
DECL|function|graph_draw_octopus_merge
specifier|static
name|int
name|graph_draw_octopus_merge
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
comment|/* 	 * Here dashless_commits represents the number of parents 	 * which don't need to have dashes (because their edges fit 	 * neatly under the commit). 	 */
specifier|const
name|int
name|dashless_commits
init|=
literal|2
decl_stmt|;
name|int
name|col_num
decl_stmt|,
name|i
decl_stmt|;
name|int
name|num_dashes
init|=
operator|(
operator|(
name|graph
operator|->
name|num_parents
operator|-
name|dashless_commits
operator|)
operator|*
literal|2
operator|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dashes
condition|;
name|i
operator|++
control|)
block|{
name|col_num
operator|=
operator|(
name|i
operator|/
literal|2
operator|)
operator|+
name|dashless_commits
expr_stmt|;
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
operator|&
name|graph
operator|->
name|new_columns
index|[
name|col_num
index|]
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|col_num
operator|=
operator|(
name|i
operator|/
literal|2
operator|)
operator|+
name|dashless_commits
expr_stmt|;
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
operator|&
name|graph
operator|->
name|new_columns
index|[
name|col_num
index|]
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
return|return
name|num_dashes
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|graph_output_commit_line
specifier|static
name|void
name|graph_output_commit_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|seen_this
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chars_written
decl_stmt|;
comment|/* 	 * Output the row containing this commit 	 * Iterate up to and including graph->num_columns, 	 * since the current commit may not be in any of the existing 	 * columns.  (This happens when the current commit doesn't have any 	 * children that we have already processed.) 	 */
name|seen_this
operator|=
literal|0
expr_stmt|;
name|chars_written
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|graph
operator|->
name|num_columns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|column
modifier|*
name|col
init|=
operator|&
name|graph
operator|->
name|columns
index|[
name|i
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|col_commit
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|graph
operator|->
name|num_columns
condition|)
block|{
if|if
condition|(
name|seen_this
condition|)
break|break;
name|col_commit
operator|=
name|graph
operator|->
name|commit
expr_stmt|;
block|}
else|else
block|{
name|col_commit
operator|=
name|graph
operator|->
name|columns
index|[
name|i
index|]
operator|.
name|commit
expr_stmt|;
block|}
if|if
condition|(
name|col_commit
operator|==
name|graph
operator|->
name|commit
condition|)
block|{
name|seen_this
operator|=
literal|1
expr_stmt|;
name|graph_output_commit_char
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|num_parents
operator|>
literal|2
condition|)
name|chars_written
operator|+=
name|graph_draw_octopus_merge
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_this
operator|&&
operator|(
name|graph
operator|->
name|num_parents
operator|>
literal|2
operator|)
condition|)
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_this
operator|&&
operator|(
name|graph
operator|->
name|num_parents
operator|==
literal|2
operator|)
condition|)
block|{
comment|/* 			 * This is a 2-way merge commit. 			 * There is no GRAPH_PRE_COMMIT stage for 2-way 			 * merges, so this is the first line of output 			 * for this commit.  Check to see what the previous 			 * line of output was. 			 * 			 * If it was GRAPH_POST_MERGE, the branch line 			 * coming into this commit may have been '\', 			 * and not '|' or '/'.  If so, output the branch 			 * line as '\' on this line, instead of '|'.  This 			 * makes the output look nicer. 			 */
if|if
condition|(
name|graph
operator|->
name|prev_state
operator|==
name|GRAPH_POST_MERGE
operator|&&
name|graph
operator|->
name|prev_commit_index
operator|<
name|i
condition|)
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
else|else
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
else|else
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
block|}
name|graph_pad_horizontally
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|,
name|chars_written
argument_list|)
expr_stmt|;
comment|/* 	 * Update graph->state 	 */
if|if
condition|(
name|graph
operator|->
name|num_parents
operator|>
literal|1
condition|)
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_POST_MERGE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|graph_is_mapping_correct
argument_list|(
name|graph
argument_list|)
condition|)
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_PADDING
argument_list|)
expr_stmt|;
else|else
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_COLLAPSING
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_new_column_by_commit
specifier|static
name|struct
name|column
modifier|*
name|find_new_column_by_commit
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|num_new_columns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|graph
operator|->
name|new_columns
index|[
name|i
index|]
operator|.
name|commit
operator|==
name|commit
condition|)
return|return
operator|&
name|graph
operator|->
name|new_columns
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|graph_output_post_merge_line
specifier|static
name|void
name|graph_output_post_merge_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|seen_this
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|chars_written
decl_stmt|;
comment|/* 	 * Output the post-merge row 	 */
name|chars_written
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|graph
operator|->
name|num_columns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|column
modifier|*
name|col
init|=
operator|&
name|graph
operator|->
name|columns
index|[
name|i
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|col_commit
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|graph
operator|->
name|num_columns
condition|)
block|{
if|if
condition|(
name|seen_this
condition|)
break|break;
name|col_commit
operator|=
name|graph
operator|->
name|commit
expr_stmt|;
block|}
else|else
block|{
name|col_commit
operator|=
name|col
operator|->
name|commit
expr_stmt|;
block|}
if|if
condition|(
name|col_commit
operator|==
name|graph
operator|->
name|commit
condition|)
block|{
comment|/* 			 * Since the current commit is a merge find 			 * the columns for the parent commits in 			 * new_columns and use those to format the 			 * edges. 			 */
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|;
name|struct
name|column
modifier|*
name|par_column
decl_stmt|;
name|seen_this
operator|=
literal|1
expr_stmt|;
name|parents
operator|=
name|first_interesting_parent
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|par_column
operator|=
name|find_new_column_by_commit
argument_list|(
name|graph
argument_list|,
name|parents
operator|->
name|item
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|par_column
argument_list|)
expr_stmt|;
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|par_column
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|chars_written
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|graph
operator|->
name|num_parents
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|parents
operator|=
name|next_interesting_parent
argument_list|(
name|graph
argument_list|,
name|parents
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|par_column
operator|=
name|find_new_column_by_commit
argument_list|(
name|graph
argument_list|,
name|parents
operator|->
name|item
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|par_column
argument_list|)
expr_stmt|;
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|par_column
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|chars_written
operator|+=
name|j
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seen_this
condition|)
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|chars_written
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|chars_written
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|graph_pad_horizontally
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|,
name|chars_written
argument_list|)
expr_stmt|;
comment|/* 	 * Update graph->state 	 */
if|if
condition|(
name|graph_is_mapping_correct
argument_list|(
name|graph
argument_list|)
condition|)
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_PADDING
argument_list|)
expr_stmt|;
else|else
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_COLLAPSING
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_output_collapsing_line
specifier|static
name|void
name|graph_output_collapsing_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|tmp_mapping
decl_stmt|;
name|short
name|used_horizontal
init|=
literal|0
decl_stmt|;
name|int
name|horizontal_edge
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|horizontal_edge_target
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 	 * Clear out the new_mapping array 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|mapping_size
condition|;
name|i
operator|++
control|)
name|graph
operator|->
name|new_mapping
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|mapping_size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|target
init|=
name|graph
operator|->
name|mapping
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
continue|continue;
comment|/* 		 * Since update_columns() always inserts the leftmost 		 * column first, each branch's target location should 		 * always be either its current location or to the left of 		 * its current location. 		 * 		 * We never have to move branches to the right.  This makes 		 * the graph much more legible, since whenever branches 		 * cross, only one is moving directions. 		 */
name|assert
argument_list|(
name|target
operator|*
literal|2
operator|<=
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|*
literal|2
operator|==
name|i
condition|)
block|{
comment|/* 			 * This column is already in the 			 * correct place 			 */
name|assert
argument_list|(
name|graph
operator|->
name|new_mapping
index|[
name|i
index|]
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|graph
operator|->
name|new_mapping
index|[
name|i
index|]
operator|=
name|target
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|graph
operator|->
name|new_mapping
index|[
name|i
operator|-
literal|1
index|]
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Nothing is to the left. 			 * Move to the left by one 			 */
name|graph
operator|->
name|new_mapping
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|target
expr_stmt|;
comment|/* 			 * If there isn't already an edge moving horizontally 			 * select this one. 			 */
if|if
condition|(
name|horizontal_edge
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|j
decl_stmt|;
name|horizontal_edge
operator|=
name|i
expr_stmt|;
name|horizontal_edge_target
operator|=
name|target
expr_stmt|;
comment|/* 				 * The variable target is the index of the graph 				 * column, and therefore target*2+3 is the 				 * actual screen column of the first horizontal 				 * line. 				 */
for|for
control|(
name|j
operator|=
operator|(
name|target
operator|*
literal|2
operator|)
operator|+
literal|3
init|;
name|j
operator|<
operator|(
name|i
operator|-
literal|2
operator|)
condition|;
name|j
operator|+=
literal|2
control|)
name|graph
operator|->
name|new_mapping
index|[
name|j
index|]
operator|=
name|target
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|graph
operator|->
name|new_mapping
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|target
condition|)
block|{
comment|/* 			 * There is a branch line to our left 			 * already, and it is our target.  We 			 * combine with this line, since we share 			 * the same parent commit. 			 * 			 * We don't have to add anything to the 			 * output or new_mapping, since the 			 * existing branch line has already taken 			 * care of it. 			 */
block|}
else|else
block|{
comment|/* 			 * There is a branch line to our left, 			 * but it isn't our target.  We need to 			 * cross over it. 			 * 			 * The space just to the left of this 			 * branch should always be empty. 			 * 			 * The branch to the left of that space 			 * should be our eventual target. 			 */
name|assert
argument_list|(
name|graph
operator|->
name|new_mapping
index|[
name|i
operator|-
literal|1
index|]
operator|>
name|target
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|graph
operator|->
name|new_mapping
index|[
name|i
operator|-
literal|2
index|]
operator|<
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|graph
operator|->
name|new_mapping
index|[
name|i
operator|-
literal|3
index|]
operator|==
name|target
argument_list|)
expr_stmt|;
name|graph
operator|->
name|new_mapping
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|target
expr_stmt|;
comment|/* 			 * Mark this branch as the horizontal edge to 			 * prevent any other edges from moving 			 * horizontally. 			 */
if|if
condition|(
name|horizontal_edge
operator|==
operator|-
literal|1
condition|)
name|horizontal_edge
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * The new mapping may be 1 smaller than the old mapping 	 */
if|if
condition|(
name|graph
operator|->
name|new_mapping
index|[
name|graph
operator|->
name|mapping_size
operator|-
literal|1
index|]
operator|<
literal|0
condition|)
name|graph
operator|->
name|mapping_size
operator|--
expr_stmt|;
comment|/* 	 * Output out a line based on the new mapping info 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|mapping_size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|target
init|=
name|graph
operator|->
name|new_mapping
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|*
literal|2
operator|==
name|i
condition|)
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
operator|&
name|graph
operator|->
name|new_columns
index|[
name|target
index|]
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|==
name|horizontal_edge_target
operator|&&
name|i
operator|!=
name|horizontal_edge
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Set the mappings for all but the 				 * first segment to -1 so that they 				 * won't continue into the next line. 				 */
if|if
condition|(
name|i
operator|!=
operator|(
name|target
operator|*
literal|2
operator|)
operator|+
literal|3
condition|)
name|graph
operator|->
name|new_mapping
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|used_horizontal
operator|=
literal|1
expr_stmt|;
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
operator|&
name|graph
operator|->
name|new_columns
index|[
name|target
index|]
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|used_horizontal
operator|&&
name|i
operator|<
name|horizontal_edge
condition|)
name|graph
operator|->
name|new_mapping
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
operator|&
name|graph
operator|->
name|new_columns
index|[
name|target
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
block|}
name|graph_pad_horizontally
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|,
name|graph
operator|->
name|mapping_size
argument_list|)
expr_stmt|;
comment|/* 	 * Swap mapping and new_mapping 	 */
name|tmp_mapping
operator|=
name|graph
operator|->
name|mapping
expr_stmt|;
name|graph
operator|->
name|mapping
operator|=
name|graph
operator|->
name|new_mapping
expr_stmt|;
name|graph
operator|->
name|new_mapping
operator|=
name|tmp_mapping
expr_stmt|;
comment|/* 	 * If graph->mapping indicates that all of the branch lines 	 * are already in the correct positions, we are done. 	 * Otherwise, we need to collapse some branch lines together. 	 */
if|if
condition|(
name|graph_is_mapping_correct
argument_list|(
name|graph
argument_list|)
condition|)
name|graph_update_state
argument_list|(
name|graph
argument_list|,
name|GRAPH_PADDING
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_next_line
name|int
name|graph_next_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
switch|switch
condition|(
name|graph
operator|->
name|state
condition|)
block|{
case|case
name|GRAPH_PADDING
case|:
name|graph_output_padding_line
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GRAPH_SKIP
case|:
name|graph_output_skip_line
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GRAPH_PRE_COMMIT
case|:
name|graph_output_pre_commit_line
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GRAPH_COMMIT
case|:
name|graph_output_commit_line
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|GRAPH_POST_MERGE
case|:
name|graph_output_post_merge_line
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GRAPH_COLLAPSING
case|:
name|graph_output_collapsing_line
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|graph_padding_line
specifier|static
name|void
name|graph_padding_line
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|graph
operator|->
name|state
operator|!=
name|GRAPH_COMMIT
condition|)
block|{
name|graph_next_line
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Output the row containing this commit 	 * Iterate up to and including graph->num_columns, 	 * since the current commit may not be in any of the existing 	 * columns.  (This happens when the current commit doesn't have any 	 * children that we have already processed.) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graph
operator|->
name|num_columns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|column
modifier|*
name|col
init|=
operator|&
name|graph
operator|->
name|columns
index|[
name|i
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|col_commit
init|=
name|col
operator|->
name|commit
decl_stmt|;
if|if
condition|(
name|col_commit
operator|==
name|graph
operator|->
name|commit
condition|)
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|num_parents
operator|<
literal|3
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|num_spaces
init|=
operator|(
operator|(
name|graph
operator|->
name|num_parents
operator|-
literal|2
operator|)
operator|*
literal|2
operator|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_spaces
condition|;
name|j
operator|++
control|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|strbuf_write_column
argument_list|(
name|sb
argument_list|,
name|col
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|graph_pad_horizontally
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|,
name|graph
operator|->
name|num_columns
argument_list|)
expr_stmt|;
comment|/* 	 * Update graph->prev_state since we have output a padding line 	 */
name|graph
operator|->
name|prev_state
operator|=
name|GRAPH_PADDING
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_is_commit_finished
name|int
name|graph_is_commit_finished
parameter_list|(
name|struct
name|git_graph
specifier|const
modifier|*
name|graph
parameter_list|)
block|{
return|return
operator|(
name|graph
operator|->
name|state
operator|==
name|GRAPH_PADDING
operator|)
return|;
block|}
end_function
begin_function
DECL|function|graph_show_commit
name|void
name|graph_show_commit
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|struct
name|strbuf
name|msgbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|shown_commit_line
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|graph
condition|)
return|return;
while|while
condition|(
operator|!
name|shown_commit_line
operator|&&
operator|!
name|graph_is_commit_finished
argument_list|(
name|graph
argument_list|)
condition|)
block|{
name|shown_commit_line
operator|=
name|graph_next_line
argument_list|(
name|graph
argument_list|,
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|msgbuf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|msgbuf
operator|.
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shown_commit_line
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_show_oneline
name|void
name|graph_show_oneline
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|struct
name|strbuf
name|msgbuf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|graph
condition|)
return|return;
name|graph_next_line
argument_list|(
name|graph
argument_list|,
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|msgbuf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|msgbuf
operator|.
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_show_padding
name|void
name|graph_show_padding
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|struct
name|strbuf
name|msgbuf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|graph
condition|)
return|return;
name|graph_padding_line
argument_list|(
name|graph
argument_list|,
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|msgbuf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|msgbuf
operator|.
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|graph_show_remainder
name|int
name|graph_show_remainder
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|)
block|{
name|struct
name|strbuf
name|msgbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|shown
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|graph
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|graph_is_commit_finished
argument_list|(
name|graph
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|graph_next_line
argument_list|(
name|graph
argument_list|,
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|msgbuf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|msgbuf
operator|.
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shown
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|graph_is_commit_finished
argument_list|(
name|graph
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|strbuf_release
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
return|return
name|shown
return|;
block|}
end_function
begin_function
DECL|function|graph_show_strbuf
specifier|static
name|void
name|graph_show_strbuf
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
specifier|const
modifier|*
name|sb
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|graph
condition|)
block|{
name|fwrite
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|sb
operator|->
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Print the strbuf line by line, 	 * and display the graph info before each line but the first. 	 */
name|p
operator|=
name|sb
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|next_p
init|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_p
condition|)
block|{
name|next_p
operator|++
expr_stmt|;
name|len
operator|=
name|next_p
operator|-
name|p
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
operator|(
name|sb
operator|->
name|buf
operator|+
name|sb
operator|->
name|len
operator|)
operator|-
name|p
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_p
operator|&&
operator|*
name|next_p
operator|!=
literal|'\0'
condition|)
name|graph_show_oneline
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|p
operator|=
name|next_p
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|graph_show_commit_msg
name|void
name|graph_show_commit_msg
parameter_list|(
name|struct
name|git_graph
modifier|*
name|graph
parameter_list|,
name|struct
name|strbuf
specifier|const
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|newline_terminated
decl_stmt|;
if|if
condition|(
operator|!
name|graph
condition|)
block|{
comment|/* 		 * If there's no graph, just print the message buffer. 		 * 		 * The message buffer for CMIT_FMT_ONELINE and 		 * CMIT_FMT_USERFORMAT are already missing a terminating 		 * newline.  All of the other formats should have it. 		 */
name|fwrite
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|sb
operator|->
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
name|newline_terminated
operator|=
operator|(
name|sb
operator|->
name|len
operator|&&
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
expr_stmt|;
comment|/* 	 * Show the commit message 	 */
name|graph_show_strbuf
argument_list|(
name|graph
argument_list|,
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * If there is more output needed for this commit, show it now 	 */
if|if
condition|(
operator|!
name|graph_is_commit_finished
argument_list|(
name|graph
argument_list|)
condition|)
block|{
comment|/* 		 * If sb doesn't have a terminating newline, print one now, 		 * so we can start the remainder of the graph output on a 		 * new line. 		 */
if|if
condition|(
operator|!
name|newline_terminated
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|graph_show_remainder
argument_list|(
name|graph
argument_list|)
expr_stmt|;
comment|/* 		 * If sb ends with a newline, our output should too. 		 */
if|if
condition|(
name|newline_terminated
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function
end_unit
