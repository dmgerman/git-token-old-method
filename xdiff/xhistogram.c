begin_unit
begin_comment
comment|/*  * Copyright (C) 2010, Google Inc.  * and other copyright owners as documented in JGit's IP log.  *  * This program and the accompanying materials are made available  * under the terms of the Eclipse Distribution License v1.0 which  * accompanies this distribution, is reproduced below, and is  * available at http://www.eclipse.org/org/documents/edl-v10.php  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  *  * - Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  *  * - Redistributions in binary form must reproduce the above  *   copyright notice, this list of conditions and the following  *   disclaimer in the documentation and/or other materials provided  *   with the distribution.  *  * - Neither the name of the Eclipse Foundation, Inc. nor the  *   names of its contributors may be used to endorse or promote  *   products derived from this software without specific prior  *   written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND  * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_include
include|#
directive|include
file|"xinclude.h"
end_include
begin_include
include|#
directive|include
file|"xtypes.h"
end_include
begin_include
include|#
directive|include
file|"xdiff.h"
end_include
begin_define
DECL|macro|MAX_PTR
define|#
directive|define
name|MAX_PTR
value|UINT_MAX
end_define
begin_define
DECL|macro|MAX_CNT
define|#
directive|define
name|MAX_CNT
value|UINT_MAX
end_define
begin_define
DECL|macro|LINE_END
define|#
directive|define
name|LINE_END
parameter_list|(
name|n
parameter_list|)
value|(line##n + count##n - 1)
end_define
begin_define
DECL|macro|LINE_END_PTR
define|#
directive|define
name|LINE_END_PTR
parameter_list|(
name|n
parameter_list|)
value|(*line##n + *count##n - 1)
end_define
begin_struct
DECL|struct|histindex
struct|struct
name|histindex
block|{
DECL|struct|record
struct|struct
name|record
block|{
DECL|member|ptr
DECL|member|cnt
name|unsigned
name|int
name|ptr
decl_stmt|,
name|cnt
decl_stmt|;
DECL|member|next
name|struct
name|record
modifier|*
name|next
decl_stmt|;
block|}
DECL|member|records
modifier|*
modifier|*
name|records
struct|,
comment|/* an ocurrence */
DECL|member|line_map
modifier|*
modifier|*
name|line_map
struct|;
comment|/* map of line to record chain */
DECL|member|rcha
name|chastore_t
name|rcha
decl_stmt|;
DECL|member|next_ptrs
name|unsigned
name|int
modifier|*
name|next_ptrs
decl_stmt|;
DECL|member|table_bits
name|unsigned
name|int
name|table_bits
decl_stmt|,
DECL|member|records_size
name|records_size
decl_stmt|,
DECL|member|line_map_size
name|line_map_size
decl_stmt|;
DECL|member|max_chain_length
name|unsigned
name|int
name|max_chain_length
decl_stmt|,
DECL|member|key_shift
name|key_shift
decl_stmt|,
DECL|member|ptr_shift
name|ptr_shift
decl_stmt|;
DECL|member|cnt
name|unsigned
name|int
name|cnt
decl_stmt|,
DECL|member|has_common
name|has_common
decl_stmt|;
DECL|member|env
name|xdfenv_t
modifier|*
name|env
decl_stmt|;
DECL|member|xpp
name|xpparam_t
specifier|const
modifier|*
name|xpp
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|region
struct|struct
name|region
block|{
DECL|member|begin1
DECL|member|end1
name|unsigned
name|int
name|begin1
decl_stmt|,
name|end1
decl_stmt|;
DECL|member|begin2
DECL|member|end2
name|unsigned
name|int
name|begin2
decl_stmt|,
name|end2
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|LINE_MAP
define|#
directive|define
name|LINE_MAP
parameter_list|(
name|i
parameter_list|,
name|a
parameter_list|)
value|(i->line_map[(a) - i->ptr_shift])
end_define
begin_define
DECL|macro|NEXT_PTR
define|#
directive|define
name|NEXT_PTR
parameter_list|(
name|index
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(index->next_ptrs[(ptr) - index->ptr_shift])
end_define
begin_define
DECL|macro|CNT
define|#
directive|define
name|CNT
parameter_list|(
name|index
parameter_list|,
name|ptr
parameter_list|)
define|\
value|((LINE_MAP(index, ptr))->cnt)
end_define
begin_define
DECL|macro|REC
define|#
directive|define
name|REC
parameter_list|(
name|env
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
define|\
value|(env->xdf##s.recs[l - 1])
end_define
begin_function
DECL|function|cmp_recs
specifier|static
name|int
name|cmp_recs
parameter_list|(
name|xpparam_t
specifier|const
modifier|*
name|xpp
parameter_list|,
name|xrecord_t
modifier|*
name|r1
parameter_list|,
name|xrecord_t
modifier|*
name|r2
parameter_list|)
block|{
return|return
name|r1
operator|->
name|ha
operator|==
name|r2
operator|->
name|ha
operator|&&
name|xdl_recmatch
argument_list|(
name|r1
operator|->
name|ptr
argument_list|,
name|r1
operator|->
name|size
argument_list|,
name|r2
operator|->
name|ptr
argument_list|,
name|r2
operator|->
name|size
argument_list|,
name|xpp
operator|->
name|flags
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|CMP_ENV
define|#
directive|define
name|CMP_ENV
parameter_list|(
name|xpp
parameter_list|,
name|env
parameter_list|,
name|s1
parameter_list|,
name|l1
parameter_list|,
name|s2
parameter_list|,
name|l2
parameter_list|)
define|\
value|(cmp_recs(xpp, REC(env, s1, l1), REC(env, s2, l2)))
end_define
begin_define
DECL|macro|CMP
define|#
directive|define
name|CMP
parameter_list|(
name|i
parameter_list|,
name|s1
parameter_list|,
name|l1
parameter_list|,
name|s2
parameter_list|,
name|l2
parameter_list|)
define|\
value|(cmp_recs(i->xpp, REC(i->env, s1, l1), REC(i->env, s2, l2)))
end_define
begin_define
DECL|macro|TABLE_HASH
define|#
directive|define
name|TABLE_HASH
parameter_list|(
name|index
parameter_list|,
name|side
parameter_list|,
name|line
parameter_list|)
define|\
value|XDL_HASHLONG((REC(index->env, side, line))->ha, index->table_bits)
end_define
begin_function
DECL|function|scanA
specifier|static
name|int
name|scanA
parameter_list|(
name|struct
name|histindex
modifier|*
name|index
parameter_list|,
name|int
name|line1
parameter_list|,
name|int
name|count1
parameter_list|)
block|{
name|unsigned
name|int
name|ptr
decl_stmt|,
name|tbl_idx
decl_stmt|;
name|unsigned
name|int
name|chain_len
decl_stmt|;
name|struct
name|record
modifier|*
modifier|*
name|rec_chain
decl_stmt|,
modifier|*
name|rec
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|LINE_END
argument_list|(
literal|1
argument_list|)
init|;
name|line1
operator|<=
name|ptr
condition|;
name|ptr
operator|--
control|)
block|{
name|tbl_idx
operator|=
name|TABLE_HASH
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|rec_chain
operator|=
name|index
operator|->
name|records
operator|+
name|tbl_idx
expr_stmt|;
name|rec
operator|=
operator|*
name|rec_chain
expr_stmt|;
name|chain_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rec
condition|)
block|{
if|if
condition|(
name|CMP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
name|rec
operator|->
name|ptr
argument_list|,
literal|1
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
comment|/* 				 * ptr is identical to another element. Insert 				 * it onto the front of the existing element 				 * chain. 				 */
name|NEXT_PTR
argument_list|(
name|index
argument_list|,
name|ptr
argument_list|)
operator|=
name|rec
operator|->
name|ptr
expr_stmt|;
name|rec
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
comment|/* cap rec->cnt at MAX_CNT */
name|rec
operator|->
name|cnt
operator|=
name|XDL_MIN
argument_list|(
name|MAX_CNT
argument_list|,
name|rec
operator|->
name|cnt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LINE_MAP
argument_list|(
name|index
argument_list|,
name|ptr
argument_list|)
operator|=
name|rec
expr_stmt|;
goto|goto
name|continue_scan
goto|;
block|}
name|rec
operator|=
name|rec
operator|->
name|next
expr_stmt|;
name|chain_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chain_len
operator|==
name|index
operator|->
name|max_chain_length
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 		 * This is the first time we have ever seen this particular 		 * element in the sequence. Construct a new chain for it. 		 */
if|if
condition|(
operator|!
operator|(
name|rec
operator|=
name|xdl_cha_alloc
argument_list|(
operator|&
name|index
operator|->
name|rcha
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|rec
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|rec
operator|->
name|cnt
operator|=
literal|1
expr_stmt|;
name|rec
operator|->
name|next
operator|=
operator|*
name|rec_chain
expr_stmt|;
operator|*
name|rec_chain
operator|=
name|rec
expr_stmt|;
name|LINE_MAP
argument_list|(
name|index
argument_list|,
name|ptr
argument_list|)
operator|=
name|rec
expr_stmt|;
name|continue_scan
label|:
empty_stmt|;
comment|/* no op */
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|try_lcs
specifier|static
name|int
name|try_lcs
parameter_list|(
name|struct
name|histindex
modifier|*
name|index
parameter_list|,
name|struct
name|region
modifier|*
name|lcs
parameter_list|,
name|int
name|b_ptr
parameter_list|,
name|int
name|line1
parameter_list|,
name|int
name|count1
parameter_list|,
name|int
name|line2
parameter_list|,
name|int
name|count2
parameter_list|)
block|{
name|unsigned
name|int
name|b_next
init|=
name|b_ptr
operator|+
literal|1
decl_stmt|;
name|struct
name|record
modifier|*
name|rec
init|=
name|index
operator|->
name|records
index|[
name|TABLE_HASH
argument_list|(
name|index
argument_list|,
literal|2
argument_list|,
name|b_ptr
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|as
decl_stmt|,
name|ae
decl_stmt|,
name|bs
decl_stmt|,
name|be
decl_stmt|,
name|np
decl_stmt|,
name|rc
decl_stmt|;
name|int
name|should_break
decl_stmt|;
for|for
control|(
init|;
name|rec
condition|;
name|rec
operator|=
name|rec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rec
operator|->
name|cnt
operator|>
name|index
operator|->
name|cnt
condition|)
block|{
if|if
condition|(
operator|!
name|index
operator|->
name|has_common
condition|)
name|index
operator|->
name|has_common
operator|=
name|CMP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
name|rec
operator|->
name|ptr
argument_list|,
literal|2
argument_list|,
name|b_ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|as
operator|=
name|rec
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|CMP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
name|as
argument_list|,
literal|2
argument_list|,
name|b_ptr
argument_list|)
condition|)
continue|continue;
name|index
operator|->
name|has_common
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|should_break
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|NEXT_PTR
argument_list|(
name|index
argument_list|,
name|as
argument_list|)
expr_stmt|;
name|bs
operator|=
name|b_ptr
expr_stmt|;
name|ae
operator|=
name|as
expr_stmt|;
name|be
operator|=
name|bs
expr_stmt|;
name|rc
operator|=
name|rec
operator|->
name|cnt
expr_stmt|;
while|while
condition|(
name|line1
operator|<
name|as
operator|&&
name|line2
operator|<
name|bs
operator|&&
name|CMP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
name|as
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
name|bs
operator|-
literal|1
argument_list|)
condition|)
block|{
name|as
operator|--
expr_stmt|;
name|bs
operator|--
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|rc
condition|)
name|rc
operator|=
name|XDL_MIN
argument_list|(
name|rc
argument_list|,
name|CNT
argument_list|(
name|index
argument_list|,
name|as
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ae
operator|<
name|LINE_END
argument_list|(
literal|1
argument_list|)
operator|&&
name|be
operator|<
name|LINE_END
argument_list|(
literal|2
argument_list|)
operator|&&
name|CMP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|,
name|ae
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|be
operator|+
literal|1
argument_list|)
condition|)
block|{
name|ae
operator|++
expr_stmt|;
name|be
operator|++
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|rc
condition|)
name|rc
operator|=
name|XDL_MIN
argument_list|(
name|rc
argument_list|,
name|CNT
argument_list|(
name|index
argument_list|,
name|ae
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b_next
operator|<=
name|be
condition|)
name|b_next
operator|=
name|be
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lcs
operator|->
name|end1
operator|-
name|lcs
operator|->
name|begin1
operator|<
name|ae
operator|-
name|as
operator|||
name|rc
operator|<
name|index
operator|->
name|cnt
condition|)
block|{
name|lcs
operator|->
name|begin1
operator|=
name|as
expr_stmt|;
name|lcs
operator|->
name|begin2
operator|=
name|bs
expr_stmt|;
name|lcs
operator|->
name|end1
operator|=
name|ae
expr_stmt|;
name|lcs
operator|->
name|end2
operator|=
name|be
expr_stmt|;
name|index
operator|->
name|cnt
operator|=
name|rc
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|==
literal|0
condition|)
break|break;
while|while
condition|(
name|np
operator|<=
name|ae
condition|)
block|{
name|np
operator|=
name|NEXT_PTR
argument_list|(
name|index
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|should_break
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|should_break
condition|)
break|break;
name|as
operator|=
name|np
expr_stmt|;
block|}
block|}
return|return
name|b_next
return|;
block|}
end_function
begin_function
DECL|function|find_lcs
specifier|static
name|int
name|find_lcs
parameter_list|(
name|struct
name|histindex
modifier|*
name|index
parameter_list|,
name|struct
name|region
modifier|*
name|lcs
parameter_list|,
name|int
name|line1
parameter_list|,
name|int
name|count1
parameter_list|,
name|int
name|line2
parameter_list|,
name|int
name|count2
parameter_list|)
block|{
name|int
name|b_ptr
decl_stmt|;
if|if
condition|(
name|scanA
argument_list|(
name|index
argument_list|,
name|line1
argument_list|,
name|count1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|index
operator|->
name|cnt
operator|=
name|index
operator|->
name|max_chain_length
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|b_ptr
operator|=
name|line2
init|;
name|b_ptr
operator|<=
name|LINE_END
argument_list|(
literal|2
argument_list|)
condition|;
control|)
name|b_ptr
operator|=
name|try_lcs
argument_list|(
name|index
argument_list|,
name|lcs
argument_list|,
name|b_ptr
argument_list|,
name|line1
argument_list|,
name|count1
argument_list|,
name|line2
argument_list|,
name|count2
argument_list|)
expr_stmt|;
return|return
name|index
operator|->
name|has_common
operator|&&
name|index
operator|->
name|max_chain_length
operator|<
name|index
operator|->
name|cnt
return|;
block|}
end_function
begin_function
DECL|function|fall_back_to_classic_diff
specifier|static
name|int
name|fall_back_to_classic_diff
parameter_list|(
name|struct
name|histindex
modifier|*
name|index
parameter_list|,
name|int
name|line1
parameter_list|,
name|int
name|count1
parameter_list|,
name|int
name|line2
parameter_list|,
name|int
name|count2
parameter_list|)
block|{
name|xpparam_t
name|xpp
decl_stmt|;
name|xpp
operator|.
name|flags
operator|=
name|index
operator|->
name|xpp
operator|->
name|flags
operator|&
operator|~
name|XDF_HISTOGRAM_DIFF
expr_stmt|;
return|return
name|xdl_fall_back_diff
argument_list|(
name|index
operator|->
name|env
argument_list|,
operator|&
name|xpp
argument_list|,
name|line1
argument_list|,
name|count1
argument_list|,
name|line2
argument_list|,
name|count2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|histogram_diff
specifier|static
name|int
name|histogram_diff
parameter_list|(
name|xpparam_t
specifier|const
modifier|*
name|xpp
parameter_list|,
name|xdfenv_t
modifier|*
name|env
parameter_list|,
name|int
name|line1
parameter_list|,
name|int
name|count1
parameter_list|,
name|int
name|line2
parameter_list|,
name|int
name|count2
parameter_list|)
block|{
name|struct
name|histindex
name|index
decl_stmt|;
name|struct
name|region
name|lcs
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|count1
operator|<=
literal|0
operator|&&
name|count2
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|LINE_END
argument_list|(
literal|1
argument_list|)
operator|>=
name|MAX_PTR
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|count1
condition|)
block|{
while|while
condition|(
name|count2
operator|--
condition|)
name|env
operator|->
name|xdf2
operator|.
name|rchg
index|[
name|line2
operator|++
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|count2
condition|)
block|{
while|while
condition|(
name|count1
operator|--
condition|)
name|env
operator|->
name|xdf1
operator|.
name|rchg
index|[
name|line1
operator|++
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
operator|&
name|index
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|.
name|env
operator|=
name|env
expr_stmt|;
name|index
operator|.
name|xpp
operator|=
name|xpp
expr_stmt|;
name|index
operator|.
name|records
operator|=
name|NULL
expr_stmt|;
name|index
operator|.
name|line_map
operator|=
name|NULL
expr_stmt|;
comment|/* in case of early xdl_cha_free() */
name|index
operator|.
name|rcha
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|index
operator|.
name|table_bits
operator|=
name|xdl_hashbits
argument_list|(
name|count1
argument_list|)
expr_stmt|;
name|sz
operator|=
name|index
operator|.
name|records_size
operator|=
literal|1
operator|<<
name|index
operator|.
name|table_bits
expr_stmt|;
name|sz
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|record
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|index
operator|.
name|records
operator|=
operator|(
expr|struct
name|record
operator|*
operator|*
operator|)
name|xdl_malloc
argument_list|(
name|sz
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|memset
argument_list|(
name|index
operator|.
name|records
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|sz
operator|=
name|index
operator|.
name|line_map_size
operator|=
name|count1
expr_stmt|;
name|sz
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|record
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|index
operator|.
name|line_map
operator|=
operator|(
expr|struct
name|record
operator|*
operator|*
operator|)
name|xdl_malloc
argument_list|(
name|sz
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|memset
argument_list|(
name|index
operator|.
name|line_map
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|sz
operator|=
name|index
operator|.
name|line_map_size
expr_stmt|;
name|sz
operator|*=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|index
operator|.
name|next_ptrs
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xdl_malloc
argument_list|(
name|sz
argument_list|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|memset
argument_list|(
name|index
operator|.
name|next_ptrs
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
expr_stmt|;
comment|/* lines / 4 + 1 comes from xprepare.c:xdl_prepare_ctx() */
if|if
condition|(
name|xdl_cha_init
argument_list|(
operator|&
name|index
operator|.
name|rcha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|record
argument_list|)
argument_list|,
name|count1
operator|/
literal|4
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|index
operator|.
name|ptr_shift
operator|=
name|line1
expr_stmt|;
name|index
operator|.
name|max_chain_length
operator|=
literal|64
expr_stmt|;
name|memset
argument_list|(
operator|&
name|lcs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lcs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_lcs
argument_list|(
operator|&
name|index
argument_list|,
operator|&
name|lcs
argument_list|,
name|line1
argument_list|,
name|count1
argument_list|,
name|line2
argument_list|,
name|count2
argument_list|)
condition|)
name|result
operator|=
name|fall_back_to_classic_diff
argument_list|(
operator|&
name|index
argument_list|,
name|line1
argument_list|,
name|count1
argument_list|,
name|line2
argument_list|,
name|count2
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lcs
operator|.
name|begin1
operator|==
literal|0
operator|&&
name|lcs
operator|.
name|begin2
operator|==
literal|0
condition|)
block|{
name|int
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
literal|0
init|;
name|ptr
operator|<
name|count1
condition|;
name|ptr
operator|++
control|)
name|env
operator|->
name|xdf1
operator|.
name|rchg
index|[
name|line1
operator|+
name|ptr
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ptr
operator|=
literal|0
init|;
name|ptr
operator|<
name|count2
condition|;
name|ptr
operator|++
control|)
name|env
operator|->
name|xdf2
operator|.
name|rchg
index|[
name|line2
operator|+
name|ptr
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|histogram_diff
argument_list|(
name|xpp
argument_list|,
name|env
argument_list|,
name|line1
argument_list|,
name|lcs
operator|.
name|begin1
operator|-
name|line1
argument_list|,
name|line2
argument_list|,
name|lcs
operator|.
name|begin2
operator|-
name|line2
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|histogram_diff
argument_list|(
name|xpp
argument_list|,
name|env
argument_list|,
name|lcs
operator|.
name|end1
operator|+
literal|1
argument_list|,
name|LINE_END
argument_list|(
literal|1
argument_list|)
operator|-
name|lcs
operator|.
name|end1
argument_list|,
name|lcs
operator|.
name|end2
operator|+
literal|1
argument_list|,
name|LINE_END
argument_list|(
literal|2
argument_list|)
operator|-
name|lcs
operator|.
name|end2
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
goto|goto
name|cleanup
goto|;
block|}
block|}
name|cleanup
label|:
name|xdl_free
argument_list|(
name|index
operator|.
name|records
argument_list|)
expr_stmt|;
name|xdl_free
argument_list|(
name|index
operator|.
name|line_map
argument_list|)
expr_stmt|;
name|xdl_free
argument_list|(
name|index
operator|.
name|next_ptrs
argument_list|)
expr_stmt|;
name|xdl_cha_free
argument_list|(
operator|&
name|index
operator|.
name|rcha
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|xdl_do_histogram_diff
name|int
name|xdl_do_histogram_diff
parameter_list|(
name|mmfile_t
modifier|*
name|file1
parameter_list|,
name|mmfile_t
modifier|*
name|file2
parameter_list|,
name|xpparam_t
specifier|const
modifier|*
name|xpp
parameter_list|,
name|xdfenv_t
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
name|xdl_prepare_env
argument_list|(
name|file1
argument_list|,
name|file2
argument_list|,
name|xpp
argument_list|,
name|env
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|histogram_diff
argument_list|(
name|xpp
argument_list|,
name|env
argument_list|,
name|env
operator|->
name|xdf1
operator|.
name|dstart
operator|+
literal|1
argument_list|,
name|env
operator|->
name|xdf1
operator|.
name|dend
operator|-
name|env
operator|->
name|xdf1
operator|.
name|dstart
operator|+
literal|1
argument_list|,
name|env
operator|->
name|xdf2
operator|.
name|dstart
operator|+
literal|1
argument_list|,
name|env
operator|->
name|xdf2
operator|.
name|dend
operator|-
name|env
operator|->
name|xdf2
operator|.
name|dstart
operator|+
literal|1
argument_list|)
return|;
block|}
end_function
end_unit
