begin_unit
begin_include
include|#
directive|include
file|"git-compat-util.h"
end_include
begin_include
include|#
directive|include
file|"line-range.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"decorate.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"graph.h"
end_include
begin_include
include|#
directive|include
file|"userdiff.h"
end_include
begin_include
include|#
directive|include
file|"line-log.h"
end_include
begin_function
DECL|function|range_set_grow
specifier|static
name|void
name|range_set_grow
parameter_list|(
name|struct
name|range_set
modifier|*
name|rs
parameter_list|,
name|size_t
name|extra
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|rs
operator|->
name|ranges
argument_list|,
name|rs
operator|->
name|nr
operator|+
name|extra
argument_list|,
name|rs
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Either initialization would be fine */
end_comment
begin_define
DECL|macro|RANGE_SET_INIT
define|#
directive|define
name|RANGE_SET_INIT
value|{0}
end_define
begin_function
DECL|function|range_set_init
specifier|static
name|void
name|range_set_init
parameter_list|(
name|struct
name|range_set
modifier|*
name|rs
parameter_list|,
name|size_t
name|prealloc
parameter_list|)
block|{
name|rs
operator|->
name|alloc
operator|=
name|rs
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|ranges
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prealloc
condition|)
name|range_set_grow
argument_list|(
name|rs
argument_list|,
name|prealloc
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|range_set_release
specifier|static
name|void
name|range_set_release
parameter_list|(
name|struct
name|range_set
modifier|*
name|rs
parameter_list|)
block|{
name|free
argument_list|(
name|rs
operator|->
name|ranges
argument_list|)
expr_stmt|;
name|rs
operator|->
name|alloc
operator|=
name|rs
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|ranges
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_comment
comment|/* dst must be uninitialized! */
end_comment
begin_function
DECL|function|range_set_copy
specifier|static
name|void
name|range_set_copy
parameter_list|(
name|struct
name|range_set
modifier|*
name|dst
parameter_list|,
name|struct
name|range_set
modifier|*
name|src
parameter_list|)
block|{
name|range_set_init
argument_list|(
name|dst
argument_list|,
name|src
operator|->
name|nr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|ranges
argument_list|,
name|src
operator|->
name|ranges
argument_list|,
name|src
operator|->
name|nr
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|range_set
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|nr
operator|=
name|src
operator|->
name|nr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|range_set_move
specifier|static
name|void
name|range_set_move
parameter_list|(
name|struct
name|range_set
modifier|*
name|dst
parameter_list|,
name|struct
name|range_set
modifier|*
name|src
parameter_list|)
block|{
name|range_set_release
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|ranges
operator|=
name|src
operator|->
name|ranges
expr_stmt|;
name|dst
operator|->
name|nr
operator|=
name|src
operator|->
name|nr
expr_stmt|;
name|dst
operator|->
name|alloc
operator|=
name|src
operator|->
name|alloc
expr_stmt|;
name|src
operator|->
name|ranges
operator|=
name|NULL
expr_stmt|;
name|src
operator|->
name|alloc
operator|=
name|src
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* tack on a _new_ range _at the end_ */
end_comment
begin_function
DECL|function|range_set_append_unsafe
specifier|static
name|void
name|range_set_append_unsafe
parameter_list|(
name|struct
name|range_set
modifier|*
name|rs
parameter_list|,
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|assert
argument_list|(
name|a
operator|<=
name|b
argument_list|)
expr_stmt|;
name|range_set_grow
argument_list|(
name|rs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|->
name|ranges
index|[
name|rs
operator|->
name|nr
index|]
operator|.
name|start
operator|=
name|a
expr_stmt|;
name|rs
operator|->
name|ranges
index|[
name|rs
operator|->
name|nr
index|]
operator|.
name|end
operator|=
name|b
expr_stmt|;
name|rs
operator|->
name|nr
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|range_set_append
specifier|static
name|void
name|range_set_append
parameter_list|(
name|struct
name|range_set
modifier|*
name|rs
parameter_list|,
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|assert
argument_list|(
name|rs
operator|->
name|nr
operator|==
literal|0
operator|||
name|rs
operator|->
name|ranges
index|[
name|rs
operator|->
name|nr
operator|-
literal|1
index|]
operator|.
name|end
operator|<=
name|a
argument_list|)
expr_stmt|;
name|range_set_append_unsafe
argument_list|(
name|rs
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|range_cmp
specifier|static
name|int
name|range_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|_r
parameter_list|,
specifier|const
name|void
modifier|*
name|_s
parameter_list|)
block|{
specifier|const
name|struct
name|range
modifier|*
name|r
init|=
name|_r
decl_stmt|;
specifier|const
name|struct
name|range
modifier|*
name|s
init|=
name|_s
decl_stmt|;
comment|/* this could be simply 'return r.start-s.start', but for the types */
if|if
condition|(
name|r
operator|->
name|start
operator|==
name|s
operator|->
name|start
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|->
name|start
operator|<
name|s
operator|->
name|start
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Check that the ranges are non-empty, sorted and non-overlapping  */
end_comment
begin_function
DECL|function|range_set_check_invariants
specifier|static
name|void
name|range_set_check_invariants
parameter_list|(
name|struct
name|range_set
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rs
condition|)
return|return;
if|if
condition|(
name|rs
operator|->
name|nr
condition|)
name|assert
argument_list|(
name|rs
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|start
operator|<
name|rs
operator|->
name|ranges
index|[
literal|0
index|]
operator|.
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rs
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|rs
operator|->
name|ranges
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|end
operator|<
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|start
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|start
operator|<
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * In-place pass of sorting and merging the ranges in the range set,  * to establish the invariants when we get the ranges from the user  */
end_comment
begin_function
DECL|function|sort_and_merge_range_set
specifier|static
name|void
name|sort_and_merge_range_set
parameter_list|(
name|struct
name|range_set
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|o
init|=
literal|0
decl_stmt|;
comment|/* output cursor */
name|qsort
argument_list|(
name|rs
operator|->
name|ranges
argument_list|,
name|rs
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|range
argument_list|)
argument_list|,
name|range_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|start
operator|==
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|end
condition|)
continue|continue;
if|if
condition|(
name|o
operator|>
literal|0
operator|&&
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|start
operator|<=
name|rs
operator|->
name|ranges
index|[
name|o
operator|-
literal|1
index|]
operator|.
name|end
condition|)
block|{
if|if
condition|(
name|rs
operator|->
name|ranges
index|[
name|o
operator|-
literal|1
index|]
operator|.
name|end
operator|<
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|end
condition|)
name|rs
operator|->
name|ranges
index|[
name|o
operator|-
literal|1
index|]
operator|.
name|end
operator|=
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|end
expr_stmt|;
block|}
else|else
block|{
name|rs
operator|->
name|ranges
index|[
name|o
index|]
operator|.
name|start
operator|=
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|start
expr_stmt|;
name|rs
operator|->
name|ranges
index|[
name|o
index|]
operator|.
name|end
operator|=
name|rs
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|end
expr_stmt|;
name|o
operator|++
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|o
operator|<=
name|rs
operator|->
name|nr
argument_list|)
expr_stmt|;
name|rs
operator|->
name|nr
operator|=
name|o
expr_stmt|;
name|range_set_check_invariants
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Union of range sets (i.e., sets of line numbers).  Used to merge  * them when searches meet at a common ancestor.  *  * This is also where the ranges are consolidated into canonical form:  * overlapping and adjacent ranges are merged, and empty ranges are  * removed.  */
end_comment
begin_function
DECL|function|range_set_union
specifier|static
name|void
name|range_set_union
parameter_list|(
name|struct
name|range_set
modifier|*
name|out
parameter_list|,
name|struct
name|range_set
modifier|*
name|a
parameter_list|,
name|struct
name|range_set
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|o
init|=
literal|0
decl_stmt|;
name|struct
name|range
modifier|*
name|ra
init|=
name|a
operator|->
name|ranges
decl_stmt|;
name|struct
name|range
modifier|*
name|rb
init|=
name|b
operator|->
name|ranges
decl_stmt|;
comment|/* cannot make an alias of out->ranges: it may change during grow */
name|assert
argument_list|(
name|out
operator|->
name|nr
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|a
operator|->
name|nr
operator|||
name|j
operator|<
name|b
operator|->
name|nr
condition|)
block|{
name|struct
name|range
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|a
operator|->
name|nr
operator|&&
name|j
operator|<
name|b
operator|->
name|nr
condition|)
block|{
if|if
condition|(
name|ra
index|[
name|i
index|]
operator|.
name|start
operator|<
name|rb
index|[
name|j
index|]
operator|.
name|start
condition|)
name|new
operator|=
operator|&
name|ra
index|[
name|i
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ra
index|[
name|i
index|]
operator|.
name|start
operator|>
name|rb
index|[
name|j
index|]
operator|.
name|start
condition|)
name|new
operator|=
operator|&
name|rb
index|[
name|j
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ra
index|[
name|i
index|]
operator|.
name|end
operator|<
name|rb
index|[
name|j
index|]
operator|.
name|end
condition|)
name|new
operator|=
operator|&
name|ra
index|[
name|i
operator|++
index|]
expr_stmt|;
else|else
name|new
operator|=
operator|&
name|rb
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|a
operator|->
name|nr
condition|)
comment|/* b exhausted */
name|new
operator|=
operator|&
name|ra
index|[
name|i
operator|++
index|]
expr_stmt|;
else|else
comment|/* a exhausted */
name|new
operator|=
operator|&
name|rb
index|[
name|j
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|start
operator|==
name|new
operator|->
name|end
condition|)
empty_stmt|;
comment|/* empty range */
elseif|else
if|if
condition|(
operator|!
name|o
operator|||
name|out
operator|->
name|ranges
index|[
name|o
operator|-
literal|1
index|]
operator|.
name|end
operator|<
name|new
operator|->
name|start
condition|)
block|{
name|range_set_grow
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
operator|->
name|ranges
index|[
name|o
index|]
operator|.
name|start
operator|=
name|new
operator|->
name|start
expr_stmt|;
name|out
operator|->
name|ranges
index|[
name|o
index|]
operator|.
name|end
operator|=
name|new
operator|->
name|end
expr_stmt|;
name|o
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out
operator|->
name|ranges
index|[
name|o
operator|-
literal|1
index|]
operator|.
name|end
operator|<
name|new
operator|->
name|end
condition|)
block|{
name|out
operator|->
name|ranges
index|[
name|o
operator|-
literal|1
index|]
operator|.
name|end
operator|=
name|new
operator|->
name|end
expr_stmt|;
block|}
block|}
name|out
operator|->
name|nr
operator|=
name|o
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Difference of range sets (out = a \ b).  Pass the "interesting"  * ranges as 'a' and the target side of the diff as 'b': it removes  * the ranges for which the commit is responsible.  */
end_comment
begin_function
DECL|function|range_set_difference
specifier|static
name|void
name|range_set_difference
parameter_list|(
name|struct
name|range_set
modifier|*
name|out
parameter_list|,
name|struct
name|range_set
modifier|*
name|a
parameter_list|,
name|struct
name|range_set
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|long
name|start
init|=
name|a
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
name|long
name|end
init|=
name|a
operator|->
name|ranges
index|[
name|i
index|]
operator|.
name|end
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
while|while
condition|(
name|j
operator|<
name|b
operator|->
name|nr
operator|&&
name|start
operator|>=
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|end
condition|)
comment|/* 				 * a:         |------- 				 * b: ------| 				 */
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|b
operator|->
name|nr
operator|||
name|end
operator|<
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|start
condition|)
block|{
comment|/* 				 * b exhausted, or 				 * a:  ----| 				 * b:         |---- 				 */
name|range_set_append
argument_list|(
name|out
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|start
operator|>=
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|start
condition|)
block|{
comment|/* 				 * a:     |--???? 				 * b: |------| 				 */
name|start
operator|=
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
operator|>
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|start
condition|)
block|{
comment|/* 				 * a: |-----| 				 * b:    |--????? 				 */
if|if
condition|(
name|start
operator|<
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|start
condition|)
name|range_set_append
argument_list|(
name|out
argument_list|,
name|start
argument_list|,
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
name|b
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|end
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|diff_ranges_init
specifier|static
name|void
name|diff_ranges_init
parameter_list|(
name|struct
name|diff_ranges
modifier|*
name|diff
parameter_list|)
block|{
name|range_set_init
argument_list|(
operator|&
name|diff
operator|->
name|parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range_set_init
argument_list|(
operator|&
name|diff
operator|->
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|diff_ranges_release
specifier|static
name|void
name|diff_ranges_release
parameter_list|(
name|struct
name|diff_ranges
modifier|*
name|diff
parameter_list|)
block|{
name|range_set_release
argument_list|(
operator|&
name|diff
operator|->
name|parent
argument_list|)
expr_stmt|;
name|range_set_release
argument_list|(
operator|&
name|diff
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|line_log_data_init
name|void
name|line_log_data_init
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|r
parameter_list|)
block|{
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|line_log_data
argument_list|)
argument_list|)
expr_stmt|;
name|range_set_init
argument_list|(
operator|&
name|r
operator|->
name|ranges
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|line_log_data_clear
specifier|static
name|void
name|line_log_data_clear
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|r
parameter_list|)
block|{
name|range_set_release
argument_list|(
operator|&
name|r
operator|->
name|ranges
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|pair
condition|)
name|diff_free_filepair
argument_list|(
name|r
operator|->
name|pair
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_line_log_data
specifier|static
name|void
name|free_line_log_data
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|r
parameter_list|)
block|{
while|while
condition|(
name|r
condition|)
block|{
name|struct
name|line_log_data
modifier|*
name|next
init|=
name|r
operator|->
name|next
decl_stmt|;
name|line_log_data_clear
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|struct
name|line_log_data
modifier|*
DECL|function|search_line_log_data
name|search_line_log_data
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|line_log_data
modifier|*
modifier|*
name|insertion_point
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|p
init|=
name|list
decl_stmt|;
if|if
condition|(
name|insertion_point
condition|)
operator|*
name|insertion_point
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|int
name|cmp
init|=
name|strcmp
argument_list|(
name|p
operator|->
name|path
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|p
return|;
if|if
condition|(
name|insertion_point
operator|&&
name|cmp
operator|<
literal|0
condition|)
operator|*
name|insertion_point
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Note: takes ownership of 'path', which happens to be what the only  * caller needs.  */
end_comment
begin_function
DECL|function|line_log_data_insert
specifier|static
name|void
name|line_log_data_insert
parameter_list|(
name|struct
name|line_log_data
modifier|*
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|long
name|begin
parameter_list|,
name|long
name|end
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|ip
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|p
init|=
name|search_line_log_data
argument_list|(
operator|*
name|list
argument_list|,
name|path
argument_list|,
operator|&
name|ip
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|range_set_append_unsafe
argument_list|(
operator|&
name|p
operator|->
name|ranges
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|sort_and_merge_range_set
argument_list|(
operator|&
name|p
operator|->
name|ranges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|line_log_data
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|range_set_append
argument_list|(
operator|&
name|p
operator|->
name|ranges
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|sort_and_merge_range_set
argument_list|(
operator|&
name|p
operator|->
name|ranges
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|p
operator|->
name|next
operator|=
name|ip
operator|->
name|next
expr_stmt|;
name|ip
operator|->
name|next
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function
begin_struct
DECL|struct|collect_diff_cbdata
struct|struct
name|collect_diff_cbdata
block|{
DECL|member|diff
name|struct
name|diff_ranges
modifier|*
name|diff
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|collect_diff_cb
specifier|static
name|int
name|collect_diff_cb
parameter_list|(
name|long
name|start_a
parameter_list|,
name|long
name|count_a
parameter_list|,
name|long
name|start_b
parameter_list|,
name|long
name|count_b
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|collect_diff_cbdata
modifier|*
name|d
init|=
name|data
decl_stmt|;
if|if
condition|(
name|count_a
operator|>=
literal|0
condition|)
name|range_set_append
argument_list|(
operator|&
name|d
operator|->
name|diff
operator|->
name|parent
argument_list|,
name|start_a
argument_list|,
name|start_a
operator|+
name|count_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_b
operator|>=
literal|0
condition|)
name|range_set_append
argument_list|(
operator|&
name|d
operator|->
name|diff
operator|->
name|target
argument_list|,
name|start_b
argument_list|,
name|start_b
operator|+
name|count_b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|collect_diff
specifier|static
name|void
name|collect_diff
parameter_list|(
name|mmfile_t
modifier|*
name|parent
parameter_list|,
name|mmfile_t
modifier|*
name|target
parameter_list|,
name|struct
name|diff_ranges
modifier|*
name|out
parameter_list|)
block|{
name|struct
name|collect_diff_cbdata
name|cbdata
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|xpparam_t
name|xpp
decl_stmt|;
name|xdemitconf_t
name|xecfg
decl_stmt|;
name|xdemitcb_t
name|ecb
decl_stmt|;
name|memset
argument_list|(
operator|&
name|xpp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xpp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|xecfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xecfg
argument_list|)
argument_list|)
expr_stmt|;
name|xecfg
operator|.
name|ctxlen
operator|=
name|xecfg
operator|.
name|interhunkctxlen
operator|=
literal|0
expr_stmt|;
name|cbdata
operator|.
name|diff
operator|=
name|out
expr_stmt|;
name|xecfg
operator|.
name|hunk_func
operator|=
name|collect_diff_cb
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ecb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ecb
argument_list|)
argument_list|)
expr_stmt|;
name|ecb
operator|.
name|priv
operator|=
operator|&
name|cbdata
expr_stmt|;
name|xdi_diff
argument_list|(
name|parent
argument_list|,
name|target
argument_list|,
operator|&
name|xpp
argument_list|,
operator|&
name|xecfg
argument_list|,
operator|&
name|ecb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * These are handy for debugging.  Removing them with #if 0 silences  * the "unused function" warning.  */
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|static void dump_range_set(struct range_set *rs, const char *desc) { 	int i; 	printf("range set %s (%d items):\n", desc, rs->nr); 	for (i = 0; i< rs->nr; i++) 		printf("\t[%ld,%ld]\n", rs->ranges[i].start, rs->ranges[i].end); }  static void dump_line_log_data(struct line_log_data *r) { 	char buf[4096]; 	while (r) { 		snprintf(buf, 4096, "file %s\n", r->path); 		dump_range_set(&r->ranges, buf); 		r = r->next; 	} }  static void dump_diff_ranges(struct diff_ranges *diff, const char *desc) { 	int i; 	assert(diff->parent.nr == diff->target.nr); 	printf("diff ranges %s (%d items):\n", desc, diff->parent.nr); 	printf("\tparent\ttarget\n"); 	for (i = 0; i< diff->parent.nr; i++) { 		printf("\t[%ld,%ld]\t[%ld,%ld]\n", 		       diff->parent.ranges[i].start, 		       diff->parent.ranges[i].end, 		       diff->target.ranges[i].start, 		       diff->target.ranges[i].end); 	} }
endif|#
directive|endif
end_endif
begin_function
DECL|function|ranges_overlap
specifier|static
name|int
name|ranges_overlap
parameter_list|(
name|struct
name|range
modifier|*
name|a
parameter_list|,
name|struct
name|range
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|!
operator|(
name|a
operator|->
name|end
operator|<=
name|b
operator|->
name|start
operator|||
name|b
operator|->
name|end
operator|<=
name|a
operator|->
name|start
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Given a diff and the set of interesting ranges, determine all hunks  * of the diff which touch (overlap) at least one of the interesting  * ranges in the target.  */
end_comment
begin_function
DECL|function|diff_ranges_filter_touched
specifier|static
name|void
name|diff_ranges_filter_touched
parameter_list|(
name|struct
name|diff_ranges
modifier|*
name|out
parameter_list|,
name|struct
name|diff_ranges
modifier|*
name|diff
parameter_list|,
name|struct
name|range_set
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|out
operator|->
name|target
operator|.
name|nr
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff
operator|->
name|target
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|i
index|]
operator|.
name|start
operator|>
name|rs
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|end
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|rs
operator|->
name|nr
condition|)
return|return;
block|}
if|if
condition|(
name|ranges_overlap
argument_list|(
operator|&
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|i
index|]
argument_list|,
operator|&
name|rs
operator|->
name|ranges
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|range_set_append
argument_list|(
operator|&
name|out
operator|->
name|parent
argument_list|,
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|i
index|]
operator|.
name|end
argument_list|)
expr_stmt|;
name|range_set_append
argument_list|(
operator|&
name|out
operator|->
name|target
argument_list|,
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|i
index|]
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * Adjust the line counts in 'rs' to account for the lines  * added/removed in the diff.  */
end_comment
begin_function
DECL|function|range_set_shift_diff
specifier|static
name|void
name|range_set_shift_diff
parameter_list|(
name|struct
name|range_set
modifier|*
name|out
parameter_list|,
name|struct
name|range_set
modifier|*
name|rs
parameter_list|,
name|struct
name|diff_ranges
modifier|*
name|diff
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|range
modifier|*
name|src
init|=
name|rs
operator|->
name|ranges
decl_stmt|;
name|struct
name|range
modifier|*
name|target
init|=
name|diff
operator|->
name|target
operator|.
name|ranges
decl_stmt|;
name|struct
name|range
modifier|*
name|parent
init|=
name|diff
operator|->
name|parent
operator|.
name|ranges
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|j
operator|<
name|diff
operator|->
name|target
operator|.
name|nr
operator|&&
name|src
index|[
name|i
index|]
operator|.
name|start
operator|>=
name|target
index|[
name|j
index|]
operator|.
name|start
condition|)
block|{
name|offset
operator|+=
operator|(
name|parent
index|[
name|j
index|]
operator|.
name|end
operator|-
name|parent
index|[
name|j
index|]
operator|.
name|start
operator|)
operator|-
operator|(
name|target
index|[
name|j
index|]
operator|.
name|end
operator|-
name|target
index|[
name|j
index|]
operator|.
name|start
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|range_set_append
argument_list|(
name|out
argument_list|,
name|src
index|[
name|i
index|]
operator|.
name|start
operator|+
name|offset
argument_list|,
name|src
index|[
name|i
index|]
operator|.
name|end
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Given a diff and the set of interesting ranges, map the ranges  * across the diff.  That is: observe that the target commit takes  * blame for all the + (target-side) ranges.  So for every pair of  * ranges in the diff that was touched, we remove the latter and add  * its parent side.  */
end_comment
begin_function
DECL|function|range_set_map_across_diff
specifier|static
name|void
name|range_set_map_across_diff
parameter_list|(
name|struct
name|range_set
modifier|*
name|out
parameter_list|,
name|struct
name|range_set
modifier|*
name|rs
parameter_list|,
name|struct
name|diff_ranges
modifier|*
name|diff
parameter_list|,
name|struct
name|diff_ranges
modifier|*
modifier|*
name|touched_out
parameter_list|)
block|{
name|struct
name|diff_ranges
modifier|*
name|touched
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|touched
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|range_set
name|tmp1
init|=
name|RANGE_SET_INIT
decl_stmt|;
name|struct
name|range_set
name|tmp2
init|=
name|RANGE_SET_INIT
decl_stmt|;
name|diff_ranges_init
argument_list|(
name|touched
argument_list|)
expr_stmt|;
name|diff_ranges_filter_touched
argument_list|(
name|touched
argument_list|,
name|diff
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|range_set_difference
argument_list|(
operator|&
name|tmp1
argument_list|,
name|rs
argument_list|,
operator|&
name|touched
operator|->
name|target
argument_list|)
expr_stmt|;
name|range_set_shift_diff
argument_list|(
operator|&
name|tmp2
argument_list|,
operator|&
name|tmp1
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|range_set_union
argument_list|(
name|out
argument_list|,
operator|&
name|tmp2
argument_list|,
operator|&
name|touched
operator|->
name|parent
argument_list|)
expr_stmt|;
name|range_set_release
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|range_set_release
argument_list|(
operator|&
name|tmp2
argument_list|)
expr_stmt|;
operator|*
name|touched_out
operator|=
name|touched
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_single_commit
specifier|static
name|struct
name|commit
modifier|*
name|check_single_commit
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|commit
init|=
name|NULL
decl_stmt|;
name|int
name|found
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revs
operator|->
name|pending
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
name|UNINTERESTING
condition|)
continue|continue;
while|while
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
name|obj
operator|=
name|deref_tag
argument_list|(
name|obj
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Non commit %s?"
argument_list|,
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
name|die
argument_list|(
literal|"More than one commit to dig from: %s and %s?"
argument_list|,
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|found
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|commit
operator|=
name|obj
expr_stmt|;
name|found
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|commit
condition|)
name|die
argument_list|(
literal|"No commit specified?"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|commit
return|;
block|}
end_function
begin_function
DECL|function|fill_blob_sha1
specifier|static
name|void
name|fill_blob_sha1
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|diff_filespec
modifier|*
name|spec
parameter_list|)
block|{
name|unsigned
name|mode
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_tree_entry
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|spec
operator|->
name|path
argument_list|,
name|sha1
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
name|die
argument_list|(
literal|"There is no path %s in the commit"
argument_list|,
name|spec
operator|->
name|path
argument_list|)
expr_stmt|;
name|fill_filespec
argument_list|(
name|spec
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_function
DECL|function|fill_line_ends
specifier|static
name|void
name|fill_line_ends
parameter_list|(
name|struct
name|diff_filespec
modifier|*
name|spec
parameter_list|,
name|long
modifier|*
name|lines
parameter_list|,
name|unsigned
name|long
modifier|*
modifier|*
name|line_ends
parameter_list|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|50
decl_stmt|;
name|long
name|cur
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
modifier|*
name|ends
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|diff_populate_filespec
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|)
condition|)
name|die
argument_list|(
literal|"Cannot read blob %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|spec
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|ends
operator|=
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ends
argument_list|)
argument_list|)
expr_stmt|;
name|ends
index|[
name|cur
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|spec
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|num
operator|<
name|spec
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|data
index|[
name|num
index|]
operator|==
literal|'\n'
operator|||
name|num
operator|==
name|spec
operator|->
name|size
operator|-
literal|1
condition|)
block|{
name|ALLOC_GROW
argument_list|(
name|ends
argument_list|,
operator|(
name|cur
operator|+
literal|1
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ends
index|[
name|cur
operator|++
index|]
operator|=
name|num
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
block|}
comment|/* shrink the array to fit the elements */
name|ends
operator|=
name|xrealloc
argument_list|(
name|ends
argument_list|,
name|cur
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ends
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lines
operator|=
name|cur
operator|-
literal|1
expr_stmt|;
operator|*
name|line_ends
operator|=
name|ends
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|nth_line_cb
struct|struct
name|nth_line_cb
block|{
DECL|member|spec
name|struct
name|diff_filespec
modifier|*
name|spec
decl_stmt|;
DECL|member|lines
name|long
name|lines
decl_stmt|;
DECL|member|line_ends
name|unsigned
name|long
modifier|*
name|line_ends
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|nth_line
specifier|static
specifier|const
name|char
modifier|*
name|nth_line
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|long
name|line
parameter_list|)
block|{
name|struct
name|nth_line_cb
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|assert
argument_list|(
name|d
operator|&&
name|line
operator|<=
name|d
operator|->
name|lines
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|d
operator|->
name|spec
operator|&&
name|d
operator|->
name|spec
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|spec
operator|->
name|data
return|;
else|else
return|return
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|spec
operator|->
name|data
operator|+
name|d
operator|->
name|line_ends
index|[
name|line
index|]
operator|+
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|struct
name|line_log_data
modifier|*
DECL|function|parse_lines
name|parse_lines
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|string_list
modifier|*
name|args
parameter_list|)
block|{
name|long
name|lines
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
modifier|*
name|ends
init|=
name|NULL
decl_stmt|;
name|struct
name|nth_line_cb
name|cb_data
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|ranges
init|=
name|NULL
decl_stmt|;
name|for_each_string_list_item
argument_list|(
argument|item
argument_list|,
argument|args
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|name_part
decl_stmt|,
modifier|*
name|range_part
decl_stmt|;
name|char
modifier|*
name|full_name
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|spec
decl_stmt|;
name|long
name|begin
init|=
literal|0
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
name|name_part
operator|=
name|skip_range_arg
argument_list|(
name|item
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name_part
operator|||
operator|*
name|name_part
operator|!=
literal|':'
operator|||
operator|!
name|name_part
index|[
literal|1
index|]
condition|)
name|die
argument_list|(
literal|"-L argument '%s' not of the form start,end:file"
argument_list|,
name|item
operator|->
name|string
argument_list|)
expr_stmt|;
name|range_part
operator|=
name|xstrndup
argument_list|(
name|item
operator|->
name|string
argument_list|,
name|name_part
operator|-
name|item
operator|->
name|string
argument_list|)
expr_stmt|;
name|name_part
operator|++
expr_stmt|;
name|full_name
operator|=
name|prefix_path
argument_list|(
name|prefix
argument_list|,
name|prefix
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
argument_list|,
name|name_part
argument_list|)
expr_stmt|;
name|spec
operator|=
name|alloc_filespec
argument_list|(
name|full_name
argument_list|)
expr_stmt|;
name|fill_blob_sha1
argument_list|(
name|commit
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|fill_line_ends
argument_list|(
name|spec
argument_list|,
operator|&
name|lines
argument_list|,
operator|&
name|ends
argument_list|)
expr_stmt|;
name|cb_data
operator|.
name|spec
operator|=
name|spec
expr_stmt|;
name|cb_data
operator|.
name|lines
operator|=
name|lines
expr_stmt|;
name|cb_data
operator|.
name|line_ends
operator|=
name|ends
expr_stmt|;
if|if
condition|(
name|parse_range_arg
argument_list|(
name|range_part
argument_list|,
name|nth_line
argument_list|,
operator|&
name|cb_data
argument_list|,
name|lines
argument_list|,
operator|&
name|begin
argument_list|,
operator|&
name|end
argument_list|,
name|full_name
argument_list|)
condition|)
name|die
argument_list|(
literal|"malformed -L argument '%s'"
argument_list|,
name|range_part
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|<
name|end
operator|||
operator|(
operator|(
name|lines
operator|||
name|begin
operator|)
operator|&&
name|lines
operator|<
name|begin
operator|)
condition|)
name|die
argument_list|(
literal|"file %s has only %lu lines"
argument_list|,
name|name_part
argument_list|,
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|<
literal|1
condition|)
name|begin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|1
condition|)
name|end
operator|=
name|lines
expr_stmt|;
name|begin
operator|--
expr_stmt|;
name|line_log_data_insert
argument_list|(
operator|&
name|ranges
argument_list|,
name|full_name
argument_list|,
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|free_filespec
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ends
argument_list|)
expr_stmt|;
name|ends
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ranges
return|;
block|}
end_function
begin_function
DECL|function|line_log_data_copy_one
specifier|static
name|struct
name|line_log_data
modifier|*
name|line_log_data_copy_one
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|line_log_data_init
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|range_set_copy
argument_list|(
operator|&
name|ret
operator|->
name|ranges
argument_list|,
operator|&
name|r
operator|->
name|ranges
argument_list|)
expr_stmt|;
name|ret
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|r
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
specifier|static
name|struct
name|line_log_data
modifier|*
DECL|function|line_log_data_copy
name|line_log_data_copy
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tmp
operator|=
name|prev
operator|=
name|line_log_data_copy_one
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|tmp
operator|=
name|line_log_data_copy_one
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|prev
operator|=
name|tmp
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/* merge two range sets across files */
end_comment
begin_function
DECL|function|line_log_data_merge
specifier|static
name|struct
name|line_log_data
modifier|*
name|line_log_data_merge
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|a
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|head
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|pp
init|=
operator|&
name|head
decl_stmt|;
while|while
condition|(
name|a
operator|||
name|b
condition|)
block|{
name|struct
name|line_log_data
modifier|*
name|src
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|src2
init|=
name|NULL
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|d
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
name|cmp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|b
condition|)
name|cmp
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|cmp
operator|=
name|strcmp
argument_list|(
name|a
operator|->
name|path
argument_list|,
name|b
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|src
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|src
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
name|src2
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
name|d
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|line_log_data
argument_list|)
argument_list|)
expr_stmt|;
name|line_log_data_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|src
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|d
expr_stmt|;
name|pp
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|src2
condition|)
name|range_set_union
argument_list|(
operator|&
name|d
operator|->
name|ranges
argument_list|,
operator|&
name|src
operator|->
name|ranges
argument_list|,
operator|&
name|src2
operator|->
name|ranges
argument_list|)
expr_stmt|;
else|else
name|range_set_copy
argument_list|(
operator|&
name|d
operator|->
name|ranges
argument_list|,
operator|&
name|src
operator|->
name|ranges
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function
begin_function
DECL|function|add_line_range
specifier|static
name|void
name|add_line_range
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|old
init|=
name|NULL
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
name|old
operator|=
name|lookup_decoration
argument_list|(
operator|&
name|revs
operator|->
name|line_log_data
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|&&
name|range
condition|)
block|{
name|new
operator|=
name|line_log_data_merge
argument_list|(
name|old
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|free_line_log_data
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|range
condition|)
name|new
operator|=
name|line_log_data_copy
argument_list|(
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|add_decoration
argument_list|(
operator|&
name|revs
operator|->
name|line_log_data
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear_commit_line_range
specifier|static
name|void
name|clear_commit_line_range
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|lookup_decoration
argument_list|(
operator|&
name|revs
operator|->
name|line_log_data
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return;
name|free_line_log_data
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|add_decoration
argument_list|(
operator|&
name|revs
operator|->
name|line_log_data
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lookup_line_range
specifier|static
name|struct
name|line_log_data
modifier|*
name|lookup_line_range
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|d
decl_stmt|;
name|ret
operator|=
name|lookup_decoration
argument_list|(
operator|&
name|revs
operator|->
name|line_log_data
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|ret
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|range_set_check_invariants
argument_list|(
operator|&
name|d
operator|->
name|ranges
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|line_log_init
name|void
name|line_log_init
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|string_list
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|NULL
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|range
decl_stmt|;
name|commit
operator|=
name|check_single_commit
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|range
operator|=
name|parse_lines
argument_list|(
name|commit
argument_list|,
name|prefix
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|add_line_range
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|,
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
operator|->
name|diffopt
operator|.
name|detect_rename
condition|)
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|r
init|=
name|range
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|paths
decl_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
name|paths
operator|=
name|xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|range
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|paths
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|r
operator|->
name|path
argument_list|)
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
name|paths
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
name|init_pathspec
argument_list|(
operator|&
name|rev
operator|->
name|diffopt
operator|.
name|pathspec
argument_list|,
name|paths
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|load_tree_desc
specifier|static
name|void
name|load_tree_desc
parameter_list|(
name|struct
name|tree_desc
modifier|*
name|desc
parameter_list|,
name|void
modifier|*
modifier|*
name|tree
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
operator|*
name|tree
operator|=
name|read_object_with_reference
argument_list|(
name|sha1
argument_list|,
name|tree_type
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|tree
condition|)
name|die
argument_list|(
literal|"Unable to read tree (%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
name|desc
argument_list|,
operator|*
name|tree
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|count_parents
specifier|static
name|int
name|count_parents
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|commit
operator|->
name|parents
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|move_diff_queue
specifier|static
name|void
name|move_diff_queue
parameter_list|(
name|struct
name|diff_queue_struct
modifier|*
name|dst
parameter_list|,
name|struct
name|diff_queue_struct
modifier|*
name|src
parameter_list|)
block|{
name|assert
argument_list|(
name|src
operator|!=
name|dst
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diff_queue_struct
argument_list|)
argument_list|)
expr_stmt|;
name|DIFF_QUEUE_CLEAR
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|filter_diffs_for_paths
specifier|static
name|void
name|filter_diffs_for_paths
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|,
name|int
name|keep_deletions
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|diff_queue_struct
name|outq
decl_stmt|;
name|DIFF_QUEUE_CLEAR
argument_list|(
operator|&
name|outq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|rg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|DIFF_FILE_VALID
argument_list|(
name|p
operator|->
name|two
argument_list|)
condition|)
block|{
if|if
condition|(
name|keep_deletions
condition|)
name|diff_q
argument_list|(
operator|&
name|outq
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|diff_free_filepair
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|rg
operator|=
name|range
init|;
name|rg
condition|;
name|rg
operator|=
name|rg
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rg
operator|->
name|path
argument_list|,
name|p
operator|->
name|two
operator|->
name|path
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|rg
condition|)
name|diff_q
argument_list|(
operator|&
name|outq
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|diff_free_filepair
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|diff_queued_diff
operator|.
name|queue
argument_list|)
expr_stmt|;
name|diff_queued_diff
operator|=
name|outq
expr_stmt|;
block|}
end_function
begin_function
DECL|function|diff_might_be_rename
specifier|static
specifier|inline
name|int
name|diff_might_be_rename
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|DIFF_FILE_VALID
argument_list|(
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
operator|->
name|one
argument_list|)
condition|)
block|{
comment|/* fprintf(stderr, "diff_might_be_rename found creation of: %s\n", */
comment|/* 	diff_queued_diff.queue[i]->two->path); */
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|queue_diffs
specifier|static
name|void
name|queue_diffs
parameter_list|(
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|,
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|,
name|struct
name|diff_queue_struct
modifier|*
name|queue
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit
modifier|*
name|parent
parameter_list|)
block|{
name|void
modifier|*
name|tree1
init|=
name|NULL
decl_stmt|,
modifier|*
name|tree2
init|=
name|NULL
decl_stmt|;
name|struct
name|tree_desc
name|desc1
decl_stmt|,
name|desc2
decl_stmt|;
name|assert
argument_list|(
name|commit
argument_list|)
expr_stmt|;
name|load_tree_desc
argument_list|(
operator|&
name|desc2
argument_list|,
operator|&
name|tree2
argument_list|,
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|load_tree_desc
argument_list|(
operator|&
name|desc1
argument_list|,
operator|&
name|tree1
argument_list|,
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
else|else
name|init_tree_desc
argument_list|(
operator|&
name|desc1
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DIFF_QUEUE_CLEAR
argument_list|(
operator|&
name|diff_queued_diff
argument_list|)
expr_stmt|;
name|diff_tree
argument_list|(
operator|&
name|desc1
argument_list|,
operator|&
name|desc2
argument_list|,
literal|""
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|detect_rename
condition|)
block|{
name|filter_diffs_for_paths
argument_list|(
name|range
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_might_be_rename
argument_list|()
condition|)
name|diffcore_std
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|filter_diffs_for_paths
argument_list|(
name|range
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|move_diff_queue
argument_list|(
name|queue
argument_list|,
operator|&
name|diff_queued_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree1
condition|)
name|free
argument_list|(
name|tree1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree2
condition|)
name|free
argument_list|(
name|tree2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_nth_line
specifier|static
name|char
modifier|*
name|get_nth_line
parameter_list|(
name|long
name|line
parameter_list|,
name|unsigned
name|long
modifier|*
name|ends
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|data
return|;
else|else
return|return
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|ends
index|[
name|line
index|]
operator|+
literal|1
return|;
block|}
end_function
begin_function
DECL|function|print_line
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|char
name|first
parameter_list|,
name|long
name|line
parameter_list|,
name|unsigned
name|long
modifier|*
name|ends
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|color
parameter_list|,
specifier|const
name|char
modifier|*
name|reset
parameter_list|)
block|{
name|char
modifier|*
name|begin
init|=
name|get_nth_line
argument_list|(
name|line
argument_list|,
name|ends
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|get_nth_line
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|ends
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|int
name|had_nl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|end
operator|>
name|begin
operator|&&
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|end
operator|--
expr_stmt|;
name|had_nl
operator|=
literal|1
expr_stmt|;
block|}
name|fputs
argument_list|(
name|prefix
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|color
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|begin
argument_list|,
literal|1
argument_list|,
name|end
operator|-
name|begin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|reset
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|had_nl
condition|)
name|fputs
argument_list|(
literal|"\\ No newline at end of file\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_prefix
specifier|static
name|char
modifier|*
name|output_prefix
parameter_list|(
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|)
block|{
name|char
modifier|*
name|prefix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|output_prefix
condition|)
block|{
name|struct
name|strbuf
modifier|*
name|sb
init|=
name|opt
operator|->
name|output_prefix
argument_list|(
name|opt
argument_list|,
name|opt
operator|->
name|output_prefix_data
argument_list|)
decl_stmt|;
name|prefix
operator|=
name|sb
operator|->
name|buf
expr_stmt|;
block|}
return|return
name|prefix
return|;
block|}
end_function
begin_function
DECL|function|dump_diff_hacky_one
specifier|static
name|void
name|dump_diff_hacky_one
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|long
name|p_lines
decl_stmt|,
name|t_lines
decl_stmt|;
name|unsigned
name|long
modifier|*
name|p_ends
init|=
name|NULL
decl_stmt|,
modifier|*
name|t_ends
init|=
name|NULL
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|pair
init|=
name|range
operator|->
name|pair
decl_stmt|;
name|struct
name|diff_ranges
modifier|*
name|diff
init|=
operator|&
name|range
operator|->
name|diff
decl_stmt|;
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
name|output_prefix
argument_list|(
name|opt
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_reset
init|=
name|diff_get_color
argument_list|(
name|opt
operator|->
name|use_color
argument_list|,
name|DIFF_RESET
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_frag
init|=
name|diff_get_color
argument_list|(
name|opt
operator|->
name|use_color
argument_list|,
name|DIFF_FRAGINFO
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_meta
init|=
name|diff_get_color
argument_list|(
name|opt
operator|->
name|use_color
argument_list|,
name|DIFF_METAINFO
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_old
init|=
name|diff_get_color
argument_list|(
name|opt
operator|->
name|use_color
argument_list|,
name|DIFF_FILE_OLD
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_new
init|=
name|diff_get_color
argument_list|(
name|opt
operator|->
name|use_color
argument_list|,
name|DIFF_FILE_NEW
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_plain
init|=
name|diff_get_color
argument_list|(
name|opt
operator|->
name|use_color
argument_list|,
name|DIFF_PLAIN
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pair
operator|||
operator|!
name|diff
condition|)
return|return;
if|if
condition|(
name|pair
operator|->
name|one
operator|->
name|sha1_valid
condition|)
name|fill_line_ends
argument_list|(
name|pair
operator|->
name|one
argument_list|,
operator|&
name|p_lines
argument_list|,
operator|&
name|p_ends
argument_list|)
expr_stmt|;
name|fill_line_ends
argument_list|(
name|pair
operator|->
name|two
argument_list|,
operator|&
name|t_lines
argument_list|,
operator|&
name|t_ends
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%sdiff --git a/%s b/%s%s\n"
argument_list|,
name|prefix
argument_list|,
name|c_meta
argument_list|,
name|pair
operator|->
name|one
operator|->
name|path
argument_list|,
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s--- %s%s%s\n"
argument_list|,
name|prefix
argument_list|,
name|c_meta
argument_list|,
name|pair
operator|->
name|one
operator|->
name|sha1_valid
condition|?
literal|"a/"
else|:
literal|""
argument_list|,
name|pair
operator|->
name|one
operator|->
name|sha1_valid
condition|?
name|pair
operator|->
name|one
operator|->
name|path
else|:
literal|"/dev/null"
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s+++ b/%s%s\n"
argument_list|,
name|prefix
argument_list|,
name|c_meta
argument_list|,
name|pair
operator|->
name|two
operator|->
name|path
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|range
operator|->
name|ranges
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|long
name|p_start
decl_stmt|,
name|p_end
decl_stmt|;
name|long
name|t_start
init|=
name|range
operator|->
name|ranges
operator|.
name|ranges
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
name|long
name|t_end
init|=
name|range
operator|->
name|ranges
operator|.
name|ranges
index|[
name|i
index|]
operator|.
name|end
decl_stmt|;
name|long
name|t_cur
init|=
name|t_start
decl_stmt|;
name|int
name|j_last
decl_stmt|;
while|while
condition|(
name|j
operator|<
name|diff
operator|->
name|target
operator|.
name|nr
operator|&&
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|end
operator|<
name|t_start
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|diff
operator|->
name|target
operator|.
name|nr
operator|||
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
operator|>
name|t_end
condition|)
continue|continue;
comment|/* Scan ahead to determine the last diff that falls in this range */
name|j_last
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|j_last
operator|<
name|diff
operator|->
name|target
operator|.
name|nr
operator|&&
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j_last
index|]
operator|.
name|start
operator|<
name|t_end
condition|)
name|j_last
operator|++
expr_stmt|;
if|if
condition|(
name|j_last
operator|>
name|j
condition|)
name|j_last
operator|--
expr_stmt|;
comment|/* 		 * Compute parent hunk headers: we know that the diff 		 * has the correct line numbers (but not all hunks). 		 * So it suffices to shift the start/end according to 		 * the line numbers of the first/last hunk(s) that 		 * fall in this range. 		 */
if|if
condition|(
name|t_start
operator|<
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
condition|)
name|p_start
operator|=
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
operator|-
operator|(
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
operator|-
name|t_start
operator|)
expr_stmt|;
else|else
name|p_start
operator|=
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|t_end
operator|>
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j_last
index|]
operator|.
name|end
condition|)
name|p_end
operator|=
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|j_last
index|]
operator|.
name|end
operator|+
operator|(
name|t_end
operator|-
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j_last
index|]
operator|.
name|end
operator|)
expr_stmt|;
else|else
name|p_end
operator|=
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|j_last
index|]
operator|.
name|end
expr_stmt|;
if|if
condition|(
operator|!
name|p_start
operator|&&
operator|!
name|p_end
condition|)
block|{
name|p_start
operator|=
operator|-
literal|1
expr_stmt|;
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Now output a diff hunk for this range */
name|printf
argument_list|(
literal|"%s%s@@ -%ld,%ld +%ld,%ld @@%s\n"
argument_list|,
name|prefix
argument_list|,
name|c_frag
argument_list|,
name|p_start
operator|+
literal|1
argument_list|,
name|p_end
operator|-
name|p_start
argument_list|,
name|t_start
operator|+
literal|1
argument_list|,
name|t_end
operator|-
name|t_start
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|diff
operator|->
name|target
operator|.
name|nr
operator|&&
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
operator|<
name|t_end
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
init|;
name|t_cur
operator|<
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
condition|;
name|t_cur
operator|++
control|)
name|print_line
argument_list|(
name|prefix
argument_list|,
literal|' '
argument_list|,
name|t_cur
argument_list|,
name|t_ends
argument_list|,
name|pair
operator|->
name|two
operator|->
name|data
argument_list|,
name|c_plain
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|start
init|;
name|k
operator|<
name|diff
operator|->
name|parent
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|end
condition|;
name|k
operator|++
control|)
name|print_line
argument_list|(
name|prefix
argument_list|,
literal|'-'
argument_list|,
name|k
argument_list|,
name|p_ends
argument_list|,
name|pair
operator|->
name|one
operator|->
name|data
argument_list|,
name|c_old
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t_cur
operator|<
name|diff
operator|->
name|target
operator|.
name|ranges
index|[
name|j
index|]
operator|.
name|end
operator|&&
name|t_cur
operator|<
name|t_end
condition|;
name|t_cur
operator|++
control|)
name|print_line
argument_list|(
name|prefix
argument_list|,
literal|'+'
argument_list|,
name|t_cur
argument_list|,
name|t_ends
argument_list|,
name|pair
operator|->
name|two
operator|->
name|data
argument_list|,
name|c_new
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|t_cur
operator|<
name|t_end
condition|;
name|t_cur
operator|++
control|)
name|print_line
argument_list|(
name|prefix
argument_list|,
literal|' '
argument_list|,
name|t_cur
argument_list|,
name|t_ends
argument_list|,
name|pair
operator|->
name|two
operator|->
name|data
argument_list|,
name|c_plain
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p_ends
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t_ends
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * NEEDSWORK: manually building a diff here is not the Right  * Thing(tm).  log -L should be built into the diff pipeline.  */
end_comment
begin_function
DECL|function|dump_diff_hacky
specifier|static
name|void
name|dump_diff_hacky
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|)
block|{
name|puts
argument_list|(
name|output_prefix
argument_list|(
operator|&
name|rev
operator|->
name|diffopt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|range
condition|)
block|{
name|dump_diff_hacky_one
argument_list|(
name|rev
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|range
operator|=
name|range
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Unlike most other functions, this destructively operates on  * 'range'.  */
end_comment
begin_function
DECL|function|process_diff_filepair
specifier|static
name|int
name|process_diff_filepair
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|diff_filepair
modifier|*
name|pair
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|,
name|struct
name|diff_ranges
modifier|*
modifier|*
name|diff_out
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|rg
init|=
name|range
decl_stmt|;
name|struct
name|range_set
name|tmp
decl_stmt|;
name|struct
name|diff_ranges
name|diff
decl_stmt|;
name|mmfile_t
name|file_parent
decl_stmt|,
name|file_target
decl_stmt|;
name|assert
argument_list|(
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|rg
condition|)
block|{
name|assert
argument_list|(
name|rg
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rg
operator|->
name|path
argument_list|,
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
condition|)
break|break;
name|rg
operator|=
name|rg
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rg
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rg
operator|->
name|ranges
operator|.
name|nr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|pair
operator|->
name|two
operator|->
name|sha1_valid
argument_list|)
expr_stmt|;
name|diff_populate_filespec
argument_list|(
name|pair
operator|->
name|two
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_target
operator|.
name|ptr
operator|=
name|pair
operator|->
name|two
operator|->
name|data
expr_stmt|;
name|file_target
operator|.
name|size
operator|=
name|pair
operator|->
name|two
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|one
operator|->
name|sha1_valid
condition|)
block|{
name|diff_populate_filespec
argument_list|(
name|pair
operator|->
name|one
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_parent
operator|.
name|ptr
operator|=
name|pair
operator|->
name|one
operator|->
name|data
expr_stmt|;
name|file_parent
operator|.
name|size
operator|=
name|pair
operator|->
name|one
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|file_parent
operator|.
name|ptr
operator|=
literal|""
expr_stmt|;
name|file_parent
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|diff_ranges_init
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|collect_diff
argument_list|(
operator|&
name|file_parent
argument_list|,
operator|&
name|file_target
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
comment|/* NEEDSWORK should apply some heuristics to prevent mismatches */
name|free
argument_list|(
name|rg
operator|->
name|path
argument_list|)
expr_stmt|;
name|rg
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|pair
operator|->
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
name|range_set_init
argument_list|(
operator|&
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range_set_map_across_diff
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|rg
operator|->
name|ranges
argument_list|,
operator|&
name|diff
argument_list|,
name|diff_out
argument_list|)
expr_stmt|;
name|range_set_release
argument_list|(
operator|&
name|rg
operator|->
name|ranges
argument_list|)
expr_stmt|;
name|range_set_move
argument_list|(
operator|&
name|rg
operator|->
name|ranges
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|diff_ranges_release
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|diff_out
operator|)
operator|->
name|parent
operator|.
name|nr
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|diff_filepair_dup
specifier|static
name|struct
name|diff_filepair
modifier|*
name|diff_filepair_dup
parameter_list|(
name|struct
name|diff_filepair
modifier|*
name|pair
parameter_list|)
block|{
name|struct
name|diff_filepair
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|diff_filepair
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|one
operator|=
name|pair
operator|->
name|one
expr_stmt|;
name|new
operator|->
name|two
operator|=
name|pair
operator|->
name|two
expr_stmt|;
name|new
operator|->
name|one
operator|->
name|count
operator|++
expr_stmt|;
name|new
operator|->
name|two
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|new
return|;
block|}
end_function
begin_function
DECL|function|free_diffqueues
specifier|static
name|void
name|free_diffqueues
parameter_list|(
name|int
name|n
parameter_list|,
name|struct
name|diff_queue_struct
modifier|*
name|dq
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dq
index|[
name|i
index|]
operator|.
name|nr
condition|;
name|j
operator|++
control|)
name|diff_free_filepair
argument_list|(
name|dq
index|[
name|i
index|]
operator|.
name|queue
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dq
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|process_all_files
specifier|static
name|int
name|process_all_files
parameter_list|(
name|struct
name|line_log_data
modifier|*
modifier|*
name|range_out
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|diff_queue_struct
modifier|*
name|queue
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|changed
init|=
literal|0
decl_stmt|;
operator|*
name|range_out
operator|=
name|line_log_data_copy
argument_list|(
name|range
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|queue
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_ranges
modifier|*
name|pairdiff
init|=
name|NULL
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|pair
init|=
name|queue
operator|->
name|queue
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|process_diff_filepair
argument_list|(
name|rev
argument_list|,
name|pair
argument_list|,
operator|*
name|range_out
argument_list|,
operator|&
name|pairdiff
argument_list|)
condition|)
block|{
comment|/* 			 * Store away the diff for later output.  We 			 * tuck it in the ranges we got as _input_, 			 * since that's the commit that caused the 			 * diff. 			 * 			 * NEEDSWORK not enough when we get around to 			 * doing something interesting with merges; 			 * currently each invocation on a merge parent 			 * trashes the previous one's diff. 			 * 			 * NEEDSWORK tramples over data structures not owned here 			 */
name|struct
name|line_log_data
modifier|*
name|rg
init|=
name|range
decl_stmt|;
name|changed
operator|++
expr_stmt|;
while|while
condition|(
name|rg
operator|&&
name|strcmp
argument_list|(
name|rg
operator|->
name|path
argument_list|,
name|pair
operator|->
name|two
operator|->
name|path
argument_list|)
condition|)
name|rg
operator|=
name|rg
operator|->
name|next
expr_stmt|;
name|assert
argument_list|(
name|rg
argument_list|)
expr_stmt|;
name|rg
operator|->
name|pair
operator|=
name|diff_filepair_dup
argument_list|(
name|queue
operator|->
name|queue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rg
operator|->
name|diff
argument_list|,
name|pairdiff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diff_ranges
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function
begin_function
DECL|function|line_log_print
name|int
name|line_log_print
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|range
init|=
name|lookup_line_range
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|)
decl_stmt|;
name|show_log
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|dump_diff_hacky
argument_list|(
name|rev
argument_list|,
name|range
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|process_ranges_ordinary_commit
specifier|static
name|int
name|process_ranges_ordinary_commit
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|NULL
decl_stmt|;
name|struct
name|diff_queue_struct
name|queue
decl_stmt|;
name|struct
name|line_log_data
modifier|*
name|parent_range
decl_stmt|;
name|int
name|changed
decl_stmt|;
if|if
condition|(
name|commit
operator|->
name|parents
condition|)
name|parent
operator|=
name|commit
operator|->
name|parents
operator|->
name|item
expr_stmt|;
name|queue_diffs
argument_list|(
name|range
argument_list|,
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
operator|&
name|queue
argument_list|,
name|commit
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|changed
operator|=
name|process_all_files
argument_list|(
operator|&
name|parent_range
argument_list|,
name|rev
argument_list|,
operator|&
name|queue
argument_list|,
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|add_line_range
argument_list|(
name|rev
argument_list|,
name|parent
argument_list|,
name|parent_range
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function
begin_function
DECL|function|process_ranges_merge_commit
specifier|static
name|int
name|process_ranges_merge_commit
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|line_log_data
modifier|*
name|range
parameter_list|)
block|{
name|struct
name|diff_queue_struct
modifier|*
name|diffqueues
decl_stmt|;
name|struct
name|line_log_data
modifier|*
modifier|*
name|cand
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nparents
init|=
name|count_parents
argument_list|(
name|commit
argument_list|)
decl_stmt|;
name|diffqueues
operator|=
name|xmalloc
argument_list|(
name|nparents
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|diffqueues
argument_list|)
argument_list|)
expr_stmt|;
name|cand
operator|=
name|xmalloc
argument_list|(
name|nparents
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cand
argument_list|)
argument_list|)
expr_stmt|;
name|parents
operator|=
name|xmalloc
argument_list|(
name|nparents
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|parents
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparents
condition|;
name|i
operator|++
control|)
block|{
name|parents
index|[
name|i
index|]
operator|=
name|p
operator|->
name|item
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|queue_diffs
argument_list|(
name|range
argument_list|,
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
operator|&
name|diffqueues
index|[
name|i
index|]
argument_list|,
name|commit
argument_list|,
name|parents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparents
condition|;
name|i
operator|++
control|)
block|{
name|int
name|changed
decl_stmt|;
name|cand
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|changed
operator|=
name|process_all_files
argument_list|(
operator|&
name|cand
index|[
name|i
index|]
argument_list|,
name|rev
argument_list|,
operator|&
name|diffqueues
index|[
name|i
index|]
argument_list|,
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
block|{
comment|/* 			 * This parent can take all the blame, so we 			 * don't follow any other path in history 			 */
name|add_line_range
argument_list|(
name|rev
argument_list|,
name|parents
index|[
name|i
index|]
argument_list|,
name|cand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|clear_commit_line_range
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|commit
operator|->
name|parents
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_list
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|->
name|parents
operator|->
name|item
operator|=
name|parents
index|[
name|i
index|]
expr_stmt|;
name|commit
operator|->
name|parents
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cand
argument_list|)
expr_stmt|;
name|free_diffqueues
argument_list|(
name|nparents
argument_list|,
name|diffqueues
argument_list|)
expr_stmt|;
comment|/* NEEDSWORK leaking like a sieve */
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * No single parent took the blame.  We add the candidates 	 * from the above loop to the parents. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparents
condition|;
name|i
operator|++
control|)
block|{
name|add_line_range
argument_list|(
name|rev
argument_list|,
name|parents
index|[
name|i
index|]
argument_list|,
name|cand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|clear_commit_line_range
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cand
argument_list|)
expr_stmt|;
name|free_diffqueues
argument_list|(
name|nparents
argument_list|,
name|diffqueues
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* NEEDSWORK evil merge detection stuff */
comment|/* NEEDSWORK leaking like a sieve */
block|}
end_function
begin_function
DECL|function|process_ranges_arbitrary_commit
specifier|static
name|int
name|process_ranges_arbitrary_commit
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|line_log_data
modifier|*
name|range
init|=
name|lookup_line_range
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|)
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|range
condition|)
block|{
if|if
condition|(
operator|!
name|commit
operator|->
name|parents
operator|||
operator|!
name|commit
operator|->
name|parents
operator|->
name|next
condition|)
name|changed
operator|=
name|process_ranges_ordinary_commit
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|,
name|range
argument_list|)
expr_stmt|;
else|else
name|changed
operator|=
name|process_ranges_merge_commit
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|changed
condition|)
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|TREESAME
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function
begin_function
DECL|function|line_log_rewrite_one
specifier|static
name|enum
name|rewrite_result
name|line_log_rewrite_one
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|parents
operator|&&
name|p
operator|->
name|parents
operator|->
name|next
condition|)
return|return
name|rewrite_one_ok
return|;
if|if
condition|(
name|p
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
return|return
name|rewrite_one_ok
return|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|object
operator|.
name|flags
operator|&
name|TREESAME
operator|)
condition|)
return|return
name|rewrite_one_ok
return|;
if|if
condition|(
operator|!
name|p
operator|->
name|parents
condition|)
return|return
name|rewrite_one_noparents
return|;
operator|*
name|pp
operator|=
name|p
operator|->
name|parents
operator|->
name|item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|line_log_filter
name|int
name|line_log_filter
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|list
init|=
name|rev
operator|->
name|commits
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|out
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|pp
init|=
operator|&
name|out
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|to_free
init|=
name|NULL
decl_stmt|;
name|commit
operator|=
name|list
operator|->
name|item
expr_stmt|;
if|if
condition|(
name|process_ranges_arbitrary_commit
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|)
condition|)
block|{
operator|*
name|pp
operator|=
name|list
expr_stmt|;
name|pp
operator|=
operator|&
name|list
operator|->
name|next
expr_stmt|;
block|}
else|else
name|to_free
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|list
operator|=
name|out
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|rewrite_parents
argument_list|(
name|rev
argument_list|,
name|list
operator|->
name|item
argument_list|,
name|line_log_rewrite_one
argument_list|)
expr_stmt|;
name|rev
operator|->
name|commits
operator|=
name|out
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
