begin_unit
begin_comment
comment|/*  * Pickaxe  *  * Copyright (c) 2006, Junio C Hamano  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"path-list.h"
end_include
begin_include
include|#
directive|include
file|"mailmap.h"
end_include
begin_decl_stmt
DECL|variable|blame_usage
specifier|static
name|char
name|blame_usage
index|[]
init|=
literal|"git-blame [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-p] [-w] [-L n,m] [-S<revs-file>] [-M] [-C] [-C] [--contents<filename>] [--incremental] [commit] [--] file\n"
literal|"  -c                  Use the same output mode as git-annotate (Default: off)\n"
literal|"  -b                  Show blank SHA-1 for boundary commits (Default: off)\n"
literal|"  -l                  Show long commit SHA1 (Default: off)\n"
literal|"  --root              Do not treat root commits as boundaries (Default: off)\n"
literal|"  -t                  Show raw timestamp (Default: off)\n"
literal|"  -f, --show-name     Show original filename (Default: auto)\n"
literal|"  -n, --show-number   Show original linenumber (Default: off)\n"
literal|"  -s                  Suppress author name and timestamp (Default: off)\n"
literal|"  -p, --porcelain     Show in a format designed for machine consumption\n"
literal|"  -w                  Ignore whitespace differences\n"
literal|"  -L n,m              Process only line range n,m, counting from 1\n"
literal|"  -M, -C              Find line movements within and across files\n"
literal|"  --incremental       Show blame entries as we find them, incrementally\n"
literal|"  --contents file     Use<file>'s contents as the final image\n"
literal|"  -S revs-file        Use revisions from revs-file instead of calling git-rev-list\n"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|longest_file
specifier|static
name|int
name|longest_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|longest_author
specifier|static
name|int
name|longest_author
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_orig_digits
specifier|static
name|int
name|max_orig_digits
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_digits
specifier|static
name|int
name|max_digits
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_score_digits
specifier|static
name|int
name|max_score_digits
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|show_root
specifier|static
name|int
name|show_root
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blank_boundary
specifier|static
name|int
name|blank_boundary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|incremental
specifier|static
name|int
name|incremental
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cmd_is_annotate
specifier|static
name|int
name|cmd_is_annotate
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xdl_opts
specifier|static
name|int
name|xdl_opts
init|=
name|XDF_NEED_MINIMAL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|mailmap
specifier|static
name|struct
name|path_list
name|mailmap
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* stats */
end_comment
begin_decl_stmt
DECL|variable|num_read_blob
specifier|static
name|int
name|num_read_blob
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|num_get_patch
specifier|static
name|int
name|num_get_patch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|num_commits
specifier|static
name|int
name|num_commits
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|PICKAXE_BLAME_MOVE
define|#
directive|define
name|PICKAXE_BLAME_MOVE
value|01
end_define
begin_define
DECL|macro|PICKAXE_BLAME_COPY
define|#
directive|define
name|PICKAXE_BLAME_COPY
value|02
end_define
begin_define
DECL|macro|PICKAXE_BLAME_COPY_HARDER
define|#
directive|define
name|PICKAXE_BLAME_COPY_HARDER
value|04
end_define
begin_define
DECL|macro|PICKAXE_BLAME_COPY_HARDEST
define|#
directive|define
name|PICKAXE_BLAME_COPY_HARDEST
value|010
end_define
begin_comment
comment|/*  * blame for a blame_entry with score lower than these thresholds  * is not passed to the parent using move/copy logic.  */
end_comment
begin_decl_stmt
DECL|variable|blame_move_score
specifier|static
name|unsigned
name|blame_move_score
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blame_copy_score
specifier|static
name|unsigned
name|blame_copy_score
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|BLAME_DEFAULT_MOVE_SCORE
define|#
directive|define
name|BLAME_DEFAULT_MOVE_SCORE
value|20
end_define
begin_define
DECL|macro|BLAME_DEFAULT_COPY_SCORE
define|#
directive|define
name|BLAME_DEFAULT_COPY_SCORE
value|40
end_define
begin_comment
comment|/* bits #0..7 in revision.h, #8..11 used for merge_bases() in commit.c */
end_comment
begin_define
DECL|macro|METAINFO_SHOWN
define|#
directive|define
name|METAINFO_SHOWN
value|(1u<<12)
end_define
begin_define
DECL|macro|MORE_THAN_ONE_PATH
define|#
directive|define
name|MORE_THAN_ONE_PATH
value|(1u<<13)
end_define
begin_comment
comment|/*  * One blob in a commit that is being suspected  */
end_comment
begin_struct
DECL|struct|origin
struct|struct
name|origin
block|{
DECL|member|refcnt
name|int
name|refcnt
decl_stmt|;
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
DECL|member|file
name|mmfile_t
name|file
decl_stmt|;
DECL|member|blob_sha1
name|unsigned
name|char
name|blob_sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|path
name|char
name|path
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Given an origin, prepare mmfile_t structure to be used by the  * diff machinery  */
end_comment
begin_function
DECL|function|fill_origin_blob
specifier|static
name|char
modifier|*
name|fill_origin_blob
parameter_list|(
name|struct
name|origin
modifier|*
name|o
parameter_list|,
name|mmfile_t
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
operator|->
name|file
operator|.
name|ptr
condition|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|num_read_blob
operator|++
expr_stmt|;
name|file
operator|->
name|ptr
operator|=
name|read_sha1_file
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|&
operator|(
name|file
operator|->
name|size
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|ptr
condition|)
name|die
argument_list|(
literal|"Cannot read blob %s for path %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|path
argument_list|)
expr_stmt|;
name|o
operator|->
name|file
operator|=
operator|*
name|file
expr_stmt|;
block|}
else|else
operator|*
name|file
operator|=
name|o
operator|->
name|file
expr_stmt|;
return|return
name|file
operator|->
name|ptr
return|;
block|}
end_function
begin_comment
comment|/*  * Origin is refcounted and usually we keep the blob contents to be  * reused.  */
end_comment
begin_function
DECL|function|origin_incref
specifier|static
specifier|inline
name|struct
name|origin
modifier|*
name|origin_incref
parameter_list|(
name|struct
name|origin
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
condition|)
name|o
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|o
return|;
block|}
end_function
begin_function
DECL|function|origin_decref
specifier|static
name|void
name|origin_decref
parameter_list|(
name|struct
name|origin
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|&&
operator|--
name|o
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|file
operator|.
name|ptr
condition|)
name|free
argument_list|(
name|o
operator|->
name|file
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drop_origin_blob
specifier|static
name|void
name|drop_origin_blob
parameter_list|(
name|struct
name|origin
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|file
operator|.
name|ptr
condition|)
block|{
name|free
argument_list|(
name|o
operator|->
name|file
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|o
operator|->
name|file
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Each group of lines is described by a blame_entry; it can be split  * as we pass blame to the parents.  They form a linked list in the  * scoreboard structure, sorted by the target line number.  */
end_comment
begin_struct
DECL|struct|blame_entry
struct|struct
name|blame_entry
block|{
DECL|member|prev
name|struct
name|blame_entry
modifier|*
name|prev
decl_stmt|;
DECL|member|next
name|struct
name|blame_entry
modifier|*
name|next
decl_stmt|;
comment|/* the first line of this group in the final image; 	 * internally all line numbers are 0 based. 	 */
DECL|member|lno
name|int
name|lno
decl_stmt|;
comment|/* how many lines this group has */
DECL|member|num_lines
name|int
name|num_lines
decl_stmt|;
comment|/* the commit that introduced this group into the final image */
DECL|member|suspect
name|struct
name|origin
modifier|*
name|suspect
decl_stmt|;
comment|/* true if the suspect is truly guilty; false while we have not 	 * checked if the group came from one of its parents. 	 */
DECL|member|guilty
name|char
name|guilty
decl_stmt|;
comment|/* the line number of the first line of this group in the 	 * suspect's file; internally all line numbers are 0 based. 	 */
DECL|member|s_lno
name|int
name|s_lno
decl_stmt|;
comment|/* how significant this entry is -- cached to avoid 	 * scanning the lines over and over. 	 */
DECL|member|score
name|unsigned
name|score
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * The current state of the blame assignment.  */
end_comment
begin_struct
DECL|struct|scoreboard
struct|struct
name|scoreboard
block|{
comment|/* the final commit (i.e. where we started digging from) */
DECL|member|final
name|struct
name|commit
modifier|*
name|final
decl_stmt|;
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* 	 * The contents in the final image. 	 * Used by many functions to obtain contents of the nth line, 	 * indexed with scoreboard.lineno[blame_entry.lno]. 	 */
DECL|member|final_buf
specifier|const
name|char
modifier|*
name|final_buf
decl_stmt|;
DECL|member|final_buf_size
name|unsigned
name|long
name|final_buf_size
decl_stmt|;
comment|/* linked list of blames */
DECL|member|ent
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
comment|/* look-up a line in the final buffer */
DECL|member|num_lines
name|int
name|num_lines
decl_stmt|;
DECL|member|lineno
name|int
modifier|*
name|lineno
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|same_suspect
specifier|static
specifier|inline
name|int
name|same_suspect
parameter_list|(
name|struct
name|origin
modifier|*
name|a
parameter_list|,
name|struct
name|origin
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|commit
operator|!=
name|b
operator|->
name|commit
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|path
argument_list|,
name|b
operator|->
name|path
argument_list|)
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|sanity_check_refcnt
parameter_list|(
name|struct
name|scoreboard
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * If two blame entries that are next to each other came from  * contiguous lines in the same origin (i.e.<commit, path> pair),  * merge them together.  */
end_comment
begin_function
DECL|function|coalesce
specifier|static
name|void
name|coalesce
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
operator|&&
operator|(
name|next
operator|=
name|ent
operator|->
name|next
operator|)
condition|;
name|ent
operator|=
name|next
control|)
block|{
if|if
condition|(
name|same_suspect
argument_list|(
name|ent
operator|->
name|suspect
argument_list|,
name|next
operator|->
name|suspect
argument_list|)
operator|&&
name|ent
operator|->
name|guilty
operator|==
name|next
operator|->
name|guilty
operator|&&
name|ent
operator|->
name|s_lno
operator|+
name|ent
operator|->
name|num_lines
operator|==
name|next
operator|->
name|s_lno
condition|)
block|{
name|ent
operator|->
name|num_lines
operator|+=
name|next
operator|->
name|num_lines
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|next
condition|)
name|ent
operator|->
name|next
operator|->
name|prev
operator|=
name|ent
expr_stmt|;
name|origin_decref
argument_list|(
name|next
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|ent
operator|->
name|score
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|ent
expr_stmt|;
comment|/* again */
block|}
block|}
if|if
condition|(
name|DEBUG
condition|)
comment|/* sanity */
name|sanity_check_refcnt
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Given a commit and a path in it, create a new origin structure.  * The callers that add blame to the scoreboard should use  * get_origin() to obtain shared, refcounted copy instead of calling  * this function directly.  */
end_comment
begin_function
DECL|function|make_origin
specifier|static
name|struct
name|origin
modifier|*
name|make_origin
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|origin
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|o
operator|->
name|commit
operator|=
name|commit
expr_stmt|;
name|o
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|o
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function
begin_comment
comment|/*  * Locate an existing origin or create a new one.  */
end_comment
begin_function
DECL|function|get_origin
specifier|static
name|struct
name|origin
modifier|*
name|get_origin
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|suspect
operator|->
name|commit
operator|==
name|commit
operator|&&
operator|!
name|strcmp
argument_list|(
name|e
operator|->
name|suspect
operator|->
name|path
argument_list|,
name|path
argument_list|)
condition|)
return|return
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
return|;
block|}
return|return
name|make_origin
argument_list|(
name|commit
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fill the blob_sha1 field of an origin if it hasn't, so that later  * call to fill_origin_blob() can use it to locate the data.  blob_sha1  * for an origin is also used to pass the blame for the entire file to  * the parent to detect the case where a child's blob is identical to  * that of its parent's.  */
end_comment
begin_function
DECL|function|fill_blob_sha1
specifier|static
name|int
name|fill_blob_sha1
parameter_list|(
name|struct
name|origin
modifier|*
name|origin
parameter_list|)
block|{
name|unsigned
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|is_null_sha1
argument_list|(
name|origin
operator|->
name|blob_sha1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_tree_entry
argument_list|(
name|origin
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|origin
operator|->
name|path
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
goto|goto
name|error_out
goto|;
if|if
condition|(
name|sha1_object_info
argument_list|(
name|origin
operator|->
name|blob_sha1
argument_list|,
name|NULL
argument_list|)
operator|!=
name|OBJ_BLOB
condition|)
goto|goto
name|error_out
goto|;
return|return
literal|0
return|;
name|error_out
label|:
name|hashclr
argument_list|(
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * We have an origin -- check if the same path exists in the  * parent and return an origin structure to represent it.  */
end_comment
begin_function
DECL|function|find_origin
specifier|static
name|struct
name|origin
modifier|*
name|find_origin
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|NULL
decl_stmt|;
name|struct
name|diff_options
name|diff_opts
decl_stmt|;
specifier|const
name|char
modifier|*
name|paths
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|util
condition|)
block|{
comment|/* 		 * Each commit object can cache one origin in that 		 * commit.  This is a freestanding copy of origin and 		 * not refcounted. 		 */
name|struct
name|origin
modifier|*
name|cached
init|=
name|parent
operator|->
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cached
operator|->
name|path
argument_list|,
name|origin
operator|->
name|path
argument_list|)
condition|)
block|{
comment|/* 			 * The same path between origin and its parent 			 * without renaming -- the most common case. 			 */
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|cached
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 			 * If the origin was newly created (i.e. get_origin 			 * would call make_origin if none is found in the 			 * scoreboard), it does not know the blob_sha1, 			 * so copy it.  Otherwise porigin was in the 			 * scoreboard and already knows blob_sha1. 			 */
if|if
condition|(
name|porigin
operator|->
name|refcnt
operator|==
literal|1
condition|)
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|cached
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
return|return
name|porigin
return|;
block|}
comment|/* otherwise it was not very useful; free it */
name|free
argument_list|(
name|parent
operator|->
name|util
argument_list|)
expr_stmt|;
name|parent
operator|->
name|util
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* See if the origin->path is different between parent 	 * and origin first.  Most of the time they are the 	 * same and diff-tree is fairly efficient about this. 	 */
name|diff_setup
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|diff_opts
operator|.
name|detect_rename
operator|=
literal|0
expr_stmt|;
name|diff_opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|paths
index|[
literal|0
index|]
operator|=
name|origin
operator|->
name|path
expr_stmt|;
name|paths
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|diff_tree_setup_paths
argument_list|(
name|paths
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|diff_opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff-setup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|origin
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
name|do_diff_cache
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
else|else
name|diff_tree_sha1
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|origin
operator|->
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
comment|/* It is either one entry that says "modified", or "created", 	 * or nothing. 	 */
if|if
condition|(
operator|!
name|diff_queued_diff
operator|.
name|nr
condition|)
block|{
comment|/* The path is the same as parent */
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|origin
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff_queued_diff
operator|.
name|nr
operator|!=
literal|1
condition|)
name|die
argument_list|(
literal|"internal error in blame::find_origin"
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|status
condition|)
block|{
default|default:
name|die
argument_list|(
literal|"internal error in blame::find_origin (%c)"
argument_list|,
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
case|case
literal|'M'
case|:
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|origin
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'T'
case|:
comment|/* Did not exist in parent, or type changed */
break|break;
block|}
block|}
name|diff_flush
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|diff_tree_release_paths
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|porigin
condition|)
block|{
comment|/* 		 * Create a freestanding copy that is not part of 		 * the refcounted origin found in the scoreboard, and 		 * cache it in the commit. 		 */
name|struct
name|origin
modifier|*
name|cached
decl_stmt|;
name|cached
operator|=
name|make_origin
argument_list|(
name|porigin
operator|->
name|commit
argument_list|,
name|porigin
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|cached
operator|->
name|blob_sha1
argument_list|,
name|porigin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|parent
operator|->
name|util
operator|=
name|cached
expr_stmt|;
block|}
return|return
name|porigin
return|;
block|}
end_function
begin_comment
comment|/*  * We have an origin -- find the path that corresponds to it in its  * parent and return an origin structure to represent it.  */
end_comment
begin_function
DECL|function|find_rename
specifier|static
name|struct
name|origin
modifier|*
name|find_rename
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|NULL
decl_stmt|;
name|struct
name|diff_options
name|diff_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|paths
index|[
literal|2
index|]
decl_stmt|;
name|diff_setup
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|diff_opts
operator|.
name|detect_rename
operator|=
name|DIFF_DETECT_RENAME
expr_stmt|;
name|diff_opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_opts
operator|.
name|single_follow
operator|=
name|origin
operator|->
name|path
expr_stmt|;
name|paths
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|diff_tree_setup_paths
argument_list|(
name|paths
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|diff_opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff-setup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|origin
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
name|do_diff_cache
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
else|else
name|diff_tree_sha1
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|origin
operator|->
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|status
operator|==
literal|'R'
operator|||
name|p
operator|->
name|status
operator|==
literal|'C'
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|two
operator|->
name|path
argument_list|,
name|origin
operator|->
name|path
argument_list|)
condition|)
block|{
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|diff_flush
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|diff_tree_release_paths
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
return|return
name|porigin
return|;
block|}
end_function
begin_comment
comment|/*  * Parsing of patch chunks...  */
end_comment
begin_struct
DECL|struct|chunk
struct|struct
name|chunk
block|{
comment|/* line number in postimage; up to but not including this 	 * line is the same as preimage 	 */
DECL|member|same
name|int
name|same
decl_stmt|;
comment|/* preimage line number after this chunk */
DECL|member|p_next
name|int
name|p_next
decl_stmt|;
comment|/* postimage line number after this chunk */
DECL|member|t_next
name|int
name|t_next
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|patch
struct|struct
name|patch
block|{
DECL|member|chunks
name|struct
name|chunk
modifier|*
name|chunks
decl_stmt|;
DECL|member|num
name|int
name|num
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|blame_diff_state
struct|struct
name|blame_diff_state
block|{
DECL|member|xm
name|struct
name|xdiff_emit_state
name|xm
decl_stmt|;
DECL|member|ret
name|struct
name|patch
modifier|*
name|ret
decl_stmt|;
DECL|member|hunk_post_context
name|unsigned
name|hunk_post_context
decl_stmt|;
DECL|member|hunk_in_pre_context
name|unsigned
name|hunk_in_pre_context
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|process_u_diff
specifier|static
name|void
name|process_u_diff
parameter_list|(
name|void
modifier|*
name|state_
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|struct
name|blame_diff_state
modifier|*
name|state
init|=
name|state_
decl_stmt|;
name|struct
name|chunk
modifier|*
name|chunk
decl_stmt|;
name|int
name|off1
decl_stmt|,
name|off2
decl_stmt|,
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|num
decl_stmt|;
name|num
operator|=
name|state
operator|->
name|ret
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
operator|||
name|line
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|||
name|line
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|hunk_in_pre_context
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|state
operator|->
name|ret
operator|->
name|chunks
index|[
name|num
operator|-
literal|1
index|]
operator|.
name|same
operator|++
expr_stmt|;
else|else
block|{
name|state
operator|->
name|hunk_in_pre_context
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|state
operator|->
name|hunk_post_context
operator|++
expr_stmt|;
else|else
name|state
operator|->
name|hunk_post_context
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|num
operator|&&
name|state
operator|->
name|hunk_post_context
condition|)
block|{
name|chunk
operator|=
operator|&
name|state
operator|->
name|ret
operator|->
name|chunks
index|[
name|num
operator|-
literal|1
index|]
expr_stmt|;
name|chunk
operator|->
name|p_next
operator|-=
name|state
operator|->
name|hunk_post_context
expr_stmt|;
name|chunk
operator|->
name|t_next
operator|-=
name|state
operator|->
name|hunk_post_context
expr_stmt|;
block|}
name|state
operator|->
name|ret
operator|->
name|num
operator|=
operator|++
name|num
expr_stmt|;
name|state
operator|->
name|ret
operator|->
name|chunks
operator|=
name|xrealloc
argument_list|(
name|state
operator|->
name|ret
operator|->
name|chunks
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chunk
argument_list|)
operator|*
name|num
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|&
name|state
operator|->
name|ret
operator|->
name|chunks
index|[
name|num
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|parse_hunk_header
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
operator|&
name|off1
argument_list|,
operator|&
name|len1
argument_list|,
operator|&
name|off2
argument_list|,
operator|&
name|len2
argument_list|)
condition|)
block|{
name|state
operator|->
name|ret
operator|->
name|num
operator|--
expr_stmt|;
return|return;
block|}
comment|/* Line numbers in patch output are one based. */
name|off1
operator|--
expr_stmt|;
name|off2
operator|--
expr_stmt|;
name|chunk
operator|->
name|same
operator|=
name|len2
condition|?
name|off2
else|:
operator|(
name|off2
operator|+
literal|1
operator|)
expr_stmt|;
name|chunk
operator|->
name|p_next
operator|=
name|off1
operator|+
operator|(
name|len1
condition|?
name|len1
else|:
literal|1
operator|)
expr_stmt|;
name|chunk
operator|->
name|t_next
operator|=
name|chunk
operator|->
name|same
operator|+
name|len2
expr_stmt|;
name|state
operator|->
name|hunk_in_pre_context
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|hunk_post_context
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compare_buffer
specifier|static
name|struct
name|patch
modifier|*
name|compare_buffer
parameter_list|(
name|mmfile_t
modifier|*
name|file_p
parameter_list|,
name|mmfile_t
modifier|*
name|file_o
parameter_list|,
name|int
name|context
parameter_list|)
block|{
name|struct
name|blame_diff_state
name|state
decl_stmt|;
name|xpparam_t
name|xpp
decl_stmt|;
name|xdemitconf_t
name|xecfg
decl_stmt|;
name|xdemitcb_t
name|ecb
decl_stmt|;
name|xpp
operator|.
name|flags
operator|=
name|xdl_opts
expr_stmt|;
name|memset
argument_list|(
operator|&
name|xecfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xecfg
argument_list|)
argument_list|)
expr_stmt|;
name|xecfg
operator|.
name|ctxlen
operator|=
name|context
expr_stmt|;
name|ecb
operator|.
name|outf
operator|=
name|xdiff_outf
expr_stmt|;
name|ecb
operator|.
name|priv
operator|=
operator|&
name|state
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|xm
operator|.
name|consume
operator|=
name|process_u_diff
expr_stmt|;
name|state
operator|.
name|ret
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|patch
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|ret
operator|->
name|chunks
operator|=
name|NULL
expr_stmt|;
name|state
operator|.
name|ret
operator|->
name|num
operator|=
literal|0
expr_stmt|;
name|xdi_diff
argument_list|(
name|file_p
argument_list|,
name|file_o
argument_list|,
operator|&
name|xpp
argument_list|,
operator|&
name|xecfg
argument_list|,
operator|&
name|ecb
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|ret
operator|->
name|num
condition|)
block|{
name|struct
name|chunk
modifier|*
name|chunk
decl_stmt|;
name|chunk
operator|=
operator|&
name|state
operator|.
name|ret
operator|->
name|chunks
index|[
name|state
operator|.
name|ret
operator|->
name|num
operator|-
literal|1
index|]
expr_stmt|;
name|chunk
operator|->
name|p_next
operator|-=
name|state
operator|.
name|hunk_post_context
expr_stmt|;
name|chunk
operator|->
name|t_next
operator|-=
name|state
operator|.
name|hunk_post_context
expr_stmt|;
block|}
return|return
name|state
operator|.
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Run diff between two origins and grab the patch output, so that  * we can pass blame for lines origin is currently suspected for  * to its parent.  */
end_comment
begin_function
DECL|function|get_patch
specifier|static
name|struct
name|patch
modifier|*
name|get_patch
parameter_list|(
name|struct
name|origin
modifier|*
name|parent
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|)
block|{
name|mmfile_t
name|file_p
decl_stmt|,
name|file_o
decl_stmt|;
name|struct
name|patch
modifier|*
name|patch
decl_stmt|;
name|fill_origin_blob
argument_list|(
name|parent
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
name|fill_origin_blob
argument_list|(
name|origin
argument_list|,
operator|&
name|file_o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_p
operator|.
name|ptr
operator|||
operator|!
name|file_o
operator|.
name|ptr
condition|)
return|return
name|NULL
return|;
name|patch
operator|=
name|compare_buffer
argument_list|(
operator|&
name|file_p
argument_list|,
operator|&
name|file_o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num_get_patch
operator|++
expr_stmt|;
return|return
name|patch
return|;
block|}
end_function
begin_function
DECL|function|free_patch
specifier|static
name|void
name|free_patch
parameter_list|(
name|struct
name|patch
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
operator|->
name|chunks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Link in a new blame entry to the scoreboard.  Entries that cover the  * same line range have been removed from the scoreboard previously.  */
end_comment
begin_function
DECL|function|add_blame_entry
specifier|static
name|void
name|add_blame_entry
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
operator|&&
name|ent
operator|->
name|lno
operator|<
name|e
operator|->
name|lno
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
name|prev
operator|=
name|ent
expr_stmt|;
comment|/* prev, if not NULL, is the last one that is below e */
name|e
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|e
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|next
operator|=
name|sb
operator|->
name|ent
expr_stmt|;
name|sb
operator|->
name|ent
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|next
condition|)
name|e
operator|->
name|next
operator|->
name|prev
operator|=
name|e
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * src typically is on-stack; we want to copy the information in it to  * a malloced blame_entry that is already on the linked list of the  * scoreboard.  The origin of dst loses a refcnt while the origin of src  * gains one.  */
end_comment
begin_function
DECL|function|dup_entry
specifier|static
name|void
name|dup_entry
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|dst
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|p
operator|=
name|dst
operator|->
name|prev
expr_stmt|;
name|n
operator|=
name|dst
operator|->
name|next
expr_stmt|;
name|origin_incref
argument_list|(
name|src
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|dst
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|prev
operator|=
name|p
expr_stmt|;
name|dst
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|dst
operator|->
name|score
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nth_line
specifier|static
specifier|const
name|char
modifier|*
name|nth_line
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
name|lno
parameter_list|)
block|{
return|return
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|lineno
index|[
name|lno
index|]
return|;
block|}
end_function
begin_comment
comment|/*  * It is known that lines between tlno to same came from parent, and e  * has an overlap with that range.  it also is known that parent's  * line plno corresponds to e's line tlno.  *  *<---- e ----->  *<------>  *<------------>  *<------------>  *<------------------>  *  * Split e into potentially three parts; before this chunk, the chunk  * to be blamed for the parent, and after that portion.  */
end_comment
begin_function
DECL|function|split_overlap
specifier|static
name|void
name|split_overlap
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|chunk_end_lno
decl_stmt|;
name|memset
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|s_lno
operator|<
name|tlno
condition|)
block|{
comment|/* there is a pre-chunk part not blamed on parent */
name|split
index|[
literal|0
index|]
operator|.
name|suspect
operator|=
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|.
name|s_lno
operator|=
name|e
operator|->
name|s_lno
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|.
name|num_lines
operator|=
name|tlno
operator|-
name|e
operator|->
name|s_lno
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
operator|+
name|tlno
operator|-
name|e
operator|->
name|s_lno
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|s_lno
operator|=
name|plno
expr_stmt|;
block|}
else|else
block|{
name|split
index|[
literal|1
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|s_lno
operator|=
name|plno
operator|+
operator|(
name|e
operator|->
name|s_lno
operator|-
name|tlno
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|same
operator|<
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
condition|)
block|{
comment|/* there is a post-chunk part not blamed on parent */
name|split
index|[
literal|2
index|]
operator|.
name|suspect
operator|=
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|split
index|[
literal|2
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
operator|+
operator|(
name|same
operator|-
name|e
operator|->
name|s_lno
operator|)
expr_stmt|;
name|split
index|[
literal|2
index|]
operator|.
name|s_lno
operator|=
name|e
operator|->
name|s_lno
operator|+
operator|(
name|same
operator|-
name|e
operator|->
name|s_lno
operator|)
expr_stmt|;
name|split
index|[
literal|2
index|]
operator|.
name|num_lines
operator|=
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
operator|-
name|same
expr_stmt|;
name|chunk_end_lno
operator|=
name|split
index|[
literal|2
index|]
operator|.
name|lno
expr_stmt|;
block|}
else|else
name|chunk_end_lno
operator|=
name|e
operator|->
name|lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|num_lines
operator|=
name|chunk_end_lno
operator|-
name|split
index|[
literal|1
index|]
operator|.
name|lno
expr_stmt|;
comment|/* 	 * if it turns out there is nothing to blame the parent for, 	 * forget about the splitting.  !split[1].suspect signals this. 	 */
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|num_lines
operator|<
literal|1
condition|)
return|return;
name|split
index|[
literal|1
index|]
operator|.
name|suspect
operator|=
name|origin_incref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * split_overlap() divided an existing blame e into up to three parts  * in split.  Adjust the linked list of blames in the scoreboard to  * reflect the split.  */
end_comment
begin_function
DECL|function|split_blame
specifier|static
name|void
name|split_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|new_entry
decl_stmt|;
if|if
condition|(
name|split
index|[
literal|0
index|]
operator|.
name|suspect
operator|&&
name|split
index|[
literal|2
index|]
operator|.
name|suspect
condition|)
block|{
comment|/* The first part (reuse storage for the existing entry e) */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* The last part -- me */
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|2
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
comment|/* ... and the middle part -- parent */
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|1
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|split
index|[
literal|0
index|]
operator|.
name|suspect
operator|&&
operator|!
name|split
index|[
literal|2
index|]
operator|.
name|suspect
condition|)
comment|/* 		 * The parent covers the entire area; reuse storage for 		 * e and replace it with the parent. 		 */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|split
index|[
literal|0
index|]
operator|.
name|suspect
condition|)
block|{
comment|/* me and then parent */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|1
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parent and then me */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|2
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
comment|/* sanity */
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
name|int
name|lno
init|=
name|sb
operator|->
name|ent
operator|->
name|lno
decl_stmt|,
name|corrupt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lno
operator|!=
name|ent
operator|->
name|lno
condition|)
name|corrupt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|s_lno
operator|<
literal|0
condition|)
name|corrupt
operator|=
literal|1
expr_stmt|;
name|lno
operator|+=
name|ent
operator|->
name|num_lines
expr_stmt|;
block|}
if|if
condition|(
name|corrupt
condition|)
block|{
name|lno
operator|=
name|sb
operator|->
name|ent
operator|->
name|lno
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"L %8d l %8d n %8d\n"
argument_list|,
name|lno
argument_list|,
name|ent
operator|->
name|lno
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|)
expr_stmt|;
name|lno
operator|=
name|ent
operator|->
name|lno
operator|+
name|ent
operator|->
name|num_lines
expr_stmt|;
block|}
name|die
argument_list|(
literal|"oops"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * After splitting the blame, the origins used by the  * on-stack blame_entry should lose one refcnt each.  */
end_comment
begin_function
DECL|function|decref_split
specifier|static
name|void
name|decref_split
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|origin_decref
argument_list|(
name|split
index|[
name|i
index|]
operator|.
name|suspect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Helper for blame_chunk().  blame_entry e is known to overlap with  * the patch hunk; split it and pass blame to the parent.  */
end_comment
begin_function
DECL|function|blame_overlap
specifier|static
name|void
name|blame_overlap
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|blame_entry
name|split
index|[
literal|3
index|]
decl_stmt|;
name|split_overlap
argument_list|(
name|split
argument_list|,
name|e
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|same
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|suspect
condition|)
name|split_blame
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Find the line number of the last line the target is suspected for.  */
end_comment
begin_function
DECL|function|find_last_in_target
specifier|static
name|int
name|find_last_in_target
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
name|int
name|last_in_target
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|guilty
operator|||
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|last_in_target
operator|<
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
condition|)
name|last_in_target
operator|=
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
block|}
return|return
name|last_in_target
return|;
block|}
end_function
begin_comment
comment|/*  * Process one hunk from the patch between the current suspect for  * blame_entry e and its parent.  Find and split the overlap, and  * pass blame to the overlapping part to the parent.  */
end_comment
begin_function
DECL|function|blame_chunk
specifier|static
name|void
name|blame_chunk
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|guilty
operator|||
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|same
operator|<=
name|e
operator|->
name|s_lno
condition|)
continue|continue;
if|if
condition|(
name|tlno
operator|<
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
condition|)
name|blame_overlap
argument_list|(
name|sb
argument_list|,
name|e
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|same
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * We are looking at the origin 'target' and aiming to pass blame  * for the lines it is suspected to its parent.  Run diff to find  * which lines came from parent and pass blame for them.  */
end_comment
begin_function
DECL|function|pass_blame_to_parent
specifier|static
name|int
name|pass_blame_to_parent
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|last_in_target
decl_stmt|,
name|plno
decl_stmt|,
name|tlno
decl_stmt|;
name|struct
name|patch
modifier|*
name|patch
decl_stmt|;
name|last_in_target
operator|=
name|find_last_in_target
argument_list|(
name|sb
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_in_target
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* nothing remains for this target */
name|patch
operator|=
name|get_patch
argument_list|(
name|parent
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|plno
operator|=
name|tlno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patch
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|chunk
modifier|*
name|chunk
init|=
operator|&
name|patch
operator|->
name|chunks
index|[
name|i
index|]
decl_stmt|;
name|blame_chunk
argument_list|(
name|sb
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|chunk
operator|->
name|same
argument_list|,
name|target
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|plno
operator|=
name|chunk
operator|->
name|p_next
expr_stmt|;
name|tlno
operator|=
name|chunk
operator|->
name|t_next
expr_stmt|;
block|}
comment|/* The rest (i.e. anything after tlno) are the same as the parent */
name|blame_chunk
argument_list|(
name|sb
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|last_in_target
argument_list|,
name|target
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|free_patch
argument_list|(
name|patch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * The lines in blame_entry after splitting blames many times can become  * very small and trivial, and at some point it becomes pointless to  * blame the parents.  E.g. "\t\t}\n\t}\n\n" appears everywhere in any  * ordinary C program, and it is not worth to say it was copied from  * totally unrelated file in the parent.  *  * Compute how trivial the lines in the blame_entry are.  */
end_comment
begin_function
DECL|function|ent_score
specifier|static
name|unsigned
name|ent_score
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|)
block|{
name|unsigned
name|score
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|score
condition|)
return|return
name|e
operator|->
name|score
return|;
name|score
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|e
operator|->
name|lno
argument_list|)
expr_stmt|;
name|ep
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|e
operator|->
name|lno
operator|+
name|e
operator|->
name|num_lines
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
name|unsigned
name|ch
init|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp
operator|)
decl_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
condition|)
name|score
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|e
operator|->
name|score
operator|=
name|score
expr_stmt|;
return|return
name|score
return|;
block|}
end_function
begin_comment
comment|/*  * best_so_far[] and this[] are both a split of an existing blame_entry  * that passes blame to the parent.  Maintain best_so_far the best split  * so far, by comparing this and best_so_far and copying this into  * bst_so_far as needed.  */
end_comment
begin_function
DECL|function|copy_split_if_better
specifier|static
name|void
name|copy_split_if_better
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|best_so_far
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|this
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|this
index|[
literal|1
index|]
operator|.
name|suspect
condition|)
return|return;
if|if
condition|(
name|best_so_far
index|[
literal|1
index|]
operator|.
name|suspect
condition|)
block|{
if|if
condition|(
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|this
index|[
literal|1
index|]
argument_list|)
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|best_so_far
index|[
literal|1
index|]
argument_list|)
condition|)
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|origin_incref
argument_list|(
name|this
index|[
name|i
index|]
operator|.
name|suspect
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|best_so_far
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|best_so_far
argument_list|,
name|this
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * We are looking at a part of the final image represented by  * ent (tlno and same are offset by ent->s_lno).  * tlno is where we are looking at in the final image.  * up to (but not including) same match preimage.  * plno is where we are looking at in the preimage.  *  *<-------------- final image ---------------------->  *<------ent------>  *         ^tlno ^same  *<---------preimage----->  *         ^plno  *  * All line numbers are 0-based.  */
end_comment
begin_function
DECL|function|handle_split
specifier|static
name|void
name|handle_split
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|num_lines
operator|<=
name|tlno
condition|)
return|return;
if|if
condition|(
name|tlno
operator|<
name|same
condition|)
block|{
name|struct
name|blame_entry
name|this
index|[
literal|3
index|]
decl_stmt|;
name|tlno
operator|+=
name|ent
operator|->
name|s_lno
expr_stmt|;
name|same
operator|+=
name|ent
operator|->
name|s_lno
expr_stmt|;
name|split_overlap
argument_list|(
name|this
argument_list|,
name|ent
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|same
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|copy_split_if_better
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Find the lines from parent that are the same as ent so that  * we can pass blames to it.  file_p has the blob contents for  * the parent.  */
end_comment
begin_function
DECL|function|find_copy_in_blob
specifier|static
name|void
name|find_copy_in_blob
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|,
name|mmfile_t
modifier|*
name|file_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|mmfile_t
name|file_o
decl_stmt|;
name|struct
name|patch
modifier|*
name|patch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|plno
decl_stmt|,
name|tlno
decl_stmt|;
comment|/* 	 * Prepare mmfile that contains only the lines in ent. 	 */
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|ent
operator|->
name|lno
argument_list|)
expr_stmt|;
name|file_o
operator|.
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|cnt
operator|=
name|ent
operator|->
name|num_lines
expr_stmt|;
while|while
condition|(
name|cnt
operator|&&
name|cp
operator|<
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|final_buf_size
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\n'
condition|)
name|cnt
operator|--
expr_stmt|;
block|}
name|file_o
operator|.
name|size
operator|=
name|cp
operator|-
name|file_o
operator|.
name|ptr
expr_stmt|;
name|patch
operator|=
name|compare_buffer
argument_list|(
name|file_p
argument_list|,
operator|&
name|file_o
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * file_o is a part of final image we are annotating. 	 * file_p partially may match that image. 	 */
name|memset
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|plno
operator|=
name|tlno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patch
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|chunk
modifier|*
name|chunk
init|=
operator|&
name|patch
operator|->
name|chunks
index|[
name|i
index|]
decl_stmt|;
name|handle_split
argument_list|(
name|sb
argument_list|,
name|ent
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|chunk
operator|->
name|same
argument_list|,
name|parent
argument_list|,
name|split
argument_list|)
expr_stmt|;
name|plno
operator|=
name|chunk
operator|->
name|p_next
expr_stmt|;
name|tlno
operator|=
name|chunk
operator|->
name|t_next
expr_stmt|;
block|}
comment|/* remainder, if any, all match the preimage */
name|handle_split
argument_list|(
name|sb
argument_list|,
name|ent
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|,
name|parent
argument_list|,
name|split
argument_list|)
expr_stmt|;
name|free_patch
argument_list|(
name|patch
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * See if lines currently target is suspected for can be attributed to  * parent.  */
end_comment
begin_function
DECL|function|find_move_in_parent
specifier|static
name|int
name|find_move_in_parent
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|last_in_target
decl_stmt|,
name|made_progress
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|,
name|split
index|[
literal|3
index|]
decl_stmt|;
name|mmfile_t
name|file_p
decl_stmt|;
name|last_in_target
operator|=
name|find_last_in_target
argument_list|(
name|sb
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_in_target
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* nothing remains for this target */
name|fill_origin_blob
argument_list|(
name|parent
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_p
operator|.
name|ptr
condition|)
return|return
literal|0
return|;
name|made_progress
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|made_progress
condition|)
block|{
name|made_progress
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|guilty
operator|||
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
condition|)
continue|continue;
name|find_copy_in_blob
argument_list|(
name|sb
argument_list|,
name|e
argument_list|,
name|parent
argument_list|,
name|split
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|suspect
operator|&&
name|blame_move_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|split_blame
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|made_progress
operator|=
literal|1
expr_stmt|;
block|}
name|decref_split
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|blame_list
struct|struct
name|blame_list
block|{
DECL|member|ent
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
DECL|member|split
name|struct
name|blame_entry
name|split
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Count the number of entries the target is suspected for,  * and prepare a list of entry and the best split.  */
end_comment
begin_function
DECL|function|setup_blame_list
specifier|static
name|struct
name|blame_list
modifier|*
name|setup_blame_list
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|num_ents_p
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
name|int
name|num_ents
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|blame_list
modifier|*
name|blame_list
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
operator|,
name|num_ents
operator|=
literal|0
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|guilty
operator|&&
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
condition|)
name|num_ents
operator|++
expr_stmt|;
if|if
condition|(
name|num_ents
condition|)
block|{
name|blame_list
operator|=
name|xcalloc
argument_list|(
name|num_ents
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
operator|,
name|i
operator|=
literal|0
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|guilty
operator|&&
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
condition|)
name|blame_list
index|[
name|i
operator|++
index|]
operator|.
name|ent
operator|=
name|e
expr_stmt|;
block|}
operator|*
name|num_ents_p
operator|=
name|num_ents
expr_stmt|;
return|return
name|blame_list
return|;
block|}
end_function
begin_comment
comment|/*  * For lines target is suspected for, see if we can find code movement  * across file boundary from the parent commit.  porigin is the path  * in the parent we already tried.  */
end_comment
begin_function
DECL|function|find_copy_in_parent
specifier|static
name|int
name|find_copy_in_parent
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|origin
modifier|*
name|porigin
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|struct
name|diff_options
name|diff_opts
decl_stmt|;
specifier|const
name|char
modifier|*
name|paths
index|[
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|blame_list
modifier|*
name|blame_list
decl_stmt|;
name|int
name|num_ents
decl_stmt|;
name|blame_list
operator|=
name|setup_blame_list
argument_list|(
name|sb
argument_list|,
name|target
argument_list|,
operator|&
name|num_ents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blame_list
condition|)
return|return
literal|1
return|;
comment|/* nothing remains for this target */
name|diff_setup
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|diff_opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|paths
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|diff_tree_setup_paths
argument_list|(
name|paths
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|diff_opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"diff-setup"
argument_list|)
expr_stmt|;
comment|/* Try "find copies harder" on new path if requested; 	 * we do not want to use diffcore_rename() actually to 	 * match things up; find_copies_harder is set only to 	 * force diff_tree_sha1() to feed all filepairs to diff_queue, 	 * and this code needs to be after diff_setup_done(), which 	 * usually makes find-copies-harder imply copy detection. 	 */
if|if
condition|(
operator|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY_HARDEST
operator|)
operator|||
operator|(
operator|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY_HARDER
operator|)
operator|&&
operator|(
operator|!
name|porigin
operator|||
name|strcmp
argument_list|(
name|target
operator|->
name|path
argument_list|,
name|porigin
operator|->
name|path
argument_list|)
operator|)
operator|)
condition|)
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|FIND_COPIES_HARDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|target
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
name|do_diff_cache
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
else|else
name|diff_tree_sha1
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|target
operator|->
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DIFF_OPT_TST
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|FIND_COPIES_HARDER
argument_list|)
condition|)
name|diffcore_std
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|made_progress
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
name|struct
name|origin
modifier|*
name|norigin
decl_stmt|;
name|mmfile_t
name|file_p
decl_stmt|;
name|struct
name|blame_entry
name|this
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|DIFF_FILE_VALID
argument_list|(
name|p
operator|->
name|one
argument_list|)
condition|)
continue|continue;
comment|/* does not exist in parent */
if|if
condition|(
name|porigin
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|porigin
operator|->
name|path
argument_list|)
condition|)
comment|/* find_move already dealt with this path */
continue|continue;
name|norigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|norigin
operator|->
name|blob_sha1
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|fill_origin_blob
argument_list|(
name|norigin
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_p
operator|.
name|ptr
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_ents
condition|;
name|j
operator|++
control|)
block|{
name|find_copy_in_blob
argument_list|(
name|sb
argument_list|,
name|blame_list
index|[
name|j
index|]
operator|.
name|ent
argument_list|,
name|norigin
argument_list|,
name|this
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
name|copy_split_if_better
argument_list|(
name|sb
argument_list|,
name|blame_list
index|[
name|j
index|]
operator|.
name|split
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|origin_decref
argument_list|(
name|norigin
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_ents
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|blame_entry
modifier|*
name|split
init|=
name|blame_list
index|[
name|j
index|]
operator|.
name|split
decl_stmt|;
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|suspect
operator|&&
name|blame_copy_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|split_blame
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|blame_list
index|[
name|j
index|]
operator|.
name|ent
argument_list|)
expr_stmt|;
name|made_progress
operator|=
literal|1
expr_stmt|;
block|}
name|decref_split
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|blame_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|made_progress
condition|)
break|break;
name|blame_list
operator|=
name|setup_blame_list
argument_list|(
name|sb
argument_list|,
name|target
argument_list|,
operator|&
name|num_ents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blame_list
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|diff_flush
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|diff_tree_release_paths
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*  * The blobs of origin and porigin exactly match, so everything  * origin is suspected for can be blamed on the parent.  */
end_comment
begin_function
DECL|function|pass_whole_blame
specifier|static
name|void
name|pass_whole_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|,
name|struct
name|origin
modifier|*
name|porigin
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|porigin
operator|->
name|file
operator|.
name|ptr
operator|&&
name|origin
operator|->
name|file
operator|.
name|ptr
condition|)
block|{
comment|/* Steal its file */
name|porigin
operator|->
name|file
operator|=
name|origin
operator|->
name|file
expr_stmt|;
name|origin
operator|->
name|file
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|origin
argument_list|)
condition|)
continue|continue;
name|origin_incref
argument_list|(
name|porigin
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|e
operator|->
name|suspect
operator|=
name|porigin
expr_stmt|;
block|}
block|}
end_function
begin_define
DECL|macro|MAXPARENT
define|#
directive|define
name|MAXPARENT
value|16
end_define
begin_function
DECL|function|pass_blame
specifier|static
name|void
name|pass_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|origin
operator|->
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parent
decl_stmt|;
name|struct
name|origin
modifier|*
name|parent_origin
index|[
name|MAXPARENT
index|]
decl_stmt|,
modifier|*
name|porigin
decl_stmt|;
name|memset
argument_list|(
name|parent_origin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|parent_origin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The first pass looks for unrenamed path to optimize for 	 * common cases, then we look for renames in the second pass. 	 */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
argument_list|(
operator|*
name|find
argument_list|)
argument_list|(
expr|struct
name|scoreboard
operator|*
argument_list|,
expr|struct
name|commit
operator|*
argument_list|,
expr|struct
name|origin
operator|*
argument_list|)
decl_stmt|;
name|find
operator|=
name|pass
condition|?
name|find_rename
else|:
name|find_origin
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parent
operator|=
name|commit
operator|->
name|parents
init|;
name|i
operator|<
name|MAXPARENT
operator|&&
name|parent
condition|;
name|parent
operator|=
name|parent
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parent
operator|->
name|item
decl_stmt|;
name|int
name|j
decl_stmt|,
name|same
decl_stmt|;
if|if
condition|(
name|parent_origin
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|parse_commit
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|porigin
operator|=
name|find
argument_list|(
name|sb
argument_list|,
name|p
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|porigin
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
condition|)
block|{
name|pass_whole_blame
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|porigin
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|porigin
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
for|for
control|(
name|j
operator|=
name|same
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|parent_origin
index|[
name|j
index|]
operator|&&
operator|!
name|hashcmp
argument_list|(
name|parent_origin
index|[
name|j
index|]
operator|->
name|blob_sha1
argument_list|,
name|porigin
operator|->
name|blob_sha1
argument_list|)
condition|)
block|{
name|same
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|same
condition|)
name|parent_origin
index|[
name|i
index|]
operator|=
name|porigin
expr_stmt|;
else|else
name|origin_decref
argument_list|(
name|porigin
argument_list|)
expr_stmt|;
block|}
block|}
name|num_commits
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parent
operator|=
name|commit
operator|->
name|parents
init|;
name|i
operator|<
name|MAXPARENT
operator|&&
name|parent
condition|;
name|parent
operator|=
name|parent
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|parent_origin
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|porigin
condition|)
continue|continue;
if|if
condition|(
name|pass_blame_to_parent
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|porigin
argument_list|)
condition|)
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * Optionally find moves in parents' files. 	 */
if|if
condition|(
name|opt
operator|&
name|PICKAXE_BLAME_MOVE
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parent
operator|=
name|commit
operator|->
name|parents
init|;
name|i
operator|<
name|MAXPARENT
operator|&&
name|parent
condition|;
name|parent
operator|=
name|parent
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|parent_origin
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|porigin
condition|)
continue|continue;
if|if
condition|(
name|find_move_in_parent
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|porigin
argument_list|)
condition|)
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * Optionally find copies from parents' files. 	 */
if|if
condition|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parent
operator|=
name|commit
operator|->
name|parents
init|;
name|i
operator|<
name|MAXPARENT
operator|&&
name|parent
condition|;
name|parent
operator|=
name|parent
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|parent_origin
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|find_copy_in_parent
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|parent
operator|->
name|item
argument_list|,
name|porigin
argument_list|,
name|opt
argument_list|)
condition|)
goto|goto
name|finish
goto|;
block|}
name|finish
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPARENT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parent_origin
index|[
name|i
index|]
condition|)
block|{
name|drop_origin_blob
argument_list|(
name|parent_origin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|parent_origin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|drop_origin_blob
argument_list|(
name|origin
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Information on commits, used for output.  */
end_comment
begin_struct
DECL|struct|commit_info
struct|struct
name|commit_info
block|{
DECL|member|author
specifier|const
name|char
modifier|*
name|author
decl_stmt|;
DECL|member|author_mail
specifier|const
name|char
modifier|*
name|author_mail
decl_stmt|;
DECL|member|author_time
name|unsigned
name|long
name|author_time
decl_stmt|;
DECL|member|author_tz
specifier|const
name|char
modifier|*
name|author_tz
decl_stmt|;
comment|/* filled only when asked for details */
DECL|member|committer
specifier|const
name|char
modifier|*
name|committer
decl_stmt|;
DECL|member|committer_mail
specifier|const
name|char
modifier|*
name|committer_mail
decl_stmt|;
DECL|member|committer_time
name|unsigned
name|long
name|committer_time
decl_stmt|;
DECL|member|committer_tz
specifier|const
name|char
modifier|*
name|committer_tz
decl_stmt|;
DECL|member|summary
specifier|const
name|char
modifier|*
name|summary
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Parse author/committer line in the commit object buffer  */
end_comment
begin_function
DECL|function|get_ac_line
specifier|static
name|void
name|get_ac_line
parameter_list|(
specifier|const
name|char
modifier|*
name|inbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|int
name|bufsz
parameter_list|,
name|char
modifier|*
name|person
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|mail
parameter_list|,
name|unsigned
name|long
modifier|*
name|time
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tz
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|tzlen
decl_stmt|,
name|maillen
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|endp
decl_stmt|,
modifier|*
name|timepos
decl_stmt|;
name|tmp
operator|=
name|strstr
argument_list|(
name|inbuf
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|error_out
goto|;
name|tmp
operator|+=
name|strlen
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|endp
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endp
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|endp
operator|-
name|tmp
expr_stmt|;
if|if
condition|(
name|bufsz
operator|<=
name|len
condition|)
block|{
name|error_out
label|:
comment|/* Ugh */
operator|*
name|mail
operator|=
operator|*
name|tz
operator|=
literal|"(unknown)"
expr_stmt|;
operator|*
name|time
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|person
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|person
expr_stmt|;
name|tmp
operator|+=
name|len
expr_stmt|;
operator|*
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
literal|' '
condition|)
name|tmp
operator|--
expr_stmt|;
operator|*
name|tz
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
name|tzlen
operator|=
operator|(
name|person
operator|+
name|len
operator|)
operator|-
operator|(
name|tmp
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
literal|' '
condition|)
name|tmp
operator|--
expr_stmt|;
operator|*
name|time
operator|=
name|strtoul
argument_list|(
name|tmp
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|timepos
operator|=
name|tmp
expr_stmt|;
operator|*
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
literal|' '
condition|)
name|tmp
operator|--
expr_stmt|;
operator|*
name|mail
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
operator|*
name|tmp
operator|=
literal|0
expr_stmt|;
name|maillen
operator|=
name|timepos
operator|-
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|mailmap
operator|.
name|nr
condition|)
return|return;
comment|/* 	 * mailmap expansion may make the name longer. 	 * make room by pushing stuff down. 	 */
name|tmp
operator|=
name|person
operator|+
name|bufsz
operator|-
operator|(
name|tzlen
operator|+
literal|1
operator|)
expr_stmt|;
name|memmove
argument_list|(
name|tmp
argument_list|,
operator|*
name|tz
argument_list|,
name|tzlen
argument_list|)
expr_stmt|;
name|tmp
index|[
name|tzlen
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|tz
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|-
operator|(
name|maillen
operator|+
literal|1
operator|)
expr_stmt|;
name|memmove
argument_list|(
name|tmp
argument_list|,
operator|*
name|mail
argument_list|,
name|maillen
argument_list|)
expr_stmt|;
name|tmp
index|[
name|maillen
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|mail
operator|=
name|tmp
expr_stmt|;
comment|/* 	 * Now, convert e-mail using mailmap 	 */
name|map_email
argument_list|(
operator|&
name|mailmap
argument_list|,
name|tmp
operator|+
literal|1
argument_list|,
name|person
argument_list|,
name|tmp
operator|-
name|person
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_commit_info
specifier|static
name|void
name|get_commit_info
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_info
modifier|*
name|ret
parameter_list|,
name|int
name|detailed
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
specifier|static
name|char
name|author_buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
name|committer_buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
name|summary_buf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* 	 * We've operated without save_commit_buffer, so 	 * we now need to populate them for output. 	 */
if|if
condition|(
operator|!
name|commit
operator|->
name|buffer
condition|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|commit
operator|->
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|buffer
condition|)
name|die
argument_list|(
literal|"Cannot read commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|->
name|author
operator|=
name|author_buf
expr_stmt|;
name|get_ac_line
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
literal|"\nauthor "
argument_list|,
sizeof|sizeof
argument_list|(
name|author_buf
argument_list|)
argument_list|,
name|author_buf
argument_list|,
operator|&
name|ret
operator|->
name|author_mail
argument_list|,
operator|&
name|ret
operator|->
name|author_time
argument_list|,
operator|&
name|ret
operator|->
name|author_tz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|detailed
condition|)
return|return;
name|ret
operator|->
name|committer
operator|=
name|committer_buf
expr_stmt|;
name|get_ac_line
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
literal|"\ncommitter "
argument_list|,
sizeof|sizeof
argument_list|(
name|committer_buf
argument_list|)
argument_list|,
name|committer_buf
argument_list|,
operator|&
name|ret
operator|->
name|committer_mail
argument_list|,
operator|&
name|ret
operator|->
name|committer_time
argument_list|,
operator|&
name|ret
operator|->
name|committer_tz
argument_list|)
expr_stmt|;
name|ret
operator|->
name|summary
operator|=
name|summary_buf
expr_stmt|;
name|tmp
operator|=
name|strstr
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|error_out
label|:
name|sprintf
argument_list|(
name|summary_buf
argument_list|,
literal|"(%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|+=
literal|2
expr_stmt|;
name|endp
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endp
condition|)
name|endp
operator|=
name|tmp
operator|+
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|len
operator|=
name|endp
operator|-
name|tmp
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|summary_buf
argument_list|)
operator|||
name|len
operator|==
literal|0
condition|)
goto|goto
name|error_out
goto|;
name|memcpy
argument_list|(
name|summary_buf
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|summary_buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * To allow LF and other nonportable characters in pathnames,  * they are c-style quoted as needed.  */
end_comment
begin_function
DECL|function|write_filename_info
specifier|static
name|void
name|write_filename_info
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|printf
argument_list|(
literal|"filename "
argument_list|)
expr_stmt|;
name|write_name_quoted
argument_list|(
name|path
argument_list|,
name|stdout
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * The blame_entry is found to be guilty for the range.  Mark it  * as such, and show it in incremental output.  */
end_comment
begin_function
DECL|function|found_guilty_entry
specifier|static
name|void
name|found_guilty_entry
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|guilty
condition|)
return|return;
name|ent
operator|->
name|guilty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
block|{
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|printf
argument_list|(
literal|"%s %d %d %d\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|ent
operator|->
name|s_lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|METAINFO_SHOWN
operator|)
condition|)
block|{
name|struct
name|commit_info
name|ci
decl_stmt|;
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|METAINFO_SHOWN
expr_stmt|;
name|get_commit_info
argument_list|(
name|suspect
operator|->
name|commit
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author %s\n"
argument_list|,
name|ci
operator|.
name|author
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-mail %s\n"
argument_list|,
name|ci
operator|.
name|author_mail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-time %lu\n"
argument_list|,
name|ci
operator|.
name|author_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-tz %s\n"
argument_list|,
name|ci
operator|.
name|author_tz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer %s\n"
argument_list|,
name|ci
operator|.
name|committer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-mail %s\n"
argument_list|,
name|ci
operator|.
name|committer_mail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-time %lu\n"
argument_list|,
name|ci
operator|.
name|committer_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-tz %s\n"
argument_list|,
name|ci
operator|.
name|committer_tz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"summary %s\n"
argument_list|,
name|ci
operator|.
name|summary
argument_list|)
expr_stmt|;
if|if
condition|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
name|printf
argument_list|(
literal|"boundary\n"
argument_list|)
expr_stmt|;
block|}
name|write_filename_info
argument_list|(
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
name|maybe_flush_or_die
argument_list|(
name|stdout
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * The main loop -- while the scoreboard has lines whose true origin  * is still unknown, pick one blame_entry, and allow its current  * suspect to pass blames to its parents.  */
end_comment
begin_function
DECL|function|assign_blame
specifier|static
name|void
name|assign_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|NULL
decl_stmt|;
comment|/* find one suspect to break down */
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
operator|!
name|suspect
operator|&&
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|guilty
condition|)
name|suspect
operator|=
name|ent
operator|->
name|suspect
expr_stmt|;
if|if
condition|(
operator|!
name|suspect
condition|)
return|return;
comment|/* all done */
comment|/* 		 * We will use this suspect later in the loop, 		 * so hold onto it in the meantime. 		 */
name|origin_incref
argument_list|(
name|suspect
argument_list|)
expr_stmt|;
name|commit
operator|=
name|suspect
operator|->
name|commit
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
operator|&&
operator|!
operator|(
name|revs
operator|->
name|max_age
operator|!=
operator|-
literal|1
operator|&&
name|commit
operator|->
name|date
operator|<
name|revs
operator|->
name|max_age
operator|)
condition|)
name|pass_blame
argument_list|(
name|sb
argument_list|,
name|suspect
argument_list|,
name|opt
argument_list|)
expr_stmt|;
else|else
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|mark_parents_uninteresting
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
comment|/* treat root commit as boundary */
if|if
condition|(
operator|!
name|commit
operator|->
name|parents
operator|&&
operator|!
name|show_root
condition|)
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
comment|/* Take responsibility for the remaining entries */
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|same_suspect
argument_list|(
name|ent
operator|->
name|suspect
argument_list|,
name|suspect
argument_list|)
condition|)
name|found_guilty_entry
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|suspect
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
comment|/* sanity */
name|sanity_check_refcnt
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|format_time
specifier|static
specifier|const
name|char
modifier|*
name|format_time
parameter_list|(
name|unsigned
name|long
name|time
parameter_list|,
specifier|const
name|char
modifier|*
name|tz_str
parameter_list|,
name|int
name|show_raw_time
parameter_list|)
block|{
specifier|static
name|char
name|time_buf
index|[
literal|128
index|]
decl_stmt|;
name|time_t
name|t
init|=
name|time
decl_stmt|;
name|int
name|minutes
decl_stmt|,
name|tz
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
if|if
condition|(
name|show_raw_time
condition|)
block|{
name|sprintf
argument_list|(
name|time_buf
argument_list|,
literal|"%lu %s"
argument_list|,
name|time
argument_list|,
name|tz_str
argument_list|)
expr_stmt|;
return|return
name|time_buf
return|;
block|}
name|tz
operator|=
name|atoi
argument_list|(
name|tz_str
argument_list|)
expr_stmt|;
name|minutes
operator|=
name|tz
operator|<
literal|0
condition|?
operator|-
name|tz
else|:
name|tz
expr_stmt|;
name|minutes
operator|=
operator|(
name|minutes
operator|/
literal|100
operator|)
operator|*
literal|60
operator|+
operator|(
name|minutes
operator|%
literal|100
operator|)
expr_stmt|;
name|minutes
operator|=
name|tz
operator|<
literal|0
condition|?
operator|-
name|minutes
else|:
name|minutes
expr_stmt|;
name|t
operator|=
name|time
operator|+
name|minutes
operator|*
literal|60
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|time_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|time_buf
argument_list|)
argument_list|,
literal|"%Y-%m-%d %H:%M:%S "
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|time_buf
argument_list|,
name|tz_str
argument_list|)
expr_stmt|;
return|return
name|time_buf
return|;
block|}
end_function
begin_define
DECL|macro|OUTPUT_ANNOTATE_COMPAT
define|#
directive|define
name|OUTPUT_ANNOTATE_COMPAT
value|001
end_define
begin_define
DECL|macro|OUTPUT_LONG_OBJECT_NAME
define|#
directive|define
name|OUTPUT_LONG_OBJECT_NAME
value|002
end_define
begin_define
DECL|macro|OUTPUT_RAW_TIMESTAMP
define|#
directive|define
name|OUTPUT_RAW_TIMESTAMP
value|004
end_define
begin_define
DECL|macro|OUTPUT_PORCELAIN
define|#
directive|define
name|OUTPUT_PORCELAIN
value|010
end_define
begin_define
DECL|macro|OUTPUT_SHOW_NAME
define|#
directive|define
name|OUTPUT_SHOW_NAME
value|020
end_define
begin_define
DECL|macro|OUTPUT_SHOW_NUMBER
define|#
directive|define
name|OUTPUT_SHOW_NUMBER
value|040
end_define
begin_define
DECL|macro|OUTPUT_SHOW_SCORE
define|#
directive|define
name|OUTPUT_SHOW_SCORE
value|0100
end_define
begin_define
DECL|macro|OUTPUT_NO_AUTHOR
define|#
directive|define
name|OUTPUT_NO_AUTHOR
value|0200
end_define
begin_function
DECL|function|emit_porcelain
specifier|static
name|void
name|emit_porcelain
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|char
name|hex
index|[
literal|41
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%c%d %d %d\n"
argument_list|,
name|hex
argument_list|,
name|ent
operator|->
name|guilty
condition|?
literal|' '
else|:
literal|'*'
argument_list|,
comment|// purely for debugging
name|ent
operator|->
name|s_lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|METAINFO_SHOWN
operator|)
condition|)
block|{
name|struct
name|commit_info
name|ci
decl_stmt|;
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|METAINFO_SHOWN
expr_stmt|;
name|get_commit_info
argument_list|(
name|suspect
operator|->
name|commit
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author %s\n"
argument_list|,
name|ci
operator|.
name|author
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-mail %s\n"
argument_list|,
name|ci
operator|.
name|author_mail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-time %lu\n"
argument_list|,
name|ci
operator|.
name|author_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-tz %s\n"
argument_list|,
name|ci
operator|.
name|author_tz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer %s\n"
argument_list|,
name|ci
operator|.
name|committer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-mail %s\n"
argument_list|,
name|ci
operator|.
name|committer_mail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-time %lu\n"
argument_list|,
name|ci
operator|.
name|committer_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-tz %s\n"
argument_list|,
name|ci
operator|.
name|committer_tz
argument_list|)
expr_stmt|;
name|write_filename_info
argument_list|(
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"summary %s\n"
argument_list|,
name|ci
operator|.
name|summary
argument_list|)
expr_stmt|;
if|if
condition|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
name|printf
argument_list|(
literal|"boundary\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|MORE_THAN_ONE_PATH
condition|)
name|write_filename_info
argument_list|(
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|ent
operator|->
name|lno
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ent
operator|->
name|num_lines
condition|;
name|cnt
operator|++
control|)
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|cnt
condition|)
name|printf
argument_list|(
literal|"%s %d %d\n"
argument_list|,
name|hex
argument_list|,
name|ent
operator|->
name|s_lno
operator|+
literal|1
operator|+
name|cnt
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
do|do
block|{
name|ch
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|cp
operator|<
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|final_buf_size
condition|)
do|;
block|}
block|}
end_function
begin_function
DECL|function|emit_other
specifier|static
name|void
name|emit_other
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|struct
name|commit_info
name|ci
decl_stmt|;
name|char
name|hex
index|[
literal|41
index|]
decl_stmt|;
name|int
name|show_raw_time
init|=
operator|!
operator|!
operator|(
name|opt
operator|&
name|OUTPUT_RAW_TIMESTAMP
operator|)
decl_stmt|;
name|get_commit_info
argument_list|(
name|suspect
operator|->
name|commit
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|ent
operator|->
name|lno
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ent
operator|->
name|num_lines
condition|;
name|cnt
operator|++
control|)
block|{
name|char
name|ch
decl_stmt|;
name|int
name|length
init|=
operator|(
name|opt
operator|&
name|OUTPUT_LONG_OBJECT_NAME
operator|)
condition|?
literal|40
else|:
literal|8
decl_stmt|;
if|if
condition|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
block|{
if|if
condition|(
name|blank_boundary
condition|)
name|memset
argument_list|(
name|hex
argument_list|,
literal|' '
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cmd_is_annotate
condition|)
block|{
name|length
operator|--
expr_stmt|;
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%.*s"
argument_list|,
name|length
argument_list|,
name|hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_ANNOTATE_COMPAT
condition|)
name|printf
argument_list|(
literal|"\t(%10s\t%10s\t%d)"
argument_list|,
name|ci
operator|.
name|author
argument_list|,
name|format_time
argument_list|(
name|ci
operator|.
name|author_time
argument_list|,
name|ci
operator|.
name|author_tz
argument_list|,
name|show_raw_time
argument_list|)
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_SCORE
condition|)
name|printf
argument_list|(
literal|" %*d %02d"
argument_list|,
name|max_score_digits
argument_list|,
name|ent
operator|->
name|score
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_NAME
condition|)
name|printf
argument_list|(
literal|" %-*.*s"
argument_list|,
name|longest_file
argument_list|,
name|longest_file
argument_list|,
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_NUMBER
condition|)
name|printf
argument_list|(
literal|" %*d"
argument_list|,
name|max_orig_digits
argument_list|,
name|ent
operator|->
name|s_lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opt
operator|&
name|OUTPUT_NO_AUTHOR
operator|)
condition|)
name|printf
argument_list|(
literal|" (%-*.*s %10s"
argument_list|,
name|longest_author
argument_list|,
name|longest_author
argument_list|,
name|ci
operator|.
name|author
argument_list|,
name|format_time
argument_list|(
name|ci
operator|.
name|author_time
argument_list|,
name|ci
operator|.
name|author_tz
argument_list|,
name|show_raw_time
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %*d) "
argument_list|,
name|max_digits
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|ch
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|cp
operator|<
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|final_buf_size
condition|)
do|;
block|}
block|}
end_function
begin_function
DECL|function|output
specifier|static
name|void
name|output
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
name|option
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|option
operator|&
name|OUTPUT_PORCELAIN
condition|)
block|{
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
name|struct
name|blame_entry
modifier|*
name|oth
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|suspect
operator|->
name|commit
decl_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|MORE_THAN_ONE_PATH
condition|)
continue|continue;
for|for
control|(
name|oth
operator|=
name|ent
operator|->
name|next
init|;
name|oth
condition|;
name|oth
operator|=
name|oth
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|oth
operator|->
name|suspect
operator|->
name|commit
operator|!=
name|commit
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|oth
operator|->
name|suspect
operator|->
name|path
argument_list|,
name|suspect
operator|->
name|path
argument_list|)
condition|)
continue|continue;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|MORE_THAN_ONE_PATH
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|option
operator|&
name|OUTPUT_PORCELAIN
condition|)
name|emit_porcelain
argument_list|(
name|sb
argument_list|,
name|ent
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_other
argument_list|(
name|sb
argument_list|,
name|ent
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * To allow quick access to the contents of nth line in the  * final image, prepare an index in the scoreboard.  */
end_comment
begin_function
DECL|function|prepare_lines
specifier|static
name|int
name|prepare_lines
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buf
init|=
name|sb
operator|->
name|final_buf
decl_stmt|;
name|unsigned
name|long
name|len
init|=
name|sb
operator|->
name|final_buf_size
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|incomplete
init|=
literal|0
decl_stmt|,
name|bol
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|incomplete
operator|++
expr_stmt|;
comment|/* incomplete line at the end */
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|bol
condition|)
block|{
name|sb
operator|->
name|lineno
operator|=
name|xrealloc
argument_list|(
name|sb
operator|->
name|lineno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
operator|(
name|num
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|lineno
index|[
name|num
index|]
operator|=
name|buf
operator|-
name|sb
operator|->
name|final_buf
expr_stmt|;
name|bol
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf
operator|++
operator|==
literal|'\n'
condition|)
block|{
name|num
operator|++
expr_stmt|;
name|bol
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sb
operator|->
name|lineno
operator|=
name|xrealloc
argument_list|(
name|sb
operator|->
name|lineno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
operator|(
name|num
operator|+
name|incomplete
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|lineno
index|[
name|num
operator|+
name|incomplete
index|]
operator|=
name|buf
operator|-
name|sb
operator|->
name|final_buf
expr_stmt|;
name|sb
operator|->
name|num_lines
operator|=
name|num
operator|+
name|incomplete
expr_stmt|;
return|return
name|sb
operator|->
name|num_lines
return|;
block|}
end_function
begin_comment
comment|/*  * Add phony grafts for use with -S; this is primarily to  * support git-cvsserver that wants to give a linear history  * to its clients.  */
end_comment
begin_function
DECL|function|read_ancestry
specifier|static
name|int
name|read_ancestry
parameter_list|(
specifier|const
name|char
modifier|*
name|graft_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|graft_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|read_graft_line
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|graft
condition|)
name|register_commit_graft
argument_list|(
name|graft
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * How many columns do we need to show line numbers in decimal?  */
end_comment
begin_function
DECL|function|lineno_width
specifier|static
name|int
name|lineno_width
parameter_list|(
name|int
name|lines
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|width
decl_stmt|;
for|for
control|(
name|width
operator|=
literal|1
operator|,
name|i
operator|=
literal|10
init|;
name|i
operator|<=
name|lines
operator|+
literal|1
condition|;
name|width
operator|++
control|)
name|i
operator|*=
literal|10
expr_stmt|;
return|return
name|width
return|;
block|}
end_function
begin_comment
comment|/*  * How many columns do we need to show line numbers, authors,  * and filenames?  */
end_comment
begin_function
DECL|function|find_alignment
specifier|static
name|void
name|find_alignment
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
modifier|*
name|option
parameter_list|)
block|{
name|int
name|longest_src_lines
init|=
literal|0
decl_stmt|;
name|int
name|longest_dst_lines
init|=
literal|0
decl_stmt|;
name|unsigned
name|largest_score
init|=
literal|0
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|struct
name|origin
modifier|*
name|suspect
init|=
name|e
operator|->
name|suspect
decl_stmt|;
name|struct
name|commit_info
name|ci
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|suspect
operator|->
name|path
argument_list|,
name|sb
operator|->
name|path
argument_list|)
condition|)
operator|*
name|option
operator||=
name|OUTPUT_SHOW_NAME
expr_stmt|;
name|num
operator|=
name|strlen
argument_list|(
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_file
operator|<
name|num
condition|)
name|longest_file
operator|=
name|num
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|METAINFO_SHOWN
operator|)
condition|)
block|{
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|METAINFO_SHOWN
expr_stmt|;
name|get_commit_info
argument_list|(
name|suspect
operator|->
name|commit
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|num
operator|=
name|strlen
argument_list|(
name|ci
operator|.
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_author
operator|<
name|num
condition|)
name|longest_author
operator|=
name|num
expr_stmt|;
block|}
name|num
operator|=
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
if|if
condition|(
name|longest_src_lines
operator|<
name|num
condition|)
name|longest_src_lines
operator|=
name|num
expr_stmt|;
name|num
operator|=
name|e
operator|->
name|lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
if|if
condition|(
name|longest_dst_lines
operator|<
name|num
condition|)
name|longest_dst_lines
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|largest_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
name|e
argument_list|)
condition|)
name|largest_score
operator|=
name|ent_score
argument_list|(
name|sb
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|max_orig_digits
operator|=
name|lineno_width
argument_list|(
name|longest_src_lines
argument_list|)
expr_stmt|;
name|max_digits
operator|=
name|lineno_width
argument_list|(
name|longest_dst_lines
argument_list|)
expr_stmt|;
name|max_score_digits
operator|=
name|lineno_width
argument_list|(
name|largest_score
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * For debugging -- origin is refcounted, and this asserts that  * we do not underflow.  */
end_comment
begin_function
DECL|function|sanity_check_refcnt
specifier|static
name|void
name|sanity_check_refcnt
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|baa
init|=
literal|0
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
comment|/* Nobody should have zero or negative refcnt */
if|if
condition|(
name|ent
operator|->
name|suspect
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s in %s has negative refcnt %d\n"
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|path
argument_list|,
name|sha1_to_hex
argument_list|(
name|ent
operator|->
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|refcnt
argument_list|)
expr_stmt|;
name|baa
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
comment|/* Mark the ones that haven't been checked */
if|if
condition|(
literal|0
operator|<
name|ent
operator|->
name|suspect
operator|->
name|refcnt
condition|)
name|ent
operator|->
name|suspect
operator|->
name|refcnt
operator|=
operator|-
name|ent
operator|->
name|suspect
operator|->
name|refcnt
expr_stmt|;
block|}
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
comment|/* 		 * ... then pick each and see if they have the the 		 * correct refcnt. 		 */
name|int
name|found
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|suspect
operator|->
name|refcnt
condition|)
continue|continue;
name|suspect
operator|->
name|refcnt
operator|=
operator|-
name|suspect
operator|->
name|refcnt
expr_stmt|;
comment|/* Unmark */
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|suspect
operator|!=
name|suspect
condition|)
continue|continue;
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|suspect
operator|->
name|refcnt
operator|!=
name|found
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s in %s has refcnt %d, not %d\n"
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|path
argument_list|,
name|sha1_to_hex
argument_list|(
name|ent
operator|->
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|refcnt
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|baa
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baa
condition|)
block|{
name|int
name|opt
init|=
literal|0160
decl_stmt|;
name|find_alignment
argument_list|(
name|sb
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|sb
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"Baa %d!"
argument_list|,
name|baa
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Used for the command line parsing; check if the path exists  * in the working tree.  */
end_comment
begin_function
DECL|function|has_path_in_work_tree
specifier|static
name|int
name|has_path_in_work_tree
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
return|return
operator|!
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_score
specifier|static
name|unsigned
name|parse_score
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|score
init|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
return|return
literal|0
return|;
return|return
name|score
return|;
block|}
end_function
begin_function
DECL|function|add_prefix
specifier|static
specifier|const
name|char
modifier|*
name|add_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefix
operator|||
operator|!
name|prefix
index|[
literal|0
index|]
condition|)
return|return
name|path
return|;
return|return
name|prefix_path
argument_list|(
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Parsing of (comma separated) one item in the -L option  */
end_comment
begin_function
DECL|function|parse_loc
specifier|static
specifier|const
name|char
modifier|*
name|parse_loc
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|long
name|lno
parameter_list|,
name|long
name|begin
parameter_list|,
name|long
modifier|*
name|ret
parameter_list|)
block|{
name|char
modifier|*
name|term
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|long
name|num
decl_stmt|;
name|int
name|reg_error
decl_stmt|;
name|regex_t
name|regexp
decl_stmt|;
name|regmatch_t
name|match
index|[
literal|1
index|]
decl_stmt|;
comment|/* Allow "-L<something>,+20" to mean starting at<something> 	 * for 20 lines, or "-L<something>,-5" for 5 lines ending at 	 *<something>. 	 */
if|if
condition|(
literal|1
operator|<
name|begin
operator|&&
operator|(
name|spec
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|spec
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
name|num
operator|=
name|strtol
argument_list|(
name|spec
operator|+
literal|1
argument_list|,
operator|&
name|term
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|!=
name|spec
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|spec
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|num
operator|=
literal|0
operator|-
name|num
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|num
condition|)
operator|*
name|ret
operator|=
name|begin
operator|+
name|num
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num
condition|)
operator|*
name|ret
operator|=
name|begin
expr_stmt|;
else|else
operator|*
name|ret
operator|=
name|begin
operator|+
name|num
expr_stmt|;
return|return
name|term
return|;
block|}
return|return
name|spec
return|;
block|}
name|num
operator|=
name|strtol
argument_list|(
name|spec
argument_list|,
operator|&
name|term
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|!=
name|spec
condition|)
block|{
operator|*
name|ret
operator|=
name|num
expr_stmt|;
return|return
name|term
return|;
block|}
if|if
condition|(
name|spec
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return
name|spec
return|;
comment|/* it could be a regexp of form /.../ */
for|for
control|(
name|term
operator|=
operator|(
name|char
operator|*
operator|)
name|spec
operator|+
literal|1
init|;
operator|*
name|term
operator|&&
operator|*
name|term
operator|!=
literal|'/'
condition|;
name|term
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|term
operator|==
literal|'\\'
condition|)
name|term
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|term
operator|!=
literal|'/'
condition|)
return|return
name|spec
return|;
comment|/* try [spec+1 .. term-1] as regexp */
operator|*
name|term
operator|=
literal|0
expr_stmt|;
name|begin
operator|--
expr_stmt|;
comment|/* input is in human terms */
name|line
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg_error
operator|=
name|regcomp
argument_list|(
operator|&
name|regexp
argument_list|,
name|spec
operator|+
literal|1
argument_list|,
name|REG_NEWLINE
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|reg_error
operator|=
name|regexec
argument_list|(
operator|&
name|regexp
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
name|match
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
name|line
operator|+
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
decl_stmt|;
specifier|const
name|char
modifier|*
name|nline
decl_stmt|;
while|while
condition|(
name|begin
operator|++
operator|<
name|lno
condition|)
block|{
name|nline
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<=
name|cp
operator|&&
name|cp
operator|<
name|nline
condition|)
break|break;
name|line
operator|=
name|nline
expr_stmt|;
block|}
operator|*
name|ret
operator|=
name|begin
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|regexp
argument_list|)
expr_stmt|;
operator|*
name|term
operator|++
operator|=
literal|'/'
expr_stmt|;
return|return
name|term
return|;
block|}
else|else
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|regerror
argument_list|(
name|reg_error
argument_list|,
operator|&
name|regexp
argument_list|,
name|errbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"-L parameter '%s': %s"
argument_list|,
name|spec
operator|+
literal|1
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Parsing of -L option  */
end_comment
begin_function
DECL|function|prepare_blame_range
specifier|static
name|void
name|prepare_blame_range
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|bottomtop
parameter_list|,
name|long
name|lno
parameter_list|,
name|long
modifier|*
name|bottom
parameter_list|,
name|long
modifier|*
name|top
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|term
decl_stmt|;
name|term
operator|=
name|parse_loc
argument_list|(
name|bottomtop
argument_list|,
name|sb
argument_list|,
name|lno
argument_list|,
literal|1
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|term
operator|==
literal|','
condition|)
block|{
name|term
operator|=
name|parse_loc
argument_list|(
name|term
operator|+
literal|1
argument_list|,
name|sb
argument_list|,
name|lno
argument_list|,
operator|*
name|bottom
operator|+
literal|1
argument_list|,
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|term
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|term
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_blame_config
specifier|static
name|int
name|git_blame_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"blame.showroot"
argument_list|)
condition|)
block|{
name|show_root
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"blame.blankboundary"
argument_list|)
condition|)
block|{
name|blank_boundary
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fake_working_tree_commit
specifier|static
name|struct
name|commit
modifier|*
name|fake_working_tree_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|contents_from
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|origin
modifier|*
name|origin
decl_stmt|;
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|ident
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|int
name|size
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|unsigned
name|mode
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"No such ref: HEAD"
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|commit
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|->
name|parents
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit
operator|->
name|parents
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|->
name|parents
operator|->
name|item
operator|=
name|lookup_commit_reference
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|commit
operator|->
name|date
operator|=
name|now
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|type
operator|=
name|OBJ_COMMIT
expr_stmt|;
name|origin
operator|=
name|make_origin
argument_list|(
name|commit
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents_from
operator|||
name|strcmp
argument_list|(
literal|"-"
argument_list|,
name|contents_from
argument_list|)
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|read_from
decl_stmt|;
name|unsigned
name|long
name|fin_size
decl_stmt|;
if|if
condition|(
name|contents_from
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|contents_from
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Cannot stat %s"
argument_list|,
name|contents_from
argument_list|)
expr_stmt|;
name|read_from
operator|=
name|contents_from
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Cannot lstat %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|read_from
operator|=
name|path
expr_stmt|;
block|}
name|fin_size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|mode
operator|=
name|canon_mode
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|buf
argument_list|,
name|read_from
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|!=
name|st
operator|.
name|st_size
condition|)
name|die
argument_list|(
literal|"cannot open or read %s"
argument_list|,
name|read_from
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
if|if
condition|(
name|readlink
argument_list|(
name|read_from
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|alloc
argument_list|)
operator|!=
name|fin_size
condition|)
name|die
argument_list|(
literal|"cannot readlink %s"
argument_list|,
name|read_from
argument_list|)
expr_stmt|;
name|buf
operator|.
name|len
operator|=
name|fin_size
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"unsupported file type %s"
argument_list|,
name|read_from
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Reading from stdin */
name|contents_from
operator|=
literal|"standard input"
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"read error %s from stdin"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|convert_to_git
argument_list|(
name|path
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|,
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|origin
operator|->
name|file
operator|.
name|ptr
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
name|origin
operator|->
name|file
operator|.
name|size
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|pretend_sha1_file
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|,
name|OBJ_BLOB
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|commit
operator|->
name|util
operator|=
name|origin
expr_stmt|;
comment|/* 	 * Read the current index, replace the path entry with 	 * origin->blob_sha1 without mucking with its mode or type 	 * bits; we are not going to write this index out -- we just 	 * want to run "diff-index --cached". 	 */
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
block|{
name|int
name|pos
init|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pos
condition|)
name|mode
operator|=
name|ntohl
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|ce_mode
argument_list|)
expr_stmt|;
else|else
comment|/* Let's not bother reading from HEAD tree */
name|mode
operator|=
name|S_IFREG
operator||
literal|0644
expr_stmt|;
block|}
name|size
operator|=
name|cache_entry_size
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ce
operator|->
name|sha1
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_OK_TO_REPLACE
argument_list|)
expr_stmt|;
comment|/* 	 * We are not going to write this out, so this does not matter 	 * right now, but someday we might optimize diff-index --cached 	 * with cache-tree information. 	 */
name|cache_tree_invalidate_path
argument_list|(
name|active_cache_tree
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|commit
operator|->
name|buffer
operator|=
name|xmalloc
argument_list|(
literal|400
argument_list|)
expr_stmt|;
name|ident
operator|=
name|fmt_ident
argument_list|(
literal|"Not Committed Yet"
argument_list|,
literal|"not.committed.yet"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
literal|400
argument_list|,
literal|"tree 0000000000000000000000000000000000000000\n"
literal|"parent %s\n"
literal|"author %s\n"
literal|"committer %s\n\n"
literal|"Version of %s from %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head_sha1
argument_list|)
argument_list|,
name|ident
argument_list|,
name|ident
argument_list|,
name|path
argument_list|,
name|contents_from
condition|?
name|contents_from
else|:
name|path
argument_list|)
expr_stmt|;
return|return
name|commit
return|;
block|}
end_function
begin_function
DECL|function|cmd_blame
name|int
name|cmd_blame
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|scoreboard
name|sb
decl_stmt|;
name|struct
name|origin
modifier|*
name|o
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|seen_dashdash
decl_stmt|,
name|unk
decl_stmt|,
name|opt
decl_stmt|;
name|long
name|bottom
decl_stmt|,
name|top
decl_stmt|,
name|lno
decl_stmt|;
name|int
name|output_option
init|=
literal|0
decl_stmt|;
name|int
name|show_stats
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|revs_file
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_commit_name
init|=
name|NULL
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|bottomtop
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|contents_from
init|=
name|NULL
decl_stmt|;
name|cmd_is_annotate
operator|=
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"annotate"
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_blame_config
argument_list|)
expr_stmt|;
name|save_commit_buffer
operator|=
literal|0
expr_stmt|;
name|opt
operator|=
literal|0
expr_stmt|;
name|seen_dashdash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unk
operator|=
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-b"
argument_list|,
name|arg
argument_list|)
condition|)
name|blank_boundary
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--root"
argument_list|,
name|arg
argument_list|)
condition|)
name|show_root
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--show-stats"
argument_list|)
condition|)
name|show_stats
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-c"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_ANNOTATE_COMPAT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-t"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_RAW_TIMESTAMP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-l"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_LONG_OBJECT_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-s"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_NO_AUTHOR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-w"
argument_list|,
name|arg
argument_list|)
condition|)
name|xdl_opts
operator||=
name|XDF_IGNORE_WHITESPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-S"
argument_list|,
name|arg
argument_list|)
operator|&&
operator|++
name|i
operator|<
name|argc
condition|)
name|revs_file
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"-M"
argument_list|)
condition|)
block|{
name|opt
operator||=
name|PICKAXE_BLAME_MOVE
expr_stmt|;
name|blame_move_score
operator|=
name|parse_score
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"-C"
argument_list|)
condition|)
block|{
comment|/* 			 * -C enables copy from removed files; 			 * -C -C enables copy from existing files, but only 			 *       when blaming a new file; 			 * -C -C -C enables copy from existing files for 			 *          everybody 			 */
if|if
condition|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY_HARDER
condition|)
name|opt
operator||=
name|PICKAXE_BLAME_COPY_HARDEST
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY
condition|)
name|opt
operator||=
name|PICKAXE_BLAME_COPY_HARDER
expr_stmt|;
name|opt
operator||=
name|PICKAXE_BLAME_COPY
operator||
name|PICKAXE_BLAME_MOVE
expr_stmt|;
name|blame_copy_score
operator|=
name|parse_score
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|arg
argument_list|,
literal|"-L"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|arg
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
name|arg
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|arg
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|bottomtop
condition|)
name|die
argument_list|(
literal|"More than one '-L n,m' option given"
argument_list|)
expr_stmt|;
name|bottomtop
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--contents"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
name|contents_from
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--incremental"
argument_list|,
name|arg
argument_list|)
condition|)
name|incremental
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--score-debug"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_SHOW_SCORE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-f"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"--show-name"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_SHOW_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-n"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"--show-number"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_SHOW_NUMBER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-p"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"--porcelain"
argument_list|,
name|arg
argument_list|)
condition|)
name|output_option
operator||=
name|OUTPUT_PORCELAIN
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"--"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|seen_dashdash
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|argv
index|[
name|unk
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|blame_move_score
condition|)
name|blame_move_score
operator|=
name|BLAME_DEFAULT_MOVE_SCORE
expr_stmt|;
if|if
condition|(
operator|!
name|blame_copy_score
condition|)
name|blame_copy_score
operator|=
name|BLAME_DEFAULT_COPY_SCORE
expr_stmt|;
comment|/* 	 * We have collected options unknown to us in argv[1..unk] 	 * which are to be passed to revision machinery if we are 	 * going to do the "bottom" processing. 	 * 	 * The remaining are: 	 * 	 * (1) if seen_dashdash, its either 	 *     "-options --<path>" or 	 *     "-options --<path><rev>". 	 *     but the latter is allowed only if there is no 	 *     options that we passed to revision machinery. 	 * 	 * (2) otherwise, we may have "--" somewhere later and 	 *     might be looking at the first one of multiple 'rev' 	 *     parameters (e.g. " master ^next ^maint -- path"). 	 *     See if there is a dashdash first, and give the 	 *     arguments before that to revision machinery. 	 *     After that there must be one 'path'. 	 * 	 * (3) otherwise, its one of the three: 	 *     "-options<path><rev>" 	 *     "-options<rev><path>" 	 *     "-options<path>" 	 *     but again the first one is allowed only if 	 *     there is no options that we passed to revision 	 *     machinery. 	 */
if|if
condition|(
name|seen_dashdash
condition|)
block|{
comment|/* (1) */
if|if
condition|(
name|argc
operator|<=
name|i
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
name|path
operator|=
name|add_prefix
argument_list|(
name|prefix
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|unk
operator|!=
literal|1
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
name|argv
index|[
name|unk
operator|++
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|argc
condition|)
comment|/* garbage at end */
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
operator|!
name|seen_dashdash
operator|&&
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|j
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
name|seen_dashdash
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|seen_dashdash
condition|)
block|{
comment|/* (2) */
if|if
condition|(
name|seen_dashdash
operator|+
literal|1
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
name|path
operator|=
name|add_prefix
argument_list|(
name|prefix
argument_list|,
name|argv
index|[
name|seen_dashdash
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|seen_dashdash
condition|;
name|j
operator|++
control|)
name|argv
index|[
name|unk
operator|++
index|]
operator|=
name|argv
index|[
name|j
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* (3) */
if|if
condition|(
name|argc
operator|<=
name|i
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
name|path
operator|=
name|add_prefix
argument_list|(
name|prefix
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
operator|-
literal|1
condition|)
block|{
name|final_commit_name
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* if (unk == 1) we could be getting 				 * old-style 				 */
if|if
condition|(
name|unk
operator|==
literal|1
operator|&&
operator|!
name|has_path_in_work_tree
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|path
operator|=
name|add_prefix
argument_list|(
name|prefix
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|final_commit_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
comment|/* garbage at end */
name|setup_work_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|has_path_in_work_tree
argument_list|(
name|path
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot stat path %s: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|final_commit_name
condition|)
name|argv
index|[
name|unk
operator|++
index|]
operator|=
name|final_commit_name
expr_stmt|;
comment|/* 	 * Now we got rev and path.  We do not want the path pruning 	 * but we may want "bottom" processing. 	 */
name|argv
index|[
name|unk
operator|++
index|]
operator|=
literal|"--"
expr_stmt|;
comment|/* terminate the rev name */
name|argv
index|[
name|unk
index|]
operator|=
name|NULL
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
name|unk
argument_list|,
name|argv
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * There must be one and only one positive commit in the 	 * revs->pending array. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revs
operator|.
name|pending
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|revs
operator|.
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
name|UNINTERESTING
condition|)
continue|continue;
while|while
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
name|obj
operator|=
name|deref_tag
argument_list|(
name|obj
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Non commit %s?"
argument_list|,
name|revs
operator|.
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|final
condition|)
name|die
argument_list|(
literal|"More than one commit to dig from %s and %s?"
argument_list|,
name|revs
operator|.
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|final_commit_name
argument_list|)
expr_stmt|;
name|sb
operator|.
name|final
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
expr_stmt|;
name|final_commit_name
operator|=
name|revs
operator|.
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sb
operator|.
name|final
condition|)
block|{
comment|/* 		 * "--not A B -- path" without anything positive; 		 * do not default to HEAD, but use the working tree 		 * or "--contents". 		 */
name|setup_work_tree
argument_list|()
expr_stmt|;
name|sb
operator|.
name|final
operator|=
name|fake_working_tree_commit
argument_list|(
name|path
argument_list|,
name|contents_from
argument_list|)
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
operator|&
operator|(
name|sb
operator|.
name|final
operator|->
name|object
operator|)
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contents_from
condition|)
name|die
argument_list|(
literal|"Cannot use --contents with final commit object name"
argument_list|)
expr_stmt|;
comment|/* 	 * If we have bottom, this will mark the ancestors of the 	 * bottom commits we would reach while traversing as 	 * uninteresting. 	 */
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|sb
operator|.
name|final
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|o
operator|=
name|sb
operator|.
name|final
operator|->
name|util
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|o
operator|->
name|file
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|o
operator|->
name|file
operator|.
name|ptr
argument_list|,
name|o
operator|->
name|file
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|.
name|final_buf
operator|=
name|buf
expr_stmt|;
name|sb
operator|.
name|final_buf_size
operator|=
name|o
operator|->
name|file
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|o
operator|=
name|get_origin
argument_list|(
operator|&
name|sb
argument_list|,
name|sb
operator|.
name|final
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill_blob_sha1
argument_list|(
name|o
argument_list|)
condition|)
name|die
argument_list|(
literal|"no such path %s in %s"
argument_list|,
name|path
argument_list|,
name|final_commit_name
argument_list|)
expr_stmt|;
name|sb
operator|.
name|final_buf
operator|=
name|read_sha1_file
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|sb
operator|.
name|final_buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sb
operator|.
name|final_buf
condition|)
name|die
argument_list|(
literal|"Cannot read blob %s for path %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|num_read_blob
operator|++
expr_stmt|;
name|lno
operator|=
name|prepare_lines
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|top
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bottomtop
condition|)
name|prepare_blame_range
argument_list|(
operator|&
name|sb
argument_list|,
name|bottomtop
argument_list|,
name|lno
argument_list|,
operator|&
name|bottom
argument_list|,
operator|&
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottom
operator|&&
name|top
operator|&&
name|top
operator|<
name|bottom
condition|)
block|{
name|long
name|tmp
decl_stmt|;
name|tmp
operator|=
name|top
expr_stmt|;
name|top
operator|=
name|bottom
expr_stmt|;
name|bottom
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|bottom
operator|<
literal|1
condition|)
name|bottom
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|top
operator|<
literal|1
condition|)
name|top
operator|=
name|lno
expr_stmt|;
name|bottom
operator|--
expr_stmt|;
if|if
condition|(
name|lno
operator|<
name|top
condition|)
name|die
argument_list|(
literal|"file %s has only %lu lines"
argument_list|,
name|path
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|ent
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|lno
operator|=
name|bottom
expr_stmt|;
name|ent
operator|->
name|num_lines
operator|=
name|top
operator|-
name|bottom
expr_stmt|;
name|ent
operator|->
name|suspect
operator|=
name|o
expr_stmt|;
name|ent
operator|->
name|s_lno
operator|=
name|bottom
expr_stmt|;
name|sb
operator|.
name|ent
operator|=
name|ent
expr_stmt|;
name|sb
operator|.
name|path
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|revs_file
operator|&&
name|read_ancestry
argument_list|(
name|revs_file
argument_list|)
condition|)
name|die
argument_list|(
literal|"reading graft file %s failed: %s"
argument_list|,
name|revs_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|read_mailmap
argument_list|(
operator|&
name|mailmap
argument_list|,
literal|".mailmap"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|incremental
condition|)
name|setup_pager
argument_list|()
expr_stmt|;
name|assign_blame
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|revs
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
return|return
literal|0
return|;
name|coalesce
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|output_option
operator|&
name|OUTPUT_PORCELAIN
operator|)
condition|)
name|find_alignment
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|output_option
argument_list|)
expr_stmt|;
name|output
argument_list|(
operator|&
name|sb
argument_list|,
name|output_option
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sb
operator|.
name|final_buf
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|.
name|ent
init|;
name|ent
condition|;
control|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
init|=
name|ent
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|ent
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|show_stats
condition|)
block|{
name|printf
argument_list|(
literal|"num read blob: %d\n"
argument_list|,
name|num_read_blob
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"num get patch: %d\n"
argument_list|,
name|num_get_patch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"num commits: %d\n"
argument_list|,
name|num_commits
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
