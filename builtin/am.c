begin_unit
begin_comment
comment|/*  * Builtin "git am"  *  * Based on git-am.sh by Junio C Hamano.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"lockfile.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_comment
comment|/**  * Returns 1 if the file is empty or does not exist, 0 otherwise.  */
end_comment
begin_function
DECL|function|is_empty_file
specifier|static
name|int
name|is_empty_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|1
return|;
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not stat %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|st
operator|.
name|st_size
return|;
block|}
end_function
begin_comment
comment|/**  * Like strbuf_getline(), but treats both '\n' and "\r\n" as line terminators.  */
end_comment
begin_function
DECL|function|strbuf_getline_crlf
specifier|static
name|int
name|strbuf_getline_crlf
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|strbuf_getwholeline
argument_list|(
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|len
operator|>
literal|0
operator|&&
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Returns the length of the first line of msg.  */
end_comment
begin_function
DECL|function|linelen
specifier|static
name|int
name|linelen
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
name|strchrnul
argument_list|(
name|msg
argument_list|,
literal|'\n'
argument_list|)
operator|-
name|msg
return|;
block|}
end_function
begin_enum
DECL|enum|patch_format
enum|enum
name|patch_format
block|{
DECL|enumerator|PATCH_FORMAT_UNKNOWN
name|PATCH_FORMAT_UNKNOWN
init|=
literal|0
block|,
DECL|enumerator|PATCH_FORMAT_MBOX
name|PATCH_FORMAT_MBOX
block|}
enum|;
end_enum
begin_struct
DECL|struct|am_state
struct|struct
name|am_state
block|{
comment|/* state directory path */
DECL|member|dir
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* current and last patch numbers, 1-indexed */
DECL|member|cur
name|int
name|cur
decl_stmt|;
DECL|member|last
name|int
name|last
decl_stmt|;
comment|/* commit metadata and message */
DECL|member|author_name
name|char
modifier|*
name|author_name
decl_stmt|;
DECL|member|author_email
name|char
modifier|*
name|author_email
decl_stmt|;
DECL|member|author_date
name|char
modifier|*
name|author_date
decl_stmt|;
DECL|member|msg
name|char
modifier|*
name|msg
decl_stmt|;
DECL|member|msg_len
name|size_t
name|msg_len
decl_stmt|;
comment|/* number of digits in patch filename */
DECL|member|prec
name|int
name|prec
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/**  * Initializes am_state with the default values. The state directory is set to  * dir.  */
end_comment
begin_function
DECL|function|am_state_init
specifier|static
name|void
name|am_state_init
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|memset
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|state
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|state
operator|->
name|prec
operator|=
literal|4
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Releases memory allocated by an am_state.  */
end_comment
begin_function
DECL|function|am_state_release
specifier|static
name|void
name|am_state_release
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|free
argument_list|(
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns path relative to the am_state directory.  */
end_comment
begin_function
DECL|function|am_path
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|am_path
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
name|mkpath
argument_list|(
literal|"%s/%s"
argument_list|,
name|state
operator|->
name|dir
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if there is an am session in progress, 0 otherwise.  */
end_comment
begin_function
DECL|function|am_in_progress
specifier|static
name|int
name|am_in_progress
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|state
operator|->
name|dir
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lstat
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"last"
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lstat
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"next"
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/**  * Reads the contents of `file` in the `state` directory into `sb`. Returns the  * number of bytes read on success, -1 if the file does not exist. If `trim` is  * set, trailing whitespace will be removed.  */
end_comment
begin_function
DECL|function|read_state_file
specifier|static
name|int
name|read_state_file
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|trim
parameter_list|)
block|{
name|strbuf_reset
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read_file
argument_list|(
name|sb
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
name|file
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|trim
condition|)
name|strbuf_trim
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|->
name|len
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read '%s'"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Reads a KEY=VALUE shell variable assignment from `fp`, returning the VALUE  * as a newly-allocated string. VALUE must be a quoted string, and the KEY must  * match `key`. Returns NULL on failure.  *  * This is used by read_author_script() to read the GIT_AUTHOR_* variables from  * the author-script.  */
end_comment
begin_function
DECL|function|read_shell_var
specifier|static
name|char
modifier|*
name|read_shell_var
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|key
argument_list|,
operator|&
name|str
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|str
argument_list|,
literal|"="
argument_list|,
operator|&
name|str
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|strbuf_remove
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|str
operator|-
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|str
operator|=
name|sq_dequote
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|fail
goto|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
return|;
name|fail
label|:
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/**  * Reads and parses the state directory's "author-script" file, and sets  * state->author_name, state->author_email and state->author_date accordingly.  * Returns 0 on success, -1 if the file could not be parsed.  *  * The author script is of the format:  *  *	GIT_AUTHOR_NAME='$author_name'  *	GIT_AUTHOR_EMAIL='$author_email'  *	GIT_AUTHOR_DATE='$author_date'  *  * where $author_name, $author_email and $author_date are quoted. We are strict  * with our parsing, as the file was meant to be eval'd in the old git-am.sh  * script, and thus if the file differs from what this function expects, it is  * better to bail out than to do something that the user does not expect.  */
end_comment
begin_function
DECL|function|read_author_script
specifier|static
name|int
name|read_author_script
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|am_path
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not open '%s' for reading"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|author_name
operator|=
name|read_shell_var
argument_list|(
name|fp
argument_list|,
literal|"GIT_AUTHOR_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_name
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|author_email
operator|=
name|read_shell_var
argument_list|(
name|fp
argument_list|,
literal|"GIT_AUTHOR_EMAIL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_email
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|author_date
operator|=
name|read_shell_var
argument_list|(
name|fp
argument_list|,
literal|"GIT_AUTHOR_DATE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_date
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Saves state->author_name, state->author_email and state->author_date in the  * state directory's "author-script" file.  */
end_comment
begin_function
DECL|function|write_author_script
specifier|static
name|void
name|write_author_script
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"GIT_AUTHOR_NAME="
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"GIT_AUTHOR_EMAIL="
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"GIT_AUTHOR_DATE="
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|write_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Reads the commit message from the state directory's "final-commit" file,  * setting state->msg to its contents and state->msg_len to the length of its  * contents in bytes.  *  * Returns 0 on success, -1 if the file does not exist.  */
end_comment
begin_function
DECL|function|read_commit_msg
specifier|static
name|int
name|read_commit_msg
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"final-commit"
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|msg
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|state
operator|->
name|msg_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Saves state->msg in the state directory's "final-commit" file.  */
end_comment
begin_function
DECL|function|write_commit_msg
specifier|static
name|void
name|write_commit_msg
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|xopen
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|state
operator|->
name|msg
argument_list|,
name|state
operator|->
name|msg_len
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not write to %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Loads state from disk.  */
end_comment
begin_function
DECL|function|am_load
specifier|static
name|void
name|am_load
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"next"
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"BUG: state file 'next' does not exist"
argument_list|)
expr_stmt|;
name|state
operator|->
name|cur
operator|=
name|strtol
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"last"
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"BUG: state file 'last' does not exist"
argument_list|)
expr_stmt|;
name|state
operator|->
name|last
operator|=
name|strtol
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_author_script
argument_list|(
name|state
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse author script"
argument_list|)
argument_list|)
expr_stmt|;
name|read_commit_msg
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Removes the am_state directory, forcefully terminating the current am  * session.  */
end_comment
begin_function
DECL|function|am_destroy
specifier|static
name|void
name|am_destroy
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
name|remove_dir_recursively
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Determines if the file looks like a piece of RFC2822 mail by grabbing all  * non-indented lines and checking if they look like they begin with valid  * header field names.  *  * Returns 1 if the file looks like a piece of mail, 0 otherwise.  */
end_comment
begin_function
DECL|function|is_mail
specifier|static
name|int
name|is_mail
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|header_regex
init|=
literal|"^[!-9;-~]+:"
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|regex_t
name|regex
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"fseek failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|regex
argument_list|,
name|header_regex
argument_list|,
name|REG_NOSUB
operator||
name|REG_EXTENDED
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid pattern: %s"
argument_list|,
name|header_regex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline_crlf
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sb
operator|.
name|len
condition|)
break|break;
comment|/* End of header */
comment|/* Ignore indented folded lines */
if|if
condition|(
operator|*
name|sb
operator|.
name|buf
operator|==
literal|'\t'
operator|||
operator|*
name|sb
operator|.
name|buf
operator|==
literal|' '
condition|)
continue|continue;
comment|/* It's a header if it matches header_regex */
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|regex
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|regfree
argument_list|(
operator|&
name|regex
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Attempts to detect the patch_format of the patches contained in `paths`,  * returning the PATCH_FORMAT_* enum value. Returns PATCH_FORMAT_UNKNOWN if  * detection fails.  */
end_comment
begin_function
DECL|function|detect_patch_format
specifier|static
name|int
name|detect_patch_format
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|)
block|{
name|enum
name|patch_format
name|ret
init|=
name|PATCH_FORMAT_UNKNOWN
decl_stmt|;
name|struct
name|strbuf
name|l1
init|=
name|STRBUF_INIT
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* 	 * We default to mbox format if input is from stdin and for directories 	 */
if|if
condition|(
operator|!
operator|*
name|paths
operator|||
operator|!
name|strcmp
argument_list|(
operator|*
name|paths
argument_list|,
literal|"-"
argument_list|)
operator|||
name|is_directory
argument_list|(
operator|*
name|paths
argument_list|)
condition|)
return|return
name|PATCH_FORMAT_MBOX
return|;
comment|/* 	 * Otherwise, check the first few lines of the first patch, starting 	 * from the first non-blank line, to try to detect its format. 	 */
name|fp
operator|=
name|xfopen
argument_list|(
operator|*
name|paths
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline_crlf
argument_list|(
operator|&
name|l1
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|l1
operator|.
name|len
condition|)
break|break;
block|}
if|if
condition|(
name|starts_with
argument_list|(
name|l1
operator|.
name|buf
argument_list|,
literal|"From "
argument_list|)
operator|||
name|starts_with
argument_list|(
name|l1
operator|.
name|buf
argument_list|,
literal|"From: "
argument_list|)
condition|)
block|{
name|ret
operator|=
name|PATCH_FORMAT_MBOX
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|l1
operator|.
name|len
operator|&&
name|is_mail
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|ret
operator|=
name|PATCH_FORMAT_MBOX
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|l1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Splits out individual email patches from `paths`, where each path is either  * a mbox file or a Maildir. Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|split_mail_mbox
specifier|static
name|int
name|split_mail_mbox
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|)
block|{
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|struct
name|strbuf
name|last
init|=
name|STRBUF_INIT
decl_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"mailsplit"
argument_list|)
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"-d%d"
argument_list|,
name|state
operator|->
name|prec
argument_list|)
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"-o%s"
argument_list|,
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"-b"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
name|argv_array_pushv
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|capture_command
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|last
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|->
name|cur
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|last
operator|=
name|strtol
argument_list|(
name|last
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Splits a list of files/directories into individual email patches. Each path  * in `paths` must be a file/directory that is formatted according to  * `patch_format`.  *  * Once split out, the individual email patches will be stored in the state  * directory, with each patch's filename being its index, padded to state->prec  * digits.  *  * state->cur will be set to the index of the first mail, and state->last will  * be set to the index of the last mail.  *  * Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|split_mail
specifier|static
name|int
name|split_mail
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|enum
name|patch_format
name|patch_format
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|)
block|{
switch|switch
condition|(
name|patch_format
condition|)
block|{
case|case
name|PATCH_FORMAT_MBOX
case|:
return|return
name|split_mail_mbox
argument_list|(
name|state
argument_list|,
name|paths
argument_list|)
return|;
default|default:
name|die
argument_list|(
literal|"BUG: invalid patch_format"
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/**  * Setup a new am session for applying patches  */
end_comment
begin_function
DECL|function|am_setup
specifier|static
name|void
name|am_setup
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|enum
name|patch_format
name|patch_format
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|)
block|{
if|if
condition|(
operator|!
name|patch_format
condition|)
name|patch_format
operator|=
name|detect_patch_format
argument_list|(
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patch_format
condition|)
block|{
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Patch format detection failed."
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|state
operator|->
name|dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to create directory '%s'"
argument_list|)
argument_list|,
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_mail
argument_list|(
name|state
argument_list|,
name|patch_format
argument_list|,
name|paths
argument_list|)
operator|<
literal|0
condition|)
block|{
name|am_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to split patches."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * NOTE: Since the "next" and "last" files determine if an am_state 	 * session is in progress, they should be written last. 	 */
name|write_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"next"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|state
operator|->
name|cur
argument_list|)
expr_stmt|;
name|write_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"last"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|state
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Increments the patch pointer, and cleans am_state for the application of the  * next patch.  */
end_comment
begin_function
DECL|function|am_next
specifier|static
name|void
name|am_next
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|free
argument_list|(
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_name
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_email
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_date
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
name|unlink
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|cur
operator|++
expr_stmt|;
name|write_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"next"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|state
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns the filename of the current patch email.  */
end_comment
begin_function
DECL|function|msgnum
specifier|static
specifier|const
name|char
modifier|*
name|msgnum
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%0*d"
argument_list|,
name|state
operator|->
name|prec
argument_list|,
name|state
operator|->
name|cur
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|buf
return|;
block|}
end_function
begin_comment
comment|/**  * Refresh and write index.  */
end_comment
begin_function
DECL|function|refresh_and_write_cache
specifier|static
name|void
name|refresh_and_write_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock_file
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|lock_file
argument_list|,
name|COMMIT_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write index file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the index differs from HEAD, 0 otherwise. When on an unborn  * branch, returns 1 if there are entries in the index, 0 otherwise. If an  * strbuf is provided, the space-separated list of files that differ will be  * appended to it.  */
end_comment
begin_function
DECL|function|index_has_changes
specifier|static
name|int
name|index_has_changes
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|unsigned
name|char
name|head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|get_sha1_tree
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
block|{
name|struct
name|diff_options
name|opt
decl_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|EXIT_WITH_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sb
condition|)
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|QUICK
argument_list|)
expr_stmt|;
name|do_diff_cache
argument_list|(
name|head
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sb
operator|&&
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
return|return
name|DIFF_OPT_TST
argument_list|(
operator|&
name|opt
argument_list|,
name|HAS_CHANGES
argument_list|)
operator|!=
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sb
operator|&&
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|active_cache
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
operator|!
name|active_nr
return|;
block|}
block|}
end_function
begin_comment
comment|/**  * Parses `mail` using git-mailinfo, extracting its patch and authorship info.  * state->msg will be set to the patch message. state->author_name,  * state->author_email and state->author_date will be set to the patch author's  * name, email and date respectively. The patch body will be written to the  * state directory's "patch" file.  *  * Returns 1 if the patch should be skipped, 0 otherwise.  */
end_comment
begin_function
DECL|function|parse_mail
specifier|static
name|int
name|parse_mail
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|mail
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|author_name
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|author_date
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|author_email
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|in
operator|=
name|xopen
argument_list|(
name|mail
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|.
name|out
operator|=
name|xopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"info"
argument_list|)
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"mailinfo"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"msg"
argument_list|)
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not parse patch"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cp
operator|.
name|in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cp
operator|.
name|out
argument_list|)
expr_stmt|;
comment|/* Extract message and author information */
name|fp
operator|=
name|xfopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"info"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Subject: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|msg
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msg
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Author: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|author_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Email: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|author_email
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Date: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|author_date
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Skip pine's internal folder data */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|author_name
operator|.
name|buf
argument_list|,
literal|"Mail System Internal Data"
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|is_empty_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
condition|)
block|{
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"Patch is empty. Was it split wrong?"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|msg
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|msg
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"msg"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read '%s'"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"msg"
argument_list|)
argument_list|)
expr_stmt|;
name|stripspace
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_name
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|author_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_email
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|author_email
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_date
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|author_date
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|msg
argument_list|,
operator|&
name|state
operator|->
name|msg_len
argument_list|)
expr_stmt|;
name|finish
label|:
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|author_date
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|author_email
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|author_name
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Applies current patch with git-apply. Returns 0 on success, -1 otherwise.  */
end_comment
begin_function
DECL|function|run_apply
specifier|static
name|int
name|run_apply
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"apply"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--index"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Reload index as git-apply will have modified it. */
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Commits the current index with state->msg as the commit message and  * state->author_name, state->author_email and state->author_date as the author  * information.  */
end_comment
begin_function
DECL|function|do_commit
specifier|static
name|void
name|do_commit
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|char
name|tree
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|parent
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|commit
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|reflog_msg
decl_stmt|,
modifier|*
name|author
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|write_cache_as_tree
argument_list|(
name|tree
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git write-tree failed to write a tree"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sha1_commit
argument_list|(
literal|"HEAD"
argument_list|,
name|parent
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|parent
expr_stmt|;
name|commit_list_insert
argument_list|(
name|lookup_commit
argument_list|(
name|parent
argument_list|)
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|NULL
expr_stmt|;
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"applying to an empty history"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|author
operator|=
name|fmt_ident
argument_list|(
name|state
operator|->
name|author_name
argument_list|,
name|state
operator|->
name|author_email
argument_list|,
name|state
operator|->
name|author_date
argument_list|,
name|IDENT_STRICT
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_tree
argument_list|(
name|state
operator|->
name|msg
argument_list|,
name|state
operator|->
name|msg_len
argument_list|,
name|tree
argument_list|,
name|parents
argument_list|,
name|commit
argument_list|,
name|author
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to write commit object"
argument_list|)
argument_list|)
expr_stmt|;
name|reflog_msg
operator|=
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reflog_msg
condition|)
name|reflog_msg
operator|=
literal|"am"
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s: %.*s"
argument_list|,
name|reflog_msg
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|update_ref
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|commit
argument_list|,
name|ptr
argument_list|,
literal|0
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Validates the am_state for resuming -- the "msg" and authorship fields must  * be filled up.  */
end_comment
begin_function
DECL|function|validate_resume_state
specifier|static
name|void
name|validate_resume_state
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|->
name|msg
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot resume: %s does not exist."
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_name
operator|||
operator|!
name|state
operator|->
name|author_email
operator|||
operator|!
name|state
operator|->
name|author_date
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot resume: %s does not exist."
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Applies all queued mail.  *  * If `resume` is true, we are "resuming". The "msg" and authorship fields, as  * well as the state directory's "patch" file is used as-is for applying the  * patch and committing it.  */
end_comment
begin_function
DECL|function|am_run
specifier|static
name|void
name|am_run
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|int
name|resume
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|argv_gc_auto
index|[]
init|=
block|{
literal|"gc"
block|,
literal|"--auto"
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|refresh_and_write_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|index_has_changes
argument_list|(
operator|&
name|sb
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Dirty index: cannot apply patches (dirty: %s)"
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|cur
operator|<=
name|state
operator|->
name|last
condition|)
block|{
specifier|const
name|char
modifier|*
name|mail
init|=
name|am_path
argument_list|(
name|state
argument_list|,
name|msgnum
argument_list|(
name|state
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|mail
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|resume
condition|)
block|{
name|validate_resume_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|resume
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parse_mail
argument_list|(
name|state
argument_list|,
name|mail
argument_list|)
condition|)
goto|goto
name|next
goto|;
comment|/* mail should be skipped */
name|write_author_script
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|write_commit_msg
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"Applying: %.*s"
argument_list|)
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_apply
argument_list|(
name|state
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|advice_amworkdir
init|=
literal|1
decl_stmt|;
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"Patch failed at %s %.*s"
argument_list|)
argument_list|,
name|msgnum
argument_list|(
name|state
argument_list|)
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|git_config_get_bool
argument_list|(
literal|"advice.amworkdir"
argument_list|,
operator|&
name|advice_amworkdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_amworkdir
condition|)
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"The copy of the patch that failed is found in: %s"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
name|do_commit
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|next
label|:
name|am_next
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|am_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|run_command_v_opt
argument_list|(
name|argv_gc_auto
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Resume the current am session after patch application failure. The user did  * all the hard work, and we do not have to do any patch application. Just  * trust and commit what the user has in the index and working tree.  */
end_comment
begin_function
DECL|function|am_resolve
specifier|static
name|void
name|am_resolve
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|validate_resume_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"Applying: %.*s"
argument_list|)
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index_has_changes
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"No changes - did you forget to use 'git add'?\n"
literal|"If there is nothing left to stage, chances are that something else\n"
literal|"already introduced the same changes; you might want to skip this patch."
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"You still have unmerged paths in your index.\n"
literal|"Did you forget to use 'git add'?"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
name|do_commit
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|am_next
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|am_run
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Performs a checkout fast-forward from `head` to `remote`. If `reset` is  * true, any unmerged entries will be discarded. Returns 0 on success, -1 on  * failure.  */
end_comment
begin_function
DECL|function|fast_forward_to
specifier|static
name|int
name|fast_forward_to
parameter_list|(
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|remote
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock_file
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|t
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|parse_tree
argument_list|(
name|head
argument_list|)
operator|||
name|parse_tree
argument_list|(
name|remote
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|lock_file
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
expr_stmt|;
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|reset
operator|=
name|reset
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|twoway_merge
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
index|[
literal|0
index|]
argument_list|,
name|head
operator|->
name|buffer
argument_list|,
name|head
operator|->
name|size
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
index|[
literal|1
index|]
argument_list|,
name|remote
operator|->
name|buffer
argument_list|,
name|remote
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_trees
argument_list|(
literal|2
argument_list|,
name|t
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
block|{
name|rollback_lock_file
argument_list|(
name|lock_file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|lock_file
argument_list|,
name|COMMIT_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Clean the index without touching entries that are not modified between  * `head` and `remote`.  */
end_comment
begin_function
DECL|function|clean_index
specifier|static
name|int
name|clean_index
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|remote
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock_file
decl_stmt|;
name|struct
name|tree
modifier|*
name|head_tree
decl_stmt|,
modifier|*
name|remote_tree
decl_stmt|,
modifier|*
name|index_tree
decl_stmt|;
name|unsigned
name|char
name|index
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|struct
name|pathspec
name|pathspec
decl_stmt|;
name|head_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head_tree
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse object '%s'."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
argument_list|)
argument_list|)
return|;
name|remote_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_tree
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse object '%s'."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|)
return|;
name|read_cache_unmerged
argument_list|()
expr_stmt|;
if|if
condition|(
name|fast_forward_to
argument_list|(
name|head_tree
argument_list|,
name|head_tree
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|write_cache_as_tree
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|index_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index_tree
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse object '%s'."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|fast_forward_to
argument_list|(
name|index_tree
argument_list|,
name|remote_tree
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
operator|&
name|pathspec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pathspec
argument_list|)
argument_list|)
expr_stmt|;
name|lock_file
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
expr_stmt|;
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_tree
argument_list|(
name|remote_tree
argument_list|,
literal|0
argument_list|,
operator|&
name|pathspec
argument_list|)
condition|)
block|{
name|rollback_lock_file
argument_list|(
name|lock_file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|lock_file
argument_list|,
name|COMMIT_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
name|remove_branch_state
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Resume the current am session by skipping the current patch.  */
end_comment
begin_function
DECL|function|am_skip
specifier|static
name|void
name|am_skip
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|char
name|head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|head
argument_list|,
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|clean_index
argument_list|(
name|head
argument_list|,
name|head
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to clean index"
argument_list|)
argument_list|)
expr_stmt|;
name|am_next
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|am_run
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * parse_options() callback that validates and sets opt->value to the  * PATCH_FORMAT_* enum value corresponding to `arg`.  */
end_comment
begin_function
DECL|function|parse_opt_patchformat
specifier|static
name|int
name|parse_opt_patchformat
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|int
modifier|*
name|opt_value
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"mbox"
argument_list|)
condition|)
operator|*
name|opt_value
operator|=
name|PATCH_FORMAT_MBOX
expr_stmt|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid value for --patch-format: %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_enum
DECL|enum|resume_mode
enum|enum
name|resume_mode
block|{
DECL|enumerator|RESUME_FALSE
name|RESUME_FALSE
init|=
literal|0
block|,
DECL|enumerator|RESUME_APPLY
name|RESUME_APPLY
block|,
DECL|enumerator|RESUME_RESOLVED
name|RESUME_RESOLVED
block|,
DECL|enumerator|RESUME_SKIP
name|RESUME_SKIP
block|}
enum|;
end_enum
begin_function
DECL|function|cmd_am
name|int
name|cmd_am
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|am_state
name|state
decl_stmt|;
name|int
name|patch_format
init|=
name|PATCH_FORMAT_UNKNOWN
decl_stmt|;
name|enum
name|resume_mode
name|resume
init|=
name|RESUME_FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git am [options] [(<mbox>|<Maildir>)...]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git am [options] (--continue | --skip)"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_CALLBACK
argument_list|(
literal|0
argument_list|,
literal|"patch-format"
argument_list|,
operator|&
name|patch_format
argument_list|,
name|N_
argument_list|(
literal|"format"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"format the patch(es) are in"
argument_list|)
argument_list|,
name|parse_opt_patchformat
argument_list|)
block|,
name|OPT_CMDMODE
argument_list|(
literal|0
argument_list|,
literal|"continue"
argument_list|,
operator|&
name|resume
argument_list|,
name|N_
argument_list|(
literal|"continue applying patches after resolving a conflict"
argument_list|)
argument_list|,
name|RESUME_RESOLVED
argument_list|)
block|,
name|OPT_CMDMODE
argument_list|(
literal|'r'
argument_list|,
literal|"resolved"
argument_list|,
operator|&
name|resume
argument_list|,
name|N_
argument_list|(
literal|"synonyms for --continue"
argument_list|)
argument_list|,
name|RESUME_RESOLVED
argument_list|)
block|,
name|OPT_CMDMODE
argument_list|(
literal|0
argument_list|,
literal|"skip"
argument_list|,
operator|&
name|resume
argument_list|,
name|N_
argument_list|(
literal|"skip the current patch"
argument_list|)
argument_list|,
name|RESUME_SKIP
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
comment|/* 	 * NEEDSWORK: Once all the features of git-am.sh have been 	 * re-implemented in builtin/am.c, this preamble can be removed. 	 */
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"_GIT_USE_BUILTIN_AM"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|mkpath
argument_list|(
literal|"%s/git-am"
argument_list|,
name|git_exec_path
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sane_execvp
argument_list|(
name|path
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"could not exec %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
name|setup_git_directory
argument_list|()
expr_stmt|;
name|trace_repo_setup
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|setup_work_tree
argument_list|()
expr_stmt|;
block|}
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|am_state_init
argument_list|(
operator|&
name|state
argument_list|,
name|git_path
argument_list|(
literal|"rebase-apply"
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_index_preload
argument_list|(
operator|&
name|the_index
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to read the index"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|am_in_progress
argument_list|(
operator|&
name|state
argument_list|)
condition|)
block|{
if|if
condition|(
name|resume
operator|==
name|RESUME_FALSE
condition|)
name|resume
operator|=
name|RESUME_APPLY
expr_stmt|;
name|am_load
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|argv_array
name|paths
init|=
name|ARGV_ARRAY_INIT
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|resume
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Resolve operation not in progress, we are not resuming."
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is_absolute_path
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|||
operator|!
name|prefix
condition|)
name|argv_array_push
argument_list|(
operator|&
name|paths
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|argv_array_push
argument_list|(
operator|&
name|paths
argument_list|,
name|mkpath
argument_list|(
literal|"%s/%s"
argument_list|,
name|prefix
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|am_setup
argument_list|(
operator|&
name|state
argument_list|,
name|patch_format
argument_list|,
name|paths
operator|.
name|argv
argument_list|)
expr_stmt|;
name|argv_array_clear
argument_list|(
operator|&
name|paths
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|resume
condition|)
block|{
case|case
name|RESUME_FALSE
case|:
name|am_run
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME_APPLY
case|:
name|am_run
argument_list|(
operator|&
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME_RESOLVED
case|:
name|am_resolve
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME_SKIP
case|:
name|am_skip
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"BUG: invalid resume value"
argument_list|)
expr_stmt|;
block|}
name|am_state_release
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
