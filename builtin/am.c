begin_unit
begin_comment
comment|/*  * Builtin "git am"  *  * Based on git-am.sh by Junio C Hamano.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"tempfile.h"
end_include
begin_include
include|#
directive|include
file|"lockfile.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"sequencer.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"notes-utils.h"
end_include
begin_include
include|#
directive|include
file|"rerere.h"
end_include
begin_include
include|#
directive|include
file|"prompt.h"
end_include
begin_include
include|#
directive|include
file|"mailinfo.h"
end_include
begin_comment
comment|/**  * Returns 1 if the file is empty or does not exist, 0 otherwise.  */
end_comment
begin_function
DECL|function|is_empty_file
specifier|static
name|int
name|is_empty_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|1
return|;
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not stat %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|st
operator|.
name|st_size
return|;
block|}
end_function
begin_comment
comment|/**  * Like strbuf_getline(), but treats both '\n' and "\r\n" as line terminators.  */
end_comment
begin_function
DECL|function|strbuf_getline_crlf
specifier|static
name|int
name|strbuf_getline_crlf
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|strbuf_getwholeline
argument_list|(
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|len
operator|>
literal|0
operator|&&
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|sb
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Returns the length of the first line of msg.  */
end_comment
begin_function
DECL|function|linelen
specifier|static
name|int
name|linelen
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
return|return
name|strchrnul
argument_list|(
name|msg
argument_list|,
literal|'\n'
argument_list|)
operator|-
name|msg
return|;
block|}
end_function
begin_comment
comment|/**  * Returns true if `str` consists of only whitespace, false otherwise.  */
end_comment
begin_function
DECL|function|str_isspace
specifier|static
name|int
name|str_isspace
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_enum
DECL|enum|patch_format
enum|enum
name|patch_format
block|{
DECL|enumerator|PATCH_FORMAT_UNKNOWN
name|PATCH_FORMAT_UNKNOWN
init|=
literal|0
block|,
DECL|enumerator|PATCH_FORMAT_MBOX
name|PATCH_FORMAT_MBOX
block|,
DECL|enumerator|PATCH_FORMAT_STGIT
name|PATCH_FORMAT_STGIT
block|,
DECL|enumerator|PATCH_FORMAT_STGIT_SERIES
name|PATCH_FORMAT_STGIT_SERIES
block|,
DECL|enumerator|PATCH_FORMAT_HG
name|PATCH_FORMAT_HG
block|}
enum|;
end_enum
begin_enum
DECL|enum|keep_type
enum|enum
name|keep_type
block|{
DECL|enumerator|KEEP_FALSE
name|KEEP_FALSE
init|=
literal|0
block|,
DECL|enumerator|KEEP_TRUE
name|KEEP_TRUE
block|,
comment|/* pass -k flag to git-mailinfo */
DECL|enumerator|KEEP_NON_PATCH
name|KEEP_NON_PATCH
comment|/* pass -b flag to git-mailinfo */
block|}
enum|;
end_enum
begin_enum
DECL|enum|scissors_type
enum|enum
name|scissors_type
block|{
DECL|enumerator|SCISSORS_UNSET
name|SCISSORS_UNSET
init|=
operator|-
literal|1
block|,
DECL|enumerator|SCISSORS_FALSE
name|SCISSORS_FALSE
init|=
literal|0
block|,
comment|/* pass --no-scissors to git-mailinfo */
DECL|enumerator|SCISSORS_TRUE
name|SCISSORS_TRUE
comment|/* pass --scissors to git-mailinfo */
block|}
enum|;
end_enum
begin_enum
DECL|enum|signoff_type
enum|enum
name|signoff_type
block|{
DECL|enumerator|SIGNOFF_FALSE
name|SIGNOFF_FALSE
init|=
literal|0
block|,
DECL|enumerator|SIGNOFF_TRUE
name|SIGNOFF_TRUE
init|=
literal|1
block|,
DECL|enumerator|SIGNOFF_EXPLICIT
name|SIGNOFF_EXPLICIT
comment|/* --signoff was set on the command-line */
block|}
enum|;
end_enum
begin_struct
DECL|struct|am_state
struct|struct
name|am_state
block|{
comment|/* state directory path */
DECL|member|dir
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* current and last patch numbers, 1-indexed */
DECL|member|cur
name|int
name|cur
decl_stmt|;
DECL|member|last
name|int
name|last
decl_stmt|;
comment|/* commit metadata and message */
DECL|member|author_name
name|char
modifier|*
name|author_name
decl_stmt|;
DECL|member|author_email
name|char
modifier|*
name|author_email
decl_stmt|;
DECL|member|author_date
name|char
modifier|*
name|author_date
decl_stmt|;
DECL|member|msg
name|char
modifier|*
name|msg
decl_stmt|;
DECL|member|msg_len
name|size_t
name|msg_len
decl_stmt|;
comment|/* when --rebasing, records the original commit the patch came from */
DECL|member|orig_commit
name|unsigned
name|char
name|orig_commit
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
comment|/* number of digits in patch filename */
DECL|member|prec
name|int
name|prec
decl_stmt|;
comment|/* various operating modes and command line options */
DECL|member|interactive
name|int
name|interactive
decl_stmt|;
DECL|member|threeway
name|int
name|threeway
decl_stmt|;
DECL|member|quiet
name|int
name|quiet
decl_stmt|;
DECL|member|signoff
name|int
name|signoff
decl_stmt|;
comment|/* enum signoff_type */
DECL|member|utf8
name|int
name|utf8
decl_stmt|;
DECL|member|keep
name|int
name|keep
decl_stmt|;
comment|/* enum keep_type */
DECL|member|message_id
name|int
name|message_id
decl_stmt|;
DECL|member|scissors
name|int
name|scissors
decl_stmt|;
comment|/* enum scissors_type */
DECL|member|git_apply_opts
name|struct
name|argv_array
name|git_apply_opts
decl_stmt|;
DECL|member|resolvemsg
specifier|const
name|char
modifier|*
name|resolvemsg
decl_stmt|;
DECL|member|committer_date_is_author_date
name|int
name|committer_date_is_author_date
decl_stmt|;
DECL|member|ignore_date
name|int
name|ignore_date
decl_stmt|;
DECL|member|allow_rerere_autoupdate
name|int
name|allow_rerere_autoupdate
decl_stmt|;
DECL|member|sign_commit
specifier|const
name|char
modifier|*
name|sign_commit
decl_stmt|;
DECL|member|rebasing
name|int
name|rebasing
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/**  * Initializes am_state with the default values. The state directory is set to  * dir.  */
end_comment
begin_function
DECL|function|am_state_init
specifier|static
name|void
name|am_state_init
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|gpgsign
decl_stmt|;
name|memset
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|state
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|state
operator|->
name|prec
operator|=
literal|4
expr_stmt|;
name|git_config_get_bool
argument_list|(
literal|"am.threeway"
argument_list|,
operator|&
name|state
operator|->
name|threeway
argument_list|)
expr_stmt|;
name|state
operator|->
name|utf8
operator|=
literal|1
expr_stmt|;
name|git_config_get_bool
argument_list|(
literal|"am.messageid"
argument_list|,
operator|&
name|state
operator|->
name|message_id
argument_list|)
expr_stmt|;
name|state
operator|->
name|scissors
operator|=
name|SCISSORS_UNSET
expr_stmt|;
name|argv_array_init
argument_list|(
operator|&
name|state
operator|->
name|git_apply_opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|git_config_get_bool
argument_list|(
literal|"commit.gpgsign"
argument_list|,
operator|&
name|gpgsign
argument_list|)
condition|)
name|state
operator|->
name|sign_commit
operator|=
name|gpgsign
condition|?
literal|""
else|:
name|NULL
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Releases memory allocated by an am_state.  */
end_comment
begin_function
DECL|function|am_state_release
specifier|static
name|void
name|am_state_release
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|free
argument_list|(
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|argv_array_clear
argument_list|(
operator|&
name|state
operator|->
name|git_apply_opts
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns path relative to the am_state directory.  */
end_comment
begin_function
DECL|function|am_path
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|am_path
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
name|mkpath
argument_list|(
literal|"%s/%s"
argument_list|,
name|state
operator|->
name|dir
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * For convenience to call write_file()  */
end_comment
begin_function
DECL|function|write_state_text
specifier|static
name|int
name|write_state_text
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|write_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
name|name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|write_state_count
specifier|static
name|int
name|write_state_count
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
return|return
name|write_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|write_state_bool
specifier|static
name|int
name|write_state_bool
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
return|return
name|write_state_text
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|value
condition|?
literal|"t"
else|:
literal|"f"
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**  * If state->quiet is false, calls fprintf(fp, fmt, ...), and appends a newline  * at the end.  */
end_comment
begin_function
DECL|function|say
specifier|static
name|void
name|say
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|quiet
condition|)
block|{
name|vfprintf
argument_list|(
name|fp
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if there is an am session in progress, 0 otherwise.  */
end_comment
begin_function
DECL|function|am_in_progress
specifier|static
name|int
name|am_in_progress
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|state
operator|->
name|dir
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lstat
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"last"
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lstat
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"next"
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/**  * Reads the contents of `file` in the `state` directory into `sb`. Returns the  * number of bytes read on success, -1 if the file does not exist. If `trim` is  * set, trailing whitespace will be removed.  */
end_comment
begin_function
DECL|function|read_state_file
specifier|static
name|int
name|read_state_file
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|trim
parameter_list|)
block|{
name|strbuf_reset
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read_file
argument_list|(
name|sb
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
name|file
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|trim
condition|)
name|strbuf_trim
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|->
name|len
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read '%s'"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Reads a KEY=VALUE shell variable assignment from `fp`, returning the VALUE  * as a newly-allocated string. VALUE must be a quoted string, and the KEY must  * match `key`. Returns NULL on failure.  *  * This is used by read_author_script() to read the GIT_AUTHOR_* variables from  * the author-script.  */
end_comment
begin_function
DECL|function|read_shell_var
specifier|static
name|char
modifier|*
name|read_shell_var
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|key
argument_list|,
operator|&
name|str
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|str
argument_list|,
literal|"="
argument_list|,
operator|&
name|str
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|strbuf_remove
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|str
operator|-
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|str
operator|=
name|sq_dequote
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|fail
goto|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
return|;
name|fail
label|:
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/**  * Reads and parses the state directory's "author-script" file, and sets  * state->author_name, state->author_email and state->author_date accordingly.  * Returns 0 on success, -1 if the file could not be parsed.  *  * The author script is of the format:  *  *	GIT_AUTHOR_NAME='$author_name'  *	GIT_AUTHOR_EMAIL='$author_email'  *	GIT_AUTHOR_DATE='$author_date'  *  * where $author_name, $author_email and $author_date are quoted. We are strict  * with our parsing, as the file was meant to be eval'd in the old git-am.sh  * script, and thus if the file differs from what this function expects, it is  * better to bail out than to do something that the user does not expect.  */
end_comment
begin_function
DECL|function|read_author_script
specifier|static
name|int
name|read_author_script
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|am_path
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not open '%s' for reading"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|author_name
operator|=
name|read_shell_var
argument_list|(
name|fp
argument_list|,
literal|"GIT_AUTHOR_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_name
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|author_email
operator|=
name|read_shell_var
argument_list|(
name|fp
argument_list|,
literal|"GIT_AUTHOR_EMAIL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_email
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|author_date
operator|=
name|read_shell_var
argument_list|(
name|fp
argument_list|,
literal|"GIT_AUTHOR_DATE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_date
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Saves state->author_name, state->author_email and state->author_date in the  * state directory's "author-script" file.  */
end_comment
begin_function
DECL|function|write_author_script
specifier|static
name|void
name|write_author_script
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"GIT_AUTHOR_NAME="
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"GIT_AUTHOR_EMAIL="
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"GIT_AUTHOR_DATE="
argument_list|)
expr_stmt|;
name|sq_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Reads the commit message from the state directory's "final-commit" file,  * setting state->msg to its contents and state->msg_len to the length of its  * contents in bytes.  *  * Returns 0 on success, -1 if the file does not exist.  */
end_comment
begin_function
DECL|function|read_commit_msg
specifier|static
name|int
name|read_commit_msg
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"final-commit"
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|msg
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|state
operator|->
name|msg_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Saves state->msg in the state directory's "final-commit" file.  */
end_comment
begin_function
DECL|function|write_commit_msg
specifier|static
name|void
name|write_commit_msg
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|xopen
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|state
operator|->
name|msg
argument_list|,
name|state
operator|->
name|msg_len
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not write to %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Loads state from disk.  */
end_comment
begin_function
DECL|function|am_load
specifier|static
name|void
name|am_load
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"next"
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"BUG: state file 'next' does not exist"
argument_list|)
expr_stmt|;
name|state
operator|->
name|cur
operator|=
name|strtol
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"last"
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"BUG: state file 'last' does not exist"
argument_list|)
expr_stmt|;
name|state
operator|->
name|last
operator|=
name|strtol
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_author_script
argument_list|(
name|state
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse author script"
argument_list|)
argument_list|)
expr_stmt|;
name|read_commit_msg
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"original-commit"
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|hashclr
argument_list|(
name|state
operator|->
name|orig_commit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|state
operator|->
name|orig_commit
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse %s"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"original-commit"
argument_list|)
argument_list|)
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"threeway"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|state
operator|->
name|threeway
operator|=
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"quiet"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|state
operator|->
name|quiet
operator|=
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"sign"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|state
operator|->
name|signoff
operator|=
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"utf8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|state
operator|->
name|utf8
operator|=
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"keep"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"t"
argument_list|)
condition|)
name|state
operator|->
name|keep
operator|=
name|KEEP_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"b"
argument_list|)
condition|)
name|state
operator|->
name|keep
operator|=
name|KEEP_NON_PATCH
expr_stmt|;
else|else
name|state
operator|->
name|keep
operator|=
name|KEEP_FALSE
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"messageid"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|state
operator|->
name|message_id
operator|=
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"scissors"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"t"
argument_list|)
condition|)
name|state
operator|->
name|scissors
operator|=
name|SCISSORS_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"f"
argument_list|)
condition|)
name|state
operator|->
name|scissors
operator|=
name|SCISSORS_FALSE
expr_stmt|;
else|else
name|state
operator|->
name|scissors
operator|=
name|SCISSORS_UNSET
expr_stmt|;
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"apply-opt"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argv_array_clear
argument_list|(
operator|&
name|state
operator|->
name|git_apply_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq_dequote_to_argv_array
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
operator|&
name|state
operator|->
name|git_apply_opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse %s"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"apply-opt"
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|rebasing
operator|=
operator|!
operator|!
name|file_exists
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"rebasing"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Removes the am_state directory, forcefully terminating the current am  * session.  */
end_comment
begin_function
DECL|function|am_destroy
specifier|static
name|void
name|am_destroy
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
name|remove_dir_recursively
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Runs applypatch-msg hook. Returns its exit code.  */
end_comment
begin_function
DECL|function|run_applypatch_msg_hook
specifier|static
name|int
name|run_applypatch_msg_hook
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|assert
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|run_hook_le
argument_list|(
name|NULL
argument_list|,
literal|"applypatch-msg"
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|free
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|read_commit_msg
argument_list|(
name|state
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' was deleted by the applypatch-msg hook"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Runs post-rewrite hook. Returns it exit code.  */
end_comment
begin_function
DECL|function|run_post_rewrite_hook
specifier|static
name|int
name|run_post_rewrite_hook
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|hook
init|=
name|find_hook
argument_list|(
literal|"post-rewrite"
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|hook
condition|)
return|return
literal|0
return|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"rebase"
argument_list|)
expr_stmt|;
name|cp
operator|.
name|in
operator|=
name|xopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"rewritten"
argument_list|)
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|cp
operator|.
name|stdout_to_stderr
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cp
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Reads the state directory's "rewritten" file, and copies notes from the old  * commits listed in the file to their rewritten commits.  *  * Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|copy_notes_for_rebase
specifier|static
name|int
name|copy_notes_for_rebase
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|notes_rewrite_cfg
modifier|*
name|c
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|invalid_line
init|=
name|_
argument_list|(
literal|"Malformed input line: '%s'."
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"Notes added by 'git rebase'"
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|state
operator|->
name|rebasing
argument_list|)
expr_stmt|;
name|c
operator|=
name|init_copy_notes_for_rewrite
argument_list|(
literal|"rebase"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
name|fp
operator|=
name|xfopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"rewritten"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|from_obj
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|to_obj
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
if|if
condition|(
name|sb
operator|.
name|len
operator|!=
name|GIT_SHA1_HEXSZ
operator|*
literal|2
operator|+
literal|1
condition|)
block|{
name|ret
operator|=
name|error
argument_list|(
name|invalid_line
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|from_obj
argument_list|)
condition|)
block|{
name|ret
operator|=
name|error
argument_list|(
name|invalid_line
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|sb
operator|.
name|buf
index|[
name|GIT_SHA1_HEXSZ
index|]
operator|!=
literal|' '
condition|)
block|{
name|ret
operator|=
name|error
argument_list|(
name|invalid_line
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|GIT_SHA1_HEXSZ
operator|+
literal|1
argument_list|,
name|to_obj
argument_list|)
condition|)
block|{
name|ret
operator|=
name|error
argument_list|(
name|invalid_line
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|copy_note_for_rewrite
argument_list|(
name|c
argument_list|,
name|from_obj
argument_list|,
name|to_obj
argument_list|)
condition|)
name|ret
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to copy notes from '%s' to '%s'"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|from_obj
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|to_obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
name|finish_copy_notes_for_rewrite
argument_list|(
name|c
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Determines if the file looks like a piece of RFC2822 mail by grabbing all  * non-indented lines and checking if they look like they begin with valid  * header field names.  *  * Returns 1 if the file looks like a piece of mail, 0 otherwise.  */
end_comment
begin_function
DECL|function|is_mail
specifier|static
name|int
name|is_mail
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|header_regex
init|=
literal|"^[!-9;-~]+:"
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|regex_t
name|regex
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"fseek failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|regex
argument_list|,
name|header_regex
argument_list|,
name|REG_NOSUB
operator||
name|REG_EXTENDED
argument_list|)
condition|)
name|die
argument_list|(
literal|"invalid pattern: %s"
argument_list|,
name|header_regex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline_crlf
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|sb
operator|.
name|len
condition|)
break|break;
comment|/* End of header */
comment|/* Ignore indented folded lines */
if|if
condition|(
operator|*
name|sb
operator|.
name|buf
operator|==
literal|'\t'
operator|||
operator|*
name|sb
operator|.
name|buf
operator|==
literal|' '
condition|)
continue|continue;
comment|/* It's a header if it matches header_regex */
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|regex
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|regfree
argument_list|(
operator|&
name|regex
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Attempts to detect the patch_format of the patches contained in `paths`,  * returning the PATCH_FORMAT_* enum value. Returns PATCH_FORMAT_UNKNOWN if  * detection fails.  */
end_comment
begin_function
DECL|function|detect_patch_format
specifier|static
name|int
name|detect_patch_format
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|)
block|{
name|enum
name|patch_format
name|ret
init|=
name|PATCH_FORMAT_UNKNOWN
decl_stmt|;
name|struct
name|strbuf
name|l1
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|l2
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|l3
init|=
name|STRBUF_INIT
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* 	 * We default to mbox format if input is from stdin and for directories 	 */
if|if
condition|(
operator|!
operator|*
name|paths
operator|||
operator|!
name|strcmp
argument_list|(
operator|*
name|paths
argument_list|,
literal|"-"
argument_list|)
operator|||
name|is_directory
argument_list|(
operator|*
name|paths
argument_list|)
condition|)
return|return
name|PATCH_FORMAT_MBOX
return|;
comment|/* 	 * Otherwise, check the first few lines of the first patch, starting 	 * from the first non-blank line, to try to detect its format. 	 */
name|fp
operator|=
name|xfopen
argument_list|(
operator|*
name|paths
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline_crlf
argument_list|(
operator|&
name|l1
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|l1
operator|.
name|len
condition|)
break|break;
block|}
if|if
condition|(
name|starts_with
argument_list|(
name|l1
operator|.
name|buf
argument_list|,
literal|"From "
argument_list|)
operator|||
name|starts_with
argument_list|(
name|l1
operator|.
name|buf
argument_list|,
literal|"From: "
argument_list|)
condition|)
block|{
name|ret
operator|=
name|PATCH_FORMAT_MBOX
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|starts_with
argument_list|(
name|l1
operator|.
name|buf
argument_list|,
literal|"# This series applies on GIT commit"
argument_list|)
condition|)
block|{
name|ret
operator|=
name|PATCH_FORMAT_STGIT_SERIES
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|l1
operator|.
name|buf
argument_list|,
literal|"# HG changeset patch"
argument_list|)
condition|)
block|{
name|ret
operator|=
name|PATCH_FORMAT_HG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|strbuf_reset
argument_list|(
operator|&
name|l2
argument_list|)
expr_stmt|;
name|strbuf_getline_crlf
argument_list|(
operator|&
name|l2
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|l3
argument_list|)
expr_stmt|;
name|strbuf_getline_crlf
argument_list|(
operator|&
name|l3
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* 	 * If the second line is empty and the third is a From, Author or Date 	 * entry, this is likely an StGit patch. 	 */
if|if
condition|(
name|l1
operator|.
name|len
operator|&&
operator|!
name|l2
operator|.
name|len
operator|&&
operator|(
name|starts_with
argument_list|(
name|l3
operator|.
name|buf
argument_list|,
literal|"From:"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|l3
operator|.
name|buf
argument_list|,
literal|"Author:"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|l3
operator|.
name|buf
argument_list|,
literal|"Date:"
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|PATCH_FORMAT_STGIT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|l1
operator|.
name|len
operator|&&
name|is_mail
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|ret
operator|=
name|PATCH_FORMAT_MBOX
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|l1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Splits out individual email patches from `paths`, where each path is either  * a mbox file or a Maildir. Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|split_mail_mbox
specifier|static
name|int
name|split_mail_mbox
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|,
name|int
name|keep_cr
parameter_list|)
block|{
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|struct
name|strbuf
name|last
init|=
name|STRBUF_INIT
decl_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"mailsplit"
argument_list|)
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"-d%d"
argument_list|,
name|state
operator|->
name|prec
argument_list|)
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"-o%s"
argument_list|,
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"-b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_cr
condition|)
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--keep-cr"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
name|argv_array_pushv
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|capture_command
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|last
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|->
name|cur
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|last
operator|=
name|strtol
argument_list|(
name|last
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Callback signature for split_mail_conv(). The foreign patch should be  * read from `in`, and the converted patch (in RFC2822 mail format) should be  * written to `out`. Return 0 on success, or -1 on failure.  */
end_comment
begin_typedef
DECL|typedef|mail_conv_fn
typedef|typedef
name|int
function_decl|(
modifier|*
name|mail_conv_fn
function_decl|)
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
name|int
name|keep_cr
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/**  * Calls `fn` for each file in `paths` to convert the foreign patch to the  * RFC2822 mail format suitable for parsing with git-mailinfo.  *  * Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|split_mail_conv
specifier|static
name|int
name|split_mail_conv
parameter_list|(
name|mail_conv_fn
name|fn
parameter_list|,
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|,
name|int
name|keep_cr
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|stdin_only
index|[]
init|=
block|{
literal|"-"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|paths
condition|)
name|paths
operator|=
name|stdin_only
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|paths
condition|;
name|paths
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
specifier|const
name|char
modifier|*
name|mail
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|paths
argument_list|,
literal|"-"
argument_list|)
condition|)
name|in
operator|=
name|stdin
expr_stmt|;
else|else
name|in
operator|=
name|fopen
argument_list|(
operator|*
name|paths
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"could not open '%s' for reading: %s"
argument_list|)
argument_list|,
operator|*
name|paths
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
name|mail
operator|=
name|mkpath
argument_list|(
literal|"%s/%0*d"
argument_list|,
name|state
operator|->
name|dir
argument_list|,
name|state
operator|->
name|prec
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|mail
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"could not open '%s' for writing: %s"
argument_list|)
argument_list|,
name|mail
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
name|ret
operator|=
name|fn
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|keep_cr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"could not parse patch '%s'"
argument_list|)
argument_list|,
operator|*
name|paths
argument_list|)
return|;
block|}
name|state
operator|->
name|cur
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|last
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * A split_mail_conv() callback that converts an StGit patch to an RFC2822  * message suitable for parsing with git-mailinfo.  */
end_comment
begin_function
DECL|function|stgit_patch_to_mail
specifier|static
name|int
name|stgit_patch_to_mail
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
name|int
name|keep_cr
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|subject_printed
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|in
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|str_isspace
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Author:"
argument_list|,
operator|&
name|str
argument_list|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"From:%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"From"
argument_list|)
operator|||
name|starts_with
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Date"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|subject_printed
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|subject_printed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n%s\n"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
while|while
condition|(
name|strbuf_fread
argument_list|(
operator|&
name|sb
argument_list|,
literal|8192
argument_list|,
name|in
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * This function only supports a single StGit series file in `paths`.  *  * Given an StGit series file, converts the StGit patches in the series into  * RFC2822 messages suitable for parsing with git-mailinfo, and queues them in  * the state directory.  *  * Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|split_mail_stgit_series
specifier|static
name|int
name|split_mail_stgit_series
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|,
name|int
name|keep_cr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|series_dir
decl_stmt|;
name|char
modifier|*
name|series_dir_buf
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|argv_array
name|patches
init|=
name|ARGV_ARRAY_INIT
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|paths
index|[
literal|0
index|]
operator|||
name|paths
index|[
literal|1
index|]
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Only one StGIT patch series can be applied at once"
argument_list|)
argument_list|)
return|;
name|series_dir_buf
operator|=
name|xstrdup
argument_list|(
operator|*
name|paths
argument_list|)
expr_stmt|;
name|series_dir
operator|=
name|dirname
argument_list|(
name|series_dir_buf
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|paths
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"could not open '%s' for reading: %s"
argument_list|)
argument_list|,
operator|*
name|paths
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
while|while
condition|(
operator|!
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|sb
operator|.
name|buf
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* skip comment lines */
name|argv_array_push
argument_list|(
operator|&
name|patches
argument_list|,
name|mkpath
argument_list|(
literal|"%s/%s"
argument_list|,
name|series_dir
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|series_dir_buf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|split_mail_conv
argument_list|(
name|stgit_patch_to_mail
argument_list|,
name|state
argument_list|,
name|patches
operator|.
name|argv
argument_list|,
name|keep_cr
argument_list|)
expr_stmt|;
name|argv_array_clear
argument_list|(
operator|&
name|patches
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * A split_patches_conv() callback that converts a mercurial patch to a RFC2822  * message suitable for parsing with git-mailinfo.  */
end_comment
begin_function
DECL|function|hg_patch_to_mail
specifier|static
name|int
name|hg_patch_to_mail
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
name|int
name|keep_cr
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|in
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"# User "
argument_list|,
operator|&
name|str
argument_list|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"From: %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"# Date "
argument_list|,
operator|&
name|str
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|timestamp
decl_stmt|;
name|long
name|tz
decl_stmt|,
name|tz2
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|timestamp
operator|=
name|strtoul
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid timestamp"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|end
argument_list|,
literal|" "
argument_list|,
operator|&
name|str
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid Date line"
argument_list|)
argument_list|)
return|;
name|errno
operator|=
literal|0
expr_stmt|;
name|tz
operator|=
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid timezone offset"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|*
name|end
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid Date line"
argument_list|)
argument_list|)
return|;
comment|/* 			 * mercurial's timezone is in seconds west of UTC, 			 * however git's timezone is in hours + minutes east of 			 * UTC. Convert it. 			 */
name|tz2
operator|=
name|labs
argument_list|(
name|tz
argument_list|)
operator|/
literal|3600
operator|*
literal|100
operator|+
name|labs
argument_list|(
name|tz
argument_list|)
operator|%
literal|3600
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|tz
operator|>
literal|0
condition|)
name|tz2
operator|=
operator|-
name|tz2
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|show_date
argument_list|(
name|timestamp
argument_list|,
name|tz2
argument_list|,
name|DATE_MODE
argument_list|(
name|RFC2822
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"# "
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n%s\n"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
while|while
condition|(
name|strbuf_fread
argument_list|(
operator|&
name|sb
argument_list|,
literal|8192
argument_list|,
name|in
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Splits a list of files/directories into individual email patches. Each path  * in `paths` must be a file/directory that is formatted according to  * `patch_format`.  *  * Once split out, the individual email patches will be stored in the state  * directory, with each patch's filename being its index, padded to state->prec  * digits.  *  * state->cur will be set to the index of the first mail, and state->last will  * be set to the index of the last mail.  *  * Set keep_cr to 0 to convert all lines ending with \r\n to end with \n, 1  * to disable this behavior, -1 to use the default configured setting.  *  * Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|split_mail
specifier|static
name|int
name|split_mail
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|enum
name|patch_format
name|patch_format
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|,
name|int
name|keep_cr
parameter_list|)
block|{
if|if
condition|(
name|keep_cr
operator|<
literal|0
condition|)
block|{
name|keep_cr
operator|=
literal|0
expr_stmt|;
name|git_config_get_bool
argument_list|(
literal|"am.keepcr"
argument_list|,
operator|&
name|keep_cr
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|patch_format
condition|)
block|{
case|case
name|PATCH_FORMAT_MBOX
case|:
return|return
name|split_mail_mbox
argument_list|(
name|state
argument_list|,
name|paths
argument_list|,
name|keep_cr
argument_list|)
return|;
case|case
name|PATCH_FORMAT_STGIT
case|:
return|return
name|split_mail_conv
argument_list|(
name|stgit_patch_to_mail
argument_list|,
name|state
argument_list|,
name|paths
argument_list|,
name|keep_cr
argument_list|)
return|;
case|case
name|PATCH_FORMAT_STGIT_SERIES
case|:
return|return
name|split_mail_stgit_series
argument_list|(
name|state
argument_list|,
name|paths
argument_list|,
name|keep_cr
argument_list|)
return|;
case|case
name|PATCH_FORMAT_HG
case|:
return|return
name|split_mail_conv
argument_list|(
name|hg_patch_to_mail
argument_list|,
name|state
argument_list|,
name|paths
argument_list|,
name|keep_cr
argument_list|)
return|;
default|default:
name|die
argument_list|(
literal|"BUG: invalid patch_format"
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/**  * Setup a new am session for applying patches  */
end_comment
begin_function
DECL|function|am_setup
specifier|static
name|void
name|am_setup
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|enum
name|patch_format
name|patch_format
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|,
name|int
name|keep_cr
parameter_list|)
block|{
name|unsigned
name|char
name|curr_head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|patch_format
condition|)
name|patch_format
operator|=
name|detect_patch_format
argument_list|(
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patch_format
condition|)
block|{
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Patch format detection failed."
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|state
operator|->
name|dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to create directory '%s'"
argument_list|)
argument_list|,
name|state
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_mail
argument_list|(
name|state
argument_list|,
name|patch_format
argument_list|,
name|paths
argument_list|,
name|keep_cr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|am_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to split patches."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|rebasing
condition|)
name|state
operator|->
name|threeway
operator|=
literal|1
expr_stmt|;
name|write_state_bool
argument_list|(
name|state
argument_list|,
literal|"threeway"
argument_list|,
name|state
operator|->
name|threeway
argument_list|)
expr_stmt|;
name|write_state_bool
argument_list|(
name|state
argument_list|,
literal|"quiet"
argument_list|,
name|state
operator|->
name|quiet
argument_list|)
expr_stmt|;
name|write_state_bool
argument_list|(
name|state
argument_list|,
literal|"sign"
argument_list|,
name|state
operator|->
name|signoff
argument_list|)
expr_stmt|;
name|write_state_bool
argument_list|(
name|state
argument_list|,
literal|"utf8"
argument_list|,
name|state
operator|->
name|utf8
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|keep
condition|)
block|{
case|case
name|KEEP_FALSE
case|:
name|str
operator|=
literal|"f"
expr_stmt|;
break|break;
case|case
name|KEEP_TRUE
case|:
name|str
operator|=
literal|"t"
expr_stmt|;
break|break;
case|case
name|KEEP_NON_PATCH
case|:
name|str
operator|=
literal|"b"
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"BUG: invalid value for state->keep"
argument_list|)
expr_stmt|;
block|}
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"keep"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|write_state_bool
argument_list|(
name|state
argument_list|,
literal|"messageid"
argument_list|,
name|state
operator|->
name|message_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|scissors
condition|)
block|{
case|case
name|SCISSORS_UNSET
case|:
name|str
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SCISSORS_FALSE
case|:
name|str
operator|=
literal|"f"
expr_stmt|;
break|break;
case|case
name|SCISSORS_TRUE
case|:
name|str
operator|=
literal|"t"
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"BUG: invalid value for state->scissors"
argument_list|)
expr_stmt|;
block|}
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"scissors"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sq_quote_argv
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|git_apply_opts
operator|.
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"apply-opt"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|rebasing
condition|)
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"rebasing"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"applying"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|curr_head
argument_list|)
condition|)
block|{
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"abort-safety"
argument_list|,
name|sha1_to_hex
argument_list|(
name|curr_head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|rebasing
condition|)
name|update_ref
argument_list|(
literal|"am"
argument_list|,
literal|"ORIG_HEAD"
argument_list|,
name|curr_head
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"abort-safety"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|rebasing
condition|)
name|delete_ref
argument_list|(
literal|"ORIG_HEAD"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * NOTE: Since the "next" and "last" files determine if an am_state 	 * session is in progress, they should be written last. 	 */
name|write_state_count
argument_list|(
name|state
argument_list|,
literal|"next"
argument_list|,
name|state
operator|->
name|cur
argument_list|)
expr_stmt|;
name|write_state_count
argument_list|(
name|state
argument_list|,
literal|"last"
argument_list|,
name|state
operator|->
name|last
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Increments the patch pointer, and cleans am_state for the application of the  * next patch.  */
end_comment
begin_function
DECL|function|am_next
specifier|static
name|void
name|am_next
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|char
name|head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_name
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_email
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_date
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|msg_len
operator|=
literal|0
expr_stmt|;
name|unlink
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|state
operator|->
name|orig_commit
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"original-commit"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"abort-safety"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"abort-safety"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|state
operator|->
name|cur
operator|++
expr_stmt|;
name|write_state_count
argument_list|(
name|state
argument_list|,
literal|"next"
argument_list|,
name|state
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns the filename of the current patch email.  */
end_comment
begin_function
DECL|function|msgnum
specifier|static
specifier|const
name|char
modifier|*
name|msgnum
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%0*d"
argument_list|,
name|state
operator|->
name|prec
argument_list|,
name|state
operator|->
name|cur
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|buf
return|;
block|}
end_function
begin_comment
comment|/**  * Refresh and write index.  */
end_comment
begin_function
DECL|function|refresh_and_write_cache
specifier|static
name|void
name|refresh_and_write_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock_file
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|lock_file
argument_list|,
name|COMMIT_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write index file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns 1 if the index differs from HEAD, 0 otherwise. When on an unborn  * branch, returns 1 if there are entries in the index, 0 otherwise. If an  * strbuf is provided, the space-separated list of files that differ will be  * appended to it.  */
end_comment
begin_function
DECL|function|index_has_changes
specifier|static
name|int
name|index_has_changes
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|unsigned
name|char
name|head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|get_sha1_tree
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
block|{
name|struct
name|diff_options
name|opt
decl_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|EXIT_WITH_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sb
condition|)
name|DIFF_OPT_SET
argument_list|(
operator|&
name|opt
argument_list|,
name|QUICK
argument_list|)
expr_stmt|;
name|do_diff_cache
argument_list|(
name|head
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sb
operator|&&
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
return|return
name|DIFF_OPT_TST
argument_list|(
operator|&
name|opt
argument_list|,
name|HAS_CHANGES
argument_list|)
operator|!=
literal|0
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sb
operator|&&
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|active_cache
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
operator|!
name|active_nr
return|;
block|}
block|}
end_function
begin_comment
comment|/**  * Dies with a user-friendly message on how to proceed after resolving the  * problem. This message can be overridden with state->resolvemsg.  */
end_comment
begin_function
DECL|function|die_user_resolve
specifier|static
name|void
name|NORETURN
name|die_user_resolve
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|resolvemsg
condition|)
block|{
name|printf_ln
argument_list|(
literal|"%s"
argument_list|,
name|state
operator|->
name|resolvemsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|cmdline
init|=
name|state
operator|->
name|interactive
condition|?
literal|"git am -i"
else|:
literal|"git am"
decl_stmt|;
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"When you have resolved this problem, run \"%s --continue\"."
argument_list|)
argument_list|,
name|cmdline
argument_list|)
expr_stmt|;
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"If you prefer to skip this patch, run \"%s --skip\" instead."
argument_list|)
argument_list|,
name|cmdline
argument_list|)
expr_stmt|;
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"To restore the original branch and stop patching, run \"%s --abort\"."
argument_list|)
argument_list|,
name|cmdline
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|am_signoff
specifier|static
name|void
name|am_signoff
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|strbuf
name|mine
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* Does it end with our own sign-off? */
name|strbuf_addf
argument_list|(
operator|&
name|mine
argument_list|,
literal|"\n%s%s\n"
argument_list|,
name|sign_off_header
argument_list|,
name|fmt_name
argument_list|(
name|getenv
argument_list|(
literal|"GIT_COMMITTER_NAME"
argument_list|)
argument_list|,
name|getenv
argument_list|(
literal|"GIT_COMMITTER_EMAIL"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mine
operator|.
name|len
operator|<
name|sb
operator|->
name|len
operator|&&
operator|!
name|strcmp
argument_list|(
name|mine
operator|.
name|buf
argument_list|,
name|sb
operator|->
name|buf
operator|+
name|sb
operator|->
name|len
operator|-
name|mine
operator|.
name|len
argument_list|)
condition|)
goto|goto
name|exit
goto|;
comment|/* no need to duplicate */
comment|/* Does it have any Signed-off-by: in the text */
for|for
control|(
name|cp
operator|=
name|sb
operator|->
name|buf
init|;
name|cp
operator|&&
operator|*
name|cp
operator|&&
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|cp
argument_list|,
name|sign_off_header
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
control|)
block|{
if|if
condition|(
name|sb
operator|->
name|buf
operator|==
name|cp
operator|||
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|mine
operator|.
name|buf
operator|+
operator|!
operator|!
name|cp
argument_list|)
expr_stmt|;
name|exit
label|:
name|strbuf_release
argument_list|(
operator|&
name|mine
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Appends signoff to the "msg" field of the am_state.  */
end_comment
begin_function
DECL|function|am_append_signoff
specifier|static
name|void
name|am_append_signoff
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_attach
argument_list|(
operator|&
name|sb
argument_list|,
name|state
operator|->
name|msg
argument_list|,
name|state
operator|->
name|msg_len
argument_list|,
name|state
operator|->
name|msg_len
argument_list|)
expr_stmt|;
name|am_signoff
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|state
operator|->
name|msg_len
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Parses `mail` using git-mailinfo, extracting its patch and authorship info.  * state->msg will be set to the patch message. state->author_name,  * state->author_email and state->author_date will be set to the patch author's  * name, email and date respectively. The patch body will be written to the  * state directory's "patch" file.  *  * Returns 1 if the patch should be skipped, 0 otherwise.  */
end_comment
begin_function
DECL|function|parse_mail
specifier|static
name|int
name|parse_mail
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|mail
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|author_name
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|author_date
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|author_email
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mailinfo
name|mi
decl_stmt|;
name|setup_mailinfo
argument_list|(
operator|&
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|utf8
condition|)
name|mi
operator|.
name|metainfo_charset
operator|=
name|get_commit_output_encoding
argument_list|()
expr_stmt|;
else|else
name|mi
operator|.
name|metainfo_charset
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|keep
condition|)
block|{
case|case
name|KEEP_FALSE
case|:
break|break;
case|case
name|KEEP_TRUE
case|:
name|mi
operator|.
name|keep_subject
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEEP_NON_PATCH
case|:
name|mi
operator|.
name|keep_non_patch_brackets_in_subject
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"BUG: invalid value for state->keep"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|message_id
condition|)
name|mi
operator|.
name|add_message_id
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|scissors
condition|)
block|{
case|case
name|SCISSORS_UNSET
case|:
break|break;
case|case
name|SCISSORS_FALSE
case|:
name|mi
operator|.
name|use_scissors
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCISSORS_TRUE
case|:
name|mi
operator|.
name|use_scissors
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"BUG: invalid value for state->scissors"
argument_list|)
expr_stmt|;
block|}
name|mi
operator|.
name|input
operator|=
name|fopen
argument_list|(
name|mail
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mi
operator|.
name|input
condition|)
name|die
argument_list|(
literal|"could not open input"
argument_list|)
expr_stmt|;
name|mi
operator|.
name|output
operator|=
name|fopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"info"
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mi
operator|.
name|output
condition|)
name|die
argument_list|(
literal|"could not open output 'info'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mailinfo
argument_list|(
operator|&
name|mi
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"msg"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse patch"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mi
operator|.
name|input
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mi
operator|.
name|output
argument_list|)
expr_stmt|;
comment|/* Extract message and author information */
name|fp
operator|=
name|xfopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"info"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Subject: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|msg
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msg
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Author: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|author_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Email: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|author_email
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"Date: "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|author_date
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Skip pine's internal folder data */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|author_name
operator|.
name|buf
argument_list|,
literal|"Mail System Internal Data"
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|is_empty_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
condition|)
block|{
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"Patch is empty. Was it split wrong?"
argument_list|)
argument_list|)
expr_stmt|;
name|die_user_resolve
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|msg
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|msg
argument_list|,
operator|&
name|mi
operator|.
name|log_message
argument_list|)
expr_stmt|;
name|strbuf_stripspace
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|signoff
condition|)
name|am_signoff
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_name
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|author_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_email
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|author_email
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_date
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|author_date
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|msg
argument_list|,
operator|&
name|state
operator|->
name|msg_len
argument_list|)
expr_stmt|;
name|finish
label|:
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|author_date
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|author_email
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|author_name
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|clear_mailinfo
argument_list|(
operator|&
name|mi
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * Sets commit_id to the commit hash where the mail was generated from.  * Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|get_mail_commit_sha1
specifier|static
name|int
name|get_mail_commit_sha1
parameter_list|(
name|unsigned
name|char
modifier|*
name|commit_id
parameter_list|,
specifier|const
name|char
modifier|*
name|mail
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|xfopen
argument_list|(
name|mail
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|sb
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"From "
argument_list|,
operator|&
name|x
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|x
argument_list|,
name|commit_id
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Sets state->msg, state->author_name, state->author_email, state->author_date  * to the commit's respective info.  */
end_comment
begin_function
DECL|function|get_commit_info
specifier|static
name|void
name|get_commit_info
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|ident_line
decl_stmt|,
modifier|*
name|author_date
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|size_t
name|ident_len
decl_stmt|;
name|struct
name|ident_split
name|ident_split
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|buffer
operator|=
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|,
name|get_commit_output_encoding
argument_list|()
argument_list|)
expr_stmt|;
name|ident_line
operator|=
name|find_commit_header
argument_list|(
name|buffer
argument_list|,
literal|"author"
argument_list|,
operator|&
name|ident_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|ident_split
argument_list|,
name|ident_line
argument_list|,
name|ident_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|ident_line
argument_list|,
name|ident_len
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"invalid ident line: %s"
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_split
operator|.
name|name_begin
condition|)
block|{
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|ident_split
operator|.
name|name_begin
argument_list|,
name|ident_split
operator|.
name|name_end
operator|-
name|ident_split
operator|.
name|name_begin
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_name
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|state
operator|->
name|author_name
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_email
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_split
operator|.
name|mail_begin
condition|)
block|{
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|ident_split
operator|.
name|mail_begin
argument_list|,
name|ident_split
operator|.
name|mail_end
operator|-
name|ident_split
operator|.
name|mail_begin
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_email
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|state
operator|->
name|author_email
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|author_date
operator|=
name|show_ident_date
argument_list|(
operator|&
name|ident_split
argument_list|,
name|DATE_MODE
argument_list|(
name|NORMAL
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|author_date
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|author_date
argument_list|)
expr_stmt|;
name|state
operator|->
name|author_date
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to parse commit %s"
argument_list|)
argument_list|,
name|oid_to_hex
argument_list|(
operator|&
name|commit
operator|->
name|object
operator|.
name|oid
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|xstrdup
argument_list|(
name|msg
operator|+
literal|2
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg_len
operator|=
name|strlen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Writes `commit` as a patch to the state directory's "patch" file.  */
end_comment
begin_function
DECL|function|write_commit_patch
specifier|static
name|void
name|write_commit_patch
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|rev_info
name|rev_info
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev_info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev_info
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev_info
operator|.
name|abbrev
operator|=
literal|0
expr_stmt|;
name|rev_info
operator|.
name|disable_stdin
operator|=
literal|1
expr_stmt|;
name|rev_info
operator|.
name|show_root_diff
operator|=
literal|1
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_PATCH
expr_stmt|;
name|rev_info
operator|.
name|no_commit_id
operator|=
literal|1
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev_info
operator|.
name|diffopt
argument_list|,
name|BINARY
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev_info
operator|.
name|diffopt
argument_list|,
name|FULL_INDEX
argument_list|)
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|use_color
operator|=
literal|0
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|file
operator|=
name|fp
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|close_file
operator|=
literal|1
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|rev_info
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|rev_info
operator|.
name|diffopt
argument_list|)
expr_stmt|;
name|log_tree_commit
argument_list|(
operator|&
name|rev_info
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Writes the diff of the index against HEAD as a patch to the state  * directory's "patch" file.  */
end_comment
begin_function
DECL|function|write_index_patch
specifier|static
name|void
name|write_index_patch
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|unsigned
name|char
name|head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|struct
name|rev_info
name|rev_info
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|get_sha1_tree
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
name|tree
operator|=
name|lookup_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
name|tree
operator|=
name|lookup_tree
argument_list|(
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev_info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev_info
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev_info
operator|.
name|disable_stdin
operator|=
literal|1
expr_stmt|;
name|rev_info
operator|.
name|no_commit_id
operator|=
literal|1
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_PATCH
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|use_color
operator|=
literal|0
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|file
operator|=
name|fp
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|close_file
operator|=
literal|1
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|rev_info
argument_list|,
operator|&
name|tree
operator|->
name|object
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|rev_info
operator|.
name|diffopt
argument_list|)
expr_stmt|;
name|run_diff_index
argument_list|(
operator|&
name|rev_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Like parse_mail(), but parses the mail by looking up its commit ID  * directly. This is used in --rebasing mode to bypass git-mailinfo's munging  * of patches.  *  * state->orig_commit will be set to the original commit ID.  *  * Will always return 0 as the patch should never be skipped.  */
end_comment
begin_function
DECL|function|parse_mail_rebase
specifier|static
name|int
name|parse_mail_rebase
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|mail
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|unsigned
name|char
name|commit_sha1
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
if|if
condition|(
name|get_mail_commit_sha1
argument_list|(
name|commit_sha1
argument_list|,
name|mail
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse %s"
argument_list|)
argument_list|,
name|mail
argument_list|)
expr_stmt|;
name|commit
operator|=
name|lookup_commit_or_die
argument_list|(
name|commit_sha1
argument_list|,
name|mail
argument_list|)
expr_stmt|;
name|get_commit_info
argument_list|(
name|state
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|write_commit_patch
argument_list|(
name|state
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|state
operator|->
name|orig_commit
argument_list|,
name|commit_sha1
argument_list|)
expr_stmt|;
name|write_state_text
argument_list|(
name|state
argument_list|,
literal|"original-commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit_sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Applies current patch with git-apply. Returns 0 on success, -1 otherwise. If  * `index_file` is not NULL, the patch will be applied to that index.  */
end_comment
begin_function
DECL|function|run_apply
specifier|static
name|int
name|run_apply
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|index_file
parameter_list|)
block|{
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|index_file
condition|)
name|argv_array_pushf
argument_list|(
operator|&
name|cp
operator|.
name|env_array
argument_list|,
literal|"GIT_INDEX_FILE=%s"
argument_list|,
name|index_file
argument_list|)
expr_stmt|;
comment|/* 	 * If we are allowed to fall back on 3-way merge, don't give false 	 * errors during the initial attempt. 	 */
if|if
condition|(
name|state
operator|->
name|threeway
operator|&&
operator|!
name|index_file
condition|)
block|{
name|cp
operator|.
name|no_stdout
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|no_stderr
operator|=
literal|1
expr_stmt|;
block|}
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"apply"
argument_list|)
expr_stmt|;
name|argv_array_pushv
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|state
operator|->
name|git_apply_opts
operator|.
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_file
condition|)
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--cached"
argument_list|)
expr_stmt|;
else|else
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--index"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Reload index as git-apply will have modified it. */
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|index_file
condition|?
name|index_file
else|:
name|get_index_file
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Builds an index that contains just the blobs needed for a 3way merge.  */
end_comment
begin_function
DECL|function|build_fake_ancestor
specifier|static
name|int
name|build_fake_ancestor
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|index_file
parameter_list|)
block|{
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"apply"
argument_list|)
expr_stmt|;
name|argv_array_pushv
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|state
operator|->
name|git_apply_opts
operator|.
name|argv
argument_list|)
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--build-fake-ancestor=%s"
argument_list|,
name|index_file
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Do the three-way merge using fake ancestor, his tree constructed  * from the fake ancestor and the postimage of the patch, and our  * state.  */
end_comment
begin_function
DECL|function|run_fallback_merge_recursive
specifier|static
name|int
name|run_fallback_merge_recursive
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|unsigned
name|char
modifier|*
name|orig_tree
parameter_list|,
name|unsigned
name|char
modifier|*
name|our_tree
parameter_list|,
name|unsigned
name|char
modifier|*
name|his_tree
parameter_list|)
block|{
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|int
name|status
decl_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|cp
operator|.
name|env_array
argument_list|,
literal|"GITHEAD_%s=%.*s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|his_tree
argument_list|)
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|quiet
condition|)
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|env_array
argument_list|,
literal|"GIT_MERGE_VERBOSITY=0"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"merge-recursive"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|sha1_to_hex
argument_list|(
name|orig_tree
argument_list|)
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|sha1_to_hex
argument_list|(
name|our_tree
argument_list|)
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|sha1_to_hex
argument_list|(
name|his_tree
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
condition|?
operator|(
operator|-
literal|1
operator|)
else|:
literal|0
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_comment
comment|/**  * Attempt a threeway merge, using index_path as the temporary index.  */
end_comment
begin_function
DECL|function|fall_back_threeway
specifier|static
name|int
name|fall_back_threeway
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|index_path
parameter_list|)
block|{
name|unsigned
name|char
name|orig_tree
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|his_tree
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|our_tree
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|our_tree
argument_list|)
operator|<
literal|0
condition|)
name|hashcpy
argument_list|(
name|our_tree
argument_list|,
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_fake_ancestor
argument_list|(
name|state
argument_list|,
name|index_path
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"could not build fake ancestor"
argument_list|)
return|;
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|index_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_index_as_tree
argument_list|(
name|orig_tree
argument_list|,
operator|&
name|the_index
argument_list|,
name|index_path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Repository lacks necessary blobs to fall back on 3-way merge."
argument_list|)
argument_list|)
return|;
name|say
argument_list|(
name|state
argument_list|,
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Using index info to reconstruct a base tree..."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|quiet
condition|)
block|{
comment|/* 		 * List paths that needed 3-way fallback, so that the user can 		 * review them with extra care to spot mismerges. 		 */
name|struct
name|rev_info
name|rev_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|diff_filter_str
init|=
literal|"--diff-filter=AM"
decl_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev_info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev_info
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NAME_STATUS
expr_stmt|;
name|diff_opt_parse
argument_list|(
operator|&
name|rev_info
operator|.
name|diffopt
argument_list|,
operator|&
name|diff_filter_str
argument_list|,
literal|1
argument_list|,
name|rev_info
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|add_pending_sha1
argument_list|(
operator|&
name|rev_info
argument_list|,
literal|"HEAD"
argument_list|,
name|our_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|rev_info
operator|.
name|diffopt
argument_list|)
expr_stmt|;
name|run_diff_index
argument_list|(
operator|&
name|rev_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|run_apply
argument_list|(
name|state
argument_list|,
name|index_path
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Did you hand edit your patch?\n"
literal|"It does not apply to blobs recorded in its index."
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|write_index_as_tree
argument_list|(
name|his_tree
argument_list|,
operator|&
name|the_index
argument_list|,
name|index_path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"could not write tree"
argument_list|)
return|;
name|say
argument_list|(
name|state
argument_list|,
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Falling back to patching base and 3-way merge..."
argument_list|)
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
comment|/* 	 * This is not so wrong. Depending on which base we picked, orig_tree 	 * may be wildly different from ours, but his_tree has the same set of 	 * wildly different changes in parts the patch did not touch, so 	 * recursive ends up canceling them, saying that we reverted all those 	 * changes. 	 */
if|if
condition|(
name|run_fallback_merge_recursive
argument_list|(
name|state
argument_list|,
name|orig_tree
argument_list|,
name|our_tree
argument_list|,
name|his_tree
argument_list|)
condition|)
block|{
name|rerere
argument_list|(
name|state
operator|->
name|allow_rerere_autoupdate
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to merge in the changes."
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Commits the current index with state->msg as the commit message and  * state->author_name, state->author_email and state->author_date as the author  * information.  */
end_comment
begin_function
DECL|function|do_commit
specifier|static
name|void
name|do_commit
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|char
name|tree
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|parent
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|commit
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|reflog_msg
decl_stmt|,
modifier|*
name|author
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|run_hook_le
argument_list|(
name|NULL
argument_list|,
literal|"pre-applypatch"
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache_as_tree
argument_list|(
name|tree
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git write-tree failed to write a tree"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sha1_commit
argument_list|(
literal|"HEAD"
argument_list|,
name|parent
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|parent
expr_stmt|;
name|commit_list_insert
argument_list|(
name|lookup_commit
argument_list|(
name|parent
argument_list|)
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|NULL
expr_stmt|;
name|say
argument_list|(
name|state
argument_list|,
name|stderr
argument_list|,
name|_
argument_list|(
literal|"applying to an empty history"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|author
operator|=
name|fmt_ident
argument_list|(
name|state
operator|->
name|author_name
argument_list|,
name|state
operator|->
name|author_email
argument_list|,
name|state
operator|->
name|ignore_date
condition|?
name|NULL
else|:
name|state
operator|->
name|author_date
argument_list|,
name|IDENT_STRICT
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|committer_date_is_author_date
condition|)
name|setenv
argument_list|(
literal|"GIT_COMMITTER_DATE"
argument_list|,
name|state
operator|->
name|ignore_date
condition|?
literal|""
else|:
name|state
operator|->
name|author_date
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_tree
argument_list|(
name|state
operator|->
name|msg
argument_list|,
name|state
operator|->
name|msg_len
argument_list|,
name|tree
argument_list|,
name|parents
argument_list|,
name|commit
argument_list|,
name|author
argument_list|,
name|state
operator|->
name|sign_commit
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to write commit object"
argument_list|)
argument_list|)
expr_stmt|;
name|reflog_msg
operator|=
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reflog_msg
condition|)
name|reflog_msg
operator|=
literal|"am"
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s: %.*s"
argument_list|,
name|reflog_msg
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|update_ref
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|commit
argument_list|,
name|ptr
argument_list|,
literal|0
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|rebasing
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|xfopen
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"rewritten"
argument_list|)
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
operator|!
name|is_null_sha1
argument_list|(
name|state
operator|->
name|orig_commit
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|sha1_to_hex
argument_list|(
name|state
operator|->
name|orig_commit
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|run_hook_le
argument_list|(
name|NULL
argument_list|,
literal|"post-applypatch"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Validates the am_state for resuming -- the "msg" and authorship fields must  * be filled up.  */
end_comment
begin_function
DECL|function|validate_resume_state
specifier|static
name|void
name|validate_resume_state
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|->
name|msg
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot resume: %s does not exist."
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|author_name
operator|||
operator|!
name|state
operator|->
name|author_email
operator|||
operator|!
name|state
operator|->
name|author_date
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot resume: %s does not exist."
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"author-script"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Interactively prompt the user on whether the current patch should be  * applied.  *  * Returns 0 if the user chooses to apply the patch, 1 if the user chooses to  * skip it.  */
end_comment
begin_function
DECL|function|do_interactive
specifier|static
name|int
name|do_interactive
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|assert
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot be interactive without stdin connected to a terminal."
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|reply
decl_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"Commit Body is:"
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"--------------------------"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"--------------------------"
argument_list|)
expr_stmt|;
comment|/* 		 * TRANSLATORS: Make sure to include [y], [n], [e], [v] and [a] 		 * in your translation. The program will only accept English 		 * input at this point. 		 */
name|reply
operator|=
name|git_prompt
argument_list|(
name|_
argument_list|(
literal|"Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all: "
argument_list|)
argument_list|,
name|PROMPT_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|reply
operator|==
literal|'y'
operator|||
operator|*
name|reply
operator|==
literal|'Y'
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|reply
operator|==
literal|'a'
operator|||
operator|*
name|reply
operator|==
literal|'A'
condition|)
block|{
name|state
operator|->
name|interactive
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|reply
operator|==
literal|'n'
operator|||
operator|*
name|reply
operator|==
literal|'N'
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|reply
operator|==
literal|'e'
operator|||
operator|*
name|reply
operator|==
literal|'E'
condition|)
block|{
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|launch_editor
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"final-commit"
argument_list|)
argument_list|,
operator|&
name|msg
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|state
operator|->
name|msg
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|msg
argument_list|,
operator|&
name|state
operator|->
name|msg_len
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|reply
operator|==
literal|'v'
operator|||
operator|*
name|reply
operator|==
literal|'V'
condition|)
block|{
specifier|const
name|char
modifier|*
name|pager
init|=
name|git_pager
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|struct
name|child_process
name|cp
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|pager
condition|)
name|pager
operator|=
literal|"cat"
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|pager
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
expr_stmt|;
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/**  * Applies all queued mail.  *  * If `resume` is true, we are "resuming". The "msg" and authorship fields, as  * well as the state directory's "patch" file is used as-is for applying the  * patch and committing it.  */
end_comment
begin_function
DECL|function|am_run
specifier|static
name|void
name|am_run
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|,
name|int
name|resume
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|argv_gc_auto
index|[]
init|=
block|{
literal|"gc"
block|,
literal|"--auto"
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|unlink
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"dirtyindex"
argument_list|)
argument_list|)
expr_stmt|;
name|refresh_and_write_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|index_has_changes
argument_list|(
operator|&
name|sb
argument_list|)
condition|)
block|{
name|write_state_bool
argument_list|(
name|state
argument_list|,
literal|"dirtyindex"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"Dirty index: cannot apply patches (dirty: %s)"
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|cur
operator|<=
name|state
operator|->
name|last
condition|)
block|{
specifier|const
name|char
modifier|*
name|mail
init|=
name|am_path
argument_list|(
name|state
argument_list|,
name|msgnum
argument_list|(
name|state
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|apply_status
decl_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|mail
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|resume
condition|)
block|{
name|validate_resume_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|skip
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|rebasing
condition|)
name|skip
operator|=
name|parse_mail_rebase
argument_list|(
name|state
argument_list|,
name|mail
argument_list|)
expr_stmt|;
else|else
name|skip
operator|=
name|parse_mail
argument_list|(
name|state
argument_list|,
name|mail
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
goto|goto
name|next
goto|;
comment|/* mail should be skipped */
name|write_author_script
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|write_commit_msg
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|interactive
operator|&&
name|do_interactive
argument_list|(
name|state
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|run_applypatch_msg_hook
argument_list|(
name|state
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|say
argument_list|(
name|state
argument_list|,
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Applying: %.*s"
argument_list|)
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|apply_status
operator|=
name|run_apply
argument_list|(
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_status
operator|&&
name|state
operator|->
name|threeway
condition|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch-merge-index"
argument_list|)
argument_list|)
expr_stmt|;
name|apply_status
operator|=
name|fall_back_threeway
argument_list|(
name|state
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
comment|/* 			 * Applying the patch to an earlier tree and merging 			 * the result may have produced the same tree as ours. 			 */
if|if
condition|(
operator|!
name|apply_status
operator|&&
operator|!
name|index_has_changes
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
name|say
argument_list|(
name|state
argument_list|,
name|stdout
argument_list|,
name|_
argument_list|(
literal|"No changes -- Patch already applied."
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
if|if
condition|(
name|apply_status
condition|)
block|{
name|int
name|advice_amworkdir
init|=
literal|1
decl_stmt|;
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"Patch failed at %s %.*s"
argument_list|)
argument_list|,
name|msgnum
argument_list|(
name|state
argument_list|)
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
name|git_config_get_bool
argument_list|(
literal|"advice.amworkdir"
argument_list|,
operator|&
name|advice_amworkdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_amworkdir
condition|)
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"The copy of the patch that failed is found in: %s"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"patch"
argument_list|)
argument_list|)
expr_stmt|;
name|die_user_resolve
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|do_commit
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|next
label|:
name|am_next
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|resume
condition|)
name|am_load
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|resume
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_empty_file
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"rewritten"
argument_list|)
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|state
operator|->
name|rebasing
argument_list|)
expr_stmt|;
name|copy_notes_for_rebase
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|run_post_rewrite_hook
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In rebasing mode, it's up to the caller to take care of 	 * housekeeping. 	 */
if|if
condition|(
operator|!
name|state
operator|->
name|rebasing
condition|)
block|{
name|am_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|close_all_packs
argument_list|()
expr_stmt|;
name|run_command_v_opt
argument_list|(
name|argv_gc_auto
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/**  * Resume the current am session after patch application failure. The user did  * all the hard work, and we do not have to do any patch application. Just  * trust and commit what the user has in the index and working tree.  */
end_comment
begin_function
DECL|function|am_resolve
specifier|static
name|void
name|am_resolve
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|validate_resume_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|say
argument_list|(
name|state
argument_list|,
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Applying: %.*s"
argument_list|)
argument_list|,
name|linelen
argument_list|(
name|state
operator|->
name|msg
argument_list|)
argument_list|,
name|state
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index_has_changes
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"No changes - did you forget to use 'git add'?\n"
literal|"If there is nothing left to stage, chances are that something else\n"
literal|"already introduced the same changes; you might want to skip this patch."
argument_list|)
argument_list|)
expr_stmt|;
name|die_user_resolve
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|printf_ln
argument_list|(
name|_
argument_list|(
literal|"You still have unmerged paths in your index.\n"
literal|"Did you forget to use 'git add'?"
argument_list|)
argument_list|)
expr_stmt|;
name|die_user_resolve
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|interactive
condition|)
block|{
name|write_index_patch
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_interactive
argument_list|(
name|state
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
name|rerere
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|do_commit
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|next
label|:
name|am_next
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|am_load
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|am_run
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Performs a checkout fast-forward from `head` to `remote`. If `reset` is  * true, any unmerged entries will be discarded. Returns 0 on success, -1 on  * failure.  */
end_comment
begin_function
DECL|function|fast_forward_to
specifier|static
name|int
name|fast_forward_to
parameter_list|(
name|struct
name|tree
modifier|*
name|head
parameter_list|,
name|struct
name|tree
modifier|*
name|remote
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock_file
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|t
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|parse_tree
argument_list|(
name|head
argument_list|)
operator|||
name|parse_tree
argument_list|(
name|remote
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|lock_file
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
expr_stmt|;
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|reset
operator|=
name|reset
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|twoway_merge
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
index|[
literal|0
index|]
argument_list|,
name|head
operator|->
name|buffer
argument_list|,
name|head
operator|->
name|size
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
index|[
literal|1
index|]
argument_list|,
name|remote
operator|->
name|buffer
argument_list|,
name|remote
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_trees
argument_list|(
literal|2
argument_list|,
name|t
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
block|{
name|rollback_lock_file
argument_list|(
name|lock_file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|lock_file
argument_list|,
name|COMMIT_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Merges a tree into the index. The index's stat info will take precedence  * over the merged tree's. Returns 0 on success, -1 on failure.  */
end_comment
begin_function
DECL|function|merge_tree
specifier|static
name|int
name|merge_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock_file
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|t
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|parse_tree
argument_list|(
name|tree
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|lock_file
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
expr_stmt|;
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
index|[
literal|0
index|]
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_trees
argument_list|(
literal|1
argument_list|,
name|t
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
block|{
name|rollback_lock_file
argument_list|(
name|lock_file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|lock_file
argument_list|,
name|COMMIT_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Clean the index without touching entries that are not modified between  * `head` and `remote`.  */
end_comment
begin_function
DECL|function|clean_index
specifier|static
name|int
name|clean_index
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|remote
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|head_tree
decl_stmt|,
modifier|*
name|remote_tree
decl_stmt|,
modifier|*
name|index_tree
decl_stmt|;
name|unsigned
name|char
name|index
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|head_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head_tree
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse object '%s'."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
argument_list|)
argument_list|)
return|;
name|remote_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_tree
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse object '%s'."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote
argument_list|)
argument_list|)
return|;
name|read_cache_unmerged
argument_list|()
expr_stmt|;
if|if
condition|(
name|fast_forward_to
argument_list|(
name|head_tree
argument_list|,
name|head_tree
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|write_cache_as_tree
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|index_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index_tree
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not parse object '%s'."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|fast_forward_to
argument_list|(
name|index_tree
argument_list|,
name|remote_tree
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|merge_tree
argument_list|(
name|remote_tree
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|remove_branch_state
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Resets rerere's merge resolution metadata.  */
end_comment
begin_function
DECL|function|am_rerere_clear
specifier|static
name|void
name|am_rerere_clear
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|string_list
name|merge_rr
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
name|rerere_clear
argument_list|(
operator|&
name|merge_rr
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|merge_rr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Resume the current am session by skipping the current patch.  */
end_comment
begin_function
DECL|function|am_skip
specifier|static
name|void
name|am_skip
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|char
name|head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|am_rerere_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|head
argument_list|,
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|clean_index
argument_list|(
name|head
argument_list|,
name|head
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to clean index"
argument_list|)
argument_list|)
expr_stmt|;
name|am_next
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|am_load
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|am_run
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * Returns true if it is safe to reset HEAD to the ORIG_HEAD, false otherwise.  *  * It is not safe to reset HEAD when:  * 1. git-am previously failed because the index was dirty.  * 2. HEAD has moved since git-am previously failed.  */
end_comment
begin_function
DECL|function|safe_to_abort
specifier|static
name|int
name|safe_to_abort
parameter_list|(
specifier|const
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|abort_safety
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|am_path
argument_list|(
name|state
argument_list|,
literal|"dirtyindex"
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|read_state_file
argument_list|(
operator|&
name|sb
argument_list|,
name|state
argument_list|,
literal|"abort-safety"
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|abort_safety
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse %s"
argument_list|)
argument_list|,
name|am_path
argument_list|(
name|state
argument_list|,
literal|"abort_safety"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|hashclr
argument_list|(
name|abort_safety
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
name|hashclr
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|head
argument_list|,
name|abort_safety
argument_list|)
condition|)
return|return
literal|1
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"You seem to have moved HEAD since the last 'am' failure.\n"
literal|"Not rewinding to ORIG_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/**  * Aborts the current am session if it is safe to do so.  */
end_comment
begin_function
DECL|function|am_abort
specifier|static
name|void
name|am_abort
parameter_list|(
name|struct
name|am_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|char
name|curr_head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|,
name|orig_head
index|[
name|GIT_SHA1_RAWSZ
index|]
decl_stmt|;
name|int
name|has_curr_head
decl_stmt|,
name|has_orig_head
decl_stmt|;
name|char
modifier|*
name|curr_branch
decl_stmt|;
if|if
condition|(
operator|!
name|safe_to_abort
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|am_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|am_rerere_clear
argument_list|()
expr_stmt|;
name|curr_branch
operator|=
name|resolve_refdup
argument_list|(
literal|"HEAD"
argument_list|,
literal|0
argument_list|,
name|curr_head
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|has_curr_head
operator|=
operator|!
name|is_null_sha1
argument_list|(
name|curr_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_curr_head
condition|)
name|hashcpy
argument_list|(
name|curr_head
argument_list|,
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
name|has_orig_head
operator|=
operator|!
name|get_sha1
argument_list|(
literal|"ORIG_HEAD"
argument_list|,
name|orig_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_orig_head
condition|)
name|hashcpy
argument_list|(
name|orig_head
argument_list|,
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
name|clean_index
argument_list|(
name|curr_head
argument_list|,
name|orig_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_orig_head
condition|)
name|update_ref
argument_list|(
literal|"am --abort"
argument_list|,
literal|"HEAD"
argument_list|,
name|orig_head
argument_list|,
name|has_curr_head
condition|?
name|curr_head
else|:
name|NULL
argument_list|,
literal|0
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|curr_branch
condition|)
name|delete_ref
argument_list|(
name|curr_branch
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_branch
argument_list|)
expr_stmt|;
name|am_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**  * parse_options() callback that validates and sets opt->value to the  * PATCH_FORMAT_* enum value corresponding to `arg`.  */
end_comment
begin_function
DECL|function|parse_opt_patchformat
specifier|static
name|int
name|parse_opt_patchformat
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|int
modifier|*
name|opt_value
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"mbox"
argument_list|)
condition|)
operator|*
name|opt_value
operator|=
name|PATCH_FORMAT_MBOX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"stgit"
argument_list|)
condition|)
operator|*
name|opt_value
operator|=
name|PATCH_FORMAT_STGIT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"stgit-series"
argument_list|)
condition|)
operator|*
name|opt_value
operator|=
name|PATCH_FORMAT_STGIT_SERIES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"hg"
argument_list|)
condition|)
operator|*
name|opt_value
operator|=
name|PATCH_FORMAT_HG
expr_stmt|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid value for --patch-format: %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_enum
DECL|enum|resume_mode
enum|enum
name|resume_mode
block|{
DECL|enumerator|RESUME_FALSE
name|RESUME_FALSE
init|=
literal|0
block|,
DECL|enumerator|RESUME_APPLY
name|RESUME_APPLY
block|,
DECL|enumerator|RESUME_RESOLVED
name|RESUME_RESOLVED
block|,
DECL|enumerator|RESUME_SKIP
name|RESUME_SKIP
block|,
DECL|enumerator|RESUME_ABORT
name|RESUME_ABORT
block|}
enum|;
end_enum
begin_function
DECL|function|git_am_config
specifier|static
name|int
name|git_am_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|git_gpg_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
return|return
name|git_default_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_am
name|int
name|cmd_am
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|am_state
name|state
decl_stmt|;
name|int
name|binary
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|keep_cr
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|patch_format
init|=
name|PATCH_FORMAT_UNKNOWN
decl_stmt|;
name|enum
name|resume_mode
name|resume
init|=
name|RESUME_FALSE
decl_stmt|;
name|int
name|in_progress
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git am [<options>] [(<mbox>|<Maildir>)...]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git am [<options>] (--continue | --skip | --abort)"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_BOOL
argument_list|(
literal|'i'
argument_list|,
literal|"interactive"
argument_list|,
operator|&
name|state
operator|.
name|interactive
argument_list|,
name|N_
argument_list|(
literal|"run interactively"
argument_list|)
argument_list|)
block|,
name|OPT_HIDDEN_BOOL
argument_list|(
literal|'b'
argument_list|,
literal|"binary"
argument_list|,
operator|&
name|binary
argument_list|,
name|N_
argument_list|(
literal|"historical option -- no-op"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'3'
argument_list|,
literal|"3way"
argument_list|,
operator|&
name|state
operator|.
name|threeway
argument_list|,
name|N_
argument_list|(
literal|"allow fall back on 3way merging if needed"
argument_list|)
argument_list|)
block|,
name|OPT__QUIET
argument_list|(
operator|&
name|state
operator|.
name|quiet
argument_list|,
name|N_
argument_list|(
literal|"be quiet"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'s'
argument_list|,
literal|"signoff"
argument_list|,
operator|&
name|state
operator|.
name|signoff
argument_list|,
name|N_
argument_list|(
literal|"add a Signed-off-by line to the commit message"
argument_list|)
argument_list|,
name|SIGNOFF_EXPLICIT
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'u'
argument_list|,
literal|"utf8"
argument_list|,
operator|&
name|state
operator|.
name|utf8
argument_list|,
name|N_
argument_list|(
literal|"recode into utf8 (default)"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'k'
argument_list|,
literal|"keep"
argument_list|,
operator|&
name|state
operator|.
name|keep
argument_list|,
name|N_
argument_list|(
literal|"pass -k flag to git-mailinfo"
argument_list|)
argument_list|,
name|KEEP_TRUE
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"keep-non-patch"
argument_list|,
operator|&
name|state
operator|.
name|keep
argument_list|,
name|N_
argument_list|(
literal|"pass -b flag to git-mailinfo"
argument_list|)
argument_list|,
name|KEEP_NON_PATCH
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'m'
argument_list|,
literal|"message-id"
argument_list|,
operator|&
name|state
operator|.
name|message_id
argument_list|,
name|N_
argument_list|(
literal|"pass -m flag to git-mailinfo"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_SET_INT
block|,
literal|0
block|,
literal|"keep-cr"
block|,
operator|&
name|keep_cr
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"pass --keep-cr flag to git-mailsplit for mbox format"
argument_list|)
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_NONEG
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
name|OPTION_SET_INT
block|,
literal|0
block|,
literal|"no-keep-cr"
block|,
operator|&
name|keep_cr
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"do not pass --keep-cr flag to git-mailsplit independent of am.keepcr"
argument_list|)
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_NONEG
block|,
name|NULL
block|,
literal|0
block|}
block|,
name|OPT_BOOL
argument_list|(
literal|'c'
argument_list|,
literal|"scissors"
argument_list|,
operator|&
name|state
operator|.
name|scissors
argument_list|,
name|N_
argument_list|(
literal|"strip everything before a scissors line"
argument_list|)
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|0
argument_list|,
literal|"whitespace"
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|N_
argument_list|(
literal|"action"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
literal|0
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|0
argument_list|,
literal|"ignore-space-change"
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|NULL
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
name|PARSE_OPT_NOARG
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|0
argument_list|,
literal|"ignore-whitespace"
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|NULL
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
name|PARSE_OPT_NOARG
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|0
argument_list|,
literal|"directory"
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|N_
argument_list|(
literal|"root"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
literal|0
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|0
argument_list|,
literal|"exclude"
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
literal|0
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|0
argument_list|,
literal|"include"
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
literal|0
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|'C'
argument_list|,
name|NULL
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|N_
argument_list|(
literal|"n"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
literal|0
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|'p'
argument_list|,
name|NULL
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|N_
argument_list|(
literal|"num"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
literal|0
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|0
argument_list|,
literal|"patch-format"
argument_list|,
operator|&
name|patch_format
argument_list|,
name|N_
argument_list|(
literal|"format"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"format the patch(es) are in"
argument_list|)
argument_list|,
name|parse_opt_patchformat
argument_list|)
block|,
name|OPT_PASSTHRU_ARGV
argument_list|(
literal|0
argument_list|,
literal|"reject"
argument_list|,
operator|&
name|state
operator|.
name|git_apply_opts
argument_list|,
name|NULL
argument_list|,
name|N_
argument_list|(
literal|"pass it through git-apply"
argument_list|)
argument_list|,
name|PARSE_OPT_NOARG
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"resolvemsg"
argument_list|,
operator|&
name|state
operator|.
name|resolvemsg
argument_list|,
name|NULL
argument_list|,
name|N_
argument_list|(
literal|"override error message when patch failure occurs"
argument_list|)
argument_list|)
block|,
name|OPT_CMDMODE
argument_list|(
literal|0
argument_list|,
literal|"continue"
argument_list|,
operator|&
name|resume
argument_list|,
name|N_
argument_list|(
literal|"continue applying patches after resolving a conflict"
argument_list|)
argument_list|,
name|RESUME_RESOLVED
argument_list|)
block|,
name|OPT_CMDMODE
argument_list|(
literal|'r'
argument_list|,
literal|"resolved"
argument_list|,
operator|&
name|resume
argument_list|,
name|N_
argument_list|(
literal|"synonyms for --continue"
argument_list|)
argument_list|,
name|RESUME_RESOLVED
argument_list|)
block|,
name|OPT_CMDMODE
argument_list|(
literal|0
argument_list|,
literal|"skip"
argument_list|,
operator|&
name|resume
argument_list|,
name|N_
argument_list|(
literal|"skip the current patch"
argument_list|)
argument_list|,
name|RESUME_SKIP
argument_list|)
block|,
name|OPT_CMDMODE
argument_list|(
literal|0
argument_list|,
literal|"abort"
argument_list|,
operator|&
name|resume
argument_list|,
name|N_
argument_list|(
literal|"restore the original branch and abort the patching operation."
argument_list|)
argument_list|,
name|RESUME_ABORT
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"committer-date-is-author-date"
argument_list|,
operator|&
name|state
operator|.
name|committer_date_is_author_date
argument_list|,
name|N_
argument_list|(
literal|"lie about committer date"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"ignore-date"
argument_list|,
operator|&
name|state
operator|.
name|ignore_date
argument_list|,
name|N_
argument_list|(
literal|"use current timestamp for author date"
argument_list|)
argument_list|)
block|,
name|OPT_RERERE_AUTOUPDATE
argument_list|(
operator|&
name|state
operator|.
name|allow_rerere_autoupdate
argument_list|)
block|,
block|{
name|OPTION_STRING
block|,
literal|'S'
block|,
literal|"gpg-sign"
block|,
operator|&
name|state
operator|.
name|sign_commit
block|,
name|N_
argument_list|(
literal|"key-id"
argument_list|)
block|,
name|N_
argument_list|(
literal|"GPG-sign commits"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
operator|(
name|intptr_t
operator|)
literal|""
block|}
block|,
name|OPT_HIDDEN_BOOL
argument_list|(
literal|0
argument_list|,
literal|"rebasing"
argument_list|,
operator|&
name|state
operator|.
name|rebasing
argument_list|,
name|N_
argument_list|(
literal|"(internal use for git-rebase)"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|git_config
argument_list|(
name|git_am_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|am_state_init
argument_list|(
operator|&
name|state
argument_list|,
name|git_path
argument_list|(
literal|"rebase-apply"
argument_list|)
argument_list|)
expr_stmt|;
name|in_progress
operator|=
name|am_in_progress
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_progress
condition|)
name|am_load
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary
operator|>=
literal|0
condition|)
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"The -b/--binary option has been a no-op for long time, and\n"
literal|"it will be removed. Please do not use it anymore."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure a valid committer ident can be constructed */
name|git_committer_info
argument_list|(
name|IDENT_STRICT
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_index_preload
argument_list|(
operator|&
name|the_index
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to read the index"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_progress
condition|)
block|{
comment|/* 		 * Catch user error to feed us patches when there is a session 		 * in progress: 		 * 		 * 1. mbox path(s) are provided on the command-line. 		 * 2. stdin is not a tty: the user is trying to feed us a patch 		 *    from standard input. This is somewhat unreliable -- stdin 		 *    could be /dev/null for example and the caller did not 		 *    intend to feed us a patch but wanted to continue 		 *    unattended. 		 */
if|if
condition|(
name|argc
operator|||
operator|(
name|resume
operator|==
name|RESUME_FALSE
operator|&&
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"previous rebase directory %s still exists but mbox given."
argument_list|)
argument_list|,
name|state
operator|.
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|resume
operator|==
name|RESUME_FALSE
condition|)
name|resume
operator|=
name|RESUME_APPLY
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|signoff
operator|==
name|SIGNOFF_EXPLICIT
condition|)
name|am_append_signoff
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|argv_array
name|paths
init|=
name|ARGV_ARRAY_INIT
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * Handle stray state directory in the independent-run case. In 		 * the --rebasing case, it is up to the caller to take care of 		 * stray directories. 		 */
if|if
condition|(
name|file_exists
argument_list|(
name|state
operator|.
name|dir
argument_list|)
operator|&&
operator|!
name|state
operator|.
name|rebasing
condition|)
block|{
if|if
condition|(
name|resume
operator|==
name|RESUME_ABORT
condition|)
block|{
name|am_destroy
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|am_state_release
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|die
argument_list|(
name|_
argument_list|(
literal|"Stray %s directory found.\n"
literal|"Use \"git am --abort\" to remove it."
argument_list|)
argument_list|,
name|state
operator|.
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resume
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Resolve operation not in progress, we are not resuming."
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is_absolute_path
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|||
operator|!
name|prefix
condition|)
name|argv_array_push
argument_list|(
operator|&
name|paths
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|argv_array_push
argument_list|(
operator|&
name|paths
argument_list|,
name|mkpath
argument_list|(
literal|"%s/%s"
argument_list|,
name|prefix
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|am_setup
argument_list|(
operator|&
name|state
argument_list|,
name|patch_format
argument_list|,
name|paths
operator|.
name|argv
argument_list|,
name|keep_cr
argument_list|)
expr_stmt|;
name|argv_array_clear
argument_list|(
operator|&
name|paths
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|resume
condition|)
block|{
case|case
name|RESUME_FALSE
case|:
name|am_run
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME_APPLY
case|:
name|am_run
argument_list|(
operator|&
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME_RESOLVED
case|:
name|am_resolve
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME_SKIP
case|:
name|am_skip
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESUME_ABORT
case|:
name|am_abort
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"BUG: invalid resume value"
argument_list|)
expr_stmt|;
block|}
name|am_state_release
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
