begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"ll-merge.h"
end_include
begin_include
include|#
directive|include
file|"resolve-undo.h"
end_include
begin_include
include|#
directive|include
file|"submodule.h"
end_include
begin_decl_stmt
DECL|variable|checkout_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|checkout_usage
index|[]
init|=
block|{
literal|"git checkout [options]<branch>"
block|,
literal|"git checkout [options] [<branch>] --<file>..."
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|checkout_opts
struct|struct
name|checkout_opts
block|{
DECL|member|quiet
name|int
name|quiet
decl_stmt|;
DECL|member|merge
name|int
name|merge
decl_stmt|;
DECL|member|force
name|int
name|force
decl_stmt|;
DECL|member|writeout_stage
name|int
name|writeout_stage
decl_stmt|;
DECL|member|writeout_error
name|int
name|writeout_error
decl_stmt|;
comment|/* not set by parse_options */
DECL|member|branch_exists
name|int
name|branch_exists
decl_stmt|;
DECL|member|new_branch
specifier|const
name|char
modifier|*
name|new_branch
decl_stmt|;
DECL|member|new_branch_force
specifier|const
name|char
modifier|*
name|new_branch_force
decl_stmt|;
DECL|member|new_orphan_branch
specifier|const
name|char
modifier|*
name|new_orphan_branch
decl_stmt|;
DECL|member|new_branch_log
name|int
name|new_branch_log
decl_stmt|;
DECL|member|track
name|enum
name|branch_track
name|track
decl_stmt|;
DECL|member|diff_options
name|struct
name|diff_options
name|diff_options
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|post_checkout_hook
specifier|static
name|int
name|post_checkout_hook
parameter_list|(
name|struct
name|commit
modifier|*
name|old
parameter_list|,
name|struct
name|commit
modifier|*
name|new
parameter_list|,
name|int
name|changed
parameter_list|)
block|{
return|return
name|run_hook
argument_list|(
name|NULL
argument_list|,
literal|"post-checkout"
argument_list|,
name|sha1_to_hex
argument_list|(
name|old
condition|?
name|old
operator|->
name|object
operator|.
name|sha1
else|:
name|null_sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|new
condition|?
name|new
operator|->
name|object
operator|.
name|sha1
else|:
name|null_sha1
argument_list|)
argument_list|,
name|changed
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* "new" can be NULL when checking out from the index before 	   a commit exists. */
block|}
end_function
begin_function
DECL|function|update_some
specifier|static
name|int
name|update_some
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|unsigned
name|mode
parameter_list|,
name|int
name|stage
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|READ_TREE_RECURSIVE
return|;
name|len
operator|=
name|baselen
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|cache_entry_size
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ce
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
operator|+
name|baselen
argument_list|,
name|pathname
argument_list|,
name|len
operator|-
name|baselen
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_OK_TO_REPLACE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_tree_some
specifier|static
name|int
name|read_tree_some
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|read_tree_recursive
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pathspec
argument_list|,
name|update_some
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* update the index with the given tree's info 	 * for all args, expanding wildcards, and exit 	 * with any non-zero return code. 	 */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|skip_same_name
specifier|static
name|int
name|skip_same_name
parameter_list|(
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
while|while
condition|(
operator|++
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
empty_stmt|;
comment|/* skip */
return|return
name|pos
return|;
block|}
end_function
begin_function
DECL|function|check_stage
specifier|static
name|int
name|check_stage
parameter_list|(
name|int
name|stage
parameter_list|,
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
while|while
condition|(
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
operator|==
name|stage
condition|)
return|return
literal|0
return|;
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|stage
operator|==
literal|2
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have our version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have their version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|check_all_stages
specifier|static
name|int
name|check_all_stages
parameter_list|(
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
operator|!=
literal|1
operator|||
name|active_nr
operator|<=
name|pos
operator|+
literal|2
operator|||
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
operator|||
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|2
operator|||
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|2
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
operator|||
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|2
index|]
argument_list|)
operator|!=
literal|3
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have all three versions"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|checkout_stage
specifier|static
name|int
name|checkout_stage
parameter_list|(
name|int
name|stage
parameter_list|,
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|checkout
modifier|*
name|state
parameter_list|)
block|{
while|while
condition|(
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
operator|==
name|stage
condition|)
return|return
name|checkout_entry
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|,
name|state
argument_list|,
name|NULL
argument_list|)
return|;
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|stage
operator|==
literal|2
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have our version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have their version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|checkout_merged
specifier|static
name|int
name|checkout_merged
parameter_list|(
name|int
name|pos
parameter_list|,
name|struct
name|checkout
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|ce
operator|->
name|name
decl_stmt|;
name|mmfile_t
name|ancestor
decl_stmt|,
name|ours
decl_stmt|,
name|theirs
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|mmbuffer_t
name|result_buf
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
operator|!=
literal|1
operator|||
name|active_nr
operator|<=
name|pos
operator|+
literal|2
operator|||
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|name
argument_list|,
name|path
argument_list|)
operator|||
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|1
index|]
argument_list|)
operator|!=
literal|2
operator|||
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|2
index|]
operator|->
name|name
argument_list|,
name|path
argument_list|)
operator|||
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|2
index|]
argument_list|)
operator|!=
literal|3
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have all 3 versions"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|read_mmblob
argument_list|(
operator|&
name|ancestor
argument_list|,
name|active_cache
index|[
name|pos
index|]
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|ours
argument_list|,
name|active_cache
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|theirs
argument_list|,
name|active_cache
index|[
name|pos
operator|+
literal|2
index|]
operator|->
name|sha1
argument_list|)
expr_stmt|;
comment|/* 	 * NEEDSWORK: re-create conflicts from merges with 	 * merge.renormalize set, too 	 */
name|status
operator|=
name|ll_merge
argument_list|(
operator|&
name|result_buf
argument_list|,
name|path
argument_list|,
operator|&
name|ancestor
argument_list|,
literal|"base"
argument_list|,
operator|&
name|ours
argument_list|,
literal|"ours"
argument_list|,
operator|&
name|theirs
argument_list|,
literal|"theirs"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ancestor
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ours
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|theirs
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
operator|||
operator|!
name|result_buf
operator|.
name|ptr
condition|)
block|{
name|free
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s': cannot merge"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/* 	 * NEEDSWORK: 	 * There is absolutely no reason to write this as a blob object 	 * and create a phony cache entry just to leak.  This hack is 	 * primarily to get to the write_entry() machinery that massages 	 * the contents to work-tree format and writes out which only 	 * allows it for a cache entry.  The code in write_entry() needs 	 * to be refactored to allow us to feed a<buffer, size, mode> 	 * instead of a cache entry.  Such a refactoring would help 	 * merge_recursive as well (it also writes the merge result to the 	 * object database even when it may contain conflicts). 	 */
if|if
condition|(
name|write_sha1_file
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|,
name|result_buf
operator|.
name|size
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unable to add merge result for '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ce
operator|=
name|make_cache_entry
argument_list|(
name|create_ce_mode
argument_list|(
name|active_cache
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|ce_mode
argument_list|)
argument_list|,
name|sha1
argument_list|,
name|path
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"make_cache_entry failed for path '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|checkout_entry
argument_list|(
name|ce
argument_list|,
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|checkout_paths
specifier|static
name|int
name|checkout_paths
parameter_list|(
name|struct
name|tree
modifier|*
name|source_tree
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|,
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|struct
name|checkout
name|state
decl_stmt|;
specifier|static
name|char
modifier|*
name|ps_matched
decl_stmt|;
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|commit
modifier|*
name|head
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|int
name|stage
init|=
name|opts
operator|->
name|writeout_stage
decl_stmt|;
name|int
name|merge
init|=
name|opts
operator|->
name|merge
decl_stmt|;
name|int
name|newfd
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock_file
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|newfd
operator|=
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cache_preload
argument_list|(
name|pathspec
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"corrupt index file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|source_tree
condition|)
name|read_tree_some
argument_list|(
name|source_tree
argument_list|,
name|pathspec
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pathspec
index|[
name|pos
index|]
condition|;
name|pos
operator|++
control|)
empty_stmt|;
name|ps_matched
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|active_nr
condition|;
name|pos
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
name|match_pathspec
argument_list|(
name|pathspec
argument_list|,
name|ce
operator|->
name|name
argument_list|,
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ps_matched
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|report_path_error
argument_list|(
name|ps_matched
argument_list|,
name|pathspec
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* "checkout -m path" to recreate conflicted state */
if|if
condition|(
name|opts
operator|->
name|merge
condition|)
name|unmerge_cache
argument_list|(
name|pathspec
argument_list|)
expr_stmt|;
comment|/* Any unmerged paths? */
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|active_nr
condition|;
name|pos
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|match_pathspec
argument_list|(
name|pathspec
argument_list|,
name|ce
operator|->
name|name
argument_list|,
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|opts
operator|->
name|force
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"path '%s' is unmerged"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stage
condition|)
block|{
name|errs
operator||=
name|check_stage
argument_list|(
name|stage
argument_list|,
name|ce
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|merge
condition|)
block|{
name|errs
operator||=
name|check_all_stages
argument_list|(
name|ce
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' is unmerged"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|skip_same_name
argument_list|(
name|ce
argument_list|,
name|pos
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errs
condition|)
return|return
literal|1
return|;
comment|/* Now we are committed to check them out */
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|force
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|refresh_cache
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|active_nr
condition|;
name|pos
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|match_pathspec
argument_list|(
name|pathspec
argument_list|,
name|ce
operator|->
name|name
argument_list|,
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
block|{
name|errs
operator||=
name|checkout_entry
argument_list|(
name|ce
argument_list|,
operator|&
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stage
condition|)
name|errs
operator||=
name|checkout_stage
argument_list|(
name|stage
argument_list|,
name|ce
argument_list|,
name|pos
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|merge
condition|)
name|errs
operator||=
name|checkout_merged
argument_list|(
name|pos
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|pos
operator|=
name|skip_same_name
argument_list|(
name|ce
argument_list|,
name|pos
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|write_cache
argument_list|(
name|newfd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock_file
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
name|resolve_ref
argument_list|(
literal|"HEAD"
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
name|head
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|errs
operator||=
name|post_checkout_hook
argument_list|(
name|head
argument_list|,
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|errs
return|;
block|}
end_function
begin_function
DECL|function|show_local_changes
specifier|static
name|void
name|show_local_changes
parameter_list|(
name|struct
name|object
modifier|*
name|head
parameter_list|,
name|struct
name|diff_options
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
comment|/* I think we want full paths, even if we're in a subdirectory. */
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|flags
operator|=
name|opts
operator|->
name|flags
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator||=
name|DIFF_FORMAT_NAME_STATUS
expr_stmt|;
if|if
condition|(
name|diff_setup_done
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"diff_setup_done failed"
argument_list|)
argument_list|)
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|rev
argument_list|,
name|head
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|run_diff_index
argument_list|(
operator|&
name|rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|describe_detached_head
specifier|static
name|void
name|describe_detached_head
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|pretty_print_context
name|ctx
init|=
block|{
literal|0
block|}
decl_stmt|;
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
name|pretty_print_commit
argument_list|(
name|CMIT_FMT_ONELINE
argument_list|,
name|commit
argument_list|,
operator|&
name|sb
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s... %s\n"
argument_list|,
name|msg
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reset_tree
specifier|static
name|int
name|reset_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
name|struct
name|checkout_opts
modifier|*
name|o
parameter_list|,
name|int
name|worktree
parameter_list|)
block|{
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|tree_desc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|opts
operator|.
name|update
operator|=
name|worktree
expr_stmt|;
name|opts
operator|.
name|skip_unmerged
operator|=
operator|!
name|worktree
expr_stmt|;
name|opts
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|opts
operator|.
name|verbose_update
operator|=
operator|!
name|o
operator|->
name|quiet
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|tree_desc
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unpack_trees
argument_list|(
literal|1
argument_list|,
operator|&
name|tree_desc
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
block|{
case|case
operator|-
literal|2
case|:
name|o
operator|->
name|writeout_error
operator|=
literal|1
expr_stmt|;
comment|/* 		 * We return 0 nevertheless, as the index is all right 		 * and more importantly we have made best efforts to 		 * update paths in the work tree, and we cannot revert 		 * them. 		 */
case|case
literal|0
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|128
return|;
block|}
block|}
end_function
begin_struct
DECL|struct|branch_info
struct|struct
name|branch_info
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The short name used */
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The full name of a real branch */
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
comment|/* The named commit */
block|}
struct|;
end_struct
begin_function
DECL|function|setup_branch_path
specifier|static
name|void
name|setup_branch_path
parameter_list|(
name|struct
name|branch_info
modifier|*
name|branch
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_branchname
argument_list|(
operator|&
name|buf
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|branch
operator|->
name|name
argument_list|)
condition|)
name|branch
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_splice
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"refs/heads/"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|branch
operator|->
name|path
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_working_tree
specifier|static
name|int
name|merge_working_tree
parameter_list|(
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|branch_info
modifier|*
name|old
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock_file
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|newfd
init|=
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|read_cache_preload
argument_list|(
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"corrupt index file"
argument_list|)
argument_list|)
return|;
name|resolve_undo_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|force
condition|)
block|{
name|ret
operator|=
name|reset_tree
argument_list|(
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|opts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
name|struct
name|tree_desc
name|trees
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|unpack_trees_options
name|topts
decl_stmt|;
name|memset
argument_list|(
operator|&
name|topts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|topts
argument_list|)
argument_list|)
expr_stmt|;
name|topts
operator|.
name|head_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|topts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|topts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|setup_unpack_trees_porcelain
argument_list|(
operator|&
name|topts
argument_list|,
literal|"checkout"
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"you need to resolve your current index first"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 2-way merge to the new branch */
name|topts
operator|.
name|initial_checkout
operator|=
name|is_cache_unborn
argument_list|()
expr_stmt|;
name|topts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|topts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|topts
operator|.
name|gently
operator|=
name|opts
operator|->
name|merge
operator|&&
name|old
operator|->
name|commit
expr_stmt|;
name|topts
operator|.
name|verbose_update
operator|=
operator|!
name|opts
operator|->
name|quiet
expr_stmt|;
name|topts
operator|.
name|fn
operator|=
name|twoway_merge
expr_stmt|;
name|topts
operator|.
name|dir
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|topts
operator|.
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|topts
operator|.
name|dir
operator|->
name|flags
operator||=
name|DIR_SHOW_IGNORED
expr_stmt|;
name|topts
operator|.
name|dir
operator|->
name|exclude_per_dir
operator|=
literal|".gitignore"
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|old
operator|->
name|commit
condition|?
name|old
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
else|:
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|trees
index|[
literal|0
index|]
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|new
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|trees
index|[
literal|1
index|]
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unpack_trees
argument_list|(
literal|2
argument_list|,
name|trees
argument_list|,
operator|&
name|topts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Unpack couldn't do a trivial merge; either 			 * give up or do a real merge, depending on 			 * whether the merge flag was used. 			 */
name|struct
name|tree
modifier|*
name|result
decl_stmt|;
name|struct
name|tree
modifier|*
name|work
decl_stmt|;
name|struct
name|merge_options
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|merge
condition|)
return|return
literal|1
return|;
comment|/* 			 * Without old->commit, the below is the same as 			 * the two-tree unpack we already tried and failed. 			 */
if|if
condition|(
operator|!
name|old
operator|->
name|commit
condition|)
return|return
literal|1
return|;
comment|/* Do more real merge */
comment|/* 			 * We update the index fully, then write the 			 * tree from the index, then merge the new 			 * branch with the current tree, with the old 			 * branch as the base. Then we reset the index 			 * (but not the working tree) to the new 			 * branch, leaving the working tree as the 			 * merged version, but skipping unmerged 			 * entries in the index. 			 */
name|add_files_to_cache
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * NEEDSWORK: carrying over local changes 			 * when branches have different end-of-line 			 * normalization (or clean+smudge rules) is 			 * a pain; plumb in an option to set 			 * o.renormalize? 			 */
name|init_merge_options
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|verbosity
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|write_tree_from_memory
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|ret
operator|=
name|reset_tree
argument_list|(
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|opts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|o
operator|.
name|ancestor
operator|=
name|old
operator|->
name|name
expr_stmt|;
name|o
operator|.
name|branch1
operator|=
name|new
operator|->
name|name
expr_stmt|;
name|o
operator|.
name|branch2
operator|=
literal|"local"
expr_stmt|;
name|merge_trees
argument_list|(
operator|&
name|o
argument_list|,
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|work
argument_list|,
name|old
operator|->
name|commit
operator|->
name|tree
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|ret
operator|=
name|reset_tree
argument_list|(
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|opts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
if|if
condition|(
name|write_cache
argument_list|(
name|newfd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock_file
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|force
operator|&&
operator|!
name|opts
operator|->
name|quiet
condition|)
name|show_local_changes
argument_list|(
operator|&
name|new
operator|->
name|commit
operator|->
name|object
argument_list|,
operator|&
name|opts
operator|->
name|diff_options
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|report_tracking
specifier|static
name|void
name|report_tracking
parameter_list|(
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|new
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|format_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
return|return;
name|fputs
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|detach_advice
specifier|static
name|void
name|detach_advice
parameter_list|(
specifier|const
name|char
modifier|*
name|old_path
parameter_list|,
specifier|const
name|char
modifier|*
name|new_name
parameter_list|)
block|{
specifier|const
name|char
name|fmt
index|[]
init|=
literal|"Note: checking out '%s'.\n\n"
literal|"You are in 'detached HEAD' state. You can look around, make experimental\n"
literal|"changes and commit them, and you can discard any commits you make in this\n"
literal|"state without impacting any branches by performing another checkout.\n\n"
literal|"If you want to create a new branch to retain commits you create, you may\n"
literal|"do so (now or later) by using -b with the checkout command again. Example:\n\n"
literal|"  git checkout -b new_branch_name\n\n"
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_refs_for_switch
specifier|static
name|void
name|update_refs_for_switch
parameter_list|(
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|branch_info
modifier|*
name|old
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_desc
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|new_branch
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|new_orphan_branch
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|new_branch_log
operator|&&
operator|!
name|log_all_ref_updates
condition|)
block|{
name|int
name|temp
decl_stmt|;
name|char
name|log_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|ref_name
init|=
name|mkpath
argument_list|(
literal|"refs/heads/%s"
argument_list|,
name|opts
operator|->
name|new_orphan_branch
argument_list|)
decl_stmt|;
name|temp
operator|=
name|log_all_ref_updates
expr_stmt|;
name|log_all_ref_updates
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|log_ref_setup
argument_list|(
name|ref_name
argument_list|,
name|log_file
argument_list|,
sizeof|sizeof
argument_list|(
name|log_file
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Can not do reflog for '%s'\n"
argument_list|)
argument_list|,
name|opts
operator|->
name|new_orphan_branch
argument_list|)
expr_stmt|;
name|log_all_ref_updates
operator|=
name|temp
expr_stmt|;
return|return;
block|}
name|log_all_ref_updates
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
name|create_branch
argument_list|(
name|old
operator|->
name|name
argument_list|,
name|opts
operator|->
name|new_branch
argument_list|,
name|new
operator|->
name|name
argument_list|,
name|opts
operator|->
name|new_branch_force
condition|?
literal|1
else|:
literal|0
argument_list|,
name|opts
operator|->
name|new_branch_log
argument_list|,
name|opts
operator|->
name|track
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|opts
operator|->
name|new_branch
expr_stmt|;
name|setup_branch_path
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
name|old_desc
operator|=
name|old
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|old_desc
operator|&&
name|old
operator|->
name|commit
condition|)
name|old_desc
operator|=
name|sha1_to_hex
argument_list|(
name|old
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"checkout: moving from %s to %s"
argument_list|,
name|old_desc
condition|?
name|old_desc
else|:
literal|"(invalid)"
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|path
condition|)
block|{
name|create_symref
argument_list|(
literal|"HEAD"
argument_list|,
name|new
operator|->
name|path
argument_list|,
name|msg
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
condition|)
block|{
if|if
condition|(
name|old
operator|->
name|path
operator|&&
operator|!
name|strcmp
argument_list|(
name|new
operator|->
name|path
argument_list|,
name|old
operator|->
name|path
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Already on '%s'\n"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opts
operator|->
name|new_branch
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Switched to%s branch '%s'\n"
argument_list|,
name|opts
operator|->
name|branch_exists
condition|?
literal|" and reset"
else|:
literal|" a new"
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Switched to branch '%s'\n"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old
operator|->
name|path
operator|&&
name|old
operator|->
name|name
condition|)
block|{
name|char
name|log_file
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|ref_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|git_snpath
argument_list|(
name|log_file
argument_list|,
sizeof|sizeof
argument_list|(
name|log_file
argument_list|)
argument_list|,
literal|"logs/%s"
argument_list|,
name|old
operator|->
name|path
argument_list|)
expr_stmt|;
name|git_snpath
argument_list|(
name|ref_file
argument_list|,
sizeof|sizeof
argument_list|(
name|ref_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|old
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|ref_file
argument_list|)
operator|&&
name|file_exists
argument_list|(
name|log_file
argument_list|)
condition|)
name|remove_path
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|new
operator|->
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|new
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
condition|)
block|{
if|if
condition|(
name|old
operator|->
name|path
operator|&&
name|advice_detached_head
condition|)
name|detach_advice
argument_list|(
name|old
operator|->
name|path
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
name|describe_detached_head
argument_list|(
literal|"HEAD is now at"
argument_list|,
name|new
operator|->
name|commit
argument_list|)
expr_stmt|;
block|}
block|}
name|remove_branch_state
argument_list|()
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
operator|&&
operator|(
name|new
operator|->
name|path
operator|||
operator|!
name|strcmp
argument_list|(
name|new
operator|->
name|name
argument_list|,
literal|"HEAD"
argument_list|)
operator|)
condition|)
name|report_tracking
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|switch_branches
specifier|static
name|int
name|switch_branches
parameter_list|(
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|branch_info
name|old
decl_stmt|;
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|memset
argument_list|(
operator|&
name|old
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|.
name|path
operator|=
name|resolve_ref
argument_list|(
literal|"HEAD"
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
name|old
operator|.
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
condition|)
name|old
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|old
operator|.
name|path
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|old
operator|.
name|path
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|old
operator|.
name|name
operator|=
name|old
operator|.
name|path
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|name
condition|)
block|{
name|new
operator|->
name|name
operator|=
literal|"HEAD"
expr_stmt|;
name|new
operator|->
name|commit
operator|=
name|old
operator|.
name|commit
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|commit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You are on a branch yet to be born"
argument_list|)
argument_list|)
expr_stmt|;
name|parse_commit
argument_list|(
name|new
operator|->
name|commit
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|merge_working_tree
argument_list|(
name|opts
argument_list|,
operator|&
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* 	 * If we were on a detached HEAD, but have now moved to 	 * a new commit, we want to mention the old commit once more 	 * to remind the user that it might be lost. 	 */
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
operator|&&
operator|!
name|old
operator|.
name|path
operator|&&
name|old
operator|.
name|commit
operator|&&
name|new
operator|->
name|commit
operator|!=
name|old
operator|.
name|commit
condition|)
name|describe_detached_head
argument_list|(
name|_
argument_list|(
literal|"Previous HEAD position was"
argument_list|)
argument_list|,
name|old
operator|.
name|commit
argument_list|)
expr_stmt|;
name|update_refs_for_switch
argument_list|(
name|opts
argument_list|,
operator|&
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ret
operator|=
name|post_checkout_hook
argument_list|(
name|old
operator|.
name|commit
argument_list|,
name|new
operator|->
name|commit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
operator|||
name|opts
operator|->
name|writeout_error
return|;
block|}
end_function
begin_function
DECL|function|git_checkout_config
specifier|static
name|int
name|git_checkout_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"diff.ignoresubmodules"
argument_list|)
condition|)
block|{
name|struct
name|checkout_opts
modifier|*
name|opts
init|=
name|cb
decl_stmt|;
name|handle_ignore_submodules_arg
argument_list|(
operator|&
name|opts
operator|->
name|diff_options
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"submodule."
argument_list|)
condition|)
return|return
name|parse_submodule_config_option
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
return|return
name|git_xmerge_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|interactive_checkout
specifier|static
name|int
name|interactive_checkout
parameter_list|(
specifier|const
name|char
modifier|*
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|,
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|)
block|{
return|return
name|run_add_interactive
argument_list|(
name|revision
argument_list|,
literal|"--patch=checkout"
argument_list|,
name|pathspec
argument_list|)
return|;
block|}
end_function
begin_struct
DECL|struct|tracking_name_data
struct|struct
name|tracking_name_data
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|remote
name|char
modifier|*
name|remote
decl_stmt|;
DECL|member|unique
name|int
name|unique
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|check_tracking_name
specifier|static
name|int
name|check_tracking_name
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|tracking_name_data
modifier|*
name|cb
init|=
name|cb_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|refname
argument_list|,
literal|"refs/remotes/"
argument_list|)
condition|)
return|return
literal|0
return|;
name|slash
operator|=
name|strchr
argument_list|(
name|refname
operator|+
literal|13
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slash
operator|||
name|strcmp
argument_list|(
name|slash
operator|+
literal|1
argument_list|,
name|cb
operator|->
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cb
operator|->
name|remote
condition|)
block|{
name|cb
operator|->
name|unique
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cb
operator|->
name|remote
operator|=
name|xstrdup
argument_list|(
name|refname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unique_tracking_name
specifier|static
specifier|const
name|char
modifier|*
name|unique_tracking_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tracking_name_data
name|cb_data
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|1
block|}
decl_stmt|;
name|cb_data
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|for_each_ref
argument_list|(
name|check_tracking_name
argument_list|,
operator|&
name|cb_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb_data
operator|.
name|unique
condition|)
return|return
name|cb_data
operator|.
name|remote
return|;
name|free
argument_list|(
name|cb_data
operator|.
name|remote
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|cmd_checkout
name|int
name|cmd_checkout
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|checkout_opts
name|opts
decl_stmt|;
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|branch_info
name|new
decl_stmt|;
name|struct
name|tree
modifier|*
name|source_tree
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|conflict_style
init|=
name|NULL
decl_stmt|;
name|int
name|patch_mode
init|=
literal|0
decl_stmt|;
name|int
name|dwim_new_local_branch
init|=
literal|1
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT__QUIET
argument_list|(
operator|&
name|opts
operator|.
name|quiet
argument_list|,
literal|"suppress progress reporting"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'b'
argument_list|,
name|NULL
argument_list|,
operator|&
name|opts
operator|.
name|new_branch
argument_list|,
literal|"branch"
argument_list|,
literal|"create and checkout a new branch"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'B'
argument_list|,
name|NULL
argument_list|,
operator|&
name|opts
operator|.
name|new_branch_force
argument_list|,
literal|"branch"
argument_list|,
literal|"create/reset and checkout a branch"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'l'
argument_list|,
name|NULL
argument_list|,
operator|&
name|opts
operator|.
name|new_branch_log
argument_list|,
literal|"create reflog for new branch"
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'t'
argument_list|,
literal|"track"
argument_list|,
operator|&
name|opts
operator|.
name|track
argument_list|,
literal|"set upstream info for new branch"
argument_list|,
name|BRANCH_TRACK_EXPLICIT
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"orphan"
argument_list|,
operator|&
name|opts
operator|.
name|new_orphan_branch
argument_list|,
literal|"new branch"
argument_list|,
literal|"new unparented branch"
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'2'
argument_list|,
literal|"ours"
argument_list|,
operator|&
name|opts
operator|.
name|writeout_stage
argument_list|,
literal|"checkout our version for unmerged files"
argument_list|,
literal|2
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'3'
argument_list|,
literal|"theirs"
argument_list|,
operator|&
name|opts
operator|.
name|writeout_stage
argument_list|,
literal|"checkout their version for unmerged files"
argument_list|,
literal|3
argument_list|)
block|,
name|OPT__FORCE
argument_list|(
operator|&
name|opts
operator|.
name|force
argument_list|,
literal|"force checkout (throw away local modifications)"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'m'
argument_list|,
literal|"merge"
argument_list|,
operator|&
name|opts
operator|.
name|merge
argument_list|,
literal|"perform a 3-way merge with the new branch"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"conflict"
argument_list|,
operator|&
name|conflict_style
argument_list|,
literal|"style"
argument_list|,
literal|"conflict style (merge or diff3)"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'p'
argument_list|,
literal|"patch"
argument_list|,
operator|&
name|patch_mode
argument_list|,
literal|"select hunks interactively"
argument_list|)
block|,
block|{
name|OPTION_BOOLEAN
block|,
literal|0
block|,
literal|"guess"
block|,
operator|&
name|dwim_new_local_branch
block|,
name|NULL
block|,
literal|"second guess 'git checkout no-such-branch'"
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_HIDDEN
block|}
block|,
name|OPT_END
argument_list|()
block|, 	}
decl_stmt|;
name|int
name|has_dash_dash
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|gitmodules_config
argument_list|()
expr_stmt|;
name|git_config
argument_list|(
name|git_checkout_config
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|track
operator|=
name|BRANCH_TRACK_UNSPECIFIED
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|checkout_usage
argument_list|,
name|PARSE_OPT_KEEP_DASHDASH
argument_list|)
expr_stmt|;
comment|/* we can assume from now on new_branch = !new_branch_force */
if|if
condition|(
name|opts
operator|.
name|new_branch
operator|&&
name|opts
operator|.
name|new_branch_force
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"-B cannot be used with -b"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy -B over to -b, so that we can just check the latter */
if|if
condition|(
name|opts
operator|.
name|new_branch_force
condition|)
name|opts
operator|.
name|new_branch
operator|=
name|opts
operator|.
name|new_branch_force
expr_stmt|;
if|if
condition|(
name|patch_mode
operator|&&
operator|(
name|opts
operator|.
name|track
operator|>
literal|0
operator|||
name|opts
operator|.
name|new_branch
operator|||
name|opts
operator|.
name|new_branch_log
operator|||
name|opts
operator|.
name|merge
operator|||
name|opts
operator|.
name|force
operator|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--patch is incompatible with all other options"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* --track without -b should DWIM */
if|if
condition|(
literal|0
operator|<
name|opts
operator|.
name|track
operator|&&
operator|!
name|opts
operator|.
name|new_branch
condition|)
block|{
specifier|const
name|char
modifier|*
name|argv0
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|argc
operator|||
operator|!
name|strcmp
argument_list|(
name|argv0
argument_list|,
literal|"--"
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--track needs a branch name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|argv0
argument_list|,
literal|"refs/"
argument_list|)
condition|)
name|argv0
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|argv0
argument_list|,
literal|"remotes/"
argument_list|)
condition|)
name|argv0
operator|+=
literal|8
expr_stmt|;
name|argv0
operator|=
name|strchr
argument_list|(
name|argv0
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argv0
operator|||
operator|!
name|argv0
index|[
literal|1
index|]
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Missing branch name; try -b"
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|new_branch
operator|=
name|argv0
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|.
name|new_orphan_branch
condition|)
block|{
if|if
condition|(
name|opts
operator|.
name|new_branch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--orphan and -b|-B are mutually exclusive"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|.
name|track
operator|>
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--orphan cannot be used with -t"
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|new_branch
operator|=
name|opts
operator|.
name|new_orphan_branch
expr_stmt|;
block|}
if|if
condition|(
name|conflict_style
condition|)
block|{
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
comment|/* implied */
name|git_xmerge_config
argument_list|(
literal|"merge.conflictstyle"
argument_list|,
name|conflict_style
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|.
name|force
operator|&&
name|opts
operator|.
name|merge
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: -f and -m are incompatible"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * case 1: git checkout<ref> -- [<paths>] 	 * 	 *<ref> must be a valid tree, everything after the '--' must be 	 *   a path. 	 * 	 * case 2: git checkout -- [<paths>] 	 * 	 *   everything after the '--' must be paths. 	 * 	 * case 3: git checkout<something> [<paths>] 	 * 	 *   With no paths, if<something> is a commit, that is to 	 *   switch to the branch or detach HEAD at it.  As a special case, 	 *   if<something> is A...B (missing A or B means HEAD but you can 	 *   omit at most one side), and if there is a unique merge base 	 *   between A and B, A...B names that merge base. 	 * 	 *   With no paths, if<something> is _not_ a commit, no -t nor -b 	 *   was given, and there is a remote-tracking branch whose name is 	 *<something> in one and only one remote, then this is a short-hand 	 *   to fork local<something> from that remote-tracking branch. 	 * 	 *   Otherwise<something> shall not be ambiguous. 	 *   - If it's *only* a reference, treat it like case (1). 	 *   - If it's only a path, treat it like case (2). 	 *   - else: fail. 	 * 	 */
if|if
condition|(
name|argc
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
comment|/* case (2) */
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
goto|goto
name|no_reference
goto|;
block|}
name|arg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|has_dash_dash
operator|=
operator|(
name|argc
operator|>
literal|1
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
name|arg
operator|=
literal|"@{-1}"
expr_stmt|;
if|if
condition|(
name|get_sha1_mb
argument_list|(
name|arg
argument_list|,
name|rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|has_dash_dash
condition|)
comment|/* case (1) */
name|die
argument_list|(
name|_
argument_list|(
literal|"invalid reference: %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patch_mode
operator|&&
name|dwim_new_local_branch
operator|&&
name|opts
operator|.
name|track
operator|==
name|BRANCH_TRACK_UNSPECIFIED
operator|&&
operator|!
name|opts
operator|.
name|new_branch
operator|&&
operator|!
name|check_filename
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|)
operator|&&
name|argc
operator|==
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|remote
init|=
name|unique_tracking_name
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|remote
operator|||
name|get_sha1
argument_list|(
name|remote
argument_list|,
name|rev
argument_list|)
condition|)
goto|goto
name|no_reference
goto|;
name|opts
operator|.
name|new_branch
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|remote
expr_stmt|;
comment|/* DWIMmed to create local branch */
block|}
else|else
goto|goto
name|no_reference
goto|;
block|}
comment|/* we can't end up being in (2) anymore, eat the argument */
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|new
operator|.
name|name
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|.
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|rev
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|setup_branch_path
argument_list|(
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|check_ref_format
argument_list|(
name|new
operator|.
name|path
argument_list|)
operator|==
name|CHECK_REF_FORMAT_OK
operator|)
operator|&&
name|resolve_ref
argument_list|(
name|new
operator|.
name|path
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
empty_stmt|;
else|else
name|new
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
name|parse_commit
argument_list|(
name|new
operator|.
name|commit
argument_list|)
expr_stmt|;
name|source_tree
operator|=
name|new
operator|.
name|commit
operator|->
name|tree
expr_stmt|;
block|}
else|else
name|source_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source_tree
condition|)
comment|/* case (1): want a tree */
name|die
argument_list|(
name|_
argument_list|(
literal|"reference is not a tree: %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_dash_dash
condition|)
block|{
comment|/* case (3 -> 1) */
comment|/* 			 * Do not complain the most common case 			 *	git checkout branch 			 * even if there happen to be a file called 'branch'; 			 * it would be extremely annoying. 			 */
if|if
condition|(
name|argc
condition|)
name|verify_non_filename
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
block|}
name|no_reference
label|:
if|if
condition|(
name|opts
operator|.
name|track
operator|==
name|BRANCH_TRACK_UNSPECIFIED
condition|)
name|opts
operator|.
name|track
operator|=
name|git_branch_track
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
init|=
name|get_pathspec
argument_list|(
name|prefix
argument_list|,
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pathspec
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"invalid path specification"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch_mode
condition|)
return|return
name|interactive_checkout
argument_list|(
name|new
operator|.
name|name
argument_list|,
name|pathspec
argument_list|,
operator|&
name|opts
argument_list|)
return|;
comment|/* Checkout paths */
if|if
condition|(
name|opts
operator|.
name|new_branch
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: updating paths is incompatible with switching branches.\nDid you intend to checkout '%s' which can not be resolved as commit?"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: updating paths is incompatible with switching branches."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|1
operator|<
operator|!
operator|!
name|opts
operator|.
name|writeout_stage
operator|+
operator|!
operator|!
name|opts
operator|.
name|force
operator|+
operator|!
operator|!
name|opts
operator|.
name|merge
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: --ours/--theirs, --force and --merge are incompatible when\nchecking out of the index."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|checkout_paths
argument_list|(
name|source_tree
argument_list|,
name|pathspec
argument_list|,
operator|&
name|opts
argument_list|)
return|;
block|}
if|if
condition|(
name|patch_mode
condition|)
return|return
name|interactive_checkout
argument_list|(
name|new
operator|.
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|opts
argument_list|)
return|;
if|if
condition|(
name|opts
operator|.
name|new_branch
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|strbuf_check_branch_ref
argument_list|(
operator|&
name|buf
argument_list|,
name|opts
operator|.
name|new_branch
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: we do not like '%s' as a branch name."
argument_list|)
argument_list|,
name|opts
operator|.
name|new_branch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|opts
operator|.
name|branch_exists
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|.
name|new_branch_force
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: branch %s already exists"
argument_list|)
argument_list|,
name|opts
operator|.
name|new_branch
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new
operator|.
name|name
operator|&&
operator|!
name|new
operator|.
name|commit
condition|)
block|{
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot switch branch to a non-commit."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|.
name|writeout_stage
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--ours/--theirs is incompatible with switching branches."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|switch_branches
argument_list|(
operator|&
name|opts
argument_list|,
operator|&
name|new
argument_list|)
return|;
block|}
end_function
end_unit
