begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"ll-merge.h"
end_include
begin_include
include|#
directive|include
file|"resolve-undo.h"
end_include
begin_include
include|#
directive|include
file|"submodule.h"
end_include
begin_include
include|#
directive|include
file|"argv-array.h"
end_include
begin_decl_stmt
DECL|variable|checkout_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|checkout_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git checkout [options]<branch>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git checkout [options] [<branch>] --<file>..."
argument_list|)
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|checkout_opts
struct|struct
name|checkout_opts
block|{
DECL|member|patch_mode
name|int
name|patch_mode
decl_stmt|;
DECL|member|quiet
name|int
name|quiet
decl_stmt|;
DECL|member|merge
name|int
name|merge
decl_stmt|;
DECL|member|force
name|int
name|force
decl_stmt|;
DECL|member|force_detach
name|int
name|force_detach
decl_stmt|;
DECL|member|writeout_stage
name|int
name|writeout_stage
decl_stmt|;
DECL|member|overwrite_ignore
name|int
name|overwrite_ignore
decl_stmt|;
DECL|member|ignore_skipworktree
name|int
name|ignore_skipworktree
decl_stmt|;
DECL|member|new_branch
specifier|const
name|char
modifier|*
name|new_branch
decl_stmt|;
DECL|member|new_branch_force
specifier|const
name|char
modifier|*
name|new_branch_force
decl_stmt|;
DECL|member|new_orphan_branch
specifier|const
name|char
modifier|*
name|new_orphan_branch
decl_stmt|;
DECL|member|new_branch_log
name|int
name|new_branch_log
decl_stmt|;
DECL|member|track
name|enum
name|branch_track
name|track
decl_stmt|;
DECL|member|diff_options
name|struct
name|diff_options
name|diff_options
decl_stmt|;
DECL|member|branch_exists
name|int
name|branch_exists
decl_stmt|;
DECL|member|prefix
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
DECL|member|pathspec
name|struct
name|pathspec
name|pathspec
decl_stmt|;
DECL|member|source_tree
name|struct
name|tree
modifier|*
name|source_tree
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|post_checkout_hook
specifier|static
name|int
name|post_checkout_hook
parameter_list|(
name|struct
name|commit
modifier|*
name|old
parameter_list|,
name|struct
name|commit
modifier|*
name|new
parameter_list|,
name|int
name|changed
parameter_list|)
block|{
return|return
name|run_hook_le
argument_list|(
name|NULL
argument_list|,
literal|"post-checkout"
argument_list|,
name|sha1_to_hex
argument_list|(
name|old
condition|?
name|old
operator|->
name|object
operator|.
name|sha1
else|:
name|null_sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|new
condition|?
name|new
operator|->
name|object
operator|.
name|sha1
else|:
name|null_sha1
argument_list|)
argument_list|,
name|changed
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* "new" can be NULL when checking out from the index before 	   a commit exists. */
block|}
end_function
begin_function
DECL|function|update_some
specifier|static
name|int
name|update_some
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|unsigned
name|mode
parameter_list|,
name|int
name|stage
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|READ_TREE_RECURSIVE
return|;
name|len
operator|=
name|baselen
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|cache_entry_size
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ce
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
operator|+
name|baselen
argument_list|,
name|pathname
argument_list|,
name|len
operator|-
name|baselen
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
literal|0
argument_list|)
operator||
name|CE_UPDATE
expr_stmt|;
name|ce
operator|->
name|ce_namelen
operator|=
name|len
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_OK_TO_REPLACE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_tree_some
specifier|static
name|int
name|read_tree_some
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|)
block|{
name|read_tree_recursive
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pathspec
argument_list|,
name|update_some
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* update the index with the given tree's info 	 * for all args, expanding wildcards, and exit 	 * with any non-zero return code. 	 */
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|skip_same_name
specifier|static
name|int
name|skip_same_name
parameter_list|(
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
while|while
condition|(
operator|++
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
empty_stmt|;
comment|/* skip */
return|return
name|pos
return|;
block|}
end_function
begin_function
DECL|function|check_stage
specifier|static
name|int
name|check_stage
parameter_list|(
name|int
name|stage
parameter_list|,
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
while|while
condition|(
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
operator|==
name|stage
condition|)
return|return
literal|0
return|;
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|stage
operator|==
literal|2
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have our version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have their version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|check_stages
specifier|static
name|int
name|check_stages
parameter_list|(
name|unsigned
name|stages
parameter_list|,
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|unsigned
name|seen
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|ce
operator|->
name|name
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
condition|)
block|{
name|ce
operator|=
name|active_cache
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
break|break;
name|seen
operator||=
operator|(
literal|1
operator|<<
name|ce_stage
argument_list|(
name|ce
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stages
operator|&
name|seen
operator|)
operator|!=
name|stages
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have all necessary versions"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|checkout_stage
specifier|static
name|int
name|checkout_stage
parameter_list|(
name|int
name|stage
parameter_list|,
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|int
name|pos
parameter_list|,
name|struct
name|checkout
modifier|*
name|state
parameter_list|)
block|{
while|while
condition|(
name|pos
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|name
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
operator|==
name|stage
condition|)
return|return
name|checkout_entry
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|,
name|state
argument_list|,
name|NULL
argument_list|)
return|;
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|stage
operator|==
literal|2
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have our version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have their version"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|checkout_merged
specifier|static
name|int
name|checkout_merged
parameter_list|(
name|int
name|pos
parameter_list|,
name|struct
name|checkout
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|ce
operator|->
name|name
decl_stmt|;
name|mmfile_t
name|ancestor
decl_stmt|,
name|ours
decl_stmt|,
name|theirs
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|mmbuffer_t
name|result_buf
decl_stmt|;
name|unsigned
name|char
name|threeway
index|[
literal|3
index|]
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|mode
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|threeway
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|threeway
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
condition|)
block|{
name|int
name|stage
decl_stmt|;
name|stage
operator|=
name|ce_stage
argument_list|(
name|ce
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stage
operator|||
name|strcmp
argument_list|(
name|path
argument_list|,
name|ce
operator|->
name|name
argument_list|)
condition|)
break|break;
name|hashcpy
argument_list|(
name|threeway
index|[
name|stage
operator|-
literal|1
index|]
argument_list|,
name|ce
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stage
operator|==
literal|2
condition|)
name|mode
operator|=
name|create_ce_mode
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
name|ce
operator|=
name|active_cache
index|[
name|pos
index|]
expr_stmt|;
block|}
if|if
condition|(
name|is_null_sha1
argument_list|(
name|threeway
index|[
literal|1
index|]
argument_list|)
operator|||
name|is_null_sha1
argument_list|(
name|threeway
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' does not have necessary versions"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|read_mmblob
argument_list|(
operator|&
name|ancestor
argument_list|,
name|threeway
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|ours
argument_list|,
name|threeway
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|theirs
argument_list|,
name|threeway
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * NEEDSWORK: re-create conflicts from merges with 	 * merge.renormalize set, too 	 */
name|status
operator|=
name|ll_merge
argument_list|(
operator|&
name|result_buf
argument_list|,
name|path
argument_list|,
operator|&
name|ancestor
argument_list|,
literal|"base"
argument_list|,
operator|&
name|ours
argument_list|,
literal|"ours"
argument_list|,
operator|&
name|theirs
argument_list|,
literal|"theirs"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ancestor
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ours
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|theirs
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
operator|||
operator|!
name|result_buf
operator|.
name|ptr
condition|)
block|{
name|free
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s': cannot merge"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/* 	 * NEEDSWORK: 	 * There is absolutely no reason to write this as a blob object 	 * and create a phony cache entry just to leak.  This hack is 	 * primarily to get to the write_entry() machinery that massages 	 * the contents to work-tree format and writes out which only 	 * allows it for a cache entry.  The code in write_entry() needs 	 * to be refactored to allow us to feed a<buffer, size, mode> 	 * instead of a cache entry.  Such a refactoring would help 	 * merge_recursive as well (it also writes the merge result to the 	 * object database even when it may contain conflicts). 	 */
if|if
condition|(
name|write_sha1_file
argument_list|(
name|result_buf
operator|.
name|ptr
argument_list|,
name|result_buf
operator|.
name|size
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unable to add merge result for '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ce
operator|=
name|make_cache_entry
argument_list|(
name|mode
argument_list|,
name|sha1
argument_list|,
name|path
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"make_cache_entry failed for path '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|checkout_entry
argument_list|(
name|ce
argument_list|,
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|checkout_paths
specifier|static
name|int
name|checkout_paths
parameter_list|(
specifier|const
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
specifier|const
name|char
modifier|*
name|revision
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|struct
name|checkout
name|state
decl_stmt|;
specifier|static
name|char
modifier|*
name|ps_matched
decl_stmt|;
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|commit
modifier|*
name|head
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|int
name|newfd
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock_file
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|track
operator|!=
name|BRANCH_TRACK_UNSPECIFIED
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with updating paths"
argument_list|)
argument_list|,
literal|"--track"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|new_branch_log
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with updating paths"
argument_list|)
argument_list|,
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|force
operator|&&
name|opts
operator|->
name|patch_mode
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with updating paths"
argument_list|)
argument_list|,
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|force_detach
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with updating paths"
argument_list|)
argument_list|,
literal|"--detach"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|merge
operator|&&
name|opts
operator|->
name|patch_mode
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with %s"
argument_list|)
argument_list|,
literal|"--merge"
argument_list|,
literal|"--patch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|force
operator|&&
name|opts
operator|->
name|merge
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with %s"
argument_list|)
argument_list|,
literal|"-f"
argument_list|,
literal|"-m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|new_branch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot update paths and switch to branch '%s' at the same time."
argument_list|)
argument_list|,
name|opts
operator|->
name|new_branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|patch_mode
condition|)
return|return
name|run_add_interactive
argument_list|(
name|revision
argument_list|,
literal|"--patch=checkout"
argument_list|,
operator|&
name|opts
operator|->
name|pathspec
argument_list|)
return|;
name|lock_file
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cache_preload
argument_list|(
operator|&
name|opts
operator|->
name|pathspec
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"corrupt index file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opts
operator|->
name|source_tree
condition|)
name|read_tree_some
argument_list|(
name|opts
operator|->
name|source_tree
argument_list|,
operator|&
name|opts
operator|->
name|pathspec
argument_list|)
expr_stmt|;
name|ps_matched
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|opts
operator|->
name|pathspec
operator|.
name|nr
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure all pathspecs participated in locating the paths 	 * to be checked out. 	 */
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|active_nr
condition|;
name|pos
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
name|ce
operator|->
name|ce_flags
operator|&=
operator|~
name|CE_MATCHED
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|ignore_skipworktree
operator|&&
name|ce_skip_worktree
argument_list|(
name|ce
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|opts
operator|->
name|source_tree
operator|&&
operator|!
operator|(
name|ce
operator|->
name|ce_flags
operator|&
name|CE_UPDATE
operator|)
condition|)
comment|/* 			 * "git checkout tree-ish -- path", but this entry 			 * is in the original index; it will not be checked 			 * out to the working tree and it does not matter 			 * if pathspec matched this entry.  We will not do 			 * anything to this entry at all. 			 */
continue|continue;
comment|/* 		 * Either this entry came from the tree-ish we are 		 * checking the paths out of, or we are checking out 		 * of the index. 		 * 		 * If it comes from the tree-ish, we already know it 		 * matches the pathspec and could just stamp 		 * CE_MATCHED to it from update_some(). But we still 		 * need ps_matched and read_tree_recursive (and 		 * eventually tree_entry_interesting) cannot fill 		 * ps_matched yet. Once it can, we can avoid calling 		 * match_pathspec() for _all_ entries when 		 * opts->source_tree != NULL. 		 */
if|if
condition|(
name|ce_path_match
argument_list|(
name|ce
argument_list|,
operator|&
name|opts
operator|->
name|pathspec
argument_list|,
name|ps_matched
argument_list|)
condition|)
name|ce
operator|->
name|ce_flags
operator||=
name|CE_MATCHED
expr_stmt|;
block|}
if|if
condition|(
name|report_path_error
argument_list|(
name|ps_matched
argument_list|,
operator|&
name|opts
operator|->
name|pathspec
argument_list|,
name|opts
operator|->
name|prefix
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ps_matched
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|free
argument_list|(
name|ps_matched
argument_list|)
expr_stmt|;
comment|/* "checkout -m path" to recreate conflicted state */
if|if
condition|(
name|opts
operator|->
name|merge
condition|)
name|unmerge_marked_index
argument_list|(
operator|&
name|the_index
argument_list|)
expr_stmt|;
comment|/* Any unmerged paths? */
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|active_nr
condition|;
name|pos
operator|++
control|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_flags
operator|&
name|CE_MATCHED
condition|)
block|{
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|opts
operator|->
name|force
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"path '%s' is unmerged"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|writeout_stage
condition|)
block|{
name|errs
operator||=
name|check_stage
argument_list|(
name|opts
operator|->
name|writeout_stage
argument_list|,
name|ce
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|merge
condition|)
block|{
name|errs
operator||=
name|check_stages
argument_list|(
operator|(
literal|1
operator|<<
literal|2
operator|)
operator||
operator|(
literal|1
operator|<<
literal|3
operator|)
argument_list|,
name|ce
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"path '%s' is unmerged"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|skip_same_name
argument_list|(
name|ce
argument_list|,
name|pos
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errs
condition|)
return|return
literal|1
return|;
comment|/* Now we are committed to check them out */
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|force
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|refresh_cache
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|active_nr
condition|;
name|pos
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_flags
operator|&
name|CE_MATCHED
condition|)
block|{
if|if
condition|(
operator|!
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
block|{
name|errs
operator||=
name|checkout_entry
argument_list|(
name|ce
argument_list|,
operator|&
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|opts
operator|->
name|writeout_stage
condition|)
name|errs
operator||=
name|checkout_stage
argument_list|(
name|opts
operator|->
name|writeout_stage
argument_list|,
name|ce
argument_list|,
name|pos
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opts
operator|->
name|merge
condition|)
name|errs
operator||=
name|checkout_merged
argument_list|(
name|pos
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|pos
operator|=
name|skip_same_name
argument_list|(
name|ce
argument_list|,
name|pos
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|write_cache
argument_list|(
name|newfd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock_file
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
name|read_ref_full
argument_list|(
literal|"HEAD"
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
name|head
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|errs
operator||=
name|post_checkout_hook
argument_list|(
name|head
argument_list|,
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|errs
return|;
block|}
end_function
begin_function
DECL|function|show_local_changes
specifier|static
name|void
name|show_local_changes
parameter_list|(
name|struct
name|object
modifier|*
name|head
parameter_list|,
specifier|const
name|struct
name|diff_options
modifier|*
name|opts
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
comment|/* I think we want full paths, even if we're in a subdirectory. */
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|flags
operator|=
name|opts
operator|->
name|flags
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator||=
name|DIFF_FORMAT_NAME_STATUS
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|)
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|rev
argument_list|,
name|head
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|run_diff_index
argument_list|(
operator|&
name|rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|describe_detached_head
specifier|static
name|void
name|describe_detached_head
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|pp_commit_easy
argument_list|(
name|CMIT_FMT_ONELINE
argument_list|,
name|commit
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s... %s\n"
argument_list|,
name|msg
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reset_tree
specifier|static
name|int
name|reset_tree
parameter_list|(
name|struct
name|tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|struct
name|checkout_opts
modifier|*
name|o
parameter_list|,
name|int
name|worktree
parameter_list|,
name|int
modifier|*
name|writeout_error
parameter_list|)
block|{
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|tree_desc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|opts
operator|.
name|update
operator|=
name|worktree
expr_stmt|;
name|opts
operator|.
name|skip_unmerged
operator|=
operator|!
name|worktree
expr_stmt|;
name|opts
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|opts
operator|.
name|verbose_update
operator|=
operator|!
name|o
operator|->
name|quiet
operator|&&
name|isatty
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|tree_desc
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unpack_trees
argument_list|(
literal|1
argument_list|,
operator|&
name|tree_desc
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
block|{
case|case
operator|-
literal|2
case|:
operator|*
name|writeout_error
operator|=
literal|1
expr_stmt|;
comment|/* 		 * We return 0 nevertheless, as the index is all right 		 * and more importantly we have made best efforts to 		 * update paths in the work tree, and we cannot revert 		 * them. 		 */
case|case
literal|0
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|128
return|;
block|}
block|}
end_function
begin_struct
DECL|struct|branch_info
struct|struct
name|branch_info
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The short name used */
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The full name of a real branch */
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
comment|/* The named commit */
block|}
struct|;
end_struct
begin_function
DECL|function|setup_branch_path
specifier|static
name|void
name|setup_branch_path
parameter_list|(
name|struct
name|branch_info
modifier|*
name|branch
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_branchname
argument_list|(
operator|&
name|buf
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|branch
operator|->
name|name
argument_list|)
condition|)
name|branch
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_splice
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"refs/heads/"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|branch
operator|->
name|path
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_working_tree
specifier|static
name|int
name|merge_working_tree
parameter_list|(
specifier|const
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|branch_info
modifier|*
name|old
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|,
name|int
modifier|*
name|writeout_error
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock_file
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|newfd
init|=
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|read_cache_preload
argument_list|(
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"corrupt index file"
argument_list|)
argument_list|)
return|;
name|resolve_undo_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|force
condition|)
block|{
name|ret
operator|=
name|reset_tree
argument_list|(
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|opts
argument_list|,
literal|1
argument_list|,
name|writeout_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
name|struct
name|tree_desc
name|trees
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|unpack_trees_options
name|topts
decl_stmt|;
name|memset
argument_list|(
operator|&
name|topts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|topts
argument_list|)
argument_list|)
expr_stmt|;
name|topts
operator|.
name|head_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|topts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|topts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|setup_unpack_trees_porcelain
argument_list|(
operator|&
name|topts
argument_list|,
literal|"checkout"
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmerged_cache
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"you need to resolve your current index first"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 2-way merge to the new branch */
name|topts
operator|.
name|initial_checkout
operator|=
name|is_cache_unborn
argument_list|()
expr_stmt|;
name|topts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|topts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|topts
operator|.
name|gently
operator|=
name|opts
operator|->
name|merge
operator|&&
name|old
operator|->
name|commit
expr_stmt|;
name|topts
operator|.
name|verbose_update
operator|=
operator|!
name|opts
operator|->
name|quiet
operator|&&
name|isatty
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|topts
operator|.
name|fn
operator|=
name|twoway_merge
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|overwrite_ignore
condition|)
block|{
name|topts
operator|.
name|dir
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|topts
operator|.
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|topts
operator|.
name|dir
operator|->
name|flags
operator||=
name|DIR_SHOW_IGNORED
expr_stmt|;
name|setup_standard_excludes
argument_list|(
name|topts
operator|.
name|dir
argument_list|)
expr_stmt|;
block|}
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|old
operator|->
name|commit
condition|?
name|old
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
else|:
name|EMPTY_TREE_SHA1_BIN
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|trees
index|[
literal|0
index|]
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|new
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|trees
index|[
literal|1
index|]
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unpack_trees
argument_list|(
literal|2
argument_list|,
name|trees
argument_list|,
operator|&
name|topts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Unpack couldn't do a trivial merge; either 			 * give up or do a real merge, depending on 			 * whether the merge flag was used. 			 */
name|struct
name|tree
modifier|*
name|result
decl_stmt|;
name|struct
name|tree
modifier|*
name|work
decl_stmt|;
name|struct
name|merge_options
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|merge
condition|)
return|return
literal|1
return|;
comment|/* 			 * Without old->commit, the below is the same as 			 * the two-tree unpack we already tried and failed. 			 */
if|if
condition|(
operator|!
name|old
operator|->
name|commit
condition|)
return|return
literal|1
return|;
comment|/* Do more real merge */
comment|/* 			 * We update the index fully, then write the 			 * tree from the index, then merge the new 			 * branch with the current tree, with the old 			 * branch as the base. Then we reset the index 			 * (but not the working tree) to the new 			 * branch, leaving the working tree as the 			 * merged version, but skipping unmerged 			 * entries in the index. 			 */
name|add_files_to_cache
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * NEEDSWORK: carrying over local changes 			 * when branches have different end-of-line 			 * normalization (or clean+smudge rules) is 			 * a pain; plumb in an option to set 			 * o.renormalize? 			 */
name|init_merge_options
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|verbosity
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|write_tree_from_memory
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|ret
operator|=
name|reset_tree
argument_list|(
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|opts
argument_list|,
literal|1
argument_list|,
name|writeout_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|o
operator|.
name|ancestor
operator|=
name|old
operator|->
name|name
expr_stmt|;
name|o
operator|.
name|branch1
operator|=
name|new
operator|->
name|name
expr_stmt|;
name|o
operator|.
name|branch2
operator|=
literal|"local"
expr_stmt|;
name|merge_trees
argument_list|(
operator|&
name|o
argument_list|,
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|work
argument_list|,
name|old
operator|->
name|commit
operator|->
name|tree
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|ret
operator|=
name|reset_tree
argument_list|(
name|new
operator|->
name|commit
operator|->
name|tree
argument_list|,
name|opts
argument_list|,
literal|0
argument_list|,
name|writeout_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
block|}
if|if
condition|(
name|write_cache
argument_list|(
name|newfd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock_file
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|force
operator|&&
operator|!
name|opts
operator|->
name|quiet
condition|)
name|show_local_changes
argument_list|(
operator|&
name|new
operator|->
name|commit
operator|->
name|object
argument_list|,
operator|&
name|opts
operator|->
name|diff_options
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|report_tracking
specifier|static
name|void
name|report_tracking
parameter_list|(
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|new
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|format_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
return|return;
name|fputs
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_refs_for_switch
specifier|static
name|void
name|update_refs_for_switch
parameter_list|(
specifier|const
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|branch_info
modifier|*
name|old
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_desc
decl_stmt|,
modifier|*
name|reflog_msg
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|new_branch
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|new_orphan_branch
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|new_branch_log
operator|&&
operator|!
name|log_all_ref_updates
condition|)
block|{
name|int
name|temp
decl_stmt|;
name|char
name|log_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|ref_name
init|=
name|mkpath
argument_list|(
literal|"refs/heads/%s"
argument_list|,
name|opts
operator|->
name|new_orphan_branch
argument_list|)
decl_stmt|;
name|temp
operator|=
name|log_all_ref_updates
expr_stmt|;
name|log_all_ref_updates
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|log_ref_setup
argument_list|(
name|ref_name
argument_list|,
name|log_file
argument_list|,
sizeof|sizeof
argument_list|(
name|log_file
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Can not do reflog for '%s'\n"
argument_list|)
argument_list|,
name|opts
operator|->
name|new_orphan_branch
argument_list|)
expr_stmt|;
name|log_all_ref_updates
operator|=
name|temp
expr_stmt|;
return|return;
block|}
name|log_all_ref_updates
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
name|create_branch
argument_list|(
name|old
operator|->
name|name
argument_list|,
name|opts
operator|->
name|new_branch
argument_list|,
name|new
operator|->
name|name
argument_list|,
name|opts
operator|->
name|new_branch_force
condition|?
literal|1
else|:
literal|0
argument_list|,
name|opts
operator|->
name|new_branch_log
argument_list|,
name|opts
operator|->
name|new_branch_force
condition|?
literal|1
else|:
literal|0
argument_list|,
name|opts
operator|->
name|quiet
argument_list|,
name|opts
operator|->
name|track
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|opts
operator|->
name|new_branch
expr_stmt|;
name|setup_branch_path
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
name|old_desc
operator|=
name|old
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|old_desc
operator|&&
name|old
operator|->
name|commit
condition|)
name|old_desc
operator|=
name|sha1_to_hex
argument_list|(
name|old
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|reflog_msg
operator|=
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reflog_msg
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"checkout: moving from %s to %s"
argument_list|,
name|old_desc
condition|?
name|old_desc
else|:
literal|"(invalid)"
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|strbuf_insert
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
name|reflog_msg
argument_list|,
name|strlen
argument_list|(
name|reflog_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|new
operator|->
name|name
argument_list|,
literal|"HEAD"
argument_list|)
operator|&&
operator|!
name|new
operator|->
name|path
operator|&&
operator|!
name|opts
operator|->
name|force_detach
condition|)
block|{
comment|/* Nothing to do. */
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|force_detach
operator|||
operator|!
name|new
operator|->
name|path
condition|)
block|{
comment|/* No longer on any branch. */
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|new
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
condition|)
block|{
if|if
condition|(
name|old
operator|->
name|path
operator|&&
name|advice_detached_head
condition|)
name|detach_advice
argument_list|(
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
name|describe_detached_head
argument_list|(
name|_
argument_list|(
literal|"HEAD is now at"
argument_list|)
argument_list|,
name|new
operator|->
name|commit
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|new
operator|->
name|path
condition|)
block|{
comment|/* Switch branches. */
name|create_symref
argument_list|(
literal|"HEAD"
argument_list|,
name|new
operator|->
name|path
argument_list|,
name|msg
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
condition|)
block|{
if|if
condition|(
name|old
operator|->
name|path
operator|&&
operator|!
name|strcmp
argument_list|(
name|new
operator|->
name|path
argument_list|,
name|old
operator|->
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|new_branch_force
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Reset branch '%s'\n"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Already on '%s'\n"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|new_branch
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|branch_exists
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Switched to and reset branch '%s'\n"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Switched to a new branch '%s'\n"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Switched to branch '%s'\n"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old
operator|->
name|path
operator|&&
name|old
operator|->
name|name
condition|)
block|{
name|char
name|log_file
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|ref_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|git_snpath
argument_list|(
name|log_file
argument_list|,
sizeof|sizeof
argument_list|(
name|log_file
argument_list|)
argument_list|,
literal|"logs/%s"
argument_list|,
name|old
operator|->
name|path
argument_list|)
expr_stmt|;
name|git_snpath
argument_list|(
name|ref_file
argument_list|,
sizeof|sizeof
argument_list|(
name|ref_file
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|old
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|ref_file
argument_list|)
operator|&&
name|file_exists
argument_list|(
name|log_file
argument_list|)
condition|)
name|remove_path
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
block|}
block|}
name|remove_branch_state
argument_list|()
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
operator|&&
operator|(
name|new
operator|->
name|path
operator|||
operator|(
operator|!
name|opts
operator|->
name|force_detach
operator|&&
operator|!
name|strcmp
argument_list|(
name|new
operator|->
name|name
argument_list|,
literal|"HEAD"
argument_list|)
operator|)
operator|)
condition|)
name|report_tracking
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_pending_uninteresting_ref
specifier|static
name|int
name|add_pending_uninteresting_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|add_pending_sha1
argument_list|(
name|cb_data
argument_list|,
name|refname
argument_list|,
name|sha1
argument_list|,
name|UNINTERESTING
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|describe_one_orphan
specifier|static
name|void
name|describe_one_orphan
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|sb
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|pp_commit_easy
argument_list|(
name|CMIT_FMT_ONELINE
argument_list|,
name|commit
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|ORPHAN_CUTOFF
define|#
directive|define
name|ORPHAN_CUTOFF
value|4
end_define
begin_function
DECL|function|suggest_reattach
specifier|static
name|void
name|suggest_reattach
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|c
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|lost
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|get_revision
argument_list|(
name|revs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lost
operator|<
name|ORPHAN_CUTOFF
condition|)
name|describe_one_orphan
argument_list|(
operator|&
name|sb
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
name|lost
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ORPHAN_CUTOFF
operator|<
name|lost
condition|)
block|{
name|int
name|more
init|=
name|lost
operator|-
name|ORPHAN_CUTOFF
decl_stmt|;
if|if
condition|(
name|more
operator|==
literal|1
condition|)
name|describe_one_orphan
argument_list|(
operator|&
name|sb
argument_list|,
name|last
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
name|_
argument_list|(
literal|" ... and %d more.\n"
argument_list|)
argument_list|,
name|more
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|Q_
argument_list|(
comment|/* The singular version */
literal|"Warning: you are leaving %d commit behind, "
literal|"not connected to\n"
literal|"any of your branches:\n\n"
literal|"%s\n"
argument_list|,
comment|/* The plural version */
literal|"Warning: you are leaving %d commits behind, "
literal|"not connected to\n"
literal|"any of your branches:\n\n"
literal|"%s\n"
argument_list|,
comment|/* Give ngettext() the count */
name|lost
argument_list|)
argument_list|,
name|lost
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_detached_head
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"If you want to keep them by creating a new branch, "
literal|"this may be a good time\nto do so with:\n\n"
literal|" git branch new_branch_name %s\n\n"
argument_list|)
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * We are about to leave commit that was at the tip of a detached  * HEAD.  If it is not reachable from any ref, this is the last chance  * for the user to do so without resorting to reflog.  */
end_comment
begin_function
DECL|function|orphaned_commit_warning
specifier|static
name|void
name|orphaned_commit_warning
parameter_list|(
name|struct
name|commit
modifier|*
name|old
parameter_list|,
name|struct
name|commit
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
name|struct
name|object
modifier|*
name|object
init|=
operator|&
name|old
operator|->
name|object
decl_stmt|;
name|struct
name|object_array
name|refs
decl_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator|&=
operator|~
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
name|object
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|for_each_ref
argument_list|(
name|add_pending_uninteresting_ref
argument_list|,
operator|&
name|revs
argument_list|)
expr_stmt|;
name|add_pending_sha1
argument_list|(
operator|&
name|revs
argument_list|,
literal|"HEAD"
argument_list|,
name|new
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|UNINTERESTING
argument_list|)
expr_stmt|;
name|refs
operator|=
name|revs
operator|.
name|pending
expr_stmt|;
name|revs
operator|.
name|leak_pending
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"internal error in revision walk"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|old
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
name|suggest_reattach
argument_list|(
name|old
argument_list|,
operator|&
name|revs
argument_list|)
expr_stmt|;
else|else
name|describe_detached_head
argument_list|(
name|_
argument_list|(
literal|"Previous HEAD position was"
argument_list|)
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|clear_commit_marks_for_object_array
argument_list|(
operator|&
name|refs
argument_list|,
name|ALL_REV_FLAGS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refs
operator|.
name|objects
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|switch_branches
specifier|static
name|int
name|switch_branches
parameter_list|(
specifier|const
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|branch_info
name|old
decl_stmt|;
name|void
modifier|*
name|path_to_free
decl_stmt|;
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|writeout_error
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|old
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|.
name|path
operator|=
name|path_to_free
operator|=
name|resolve_refdup
argument_list|(
literal|"HEAD"
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
name|old
operator|.
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
condition|)
name|old
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|old
operator|.
name|path
operator|&&
name|starts_with
argument_list|(
name|old
operator|.
name|path
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|old
operator|.
name|name
operator|=
name|old
operator|.
name|path
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|name
condition|)
block|{
name|new
operator|->
name|name
operator|=
literal|"HEAD"
expr_stmt|;
name|new
operator|->
name|commit
operator|=
name|old
operator|.
name|commit
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|commit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You are on a branch yet to be born"
argument_list|)
argument_list|)
expr_stmt|;
name|parse_commit_or_die
argument_list|(
name|new
operator|->
name|commit
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|merge_working_tree
argument_list|(
name|opts
argument_list|,
operator|&
name|old
argument_list|,
name|new
argument_list|,
operator|&
name|writeout_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|free
argument_list|(
name|path_to_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
operator|&&
operator|!
name|old
operator|.
name|path
operator|&&
name|old
operator|.
name|commit
operator|&&
name|new
operator|->
name|commit
operator|!=
name|old
operator|.
name|commit
condition|)
name|orphaned_commit_warning
argument_list|(
name|old
operator|.
name|commit
argument_list|,
name|new
operator|->
name|commit
argument_list|)
expr_stmt|;
name|update_refs_for_switch
argument_list|(
name|opts
argument_list|,
operator|&
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ret
operator|=
name|post_checkout_hook
argument_list|(
name|old
operator|.
name|commit
argument_list|,
name|new
operator|->
name|commit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_to_free
argument_list|)
expr_stmt|;
return|return
name|ret
operator|||
name|writeout_error
return|;
block|}
end_function
begin_function
DECL|function|git_checkout_config
specifier|static
name|int
name|git_checkout_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"diff.ignoresubmodules"
argument_list|)
condition|)
block|{
name|struct
name|checkout_opts
modifier|*
name|opts
init|=
name|cb
decl_stmt|;
name|handle_ignore_submodules_arg
argument_list|(
operator|&
name|opts
operator|->
name|diff_options
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|starts_with
argument_list|(
name|var
argument_list|,
literal|"submodule."
argument_list|)
condition|)
return|return
name|parse_submodule_config_option
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
return|;
return|return
name|git_xmerge_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_struct
DECL|struct|tracking_name_data
struct|struct
name|tracking_name_data
block|{
DECL|member|src_ref
comment|/* const */
name|char
modifier|*
name|src_ref
decl_stmt|;
DECL|member|dst_ref
name|char
modifier|*
name|dst_ref
decl_stmt|;
DECL|member|dst_sha1
name|unsigned
name|char
modifier|*
name|dst_sha1
decl_stmt|;
DECL|member|unique
name|int
name|unique
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|check_tracking_name
specifier|static
name|int
name|check_tracking_name
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|tracking_name_data
modifier|*
name|cb
init|=
name|cb_data
decl_stmt|;
name|struct
name|refspec
name|query
decl_stmt|;
name|memset
argument_list|(
operator|&
name|query
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refspec
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|.
name|src
operator|=
name|cb
operator|->
name|src_ref
expr_stmt|;
if|if
condition|(
name|remote_find_tracking
argument_list|(
name|remote
argument_list|,
operator|&
name|query
argument_list|)
operator|||
name|get_sha1
argument_list|(
name|query
operator|.
name|dst
argument_list|,
name|cb
operator|->
name|dst_sha1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|query
operator|.
name|dst
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cb
operator|->
name|dst_ref
condition|)
block|{
name|free
argument_list|(
name|query
operator|.
name|dst
argument_list|)
expr_stmt|;
name|cb
operator|->
name|unique
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cb
operator|->
name|dst_ref
operator|=
name|query
operator|.
name|dst
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unique_tracking_name
specifier|static
specifier|const
name|char
modifier|*
name|unique_tracking_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|tracking_name_data
name|cb_data
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|1
block|}
decl_stmt|;
name|char
name|src_ref
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|src_ref
argument_list|,
name|PATH_MAX
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cb_data
operator|.
name|src_ref
operator|=
name|src_ref
expr_stmt|;
name|cb_data
operator|.
name|dst_sha1
operator|=
name|sha1
expr_stmt|;
name|for_each_remote
argument_list|(
name|check_tracking_name
argument_list|,
operator|&
name|cb_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb_data
operator|.
name|unique
condition|)
return|return
name|cb_data
operator|.
name|dst_ref
return|;
name|free
argument_list|(
name|cb_data
operator|.
name|dst_ref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|parse_branchname_arg
specifier|static
name|int
name|parse_branchname_arg
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|dwim_new_local_branch_ok
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|,
name|struct
name|tree
modifier|*
modifier|*
name|source_tree
parameter_list|,
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|new_branch
parameter_list|)
block|{
name|int
name|argcount
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|branch_rev
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|dash_dash_pos
decl_stmt|;
name|int
name|has_dash_dash
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * case 1: git checkout<ref> -- [<paths>] 	 * 	 *<ref> must be a valid tree, everything after the '--' must be 	 *   a path. 	 * 	 * case 2: git checkout -- [<paths>] 	 * 	 *   everything after the '--' must be paths. 	 * 	 * case 3: git checkout<something> [--] 	 * 	 *   (a) If<something> is a commit, that is to 	 *       switch to the branch or detach HEAD at it.  As a special case, 	 *       if<something> is A...B (missing A or B means HEAD but you can 	 *       omit at most one side), and if there is a unique merge base 	 *       between A and B, A...B names that merge base. 	 * 	 *   (b) If<something> is _not_ a commit, either "--" is present 	 *       or<something> is not a path, no -t or -b was given, and 	 *       and there is a tracking branch whose name is<something> 	 *       in one and only one remote, then this is a short-hand to 	 *       fork local<something> from that remote-tracking branch. 	 * 	 *   (c) Otherwise, if "--" is present, treat it like case (1). 	 * 	 *   (d) Otherwise : 	 *       - if it's a reference, treat it like case (1) 	 *       - else if it's a path, treat it like case (2) 	 *       - else: fail. 	 * 	 * case 4: git checkout<something><paths> 	 * 	 *   The first argument must not be ambiguous. 	 *   - If it's *only* a reference, treat it like case (1). 	 *   - If it's only a path, treat it like case (2). 	 *   - else: fail. 	 * 	 */
if|if
condition|(
operator|!
name|argc
condition|)
return|return
literal|0
return|;
name|arg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|dash_dash_pos
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|dash_dash_pos
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dash_dash_pos
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* case (2) */
elseif|else
if|if
condition|(
name|dash_dash_pos
operator|==
literal|1
condition|)
name|has_dash_dash
operator|=
literal|1
expr_stmt|;
comment|/* case (3) or (1) */
elseif|else
if|if
condition|(
name|dash_dash_pos
operator|>=
literal|2
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"only one reference expected, %d given."
argument_list|)
argument_list|,
name|dash_dash_pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
name|arg
operator|=
literal|"@{-1}"
expr_stmt|;
if|if
condition|(
name|get_sha1_mb
argument_list|(
name|arg
argument_list|,
name|rev
argument_list|)
condition|)
block|{
comment|/* 		 * Either case (3) or (4), with<something> not being 		 * a commit, or an attempt to use case (1) with an 		 * invalid ref. 		 * 		 * It's likely an error, but we need to find out if 		 * we should auto-create the branch, case (3).(b). 		 */
name|int
name|recover_with_dwim
init|=
name|dwim_new_local_branch_ok
decl_stmt|;
if|if
condition|(
name|check_filename
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|)
operator|&&
operator|!
name|has_dash_dash
condition|)
name|recover_with_dwim
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Accept "git checkout foo" and "git checkout foo --" 		 * as candidates for dwim. 		 */
if|if
condition|(
operator|!
operator|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|has_dash_dash
operator|)
operator|&&
operator|!
operator|(
name|argc
operator|==
literal|2
operator|&&
name|has_dash_dash
operator|)
condition|)
name|recover_with_dwim
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|recover_with_dwim
condition|)
block|{
specifier|const
name|char
modifier|*
name|remote
init|=
name|unique_tracking_name
argument_list|(
name|arg
argument_list|,
name|rev
argument_list|)
decl_stmt|;
if|if
condition|(
name|remote
condition|)
block|{
operator|*
name|new_branch
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|remote
expr_stmt|;
comment|/* DWIMmed to create local branch, case (3).(b) */
block|}
else|else
block|{
name|recover_with_dwim
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|recover_with_dwim
condition|)
block|{
if|if
condition|(
name|has_dash_dash
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"invalid reference: %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|argcount
return|;
block|}
block|}
comment|/* we can't end up being in (2) anymore, eat the argument */
name|argcount
operator|++
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|arg
expr_stmt|;
name|setup_branch_path
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_refname_format
argument_list|(
name|new
operator|->
name|path
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|read_ref
argument_list|(
name|new
operator|->
name|path
argument_list|,
name|branch_rev
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|rev
argument_list|,
name|branch_rev
argument_list|)
expr_stmt|;
else|else
name|new
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
comment|/* not an existing branch */
name|new
operator|->
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|commit
condition|)
block|{
comment|/* not a commit */
operator|*
name|source_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_commit_or_die
argument_list|(
name|new
operator|->
name|commit
argument_list|)
expr_stmt|;
operator|*
name|source_tree
operator|=
name|new
operator|->
name|commit
operator|->
name|tree
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|source_tree
condition|)
comment|/* case (1): want a tree */
name|die
argument_list|(
name|_
argument_list|(
literal|"reference is not a tree: %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_dash_dash
condition|)
block|{
comment|/* case (3).(d) -> (1) */
comment|/* 		 * Do not complain the most common case 		 *	git checkout branch 		 * even if there happen to be a file called 'branch'; 		 * it would be extremely annoying. 		 */
if|if
condition|(
name|argc
condition|)
name|verify_non_filename
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argcount
operator|++
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
return|return
name|argcount
return|;
block|}
end_function
begin_function
DECL|function|switch_unborn_to_new_branch
specifier|static
name|int
name|switch_unborn_to_new_branch
parameter_list|(
specifier|const
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|strbuf
name|branch_ref
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|new_branch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You are on a branch yet to be born"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|branch_ref
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|opts
operator|->
name|new_branch
argument_list|)
expr_stmt|;
name|status
operator|=
name|create_symref
argument_list|(
literal|"HEAD"
argument_list|,
name|branch_ref
operator|.
name|buf
argument_list|,
literal|"checkout -b"
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|branch_ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|->
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Switched to a new branch '%s'\n"
argument_list|)
argument_list|,
name|opts
operator|->
name|new_branch
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|checkout_branch
specifier|static
name|int
name|checkout_branch
parameter_list|(
name|struct
name|checkout_opts
modifier|*
name|opts
parameter_list|,
name|struct
name|branch_info
modifier|*
name|new
parameter_list|)
block|{
if|if
condition|(
name|opts
operator|->
name|pathspec
operator|.
name|nr
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"paths cannot be used with switching branches"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|patch_mode
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with switching branches"
argument_list|)
argument_list|,
literal|"--patch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|writeout_stage
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with switching branches"
argument_list|)
argument_list|,
literal|"--ours/--theirs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|force
operator|&&
name|opts
operator|->
name|merge
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with '%s'"
argument_list|)
argument_list|,
literal|"-f"
argument_list|,
literal|"-m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|force_detach
operator|&&
name|opts
operator|->
name|new_branch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with '%s'"
argument_list|)
argument_list|,
literal|"--detach"
argument_list|,
literal|"-b/-B/--orphan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|new_orphan_branch
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|track
operator|!=
name|BRANCH_TRACK_UNSPECIFIED
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with '%s'"
argument_list|)
argument_list|,
literal|"--orphan"
argument_list|,
literal|"-t"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|force_detach
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|track
operator|!=
name|BRANCH_TRACK_UNSPECIFIED
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' cannot be used with '%s'"
argument_list|)
argument_list|,
literal|"--detach"
argument_list|,
literal|"-t"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|track
operator|==
name|BRANCH_TRACK_UNSPECIFIED
condition|)
name|opts
operator|->
name|track
operator|=
name|git_branch_track
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|name
operator|&&
operator|!
name|new
operator|->
name|commit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot switch branch to a non-commit '%s'"
argument_list|)
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|commit
operator|&&
name|opts
operator|->
name|new_branch
condition|)
block|{
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|if
condition|(
operator|!
name|read_ref_full
argument_list|(
literal|"HEAD"
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
name|is_null_sha1
argument_list|(
name|rev
argument_list|)
condition|)
return|return
name|switch_unborn_to_new_branch
argument_list|(
name|opts
argument_list|)
return|;
block|}
return|return
name|switch_branches
argument_list|(
name|opts
argument_list|,
name|new
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_checkout
name|int
name|cmd_checkout
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|checkout_opts
name|opts
decl_stmt|;
name|struct
name|branch_info
name|new
decl_stmt|;
name|char
modifier|*
name|conflict_style
init|=
name|NULL
decl_stmt|;
name|int
name|dwim_new_local_branch
init|=
literal|1
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT__QUIET
argument_list|(
operator|&
name|opts
operator|.
name|quiet
argument_list|,
name|N_
argument_list|(
literal|"suppress progress reporting"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'b'
argument_list|,
name|NULL
argument_list|,
operator|&
name|opts
operator|.
name|new_branch
argument_list|,
name|N_
argument_list|(
literal|"branch"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"create and checkout a new branch"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'B'
argument_list|,
name|NULL
argument_list|,
operator|&
name|opts
operator|.
name|new_branch_force
argument_list|,
name|N_
argument_list|(
literal|"branch"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"create/reset and checkout a branch"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'l'
argument_list|,
name|NULL
argument_list|,
operator|&
name|opts
operator|.
name|new_branch_log
argument_list|,
name|N_
argument_list|(
literal|"create reflog for new branch"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"detach"
argument_list|,
operator|&
name|opts
operator|.
name|force_detach
argument_list|,
name|N_
argument_list|(
literal|"detach the HEAD at named commit"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'t'
argument_list|,
literal|"track"
argument_list|,
operator|&
name|opts
operator|.
name|track
argument_list|,
name|N_
argument_list|(
literal|"set upstream info for new branch"
argument_list|)
argument_list|,
name|BRANCH_TRACK_EXPLICIT
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"orphan"
argument_list|,
operator|&
name|opts
operator|.
name|new_orphan_branch
argument_list|,
name|N_
argument_list|(
literal|"new-branch"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"new unparented branch"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'2'
argument_list|,
literal|"ours"
argument_list|,
operator|&
name|opts
operator|.
name|writeout_stage
argument_list|,
name|N_
argument_list|(
literal|"checkout our version for unmerged files"
argument_list|)
argument_list|,
literal|2
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'3'
argument_list|,
literal|"theirs"
argument_list|,
operator|&
name|opts
operator|.
name|writeout_stage
argument_list|,
name|N_
argument_list|(
literal|"checkout their version for unmerged files"
argument_list|)
argument_list|,
literal|3
argument_list|)
block|,
name|OPT__FORCE
argument_list|(
operator|&
name|opts
operator|.
name|force
argument_list|,
name|N_
argument_list|(
literal|"force checkout (throw away local modifications)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'m'
argument_list|,
literal|"merge"
argument_list|,
operator|&
name|opts
operator|.
name|merge
argument_list|,
name|N_
argument_list|(
literal|"perform a 3-way merge with the new branch"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"overwrite-ignore"
argument_list|,
operator|&
name|opts
operator|.
name|overwrite_ignore
argument_list|,
name|N_
argument_list|(
literal|"update ignored files (default)"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"conflict"
argument_list|,
operator|&
name|conflict_style
argument_list|,
name|N_
argument_list|(
literal|"style"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"conflict style (merge or diff3)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'p'
argument_list|,
literal|"patch"
argument_list|,
operator|&
name|opts
operator|.
name|patch_mode
argument_list|,
name|N_
argument_list|(
literal|"select hunks interactively"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"ignore-skip-worktree-bits"
argument_list|,
operator|&
name|opts
operator|.
name|ignore_skipworktree
argument_list|,
name|N_
argument_list|(
literal|"do not limit pathspecs to sparse entries only"
argument_list|)
argument_list|)
block|,
name|OPT_HIDDEN_BOOL
argument_list|(
literal|0
argument_list|,
literal|"guess"
argument_list|,
operator|&
name|dwim_new_local_branch
argument_list|,
name|N_
argument_list|(
literal|"second guess 'git checkout no-such-branch'"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|, 	}
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|overwrite_ignore
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|gitmodules_config
argument_list|()
expr_stmt|;
name|git_config
argument_list|(
name|git_checkout_config
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|track
operator|=
name|BRANCH_TRACK_UNSPECIFIED
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|checkout_usage
argument_list|,
name|PARSE_OPT_KEEP_DASHDASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict_style
condition|)
block|{
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
comment|/* implied */
name|git_xmerge_config
argument_list|(
literal|"merge.conflictstyle"
argument_list|,
name|conflict_style
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
operator|!
name|opts
operator|.
name|new_branch
operator|+
operator|!
operator|!
name|opts
operator|.
name|new_branch_force
operator|+
operator|!
operator|!
name|opts
operator|.
name|new_orphan_branch
operator|)
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"-b, -B and --orphan are mutually exclusive"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * From here on, new_branch will contain the branch to be checked out, 	 * and new_branch_force and new_orphan_branch will tell us which one of 	 * -b/-B/--orphan is being used. 	 */
if|if
condition|(
name|opts
operator|.
name|new_branch_force
condition|)
name|opts
operator|.
name|new_branch
operator|=
name|opts
operator|.
name|new_branch_force
expr_stmt|;
if|if
condition|(
name|opts
operator|.
name|new_orphan_branch
condition|)
name|opts
operator|.
name|new_branch
operator|=
name|opts
operator|.
name|new_orphan_branch
expr_stmt|;
comment|/* --track without -b/-B/--orphan should DWIM */
if|if
condition|(
name|opts
operator|.
name|track
operator|!=
name|BRANCH_TRACK_UNSPECIFIED
operator|&&
operator|!
name|opts
operator|.
name|new_branch
condition|)
block|{
specifier|const
name|char
modifier|*
name|argv0
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|argc
operator|||
operator|!
name|strcmp
argument_list|(
name|argv0
argument_list|,
literal|"--"
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--track needs a branch name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|argv0
argument_list|,
literal|"refs/"
argument_list|)
condition|)
name|argv0
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|argv0
argument_list|,
literal|"remotes/"
argument_list|)
condition|)
name|argv0
operator|+=
literal|8
expr_stmt|;
name|argv0
operator|=
name|strchr
argument_list|(
name|argv0
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argv0
operator|||
operator|!
name|argv0
index|[
literal|1
index|]
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Missing branch name; try -b"
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|new_branch
operator|=
name|argv0
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * Extract branch name from command line arguments, so 	 * all that is left is pathspecs. 	 * 	 * Handle 	 * 	 *  1) git checkout<tree> -- [<paths>] 	 *  2) git checkout -- [<paths>] 	 *  3) git checkout<something> [<paths>] 	 * 	 * including "last branch" syntax and DWIM-ery for names of 	 * remote branches, erroring out for invalid or ambiguous cases. 	 */
if|if
condition|(
name|argc
condition|)
block|{
name|unsigned
name|char
name|rev
index|[
literal|20
index|]
decl_stmt|;
name|int
name|dwim_ok
init|=
operator|!
name|opts
operator|.
name|patch_mode
operator|&&
name|dwim_new_local_branch
operator|&&
name|opts
operator|.
name|track
operator|==
name|BRANCH_TRACK_UNSPECIFIED
operator|&&
operator|!
name|opts
operator|.
name|new_branch
decl_stmt|;
name|int
name|n
init|=
name|parse_branchname_arg
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|dwim_ok
argument_list|,
operator|&
name|new
argument_list|,
operator|&
name|opts
operator|.
name|source_tree
argument_list|,
name|rev
argument_list|,
operator|&
name|opts
operator|.
name|new_branch
argument_list|)
decl_stmt|;
name|argv
operator|+=
name|n
expr_stmt|;
name|argc
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|argc
condition|)
block|{
name|parse_pathspec
argument_list|(
operator|&
name|opts
operator|.
name|pathspec
argument_list|,
literal|0
argument_list|,
name|opts
operator|.
name|patch_mode
condition|?
name|PATHSPEC_PREFIX_ORIGIN
else|:
literal|0
argument_list|,
name|prefix
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opts
operator|.
name|pathspec
operator|.
name|nr
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"invalid path specification"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Try to give more helpful suggestion. 		 * new_branch&& argc> 1 will be caught later. 		 */
if|if
condition|(
name|opts
operator|.
name|new_branch
operator|&&
name|argc
operator|==
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot update paths and switch to branch '%s' at the same time.\n"
literal|"Did you intend to checkout '%s' which can not be resolved as commit?"
argument_list|)
argument_list|,
name|opts
operator|.
name|new_branch
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|.
name|force_detach
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: --detach does not take a path argument '%s'"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
operator|!
operator|!
name|opts
operator|.
name|writeout_stage
operator|+
operator|!
operator|!
name|opts
operator|.
name|force
operator|+
operator|!
operator|!
name|opts
operator|.
name|merge
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git checkout: --ours/--theirs, --force and --merge are incompatible when\n"
literal|"checking out of the index."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|.
name|new_branch
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|opts
operator|.
name|branch_exists
operator|=
name|validate_new_branchname
argument_list|(
name|opts
operator|.
name|new_branch
argument_list|,
operator|&
name|buf
argument_list|,
operator|!
operator|!
name|opts
operator|.
name|new_branch_force
argument_list|,
operator|!
operator|!
name|opts
operator|.
name|new_branch_force
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|.
name|patch_mode
operator|||
name|opts
operator|.
name|pathspec
operator|.
name|nr
condition|)
return|return
name|checkout_paths
argument_list|(
operator|&
name|opts
argument_list|,
name|new
operator|.
name|name
argument_list|)
return|;
else|else
return|return
name|checkout_branch
argument_list|(
operator|&
name|opts
argument_list|,
operator|&
name|new
argument_list|)
return|;
block|}
end_function
end_unit
