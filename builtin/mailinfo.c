begin_unit
begin_comment
comment|/*  * Another stupid program, this one parsing the headers of an  * email to figure out authorship and subject  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_decl_stmt
DECL|variable|cmitmsg
DECL|variable|patchfile
DECL|variable|fin
DECL|variable|fout
specifier|static
name|FILE
modifier|*
name|cmitmsg
decl_stmt|,
modifier|*
name|patchfile
decl_stmt|,
modifier|*
name|fin
decl_stmt|,
modifier|*
name|fout
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keep_subject
specifier|static
name|int
name|keep_subject
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keep_non_patch_brackets_in_subject
specifier|static
name|int
name|keep_non_patch_brackets_in_subject
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|metainfo_charset
specifier|static
specifier|const
name|char
modifier|*
name|metainfo_charset
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|line
specifier|static
name|struct
name|strbuf
name|line
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|name
specifier|static
name|struct
name|strbuf
name|name
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|email
specifier|static
name|struct
name|strbuf
name|email
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|TE_DONTCARE
DECL|enumerator|TE_QP
DECL|enumerator|TE_BASE64
name|TE_DONTCARE
block|,
name|TE_QP
block|,
name|TE_BASE64
block|}
DECL|variable|transfer_encoding
name|transfer_encoding
enum|;
end_enum
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|TYPE_TEXT
DECL|enumerator|TYPE_OTHER
name|TYPE_TEXT
block|,
name|TYPE_OTHER
block|}
DECL|variable|message_type
name|message_type
enum|;
end_enum
begin_decl_stmt
DECL|variable|charset
specifier|static
name|struct
name|strbuf
name|charset
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|patch_lines
specifier|static
name|int
name|patch_lines
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|p_hdr_data
DECL|variable|s_hdr_data
specifier|static
name|struct
name|strbuf
modifier|*
modifier|*
name|p_hdr_data
decl_stmt|,
modifier|*
modifier|*
name|s_hdr_data
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_scissors
specifier|static
name|int
name|use_scissors
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_inbody_headers
specifier|static
name|int
name|use_inbody_headers
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|MAX_HDR_PARSED
define|#
directive|define
name|MAX_HDR_PARSED
value|10
end_define
begin_define
DECL|macro|MAX_BOUNDARIES
define|#
directive|define
name|MAX_BOUNDARIES
value|5
end_define
begin_function_decl
specifier|static
name|void
name|cleanup_space
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|get_sane_name
specifier|static
name|void
name|get_sane_name
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|struct
name|strbuf
modifier|*
name|name
parameter_list|,
name|struct
name|strbuf
modifier|*
name|email
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|src
init|=
name|name
decl_stmt|;
if|if
condition|(
name|name
operator|->
name|len
operator|<
literal|3
operator|||
literal|60
operator|<
name|name
operator|->
name|len
operator|||
name|strchr
argument_list|(
name|name
operator|->
name|buf
argument_list|,
literal|'@'
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
operator|->
name|buf
argument_list|,
literal|'<'
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
operator|->
name|buf
argument_list|,
literal|'>'
argument_list|)
condition|)
name|src
operator|=
name|email
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|==
name|out
condition|)
return|return;
name|strbuf_reset
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
name|out
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_bogus_from
specifier|static
name|void
name|parse_bogus_from
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
comment|/* John Doe<johndoe> */
name|char
modifier|*
name|bra
decl_stmt|,
modifier|*
name|ket
decl_stmt|;
comment|/* This is fallback, so do not bother if we already have an 	 * e-mail address. 	 */
if|if
condition|(
name|email
operator|.
name|len
condition|)
return|return;
name|bra
operator|=
name|strchr
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bra
condition|)
return|return;
name|ket
operator|=
name|strchr
argument_list|(
name|bra
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ket
condition|)
return|return;
name|strbuf_reset
argument_list|(
operator|&
name|email
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|email
argument_list|,
name|bra
operator|+
literal|1
argument_list|,
name|ket
operator|-
name|bra
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|name
argument_list|,
name|line
operator|->
name|buf
argument_list|,
name|bra
operator|-
name|line
operator|->
name|buf
argument_list|)
expr_stmt|;
name|strbuf_trim
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|get_sane_name
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|email
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_from
specifier|static
name|void
name|handle_from
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|from
parameter_list|)
block|{
name|char
modifier|*
name|at
decl_stmt|;
name|size_t
name|el
decl_stmt|;
name|struct
name|strbuf
name|f
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|f
argument_list|,
name|from
operator|->
name|len
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|f
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|at
operator|=
name|strchr
argument_list|(
name|f
operator|.
name|buf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|at
condition|)
block|{
name|parse_bogus_from
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we already have one email, don't take any confusing lines 	 */
if|if
condition|(
name|email
operator|.
name|len
operator|&&
name|strchr
argument_list|(
name|at
operator|+
literal|1
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Pick up the string around '@', possibly delimited with<> 	 * pair; that is the email part. 	 */
while|while
condition|(
name|at
operator|>
name|f
operator|.
name|buf
condition|)
block|{
name|char
name|c
init|=
name|at
index|[
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|at
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
name|at
operator|--
expr_stmt|;
block|}
name|el
operator|=
name|strcspn
argument_list|(
name|at
argument_list|,
literal|" \n\t\r\v\f>"
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|email
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|email
argument_list|,
name|at
argument_list|,
name|el
argument_list|)
expr_stmt|;
name|strbuf_remove
argument_list|(
operator|&
name|f
argument_list|,
name|at
operator|-
name|f
operator|.
name|buf
argument_list|,
name|el
operator|+
operator|(
name|at
index|[
name|el
index|]
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* The remainder is name.  It could be 	 * 	 * - "John Doe<john.doe@xz>"			(a), or 	 * - "john.doe@xz (John Doe)"			(b), or 	 * - "John (zzz) Doe<john.doe@xz> (Comment)"	(c) 	 * 	 * but we have removed the email part, so 	 * 	 * - remove extra spaces which could stay after email (case 'c'), and 	 * - trim from both ends, possibly removing the () pair at the end 	 *   (cases 'a' and 'b'). 	 */
name|cleanup_space
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
name|strbuf_trim
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|buf
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
name|f
operator|.
name|len
operator|&&
name|f
operator|.
name|buf
index|[
name|f
operator|.
name|len
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
name|strbuf_remove
argument_list|(
operator|&
name|f
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|f
argument_list|,
name|f
operator|.
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|get_sane_name
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|email
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_header
specifier|static
name|void
name|handle_header
parameter_list|(
name|struct
name|strbuf
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|out
condition|)
block|{
operator|*
name|out
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|*
name|out
argument_list|,
name|line
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_reset
argument_list|(
operator|*
name|out
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|*
name|out
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* NOTE NOTE NOTE.  We do not claim we do full MIME.  We just attempt  * to have enough heuristics to grok MIME encoded patches often found  * on our mailing lists.  For example, we do not even treat header lines  * case insensitively.  */
end_comment
begin_function
DECL|function|slurp_attr
specifier|static
name|int
name|slurp_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|strbuf
modifier|*
name|attr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ends
decl_stmt|,
modifier|*
name|ap
init|=
name|strcasestr
argument_list|(
name|line
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
block|{
name|strbuf_setlen
argument_list|(
name|attr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ap
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'"'
condition|)
block|{
name|ap
operator|++
expr_stmt|;
name|ends
operator|=
literal|"\""
expr_stmt|;
block|}
else|else
name|ends
operator|=
literal|"; \t"
expr_stmt|;
name|sz
operator|=
name|strcspn
argument_list|(
name|ap
argument_list|,
name|ends
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|attr
argument_list|,
name|ap
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|content
specifier|static
name|struct
name|strbuf
modifier|*
name|content
index|[
name|MAX_BOUNDARIES
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|content_top
specifier|static
name|struct
name|strbuf
modifier|*
modifier|*
name|content_top
init|=
name|content
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|handle_content_type
specifier|static
name|void
name|handle_content_type
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|boundary
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|strbuf
argument_list|)
argument_list|)
decl_stmt|;
name|strbuf_init
argument_list|(
name|boundary
argument_list|,
name|line
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasestr
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"text/"
argument_list|)
condition|)
name|message_type
operator|=
name|TYPE_OTHER
expr_stmt|;
if|if
condition|(
name|slurp_attr
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"boundary="
argument_list|,
name|boundary
argument_list|)
condition|)
block|{
name|strbuf_insert
argument_list|(
name|boundary
argument_list|,
literal|0
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|content_top
operator|>
operator|&
name|content
index|[
name|MAX_BOUNDARIES
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many boundaries to handle\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|content_top
operator|=
name|boundary
expr_stmt|;
name|boundary
operator|=
name|NULL
expr_stmt|;
block|}
name|slurp_attr
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"charset="
argument_list|,
operator|&
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
name|boundary
condition|)
block|{
name|strbuf_release
argument_list|(
name|boundary
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|boundary
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handle_content_transfer_encoding
specifier|static
name|void
name|handle_content_transfer_encoding
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
name|strcasestr
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"base64"
argument_list|)
condition|)
name|transfer_encoding
operator|=
name|TE_BASE64
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasestr
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"quoted-printable"
argument_list|)
condition|)
name|transfer_encoding
operator|=
name|TE_QP
expr_stmt|;
else|else
name|transfer_encoding
operator|=
name|TE_DONTCARE
expr_stmt|;
block|}
end_function
begin_function
DECL|function|is_multipart_boundary
specifier|static
name|int
name|is_multipart_boundary
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|*
name|content_top
operator|)
operator|->
name|len
operator|<=
name|line
operator|->
name|len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|line
operator|->
name|buf
argument_list|,
operator|(
operator|*
name|content_top
operator|)
operator|->
name|buf
argument_list|,
operator|(
operator|*
name|content_top
operator|)
operator|->
name|len
argument_list|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|cleanup_subject
specifier|static
name|void
name|cleanup_subject
parameter_list|(
name|struct
name|strbuf
modifier|*
name|subject
parameter_list|)
block|{
name|size_t
name|at
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|at
operator|<
name|subject
operator|->
name|len
condition|)
block|{
name|char
modifier|*
name|pos
decl_stmt|;
name|size_t
name|remove
decl_stmt|;
switch|switch
condition|(
name|subject
operator|->
name|buf
index|[
name|at
index|]
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
if|if
condition|(
name|subject
operator|->
name|len
operator|<=
name|at
operator|+
literal|3
condition|)
break|break;
if|if
condition|(
operator|(
name|subject
operator|->
name|buf
index|[
name|at
operator|+
literal|1
index|]
operator|==
literal|'e'
operator|||
name|subject
operator|->
name|buf
index|[
name|at
operator|+
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|&&
name|subject
operator|->
name|buf
index|[
name|at
operator|+
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|strbuf_remove
argument_list|(
name|subject
argument_list|,
name|at
argument_list|,
literal|3
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|at
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|':'
case|:
name|strbuf_remove
argument_list|(
name|subject
argument_list|,
name|at
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
name|pos
operator|=
name|strchr
argument_list|(
name|subject
operator|->
name|buf
operator|+
name|at
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
name|remove
operator|=
name|pos
operator|-
name|subject
operator|->
name|buf
operator|+
name|at
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|keep_non_patch_brackets_in_subject
operator|||
operator|(
literal|7
operator|<=
name|remove
operator|&&
name|memmem
argument_list|(
name|subject
operator|->
name|buf
operator|+
name|at
argument_list|,
name|remove
argument_list|,
literal|"PATCH"
argument_list|,
literal|5
argument_list|)
operator|)
condition|)
name|strbuf_remove
argument_list|(
name|subject
argument_list|,
name|at
argument_list|,
name|remove
argument_list|)
expr_stmt|;
else|else
block|{
name|at
operator|+=
name|remove
expr_stmt|;
comment|/* 				 * If the input had a space after the ], keep 				 * it.  We don't bother with finding the end of 				 * the space, since we later normalize it 				 * anyway. 				 */
if|if
condition|(
name|isspace
argument_list|(
name|subject
operator|->
name|buf
index|[
name|at
index|]
argument_list|)
condition|)
name|at
operator|+=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
block|}
name|strbuf_trim
argument_list|(
name|subject
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cleanup_space
specifier|static
name|void
name|cleanup_space
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|size_t
name|pos
decl_stmt|,
name|cnt
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|sb
operator|->
name|len
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|sb
operator|->
name|buf
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
name|sb
operator|->
name|buf
index|[
name|pos
index|]
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|isspace
argument_list|(
name|sb
operator|->
name|buf
index|[
name|pos
operator|+
name|cnt
operator|+
literal|1
index|]
argument_list|)
condition|;
name|cnt
operator|++
control|)
empty_stmt|;
name|strbuf_remove
argument_list|(
name|sb
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function_decl
specifier|static
name|void
name|decode_header
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|header
specifier|static
specifier|const
name|char
modifier|*
name|header
index|[
name|MAX_HDR_PARSED
index|]
init|=
block|{
literal|"From"
block|,
literal|"Subject"
block|,
literal|"Date"
block|, }
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cmp_header
specifier|static
specifier|inline
name|int
name|cmp_header
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|hdr
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
return|return
operator|!
name|strncasecmp
argument_list|(
name|line
operator|->
name|buf
argument_list|,
name|hdr
argument_list|,
name|len
argument_list|)
operator|&&
name|line
operator|->
name|len
operator|>
name|len
operator|&&
name|line
operator|->
name|buf
index|[
name|len
index|]
operator|==
literal|':'
operator|&&
name|isspace
argument_list|(
name|line
operator|->
name|buf
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|check_header
specifier|static
name|int
name|check_header
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|,
name|struct
name|strbuf
modifier|*
name|hdr_data
index|[]
parameter_list|,
name|int
name|overwrite
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* search for the interesting parts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|header
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|hdr_data
index|[
name|i
index|]
operator|||
name|overwrite
operator|)
operator|&&
name|cmp_header
argument_list|(
name|line
argument_list|,
name|header
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Unwrap inline B and Q encoding, and optionally 			 * normalize the meta information to utf8. 			 */
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|line
operator|->
name|buf
operator|+
name|len
operator|+
literal|2
argument_list|,
name|line
operator|->
name|len
operator|-
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|decode_header
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|handle_header
argument_list|(
operator|&
name|hdr_data
index|[
name|i
index|]
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|check_header_out
goto|;
block|}
block|}
comment|/* Content stuff */
if|if
condition|(
name|cmp_header
argument_list|(
name|line
argument_list|,
literal|"Content-Type"
argument_list|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
literal|"Content-Type: "
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|line
operator|->
name|buf
operator|+
name|len
argument_list|,
name|line
operator|->
name|len
operator|-
name|len
argument_list|)
expr_stmt|;
name|decode_header
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
literal|"Content-Type: "
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|handle_content_type
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|check_header_out
goto|;
block|}
if|if
condition|(
name|cmp_header
argument_list|(
name|line
argument_list|,
literal|"Content-Transfer-Encoding"
argument_list|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
literal|"Content-Transfer-Encoding: "
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|line
operator|->
name|buf
operator|+
name|len
argument_list|,
name|line
operator|->
name|len
operator|-
name|len
argument_list|)
expr_stmt|;
name|decode_header
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|handle_content_transfer_encoding
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|check_header_out
goto|;
block|}
comment|/* for inbody stuff */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|">From"
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
operator|->
name|buf
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* Should this return 0? */
goto|goto
name|check_header_out
goto|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"[PATCH]"
argument_list|)
operator|&&
name|isspace
argument_list|(
name|line
operator|->
name|buf
index|[
literal|7
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"Subject"
argument_list|,
name|header
index|[
name|i
index|]
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|handle_header
argument_list|(
operator|&
name|hdr_data
index|[
name|i
index|]
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|check_header_out
goto|;
block|}
block|}
block|}
name|check_header_out
label|:
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|is_rfc2822_header
specifier|static
name|int
name|is_rfc2822_header
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
comment|/* 	 * The section that defines the loosest possible 	 * field name is "3.6.8 Optional fields". 	 * 	 * optional-field = field-name ":" unstructured CRLF 	 * field-name = 1*ftext 	 * ftext = %d33-57 / %59-126 	 */
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|line
operator|->
name|buf
decl_stmt|;
comment|/* Count mbox From headers as headers */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|cp
argument_list|,
literal|"From "
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|cp
argument_list|,
literal|">From "
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
literal|33
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|57
operator|)
operator|||
operator|(
literal|59
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|126
operator|)
condition|)
continue|continue;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_one_header_line
specifier|static
name|int
name|read_one_header_line
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
comment|/* Get the first part of the line. */
if|if
condition|(
name|strbuf_getline
argument_list|(
name|line
argument_list|,
name|in
argument_list|,
literal|'\n'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Is it an empty line or not a valid rfc2822 header? 	 * If so, stop here, and return false ("not a header") 	 */
name|strbuf_rtrim
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
operator|->
name|len
operator|||
operator|!
name|is_rfc2822_header
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* Re-add the newline */
name|strbuf_addch
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Now we need to eat all the continuation lines.. 	 * Yuck, 2822 header "folding" 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|peek
decl_stmt|;
name|struct
name|strbuf
name|continuation
init|=
name|STRBUF_INIT
decl_stmt|;
name|peek
operator|=
name|fgetc
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|peek
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|!=
literal|' '
operator|&&
name|peek
operator|!=
literal|'\t'
condition|)
break|break;
if|if
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|continuation
argument_list|,
name|in
argument_list|,
literal|'\n'
argument_list|)
condition|)
break|break;
name|continuation
operator|.
name|buf
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|strbuf_rtrim
argument_list|(
operator|&
name|continuation
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
name|line
argument_list|,
operator|&
name|continuation
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|decode_q_segment
specifier|static
name|struct
name|strbuf
modifier|*
name|decode_q_segment
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|q_seg
parameter_list|,
name|int
name|rfc2047
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|in
init|=
name|q_seg
operator|->
name|buf
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|out
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|strbuf
argument_list|)
argument_list|)
decl_stmt|;
name|strbuf_init
argument_list|(
name|out
argument_list|,
name|q_seg
operator|->
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|in
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|int
name|d
init|=
operator|*
name|in
operator|++
decl_stmt|;
if|if
condition|(
name|d
operator|==
literal|'\n'
operator|||
operator|!
name|d
condition|)
break|break;
comment|/* drop trailing newline */
name|strbuf_addch
argument_list|(
name|out
argument_list|,
operator|(
name|hexval
argument_list|(
name|d
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hexval
argument_list|(
operator|*
name|in
operator|++
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rfc2047
operator|&&
name|c
operator|==
literal|'_'
condition|)
comment|/* rfc2047 4.2 (2) */
name|c
operator|=
literal|0x20
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|decode_b_segment
specifier|static
name|struct
name|strbuf
modifier|*
name|decode_b_segment
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|b_seg
parameter_list|)
block|{
comment|/* Decode in..ep, possibly in-place to ot */
name|int
name|c
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|,
name|acc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|in
init|=
name|b_seg
operator|->
name|buf
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|out
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|strbuf
argument_list|)
argument_list|)
decl_stmt|;
name|strbuf_init
argument_list|(
name|out
argument_list|,
name|b_seg
operator|->
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|in
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
literal|62
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|c
operator|=
literal|63
expr_stmt|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|-=
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|-=
literal|'a'
operator|-
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|c
operator|-=
literal|'0'
operator|-
literal|52
expr_stmt|;
else|else
continue|continue;
comment|/* garbage */
switch|switch
condition|(
name|pos
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|acc
operator|=
operator|(
name|c
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|strbuf_addch
argument_list|(
name|out
argument_list|,
operator|(
name|acc
operator||
operator|(
name|c
operator|>>
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|acc
operator|=
operator|(
name|c
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strbuf_addch
argument_list|(
name|out
argument_list|,
operator|(
name|acc
operator||
operator|(
name|c
operator|>>
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|acc
operator|=
operator|(
name|c
operator|&
literal|3
operator|)
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strbuf_addch
argument_list|(
name|out
argument_list|,
operator|(
name|acc
operator||
name|c
operator|)
argument_list|)
expr_stmt|;
name|acc
operator|=
name|pos
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*  * When there is no known charset, guess.  *  * Right now we assume that if the target is UTF-8 (the default),  * and it already looks like UTF-8 (which includes US-ASCII as its  * subset, of course) then that is what it is and there is nothing  * to do.  *  * Otherwise, we default to assuming it is Latin1 for historical  * reasons.  */
end_comment
begin_function
DECL|function|guess_charset
specifier|static
specifier|const
name|char
modifier|*
name|guess_charset
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|target_charset
parameter_list|)
block|{
if|if
condition|(
name|is_encoding_utf8
argument_list|(
name|target_charset
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_utf8
argument_list|(
name|line
operator|->
name|buf
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
literal|"ISO8859-1"
return|;
block|}
end_function
begin_function
DECL|function|convert_to_utf8
specifier|static
name|void
name|convert_to_utf8
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|charset
parameter_list|)
block|{
name|char
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|charset
operator|||
operator|!
operator|*
name|charset
condition|)
block|{
name|charset
operator|=
name|guess_charset
argument_list|(
name|line
argument_list|,
name|metainfo_charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|charset
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|metainfo_charset
argument_list|,
name|charset
argument_list|)
condition|)
return|return;
name|out
operator|=
name|reencode_string
argument_list|(
name|line
operator|->
name|buf
argument_list|,
name|metainfo_charset
argument_list|,
name|charset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
name|die
argument_list|(
literal|"cannot convert from %s to %s"
argument_list|,
name|charset
argument_list|,
name|metainfo_charset
argument_list|)
expr_stmt|;
name|strbuf_attach
argument_list|(
name|line
argument_list|,
name|out
argument_list|,
name|strlen
argument_list|(
name|out
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decode_header_bq
specifier|static
name|int
name|decode_header_bq
parameter_list|(
name|struct
name|strbuf
modifier|*
name|it
parameter_list|)
block|{
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|strbuf
name|outbuf
init|=
name|STRBUF_INIT
decl_stmt|,
modifier|*
name|dec
decl_stmt|;
name|struct
name|strbuf
name|charset_q
init|=
name|STRBUF_INIT
decl_stmt|,
name|piecebuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|rfc2047
init|=
literal|0
decl_stmt|;
name|in
operator|=
name|it
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|in
operator|-
name|it
operator|->
name|buf
operator|<=
name|it
operator|->
name|len
operator|&&
operator|(
name|ep
operator|=
name|strstr
argument_list|(
name|in
argument_list|,
literal|"=?"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|encoding
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|charset_q
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|piecebuf
argument_list|)
expr_stmt|;
name|rfc2047
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|ep
condition|)
block|{
comment|/* 			 * We are about to process an encoded-word 			 * that begins at ep, but there is something 			 * before the encoded word. 			 */
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|in
init|;
name|scan
operator|<
name|ep
condition|;
name|scan
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
break|break;
if|if
condition|(
name|scan
operator|!=
name|ep
operator|||
name|in
operator|==
name|it
operator|->
name|buf
condition|)
block|{
comment|/* 				 * We should not lose that "something", 				 * unless we have just processed an 				 * encoded-word, and there is only LWS 				 * before the one we are about to process. 				 */
name|strbuf_add
argument_list|(
operator|&
name|outbuf
argument_list|,
name|in
argument_list|,
name|ep
operator|-
name|in
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* E.g. 		 * ep : "=?iso-2022-jp?B?GyR...?= foo" 		 * ep : "=?ISO-8859-1?Q?Foo=FCbar?= baz" 		 */
name|ep
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ep
operator|-
name|it
operator|->
name|buf
operator|>=
name|it
operator|->
name|len
operator|||
operator|!
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|ep
argument_list|,
literal|'?'
argument_list|)
operator|)
condition|)
goto|goto
name|decode_header_bq_out
goto|;
if|if
condition|(
name|cp
operator|+
literal|3
operator|-
name|it
operator|->
name|buf
operator|>
name|it
operator|->
name|len
condition|)
goto|goto
name|decode_header_bq_out
goto|;
name|strbuf_add
argument_list|(
operator|&
name|charset_q
argument_list|,
name|ep
argument_list|,
name|cp
operator|-
name|ep
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
operator|||
name|cp
index|[
literal|2
index|]
operator|!=
literal|'?'
condition|)
goto|goto
name|decode_header_bq_out
goto|;
name|ep
operator|=
name|strstr
argument_list|(
name|cp
operator|+
literal|3
argument_list|,
literal|"?="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
goto|goto
name|decode_header_bq_out
goto|;
name|strbuf_add
argument_list|(
operator|&
name|piecebuf
argument_list|,
name|cp
operator|+
literal|3
argument_list|,
name|ep
operator|-
name|cp
operator|-
literal|3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tolower
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|decode_header_bq_out
goto|;
case|case
literal|'b'
case|:
name|dec
operator|=
name|decode_b_segment
argument_list|(
operator|&
name|piecebuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|dec
operator|=
name|decode_q_segment
argument_list|(
operator|&
name|piecebuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|dec
argument_list|,
name|charset_q
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|outbuf
argument_list|,
name|dec
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
name|dec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dec
argument_list|)
expr_stmt|;
name|in
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|outbuf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
name|it
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
name|decode_header_bq_out
label|:
name|strbuf_release
argument_list|(
operator|&
name|outbuf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|charset_q
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|piecebuf
argument_list|)
expr_stmt|;
return|return
name|rfc2047
return|;
block|}
end_function
begin_function
DECL|function|decode_header
specifier|static
name|void
name|decode_header
parameter_list|(
name|struct
name|strbuf
modifier|*
name|it
parameter_list|)
block|{
if|if
condition|(
name|decode_header_bq
argument_list|(
name|it
argument_list|)
condition|)
return|return;
comment|/* otherwise "it" is a straight copy of the input. 	 * This can be binary guck but there is no charset specified. 	 */
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|it
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|decode_transfer_encoding
specifier|static
name|void
name|decode_transfer_encoding
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|ret
decl_stmt|;
switch|switch
condition|(
name|transfer_encoding
condition|)
block|{
case|case
name|TE_QP
case|:
name|ret
operator|=
name|decode_q_segment
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TE_BASE64
case|:
name|ret
operator|=
name|decode_b_segment
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|TE_DONTCARE
case|:
default|default:
return|return;
block|}
name|strbuf_reset
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
name|line
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|handle_filter
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|find_boundary
specifier|static
name|int
name|find_boundary
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|!
name|strbuf_getline
argument_list|(
operator|&
name|line
argument_list|,
name|fin
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|content_top
operator|&&
name|is_multipart_boundary
argument_list|(
operator|&
name|line
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_boundary
specifier|static
name|int
name|handle_boundary
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|strbuf
name|newline
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|newline
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|line
operator|.
name|len
operator|>=
operator|(
operator|*
name|content_top
operator|)
operator|->
name|len
operator|+
literal|2
operator|&&
operator|!
name|memcmp
argument_list|(
name|line
operator|.
name|buf
operator|+
operator|(
operator|*
name|content_top
operator|)
operator|->
name|len
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* we hit an end boundary */
comment|/* pop the current boundary off the stack */
name|strbuf_release
argument_list|(
operator|*
name|content_top
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|content_top
argument_list|)
expr_stmt|;
operator|*
name|content_top
operator|=
name|NULL
expr_stmt|;
comment|/* technically won't happen as is_multipart_boundary() 		   will fail first.  But just in case.. 		 */
if|if
condition|(
operator|--
name|content_top
operator|<
name|content
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Detected mismatched boundaries, "
literal|"can't recover\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|handle_filter
argument_list|(
operator|&
name|newline
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|newline
argument_list|)
expr_stmt|;
comment|/* skip to the next boundary */
if|if
condition|(
operator|!
name|find_boundary
argument_list|()
condition|)
return|return
literal|0
return|;
goto|goto
name|again
goto|;
block|}
comment|/* set some defaults */
name|transfer_encoding
operator|=
name|TE_DONTCARE
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|charset
argument_list|)
expr_stmt|;
name|message_type
operator|=
name|TYPE_TEXT
expr_stmt|;
comment|/* slurp in this section's info */
while|while
condition|(
name|read_one_header_line
argument_list|(
operator|&
name|line
argument_list|,
name|fin
argument_list|)
condition|)
name|check_header
argument_list|(
operator|&
name|line
argument_list|,
name|p_hdr_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|newline
argument_list|)
expr_stmt|;
comment|/* replenish line */
if|if
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|line
argument_list|,
name|fin
argument_list|,
literal|'\n'
argument_list|)
condition|)
return|return
literal|0
return|;
name|strbuf_addch
argument_list|(
operator|&
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|patchbreak
specifier|static
specifier|inline
name|int
name|patchbreak
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* Beginning of a "diff -" header? */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"diff -"
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* CVS "Index: " line? */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"Index: "
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* 	 * "---<filename>" starts patches without headers 	 * "---<sp>*" is a manual separator 	 */
if|if
condition|(
name|line
operator|->
name|len
operator|<
literal|4
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|"---"
argument_list|)
condition|)
block|{
comment|/* space followed by a filename? */
if|if
condition|(
name|line
operator|->
name|buf
index|[
literal|3
index|]
operator|==
literal|' '
operator|&&
operator|!
name|isspace
argument_list|(
name|line
operator|->
name|buf
index|[
literal|4
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Just whitespace? */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|line
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
name|line
operator|->
name|buf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_scissors_line
specifier|static
name|int
name|is_scissors_line
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|len
init|=
name|line
operator|->
name|len
decl_stmt|;
name|int
name|scissors
init|=
literal|0
decl_stmt|,
name|gap
init|=
literal|0
decl_stmt|;
name|int
name|first_nonblank
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|last_nonblank
init|=
literal|0
decl_stmt|,
name|visible
decl_stmt|,
name|perforation
init|=
literal|0
decl_stmt|,
name|in_perforation
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
name|line
operator|->
name|buf
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|in_perforation
condition|)
block|{
name|perforation
operator|++
expr_stmt|;
name|gap
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
name|last_nonblank
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|first_nonblank
operator|<
literal|0
condition|)
name|first_nonblank
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|in_perforation
operator|=
literal|1
expr_stmt|;
name|perforation
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|len
operator|&&
operator|(
operator|!
name|memcmp
argument_list|(
name|buf
operator|+
name|i
argument_list|,
literal|">8"
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|memcmp
argument_list|(
name|buf
operator|+
name|i
argument_list|,
literal|"8<"
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|memcmp
argument_list|(
name|buf
operator|+
name|i
argument_list|,
literal|">%"
argument_list|,
literal|2
argument_list|)
operator|||
operator|!
name|memcmp
argument_list|(
name|buf
operator|+
name|i
argument_list|,
literal|"%<"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|in_perforation
operator|=
literal|1
expr_stmt|;
name|perforation
operator|+=
literal|2
expr_stmt|;
name|scissors
operator|+=
literal|2
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|in_perforation
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * The mark must be at least 8 bytes long (e.g. "-->8 --"). 	 * Even though there can be arbitrary cruft on the same line 	 * (e.g. "cut here"), in order to avoid misidentification, the 	 * perforation must occupy more than a third of the visible 	 * width of the line, and dashes and scissors must occupy more 	 * than half of the perforation. 	 */
name|visible
operator|=
name|last_nonblank
operator|-
name|first_nonblank
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|scissors
operator|&&
literal|8
operator|<=
name|visible
operator|&&
name|visible
operator|<
name|perforation
operator|*
literal|3
operator|&&
name|gap
operator|*
literal|2
operator|<
name|perforation
operator|)
return|;
block|}
end_function
begin_function
DECL|function|handle_commit_msg
specifier|static
name|int
name|handle_commit_msg
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
specifier|static
name|int
name|still_looking
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|cmitmsg
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|still_looking
condition|)
block|{
if|if
condition|(
operator|!
name|line
operator|->
name|len
operator|||
operator|(
name|line
operator|->
name|len
operator|==
literal|1
operator|&&
name|line
operator|->
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|use_inbody_headers
operator|&&
name|still_looking
condition|)
block|{
name|still_looking
operator|=
name|check_header
argument_list|(
name|line
argument_list|,
name|s_hdr_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_looking
condition|)
return|return
literal|0
return|;
block|}
else|else
comment|/* Only trim the first (blank) line of the commit message 		 * when ignoring in-body headers. 		 */
name|still_looking
operator|=
literal|0
expr_stmt|;
comment|/* normalize the log message to UTF-8. */
if|if
condition|(
name|metainfo_charset
condition|)
name|convert_to_utf8
argument_list|(
name|line
argument_list|,
name|charset
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_scissors
operator|&&
name|is_scissors_line
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|cmitmsg
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"Could not rewind output message file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|cmitmsg
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"Could not truncate output message file at scissors"
argument_list|)
expr_stmt|;
name|still_looking
operator|=
literal|1
expr_stmt|;
comment|/* 		 * We may have already read "secondary headers"; purge 		 * them to give ourselves a clean restart. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s_hdr_data
index|[
name|i
index|]
condition|)
name|strbuf_release
argument_list|(
name|s_hdr_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|s_hdr_data
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|patchbreak
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|cmitmsg
argument_list|)
expr_stmt|;
name|cmitmsg
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fputs
argument_list|(
name|line
operator|->
name|buf
argument_list|,
name|cmitmsg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|handle_patch
specifier|static
name|void
name|handle_patch
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
name|fwrite
argument_list|(
name|line
operator|->
name|buf
argument_list|,
literal|1
argument_list|,
name|line
operator|->
name|len
argument_list|,
name|patchfile
argument_list|)
expr_stmt|;
name|patch_lines
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_filter
specifier|static
name|void
name|handle_filter
parameter_list|(
name|struct
name|strbuf
modifier|*
name|line
parameter_list|)
block|{
specifier|static
name|int
name|filter
init|=
literal|0
decl_stmt|;
comment|/* filter tells us which part we left off on */
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|handle_commit_msg
argument_list|(
name|line
argument_list|)
condition|)
break|break;
name|filter
operator|++
expr_stmt|;
case|case
literal|1
case|:
name|handle_patch
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|handle_body
specifier|static
name|void
name|handle_body
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|strbuf
name|prev
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* Skip up to the first boundary */
if|if
condition|(
operator|*
name|content_top
condition|)
block|{
if|if
condition|(
operator|!
name|find_boundary
argument_list|()
condition|)
goto|goto
name|handle_body_out
goto|;
block|}
do|do
block|{
comment|/* process any boundary lines */
if|if
condition|(
operator|*
name|content_top
operator|&&
name|is_multipart_boundary
argument_list|(
operator|&
name|line
argument_list|)
condition|)
block|{
comment|/* flush any leftover */
if|if
condition|(
name|prev
operator|.
name|len
condition|)
block|{
name|handle_filter
argument_list|(
operator|&
name|prev
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|handle_boundary
argument_list|()
condition|)
goto|goto
name|handle_body_out
goto|;
block|}
comment|/* Unwrap transfer encoding */
name|decode_transfer_encoding
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|transfer_encoding
condition|)
block|{
case|case
name|TE_BASE64
case|:
case|case
name|TE_QP
case|:
block|{
name|struct
name|strbuf
modifier|*
modifier|*
name|lines
decl_stmt|,
modifier|*
modifier|*
name|it
decl_stmt|,
modifier|*
name|sb
decl_stmt|;
comment|/* Prepend any previous partial lines */
name|strbuf_insert
argument_list|(
operator|&
name|line
argument_list|,
literal|0
argument_list|,
name|prev
operator|.
name|buf
argument_list|,
name|prev
operator|.
name|len
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|prev
argument_list|)
expr_stmt|;
comment|/* binary data most likely doesn't have newlines */
if|if
condition|(
name|message_type
operator|!=
name|TYPE_TEXT
condition|)
block|{
name|handle_filter
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * This is a decoded line that may contain 			 * multiple new lines.  Pass only one chunk 			 * at a time to handle_filter() 			 */
name|lines
operator|=
name|strbuf_split
argument_list|(
operator|&
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|it
operator|=
name|lines
init|;
operator|(
name|sb
operator|=
operator|*
name|it
operator|)
condition|;
name|it
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|it
operator|+
literal|1
operator|)
operator|==
name|NULL
condition|)
comment|/* The last line */
if|if
condition|(
name|sb
operator|->
name|buf
index|[
name|sb
operator|->
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Partial line, save it for later. */
name|strbuf_addbuf
argument_list|(
operator|&
name|prev
argument_list|,
name|sb
argument_list|)
expr_stmt|;
break|break;
block|}
name|handle_filter
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * The partial chunk is saved in "prev" and will be 			 * appended by the next iteration of read_line_with_nul(). 			 */
name|strbuf_list_free
argument_list|(
name|lines
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|handle_filter
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|strbuf_getwholeline
argument_list|(
operator|&
name|line
argument_list|,
name|fin
argument_list|,
literal|'\n'
argument_list|)
condition|)
do|;
name|handle_body_out
label|:
name|strbuf_release
argument_list|(
operator|&
name|prev
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_header_lines
specifier|static
name|void
name|output_header_lines
parameter_list|(
name|FILE
modifier|*
name|fout
parameter_list|,
specifier|const
name|char
modifier|*
name|hdr
parameter_list|,
specifier|const
name|struct
name|strbuf
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sp
init|=
name|data
operator|->
name|buf
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|ep
init|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|ep
operator|-
name|sp
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s: %.*s\n"
argument_list|,
name|hdr
argument_list|,
name|len
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
break|break;
name|sp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|handle_info
specifier|static
name|void
name|handle_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|hdr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* only print inbody headers if we output a patch file */
if|if
condition|(
name|patch_lines
operator|&&
name|s_hdr_data
index|[
name|i
index|]
condition|)
name|hdr
operator|=
name|s_hdr_data
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|p_hdr_data
index|[
name|i
index|]
condition|)
name|hdr
operator|=
name|p_hdr_data
index|[
name|i
index|]
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|header
index|[
name|i
index|]
argument_list|,
literal|"Subject"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|keep_subject
condition|)
block|{
name|cleanup_subject
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|cleanup_space
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
name|output_header_lines
argument_list|(
name|fout
argument_list|,
literal|"Subject"
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|header
index|[
name|i
index|]
argument_list|,
literal|"From"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|cleanup_space
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|handle_from
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"Author: %s\n"
argument_list|,
name|name
operator|.
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"Email: %s\n"
argument_list|,
name|email
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cleanup_space
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|header
index|[
name|i
index|]
argument_list|,
name|hdr
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mailinfo
specifier|static
name|int
name|mailinfo
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|patch
parameter_list|)
block|{
name|int
name|peek
decl_stmt|;
name|fin
operator|=
name|in
expr_stmt|;
name|fout
operator|=
name|out
expr_stmt|;
name|cmitmsg
operator|=
name|fopen
argument_list|(
name|msg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmitmsg
condition|)
block|{
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|patchfile
operator|=
name|fopen
argument_list|(
name|patch
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patchfile
condition|)
block|{
name|perror
argument_list|(
name|patch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|cmitmsg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_hdr_data
operator|=
name|xcalloc
argument_list|(
name|MAX_HDR_PARSED
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_hdr_data
argument_list|)
argument_list|)
expr_stmt|;
name|s_hdr_data
operator|=
name|xcalloc
argument_list|(
name|MAX_HDR_PARSED
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s_hdr_data
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|peek
operator|=
name|fgetc
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|peek
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|peek
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* process the email header */
while|while
condition|(
name|read_one_header_line
argument_list|(
operator|&
name|line
argument_list|,
name|fin
argument_list|)
condition|)
name|check_header
argument_list|(
operator|&
name|line
argument_list|,
name|p_hdr_data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|handle_body
argument_list|()
expr_stmt|;
name|handle_info
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_mailinfo_config
specifier|static
name|int
name|git_mailinfo_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"mailinfo."
argument_list|)
condition|)
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|unused
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"mailinfo.scissors"
argument_list|)
condition|)
block|{
name|use_scissors
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* perhaps others here */
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|mailinfo_usage
specifier|static
specifier|const
name|char
name|mailinfo_usage
index|[]
init|=
literal|"git mailinfo [-k|-b] [-u | --encoding=<encoding> | -n] [--scissors | --no-scissors] msg patch< mail>info"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cmd_mailinfo
name|int
name|cmd_mailinfo
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|def_charset
decl_stmt|;
comment|/* NEEDSWORK: might want to do the optional .git/ directory 	 * discovery 	 */
name|git_config
argument_list|(
name|git_mailinfo_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|def_charset
operator|=
name|get_commit_output_encoding
argument_list|()
expr_stmt|;
name|metainfo_charset
operator|=
name|def_charset
expr_stmt|;
while|while
condition|(
literal|1
operator|<
name|argc
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-k"
argument_list|)
condition|)
name|keep_subject
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-b"
argument_list|)
condition|)
name|keep_non_patch_brackets_in_subject
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-u"
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|def_charset
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--encoding="
argument_list|)
condition|)
name|metainfo_charset
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|11
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--scissors"
argument_list|)
condition|)
name|use_scissors
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--no-scissors"
argument_list|)
condition|)
name|use_scissors
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--no-inbody-headers"
argument_list|)
condition|)
name|use_inbody_headers
operator|=
literal|0
expr_stmt|;
else|else
name|usage
argument_list|(
name|mailinfo_usage
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|usage
argument_list|(
name|mailinfo_usage
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|mailinfo
argument_list|(
name|stdin
argument_list|,
name|stdout
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
return|;
block|}
end_function
end_unit
