begin_unit
begin_comment
comment|/*  * Blame  *  * Copyright (c) 2006, Junio C Hamano  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"mailmap.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"userdiff.h"
end_include
begin_include
include|#
directive|include
file|"line-range.h"
end_include
begin_include
include|#
directive|include
file|"line-log.h"
end_include
begin_decl_stmt
DECL|variable|blame_usage
specifier|static
name|char
name|blame_usage
index|[]
init|=
name|N_
argument_list|(
literal|"git blame [options] [rev-opts] [rev] [--] file"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blame_opt_usage
specifier|static
specifier|const
name|char
modifier|*
name|blame_opt_usage
index|[]
init|=
block|{
name|blame_usage
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"[rev-opts] are documented in git-rev-list(1)"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|longest_file
specifier|static
name|int
name|longest_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|longest_author
specifier|static
name|int
name|longest_author
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_orig_digits
specifier|static
name|int
name|max_orig_digits
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_digits
specifier|static
name|int
name|max_digits
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|max_score_digits
specifier|static
name|int
name|max_score_digits
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|show_root
specifier|static
name|int
name|show_root
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|reverse
specifier|static
name|int
name|reverse
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blank_boundary
specifier|static
name|int
name|blank_boundary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|incremental
specifier|static
name|int
name|incremental
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xdl_opts
specifier|static
name|int
name|xdl_opts
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|abbrev
specifier|static
name|int
name|abbrev
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_whole_file_rename
specifier|static
name|int
name|no_whole_file_rename
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blame_date_mode
specifier|static
name|enum
name|date_mode
name|blame_date_mode
init|=
name|DATE_ISO8601
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blame_date_width
specifier|static
name|size_t
name|blame_date_width
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|mailmap
specifier|static
name|struct
name|string_list
name|mailmap
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* stats */
end_comment
begin_decl_stmt
DECL|variable|num_read_blob
specifier|static
name|int
name|num_read_blob
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|num_get_patch
specifier|static
name|int
name|num_get_patch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|num_commits
specifier|static
name|int
name|num_commits
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|PICKAXE_BLAME_MOVE
define|#
directive|define
name|PICKAXE_BLAME_MOVE
value|01
end_define
begin_define
DECL|macro|PICKAXE_BLAME_COPY
define|#
directive|define
name|PICKAXE_BLAME_COPY
value|02
end_define
begin_define
DECL|macro|PICKAXE_BLAME_COPY_HARDER
define|#
directive|define
name|PICKAXE_BLAME_COPY_HARDER
value|04
end_define
begin_define
DECL|macro|PICKAXE_BLAME_COPY_HARDEST
define|#
directive|define
name|PICKAXE_BLAME_COPY_HARDEST
value|010
end_define
begin_comment
comment|/*  * blame for a blame_entry with score lower than these thresholds  * is not passed to the parent using move/copy logic.  */
end_comment
begin_decl_stmt
DECL|variable|blame_move_score
specifier|static
name|unsigned
name|blame_move_score
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|blame_copy_score
specifier|static
name|unsigned
name|blame_copy_score
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|BLAME_DEFAULT_MOVE_SCORE
define|#
directive|define
name|BLAME_DEFAULT_MOVE_SCORE
value|20
end_define
begin_define
DECL|macro|BLAME_DEFAULT_COPY_SCORE
define|#
directive|define
name|BLAME_DEFAULT_COPY_SCORE
value|40
end_define
begin_comment
comment|/* bits #0..7 in revision.h, #8..11 used for merge_bases() in commit.c */
end_comment
begin_define
DECL|macro|METAINFO_SHOWN
define|#
directive|define
name|METAINFO_SHOWN
value|(1u<<12)
end_define
begin_define
DECL|macro|MORE_THAN_ONE_PATH
define|#
directive|define
name|MORE_THAN_ONE_PATH
value|(1u<<13)
end_define
begin_comment
comment|/*  * One blob in a commit that is being suspected  */
end_comment
begin_struct
DECL|struct|origin
struct|struct
name|origin
block|{
DECL|member|refcnt
name|int
name|refcnt
decl_stmt|;
DECL|member|previous
name|struct
name|origin
modifier|*
name|previous
decl_stmt|;
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
DECL|member|file
name|mmfile_t
name|file
decl_stmt|;
DECL|member|blob_sha1
name|unsigned
name|char
name|blob_sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|mode
name|unsigned
name|mode
decl_stmt|;
DECL|member|path
name|char
name|path
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|diff_hunks
specifier|static
name|int
name|diff_hunks
parameter_list|(
name|mmfile_t
modifier|*
name|file_a
parameter_list|,
name|mmfile_t
modifier|*
name|file_b
parameter_list|,
name|long
name|ctxlen
parameter_list|,
name|xdl_emit_hunk_consume_func_t
name|hunk_func
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|xpparam_t
name|xpp
init|=
block|{
literal|0
block|}
decl_stmt|;
name|xdemitconf_t
name|xecfg
init|=
block|{
literal|0
block|}
decl_stmt|;
name|xdemitcb_t
name|ecb
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|xpp
operator|.
name|flags
operator|=
name|xdl_opts
expr_stmt|;
name|xecfg
operator|.
name|ctxlen
operator|=
name|ctxlen
expr_stmt|;
name|xecfg
operator|.
name|hunk_func
operator|=
name|hunk_func
expr_stmt|;
name|ecb
operator|.
name|priv
operator|=
name|cb_data
expr_stmt|;
return|return
name|xdi_diff
argument_list|(
name|file_a
argument_list|,
name|file_b
argument_list|,
operator|&
name|xpp
argument_list|,
operator|&
name|xecfg
argument_list|,
operator|&
name|ecb
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Prepare diff_filespec and convert it using diff textconv API  * if the textconv driver exists.  * Return 1 if the conversion succeeds, 0 otherwise.  */
end_comment
begin_function
DECL|function|textconv_object
name|int
name|textconv_object
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|sha1_valid
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
modifier|*
name|buf_size
parameter_list|)
block|{
name|struct
name|diff_filespec
modifier|*
name|df
decl_stmt|;
name|struct
name|userdiff_driver
modifier|*
name|textconv
decl_stmt|;
name|df
operator|=
name|alloc_filespec
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|fill_filespec
argument_list|(
name|df
argument_list|,
name|sha1
argument_list|,
name|sha1_valid
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|textconv
operator|=
name|get_textconv
argument_list|(
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|textconv
condition|)
block|{
name|free_filespec
argument_list|(
name|df
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|buf_size
operator|=
name|fill_textconv
argument_list|(
name|textconv
argument_list|,
name|df
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free_filespec
argument_list|(
name|df
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Given an origin, prepare mmfile_t structure to be used by the  * diff machinery  */
end_comment
begin_function
DECL|function|fill_origin_blob
specifier|static
name|void
name|fill_origin_blob
parameter_list|(
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|,
name|struct
name|origin
modifier|*
name|o
parameter_list|,
name|mmfile_t
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
operator|->
name|file
operator|.
name|ptr
condition|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|file_size
decl_stmt|;
name|num_read_blob
operator|++
expr_stmt|;
if|if
condition|(
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|ALLOW_TEXTCONV
argument_list|)
operator|&&
name|textconv_object
argument_list|(
name|o
operator|->
name|path
argument_list|,
name|o
operator|->
name|mode
argument_list|,
name|o
operator|->
name|blob_sha1
argument_list|,
literal|1
argument_list|,
operator|&
name|file
operator|->
name|ptr
argument_list|,
operator|&
name|file_size
argument_list|)
condition|)
empty_stmt|;
else|else
name|file
operator|->
name|ptr
operator|=
name|read_sha1_file
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|file_size
argument_list|)
expr_stmt|;
name|file
operator|->
name|size
operator|=
name|file_size
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|ptr
condition|)
name|die
argument_list|(
literal|"Cannot read blob %s for path %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|)
argument_list|,
name|o
operator|->
name|path
argument_list|)
expr_stmt|;
name|o
operator|->
name|file
operator|=
operator|*
name|file
expr_stmt|;
block|}
else|else
operator|*
name|file
operator|=
name|o
operator|->
name|file
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Origin is refcounted and usually we keep the blob contents to be  * reused.  */
end_comment
begin_function
DECL|function|origin_incref
specifier|static
specifier|inline
name|struct
name|origin
modifier|*
name|origin_incref
parameter_list|(
name|struct
name|origin
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
condition|)
name|o
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|o
return|;
block|}
end_function
begin_function
DECL|function|origin_decref
specifier|static
name|void
name|origin_decref
parameter_list|(
name|struct
name|origin
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|&&
operator|--
name|o
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|previous
condition|)
name|origin_decref
argument_list|(
name|o
operator|->
name|previous
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o
operator|->
name|file
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|drop_origin_blob
specifier|static
name|void
name|drop_origin_blob
parameter_list|(
name|struct
name|origin
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|file
operator|.
name|ptr
condition|)
block|{
name|free
argument_list|(
name|o
operator|->
name|file
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|o
operator|->
name|file
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Each group of lines is described by a blame_entry; it can be split  * as we pass blame to the parents.  They form a linked list in the  * scoreboard structure, sorted by the target line number.  */
end_comment
begin_struct
DECL|struct|blame_entry
struct|struct
name|blame_entry
block|{
DECL|member|prev
name|struct
name|blame_entry
modifier|*
name|prev
decl_stmt|;
DECL|member|next
name|struct
name|blame_entry
modifier|*
name|next
decl_stmt|;
comment|/* the first line of this group in the final image; 	 * internally all line numbers are 0 based. 	 */
DECL|member|lno
name|int
name|lno
decl_stmt|;
comment|/* how many lines this group has */
DECL|member|num_lines
name|int
name|num_lines
decl_stmt|;
comment|/* the commit that introduced this group into the final image */
DECL|member|suspect
name|struct
name|origin
modifier|*
name|suspect
decl_stmt|;
comment|/* true if the suspect is truly guilty; false while we have not 	 * checked if the group came from one of its parents. 	 */
DECL|member|guilty
name|char
name|guilty
decl_stmt|;
comment|/* true if the entry has been scanned for copies in the current parent 	 */
DECL|member|scanned
name|char
name|scanned
decl_stmt|;
comment|/* the line number of the first line of this group in the 	 * suspect's file; internally all line numbers are 0 based. 	 */
DECL|member|s_lno
name|int
name|s_lno
decl_stmt|;
comment|/* how significant this entry is -- cached to avoid 	 * scanning the lines over and over. 	 */
DECL|member|score
name|unsigned
name|score
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * The current state of the blame assignment.  */
end_comment
begin_struct
DECL|struct|scoreboard
struct|struct
name|scoreboard
block|{
comment|/* the final commit (i.e. where we started digging from) */
DECL|member|final
name|struct
name|commit
modifier|*
name|final
decl_stmt|;
DECL|member|revs
name|struct
name|rev_info
modifier|*
name|revs
decl_stmt|;
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* 	 * The contents in the final image. 	 * Used by many functions to obtain contents of the nth line, 	 * indexed with scoreboard.lineno[blame_entry.lno]. 	 */
DECL|member|final_buf
specifier|const
name|char
modifier|*
name|final_buf
decl_stmt|;
DECL|member|final_buf_size
name|unsigned
name|long
name|final_buf_size
decl_stmt|;
comment|/* linked list of blames */
DECL|member|ent
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
comment|/* look-up a line in the final buffer */
DECL|member|num_lines
name|int
name|num_lines
decl_stmt|;
DECL|member|lineno
name|int
modifier|*
name|lineno
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|same_suspect
specifier|static
specifier|inline
name|int
name|same_suspect
parameter_list|(
name|struct
name|origin
modifier|*
name|a
parameter_list|,
name|struct
name|origin
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|commit
operator|!=
name|b
operator|->
name|commit
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|path
argument_list|,
name|b
operator|->
name|path
argument_list|)
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|sanity_check_refcnt
parameter_list|(
name|struct
name|scoreboard
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * If two blame entries that are next to each other came from  * contiguous lines in the same origin (i.e.<commit, path> pair),  * merge them together.  */
end_comment
begin_function
DECL|function|coalesce
specifier|static
name|void
name|coalesce
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
operator|&&
operator|(
name|next
operator|=
name|ent
operator|->
name|next
operator|)
condition|;
name|ent
operator|=
name|next
control|)
block|{
if|if
condition|(
name|same_suspect
argument_list|(
name|ent
operator|->
name|suspect
argument_list|,
name|next
operator|->
name|suspect
argument_list|)
operator|&&
name|ent
operator|->
name|guilty
operator|==
name|next
operator|->
name|guilty
operator|&&
name|ent
operator|->
name|s_lno
operator|+
name|ent
operator|->
name|num_lines
operator|==
name|next
operator|->
name|s_lno
condition|)
block|{
name|ent
operator|->
name|num_lines
operator|+=
name|next
operator|->
name|num_lines
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|next
condition|)
name|ent
operator|->
name|next
operator|->
name|prev
operator|=
name|ent
expr_stmt|;
name|origin_decref
argument_list|(
name|next
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|ent
operator|->
name|score
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|ent
expr_stmt|;
comment|/* again */
block|}
block|}
if|if
condition|(
name|DEBUG
condition|)
comment|/* sanity */
name|sanity_check_refcnt
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Given a commit and a path in it, create a new origin structure.  * The callers that add blame to the scoreboard should use  * get_origin() to obtain shared, refcounted copy instead of calling  * this function directly.  */
end_comment
begin_function
DECL|function|make_origin
specifier|static
name|struct
name|origin
modifier|*
name|make_origin
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|origin
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|o
operator|->
name|commit
operator|=
name|commit
expr_stmt|;
name|o
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|o
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function
begin_comment
comment|/*  * Locate an existing origin or create a new one.  */
end_comment
begin_function
DECL|function|get_origin
specifier|static
name|struct
name|origin
modifier|*
name|get_origin
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|suspect
operator|->
name|commit
operator|==
name|commit
operator|&&
operator|!
name|strcmp
argument_list|(
name|e
operator|->
name|suspect
operator|->
name|path
argument_list|,
name|path
argument_list|)
condition|)
return|return
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
return|;
block|}
return|return
name|make_origin
argument_list|(
name|commit
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Fill the blob_sha1 field of an origin if it hasn't, so that later  * call to fill_origin_blob() can use it to locate the data.  blob_sha1  * for an origin is also used to pass the blame for the entire file to  * the parent to detect the case where a child's blob is identical to  * that of its parent's.  *  * This also fills origin->mode for corresponding tree path.  */
end_comment
begin_function
DECL|function|fill_blob_sha1_and_mode
specifier|static
name|int
name|fill_blob_sha1_and_mode
parameter_list|(
name|struct
name|origin
modifier|*
name|origin
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_null_sha1
argument_list|(
name|origin
operator|->
name|blob_sha1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_tree_entry
argument_list|(
name|origin
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|origin
operator|->
name|path
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|,
operator|&
name|origin
operator|->
name|mode
argument_list|)
condition|)
goto|goto
name|error_out
goto|;
if|if
condition|(
name|sha1_object_info
argument_list|(
name|origin
operator|->
name|blob_sha1
argument_list|,
name|NULL
argument_list|)
operator|!=
name|OBJ_BLOB
condition|)
goto|goto
name|error_out
goto|;
return|return
literal|0
return|;
name|error_out
label|:
name|hashclr
argument_list|(
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|origin
operator|->
name|mode
operator|=
name|S_IFINVALID
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * We have an origin -- check if the same path exists in the  * parent and return an origin structure to represent it.  */
end_comment
begin_function
DECL|function|find_origin
specifier|static
name|struct
name|origin
modifier|*
name|find_origin
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|NULL
decl_stmt|;
name|struct
name|diff_options
name|diff_opts
decl_stmt|;
specifier|const
name|char
modifier|*
name|paths
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|util
condition|)
block|{
comment|/* 		 * Each commit object can cache one origin in that 		 * commit.  This is a freestanding copy of origin and 		 * not refcounted. 		 */
name|struct
name|origin
modifier|*
name|cached
init|=
name|parent
operator|->
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cached
operator|->
name|path
argument_list|,
name|origin
operator|->
name|path
argument_list|)
condition|)
block|{
comment|/* 			 * The same path between origin and its parent 			 * without renaming -- the most common case. 			 */
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|cached
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 			 * If the origin was newly created (i.e. get_origin 			 * would call make_origin if none is found in the 			 * scoreboard), it does not know the blob_sha1/mode, 			 * so copy it.  Otherwise porigin was in the 			 * scoreboard and already knows blob_sha1/mode. 			 */
if|if
condition|(
name|porigin
operator|->
name|refcnt
operator|==
literal|1
condition|)
block|{
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|cached
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|porigin
operator|->
name|mode
operator|=
name|cached
operator|->
name|mode
expr_stmt|;
block|}
return|return
name|porigin
return|;
block|}
comment|/* otherwise it was not very useful; free it */
name|free
argument_list|(
name|parent
operator|->
name|util
argument_list|)
expr_stmt|;
name|parent
operator|->
name|util
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* See if the origin->path is different between parent 	 * and origin first.  Most of the time they are the 	 * same and diff-tree is fairly efficient about this. 	 */
name|diff_setup
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|diff_opts
operator|.
name|detect_rename
operator|=
literal|0
expr_stmt|;
name|diff_opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|paths
index|[
literal|0
index|]
operator|=
name|origin
operator|->
name|path
expr_stmt|;
name|paths
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|parse_pathspec
argument_list|(
operator|&
name|diff_opts
operator|.
name|pathspec
argument_list|,
name|PATHSPEC_ALL_MAGIC
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
name|paths
argument_list|)
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|origin
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
name|do_diff_cache
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
else|else
name|diff_tree_sha1
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|origin
operator|->
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diff_queued_diff
operator|.
name|nr
condition|)
block|{
comment|/* The path is the same as parent */
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|origin
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|porigin
operator|->
name|mode
operator|=
name|origin
operator|->
name|mode
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Since origin->path is a pathspec, if the parent 		 * commit had it as a directory, we will see a whole 		 * bunch of deletion of files in the directory that we 		 * do not care about. 		 */
name|int
name|i
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|p
operator|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
expr_stmt|;
name|name
operator|=
name|p
operator|->
name|one
operator|->
name|path
condition|?
name|p
operator|->
name|one
operator|->
name|path
else|:
name|p
operator|->
name|two
operator|->
name|path
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|origin
operator|->
name|path
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|p
condition|)
name|die
argument_list|(
literal|"internal error in blame::find_origin"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|status
condition|)
block|{
default|default:
name|die
argument_list|(
literal|"internal error in blame::find_origin (%c)"
argument_list|,
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
case|case
literal|'M'
case|:
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|origin
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|porigin
operator|->
name|mode
operator|=
name|p
operator|->
name|one
operator|->
name|mode
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'T'
case|:
comment|/* Did not exist in parent, or type changed */
break|break;
block|}
block|}
name|diff_flush
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|free_pathspec
argument_list|(
operator|&
name|diff_opts
operator|.
name|pathspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|porigin
condition|)
block|{
comment|/* 		 * Create a freestanding copy that is not part of 		 * the refcounted origin found in the scoreboard, and 		 * cache it in the commit. 		 */
name|struct
name|origin
modifier|*
name|cached
decl_stmt|;
name|cached
operator|=
name|make_origin
argument_list|(
name|porigin
operator|->
name|commit
argument_list|,
name|porigin
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|cached
operator|->
name|blob_sha1
argument_list|,
name|porigin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|cached
operator|->
name|mode
operator|=
name|porigin
operator|->
name|mode
expr_stmt|;
name|parent
operator|->
name|util
operator|=
name|cached
expr_stmt|;
block|}
return|return
name|porigin
return|;
block|}
end_function
begin_comment
comment|/*  * We have an origin -- find the path that corresponds to it in its  * parent and return an origin structure to represent it.  */
end_comment
begin_function
DECL|function|find_rename
specifier|static
name|struct
name|origin
modifier|*
name|find_rename
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|NULL
decl_stmt|;
name|struct
name|diff_options
name|diff_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|diff_setup
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|diff_opts
operator|.
name|detect_rename
operator|=
name|DIFF_DETECT_RENAME
expr_stmt|;
name|diff_opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_opts
operator|.
name|single_follow
operator|=
name|origin
operator|->
name|path
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|origin
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
name|do_diff_cache
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
else|else
name|diff_tree_sha1
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|origin
operator|->
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|status
operator|==
literal|'R'
operator|||
name|p
operator|->
name|status
operator|==
literal|'C'
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|two
operator|->
name|path
argument_list|,
name|origin
operator|->
name|path
argument_list|)
condition|)
block|{
name|porigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|porigin
operator|->
name|mode
operator|=
name|p
operator|->
name|one
operator|->
name|mode
expr_stmt|;
break|break;
block|}
block|}
name|diff_flush
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|free_pathspec
argument_list|(
operator|&
name|diff_opts
operator|.
name|pathspec
argument_list|)
expr_stmt|;
return|return
name|porigin
return|;
block|}
end_function
begin_comment
comment|/*  * Link in a new blame entry to the scoreboard.  Entries that cover the  * same line range have been removed from the scoreboard previously.  */
end_comment
begin_function
DECL|function|add_blame_entry
specifier|static
name|void
name|add_blame_entry
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
operator|&&
name|ent
operator|->
name|lno
operator|<
name|e
operator|->
name|lno
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
name|prev
operator|=
name|ent
expr_stmt|;
comment|/* prev, if not NULL, is the last one that is below e */
name|e
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|e
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|next
operator|=
name|sb
operator|->
name|ent
expr_stmt|;
name|sb
operator|->
name|ent
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|next
condition|)
name|e
operator|->
name|next
operator|->
name|prev
operator|=
name|e
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * src typically is on-stack; we want to copy the information in it to  * a malloced blame_entry that is already on the linked list of the  * scoreboard.  The origin of dst loses a refcnt while the origin of src  * gains one.  */
end_comment
begin_function
DECL|function|dup_entry
specifier|static
name|void
name|dup_entry
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|dst
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|p
operator|=
name|dst
operator|->
name|prev
expr_stmt|;
name|n
operator|=
name|dst
operator|->
name|next
expr_stmt|;
name|origin_incref
argument_list|(
name|src
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|dst
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|prev
operator|=
name|p
expr_stmt|;
name|dst
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|dst
operator|->
name|score
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|nth_line
specifier|static
specifier|const
name|char
modifier|*
name|nth_line
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|long
name|lno
parameter_list|)
block|{
return|return
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|lineno
index|[
name|lno
index|]
return|;
block|}
end_function
begin_function
DECL|function|nth_line_cb
specifier|static
specifier|const
name|char
modifier|*
name|nth_line_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|long
name|lno
parameter_list|)
block|{
return|return
name|nth_line
argument_list|(
operator|(
expr|struct
name|scoreboard
operator|*
operator|)
name|data
argument_list|,
name|lno
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * It is known that lines between tlno to same came from parent, and e  * has an overlap with that range.  it also is known that parent's  * line plno corresponds to e's line tlno.  *  *<---- e ----->  *<------>  *<------------>  *<------------>  *<------------------>  *  * Split e into potentially three parts; before this chunk, the chunk  * to be blamed for the parent, and after that portion.  */
end_comment
begin_function
DECL|function|split_overlap
specifier|static
name|void
name|split_overlap
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|chunk_end_lno
decl_stmt|;
name|memset
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|s_lno
operator|<
name|tlno
condition|)
block|{
comment|/* there is a pre-chunk part not blamed on parent */
name|split
index|[
literal|0
index|]
operator|.
name|suspect
operator|=
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|.
name|s_lno
operator|=
name|e
operator|->
name|s_lno
expr_stmt|;
name|split
index|[
literal|0
index|]
operator|.
name|num_lines
operator|=
name|tlno
operator|-
name|e
operator|->
name|s_lno
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
operator|+
name|tlno
operator|-
name|e
operator|->
name|s_lno
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|s_lno
operator|=
name|plno
expr_stmt|;
block|}
else|else
block|{
name|split
index|[
literal|1
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|s_lno
operator|=
name|plno
operator|+
operator|(
name|e
operator|->
name|s_lno
operator|-
name|tlno
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|same
operator|<
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
condition|)
block|{
comment|/* there is a post-chunk part not blamed on parent */
name|split
index|[
literal|2
index|]
operator|.
name|suspect
operator|=
name|origin_incref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|split
index|[
literal|2
index|]
operator|.
name|lno
operator|=
name|e
operator|->
name|lno
operator|+
operator|(
name|same
operator|-
name|e
operator|->
name|s_lno
operator|)
expr_stmt|;
name|split
index|[
literal|2
index|]
operator|.
name|s_lno
operator|=
name|e
operator|->
name|s_lno
operator|+
operator|(
name|same
operator|-
name|e
operator|->
name|s_lno
operator|)
expr_stmt|;
name|split
index|[
literal|2
index|]
operator|.
name|num_lines
operator|=
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
operator|-
name|same
expr_stmt|;
name|chunk_end_lno
operator|=
name|split
index|[
literal|2
index|]
operator|.
name|lno
expr_stmt|;
block|}
else|else
name|chunk_end_lno
operator|=
name|e
operator|->
name|lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
name|split
index|[
literal|1
index|]
operator|.
name|num_lines
operator|=
name|chunk_end_lno
operator|-
name|split
index|[
literal|1
index|]
operator|.
name|lno
expr_stmt|;
comment|/* 	 * if it turns out there is nothing to blame the parent for, 	 * forget about the splitting.  !split[1].suspect signals this. 	 */
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|num_lines
operator|<
literal|1
condition|)
return|return;
name|split
index|[
literal|1
index|]
operator|.
name|suspect
operator|=
name|origin_incref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * split_overlap() divided an existing blame e into up to three parts  * in split.  Adjust the linked list of blames in the scoreboard to  * reflect the split.  */
end_comment
begin_function
DECL|function|split_blame
specifier|static
name|void
name|split_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|new_entry
decl_stmt|;
if|if
condition|(
name|split
index|[
literal|0
index|]
operator|.
name|suspect
operator|&&
name|split
index|[
literal|2
index|]
operator|.
name|suspect
condition|)
block|{
comment|/* The first part (reuse storage for the existing entry e) */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* The last part -- me */
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|2
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
comment|/* ... and the middle part -- parent */
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|1
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|split
index|[
literal|0
index|]
operator|.
name|suspect
operator|&&
operator|!
name|split
index|[
literal|2
index|]
operator|.
name|suspect
condition|)
comment|/* 		 * The parent covers the entire area; reuse storage for 		 * e and replace it with the parent. 		 */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|split
index|[
literal|0
index|]
operator|.
name|suspect
condition|)
block|{
comment|/* me and then parent */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|1
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parent and then me */
name|dup_entry
argument_list|(
name|e
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new_entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
operator|&
operator|(
name|split
index|[
literal|2
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
argument_list|)
argument_list|)
expr_stmt|;
name|add_blame_entry
argument_list|(
name|sb
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
condition|)
block|{
comment|/* sanity */
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
name|int
name|lno
init|=
name|sb
operator|->
name|ent
operator|->
name|lno
decl_stmt|,
name|corrupt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lno
operator|!=
name|ent
operator|->
name|lno
condition|)
name|corrupt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|s_lno
operator|<
literal|0
condition|)
name|corrupt
operator|=
literal|1
expr_stmt|;
name|lno
operator|+=
name|ent
operator|->
name|num_lines
expr_stmt|;
block|}
if|if
condition|(
name|corrupt
condition|)
block|{
name|lno
operator|=
name|sb
operator|->
name|ent
operator|->
name|lno
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"L %8d l %8d n %8d\n"
argument_list|,
name|lno
argument_list|,
name|ent
operator|->
name|lno
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|)
expr_stmt|;
name|lno
operator|=
name|ent
operator|->
name|lno
operator|+
name|ent
operator|->
name|num_lines
expr_stmt|;
block|}
name|die
argument_list|(
literal|"oops"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * After splitting the blame, the origins used by the  * on-stack blame_entry should lose one refcnt each.  */
end_comment
begin_function
DECL|function|decref_split
specifier|static
name|void
name|decref_split
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|origin_decref
argument_list|(
name|split
index|[
name|i
index|]
operator|.
name|suspect
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Helper for blame_chunk().  blame_entry e is known to overlap with  * the patch hunk; split it and pass blame to the parent.  */
end_comment
begin_function
DECL|function|blame_overlap
specifier|static
name|void
name|blame_overlap
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|blame_entry
name|split
index|[
literal|3
index|]
decl_stmt|;
name|split_overlap
argument_list|(
name|split
argument_list|,
name|e
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|same
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|suspect
condition|)
name|split_blame
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Find the line number of the last line the target is suspected for.  */
end_comment
begin_function
DECL|function|find_last_in_target
specifier|static
name|int
name|find_last_in_target
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
name|int
name|last_in_target
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|guilty
operator|||
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|last_in_target
operator|<
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
condition|)
name|last_in_target
operator|=
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
block|}
return|return
name|last_in_target
return|;
block|}
end_function
begin_comment
comment|/*  * Process one hunk from the patch between the current suspect for  * blame_entry e and its parent.  Find and split the overlap, and  * pass blame to the overlapping part to the parent.  */
end_comment
begin_function
DECL|function|blame_chunk
specifier|static
name|void
name|blame_chunk
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|guilty
operator|||
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|same
operator|<=
name|e
operator|->
name|s_lno
condition|)
continue|continue;
if|if
condition|(
name|tlno
operator|<
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
condition|)
name|blame_overlap
argument_list|(
name|sb
argument_list|,
name|e
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|same
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_struct
DECL|struct|blame_chunk_cb_data
struct|struct
name|blame_chunk_cb_data
block|{
DECL|member|sb
name|struct
name|scoreboard
modifier|*
name|sb
decl_stmt|;
DECL|member|target
name|struct
name|origin
modifier|*
name|target
decl_stmt|;
DECL|member|parent
name|struct
name|origin
modifier|*
name|parent
decl_stmt|;
DECL|member|plno
name|long
name|plno
decl_stmt|;
DECL|member|tlno
name|long
name|tlno
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|blame_chunk_cb
specifier|static
name|int
name|blame_chunk_cb
parameter_list|(
name|long
name|start_a
parameter_list|,
name|long
name|count_a
parameter_list|,
name|long
name|start_b
parameter_list|,
name|long
name|count_b
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|blame_chunk_cb_data
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|blame_chunk
argument_list|(
name|d
operator|->
name|sb
argument_list|,
name|d
operator|->
name|tlno
argument_list|,
name|d
operator|->
name|plno
argument_list|,
name|start_b
argument_list|,
name|d
operator|->
name|target
argument_list|,
name|d
operator|->
name|parent
argument_list|)
expr_stmt|;
name|d
operator|->
name|plno
operator|=
name|start_a
operator|+
name|count_a
expr_stmt|;
name|d
operator|->
name|tlno
operator|=
name|start_b
operator|+
name|count_b
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * We are looking at the origin 'target' and aiming to pass blame  * for the lines it is suspected to its parent.  Run diff to find  * which lines came from parent and pass blame for them.  */
end_comment
begin_function
DECL|function|pass_blame_to_parent
specifier|static
name|int
name|pass_blame_to_parent
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|last_in_target
decl_stmt|;
name|mmfile_t
name|file_p
decl_stmt|,
name|file_o
decl_stmt|;
name|struct
name|blame_chunk_cb_data
name|d
decl_stmt|;
name|memset
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|sb
operator|=
name|sb
expr_stmt|;
name|d
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|d
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|last_in_target
operator|=
name|find_last_in_target
argument_list|(
name|sb
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_in_target
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* nothing remains for this target */
name|fill_origin_blob
argument_list|(
operator|&
name|sb
operator|->
name|revs
operator|->
name|diffopt
argument_list|,
name|parent
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
name|fill_origin_blob
argument_list|(
operator|&
name|sb
operator|->
name|revs
operator|->
name|diffopt
argument_list|,
name|target
argument_list|,
operator|&
name|file_o
argument_list|)
expr_stmt|;
name|num_get_patch
operator|++
expr_stmt|;
name|diff_hunks
argument_list|(
operator|&
name|file_p
argument_list|,
operator|&
name|file_o
argument_list|,
literal|0
argument_list|,
name|blame_chunk_cb
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
comment|/* The rest (i.e. anything after tlno) are the same as the parent */
name|blame_chunk
argument_list|(
name|sb
argument_list|,
name|d
operator|.
name|tlno
argument_list|,
name|d
operator|.
name|plno
argument_list|,
name|last_in_target
argument_list|,
name|target
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * The lines in blame_entry after splitting blames many times can become  * very small and trivial, and at some point it becomes pointless to  * blame the parents.  E.g. "\t\t}\n\t}\n\n" appears everywhere in any  * ordinary C program, and it is not worth to say it was copied from  * totally unrelated file in the parent.  *  * Compute how trivial the lines in the blame_entry are.  */
end_comment
begin_function
DECL|function|ent_score
specifier|static
name|unsigned
name|ent_score
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|e
parameter_list|)
block|{
name|unsigned
name|score
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|score
condition|)
return|return
name|e
operator|->
name|score
return|;
name|score
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|e
operator|->
name|lno
argument_list|)
expr_stmt|;
name|ep
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|e
operator|->
name|lno
operator|+
name|e
operator|->
name|num_lines
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
name|unsigned
name|ch
init|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp
operator|)
decl_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
condition|)
name|score
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|e
operator|->
name|score
operator|=
name|score
expr_stmt|;
return|return
name|score
return|;
block|}
end_function
begin_comment
comment|/*  * best_so_far[] and this[] are both a split of an existing blame_entry  * that passes blame to the parent.  Maintain best_so_far the best split  * so far, by comparing this and best_so_far and copying this into  * bst_so_far as needed.  */
end_comment
begin_function
DECL|function|copy_split_if_better
specifier|static
name|void
name|copy_split_if_better
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|best_so_far
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|this
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|this
index|[
literal|1
index|]
operator|.
name|suspect
condition|)
return|return;
if|if
condition|(
name|best_so_far
index|[
literal|1
index|]
operator|.
name|suspect
condition|)
block|{
if|if
condition|(
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|this
index|[
literal|1
index|]
argument_list|)
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|best_so_far
index|[
literal|1
index|]
argument_list|)
condition|)
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|origin_incref
argument_list|(
name|this
index|[
name|i
index|]
operator|.
name|suspect
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|best_so_far
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|best_so_far
argument_list|,
name|this
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * We are looking at a part of the final image represented by  * ent (tlno and same are offset by ent->s_lno).  * tlno is where we are looking at in the final image.  * up to (but not including) same match preimage.  * plno is where we are looking at in the preimage.  *  *<-------------- final image ---------------------->  *<------ent------>  *         ^tlno ^same  *<---------preimage----->  *         ^plno  *  * All line numbers are 0-based.  */
end_comment
begin_function
DECL|function|handle_split
specifier|static
name|void
name|handle_split
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|,
name|int
name|tlno
parameter_list|,
name|int
name|plno
parameter_list|,
name|int
name|same
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|num_lines
operator|<=
name|tlno
condition|)
return|return;
if|if
condition|(
name|tlno
operator|<
name|same
condition|)
block|{
name|struct
name|blame_entry
name|this
index|[
literal|3
index|]
decl_stmt|;
name|tlno
operator|+=
name|ent
operator|->
name|s_lno
expr_stmt|;
name|same
operator|+=
name|ent
operator|->
name|s_lno
expr_stmt|;
name|split_overlap
argument_list|(
name|this
argument_list|,
name|ent
argument_list|,
name|tlno
argument_list|,
name|plno
argument_list|,
name|same
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|copy_split_if_better
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_struct
DECL|struct|handle_split_cb_data
struct|struct
name|handle_split_cb_data
block|{
DECL|member|sb
name|struct
name|scoreboard
modifier|*
name|sb
decl_stmt|;
DECL|member|ent
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
DECL|member|parent
name|struct
name|origin
modifier|*
name|parent
decl_stmt|;
DECL|member|split
name|struct
name|blame_entry
modifier|*
name|split
decl_stmt|;
DECL|member|plno
name|long
name|plno
decl_stmt|;
DECL|member|tlno
name|long
name|tlno
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|handle_split_cb
specifier|static
name|int
name|handle_split_cb
parameter_list|(
name|long
name|start_a
parameter_list|,
name|long
name|count_a
parameter_list|,
name|long
name|start_b
parameter_list|,
name|long
name|count_b
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|handle_split_cb_data
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|handle_split
argument_list|(
name|d
operator|->
name|sb
argument_list|,
name|d
operator|->
name|ent
argument_list|,
name|d
operator|->
name|tlno
argument_list|,
name|d
operator|->
name|plno
argument_list|,
name|start_b
argument_list|,
name|d
operator|->
name|parent
argument_list|,
name|d
operator|->
name|split
argument_list|)
expr_stmt|;
name|d
operator|->
name|plno
operator|=
name|start_a
operator|+
name|count_a
expr_stmt|;
name|d
operator|->
name|tlno
operator|=
name|start_b
operator|+
name|count_b
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Find the lines from parent that are the same as ent so that  * we can pass blames to it.  file_p has the blob contents for  * the parent.  */
end_comment
begin_function
DECL|function|find_copy_in_blob
specifier|static
name|void
name|find_copy_in_blob
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|split
parameter_list|,
name|mmfile_t
modifier|*
name|file_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|mmfile_t
name|file_o
decl_stmt|;
name|struct
name|handle_split_cb_data
name|d
decl_stmt|;
name|memset
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|sb
operator|=
name|sb
expr_stmt|;
name|d
operator|.
name|ent
operator|=
name|ent
expr_stmt|;
name|d
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|d
operator|.
name|split
operator|=
name|split
expr_stmt|;
comment|/* 	 * Prepare mmfile that contains only the lines in ent. 	 */
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|ent
operator|->
name|lno
argument_list|)
expr_stmt|;
name|file_o
operator|.
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|cnt
operator|=
name|ent
operator|->
name|num_lines
expr_stmt|;
while|while
condition|(
name|cnt
operator|&&
name|cp
operator|<
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|final_buf_size
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\n'
condition|)
name|cnt
operator|--
expr_stmt|;
block|}
name|file_o
operator|.
name|size
operator|=
name|cp
operator|-
name|file_o
operator|.
name|ptr
expr_stmt|;
comment|/* 	 * file_o is a part of final image we are annotating. 	 * file_p partially may match that image. 	 */
name|memset
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_entry
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|diff_hunks
argument_list|(
name|file_p
argument_list|,
operator|&
name|file_o
argument_list|,
literal|1
argument_list|,
name|handle_split_cb
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
comment|/* remainder, if any, all match the preimage */
name|handle_split
argument_list|(
name|sb
argument_list|,
name|ent
argument_list|,
name|d
operator|.
name|tlno
argument_list|,
name|d
operator|.
name|plno
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|,
name|parent
argument_list|,
name|split
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * See if lines currently target is suspected for can be attributed to  * parent.  */
end_comment
begin_function
DECL|function|find_move_in_parent
specifier|static
name|int
name|find_move_in_parent
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|origin
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|last_in_target
decl_stmt|,
name|made_progress
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|,
name|split
index|[
literal|3
index|]
decl_stmt|;
name|mmfile_t
name|file_p
decl_stmt|;
name|last_in_target
operator|=
name|find_last_in_target
argument_list|(
name|sb
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_in_target
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* nothing remains for this target */
name|fill_origin_blob
argument_list|(
operator|&
name|sb
operator|->
name|revs
operator|->
name|diffopt
argument_list|,
name|parent
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_p
operator|.
name|ptr
condition|)
return|return
literal|0
return|;
name|made_progress
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|made_progress
condition|)
block|{
name|made_progress
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|guilty
operator|||
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
operator|||
name|ent_score
argument_list|(
name|sb
argument_list|,
name|e
argument_list|)
operator|<
name|blame_move_score
condition|)
continue|continue;
name|find_copy_in_blob
argument_list|(
name|sb
argument_list|,
name|e
argument_list|,
name|parent
argument_list|,
name|split
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|suspect
operator|&&
name|blame_move_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|split_blame
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|made_progress
operator|=
literal|1
expr_stmt|;
block|}
name|decref_split
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|blame_list
struct|struct
name|blame_list
block|{
DECL|member|ent
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
DECL|member|split
name|struct
name|blame_entry
name|split
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Count the number of entries the target is suspected for,  * and prepare a list of entry and the best split.  */
end_comment
begin_function
DECL|function|setup_blame_list
specifier|static
name|struct
name|blame_list
modifier|*
name|setup_blame_list
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|int
name|min_score
parameter_list|,
name|int
modifier|*
name|num_ents_p
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
name|int
name|num_ents
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|blame_list
modifier|*
name|blame_list
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
operator|,
name|num_ents
operator|=
literal|0
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|scanned
operator|&&
operator|!
name|e
operator|->
name|guilty
operator|&&
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
operator|&&
name|min_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
name|e
argument_list|)
condition|)
name|num_ents
operator|++
expr_stmt|;
if|if
condition|(
name|num_ents
condition|)
block|{
name|blame_list
operator|=
name|xcalloc
argument_list|(
name|num_ents
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blame_list
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
operator|,
name|i
operator|=
literal|0
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|scanned
operator|&&
operator|!
name|e
operator|->
name|guilty
operator|&&
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|target
argument_list|)
operator|&&
name|min_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
name|e
argument_list|)
condition|)
name|blame_list
index|[
name|i
operator|++
index|]
operator|.
name|ent
operator|=
name|e
expr_stmt|;
block|}
operator|*
name|num_ents_p
operator|=
name|num_ents
expr_stmt|;
return|return
name|blame_list
return|;
block|}
end_function
begin_comment
comment|/*  * Reset the scanned status on all entries.  */
end_comment
begin_function
DECL|function|reset_scanned_flag
specifier|static
name|void
name|reset_scanned_flag
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
name|e
operator|->
name|scanned
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * For lines target is suspected for, see if we can find code movement  * across file boundary from the parent commit.  porigin is the path  * in the parent we already tried.  */
end_comment
begin_function
DECL|function|find_copy_in_parent
specifier|static
name|int
name|find_copy_in_parent
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|target
parameter_list|,
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|origin
modifier|*
name|porigin
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|struct
name|diff_options
name|diff_opts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|blame_list
modifier|*
name|blame_list
decl_stmt|;
name|int
name|num_ents
decl_stmt|;
name|blame_list
operator|=
name|setup_blame_list
argument_list|(
name|sb
argument_list|,
name|target
argument_list|,
name|blame_copy_score
argument_list|,
operator|&
name|num_ents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blame_list
condition|)
return|return
literal|1
return|;
comment|/* nothing remains for this target */
name|diff_setup
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|diff_opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
comment|/* Try "find copies harder" on new path if requested; 	 * we do not want to use diffcore_rename() actually to 	 * match things up; find_copies_harder is set only to 	 * force diff_tree_sha1() to feed all filepairs to diff_queue, 	 * and this code needs to be after diff_setup_done(), which 	 * usually makes find-copies-harder imply copy detection. 	 */
if|if
condition|(
operator|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY_HARDEST
operator|)
operator|||
operator|(
operator|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY_HARDER
operator|)
operator|&&
operator|(
operator|!
name|porigin
operator|||
name|strcmp
argument_list|(
name|target
operator|->
name|path
argument_list|,
name|porigin
operator|->
name|path
argument_list|)
operator|)
operator|)
condition|)
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|FIND_COPIES_HARDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|target
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
name|do_diff_cache
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
else|else
name|diff_tree_sha1
argument_list|(
name|parent
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|target
operator|->
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DIFF_OPT_TST
argument_list|(
operator|&
name|diff_opts
argument_list|,
name|FIND_COPIES_HARDER
argument_list|)
condition|)
name|diffcore_std
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|made_progress
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_queued_diff
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|diff_filepair
modifier|*
name|p
init|=
name|diff_queued_diff
operator|.
name|queue
index|[
name|i
index|]
decl_stmt|;
name|struct
name|origin
modifier|*
name|norigin
decl_stmt|;
name|mmfile_t
name|file_p
decl_stmt|;
name|struct
name|blame_entry
name|this
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|DIFF_FILE_VALID
argument_list|(
name|p
operator|->
name|one
argument_list|)
condition|)
continue|continue;
comment|/* does not exist in parent */
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|p
operator|->
name|one
operator|->
name|mode
argument_list|)
condition|)
continue|continue;
comment|/* ignore git links */
if|if
condition|(
name|porigin
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|one
operator|->
name|path
argument_list|,
name|porigin
operator|->
name|path
argument_list|)
condition|)
comment|/* find_move already dealt with this path */
continue|continue;
name|norigin
operator|=
name|get_origin
argument_list|(
name|sb
argument_list|,
name|parent
argument_list|,
name|p
operator|->
name|one
operator|->
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|norigin
operator|->
name|blob_sha1
argument_list|,
name|p
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|norigin
operator|->
name|mode
operator|=
name|p
operator|->
name|one
operator|->
name|mode
expr_stmt|;
name|fill_origin_blob
argument_list|(
operator|&
name|sb
operator|->
name|revs
operator|->
name|diffopt
argument_list|,
name|norigin
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_p
operator|.
name|ptr
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_ents
condition|;
name|j
operator|++
control|)
block|{
name|find_copy_in_blob
argument_list|(
name|sb
argument_list|,
name|blame_list
index|[
name|j
index|]
operator|.
name|ent
argument_list|,
name|norigin
argument_list|,
name|this
argument_list|,
operator|&
name|file_p
argument_list|)
expr_stmt|;
name|copy_split_if_better
argument_list|(
name|sb
argument_list|,
name|blame_list
index|[
name|j
index|]
operator|.
name|split
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|decref_split
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|origin_decref
argument_list|(
name|norigin
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_ents
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|blame_entry
modifier|*
name|split
init|=
name|blame_list
index|[
name|j
index|]
operator|.
name|split
decl_stmt|;
if|if
condition|(
name|split
index|[
literal|1
index|]
operator|.
name|suspect
operator|&&
name|blame_copy_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
operator|&
name|split
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|split_blame
argument_list|(
name|sb
argument_list|,
name|split
argument_list|,
name|blame_list
index|[
name|j
index|]
operator|.
name|ent
argument_list|)
expr_stmt|;
name|made_progress
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|blame_list
index|[
name|j
index|]
operator|.
name|ent
operator|->
name|scanned
operator|=
literal|1
expr_stmt|;
name|decref_split
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|blame_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|made_progress
condition|)
break|break;
name|blame_list
operator|=
name|setup_blame_list
argument_list|(
name|sb
argument_list|,
name|target
argument_list|,
name|blame_copy_score
argument_list|,
operator|&
name|num_ents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blame_list
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|reset_scanned_flag
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|diff_opts
argument_list|)
expr_stmt|;
name|free_pathspec
argument_list|(
operator|&
name|diff_opts
operator|.
name|pathspec
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*  * The blobs of origin and porigin exactly match, so everything  * origin is suspected for can be blamed on the parent.  */
end_comment
begin_function
DECL|function|pass_whole_blame
specifier|static
name|void
name|pass_whole_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|,
name|struct
name|origin
modifier|*
name|porigin
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|porigin
operator|->
name|file
operator|.
name|ptr
operator|&&
name|origin
operator|->
name|file
operator|.
name|ptr
condition|)
block|{
comment|/* Steal its file */
name|porigin
operator|->
name|file
operator|=
name|origin
operator|->
name|file
expr_stmt|;
name|origin
operator|->
name|file
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|same_suspect
argument_list|(
name|e
operator|->
name|suspect
argument_list|,
name|origin
argument_list|)
condition|)
continue|continue;
name|origin_incref
argument_list|(
name|porigin
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|e
operator|->
name|suspect
argument_list|)
expr_stmt|;
name|e
operator|->
name|suspect
operator|=
name|porigin
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * We pass blame from the current commit to its parents.  We keep saying  * "parent" (and "porigin"), but what we mean is to find scapegoat to  * exonerate ourselves.  */
end_comment
begin_function
DECL|function|first_scapegoat
specifier|static
name|struct
name|commit_list
modifier|*
name|first_scapegoat
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
if|if
condition|(
operator|!
name|reverse
condition|)
return|return
name|commit
operator|->
name|parents
return|;
return|return
name|lookup_decoration
argument_list|(
operator|&
name|revs
operator|->
name|children
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|num_scapegoats
specifier|static
name|int
name|num_scapegoats
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|l
init|=
name|first_scapegoat
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|cnt
operator|++
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function
begin_define
DECL|macro|MAXSG
define|#
directive|define
name|MAXSG
value|16
end_define
begin_function
DECL|function|pass_blame
specifier|static
name|void
name|pass_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|origin
modifier|*
name|origin
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|struct
name|rev_info
modifier|*
name|revs
init|=
name|sb
operator|->
name|revs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|,
name|num_sg
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|origin
operator|->
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|sg
decl_stmt|;
name|struct
name|origin
modifier|*
name|sg_buf
index|[
name|MAXSG
index|]
decl_stmt|;
name|struct
name|origin
modifier|*
name|porigin
decl_stmt|,
modifier|*
modifier|*
name|sg_origin
init|=
name|sg_buf
decl_stmt|;
name|num_sg
operator|=
name|num_scapegoats
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_sg
condition|)
goto|goto
name|finish
goto|;
elseif|else
if|if
condition|(
name|num_sg
operator|<
name|ARRAY_SIZE
argument_list|(
name|sg_buf
argument_list|)
condition|)
name|memset
argument_list|(
name|sg_buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sg_buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sg_origin
operator|=
name|xcalloc
argument_list|(
name|num_sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sg_origin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The first pass looks for unrenamed path to optimize for 	 * common cases, then we look for renames in the second pass. 	 */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
operator|-
name|no_whole_file_rename
condition|;
name|pass
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
argument_list|(
operator|*
name|find
argument_list|)
argument_list|(
expr|struct
name|scoreboard
operator|*
argument_list|,
expr|struct
name|commit
operator|*
argument_list|,
expr|struct
name|origin
operator|*
argument_list|)
decl_stmt|;
name|find
operator|=
name|pass
condition|?
name|find_rename
else|:
name|find_origin
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sg
operator|=
name|first_scapegoat
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
init|;
name|i
operator|<
name|num_sg
operator|&&
name|sg
condition|;
name|sg
operator|=
name|sg
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|sg
operator|->
name|item
decl_stmt|;
name|int
name|j
decl_stmt|,
name|same
decl_stmt|;
if|if
condition|(
name|sg_origin
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|parse_commit
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
name|porigin
operator|=
name|find
argument_list|(
name|sb
argument_list|,
name|p
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|porigin
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|porigin
operator|->
name|blob_sha1
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
condition|)
block|{
name|pass_whole_blame
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|porigin
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|porigin
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
for|for
control|(
name|j
operator|=
name|same
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|sg_origin
index|[
name|j
index|]
operator|&&
operator|!
name|hashcmp
argument_list|(
name|sg_origin
index|[
name|j
index|]
operator|->
name|blob_sha1
argument_list|,
name|porigin
operator|->
name|blob_sha1
argument_list|)
condition|)
block|{
name|same
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|same
condition|)
name|sg_origin
index|[
name|i
index|]
operator|=
name|porigin
expr_stmt|;
else|else
name|origin_decref
argument_list|(
name|porigin
argument_list|)
expr_stmt|;
block|}
block|}
name|num_commits
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sg
operator|=
name|first_scapegoat
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
init|;
name|i
operator|<
name|num_sg
operator|&&
name|sg
condition|;
name|sg
operator|=
name|sg
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|sg_origin
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|porigin
condition|)
continue|continue;
if|if
condition|(
operator|!
name|origin
operator|->
name|previous
condition|)
block|{
name|origin_incref
argument_list|(
name|porigin
argument_list|)
expr_stmt|;
name|origin
operator|->
name|previous
operator|=
name|porigin
expr_stmt|;
block|}
if|if
condition|(
name|pass_blame_to_parent
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|porigin
argument_list|)
condition|)
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * Optionally find moves in parents' files. 	 */
if|if
condition|(
name|opt
operator|&
name|PICKAXE_BLAME_MOVE
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sg
operator|=
name|first_scapegoat
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
init|;
name|i
operator|<
name|num_sg
operator|&&
name|sg
condition|;
name|sg
operator|=
name|sg
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|sg_origin
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|porigin
condition|)
continue|continue;
if|if
condition|(
name|find_move_in_parent
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|porigin
argument_list|)
condition|)
goto|goto
name|finish
goto|;
block|}
comment|/* 	 * Optionally find copies from parents' files. 	 */
if|if
condition|(
name|opt
operator|&
name|PICKAXE_BLAME_COPY
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sg
operator|=
name|first_scapegoat
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
init|;
name|i
operator|<
name|num_sg
operator|&&
name|sg
condition|;
name|sg
operator|=
name|sg
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|origin
modifier|*
name|porigin
init|=
name|sg_origin
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|find_copy_in_parent
argument_list|(
name|sb
argument_list|,
name|origin
argument_list|,
name|sg
operator|->
name|item
argument_list|,
name|porigin
argument_list|,
name|opt
argument_list|)
condition|)
goto|goto
name|finish
goto|;
block|}
name|finish
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sg_origin
index|[
name|i
index|]
condition|)
block|{
name|drop_origin_blob
argument_list|(
name|sg_origin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|sg_origin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|drop_origin_blob
argument_list|(
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_buf
operator|!=
name|sg_origin
condition|)
name|free
argument_list|(
name|sg_origin
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Information on commits, used for output.  */
end_comment
begin_struct
DECL|struct|commit_info
struct|struct
name|commit_info
block|{
DECL|member|author
name|struct
name|strbuf
name|author
decl_stmt|;
DECL|member|author_mail
name|struct
name|strbuf
name|author_mail
decl_stmt|;
DECL|member|author_time
name|unsigned
name|long
name|author_time
decl_stmt|;
DECL|member|author_tz
name|struct
name|strbuf
name|author_tz
decl_stmt|;
comment|/* filled only when asked for details */
DECL|member|committer
name|struct
name|strbuf
name|committer
decl_stmt|;
DECL|member|committer_mail
name|struct
name|strbuf
name|committer_mail
decl_stmt|;
DECL|member|committer_time
name|unsigned
name|long
name|committer_time
decl_stmt|;
DECL|member|committer_tz
name|struct
name|strbuf
name|committer_tz
decl_stmt|;
DECL|member|summary
name|struct
name|strbuf
name|summary
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Parse author/committer line in the commit object buffer  */
end_comment
begin_function
DECL|function|get_ac_line
specifier|static
name|void
name|get_ac_line
parameter_list|(
specifier|const
name|char
modifier|*
name|inbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|struct
name|strbuf
modifier|*
name|name
parameter_list|,
name|struct
name|strbuf
modifier|*
name|mail
parameter_list|,
name|unsigned
name|long
modifier|*
name|time
parameter_list|,
name|struct
name|strbuf
modifier|*
name|tz
parameter_list|)
block|{
name|struct
name|ident_split
name|ident
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|maillen
decl_stmt|,
name|namelen
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
specifier|const
name|char
modifier|*
name|namebuf
decl_stmt|,
modifier|*
name|mailbuf
decl_stmt|;
name|tmp
operator|=
name|strstr
argument_list|(
name|inbuf
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|error_out
goto|;
name|tmp
operator|+=
name|strlen
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|endp
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endp
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|endp
operator|-
name|tmp
expr_stmt|;
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|ident
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|error_out
label|:
comment|/* Ugh */
name|tmp
operator|=
literal|"(unknown)"
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|mail
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|tz
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|time
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|namelen
operator|=
name|ident
operator|.
name|name_end
operator|-
name|ident
operator|.
name|name_begin
expr_stmt|;
name|namebuf
operator|=
name|ident
operator|.
name|name_begin
expr_stmt|;
name|maillen
operator|=
name|ident
operator|.
name|mail_end
operator|-
name|ident
operator|.
name|mail_begin
expr_stmt|;
name|mailbuf
operator|=
name|ident
operator|.
name|mail_begin
expr_stmt|;
if|if
condition|(
name|ident
operator|.
name|date_begin
operator|&&
name|ident
operator|.
name|date_end
condition|)
operator|*
name|time
operator|=
name|strtoul
argument_list|(
name|ident
operator|.
name|date_begin
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
operator|*
name|time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ident
operator|.
name|tz_begin
operator|&&
name|ident
operator|.
name|tz_end
condition|)
name|strbuf_add
argument_list|(
name|tz
argument_list|,
name|ident
operator|.
name|tz_begin
argument_list|,
name|ident
operator|.
name|tz_end
operator|-
name|ident
operator|.
name|tz_begin
argument_list|)
expr_stmt|;
else|else
name|strbuf_addstr
argument_list|(
name|tz
argument_list|,
literal|"(unknown)"
argument_list|)
expr_stmt|;
comment|/* 	 * Now, convert both name and e-mail using mailmap 	 */
name|map_user
argument_list|(
operator|&
name|mailmap
argument_list|,
operator|&
name|mailbuf
argument_list|,
operator|&
name|maillen
argument_list|,
operator|&
name|namebuf
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|mail
argument_list|,
literal|"<%.*s>"
argument_list|,
operator|(
name|int
operator|)
name|maillen
argument_list|,
name|mailbuf
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|commit_info_init
specifier|static
name|void
name|commit_info_init
parameter_list|(
name|struct
name|commit_info
modifier|*
name|ci
parameter_list|)
block|{
name|strbuf_init
argument_list|(
operator|&
name|ci
operator|->
name|author
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|ci
operator|->
name|author_mail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|ci
operator|->
name|author_tz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|ci
operator|->
name|committer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|ci
operator|->
name|committer_mail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|ci
operator|->
name|committer_tz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|ci
operator|->
name|summary
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|commit_info_destroy
specifier|static
name|void
name|commit_info_destroy
parameter_list|(
name|struct
name|commit_info
modifier|*
name|ci
parameter_list|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|ci
operator|->
name|author
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|ci
operator|->
name|author_mail
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|ci
operator|->
name|author_tz
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|ci
operator|->
name|committer
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|ci
operator|->
name|committer_mail
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|ci
operator|->
name|committer_tz
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|ci
operator|->
name|summary
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_commit_info
specifier|static
name|void
name|get_commit_info
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_info
modifier|*
name|ret
parameter_list|,
name|int
name|detailed
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|subject
decl_stmt|,
modifier|*
name|encoding
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|commit_info_init
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|get_log_output_encoding
argument_list|()
expr_stmt|;
name|message
operator|=
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|get_ac_line
argument_list|(
name|message
argument_list|,
literal|"\nauthor "
argument_list|,
operator|&
name|ret
operator|->
name|author
argument_list|,
operator|&
name|ret
operator|->
name|author_mail
argument_list|,
operator|&
name|ret
operator|->
name|author_time
argument_list|,
operator|&
name|ret
operator|->
name|author_tz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|detailed
condition|)
block|{
name|logmsg_free
argument_list|(
name|message
argument_list|,
name|commit
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_ac_line
argument_list|(
name|message
argument_list|,
literal|"\ncommitter "
argument_list|,
operator|&
name|ret
operator|->
name|committer
argument_list|,
operator|&
name|ret
operator|->
name|committer_mail
argument_list|,
operator|&
name|ret
operator|->
name|committer_time
argument_list|,
operator|&
name|ret
operator|->
name|committer_tz
argument_list|)
expr_stmt|;
name|len
operator|=
name|find_commit_subject
argument_list|(
name|message
argument_list|,
operator|&
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|strbuf_add
argument_list|(
operator|&
name|ret
operator|->
name|summary
argument_list|,
name|subject
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
operator|&
name|ret
operator|->
name|summary
argument_list|,
literal|"(%s)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|logmsg_free
argument_list|(
name|message
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * To allow LF and other nonportable characters in pathnames,  * they are c-style quoted as needed.  */
end_comment
begin_function
DECL|function|write_filename_info
specifier|static
name|void
name|write_filename_info
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|printf
argument_list|(
literal|"filename "
argument_list|)
expr_stmt|;
name|write_name_quoted
argument_list|(
name|path
argument_list|,
name|stdout
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Porcelain/Incremental format wants to show a lot of details per  * commit.  Instead of repeating this every line, emit it only once,  * the first time each commit appears in the output (unless the  * user has specifically asked for us to repeat).  */
end_comment
begin_function
DECL|function|emit_one_suspect_detail
specifier|static
name|int
name|emit_one_suspect_detail
parameter_list|(
name|struct
name|origin
modifier|*
name|suspect
parameter_list|,
name|int
name|repeat
parameter_list|)
block|{
name|struct
name|commit_info
name|ci
decl_stmt|;
if|if
condition|(
operator|!
name|repeat
operator|&&
operator|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|METAINFO_SHOWN
operator|)
condition|)
return|return
literal|0
return|;
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|METAINFO_SHOWN
expr_stmt|;
name|get_commit_info
argument_list|(
name|suspect
operator|->
name|commit
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author %s\n"
argument_list|,
name|ci
operator|.
name|author
operator|.
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-mail %s\n"
argument_list|,
name|ci
operator|.
name|author_mail
operator|.
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-time %lu\n"
argument_list|,
name|ci
operator|.
name|author_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"author-tz %s\n"
argument_list|,
name|ci
operator|.
name|author_tz
operator|.
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer %s\n"
argument_list|,
name|ci
operator|.
name|committer
operator|.
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-mail %s\n"
argument_list|,
name|ci
operator|.
name|committer_mail
operator|.
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-time %lu\n"
argument_list|,
name|ci
operator|.
name|committer_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"committer-tz %s\n"
argument_list|,
name|ci
operator|.
name|committer_tz
operator|.
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"summary %s\n"
argument_list|,
name|ci
operator|.
name|summary
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
name|printf
argument_list|(
literal|"boundary\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|suspect
operator|->
name|previous
condition|)
block|{
name|struct
name|origin
modifier|*
name|prev
init|=
name|suspect
operator|->
name|previous
decl_stmt|;
name|printf
argument_list|(
literal|"previous %s "
argument_list|,
name|sha1_to_hex
argument_list|(
name|prev
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|write_name_quoted
argument_list|(
name|prev
operator|->
name|path
argument_list|,
name|stdout
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|commit_info_destroy
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * The blame_entry is found to be guilty for the range.  Mark it  * as such, and show it in incremental output.  */
end_comment
begin_function
DECL|function|found_guilty_entry
specifier|static
name|void
name|found_guilty_entry
parameter_list|(
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|guilty
condition|)
return|return;
name|ent
operator|->
name|guilty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
block|{
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|printf
argument_list|(
literal|"%s %d %d %d\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|ent
operator|->
name|s_lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|)
expr_stmt|;
name|emit_one_suspect_detail
argument_list|(
name|suspect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_filename_info
argument_list|(
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
name|maybe_flush_or_die
argument_list|(
name|stdout
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * The main loop -- while the scoreboard has lines whose true origin  * is still unknown, pick one blame_entry, and allow its current  * suspect to pass blames to its parents.  */
end_comment
begin_function
DECL|function|assign_blame
specifier|static
name|void
name|assign_blame
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|struct
name|rev_info
modifier|*
name|revs
init|=
name|sb
operator|->
name|revs
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|NULL
decl_stmt|;
comment|/* find one suspect to break down */
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
operator|!
name|suspect
operator|&&
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|guilty
condition|)
name|suspect
operator|=
name|ent
operator|->
name|suspect
expr_stmt|;
if|if
condition|(
operator|!
name|suspect
condition|)
return|return;
comment|/* all done */
comment|/* 		 * We will use this suspect later in the loop, 		 * so hold onto it in the meantime. 		 */
name|origin_incref
argument_list|(
name|suspect
argument_list|)
expr_stmt|;
name|commit
operator|=
name|suspect
operator|->
name|commit
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
operator|||
operator|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
operator|&&
operator|!
operator|(
name|revs
operator|->
name|max_age
operator|!=
operator|-
literal|1
operator|&&
name|commit
operator|->
name|date
operator|<
name|revs
operator|->
name|max_age
operator|)
operator|)
condition|)
name|pass_blame
argument_list|(
name|sb
argument_list|,
name|suspect
argument_list|,
name|opt
argument_list|)
expr_stmt|;
else|else
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|parsed
condition|)
name|mark_parents_uninteresting
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
comment|/* treat root commit as boundary */
if|if
condition|(
operator|!
name|commit
operator|->
name|parents
operator|&&
operator|!
name|show_root
condition|)
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
comment|/* Take responsibility for the remaining entries */
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|same_suspect
argument_list|(
name|ent
operator|->
name|suspect
argument_list|,
name|suspect
argument_list|)
condition|)
name|found_guilty_entry
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|origin_decref
argument_list|(
name|suspect
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
condition|)
comment|/* sanity */
name|sanity_check_refcnt
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|format_time
specifier|static
specifier|const
name|char
modifier|*
name|format_time
parameter_list|(
name|unsigned
name|long
name|time
parameter_list|,
specifier|const
name|char
modifier|*
name|tz_str
parameter_list|,
name|int
name|show_raw_time
parameter_list|)
block|{
specifier|static
name|char
name|time_buf
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|time_str
decl_stmt|;
name|int
name|time_len
decl_stmt|;
name|int
name|tz
decl_stmt|;
if|if
condition|(
name|show_raw_time
condition|)
block|{
name|snprintf
argument_list|(
name|time_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|time_buf
argument_list|)
argument_list|,
literal|"%lu %s"
argument_list|,
name|time
argument_list|,
name|tz_str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tz
operator|=
name|atoi
argument_list|(
name|tz_str
argument_list|)
expr_stmt|;
name|time_str
operator|=
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|blame_date_mode
argument_list|)
expr_stmt|;
name|time_len
operator|=
name|strlen
argument_list|(
name|time_str
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|time_buf
argument_list|,
name|time_str
argument_list|,
name|time_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|time_buf
operator|+
name|time_len
argument_list|,
literal|' '
argument_list|,
name|blame_date_width
operator|-
name|time_len
argument_list|)
expr_stmt|;
block|}
return|return
name|time_buf
return|;
block|}
end_function
begin_define
DECL|macro|OUTPUT_ANNOTATE_COMPAT
define|#
directive|define
name|OUTPUT_ANNOTATE_COMPAT
value|001
end_define
begin_define
DECL|macro|OUTPUT_LONG_OBJECT_NAME
define|#
directive|define
name|OUTPUT_LONG_OBJECT_NAME
value|002
end_define
begin_define
DECL|macro|OUTPUT_RAW_TIMESTAMP
define|#
directive|define
name|OUTPUT_RAW_TIMESTAMP
value|004
end_define
begin_define
DECL|macro|OUTPUT_PORCELAIN
define|#
directive|define
name|OUTPUT_PORCELAIN
value|010
end_define
begin_define
DECL|macro|OUTPUT_SHOW_NAME
define|#
directive|define
name|OUTPUT_SHOW_NAME
value|020
end_define
begin_define
DECL|macro|OUTPUT_SHOW_NUMBER
define|#
directive|define
name|OUTPUT_SHOW_NUMBER
value|040
end_define
begin_define
DECL|macro|OUTPUT_SHOW_SCORE
define|#
directive|define
name|OUTPUT_SHOW_SCORE
value|0100
end_define
begin_define
DECL|macro|OUTPUT_NO_AUTHOR
define|#
directive|define
name|OUTPUT_NO_AUTHOR
value|0200
end_define
begin_define
DECL|macro|OUTPUT_SHOW_EMAIL
define|#
directive|define
name|OUTPUT_SHOW_EMAIL
value|0400
end_define
begin_define
DECL|macro|OUTPUT_LINE_PORCELAIN
define|#
directive|define
name|OUTPUT_LINE_PORCELAIN
value|01000
end_define
begin_function
DECL|function|emit_porcelain_details
specifier|static
name|void
name|emit_porcelain_details
parameter_list|(
name|struct
name|origin
modifier|*
name|suspect
parameter_list|,
name|int
name|repeat
parameter_list|)
block|{
if|if
condition|(
name|emit_one_suspect_detail
argument_list|(
name|suspect
argument_list|,
name|repeat
argument_list|)
operator|||
operator|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|MORE_THAN_ONE_PATH
operator|)
condition|)
name|write_filename_info
argument_list|(
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emit_porcelain
specifier|static
name|void
name|emit_porcelain
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|int
name|repeat
init|=
name|opt
operator|&
name|OUTPUT_LINE_PORCELAIN
decl_stmt|;
name|int
name|cnt
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|char
name|hex
index|[
literal|41
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%c%d %d %d\n"
argument_list|,
name|hex
argument_list|,
name|ent
operator|->
name|guilty
condition|?
literal|' '
else|:
literal|'*'
argument_list|,
comment|/* purely for debugging */
name|ent
operator|->
name|s_lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
argument_list|,
name|ent
operator|->
name|num_lines
argument_list|)
expr_stmt|;
name|emit_porcelain_details
argument_list|(
name|suspect
argument_list|,
name|repeat
argument_list|)
expr_stmt|;
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|ent
operator|->
name|lno
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ent
operator|->
name|num_lines
condition|;
name|cnt
operator|++
control|)
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|cnt
condition|)
block|{
name|printf
argument_list|(
literal|"%s %d %d\n"
argument_list|,
name|hex
argument_list|,
name|ent
operator|->
name|s_lno
operator|+
literal|1
operator|+
name|cnt
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
name|emit_porcelain_details
argument_list|(
name|suspect
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
do|do
block|{
name|ch
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|cp
operator|<
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|final_buf_size
condition|)
do|;
block|}
if|if
condition|(
name|sb
operator|->
name|final_buf_size
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emit_other
specifier|static
name|void
name|emit_other
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|struct
name|blame_entry
modifier|*
name|ent
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|struct
name|commit_info
name|ci
decl_stmt|;
name|char
name|hex
index|[
literal|41
index|]
decl_stmt|;
name|int
name|show_raw_time
init|=
operator|!
operator|!
operator|(
name|opt
operator|&
name|OUTPUT_RAW_TIMESTAMP
operator|)
decl_stmt|;
name|get_commit_info
argument_list|(
name|suspect
operator|->
name|commit
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hex
argument_list|,
name|sha1_to_hex
argument_list|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|nth_line
argument_list|(
name|sb
argument_list|,
name|ent
operator|->
name|lno
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ent
operator|->
name|num_lines
condition|;
name|cnt
operator|++
control|)
block|{
name|char
name|ch
decl_stmt|;
name|int
name|length
init|=
operator|(
name|opt
operator|&
name|OUTPUT_LONG_OBJECT_NAME
operator|)
condition|?
literal|40
else|:
name|abbrev
decl_stmt|;
if|if
condition|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
block|{
if|if
condition|(
name|blank_boundary
condition|)
name|memset
argument_list|(
name|hex
argument_list|,
literal|' '
argument_list|,
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|opt
operator|&
name|OUTPUT_ANNOTATE_COMPAT
operator|)
condition|)
block|{
name|length
operator|--
expr_stmt|;
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%.*s"
argument_list|,
name|length
argument_list|,
name|hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_ANNOTATE_COMPAT
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_EMAIL
condition|)
name|name
operator|=
name|ci
operator|.
name|author_mail
operator|.
name|buf
expr_stmt|;
else|else
name|name
operator|=
name|ci
operator|.
name|author
operator|.
name|buf
expr_stmt|;
name|printf
argument_list|(
literal|"\t(%10s\t%10s\t%d)"
argument_list|,
name|name
argument_list|,
name|format_time
argument_list|(
name|ci
operator|.
name|author_time
argument_list|,
name|ci
operator|.
name|author_tz
operator|.
name|buf
argument_list|,
name|show_raw_time
argument_list|)
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_SCORE
condition|)
name|printf
argument_list|(
literal|" %*d %02d"
argument_list|,
name|max_score_digits
argument_list|,
name|ent
operator|->
name|score
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_NAME
condition|)
name|printf
argument_list|(
literal|" %-*.*s"
argument_list|,
name|longest_file
argument_list|,
name|longest_file
argument_list|,
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_NUMBER
condition|)
name|printf
argument_list|(
literal|" %*d"
argument_list|,
name|max_orig_digits
argument_list|,
name|ent
operator|->
name|s_lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opt
operator|&
name|OUTPUT_NO_AUTHOR
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|pad
decl_stmt|;
if|if
condition|(
name|opt
operator|&
name|OUTPUT_SHOW_EMAIL
condition|)
name|name
operator|=
name|ci
operator|.
name|author_mail
operator|.
name|buf
expr_stmt|;
else|else
name|name
operator|=
name|ci
operator|.
name|author
operator|.
name|buf
expr_stmt|;
name|pad
operator|=
name|longest_author
operator|-
name|utf8_strwidth
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%s%*s %10s"
argument_list|,
name|name
argument_list|,
name|pad
argument_list|,
literal|""
argument_list|,
name|format_time
argument_list|(
name|ci
operator|.
name|author_time
argument_list|,
name|ci
operator|.
name|author_tz
operator|.
name|buf
argument_list|,
name|show_raw_time
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %*d) "
argument_list|,
name|max_digits
argument_list|,
name|ent
operator|->
name|lno
operator|+
literal|1
operator|+
name|cnt
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|ch
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|cp
operator|<
name|sb
operator|->
name|final_buf
operator|+
name|sb
operator|->
name|final_buf_size
condition|)
do|;
block|}
if|if
condition|(
name|sb
operator|->
name|final_buf_size
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|commit_info_destroy
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output
specifier|static
name|void
name|output
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
name|option
parameter_list|)
block|{
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|option
operator|&
name|OUTPUT_PORCELAIN
condition|)
block|{
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
name|struct
name|blame_entry
modifier|*
name|oth
decl_stmt|;
name|struct
name|origin
modifier|*
name|suspect
init|=
name|ent
operator|->
name|suspect
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|suspect
operator|->
name|commit
decl_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|MORE_THAN_ONE_PATH
condition|)
continue|continue;
for|for
control|(
name|oth
operator|=
name|ent
operator|->
name|next
init|;
name|oth
condition|;
name|oth
operator|=
name|oth
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|oth
operator|->
name|suspect
operator|->
name|commit
operator|!=
name|commit
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|oth
operator|->
name|suspect
operator|->
name|path
argument_list|,
name|suspect
operator|->
name|path
argument_list|)
condition|)
continue|continue;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|MORE_THAN_ONE_PATH
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|option
operator|&
name|OUTPUT_PORCELAIN
condition|)
name|emit_porcelain
argument_list|(
name|sb
argument_list|,
name|ent
argument_list|,
name|option
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_other
argument_list|(
name|sb
argument_list|,
name|ent
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * To allow quick access to the contents of nth line in the  * final image, prepare an index in the scoreboard.  */
end_comment
begin_function
DECL|function|prepare_lines
specifier|static
name|int
name|prepare_lines
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buf
init|=
name|sb
operator|->
name|final_buf
decl_stmt|;
name|unsigned
name|long
name|len
init|=
name|sb
operator|->
name|final_buf_size
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|incomplete
init|=
literal|0
decl_stmt|,
name|bol
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|incomplete
operator|++
expr_stmt|;
comment|/* incomplete line at the end */
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|bol
condition|)
block|{
name|sb
operator|->
name|lineno
operator|=
name|xrealloc
argument_list|(
name|sb
operator|->
name|lineno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
operator|(
name|num
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|lineno
index|[
name|num
index|]
operator|=
name|buf
operator|-
name|sb
operator|->
name|final_buf
expr_stmt|;
name|bol
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf
operator|++
operator|==
literal|'\n'
condition|)
block|{
name|num
operator|++
expr_stmt|;
name|bol
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sb
operator|->
name|lineno
operator|=
name|xrealloc
argument_list|(
name|sb
operator|->
name|lineno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
operator|(
name|num
operator|+
name|incomplete
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|lineno
index|[
name|num
operator|+
name|incomplete
index|]
operator|=
name|buf
operator|-
name|sb
operator|->
name|final_buf
expr_stmt|;
name|sb
operator|->
name|num_lines
operator|=
name|num
operator|+
name|incomplete
expr_stmt|;
return|return
name|sb
operator|->
name|num_lines
return|;
block|}
end_function
begin_comment
comment|/*  * Add phony grafts for use with -S; this is primarily to  * support git's cvsserver that wants to give a linear history  * to its clients.  */
end_comment
begin_function
DECL|function|read_ancestry
specifier|static
name|int
name|read_ancestry
parameter_list|(
specifier|const
name|char
modifier|*
name|graft_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|graft_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|read_graft_line
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|graft
condition|)
name|register_commit_graft
argument_list|(
name|graft
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|update_auto_abbrev
specifier|static
name|int
name|update_auto_abbrev
parameter_list|(
name|int
name|auto_abbrev
parameter_list|,
name|struct
name|origin
modifier|*
name|suspect
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|uniq
init|=
name|find_unique_abbrev
argument_list|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|auto_abbrev
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|uniq
argument_list|)
decl_stmt|;
if|if
condition|(
name|auto_abbrev
operator|<
name|len
condition|)
return|return
name|len
return|;
return|return
name|auto_abbrev
return|;
block|}
end_function
begin_comment
comment|/*  * How many columns do we need to show line numbers, authors,  * and filenames?  */
end_comment
begin_function
DECL|function|find_alignment
specifier|static
name|void
name|find_alignment
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|,
name|int
modifier|*
name|option
parameter_list|)
block|{
name|int
name|longest_src_lines
init|=
literal|0
decl_stmt|;
name|int
name|longest_dst_lines
init|=
literal|0
decl_stmt|;
name|unsigned
name|largest_score
init|=
literal|0
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|e
decl_stmt|;
name|int
name|compute_auto_abbrev
init|=
operator|(
name|abbrev
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|auto_abbrev
init|=
name|default_abbrev
decl_stmt|;
for|for
control|(
name|e
operator|=
name|sb
operator|->
name|ent
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|struct
name|origin
modifier|*
name|suspect
init|=
name|e
operator|->
name|suspect
decl_stmt|;
name|struct
name|commit_info
name|ci
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
name|compute_auto_abbrev
condition|)
name|auto_abbrev
operator|=
name|update_auto_abbrev
argument_list|(
name|auto_abbrev
argument_list|,
name|suspect
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|suspect
operator|->
name|path
argument_list|,
name|sb
operator|->
name|path
argument_list|)
condition|)
operator|*
name|option
operator||=
name|OUTPUT_SHOW_NAME
expr_stmt|;
name|num
operator|=
name|strlen
argument_list|(
name|suspect
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_file
operator|<
name|num
condition|)
name|longest_file
operator|=
name|num
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|METAINFO_SHOWN
operator|)
condition|)
block|{
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|METAINFO_SHOWN
expr_stmt|;
name|get_commit_info
argument_list|(
name|suspect
operator|->
name|commit
argument_list|,
operator|&
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|&
name|OUTPUT_SHOW_EMAIL
condition|)
name|num
operator|=
name|utf8_strwidth
argument_list|(
name|ci
operator|.
name|author_mail
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
name|num
operator|=
name|utf8_strwidth
argument_list|(
name|ci
operator|.
name|author
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest_author
operator|<
name|num
condition|)
name|longest_author
operator|=
name|num
expr_stmt|;
block|}
name|num
operator|=
name|e
operator|->
name|s_lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
if|if
condition|(
name|longest_src_lines
operator|<
name|num
condition|)
name|longest_src_lines
operator|=
name|num
expr_stmt|;
name|num
operator|=
name|e
operator|->
name|lno
operator|+
name|e
operator|->
name|num_lines
expr_stmt|;
if|if
condition|(
name|longest_dst_lines
operator|<
name|num
condition|)
name|longest_dst_lines
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|largest_score
operator|<
name|ent_score
argument_list|(
name|sb
argument_list|,
name|e
argument_list|)
condition|)
name|largest_score
operator|=
name|ent_score
argument_list|(
name|sb
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|commit_info_destroy
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
block|}
name|max_orig_digits
operator|=
name|decimal_width
argument_list|(
name|longest_src_lines
argument_list|)
expr_stmt|;
name|max_digits
operator|=
name|decimal_width
argument_list|(
name|longest_dst_lines
argument_list|)
expr_stmt|;
name|max_score_digits
operator|=
name|decimal_width
argument_list|(
name|largest_score
argument_list|)
expr_stmt|;
if|if
condition|(
name|compute_auto_abbrev
condition|)
comment|/* one more abbrev length is needed for the boundary commit */
name|abbrev
operator|=
name|auto_abbrev
operator|+
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * For debugging -- origin is refcounted, and this asserts that  * we do not underflow.  */
end_comment
begin_function
DECL|function|sanity_check_refcnt
specifier|static
name|void
name|sanity_check_refcnt
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|baa
init|=
literal|0
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|->
name|ent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
comment|/* Nobody should have zero or negative refcnt */
if|if
condition|(
name|ent
operator|->
name|suspect
operator|->
name|refcnt
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s in %s has negative refcnt %d\n"
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|path
argument_list|,
name|sha1_to_hex
argument_list|(
name|ent
operator|->
name|suspect
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|ent
operator|->
name|suspect
operator|->
name|refcnt
argument_list|)
expr_stmt|;
name|baa
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|baa
condition|)
block|{
name|int
name|opt
init|=
literal|0160
decl_stmt|;
name|find_alignment
argument_list|(
name|sb
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|sb
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"Baa %d!"
argument_list|,
name|baa
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Used for the command line parsing; check if the path exists  * in the working tree.  */
end_comment
begin_function
DECL|function|has_string_in_work_tree
specifier|static
name|int
name|has_string_in_work_tree
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
return|return
operator|!
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_score
specifier|static
name|unsigned
name|parse_score
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|score
init|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
return|return
literal|0
return|;
return|return
name|score
return|;
block|}
end_function
begin_function
DECL|function|add_prefix
specifier|static
specifier|const
name|char
modifier|*
name|add_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
name|prefix_path
argument_list|(
name|prefix
argument_list|,
name|prefix
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_blame_config
specifier|static
name|int
name|git_blame_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"blame.showroot"
argument_list|)
condition|)
block|{
name|show_root
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"blame.blankboundary"
argument_list|)
condition|)
block|{
name|blank_boundary
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"blame.date"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
name|blame_date_mode
operator|=
name|parse_date_format
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|userdiff_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|verify_working_tree_path
specifier|static
name|void
name|verify_working_tree_path
parameter_list|(
name|struct
name|commit
modifier|*
name|work_tree
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
for|for
control|(
name|parents
operator|=
name|work_tree
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|commit_sha1
init|=
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
decl_stmt|;
name|unsigned
name|char
name|blob_sha1
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|get_tree_entry
argument_list|(
name|commit_sha1
argument_list|,
name|path
argument_list|,
name|blob_sha1
argument_list|,
operator|&
name|mode
argument_list|)
operator|&&
name|sha1_object_info
argument_list|(
name|blob_sha1
argument_list|,
name|NULL
argument_list|)
operator|==
name|OBJ_BLOB
condition|)
return|return;
block|}
name|die
argument_list|(
literal|"no such path '%s' in HEAD"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append_parent
specifier|static
name|struct
name|commit_list
modifier|*
modifier|*
name|append_parent
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|tail
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|parent
decl_stmt|;
name|parent
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
name|die
argument_list|(
literal|"no such commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
name|tail
argument_list|)
operator|->
name|next
return|;
block|}
end_function
begin_function
DECL|function|append_merge_parents
specifier|static
name|void
name|append_merge_parents
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|int
name|merge_head
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_head_file
init|=
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|line
init|=
name|STRBUF_INIT
decl_stmt|;
name|merge_head
operator|=
name|open
argument_list|(
name|merge_head_file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_head
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return;
name|die
argument_list|(
literal|"cannot open '%s' for reading"
argument_list|,
name|merge_head_file
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|strbuf_getwholeline_fd
argument_list|(
operator|&
name|line
argument_list|,
name|merge_head
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|line
operator|.
name|len
operator|<
literal|40
operator|||
name|get_sha1_hex
argument_list|(
name|line
operator|.
name|buf
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"unknown line in '%s': %s"
argument_list|,
name|merge_head_file
argument_list|,
name|line
operator|.
name|buf
argument_list|)
expr_stmt|;
name|tail
operator|=
name|append_parent
argument_list|(
name|tail
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|merge_head
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Prepare a dummy commit that represents the work tree (or staged) item.  * Note that annotating work tree item never works in the reverse.  */
end_comment
begin_function
DECL|function|fake_working_tree_commit
specifier|static
name|struct
name|commit
modifier|*
name|fake_working_tree_commit
parameter_list|(
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|contents_from
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|origin
modifier|*
name|origin
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|parent_tail
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|ident
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|int
name|size
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|unsigned
name|mode
decl_stmt|;
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|commit
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|commit
operator|->
name|date
operator|=
name|now
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|type
operator|=
name|OBJ_COMMIT
expr_stmt|;
name|parent_tail
operator|=
operator|&
name|commit
operator|->
name|parents
expr_stmt|;
if|if
condition|(
operator|!
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"no such ref: HEAD"
argument_list|)
expr_stmt|;
name|parent_tail
operator|=
name|append_parent
argument_list|(
name|parent_tail
argument_list|,
name|head_sha1
argument_list|)
expr_stmt|;
name|append_merge_parents
argument_list|(
name|parent_tail
argument_list|)
expr_stmt|;
name|verify_working_tree_path
argument_list|(
name|commit
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|origin
operator|=
name|make_origin
argument_list|(
name|commit
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ident
operator|=
name|fmt_ident
argument_list|(
literal|"Not Committed Yet"
argument_list|,
literal|"not.committed.yet"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msg
argument_list|,
literal|"tree 0000000000000000000000000000000000000000\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|parent
operator|=
name|commit
operator|->
name|parents
init|;
name|parent
condition|;
name|parent
operator|=
name|parent
operator|->
name|next
control|)
name|strbuf_addf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"parent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"author %s\n"
literal|"committer %s\n\n"
literal|"Version of %s from %s\n"
argument_list|,
name|ident
argument_list|,
name|ident
argument_list|,
name|path
argument_list|,
operator|(
operator|!
name|contents_from
condition|?
name|path
else|:
operator|(
operator|!
name|strcmp
argument_list|(
name|contents_from
argument_list|,
literal|"-"
argument_list|)
condition|?
literal|"standard input"
else|:
name|contents_from
operator|)
operator|)
argument_list|)
expr_stmt|;
name|commit
operator|->
name|buffer
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|msg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents_from
operator|||
name|strcmp
argument_list|(
literal|"-"
argument_list|,
name|contents_from
argument_list|)
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|read_from
decl_stmt|;
name|char
modifier|*
name|buf_ptr
decl_stmt|;
name|unsigned
name|long
name|buf_len
decl_stmt|;
if|if
condition|(
name|contents_from
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|contents_from
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"Cannot stat '%s'"
argument_list|,
name|contents_from
argument_list|)
expr_stmt|;
name|read_from
operator|=
name|contents_from
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"Cannot lstat '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|read_from
operator|=
name|path
expr_stmt|;
block|}
name|mode
operator|=
name|canon_mode
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
if|if
condition|(
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|ALLOW_TEXTCONV
argument_list|)
operator|&&
name|textconv_object
argument_list|(
name|read_from
argument_list|,
name|mode
argument_list|,
name|null_sha1
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_ptr
argument_list|,
operator|&
name|buf_len
argument_list|)
condition|)
name|strbuf_attach
argument_list|(
operator|&
name|buf
argument_list|,
name|buf_ptr
argument_list|,
name|buf_len
argument_list|,
name|buf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|buf
argument_list|,
name|read_from
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|!=
name|st
operator|.
name|st_size
condition|)
name|die_errno
argument_list|(
literal|"cannot open or read '%s'"
argument_list|,
name|read_from
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
if|if
condition|(
name|strbuf_readlink
argument_list|(
operator|&
name|buf
argument_list|,
name|read_from
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"cannot readlink '%s'"
argument_list|,
name|read_from
argument_list|)
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"unsupported file type %s"
argument_list|,
name|read_from
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Reading from stdin */
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"failed to read from stdin"
argument_list|)
expr_stmt|;
block|}
name|convert_to_git
argument_list|(
name|path
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|,
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|origin
operator|->
name|file
operator|.
name|ptr
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
name|origin
operator|->
name|file
operator|.
name|size
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|pretend_sha1_file
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|,
name|OBJ_BLOB
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|commit
operator|->
name|util
operator|=
name|origin
expr_stmt|;
comment|/* 	 * Read the current index, replace the path entry with 	 * origin->blob_sha1 without mucking with its mode or type 	 * bits; we are not going to write this index out -- we just 	 * want to run "diff-index --cached". 	 */
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
block|{
name|int
name|pos
init|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pos
condition|)
name|mode
operator|=
name|active_cache
index|[
name|pos
index|]
operator|->
name|ce_mode
expr_stmt|;
else|else
comment|/* Let's not bother reading from HEAD tree */
name|mode
operator|=
name|S_IFREG
operator||
literal|0644
expr_stmt|;
block|}
name|size
operator|=
name|cache_entry_size
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ce
operator|->
name|sha1
argument_list|,
name|origin
operator|->
name|blob_sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_namelen
operator|=
name|len
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|ADD_CACHE_OK_TO_ADD
operator||
name|ADD_CACHE_OK_TO_REPLACE
argument_list|)
expr_stmt|;
comment|/* 	 * We are not going to write this out, so this does not matter 	 * right now, but someday we might optimize diff-index --cached 	 * with cache-tree information. 	 */
name|cache_tree_invalidate_path
argument_list|(
name|active_cache_tree
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|commit
return|;
block|}
end_function
begin_function
DECL|function|prepare_final
specifier|static
specifier|const
name|char
modifier|*
name|prepare_final
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_commit_name
init|=
name|NULL
decl_stmt|;
name|struct
name|rev_info
modifier|*
name|revs
init|=
name|sb
operator|->
name|revs
decl_stmt|;
comment|/* 	 * There must be one and only one positive commit in the 	 * revs->pending array. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revs
operator|->
name|pending
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|flags
operator|&
name|UNINTERESTING
condition|)
continue|continue;
while|while
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
name|obj
operator|=
name|deref_tag
argument_list|(
name|obj
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Non commit %s?"
argument_list|,
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|final
condition|)
name|die
argument_list|(
literal|"More than one commit to dig from %s and %s?"
argument_list|,
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|final_commit_name
argument_list|)
expr_stmt|;
name|sb
operator|->
name|final
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
expr_stmt|;
name|final_commit_name
operator|=
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
return|return
name|final_commit_name
return|;
block|}
end_function
begin_function
DECL|function|prepare_initial
specifier|static
specifier|const
name|char
modifier|*
name|prepare_initial
parameter_list|(
name|struct
name|scoreboard
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_commit_name
init|=
name|NULL
decl_stmt|;
name|struct
name|rev_info
modifier|*
name|revs
init|=
name|sb
operator|->
name|revs
decl_stmt|;
comment|/* 	 * There must be one and only one negative commit, and it must be 	 * the boundary. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revs
operator|->
name|pending
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|obj
operator|->
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
continue|continue;
while|while
condition|(
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
name|obj
operator|=
name|deref_tag
argument_list|(
name|obj
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Non commit %s?"
argument_list|,
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|final
condition|)
name|die
argument_list|(
literal|"More than one commit to dig down to %s and %s?"
argument_list|,
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|final_commit_name
argument_list|)
expr_stmt|;
name|sb
operator|->
name|final
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
expr_stmt|;
name|final_commit_name
operator|=
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|final_commit_name
condition|)
name|die
argument_list|(
literal|"No commit to dig down to?"
argument_list|)
expr_stmt|;
return|return
name|final_commit_name
return|;
block|}
end_function
begin_function
DECL|function|blame_copy_callback
specifier|static
name|int
name|blame_copy_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|int
modifier|*
name|opt
init|=
name|option
operator|->
name|value
decl_stmt|;
comment|/* 	 * -C enables copy from removed files; 	 * -C -C enables copy from existing files, but only 	 *       when blaming a new file; 	 * -C -C -C enables copy from existing files for 	 *          everybody 	 */
if|if
condition|(
operator|*
name|opt
operator|&
name|PICKAXE_BLAME_COPY_HARDER
condition|)
operator|*
name|opt
operator||=
name|PICKAXE_BLAME_COPY_HARDEST
expr_stmt|;
if|if
condition|(
operator|*
name|opt
operator|&
name|PICKAXE_BLAME_COPY
condition|)
operator|*
name|opt
operator||=
name|PICKAXE_BLAME_COPY_HARDER
expr_stmt|;
operator|*
name|opt
operator||=
name|PICKAXE_BLAME_COPY
operator||
name|PICKAXE_BLAME_MOVE
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|blame_copy_score
operator|=
name|parse_score
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|blame_move_callback
specifier|static
name|int
name|blame_move_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|int
modifier|*
name|opt
init|=
name|option
operator|->
name|value
decl_stmt|;
operator|*
name|opt
operator||=
name|PICKAXE_BLAME_MOVE
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|blame_move_score
operator|=
name|parse_score
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmd_blame
name|int
name|cmd_blame
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|scoreboard
name|sb
decl_stmt|;
name|struct
name|origin
modifier|*
name|o
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|ent
init|=
name|NULL
decl_stmt|;
name|long
name|dashdash_pos
decl_stmt|,
name|lno
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_commit_name
init|=
name|NULL
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
specifier|static
name|struct
name|string_list
name|range_list
decl_stmt|;
specifier|static
name|int
name|output_option
init|=
literal|0
decl_stmt|,
name|opt
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|show_stats
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|revs_file
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|contents_from
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"incremental"
argument_list|,
operator|&
name|incremental
argument_list|,
name|N_
argument_list|(
literal|"Show blame entries as we find them, incrementally"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'b'
argument_list|,
name|NULL
argument_list|,
operator|&
name|blank_boundary
argument_list|,
name|N_
argument_list|(
literal|"Show blank SHA-1 for boundary commits (Default: off)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"root"
argument_list|,
operator|&
name|show_root
argument_list|,
name|N_
argument_list|(
literal|"Do not treat root commits as boundaries (Default: off)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"show-stats"
argument_list|,
operator|&
name|show_stats
argument_list|,
name|N_
argument_list|(
literal|"Show work cost statistics"
argument_list|)
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"score-debug"
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show output score for blame entries"
argument_list|)
argument_list|,
name|OUTPUT_SHOW_SCORE
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'f'
argument_list|,
literal|"show-name"
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show original filename (Default: auto)"
argument_list|)
argument_list|,
name|OUTPUT_SHOW_NAME
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'n'
argument_list|,
literal|"show-number"
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show original linenumber (Default: off)"
argument_list|)
argument_list|,
name|OUTPUT_SHOW_NUMBER
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'p'
argument_list|,
literal|"porcelain"
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show in a format designed for machine consumption"
argument_list|)
argument_list|,
name|OUTPUT_PORCELAIN
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"line-porcelain"
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show porcelain format with per-line commit information"
argument_list|)
argument_list|,
name|OUTPUT_PORCELAIN
operator||
name|OUTPUT_LINE_PORCELAIN
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'c'
argument_list|,
name|NULL
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Use the same output mode as git-annotate (Default: off)"
argument_list|)
argument_list|,
name|OUTPUT_ANNOTATE_COMPAT
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'t'
argument_list|,
name|NULL
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show raw timestamp (Default: off)"
argument_list|)
argument_list|,
name|OUTPUT_RAW_TIMESTAMP
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'l'
argument_list|,
name|NULL
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show long commit SHA1 (Default: off)"
argument_list|)
argument_list|,
name|OUTPUT_LONG_OBJECT_NAME
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'s'
argument_list|,
name|NULL
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Suppress author name and timestamp (Default: off)"
argument_list|)
argument_list|,
name|OUTPUT_NO_AUTHOR
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'e'
argument_list|,
literal|"show-email"
argument_list|,
operator|&
name|output_option
argument_list|,
name|N_
argument_list|(
literal|"Show author email instead of name (Default: off)"
argument_list|)
argument_list|,
name|OUTPUT_SHOW_EMAIL
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'w'
argument_list|,
name|NULL
argument_list|,
operator|&
name|xdl_opts
argument_list|,
name|N_
argument_list|(
literal|"Ignore whitespace differences"
argument_list|)
argument_list|,
name|XDF_IGNORE_WHITESPACE
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"minimal"
argument_list|,
operator|&
name|xdl_opts
argument_list|,
name|N_
argument_list|(
literal|"Spend extra cycles to find better match"
argument_list|)
argument_list|,
name|XDF_NEED_MINIMAL
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'S'
argument_list|,
name|NULL
argument_list|,
operator|&
name|revs_file
argument_list|,
name|N_
argument_list|(
literal|"file"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Use revisions from<file> instead of calling git-rev-list"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"contents"
argument_list|,
operator|&
name|contents_from
argument_list|,
name|N_
argument_list|(
literal|"file"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Use<file>'s contents as the final image"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'C'
block|,
name|NULL
block|,
operator|&
name|opt
block|,
name|N_
argument_list|(
literal|"score"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Find line copies within and across files"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|blame_copy_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'M'
block|,
name|NULL
block|,
operator|&
name|opt
block|,
name|N_
argument_list|(
literal|"score"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Find line movements within and across files"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|blame_move_callback
block|}
block|,
name|OPT_STRING_LIST
argument_list|(
literal|'L'
argument_list|,
name|NULL
argument_list|,
operator|&
name|range_list
argument_list|,
name|N_
argument_list|(
literal|"n,m"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Process only line range n,m, counting from 1"
argument_list|)
argument_list|)
block|,
name|OPT__ABBREV
argument_list|(
operator|&
name|abbrev
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|struct
name|parse_opt_ctx_t
name|ctx
decl_stmt|;
name|int
name|cmd_is_annotate
init|=
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"annotate"
argument_list|)
decl_stmt|;
name|struct
name|range_set
name|ranges
decl_stmt|;
name|unsigned
name|int
name|range_i
decl_stmt|;
name|long
name|anchor
decl_stmt|;
name|git_config
argument_list|(
name|git_blame_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|revs
operator|.
name|date_mode
operator|=
name|blame_date_mode
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|revs
operator|.
name|diffopt
argument_list|,
name|ALLOW_TEXTCONV
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|revs
operator|.
name|diffopt
argument_list|,
name|FOLLOW_RENAMES
argument_list|)
expr_stmt|;
name|save_commit_buffer
operator|=
literal|0
expr_stmt|;
name|dashdash_pos
operator|=
literal|0
expr_stmt|;
name|parse_options_start
argument_list|(
operator|&
name|ctx
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|PARSE_OPT_KEEP_DASHDASH
operator||
name|PARSE_OPT_KEEP_ARGV0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|parse_options_step
argument_list|(
operator|&
name|ctx
argument_list|,
name|options
argument_list|,
name|blame_opt_usage
argument_list|)
condition|)
block|{
case|case
name|PARSE_OPT_HELP
case|:
name|exit
argument_list|(
literal|129
argument_list|)
expr_stmt|;
case|case
name|PARSE_OPT_DONE
case|:
if|if
condition|(
name|ctx
operator|.
name|argv
index|[
literal|0
index|]
condition|)
name|dashdash_pos
operator|=
name|ctx
operator|.
name|cpidx
expr_stmt|;
goto|goto
name|parse_done
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ctx
operator|.
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"--reverse"
argument_list|)
condition|)
block|{
name|ctx
operator|.
name|argv
index|[
literal|0
index|]
operator|=
literal|"--children"
expr_stmt|;
name|reverse
operator|=
literal|1
expr_stmt|;
block|}
name|parse_revision_opt
argument_list|(
operator|&
name|revs
argument_list|,
operator|&
name|ctx
argument_list|,
name|options
argument_list|,
name|blame_opt_usage
argument_list|)
expr_stmt|;
block|}
name|parse_done
label|:
name|no_whole_file_rename
operator|=
operator|!
name|DIFF_OPT_TST
argument_list|(
operator|&
name|revs
operator|.
name|diffopt
argument_list|,
name|FOLLOW_RENAMES
argument_list|)
expr_stmt|;
name|DIFF_OPT_CLR
argument_list|(
operator|&
name|revs
operator|.
name|diffopt
argument_list|,
name|FOLLOW_RENAMES
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options_end
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|abbrev
condition|)
comment|/* one more abbrev length is needed for the boundary commit */
name|abbrev
operator|++
expr_stmt|;
if|if
condition|(
name|revs_file
operator|&&
name|read_ancestry
argument_list|(
name|revs_file
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"reading graft file '%s' failed"
argument_list|,
name|revs_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_is_annotate
condition|)
block|{
name|output_option
operator||=
name|OUTPUT_ANNOTATE_COMPAT
expr_stmt|;
name|blame_date_mode
operator|=
name|DATE_ISO8601
expr_stmt|;
block|}
else|else
block|{
name|blame_date_mode
operator|=
name|revs
operator|.
name|date_mode
expr_stmt|;
block|}
comment|/* The maximum width used to show the dates */
switch|switch
condition|(
name|blame_date_mode
condition|)
block|{
case|case
name|DATE_RFC2822
case|:
name|blame_date_width
operator|=
sizeof|sizeof
argument_list|(
literal|"Thu, 19 Oct 2006 16:00:04 -0700"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE_ISO8601
case|:
name|blame_date_width
operator|=
sizeof|sizeof
argument_list|(
literal|"2006-10-19 16:00:04 -0700"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE_RAW
case|:
name|blame_date_width
operator|=
sizeof|sizeof
argument_list|(
literal|"1161298804 -0700"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE_SHORT
case|:
name|blame_date_width
operator|=
sizeof|sizeof
argument_list|(
literal|"2006-10-19"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE_RELATIVE
case|:
comment|/* "normal" is used as the fallback for "relative" */
case|case
name|DATE_LOCAL
case|:
case|case
name|DATE_NORMAL
case|:
name|blame_date_width
operator|=
sizeof|sizeof
argument_list|(
literal|"Thu Oct 19 16:00:04 2006 -0700"
argument_list|)
expr_stmt|;
break|break;
block|}
name|blame_date_width
operator|-=
literal|1
expr_stmt|;
comment|/* strip the null */
if|if
condition|(
name|DIFF_OPT_TST
argument_list|(
operator|&
name|revs
operator|.
name|diffopt
argument_list|,
name|FIND_COPIES_HARDER
argument_list|)
condition|)
name|opt
operator||=
operator|(
name|PICKAXE_BLAME_COPY
operator||
name|PICKAXE_BLAME_MOVE
operator||
name|PICKAXE_BLAME_COPY_HARDER
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|blame_move_score
condition|)
name|blame_move_score
operator|=
name|BLAME_DEFAULT_MOVE_SCORE
expr_stmt|;
if|if
condition|(
operator|!
name|blame_copy_score
condition|)
name|blame_copy_score
operator|=
name|BLAME_DEFAULT_COPY_SCORE
expr_stmt|;
comment|/* 	 * We have collected options unknown to us in argv[1..unk] 	 * which are to be passed to revision machinery if we are 	 * going to do the "bottom" processing. 	 * 	 * The remaining are: 	 * 	 * (1) if dashdash_pos != 0, it is either 	 *     "blame [revisions] --<path>" or 	 *     "blame --<path><rev>" 	 * 	 * (2) otherwise, it is one of the two: 	 *     "blame [revisions]<path>" 	 *     "blame<path><rev>" 	 * 	 * Note that we must strip out<path> from the arguments: we do not 	 * want the path pruning but we may want "bottom" processing. 	 */
if|if
condition|(
name|dashdash_pos
condition|)
block|{
switch|switch
condition|(
name|argc
operator|-
name|dashdash_pos
operator|-
literal|1
condition|)
block|{
case|case
literal|2
case|:
comment|/* (1b) */
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
name|usage_with_options
argument_list|(
name|blame_opt_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
comment|/* reorder for the new way:<rev> --<path> */
name|argv
index|[
literal|1
index|]
operator|=
name|argv
index|[
literal|3
index|]
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
literal|"--"
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
comment|/* (1a) */
name|path
operator|=
name|add_prefix
argument_list|(
name|prefix
argument_list|,
name|argv
index|[
operator|--
name|argc
index|]
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|usage_with_options
argument_list|(
name|blame_opt_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage_with_options
argument_list|(
name|blame_opt_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|path
operator|=
name|add_prefix
argument_list|(
name|prefix
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
operator|&&
operator|!
name|has_string_in_work_tree
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* (2b) */
name|path
operator|=
name|add_prefix
argument_list|(
name|prefix
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
name|argv
index|[
name|argc
operator|-
literal|1
index|]
operator|=
literal|"--"
expr_stmt|;
name|setup_work_tree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|has_string_in_work_tree
argument_list|(
name|path
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"cannot stat path '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|revs
operator|.
name|disable_stdin
operator|=
literal|1
expr_stmt|;
name|setup_revisions
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|revs
operator|=
operator|&
name|revs
expr_stmt|;
if|if
condition|(
operator|!
name|reverse
condition|)
name|final_commit_name
operator|=
name|prepare_final
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|contents_from
condition|)
name|die
argument_list|(
literal|"--contents and --children do not blend well."
argument_list|)
expr_stmt|;
else|else
name|final_commit_name
operator|=
name|prepare_initial
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sb
operator|.
name|final
condition|)
block|{
comment|/* 		 * "--not A B -- path" without anything positive; 		 * do not default to HEAD, but use the working tree 		 * or "--contents". 		 */
name|setup_work_tree
argument_list|()
expr_stmt|;
name|sb
operator|.
name|final
operator|=
name|fake_working_tree_commit
argument_list|(
operator|&
name|sb
operator|.
name|revs
operator|->
name|diffopt
argument_list|,
name|path
argument_list|,
name|contents_from
argument_list|)
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|revs
argument_list|,
operator|&
operator|(
name|sb
operator|.
name|final
operator|->
name|object
operator|)
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contents_from
condition|)
name|die
argument_list|(
literal|"Cannot use --contents with final commit object name"
argument_list|)
expr_stmt|;
comment|/* 	 * If we have bottom, this will mark the ancestors of the 	 * bottom commits we would reach while traversing as 	 * uninteresting. 	 */
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
literal|"revision walk setup failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|sb
operator|.
name|final
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|o
operator|=
name|sb
operator|.
name|final
operator|->
name|util
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|o
operator|->
name|file
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|o
operator|->
name|file
operator|.
name|ptr
argument_list|,
name|o
operator|->
name|file
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|.
name|final_buf
operator|=
name|buf
expr_stmt|;
name|sb
operator|.
name|final_buf_size
operator|=
name|o
operator|->
name|file
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|o
operator|=
name|get_origin
argument_list|(
operator|&
name|sb
argument_list|,
name|sb
operator|.
name|final
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill_blob_sha1_and_mode
argument_list|(
name|o
argument_list|)
condition|)
name|die
argument_list|(
literal|"no such path %s in %s"
argument_list|,
name|path
argument_list|,
name|final_commit_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIFF_OPT_TST
argument_list|(
operator|&
name|sb
operator|.
name|revs
operator|->
name|diffopt
argument_list|,
name|ALLOW_TEXTCONV
argument_list|)
operator|&&
name|textconv_object
argument_list|(
name|path
argument_list|,
name|o
operator|->
name|mode
argument_list|,
name|o
operator|->
name|blob_sha1
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|sb
operator|.
name|final_buf
argument_list|,
operator|&
name|sb
operator|.
name|final_buf_size
argument_list|)
condition|)
empty_stmt|;
else|else
name|sb
operator|.
name|final_buf
operator|=
name|read_sha1_file
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|sb
operator|.
name|final_buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sb
operator|.
name|final_buf
condition|)
name|die
argument_list|(
literal|"Cannot read blob %s for path %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|o
operator|->
name|blob_sha1
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|num_read_blob
operator|++
expr_stmt|;
name|lno
operator|=
name|prepare_lines
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lno
operator|&&
operator|!
name|range_list
operator|.
name|nr
condition|)
name|string_list_append
argument_list|(
operator|&
name|range_list
argument_list|,
name|xstrdup
argument_list|(
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|anchor
operator|=
literal|1
expr_stmt|;
name|range_set_init
argument_list|(
operator|&
name|ranges
argument_list|,
name|range_list
operator|.
name|nr
argument_list|)
expr_stmt|;
for|for
control|(
name|range_i
operator|=
literal|0
init|;
name|range_i
operator|<
name|range_list
operator|.
name|nr
condition|;
operator|++
name|range_i
control|)
block|{
name|long
name|bottom
decl_stmt|,
name|top
decl_stmt|;
if|if
condition|(
name|parse_range_arg
argument_list|(
name|range_list
operator|.
name|items
index|[
name|range_i
index|]
operator|.
name|string
argument_list|,
name|nth_line_cb
argument_list|,
operator|&
name|sb
argument_list|,
name|lno
argument_list|,
name|anchor
argument_list|,
operator|&
name|bottom
argument_list|,
operator|&
name|top
argument_list|,
name|sb
operator|.
name|path
argument_list|)
condition|)
name|usage
argument_list|(
name|blame_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|lno
operator|<
name|top
operator|||
operator|(
operator|(
name|lno
operator|||
name|bottom
operator|)
operator|&&
name|lno
operator|<
name|bottom
operator|)
condition|)
name|die
argument_list|(
literal|"file %s has only %lu lines"
argument_list|,
name|path
argument_list|,
name|lno
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottom
operator|<
literal|1
condition|)
name|bottom
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|top
operator|<
literal|1
condition|)
name|top
operator|=
name|lno
expr_stmt|;
name|bottom
operator|--
expr_stmt|;
name|range_set_append_unsafe
argument_list|(
operator|&
name|ranges
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|top
operator|+
literal|1
expr_stmt|;
block|}
name|sort_and_merge_range_set
argument_list|(
operator|&
name|ranges
argument_list|)
expr_stmt|;
for|for
control|(
name|range_i
operator|=
name|ranges
operator|.
name|nr
init|;
name|range_i
operator|>
literal|0
condition|;
operator|--
name|range_i
control|)
block|{
specifier|const
name|struct
name|range
modifier|*
name|r
init|=
operator|&
name|ranges
operator|.
name|ranges
index|[
name|range_i
operator|-
literal|1
index|]
decl_stmt|;
name|long
name|bottom
init|=
name|r
operator|->
name|start
decl_stmt|;
name|long
name|top
init|=
name|r
operator|->
name|end
decl_stmt|;
name|struct
name|blame_entry
modifier|*
name|next
init|=
name|ent
decl_stmt|;
name|ent
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|lno
operator|=
name|bottom
expr_stmt|;
name|ent
operator|->
name|num_lines
operator|=
name|top
operator|-
name|bottom
expr_stmt|;
name|ent
operator|->
name|suspect
operator|=
name|o
expr_stmt|;
name|ent
operator|->
name|s_lno
operator|=
name|bottom
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|ent
expr_stmt|;
name|origin_incref
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
name|origin_decref
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|range_set_release
argument_list|(
operator|&
name|ranges
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|range_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sb
operator|.
name|ent
operator|=
name|ent
expr_stmt|;
name|sb
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|read_mailmap
argument_list|(
operator|&
name|mailmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|incremental
condition|)
name|setup_pager
argument_list|()
expr_stmt|;
name|assign_blame
argument_list|(
operator|&
name|sb
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
return|return
literal|0
return|;
name|coalesce
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|output_option
operator|&
name|OUTPUT_PORCELAIN
operator|)
condition|)
name|find_alignment
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|output_option
argument_list|)
expr_stmt|;
name|output
argument_list|(
operator|&
name|sb
argument_list|,
name|output_option
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sb
operator|.
name|final_buf
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sb
operator|.
name|ent
init|;
name|ent
condition|;
control|)
block|{
name|struct
name|blame_entry
modifier|*
name|e
init|=
name|ent
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|ent
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|show_stats
condition|)
block|{
name|printf
argument_list|(
literal|"num read blob: %d\n"
argument_list|,
name|num_read_blob
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"num get patch: %d\n"
argument_list|,
name|num_get_patch
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"num commits: %d\n"
argument_list|,
name|num_commits
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
