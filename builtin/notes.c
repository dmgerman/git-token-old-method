begin_unit
begin_comment
comment|/*  * Builtin "git notes"  *  * Copyright (c) 2010 Johan Herland<johan@herland.net>  *  * Based on git-notes.sh by Johannes Schindelin,  * and builtin/tag.c by Kristian HÃ¸gsberg and Carlos Rica.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"notes-merge.h"
end_include
begin_include
include|#
directive|include
file|"notes-utils.h"
end_include
begin_decl_stmt
DECL|variable|git_notes_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] [list [<object>]]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] add [-f] [-m<msg> | -F<file> | (-c | -C)<object>] [<object>]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] copy [-f]<from-object><to-object>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] append [-m<msg> | -F<file> | (-c | -C)<object>] [<object>]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] edit [<object>]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] show [<object>]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] merge [-v | -q] [-s<strategy> ]<notes_ref>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes merge --commit [-v | -q]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes merge --abort [-v | -q]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] remove [<object>...]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] prune [-n | -v]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes [--ref<notes_ref>] get-ref"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_list_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_list_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes [list [<object>]]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_add_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_add_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes add [<options>] [<object>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_copy_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_copy_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes copy [<options>]<from-object><to-object>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes copy --stdin [<from-object><to-object>]..."
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_append_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_append_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes append [<options>] [<object>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_edit_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_edit_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes edit [<object>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_show_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_show_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes show [<object>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_merge_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_merge_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes merge [<options>]<notes_ref>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes merge --commit [<options>]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git notes merge --abort [<options>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_remove_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_remove_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes remove [<object>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_prune_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_prune_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes prune [<options>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_get_ref_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_get_ref_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git notes get-ref"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|note_template
specifier|static
specifier|const
name|char
name|note_template
index|[]
init|=
literal|"\nWrite/edit the notes for the following object:\n"
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|note_data
struct|struct
name|note_data
block|{
DECL|member|given
name|int
name|given
decl_stmt|;
DECL|member|use_editor
name|int
name|use_editor
decl_stmt|;
DECL|member|edit_path
name|char
modifier|*
name|edit_path
decl_stmt|;
DECL|member|buf
name|struct
name|strbuf
name|buf
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|free_note_data
specifier|static
name|void
name|free_note_data
parameter_list|(
name|struct
name|note_data
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|edit_path
condition|)
block|{
name|unlink_or_warn
argument_list|(
name|d
operator|->
name|edit_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|edit_path
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|list_each_note
specifier|static
name|int
name|list_each_note
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|object_sha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|note_sha1
parameter_list|,
name|char
modifier|*
name|note_path
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|note_sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object_sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|copy_obj_to_fd
specifier|static
name|void
name|copy_obj_to_fd
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
if|if
condition|(
name|size
condition|)
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|write_commented_object
specifier|static
name|void
name|write_commented_object
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|object
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|show_args
index|[
literal|5
index|]
init|=
block|{
literal|"show"
block|,
literal|"--stat"
block|,
literal|"--no-notes"
block|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|child_process
name|show
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|cbuf
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* Invoke "git show --stat --no-notes $object" */
name|show
operator|.
name|argv
operator|=
name|show_args
expr_stmt|;
name|show
operator|.
name|no_stdin
operator|=
literal|1
expr_stmt|;
name|show
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|show
operator|.
name|err
operator|=
literal|0
expr_stmt|;
name|show
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|show
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to start 'show' for object '%s'"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|buf
argument_list|,
name|show
operator|.
name|out
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read 'show' output"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_add_commented_lines
argument_list|(
operator|&
name|cbuf
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|cbuf
operator|.
name|buf
argument_list|,
name|cbuf
operator|.
name|len
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|cbuf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|show
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to finish 'show' for object '%s'"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_note_data
specifier|static
name|void
name|prepare_note_data
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|object
parameter_list|,
name|struct
name|note_data
modifier|*
name|d
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_note
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|use_editor
operator|||
operator|!
name|d
operator|->
name|given
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* write the template message before editing: */
name|d
operator|->
name|edit_path
operator|=
name|git_pathdup
argument_list|(
literal|"NOTES_EDITMSG"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|d
operator|->
name|edit_path
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not create file '%s'"
argument_list|)
argument_list|,
name|d
operator|->
name|edit_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|given
condition|)
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|d
operator|->
name|buf
operator|.
name|buf
argument_list|,
name|d
operator|->
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|old_note
condition|)
name|copy_obj_to_fd
argument_list|(
name|fd
argument_list|,
name|old_note
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_add_commented_lines
argument_list|(
operator|&
name|buf
argument_list|,
name|note_template
argument_list|,
name|strlen
argument_list|(
name|note_template
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|write_commented_object
argument_list|(
name|fd
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|launch_editor
argument_list|(
name|d
operator|->
name|edit_path
argument_list|,
operator|&
name|d
operator|->
name|buf
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|die
argument_list|(
name|_
argument_list|(
literal|"Please supply the note contents using either -m or -F option"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stripspace
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|write_note_data
specifier|static
name|void
name|write_note_data
parameter_list|(
name|struct
name|note_data
modifier|*
name|d
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
if|if
condition|(
name|write_sha1_file
argument_list|(
name|d
operator|->
name|buf
operator|.
name|buf
argument_list|,
name|d
operator|->
name|buf
operator|.
name|len
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"unable to write note object"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|edit_path
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"The note contents have been left in %s"
argument_list|)
argument_list|,
name|d
operator|->
name|edit_path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parse_msg_arg
specifier|static
name|int
name|parse_msg_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|note_data
modifier|*
name|d
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|strbuf_grow
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|buf
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|stripspace
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|given
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_file_arg
specifier|static
name|int
name|parse_file_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|note_data
modifier|*
name|d
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|buf
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"cannot read '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
name|arg
argument_list|,
literal|1024
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not open or read '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|stripspace
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|given
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_reuse_arg
specifier|static
name|int
name|parse_reuse_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|note_data
modifier|*
name|d
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|buf
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|arg
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|object
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to read object '%s'."
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot read note data from non-blob object '%s'."
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|strbuf_add
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|d
operator|->
name|given
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_reedit_arg
specifier|static
name|int
name|parse_reedit_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|note_data
modifier|*
name|d
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|d
operator|->
name|use_editor
operator|=
literal|1
expr_stmt|;
return|return
name|parse_reuse_arg
argument_list|(
name|opt
argument_list|,
name|arg
argument_list|,
name|unset
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|notes_copy_from_stdin
specifier|static
name|int
name|notes_copy_from_stdin
parameter_list|(
name|int
name|force
parameter_list|,
specifier|const
name|char
modifier|*
name|rewrite_cmd
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|notes_rewrite_cfg
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"Notes added by 'git notes copy'"
decl_stmt|;
if|if
condition|(
name|rewrite_cmd
condition|)
block|{
name|c
operator|=
name|init_copy_notes_for_rewrite
argument_list|(
name|rewrite_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|init_notes
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|default_notes_tree
expr_stmt|;
block|}
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|buf
argument_list|,
name|stdin
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|unsigned
name|char
name|from_obj
index|[
literal|20
index|]
decl_stmt|,
name|to_obj
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
modifier|*
modifier|*
name|split
decl_stmt|;
name|int
name|err
decl_stmt|;
name|split
operator|=
name|strbuf_split
argument_list|(
operator|&
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|split
index|[
literal|0
index|]
operator|||
operator|!
name|split
index|[
literal|1
index|]
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Malformed input line: '%s'."
argument_list|)
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_rtrim
argument_list|(
name|split
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strbuf_rtrim
argument_list|(
name|split
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|split
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
name|from_obj
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|split
index|[
literal|0
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|split
index|[
literal|1
index|]
operator|->
name|buf
argument_list|,
name|to_obj
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|split
index|[
literal|1
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rewrite_cmd
condition|)
name|err
operator|=
name|copy_note_for_rewrite
argument_list|(
name|c
argument_list|,
name|from_obj
argument_list|,
name|to_obj
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|copy_note
argument_list|(
name|t
argument_list|,
name|from_obj
argument_list|,
name|to_obj
argument_list|,
name|force
argument_list|,
name|combine_notes_overwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to copy notes from '%s' to '%s'"
argument_list|)
argument_list|,
name|split
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
name|split
index|[
literal|1
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|strbuf_list_free
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rewrite_cmd
condition|)
block|{
name|commit_notes
argument_list|(
name|t
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|finish_copy_notes_for_rewrite
argument_list|(
name|c
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|init_notes_check
specifier|static
name|struct
name|notes_tree
modifier|*
name|init_notes_check
parameter_list|(
specifier|const
name|char
modifier|*
name|subcommand
parameter_list|)
block|{
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|init_notes
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|default_notes_tree
expr_stmt|;
if|if
condition|(
operator|!
name|starts_with
argument_list|(
name|t
operator|->
name|ref
argument_list|,
literal|"refs/notes/"
argument_list|)
condition|)
name|die
argument_list|(
literal|"Refusing to %s notes in %s (outside of refs/notes/)"
argument_list|,
name|subcommand
argument_list|,
name|t
operator|->
name|ref
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|list
specifier|static
name|int
name|list
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_END
argument_list|()
block|}
decl_stmt|;
if|if
condition|(
name|argc
condition|)
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_list_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_list_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
if|if
condition|(
name|get_sha1
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|puts
argument_list|(
name|sha1_to_hex
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"No note found for object %s."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|for_each_note
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|list_each_note
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function_decl
specifier|static
name|int
name|append_edit
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|add
specifier|static
name|int
name|add
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|force
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|,
name|new_note
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|struct
name|note_data
name|d
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|STRBUF_INIT
block|}
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|'m'
block|,
literal|"message"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"message"
argument_list|)
block|,
name|N_
argument_list|(
literal|"note contents as a string"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_msg_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'F'
block|,
literal|"file"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"file"
argument_list|)
block|,
name|N_
argument_list|(
literal|"note contents in a file"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_file_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'c'
block|,
literal|"reedit-message"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"object"
argument_list|)
block|,
name|N_
argument_list|(
literal|"reuse and edit specified note object"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reedit_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'C'
block|,
literal|"reuse-message"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"object"
argument_list|)
block|,
name|N_
argument_list|(
literal|"reuse specified note object"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reuse_arg
block|}
block|,
name|OPT__FORCE
argument_list|(
operator|&
name|force
argument_list|,
name|N_
argument_list|(
literal|"replace existing notes"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_add_usage
argument_list|,
name|PARSE_OPT_KEEP_ARGV0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|2
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_add_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|object_ref
operator|=
name|argc
operator|>
literal|1
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"add"
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|given
condition|)
block|{
name|free_note_data
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot add notes. "
literal|"Found existing notes for object %s. "
literal|"Use '-f' to overwrite existing notes"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
return|;
block|}
comment|/* 			 * Redirect to "edit" subcommand. 			 * 			 * We only end up here if none of -m/-F/-c/-C or -f are 			 * given. The original args are therefore still in 			 * argv[0-1]. 			 */
name|argv
index|[
literal|0
index|]
operator|=
literal|"edit"
expr_stmt|;
return|return
name|append_edit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Overwriting existing notes for object %s\n"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prepare_note_data
argument_list|(
name|object
argument_list|,
operator|&
name|d
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|buf
operator|.
name|len
condition|)
block|{
name|write_note_data
argument_list|(
operator|&
name|d
argument_list|,
name|new_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|,
name|new_note
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes added by 'git notes add'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Removing note for object %s\n"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes removed by 'git notes add'"
argument_list|)
expr_stmt|;
block|}
name|free_note_data
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|copy
specifier|static
name|int
name|copy
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|force
init|=
literal|0
decl_stmt|,
name|from_stdin
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|from_note
decl_stmt|,
modifier|*
name|note
decl_stmt|;
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|,
name|from_obj
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|rewrite_cmd
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT__FORCE
argument_list|(
operator|&
name|force
argument_list|,
name|N_
argument_list|(
literal|"replace existing notes"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"stdin"
argument_list|,
operator|&
name|from_stdin
argument_list|,
name|N_
argument_list|(
literal|"read objects from stdin"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"for-rewrite"
argument_list|,
operator|&
name|rewrite_cmd
argument_list|,
name|N_
argument_list|(
literal|"command"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"load rewriting config for<command> (implies "
literal|"--stdin)"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_copy_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_stdin
operator|||
name|rewrite_cmd
condition|)
block|{
if|if
condition|(
name|argc
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_copy_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|notes_copy_from_stdin
argument_list|(
name|force
argument_list|,
name|rewrite_cmd
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too few parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_copy_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|2
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_copy_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_sha1
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|from_obj
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|object_ref
operator|=
literal|1
operator|<
name|argc
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|retval
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot copy notes. Found existing "
literal|"notes for object %s. Use '-f' to "
literal|"overwrite existing notes"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Overwriting existing notes for object %s\n"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|from_note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|from_obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_note
condition|)
block|{
name|retval
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"Missing notes on source object %s. Cannot "
literal|"copy."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|from_obj
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|,
name|from_note
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes added by 'git notes copy'"
argument_list|)
expr_stmt|;
name|out
label|:
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|append_edit
specifier|static
name|int
name|append_edit
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|,
name|new_note
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|char
name|logmsg
index|[
literal|100
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|usage
decl_stmt|;
name|struct
name|note_data
name|d
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|STRBUF_INIT
block|}
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|'m'
block|,
literal|"message"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"message"
argument_list|)
block|,
name|N_
argument_list|(
literal|"note contents as a string"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_msg_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'F'
block|,
literal|"file"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"file"
argument_list|)
block|,
name|N_
argument_list|(
literal|"note contents in a file"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_file_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'c'
block|,
literal|"reedit-message"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"object"
argument_list|)
block|,
name|N_
argument_list|(
literal|"reuse and edit specified note object"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reedit_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'C'
block|,
literal|"reuse-message"
block|,
operator|&
name|d
block|,
name|N_
argument_list|(
literal|"object"
argument_list|)
block|,
name|N_
argument_list|(
literal|"reuse specified note object"
argument_list|)
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reuse_arg
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|int
name|edit
init|=
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"edit"
argument_list|)
decl_stmt|;
name|usage
operator|=
name|edit
condition|?
name|git_notes_edit_usage
else|:
name|git_notes_append_usage
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|usage
argument_list|,
name|PARSE_OPT_KEEP_ARGV0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|2
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|.
name|given
operator|&&
name|edit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"The -m/-F/-c/-C options have been deprecated "
literal|"for the 'edit' subcommand.\n"
literal|"Please use 'git notes add -f -m/-F/-c/-C' instead.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|object_ref
operator|=
literal|1
operator|<
name|argc
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|prepare_note_data
argument_list|(
name|object
argument_list|,
operator|&
name|d
argument_list|,
name|edit
condition|?
name|note
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|&&
operator|!
name|edit
condition|)
block|{
comment|/* Append buf to previous note contents */
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
modifier|*
name|prev_buf
init|=
name|read_sha1_file
argument_list|(
name|note
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|strbuf_grow
argument_list|(
operator|&
name|d
operator|.
name|buf
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|buf
operator|.
name|len
operator|&&
name|prev_buf
operator|&&
name|size
condition|)
name|strbuf_insert
argument_list|(
operator|&
name|d
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_buf
operator|&&
name|size
condition|)
name|strbuf_insert
argument_list|(
operator|&
name|d
operator|.
name|buf
argument_list|,
literal|0
argument_list|,
name|prev_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|.
name|buf
operator|.
name|len
condition|)
block|{
name|write_note_data
argument_list|(
operator|&
name|d
argument_list|,
name|new_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|,
name|new_note
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|logmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|logmsg
argument_list|)
argument_list|,
literal|"Notes added by 'git notes %s'"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Removing note for object %s\n"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|logmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|logmsg
argument_list|)
argument_list|,
literal|"Notes removed by 'git notes %s'"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|commit_notes
argument_list|(
name|t
argument_list|,
name|logmsg
argument_list|)
expr_stmt|;
name|free_note_data
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|show
specifier|static
name|int
name|show
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_show_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_show_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|object_ref
operator|=
name|argc
condition|?
name|argv
index|[
literal|0
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"show"
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
name|retval
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"No note found for object %s."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|show_args
index|[
literal|3
index|]
init|=
block|{
literal|"show"
block|,
name|sha1_to_hex
argument_list|(
name|note
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|retval
operator|=
name|execv_git_cmd
argument_list|(
name|show_args
argument_list|)
expr_stmt|;
block|}
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|merge_abort
specifier|static
name|int
name|merge_abort
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * Remove .git/NOTES_MERGE_PARTIAL and .git/NOTES_MERGE_REF, and call 	 * notes_merge_abort() to remove .git/NOTES_MERGE_WORKTREE. 	 */
if|if
condition|(
name|delete_ref
argument_list|(
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|ret
operator|+=
name|error
argument_list|(
literal|"Failed to delete ref NOTES_MERGE_PARTIAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_ref
argument_list|(
literal|"NOTES_MERGE_REF"
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|)
condition|)
name|ret
operator|+=
name|error
argument_list|(
literal|"Failed to delete ref NOTES_MERGE_REF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|notes_merge_abort
argument_list|(
name|o
argument_list|)
condition|)
name|ret
operator|+=
name|error
argument_list|(
literal|"Failed to remove 'git notes merge' worktree"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|merge_commit
specifier|static
name|int
name|merge_commit
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|,
name|parent_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|commit
modifier|*
name|partial
decl_stmt|;
name|struct
name|pretty_print_context
name|pretty_ctx
decl_stmt|;
name|void
modifier|*
name|local_ref_to_free
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Read partial merge result from .git/NOTES_MERGE_PARTIAL, 	 * and target notes ref from .git/NOTES_MERGE_REF. 	 */
if|if
condition|(
name|get_sha1
argument_list|(
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to read ref NOTES_MERGE_PARTIAL"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|partial
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"Could not find commit from NOTES_MERGE_PARTIAL."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_commit
argument_list|(
name|partial
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not parse commit from NOTES_MERGE_PARTIAL."
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial
operator|->
name|parents
condition|)
name|hashcpy
argument_list|(
name|parent_sha1
argument_list|,
name|partial
operator|->
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
else|else
name|hashclr
argument_list|(
name|parent_sha1
argument_list|)
expr_stmt|;
name|t
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_tree
argument_list|)
argument_list|)
expr_stmt|;
name|init_notes
argument_list|(
name|t
argument_list|,
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|combine_notes_overwrite
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|o
operator|->
name|local_ref
operator|=
name|local_ref_to_free
operator|=
name|resolve_refdup
argument_list|(
literal|"NOTES_MERGE_REF"
argument_list|,
literal|0
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|local_ref
condition|)
name|die
argument_list|(
literal|"Failed to resolve NOTES_MERGE_REF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|notes_merge_commit
argument_list|(
name|o
argument_list|,
name|t
argument_list|,
name|partial
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to finalize notes merge"
argument_list|)
expr_stmt|;
comment|/* Reuse existing commit message in reflog message */
name|memset
argument_list|(
operator|&
name|pretty_ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pretty_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|format_commit_message
argument_list|(
name|partial
argument_list|,
literal|"%s"
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|pretty_ctx
argument_list|)
expr_stmt|;
name|strbuf_trim
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
literal|"notes: "
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
name|o
operator|->
name|local_ref
argument_list|,
name|sha1
argument_list|,
name|is_null_sha1
argument_list|(
name|parent_sha1
argument_list|)
condition|?
name|NULL
else|:
name|parent_sha1
argument_list|,
literal|0
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|merge_abort
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|local_ref_to_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|merge
specifier|static
name|int
name|merge
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|strbuf
name|remote_ref
init|=
name|STRBUF_INIT
decl_stmt|,
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|result_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|notes_merge_options
name|o
decl_stmt|;
name|int
name|do_merge
init|=
literal|0
decl_stmt|,
name|do_commit
init|=
literal|0
decl_stmt|,
name|do_abort
init|=
literal|0
decl_stmt|;
name|int
name|verbosity
init|=
literal|0
decl_stmt|,
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|strategy
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"General options"
argument_list|)
argument_list|)
block|,
name|OPT__VERBOSITY
argument_list|(
operator|&
name|verbosity
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Merge options"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'s'
argument_list|,
literal|"strategy"
argument_list|,
operator|&
name|strategy
argument_list|,
name|N_
argument_list|(
literal|"strategy"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"resolve notes conflicts using the given strategy "
literal|"(manual/ours/theirs/union/cat_sort_uniq)"
argument_list|)
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Committing unmerged notes"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_SET_INT
block|,
literal|0
block|,
literal|"commit"
block|,
operator|&
name|do_commit
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"finalize notes merge by committing unmerged notes"
argument_list|)
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_NONEG
block|,
name|NULL
block|,
literal|1
block|}
block|,
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Aborting notes merge resolution"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_SET_INT
block|,
literal|0
block|,
literal|"abort"
block|,
operator|&
name|do_abort
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"abort notes merge"
argument_list|)
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_NONEG
block|,
name|NULL
block|,
literal|1
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_merge_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strategy
operator|||
name|do_commit
operator|+
name|do_abort
operator|==
literal|0
condition|)
name|do_merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|do_merge
operator|+
name|do_commit
operator|+
name|do_abort
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"cannot mix --commit, --abort or -s/--strategy"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_merge
operator|&&
name|argc
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Must specify a notes ref to merge"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|do_merge
operator|&&
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|init_notes_merge_options
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|verbosity
operator|=
name|verbosity
operator|+
name|NOTES_MERGE_VERBOSITY_DEFAULT
expr_stmt|;
if|if
condition|(
name|do_abort
condition|)
return|return
name|merge_abort
argument_list|(
operator|&
name|o
argument_list|)
return|;
if|if
condition|(
name|do_commit
condition|)
return|return
name|merge_commit
argument_list|(
operator|&
name|o
argument_list|)
return|;
name|o
operator|.
name|local_ref
operator|=
name|default_notes_ref
argument_list|()
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|remote_ref
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|expand_notes_ref
argument_list|(
operator|&
name|remote_ref
argument_list|)
expr_stmt|;
name|o
operator|.
name|remote_ref
operator|=
name|remote_ref
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|strategy
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"manual"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_MANUAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"ours"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_OURS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"theirs"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_THEIRS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"union"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_UNION
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"cat_sort_uniq"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_CAT_SORT_UNIQ
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"Unknown -s/--strategy: %s"
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"merge"
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"notes: Merged notes from %s into %s"
argument_list|,
name|remote_ref
operator|.
name|buf
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
operator|(
name|o
operator|.
name|commit_msg
operator|)
argument_list|,
name|msg
operator|.
name|buf
operator|+
literal|7
argument_list|,
name|msg
operator|.
name|len
operator|-
literal|7
argument_list|)
expr_stmt|;
comment|/* skip "notes: " */
name|result
operator|=
name|notes_merge
argument_list|(
operator|&
name|o
argument_list|,
name|t
argument_list|,
name|result_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
comment|/* Merge resulted (trivially) in result_sha1 */
comment|/* Update default notes ref with new commit */
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|,
name|result_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Merge has unresolved conflicts */
comment|/* Update .git/NOTES_MERGE_PARTIAL with partial merge result */
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|result_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|UPDATE_REFS_DIE_ON_ERR
argument_list|)
expr_stmt|;
comment|/* Store ref-to-be-updated into .git/NOTES_MERGE_REF */
if|if
condition|(
name|create_symref
argument_list|(
literal|"NOTES_MERGE_REF"
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to store link to current notes ref (%s)"
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Automatic notes merge failed. Fix conflicts in %s and "
literal|"commit the result with 'git notes merge --commit', or "
literal|"abort the merge with 'git notes merge --abort'.\n"
argument_list|,
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|remote_ref
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|result
operator|<
literal|0
return|;
comment|/* return non-zero on conflicts */
block|}
end_function
begin_define
DECL|macro|IGNORE_MISSING
define|#
directive|define
name|IGNORE_MISSING
value|1
end_define
begin_function
DECL|function|remove_one_note
specifier|static
name|int
name|remove_one_note
parameter_list|(
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|flag
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
name|status
operator|=
name|remove_note
argument_list|(
name|t
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Object %s has no note\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Removing note for object %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|flag
operator|&
name|IGNORE_MISSING
operator|)
condition|?
literal|0
else|:
name|status
return|;
block|}
end_function
begin_function
DECL|function|remove_cmd
specifier|static
name|int
name|remove_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|unsigned
name|flag
init|=
literal|0
decl_stmt|;
name|int
name|from_stdin
init|=
literal|0
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"ignore-missing"
argument_list|,
operator|&
name|flag
argument_list|,
name|N_
argument_list|(
literal|"attempt to remove non-existent note is not an error"
argument_list|)
argument_list|,
name|IGNORE_MISSING
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"stdin"
argument_list|,
operator|&
name|from_stdin
argument_list|,
name|N_
argument_list|(
literal|"read object names from the standard input"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_remove_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"remove"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argc
operator|&&
operator|!
name|from_stdin
condition|)
block|{
name|retval
operator|=
name|remove_one_note
argument_list|(
name|t
argument_list|,
literal|"HEAD"
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|argv
condition|)
block|{
name|retval
operator||=
name|remove_one_note
argument_list|(
name|t
argument_list|,
operator|*
name|argv
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_stdin
condition|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
while|while
condition|(
name|strbuf_getwholeline
argument_list|(
operator|&
name|sb
argument_list|,
name|stdin
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|strbuf_rtrim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|retval
operator||=
name|remove_one_note
argument_list|(
name|t
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retval
condition|)
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes removed by 'git notes remove'"
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|prune
specifier|static
name|int
name|prune
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|int
name|show_only
init|=
literal|0
decl_stmt|,
name|verbose
init|=
literal|0
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT__DRY_RUN
argument_list|(
operator|&
name|show_only
argument_list|,
literal|"do not remove, show only"
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|verbose
argument_list|,
literal|"report pruned notes"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_prune_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many parameters"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_prune_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"prune"
argument_list|)
expr_stmt|;
name|prune_notes
argument_list|(
name|t
argument_list|,
operator|(
name|verbose
condition|?
name|NOTES_PRUNE_VERBOSE
else|:
literal|0
operator|)
operator||
operator|(
name|show_only
condition|?
name|NOTES_PRUNE_VERBOSE
operator||
name|NOTES_PRUNE_DRYRUN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|show_only
condition|)
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes removed by 'git notes prune'"
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_ref
specifier|static
name|int
name|get_ref
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_get_ref_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_get_ref_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
name|default_notes_ref
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmd_notes
name|int
name|cmd_notes
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|override_notes_ref
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"ref"
argument_list|,
operator|&
name|override_notes_ref
argument_list|,
name|N_
argument_list|(
literal|"notes-ref"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"use notes from<notes_ref>"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_usage
argument_list|,
name|PARSE_OPT_STOP_AT_NON_OPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|override_notes_ref
condition|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|override_notes_ref
argument_list|)
expr_stmt|;
name|expand_notes_ref
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"GIT_NOTES_REF"
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|1
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"list"
argument_list|)
condition|)
name|result
operator|=
name|list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"add"
argument_list|)
condition|)
name|result
operator|=
name|add
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"copy"
argument_list|)
condition|)
name|result
operator|=
name|copy
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"append"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"edit"
argument_list|)
condition|)
name|result
operator|=
name|append_edit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"show"
argument_list|)
condition|)
name|result
operator|=
name|show
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"merge"
argument_list|)
condition|)
name|result
operator|=
name|merge
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"remove"
argument_list|)
condition|)
name|result
operator|=
name|remove_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"prune"
argument_list|)
condition|)
name|result
operator|=
name|prune
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"get-ref"
argument_list|)
condition|)
name|result
operator|=
name|get_ref
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"Unknown subcommand: %s"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
return|return
name|result
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
end_unit
