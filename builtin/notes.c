begin_unit
begin_comment
comment|/*  * Builtin "git notes"  *  * Copyright (c) 2010 Johan Herland<johan@herland.net>  *  * Based on git-notes.sh by Johannes Schindelin,  * and builtin-tag.c by Kristian HÃ¸gsberg and Carlos Rica.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"notes-merge.h"
end_include
begin_decl_stmt
DECL|variable|git_notes_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_usage
index|[]
init|=
block|{
literal|"git notes [--ref<notes_ref>] [list [<object>]]"
block|,
literal|"git notes [--ref<notes_ref>] add [-f] [-m<msg> | -F<file> | (-c | -C)<object>] [<object>]"
block|,
literal|"git notes [--ref<notes_ref>] copy [-f]<from-object><to-object>"
block|,
literal|"git notes [--ref<notes_ref>] append [-m<msg> | -F<file> | (-c | -C)<object>] [<object>]"
block|,
literal|"git notes [--ref<notes_ref>] edit [<object>]"
block|,
literal|"git notes [--ref<notes_ref>] show [<object>]"
block|,
literal|"git notes [--ref<notes_ref>] merge [-v | -q] [-s<strategy> ]<notes_ref>"
block|,
literal|"git notes merge --commit [-v | -q]"
block|,
literal|"git notes merge --abort [-v | -q]"
block|,
literal|"git notes [--ref<notes_ref>] remove [<object>]"
block|,
literal|"git notes [--ref<notes_ref>] prune [-n | -v]"
block|,
literal|"git notes [--ref<notes_ref>] get-ref"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_list_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_list_usage
index|[]
init|=
block|{
literal|"git notes [list [<object>]]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_add_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_add_usage
index|[]
init|=
block|{
literal|"git notes add [<options>] [<object>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_copy_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_copy_usage
index|[]
init|=
block|{
literal|"git notes copy [<options>]<from-object><to-object>"
block|,
literal|"git notes copy --stdin [<from-object><to-object>]..."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_append_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_append_usage
index|[]
init|=
block|{
literal|"git notes append [<options>] [<object>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_edit_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_edit_usage
index|[]
init|=
block|{
literal|"git notes edit [<object>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_show_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_show_usage
index|[]
init|=
block|{
literal|"git notes show [<object>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_merge_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_merge_usage
index|[]
init|=
block|{
literal|"git notes merge [<options>]<notes_ref>"
block|,
literal|"git notes merge --commit [<options>]"
block|,
literal|"git notes merge --abort [<options>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_remove_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_remove_usage
index|[]
init|=
block|{
literal|"git notes remove [<object>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_prune_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_prune_usage
index|[]
init|=
block|{
literal|"git notes prune [<options>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|git_notes_get_ref_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|git_notes_get_ref_usage
index|[]
init|=
block|{
literal|"git notes get-ref"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|note_template
specifier|static
specifier|const
name|char
name|note_template
index|[]
init|=
literal|"\n"
literal|"#\n"
literal|"# Write/edit the notes for the following object:\n"
literal|"#\n"
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|msg_arg
struct|struct
name|msg_arg
block|{
DECL|member|given
name|int
name|given
decl_stmt|;
DECL|member|use_editor
name|int
name|use_editor
decl_stmt|;
DECL|member|buf
name|struct
name|strbuf
name|buf
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|expand_notes_ref
specifier|static
name|void
name|expand_notes_ref
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
literal|"refs/notes/"
argument_list|)
condition|)
return|return;
comment|/* we're happy */
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
literal|"notes/"
argument_list|)
condition|)
name|strbuf_insert
argument_list|(
name|sb
argument_list|,
literal|0
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
else|else
name|strbuf_insert
argument_list|(
name|sb
argument_list|,
literal|0
argument_list|,
literal|"refs/notes/"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|list_each_note
specifier|static
name|int
name|list_each_note
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|object_sha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|note_sha1
parameter_list|,
name|char
modifier|*
name|note_path
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|note_sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|object_sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_note_data
specifier|static
name|void
name|write_note_data
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
if|if
condition|(
name|size
condition|)
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|write_commented_object
specifier|static
name|void
name|write_commented_object
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|object
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|show_args
index|[
literal|5
index|]
init|=
block|{
literal|"show"
block|,
literal|"--stat"
block|,
literal|"--no-notes"
block|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|child_process
name|show
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|FILE
modifier|*
name|show_out
decl_stmt|;
comment|/* Invoke "git show --stat --no-notes $object" */
name|memset
argument_list|(
operator|&
name|show
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
name|show
operator|.
name|argv
operator|=
name|show_args
expr_stmt|;
name|show
operator|.
name|no_stdin
operator|=
literal|1
expr_stmt|;
name|show
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|show
operator|.
name|err
operator|=
literal|0
expr_stmt|;
name|show
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|show
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to start 'show' for object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the output as FILE* so strbuf_getline() can be used. */
name|show_out
operator|=
name|xfdopen
argument_list|(
name|show
operator|.
name|out
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_out
operator|==
name|NULL
condition|)
name|die_errno
argument_list|(
literal|"can't fdopen 'show' output fd"
argument_list|)
expr_stmt|;
comment|/* Prepend "# " to each output line and write result to 'fd' */
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|buf
argument_list|,
name|show_out
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|write_or_die
argument_list|(
name|fd
argument_list|,
literal|"# "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
name|write_or_die
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|show_out
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"failed to close pipe to 'show' for object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|show
argument_list|)
condition|)
name|die
argument_list|(
literal|"failed to finish 'show' for object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|create_note
specifier|static
name|void
name|create_note
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|object
parameter_list|,
name|struct
name|msg_arg
modifier|*
name|msg
parameter_list|,
name|int
name|append_only
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|prev
parameter_list|,
name|unsigned
name|char
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|use_editor
operator|||
operator|!
name|msg
operator|->
name|given
condition|)
block|{
name|int
name|fd
decl_stmt|;
comment|/* write the template message before editing: */
name|path
operator|=
name|git_pathdup
argument_list|(
literal|"NOTES_EDITMSG"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"could not create file '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|given
condition|)
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|msg
operator|->
name|buf
operator|.
name|buf
argument_list|,
name|msg
operator|->
name|buf
operator|.
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prev
operator|&&
operator|!
name|append_only
condition|)
name|write_note_data
argument_list|(
name|fd
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|note_template
argument_list|,
name|strlen
argument_list|(
name|note_template
argument_list|)
argument_list|)
expr_stmt|;
name|write_commented_object
argument_list|(
name|fd
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|launch_editor
argument_list|(
name|path
argument_list|,
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|die
argument_list|(
literal|"Please supply the note contents using either -m"
expr|\
literal|" or -F option"
argument_list|)
expr_stmt|;
block|}
name|stripspace
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|&&
name|append_only
condition|)
block|{
comment|/* Append buf to previous note contents */
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
modifier|*
name|prev_buf
init|=
name|read_sha1_file
argument_list|(
name|prev
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|strbuf_grow
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|buf
operator|.
name|len
operator|&&
name|prev_buf
operator|&&
name|size
condition|)
name|strbuf_insert
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|0
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_buf
operator|&&
name|size
condition|)
name|strbuf_insert
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|0
argument_list|,
name|prev_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msg
operator|->
name|buf
operator|.
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removing note for object %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|write_sha1_file
argument_list|(
name|msg
operator|->
name|buf
operator|.
name|buf
argument_list|,
name|msg
operator|->
name|buf
operator|.
name|len
argument_list|,
name|blob_type
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"unable to write note object"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|error
argument_list|(
literal|"The note contents has been left in %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
condition|)
block|{
name|unlink_or_warn
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parse_msg_arg
specifier|static
name|int
name|parse_msg_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|msg_arg
modifier|*
name|msg
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|strbuf_grow
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|buf
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|stripspace
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg
operator|->
name|given
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_file_arg
specifier|static
name|int
name|parse_file_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|msg_arg
modifier|*
name|msg
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|buf
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"cannot read '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
name|arg
argument_list|,
literal|1024
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"could not open or read '%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|stripspace
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg
operator|->
name|given
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_reuse_arg
specifier|static
name|int
name|parse_reuse_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|msg_arg
modifier|*
name|msg
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|buf
operator|.
name|len
condition|)
name|strbuf_addch
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|arg
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|object
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|||
operator|!
name|len
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"Failed to read object '%s'."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
name|strbuf_add
argument_list|(
operator|&
operator|(
name|msg
operator|->
name|buf
operator|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|msg
operator|->
name|given
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_reedit_arg
specifier|static
name|int
name|parse_reedit_arg
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|msg_arg
modifier|*
name|msg
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|msg
operator|->
name|use_editor
operator|=
literal|1
expr_stmt|;
return|return
name|parse_reuse_arg
argument_list|(
name|opt
argument_list|,
name|arg
argument_list|,
name|unset
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|commit_notes
name|void
name|commit_notes
parameter_list|(
name|struct
name|notes_tree
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|commit_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
operator|&
name|default_notes_tree
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|initialized
operator|||
operator|!
name|t
operator|->
name|ref
operator|||
operator|!
operator|*
name|t
operator|->
name|ref
condition|)
name|die
argument_list|(
literal|"Cannot commit uninitialized/unreferenced notes tree"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|dirty
condition|)
return|return;
comment|/* don't have to commit an unchanged tree */
comment|/* Prepare commit message and reflog message */
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"notes: "
argument_list|)
expr_stmt|;
comment|/* commit message starts at index 7 */
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|buf
index|[
name|buf
operator|.
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Make sure msg ends with newline */
name|create_notes_commit
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|buf
operator|+
literal|7
argument_list|,
name|commit_sha1
argument_list|)
expr_stmt|;
name|update_ref
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|t
operator|->
name|ref
argument_list|,
name|commit_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_combine_notes_fn
name|combine_notes_fn
name|parse_combine_notes_fn
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|v
argument_list|,
literal|"overwrite"
argument_list|)
condition|)
return|return
name|combine_notes_overwrite
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|v
argument_list|,
literal|"ignore"
argument_list|)
condition|)
return|return
name|combine_notes_ignore
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|v
argument_list|,
literal|"concatenate"
argument_list|)
condition|)
return|return
name|combine_notes_concatenate
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|v
argument_list|,
literal|"cat_sort_uniq"
argument_list|)
condition|)
return|return
name|combine_notes_cat_sort_uniq
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|notes_rewrite_config
specifier|static
name|int
name|notes_rewrite_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|notes_rewrite_cfg
modifier|*
name|c
init|=
name|cb
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|k
argument_list|,
literal|"notes.rewrite."
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|k
operator|+
literal|14
argument_list|,
name|c
operator|->
name|cmd
argument_list|)
condition|)
block|{
name|c
operator|->
name|enabled
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|c
operator|->
name|mode_from_env
operator|&&
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"notes.rewritemode"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|v
condition|)
name|config_error_nonbool
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|c
operator|->
name|combine
operator|=
name|parse_combine_notes_fn
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|combine
condition|)
block|{
name|error
argument_list|(
literal|"Bad notes.rewriteMode value: '%s'"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|c
operator|->
name|refs_from_env
operator|&&
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"notes.rewriteref"
argument_list|)
condition|)
block|{
comment|/* note that a refs/ prefix is implied in the 		 * underlying for_each_glob_ref */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|v
argument_list|,
literal|"refs/notes/"
argument_list|)
condition|)
name|string_list_add_refs_by_glob
argument_list|(
name|c
operator|->
name|refs
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Refusing to rewrite notes in %s"
literal|" (outside of refs/notes/)"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|init_copy_notes_for_rewrite
name|struct
name|notes_rewrite_cfg
modifier|*
name|init_copy_notes_for_rewrite
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|notes_rewrite_cfg
modifier|*
name|c
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|notes_rewrite_cfg
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rewrite_mode_env
init|=
name|getenv
argument_list|(
name|GIT_NOTES_REWRITE_MODE_ENVIRONMENT
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rewrite_refs_env
init|=
name|getenv
argument_list|(
name|GIT_NOTES_REWRITE_REF_ENVIRONMENT
argument_list|)
decl_stmt|;
name|c
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|c
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|combine
operator|=
name|combine_notes_concatenate
expr_stmt|;
name|c
operator|->
name|refs
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|refs
operator|->
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|refs_from_env
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|mode_from_env
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rewrite_mode_env
condition|)
block|{
name|c
operator|->
name|mode_from_env
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|combine
operator|=
name|parse_combine_notes_fn
argument_list|(
name|rewrite_mode_env
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|combine
condition|)
name|error
argument_list|(
literal|"Bad "
name|GIT_NOTES_REWRITE_MODE_ENVIRONMENT
literal|" value: '%s'"
argument_list|,
name|rewrite_mode_env
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rewrite_refs_env
condition|)
block|{
name|c
operator|->
name|refs_from_env
operator|=
literal|1
expr_stmt|;
name|string_list_add_refs_from_colon_sep
argument_list|(
name|c
operator|->
name|refs
argument_list|,
name|rewrite_refs_env
argument_list|)
expr_stmt|;
block|}
name|git_config
argument_list|(
name|notes_rewrite_config
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|enabled
operator|||
operator|!
name|c
operator|->
name|refs
operator|->
name|nr
condition|)
block|{
name|string_list_clear
argument_list|(
name|c
operator|->
name|refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|refs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|->
name|trees
operator|=
name|load_notes_trees
argument_list|(
name|c
operator|->
name|refs
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
name|c
operator|->
name|refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|refs
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|copy_note_for_rewrite
name|int
name|copy_note_for_rewrite
parameter_list|(
name|struct
name|notes_rewrite_cfg
modifier|*
name|c
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from_obj
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|to_obj
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|trees
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ret
operator|=
name|copy_note
argument_list|(
name|c
operator|->
name|trees
index|[
name|i
index|]
argument_list|,
name|from_obj
argument_list|,
name|to_obj
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|combine
argument_list|)
operator|||
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|finish_copy_notes_for_rewrite
name|void
name|finish_copy_notes_for_rewrite
parameter_list|(
name|struct
name|notes_rewrite_cfg
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|trees
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|commit_notes
argument_list|(
name|c
operator|->
name|trees
index|[
name|i
index|]
argument_list|,
literal|"Notes added by 'git notes copy'"
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|c
operator|->
name|trees
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|c
operator|->
name|trees
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|notes_copy_from_stdin
name|int
name|notes_copy_from_stdin
parameter_list|(
name|int
name|force
parameter_list|,
specifier|const
name|char
modifier|*
name|rewrite_cmd
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|notes_rewrite_cfg
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rewrite_cmd
condition|)
block|{
name|c
operator|=
name|init_copy_notes_for_rewrite
argument_list|(
name|rewrite_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|init_notes
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|default_notes_tree
expr_stmt|;
block|}
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|buf
argument_list|,
name|stdin
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|unsigned
name|char
name|from_obj
index|[
literal|20
index|]
decl_stmt|,
name|to_obj
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
modifier|*
modifier|*
name|split
decl_stmt|;
name|int
name|err
decl_stmt|;
name|split
operator|=
name|strbuf_split
argument_list|(
operator|&
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|split
index|[
literal|0
index|]
operator|||
operator|!
name|split
index|[
literal|1
index|]
condition|)
name|die
argument_list|(
literal|"Malformed input line: '%s'."
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_rtrim
argument_list|(
name|split
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strbuf_rtrim
argument_list|(
name|split
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|split
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
name|from_obj
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|split
index|[
literal|0
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|split
index|[
literal|1
index|]
operator|->
name|buf
argument_list|,
name|to_obj
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|split
index|[
literal|1
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rewrite_cmd
condition|)
name|err
operator|=
name|copy_note_for_rewrite
argument_list|(
name|c
argument_list|,
name|from_obj
argument_list|,
name|to_obj
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|copy_note
argument_list|(
name|t
argument_list|,
name|from_obj
argument_list|,
name|to_obj
argument_list|,
name|force
argument_list|,
name|combine_notes_overwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"Failed to copy notes from '%s' to '%s'"
argument_list|,
name|split
index|[
literal|0
index|]
operator|->
name|buf
argument_list|,
name|split
index|[
literal|1
index|]
operator|->
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|strbuf_list_free
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rewrite_cmd
condition|)
block|{
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes added by 'git notes copy'"
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|finish_copy_notes_for_rewrite
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|init_notes_check
specifier|static
name|struct
name|notes_tree
modifier|*
name|init_notes_check
parameter_list|(
specifier|const
name|char
modifier|*
name|subcommand
parameter_list|)
block|{
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|init_notes
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|default_notes_tree
expr_stmt|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|t
operator|->
name|ref
argument_list|,
literal|"refs/notes/"
argument_list|)
condition|)
name|die
argument_list|(
literal|"Refusing to %s notes in %s (outside of refs/notes/)"
argument_list|,
name|subcommand
argument_list|,
name|t
operator|->
name|ref
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function
begin_function
DECL|function|list
specifier|static
name|int
name|list
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_END
argument_list|()
block|}
decl_stmt|;
if|if
condition|(
name|argc
condition|)
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_list_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_list_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
if|if
condition|(
name|get_sha1
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|puts
argument_list|(
name|sha1_to_hex
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|error
argument_list|(
literal|"No note found for object %s."
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|for_each_note
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|list_each_note
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|add
specifier|static
name|int
name|add
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|force
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|,
name|new_note
index|[
literal|20
index|]
decl_stmt|;
name|char
name|logmsg
index|[
literal|100
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|struct
name|msg_arg
name|msg
init|=
block|{
literal|0
block|,
literal|0
block|,
name|STRBUF_INIT
block|}
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|'m'
block|,
literal|"message"
block|,
operator|&
name|msg
block|,
literal|"MSG"
block|,
literal|"note contents as a string"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_msg_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'F'
block|,
literal|"file"
block|,
operator|&
name|msg
block|,
literal|"FILE"
block|,
literal|"note contents in a file"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_file_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'c'
block|,
literal|"reedit-message"
block|,
operator|&
name|msg
block|,
literal|"OBJECT"
block|,
literal|"reuse and edit specified note object"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reedit_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'C'
block|,
literal|"reuse-message"
block|,
operator|&
name|msg
block|,
literal|"OBJECT"
block|,
literal|"reuse specified note object"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reuse_arg
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'f'
argument_list|,
literal|"force"
argument_list|,
operator|&
name|force
argument_list|,
literal|"replace existing notes"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_add_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_add_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|object_ref
operator|=
name|argc
condition|?
name|argv
index|[
literal|0
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"add"
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|retval
operator|=
name|error
argument_list|(
literal|"Cannot add notes. Found existing notes "
literal|"for object %s. Use '-f' to overwrite "
literal|"existing notes"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Overwriting existing notes for object %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|create_note
argument_list|(
name|object
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
name|note
argument_list|,
name|new_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|new_note
argument_list|)
condition|)
name|remove_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|,
name|new_note
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|logmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|logmsg
argument_list|)
argument_list|,
literal|"Notes %s by 'git notes %s'"
argument_list|,
name|is_null_sha1
argument_list|(
name|new_note
argument_list|)
condition|?
literal|"removed"
else|:
literal|"added"
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
name|commit_notes
argument_list|(
name|t
argument_list|,
name|logmsg
argument_list|)
expr_stmt|;
name|out
label|:
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
operator|(
name|msg
operator|.
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|copy
specifier|static
name|int
name|copy
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|force
init|=
literal|0
decl_stmt|,
name|from_stdin
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|from_note
decl_stmt|,
modifier|*
name|note
decl_stmt|;
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|,
name|from_obj
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|rewrite_cmd
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_BOOLEAN
argument_list|(
literal|'f'
argument_list|,
literal|"force"
argument_list|,
operator|&
name|force
argument_list|,
literal|"replace existing notes"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"stdin"
argument_list|,
operator|&
name|from_stdin
argument_list|,
literal|"read objects from stdin"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"for-rewrite"
argument_list|,
operator|&
name|rewrite_cmd
argument_list|,
literal|"command"
argument_list|,
literal|"load rewriting config for<command> (implies "
literal|"--stdin)"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_copy_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_stdin
operator|||
name|rewrite_cmd
condition|)
block|{
if|if
condition|(
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_copy_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|notes_copy_from_stdin
argument_list|(
name|force
argument_list|,
name|rewrite_cmd
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"too few parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_copy_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|2
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_copy_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_sha1
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|from_obj
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|object_ref
operator|=
literal|1
operator|<
name|argc
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|retval
operator|=
name|error
argument_list|(
literal|"Cannot copy notes. Found existing "
literal|"notes for object %s. Use '-f' to "
literal|"overwrite existing notes"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Overwriting existing notes for object %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|from_note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|from_obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_note
condition|)
block|{
name|retval
operator|=
name|error
argument_list|(
literal|"Missing notes on source object %s. Cannot "
literal|"copy."
argument_list|,
name|sha1_to_hex
argument_list|(
name|from_obj
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|,
name|from_note
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes added by 'git notes copy'"
argument_list|)
expr_stmt|;
name|out
label|:
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|append_edit
specifier|static
name|int
name|append_edit
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|,
name|new_note
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|char
name|logmsg
index|[
literal|100
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|usage
decl_stmt|;
name|struct
name|msg_arg
name|msg
init|=
block|{
literal|0
block|,
literal|0
block|,
name|STRBUF_INIT
block|}
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|'m'
block|,
literal|"message"
block|,
operator|&
name|msg
block|,
literal|"MSG"
block|,
literal|"note contents as a string"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_msg_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'F'
block|,
literal|"file"
block|,
operator|&
name|msg
block|,
literal|"FILE"
block|,
literal|"note contents in a file"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_file_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'c'
block|,
literal|"reedit-message"
block|,
operator|&
name|msg
block|,
literal|"OBJECT"
block|,
literal|"reuse and edit specified note object"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reedit_arg
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'C'
block|,
literal|"reuse-message"
block|,
operator|&
name|msg
block|,
literal|"OBJECT"
block|,
literal|"reuse specified note object"
block|,
name|PARSE_OPT_NONEG
block|,
name|parse_reuse_arg
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|int
name|edit
init|=
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"edit"
argument_list|)
decl_stmt|;
name|usage
operator|=
name|edit
condition|?
name|git_notes_edit_usage
else|:
name|git_notes_append_usage
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|usage
argument_list|,
name|PARSE_OPT_KEEP_ARGV0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|2
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|.
name|given
operator|&&
name|edit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The -m/-F/-c/-C options have been deprecated "
literal|"for the 'edit' subcommand.\n"
literal|"Please use 'git notes add -f -m/-F/-c/-C' instead.\n"
argument_list|)
expr_stmt|;
name|object_ref
operator|=
literal|1
operator|<
name|argc
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|create_note
argument_list|(
name|object
argument_list|,
operator|&
name|msg
argument_list|,
operator|!
name|edit
argument_list|,
name|note
argument_list|,
name|new_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|new_note
argument_list|)
condition|)
name|remove_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|add_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|,
name|new_note
argument_list|,
name|combine_notes_overwrite
argument_list|)
condition|)
name|die
argument_list|(
literal|"BUG: combine_notes_overwrite failed"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|logmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|logmsg
argument_list|)
argument_list|,
literal|"Notes %s by 'git notes %s'"
argument_list|,
name|is_null_sha1
argument_list|(
name|new_note
argument_list|)
condition|?
literal|"removed"
else|:
literal|"added"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|commit_notes
argument_list|(
name|t
argument_list|,
name|logmsg
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
operator|(
name|msg
operator|.
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|show
specifier|static
name|int
name|show
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|note
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_show_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_show_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|object_ref
operator|=
name|argc
condition|?
name|argv
index|[
literal|0
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"show"
argument_list|)
expr_stmt|;
name|note
operator|=
name|get_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
name|retval
operator|=
name|error
argument_list|(
literal|"No note found for object %s."
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|show_args
index|[
literal|3
index|]
init|=
block|{
literal|"show"
block|,
name|sha1_to_hex
argument_list|(
name|note
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|retval
operator|=
name|execv_git_cmd
argument_list|(
name|show_args
argument_list|)
expr_stmt|;
block|}
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|merge_abort
specifier|static
name|int
name|merge_abort
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * Remove .git/NOTES_MERGE_PARTIAL and .git/NOTES_MERGE_REF, and call 	 * notes_merge_abort() to remove .git/NOTES_MERGE_WORKTREE. 	 */
if|if
condition|(
name|delete_ref
argument_list|(
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|ret
operator|+=
name|error
argument_list|(
literal|"Failed to delete ref NOTES_MERGE_PARTIAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_ref
argument_list|(
literal|"NOTES_MERGE_REF"
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|)
condition|)
name|ret
operator|+=
name|error
argument_list|(
literal|"Failed to delete ref NOTES_MERGE_REF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|notes_merge_abort
argument_list|(
name|o
argument_list|)
condition|)
name|ret
operator|+=
name|error
argument_list|(
literal|"Failed to remove 'git notes merge' worktree"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|merge_commit
specifier|static
name|int
name|merge_commit
parameter_list|(
name|struct
name|notes_merge_options
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|,
name|parent_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|commit
modifier|*
name|partial
decl_stmt|;
name|struct
name|pretty_print_context
name|pretty_ctx
decl_stmt|;
comment|/* 	 * Read partial merge result from .git/NOTES_MERGE_PARTIAL, 	 * and target notes ref from .git/NOTES_MERGE_REF. 	 */
if|if
condition|(
name|get_sha1
argument_list|(
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to read ref NOTES_MERGE_PARTIAL"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|partial
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"Could not find commit from NOTES_MERGE_PARTIAL."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_commit
argument_list|(
name|partial
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not parse commit from NOTES_MERGE_PARTIAL."
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial
operator|->
name|parents
condition|)
name|hashcpy
argument_list|(
name|parent_sha1
argument_list|,
name|partial
operator|->
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
else|else
name|hashclr
argument_list|(
name|parent_sha1
argument_list|)
expr_stmt|;
name|t
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|notes_tree
argument_list|)
argument_list|)
expr_stmt|;
name|init_notes
argument_list|(
name|t
argument_list|,
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|combine_notes_overwrite
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|o
operator|->
name|local_ref
operator|=
name|resolve_ref
argument_list|(
literal|"NOTES_MERGE_REF"
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|local_ref
condition|)
name|die
argument_list|(
literal|"Failed to resolve NOTES_MERGE_REF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|notes_merge_commit
argument_list|(
name|o
argument_list|,
name|t
argument_list|,
name|partial
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to finalize notes merge"
argument_list|)
expr_stmt|;
comment|/* Reuse existing commit message in reflog message */
name|memset
argument_list|(
operator|&
name|pretty_ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pretty_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|format_commit_message
argument_list|(
name|partial
argument_list|,
literal|"%s"
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|pretty_ctx
argument_list|)
expr_stmt|;
name|strbuf_trim
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
literal|"notes: "
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
name|o
operator|->
name|local_ref
argument_list|,
name|sha1
argument_list|,
name|is_null_sha1
argument_list|(
name|parent_sha1
argument_list|)
condition|?
name|NULL
else|:
name|parent_sha1
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|merge_abort
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|merge
specifier|static
name|int
name|merge
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|strbuf
name|remote_ref
init|=
name|STRBUF_INIT
decl_stmt|,
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|result_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|notes_merge_options
name|o
decl_stmt|;
name|int
name|do_merge
init|=
literal|0
decl_stmt|,
name|do_commit
init|=
literal|0
decl_stmt|,
name|do_abort
init|=
literal|0
decl_stmt|;
name|int
name|verbosity
init|=
literal|0
decl_stmt|,
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|strategy
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_GROUP
argument_list|(
literal|"General options"
argument_list|)
block|,
name|OPT__VERBOSITY
argument_list|(
operator|&
name|verbosity
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
literal|"Merge options"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'s'
argument_list|,
literal|"strategy"
argument_list|,
operator|&
name|strategy
argument_list|,
literal|"strategy"
argument_list|,
literal|"resolve notes conflicts using the given strategy "
literal|"(manual/ours/theirs/union/cat_sort_uniq)"
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
literal|"Committing unmerged notes"
argument_list|)
block|,
block|{
name|OPTION_BOOLEAN
block|,
literal|0
block|,
literal|"commit"
block|,
operator|&
name|do_commit
block|,
name|NULL
block|,
literal|"finalize notes merge by committing unmerged notes"
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_NONEG
block|}
block|,
name|OPT_GROUP
argument_list|(
literal|"Aborting notes merge resolution"
argument_list|)
block|,
block|{
name|OPTION_BOOLEAN
block|,
literal|0
block|,
literal|"abort"
block|,
operator|&
name|do_abort
block|,
name|NULL
block|,
literal|"abort notes merge"
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_NONEG
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_merge_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strategy
operator|||
name|do_commit
operator|+
name|do_abort
operator|==
literal|0
condition|)
name|do_merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|do_merge
operator|+
name|do_commit
operator|+
name|do_abort
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"cannot mix --commit, --abort or -s/--strategy"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_merge
operator|&&
name|argc
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Must specify a notes ref to merge"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|do_merge
operator|&&
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|init_notes_merge_options
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|verbosity
operator|=
name|verbosity
operator|+
name|NOTES_MERGE_VERBOSITY_DEFAULT
expr_stmt|;
if|if
condition|(
name|do_abort
condition|)
return|return
name|merge_abort
argument_list|(
operator|&
name|o
argument_list|)
return|;
if|if
condition|(
name|do_commit
condition|)
return|return
name|merge_commit
argument_list|(
operator|&
name|o
argument_list|)
return|;
name|o
operator|.
name|local_ref
operator|=
name|default_notes_ref
argument_list|()
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|remote_ref
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|expand_notes_ref
argument_list|(
operator|&
name|remote_ref
argument_list|)
expr_stmt|;
name|o
operator|.
name|remote_ref
operator|=
name|remote_ref
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|strategy
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"manual"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_MANUAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"ours"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_OURS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"theirs"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_THEIRS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"union"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_UNION
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"cat_sort_uniq"
argument_list|)
condition|)
name|o
operator|.
name|strategy
operator|=
name|NOTES_MERGE_RESOLVE_CAT_SORT_UNIQ
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"Unknown -s/--strategy: %s"
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_merge_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"merge"
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"notes: Merged notes from %s into %s"
argument_list|,
name|remote_ref
operator|.
name|buf
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
operator|(
name|o
operator|.
name|commit_msg
operator|)
argument_list|,
name|msg
operator|.
name|buf
operator|+
literal|7
argument_list|,
name|msg
operator|.
name|len
operator|-
literal|7
argument_list|)
expr_stmt|;
comment|/* skip "notes: " */
name|result
operator|=
name|notes_merge
argument_list|(
operator|&
name|o
argument_list|,
name|t
argument_list|,
name|result_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
comment|/* Merge resulted (trivially) in result_sha1 */
comment|/* Update default notes ref with new commit */
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|,
name|result_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Merge has unresolved conflicts */
comment|/* Update .git/NOTES_MERGE_PARTIAL with partial merge result */
name|update_ref
argument_list|(
name|msg
operator|.
name|buf
argument_list|,
literal|"NOTES_MERGE_PARTIAL"
argument_list|,
name|result_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
comment|/* Store ref-to-be-updated into .git/NOTES_MERGE_REF */
if|if
condition|(
name|create_symref
argument_list|(
literal|"NOTES_MERGE_REF"
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to store link to current notes ref (%s)"
argument_list|,
name|default_notes_ref
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Automatic notes merge failed. Fix conflicts in %s and "
literal|"commit the result with 'git notes merge --commit', or "
literal|"abort the merge with 'git notes merge --abort'.\n"
argument_list|,
name|git_path
argument_list|(
name|NOTES_MERGE_WORKTREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|remote_ref
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|result
operator|<
literal|0
return|;
comment|/* return non-zero on conflicts */
block|}
end_function
begin_function
DECL|function|remove_cmd
specifier|static
name|int
name|remove_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_END
argument_list|()
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|object_ref
decl_stmt|;
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
name|object
index|[
literal|20
index|]
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_remove_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_remove_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|object_ref
operator|=
name|argc
condition|?
name|argv
index|[
literal|0
index|]
else|:
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|object_ref
argument_list|,
name|object
argument_list|)
condition|)
name|die
argument_list|(
literal|"Failed to resolve '%s' as a valid ref."
argument_list|,
name|object_ref
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"remove"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Removing note for object %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|t
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes removed by 'git notes remove'"
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|prune
specifier|static
name|int
name|prune
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|notes_tree
modifier|*
name|t
decl_stmt|;
name|int
name|show_only
init|=
literal|0
decl_stmt|,
name|verbose
init|=
literal|0
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_BOOLEAN
argument_list|(
literal|'n'
argument_list|,
literal|"dry-run"
argument_list|,
operator|&
name|show_only
argument_list|,
literal|"do not remove, show only"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'v'
argument_list|,
literal|"verbose"
argument_list|,
operator|&
name|verbose
argument_list|,
literal|"report pruned notes"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_prune_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_prune_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|init_notes_check
argument_list|(
literal|"prune"
argument_list|)
expr_stmt|;
name|prune_notes
argument_list|(
name|t
argument_list|,
operator|(
name|verbose
condition|?
name|NOTES_PRUNE_VERBOSE
else|:
literal|0
operator|)
operator||
operator|(
name|show_only
condition|?
name|NOTES_PRUNE_VERBOSE
operator||
name|NOTES_PRUNE_DRYRUN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|show_only
condition|)
name|commit_notes
argument_list|(
name|t
argument_list|,
literal|"Notes removed by 'git notes prune'"
argument_list|)
expr_stmt|;
name|free_notes
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_ref
specifier|static
name|int
name|get_ref
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_get_ref_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_get_ref_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
name|default_notes_ref
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmd_notes
name|int
name|cmd_notes
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|override_notes_ref
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"ref"
argument_list|,
operator|&
name|override_notes_ref
argument_list|,
literal|"notes_ref"
argument_list|,
literal|"use notes from<notes_ref>"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|git_notes_usage
argument_list|,
name|PARSE_OPT_STOP_AT_NON_OPTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|override_notes_ref
condition|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|override_notes_ref
argument_list|)
expr_stmt|;
name|expand_notes_ref
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"GIT_NOTES_REF"
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|1
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"list"
argument_list|)
condition|)
name|result
operator|=
name|list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"add"
argument_list|)
condition|)
name|result
operator|=
name|add
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"copy"
argument_list|)
condition|)
name|result
operator|=
name|copy
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"append"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"edit"
argument_list|)
condition|)
name|result
operator|=
name|append_edit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"show"
argument_list|)
condition|)
name|result
operator|=
name|show
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"merge"
argument_list|)
condition|)
name|result
operator|=
name|merge
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"remove"
argument_list|)
condition|)
name|result
operator|=
name|remove_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"prune"
argument_list|)
condition|)
name|result
operator|=
name|prune
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"get-ref"
argument_list|)
condition|)
name|result
operator|=
name|get_ref
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|=
name|error
argument_list|(
literal|"Unknown subcommand: %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|git_notes_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
return|return
name|result
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
end_unit
