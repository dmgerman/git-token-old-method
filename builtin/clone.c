begin_unit
begin_comment
comment|/*  * Builtin "git clone"  *  * Copyright (c) 2007 Kristian HÃ¸gsberg<krh@redhat.com>,  *		 2008 Daniel Barkalow<barkalow@iabervon.org>  * Based on git-commit.sh by Junio C Hamano and Linus Torvalds  *  * Clone a repository into a different directory that does not yet exist.  */
end_comment
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"fetch-pack.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"transport.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"sigchain.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"connected.h"
end_include
begin_comment
comment|/*  * Overall FIXMEs:  *  - respect DB_ENVIRONMENT for .git/objects.  *  * Implementation notes:  *  - dropping use-separate-remote and no-separate-remote compatibility  *  */
end_comment
begin_decl_stmt
DECL|variable|builtin_clone_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_clone_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git clone [options] [--]<repo> [<dir>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_no_checkout
DECL|variable|option_bare
DECL|variable|option_mirror
DECL|variable|option_single_branch
specifier|static
name|int
name|option_no_checkout
decl_stmt|,
name|option_bare
decl_stmt|,
name|option_mirror
decl_stmt|,
name|option_single_branch
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_local
DECL|variable|option_no_hardlinks
DECL|variable|option_shared
DECL|variable|option_recursive
specifier|static
name|int
name|option_local
init|=
operator|-
literal|1
decl_stmt|,
name|option_no_hardlinks
decl_stmt|,
name|option_shared
decl_stmt|,
name|option_recursive
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_template
DECL|variable|option_depth
specifier|static
name|char
modifier|*
name|option_template
decl_stmt|,
modifier|*
name|option_depth
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_origin
specifier|static
name|char
modifier|*
name|option_origin
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_branch
specifier|static
name|char
modifier|*
name|option_branch
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|real_git_dir
specifier|static
specifier|const
name|char
modifier|*
name|real_git_dir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_upload_pack
specifier|static
name|char
modifier|*
name|option_upload_pack
init|=
literal|"git-upload-pack"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_verbosity
specifier|static
name|int
name|option_verbosity
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_progress
specifier|static
name|int
name|option_progress
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_config
specifier|static
name|struct
name|string_list
name|option_config
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_reference
specifier|static
name|struct
name|string_list
name|option_reference
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|opt_parse_reference
specifier|static
name|int
name|opt_parse_reference
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|option_reference
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
operator|-
literal|1
return|;
name|string_list_append
argument_list|(
name|option_reference
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|builtin_clone_options
specifier|static
name|struct
name|option
name|builtin_clone_options
index|[]
init|=
block|{
name|OPT__VERBOSITY
argument_list|(
operator|&
name|option_verbosity
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"progress"
argument_list|,
operator|&
name|option_progress
argument_list|,
name|N_
argument_list|(
literal|"force progress reporting"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'n'
argument_list|,
literal|"no-checkout"
argument_list|,
operator|&
name|option_no_checkout
argument_list|,
name|N_
argument_list|(
literal|"don't create a checkout"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"bare"
argument_list|,
operator|&
name|option_bare
argument_list|,
name|N_
argument_list|(
literal|"create a bare repository"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_BOOLEAN
block|,
literal|0
block|,
literal|"naked"
block|,
operator|&
name|option_bare
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"create a bare repository"
argument_list|)
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_HIDDEN
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"mirror"
argument_list|,
operator|&
name|option_mirror
argument_list|,
name|N_
argument_list|(
literal|"create a mirror repository (implies bare)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'l'
argument_list|,
literal|"local"
argument_list|,
operator|&
name|option_local
argument_list|,
name|N_
argument_list|(
literal|"to clone from a local repository"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"no-hardlinks"
argument_list|,
operator|&
name|option_no_hardlinks
argument_list|,
name|N_
argument_list|(
literal|"don't use local hardlinks, always copy"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'s'
argument_list|,
literal|"shared"
argument_list|,
operator|&
name|option_shared
argument_list|,
name|N_
argument_list|(
literal|"setup as shared repository"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"recursive"
argument_list|,
operator|&
name|option_recursive
argument_list|,
name|N_
argument_list|(
literal|"initialize submodules in the clone"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"recurse-submodules"
argument_list|,
operator|&
name|option_recursive
argument_list|,
name|N_
argument_list|(
literal|"initialize submodules in the clone"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"template"
argument_list|,
operator|&
name|option_template
argument_list|,
name|N_
argument_list|(
literal|"template-directory"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"directory from which templates will be used"
argument_list|)
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|0
argument_list|,
literal|"reference"
argument_list|,
operator|&
name|option_reference
argument_list|,
name|N_
argument_list|(
literal|"repo"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"reference repository"
argument_list|)
argument_list|,
operator|&
name|opt_parse_reference
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'o'
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|option_origin
argument_list|,
name|N_
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"use<name> instead of 'origin' to track upstream"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'b'
argument_list|,
literal|"branch"
argument_list|,
operator|&
name|option_branch
argument_list|,
name|N_
argument_list|(
literal|"branch"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"checkout<branch> instead of the remote's HEAD"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'u'
argument_list|,
literal|"upload-pack"
argument_list|,
operator|&
name|option_upload_pack
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"path to git-upload-pack on the remote"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"depth"
argument_list|,
operator|&
name|option_depth
argument_list|,
name|N_
argument_list|(
literal|"depth"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"create a shallow clone of that depth"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"single-branch"
argument_list|,
operator|&
name|option_single_branch
argument_list|,
name|N_
argument_list|(
literal|"clone only one branch, HEAD or --branch"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"separate-git-dir"
argument_list|,
operator|&
name|real_git_dir
argument_list|,
name|N_
argument_list|(
literal|"gitdir"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"separate git dir from working tree"
argument_list|)
argument_list|)
block|,
name|OPT_STRING_LIST
argument_list|(
literal|'c'
argument_list|,
literal|"config"
argument_list|,
operator|&
name|option_config
argument_list|,
name|N_
argument_list|(
literal|"key=value"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"set config inside the new repository"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|argv_submodule
specifier|static
specifier|const
name|char
modifier|*
name|argv_submodule
index|[]
init|=
block|{
literal|"submodule"
block|,
literal|"update"
block|,
literal|"--init"
block|,
literal|"--recursive"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_repo_path
specifier|static
name|char
modifier|*
name|get_repo_path
parameter_list|(
specifier|const
name|char
modifier|*
name|repo
parameter_list|,
name|int
modifier|*
name|is_bundle
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|suffix
index|[]
init|=
block|{
literal|"/.git"
block|,
literal|""
block|,
literal|".git/.git"
block|,
literal|".git"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bundle_suffix
index|[]
init|=
block|{
literal|".bundle"
block|,
literal|""
block|}
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|suffix
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|mkpath
argument_list|(
literal|"%s%s"
argument_list|,
name|repo
argument_list|,
name|suffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|is_git_directory
argument_list|(
name|path
argument_list|)
condition|)
block|{
operator|*
name|is_bundle
operator|=
literal|0
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|st
operator|.
name|st_size
operator|>
literal|8
condition|)
block|{
comment|/* Is it a "gitfile"? */
name|char
name|signature
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|fd
init|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
name|len
operator|=
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|signature
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|8
operator|||
name|strncmp
argument_list|(
name|signature
argument_list|,
literal|"gitdir: "
argument_list|,
literal|8
argument_list|)
condition|)
continue|continue;
name|path
operator|=
name|read_gitfile
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
operator|*
name|is_bundle
operator|=
literal|0
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bundle_suffix
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|mkpath
argument_list|(
literal|"%s%s"
argument_list|,
name|repo
argument_list|,
name|bundle_suffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|*
name|is_bundle
operator|=
literal|1
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|guess_dir_name
specifier|static
name|char
modifier|*
name|guess_dir_name
parameter_list|(
specifier|const
name|char
modifier|*
name|repo
parameter_list|,
name|int
name|is_bundle
parameter_list|,
name|int
name|is_bare
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|repo
operator|+
name|strlen
argument_list|(
name|repo
argument_list|)
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* 	 * Strip trailing spaces, slashes and /.git 	 */
while|while
condition|(
name|repo
operator|<
name|end
operator|&&
operator|(
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isspace
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|end
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|repo
operator|>
literal|5
operator|&&
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|5
index|]
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|end
operator|-
literal|4
argument_list|,
literal|".git"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|end
operator|-=
literal|5
expr_stmt|;
while|while
condition|(
name|repo
operator|<
name|end
operator|&&
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|end
operator|--
expr_stmt|;
block|}
comment|/* 	 * Find last component, but be prepared that repo could have 	 * the form  "remote.example.com:foo.git", i.e. no slash 	 * in the directory part. 	 */
name|start
operator|=
name|end
expr_stmt|;
while|while
condition|(
name|repo
operator|<
name|start
operator|&&
operator|!
name|is_dir_sep
argument_list|(
name|start
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|start
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
name|start
operator|--
expr_stmt|;
comment|/* 	 * Strip .{bundle,git}. 	 */
if|if
condition|(
name|is_bundle
condition|)
block|{
if|if
condition|(
name|end
operator|-
name|start
operator|>
literal|7
operator|&&
operator|!
name|strncmp
argument_list|(
name|end
operator|-
literal|7
argument_list|,
literal|".bundle"
argument_list|,
literal|7
argument_list|)
condition|)
name|end
operator|-=
literal|7
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end
operator|-
name|start
operator|>
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|end
operator|-
literal|4
argument_list|,
literal|".git"
argument_list|,
literal|4
argument_list|)
condition|)
name|end
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|is_bare
condition|)
block|{
name|struct
name|strbuf
name|result
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|result
argument_list|,
literal|"%.*s.git"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|dir
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|dir
operator|=
name|xstrndup
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * Replace sequences of 'control' characters and whitespace 	 * with one ascii space, remove leading and trailing spaces. 	 */
if|if
condition|(
operator|*
name|dir
condition|)
block|{
name|char
modifier|*
name|out
init|=
name|dir
decl_stmt|;
name|int
name|prev_space
init|=
literal|1
comment|/* strip leading whitespace */
decl_stmt|;
for|for
control|(
name|end
operator|=
name|dir
init|;
operator|*
name|end
condition|;
operator|++
name|end
control|)
block|{
name|char
name|ch
init|=
operator|*
name|end
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|ch
operator|<
literal|'\x20'
condition|)
name|ch
operator|=
literal|'\x20'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev_space
condition|)
continue|continue;
name|prev_space
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev_space
operator|=
literal|0
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|out
operator|>
name|dir
operator|&&
name|prev_space
condition|)
name|out
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|dir
return|;
block|}
end_function
begin_function
DECL|function|strip_trailing_slashes
specifier|static
name|void
name|strip_trailing_slashes
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
decl_stmt|;
while|while
condition|(
name|dir
operator|<
name|end
operator|-
literal|1
operator|&&
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|end
operator|--
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_one_reference
specifier|static
name|int
name|add_one_reference
parameter_list|(
name|struct
name|string_list_item
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|char
modifier|*
name|ref_git
decl_stmt|;
specifier|const
name|char
modifier|*
name|repo
decl_stmt|;
name|struct
name|strbuf
name|alternate
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* Beware: read_gitfile(), real_path() and mkpath() return static buffer */
name|ref_git
operator|=
name|xstrdup
argument_list|(
name|real_path
argument_list|(
name|item
operator|->
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|repo
operator|=
name|read_gitfile
argument_list|(
name|ref_git
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repo
condition|)
name|repo
operator|=
name|read_gitfile
argument_list|(
name|mkpath
argument_list|(
literal|"%s/.git"
argument_list|,
name|ref_git
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repo
condition|)
block|{
name|free
argument_list|(
name|ref_git
argument_list|)
expr_stmt|;
name|ref_git
operator|=
name|xstrdup
argument_list|(
name|repo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|repo
operator|&&
name|is_directory
argument_list|(
name|mkpath
argument_list|(
literal|"%s/.git/objects"
argument_list|,
name|ref_git
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ref_git_git
init|=
name|mkpathdup
argument_list|(
literal|"%s/.git"
argument_list|,
name|ref_git
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|ref_git
argument_list|)
expr_stmt|;
name|ref_git
operator|=
name|ref_git_git
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_directory
argument_list|(
name|mkpath
argument_list|(
literal|"%s/objects"
argument_list|,
name|ref_git
argument_list|)
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"reference repository '%s' is not a local repository."
argument_list|)
argument_list|,
name|item
operator|->
name|string
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|alternate
argument_list|,
literal|"%s/objects"
argument_list|,
name|ref_git
argument_list|)
expr_stmt|;
name|add_to_alternates_file
argument_list|(
name|alternate
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|alternate
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_git
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|setup_reference
specifier|static
name|void
name|setup_reference
parameter_list|(
name|void
parameter_list|)
block|{
name|for_each_string_list
argument_list|(
operator|&
name|option_reference
argument_list|,
name|add_one_reference
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|copy_alternates
specifier|static
name|void
name|copy_alternates
parameter_list|(
name|struct
name|strbuf
modifier|*
name|src
parameter_list|,
name|struct
name|strbuf
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src_repo
parameter_list|)
block|{
comment|/* 	 * Read from the source objects/info/alternates file 	 * and copy the entries to corresponding file in the 	 * destination repository with add_to_alternates_file(). 	 * Both src and dst have "$path/objects/info/alternates". 	 * 	 * Instead of copying bit-for-bit from the original, 	 * we need to append to existing one so that the already 	 * created entry via "clone -s" is not lost, and also 	 * to turn entries with paths relative to the original 	 * absolute, so that they can be used in the new repository. 	 */
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|src
operator|->
name|buf
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|line
init|=
name|STRBUF_INIT
decl_stmt|;
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|line
argument_list|,
name|in
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|abs_path
decl_stmt|,
name|abs_buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|len
operator|||
name|line
operator|.
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|is_absolute_path
argument_list|(
name|line
operator|.
name|buf
argument_list|)
condition|)
block|{
name|add_to_alternates_file
argument_list|(
name|line
operator|.
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|abs_path
operator|=
name|mkpath
argument_list|(
literal|"%s/objects/%s"
argument_list|,
name|src_repo
argument_list|,
name|line
operator|.
name|buf
argument_list|)
expr_stmt|;
name|normalize_path_copy
argument_list|(
name|abs_buf
argument_list|,
name|abs_path
argument_list|)
expr_stmt|;
name|add_to_alternates_file
argument_list|(
name|abs_buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|copy_or_link_directory
specifier|static
name|void
name|copy_or_link_directory
parameter_list|(
name|struct
name|strbuf
modifier|*
name|src
parameter_list|,
name|struct
name|strbuf
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src_repo
parameter_list|,
name|int
name|src_baselen
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|src_len
decl_stmt|,
name|dest_len
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|src
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to open '%s'"
argument_list|)
argument_list|,
name|src
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|dest
operator|->
name|buf
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to create directory '%s'"
argument_list|)
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|dest
operator|->
name|buf
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to stat '%s'"
argument_list|)
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"%s exists and is not a directory"
argument_list|)
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|src
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|src_len
operator|=
name|src
operator|->
name|len
expr_stmt|;
name|strbuf_addch
argument_list|(
name|dest
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|dest_len
operator|=
name|dest
operator|->
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strbuf_setlen
argument_list|(
name|src
argument_list|,
name|src_len
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|src
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|dest
argument_list|,
name|dest_len
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|dest
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|src
operator|->
name|buf
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"failed to stat %s\n"
argument_list|)
argument_list|,
name|src
operator|->
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|de
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
name|copy_or_link_directory
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|src_repo
argument_list|,
name|src_baselen
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Files that cannot be copied bit-for-bit... */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|src
operator|->
name|buf
operator|+
name|src_baselen
argument_list|,
literal|"/info/alternates"
argument_list|)
condition|)
block|{
name|copy_alternates
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|src_repo
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|dest
operator|->
name|buf
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to unlink '%s'"
argument_list|)
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_no_hardlinks
condition|)
block|{
if|if
condition|(
operator|!
name|link
argument_list|(
name|src
operator|->
name|buf
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|option_local
operator|>
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to create link '%s'"
argument_list|)
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
name|option_no_hardlinks
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|copy_file_with_time
argument_list|(
name|dest
operator|->
name|buf
argument_list|,
name|src
operator|->
name|buf
argument_list|,
literal|0666
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"failed to copy file to '%s'"
argument_list|)
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clone_local
specifier|static
name|void
name|clone_local
parameter_list|(
specifier|const
name|char
modifier|*
name|src_repo
parameter_list|,
specifier|const
name|char
modifier|*
name|dest_repo
parameter_list|)
block|{
if|if
condition|(
name|option_shared
condition|)
block|{
name|struct
name|strbuf
name|alt
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|alt
argument_list|,
literal|"%s/objects"
argument_list|,
name|src_repo
argument_list|)
expr_stmt|;
name|add_to_alternates_file
argument_list|(
name|alt
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|alt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|strbuf
name|src
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|dest
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|src
argument_list|,
literal|"%s/objects"
argument_list|,
name|src_repo
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|dest
argument_list|,
literal|"%s/objects"
argument_list|,
name|dest_repo
argument_list|)
expr_stmt|;
name|copy_or_link_directory
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|dest
argument_list|,
name|src_repo
argument_list|,
name|src
operator|.
name|len
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|option_verbosity
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"done.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|junk_work_tree
specifier|static
specifier|const
name|char
modifier|*
name|junk_work_tree
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|junk_git_dir
specifier|static
specifier|const
name|char
modifier|*
name|junk_git_dir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|junk_pid
specifier|static
name|pid_t
name|junk_pid
decl_stmt|;
end_decl_stmt
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|JUNK_LEAVE_NONE
name|JUNK_LEAVE_NONE
block|,
DECL|enumerator|JUNK_LEAVE_REPO
name|JUNK_LEAVE_REPO
block|,
DECL|enumerator|JUNK_LEAVE_ALL
name|JUNK_LEAVE_ALL
block|}
DECL|variable|junk_mode
name|junk_mode
init|=
name|JUNK_LEAVE_NONE
enum|;
end_enum
begin_decl_stmt
DECL|variable|junk_leave_repo_msg
specifier|static
specifier|const
name|char
name|junk_leave_repo_msg
index|[]
init|=
name|N_
argument_list|(
literal|"Clone succeeded, but checkout failed.\n"
literal|"You can inspect what was checked out with 'git status'\n"
literal|"and retry the checkout with 'git checkout -f HEAD'\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|remove_junk
specifier|static
name|void
name|remove_junk
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
switch|switch
condition|(
name|junk_mode
condition|)
block|{
case|case
name|JUNK_LEAVE_REPO
case|:
name|warning
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|junk_leave_repo_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fall-through */
case|case
name|JUNK_LEAVE_ALL
case|:
return|return;
default|default:
comment|/* proceed to removal */
break|break;
block|}
if|if
condition|(
name|getpid
argument_list|()
operator|!=
name|junk_pid
condition|)
return|return;
if|if
condition|(
name|junk_git_dir
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|junk_git_dir
argument_list|)
expr_stmt|;
name|remove_dir_recursively
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|junk_work_tree
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|junk_work_tree
argument_list|)
expr_stmt|;
name|remove_dir_recursively
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|remove_junk_on_signal
specifier|static
name|void
name|remove_junk_on_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|remove_junk
argument_list|()
expr_stmt|;
name|sigchain_pop
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_remote_branch
specifier|static
name|struct
name|ref
modifier|*
name|find_remote_branch
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
specifier|const
name|char
modifier|*
name|branch
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|strbuf
name|head
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|ref
operator|=
name|find_ref_by_name
argument_list|(
name|refs
argument_list|,
name|head
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
condition|)
return|return
name|ref
return|;
name|strbuf_addstr
argument_list|(
operator|&
name|head
argument_list|,
literal|"refs/tags/"
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|ref
operator|=
name|find_ref_by_name
argument_list|(
name|refs
argument_list|,
name|head
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|wanted_peer_refs
specifier|static
name|struct
name|ref
modifier|*
name|wanted_peer_refs
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|head
init|=
name|copy_ref
argument_list|(
name|find_ref_by_name
argument_list|(
name|refs
argument_list|,
literal|"HEAD"
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|local_refs
init|=
name|head
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
name|head
condition|?
operator|&
name|head
operator|->
name|next
else|:
operator|&
name|local_refs
decl_stmt|;
if|if
condition|(
name|option_single_branch
condition|)
block|{
name|struct
name|ref
modifier|*
name|remote_head
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|option_branch
condition|)
name|remote_head
operator|=
name|guess_remote_head
argument_list|(
name|head
argument_list|,
name|refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|local_refs
operator|=
name|NULL
expr_stmt|;
name|tail
operator|=
operator|&
name|local_refs
expr_stmt|;
name|remote_head
operator|=
name|copy_ref
argument_list|(
name|find_remote_branch
argument_list|(
name|refs
argument_list|,
name|option_branch
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|remote_head
operator|&&
name|option_branch
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Could not find remote branch %s to clone."
argument_list|)
argument_list|,
name|option_branch
argument_list|)
expr_stmt|;
else|else
block|{
name|get_fetch_map
argument_list|(
name|remote_head
argument_list|,
name|refspec
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if --branch=tag, pull the requested tag explicitly */
name|get_fetch_map
argument_list|(
name|remote_head
argument_list|,
name|tag_refspec
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|get_fetch_map
argument_list|(
name|refs
argument_list|,
name|refspec
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_mirror
operator|&&
operator|!
name|option_single_branch
condition|)
name|get_fetch_map
argument_list|(
name|refs
argument_list|,
name|tag_refspec
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|local_refs
return|;
block|}
end_function
begin_function
DECL|function|write_remote_refs
specifier|static
name|void
name|write_remote_refs
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|local_refs
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|r
decl_stmt|;
name|lock_packed_refs
argument_list|(
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|local_refs
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|peer_ref
condition|)
continue|continue;
name|add_packed_ref
argument_list|(
name|r
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
name|r
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit_packed_refs
argument_list|()
condition|)
name|die_errno
argument_list|(
literal|"unable to overwrite old ref-pack file"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write_followtags
specifier|static
name|void
name|write_followtags
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|suffixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"^{}"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
continue|continue;
name|update_ref
argument_list|(
name|msg
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|iterate_ref_map
specifier|static
name|int
name|iterate_ref_map
parameter_list|(
name|void
modifier|*
name|cb_data
parameter_list|,
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|rm
init|=
name|cb_data
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
init|=
operator|*
name|rm
decl_stmt|;
comment|/* 	 * Skip anything missing a peer_ref, which we are not 	 * actually going to write a ref for. 	 */
while|while
condition|(
name|ref
operator|&&
operator|!
name|ref
operator|->
name|peer_ref
condition|)
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
comment|/* Returning -1 notes "end of list" to the caller. */
if|if
condition|(
operator|!
name|ref
condition|)
return|return
operator|-
literal|1
return|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
operator|*
name|rm
operator|=
name|ref
operator|->
name|next
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|update_remote_refs
specifier|static
name|void
name|update_remote_refs
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|mapped_refs
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|remote_head_points_at
parameter_list|,
specifier|const
name|char
modifier|*
name|branch_top
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|int
name|check_connectivity
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|rm
init|=
name|mapped_refs
decl_stmt|;
if|if
condition|(
name|check_connectivity
condition|)
block|{
if|if
condition|(
name|transport
operator|->
name|progress
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Checking connectivity... "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_everything_connected_with_transport
argument_list|(
name|iterate_ref_map
argument_list|,
literal|0
argument_list|,
operator|&
name|rm
argument_list|,
name|transport
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"remote did not send all necessary objects"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|transport
operator|->
name|progress
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"done\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|refs
condition|)
block|{
name|write_remote_refs
argument_list|(
name|mapped_refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_single_branch
condition|)
name|write_followtags
argument_list|(
name|refs
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_head_points_at
operator|&&
operator|!
name|option_bare
condition|)
block|{
name|struct
name|strbuf
name|head_ref
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head_ref
argument_list|,
name|branch_top
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head_ref
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
name|create_symref
argument_list|(
name|head_ref
operator|.
name|buf
argument_list|,
name|remote_head_points_at
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|update_head
specifier|static
name|void
name|update_head
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|our
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|our
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|our
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
block|{
comment|/* Local default branch link */
name|create_symref
argument_list|(
literal|"HEAD"
argument_list|,
name|our
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_bare
condition|)
block|{
specifier|const
name|char
modifier|*
name|head
init|=
name|skip_prefix
argument_list|(
name|our
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
decl_stmt|;
name|update_ref
argument_list|(
name|msg
argument_list|,
literal|"HEAD"
argument_list|,
name|our
operator|->
name|old_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
name|install_branch_config
argument_list|(
literal|0
argument_list|,
name|head
argument_list|,
name|option_origin
argument_list|,
name|our
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|our
condition|)
block|{
name|struct
name|commit
modifier|*
name|c
init|=
name|lookup_commit_reference
argument_list|(
name|our
operator|->
name|old_sha1
argument_list|)
decl_stmt|;
comment|/* --branch specifies a non-branch (i.e. tags), detach HEAD */
name|update_ref
argument_list|(
name|msg
argument_list|,
literal|"HEAD"
argument_list|,
name|c
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remote
condition|)
block|{
comment|/* 		 * We know remote HEAD points to a non-branch, or 		 * HEAD points to a branch but we don't know which one. 		 * Detach HEAD in all these cases. 		 */
name|update_ref
argument_list|(
name|msg
argument_list|,
literal|"HEAD"
argument_list|,
name|remote
operator|->
name|old_sha1
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|checkout
specifier|static
name|int
name|checkout
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock_file
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|tree_desc
name|t
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|option_no_checkout
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|resolve_refdup
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"remote HEAD refers to nonexistent ref, "
literal|"unable to checkout.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|head
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|advice_detached_head
condition|)
name|detach_advice
argument_list|(
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|head
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"HEAD not found below refs/heads!"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* We need to be in the new work tree for the checkout */
name|setup_work_tree
argument_list|()
expr_stmt|;
name|lock_file
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|opts
operator|.
name|verbose_update
operator|=
operator|(
name|option_verbosity
operator|>=
literal|0
operator|)
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_trees
argument_list|(
literal|1
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|opts
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to checkout working tree"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock_file
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator||=
name|run_hook
argument_list|(
name|NULL
argument_list|,
literal|"post-checkout"
argument_list|,
name|sha1_to_hex
argument_list|(
name|null_sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
literal|"1"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|option_recursive
condition|)
name|err
operator|=
name|run_command_v_opt
argument_list|(
name|argv_submodule
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
begin_function
DECL|function|write_one_config
specifier|static
name|int
name|write_one_config
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
name|git_config_set_multivar
argument_list|(
name|key
argument_list|,
name|value
condition|?
name|value
else|:
literal|"true"
argument_list|,
literal|"^$"
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|write_config
specifier|static
name|void
name|write_config
parameter_list|(
name|struct
name|string_list
modifier|*
name|config
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|git_config_parse_parameter
argument_list|(
name|config
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|write_one_config
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to write parameters to config file"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|write_refspec_config
specifier|static
name|void
name|write_refspec_config
parameter_list|(
specifier|const
name|char
modifier|*
name|src_ref_prefix
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|our_head_points_at
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|remote_head_points_at
parameter_list|,
name|struct
name|strbuf
modifier|*
name|branch_top
parameter_list|)
block|{
name|struct
name|strbuf
name|key
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|value
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|option_mirror
operator|||
operator|!
name|option_bare
condition|)
block|{
if|if
condition|(
name|option_single_branch
operator|&&
operator|!
name|option_mirror
condition|)
block|{
if|if
condition|(
name|option_branch
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|our_head_points_at
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|value
argument_list|,
literal|"+%s:%s"
argument_list|,
name|our_head_points_at
operator|->
name|name
argument_list|,
name|our_head_points_at
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
operator|&
name|value
argument_list|,
literal|"+%s:%s%s"
argument_list|,
name|our_head_points_at
operator|->
name|name
argument_list|,
name|branch_top
operator|->
name|buf
argument_list|,
name|option_branch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remote_head_points_at
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|value
argument_list|,
literal|"+%s:%s%s"
argument_list|,
name|remote_head_points_at
operator|->
name|name
argument_list|,
name|branch_top
operator|->
name|buf
argument_list|,
name|skip_prefix
argument_list|(
name|remote_head_points_at
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * otherwise, the next "git fetch" will 			 * simply fetch from HEAD without updating 			 * any remote-tracking branch, which is what 			 * we want. 			 */
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
operator|&
name|value
argument_list|,
literal|"+%s*:%s*"
argument_list|,
name|src_ref_prefix
argument_list|,
name|branch_top
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Configure the remote */
if|if
condition|(
name|value
operator|.
name|len
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|key
argument_list|,
literal|"remote.%s.fetch"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|git_config_set_multivar
argument_list|(
name|key
operator|.
name|buf
argument_list|,
name|value
operator|.
name|buf
argument_list|,
literal|"^$"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_mirror
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|key
argument_list|,
literal|"remote.%s.mirror"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|git_config_set
argument_list|(
name|key
operator|.
name|buf
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|strbuf_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cmd_clone
name|int
name|cmd_clone
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|is_bundle
init|=
literal|0
decl_stmt|,
name|is_local
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|repo_name
decl_stmt|,
modifier|*
name|repo
decl_stmt|,
modifier|*
name|work_tree
decl_stmt|,
modifier|*
name|git_dir
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
name|int
name|dest_exists
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|refs
decl_stmt|,
modifier|*
name|remote_head
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|remote_head_points_at
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|our_head_points_at
decl_stmt|;
name|struct
name|ref
modifier|*
name|mapped_refs
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|strbuf
name|key
init|=
name|STRBUF_INIT
decl_stmt|,
name|value
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|branch_top
init|=
name|STRBUF_INIT
decl_stmt|,
name|reflog_msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|transport
modifier|*
name|transport
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_ref_prefix
init|=
literal|"refs/heads/"
decl_stmt|;
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|complete_refs_before_fetch
init|=
literal|1
decl_stmt|;
name|struct
name|refspec
modifier|*
name|refspec
decl_stmt|;
specifier|const
name|char
modifier|*
name|fetch_pattern
decl_stmt|;
name|junk_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|packet_trace_identity
argument_list|(
literal|"clone"
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_clone_options
argument_list|,
name|builtin_clone_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|usage_msg_opt
argument_list|(
name|_
argument_list|(
literal|"Too many arguments."
argument_list|)
argument_list|,
name|builtin_clone_usage
argument_list|,
name|builtin_clone_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage_msg_opt
argument_list|(
name|_
argument_list|(
literal|"You must specify a repository to clone."
argument_list|)
argument_list|,
name|builtin_clone_usage
argument_list|,
name|builtin_clone_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_single_branch
operator|==
operator|-
literal|1
condition|)
name|option_single_branch
operator|=
name|option_depth
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|option_mirror
condition|)
name|option_bare
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|option_bare
condition|)
block|{
if|if
condition|(
name|option_origin
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--bare and --origin %s options are incompatible."
argument_list|)
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_git_dir
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--bare and --separate-git-dir are incompatible."
argument_list|)
argument_list|)
expr_stmt|;
name|option_no_checkout
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|option_origin
condition|)
name|option_origin
operator|=
literal|"origin"
expr_stmt|;
name|repo_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|path
operator|=
name|get_repo_path
argument_list|(
name|repo_name
argument_list|,
operator|&
name|is_bundle
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|repo
operator|=
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|repo_name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|repo_name
argument_list|,
literal|':'
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"repository '%s' does not exist"
argument_list|)
argument_list|,
name|repo_name
argument_list|)
expr_stmt|;
else|else
name|repo
operator|=
name|repo_name
expr_stmt|;
name|is_local
operator|=
name|option_local
operator|!=
literal|0
operator|&&
name|path
operator|&&
operator|!
name|is_bundle
expr_stmt|;
if|if
condition|(
name|is_local
operator|&&
name|option_depth
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"--depth is ignored in local clones; use file:// instead."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_local
operator|>
literal|0
operator|&&
operator|!
name|is_local
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"--local is ignored"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|dir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|dir
operator|=
name|guess_dir_name
argument_list|(
name|repo_name
argument_list|,
name|is_bundle
argument_list|,
name|option_bare
argument_list|)
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dest_exists
operator|=
operator|!
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_exists
operator|&&
operator|!
name|is_empty_dir
argument_list|(
name|dir
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"destination path '%s' already exists and is not "
literal|"an empty directory."
argument_list|)
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|reflog_msg
argument_list|,
literal|"clone: from %s"
argument_list|,
name|repo
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_bare
condition|)
name|work_tree
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|work_tree
operator|=
name|getenv
argument_list|(
literal|"GIT_WORK_TREE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_tree
operator|&&
operator|!
name|stat
argument_list|(
name|work_tree
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"working tree '%s' already exists."
argument_list|)
argument_list|,
name|work_tree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|option_bare
operator|||
name|work_tree
condition|)
name|git_dir
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
else|else
block|{
name|work_tree
operator|=
name|dir
expr_stmt|;
name|git_dir
operator|=
name|mkpathdup
argument_list|(
literal|"%s/.git"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|option_bare
condition|)
block|{
name|junk_work_tree
operator|=
name|work_tree
expr_stmt|;
if|if
condition|(
name|safe_create_leading_directories_const
argument_list|(
name|work_tree
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not create leading directories of '%s'"
argument_list|)
argument_list|,
name|work_tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest_exists
operator|&&
name|mkdir
argument_list|(
name|work_tree
argument_list|,
literal|0777
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not create work tree dir '%s'."
argument_list|)
argument_list|,
name|work_tree
argument_list|)
expr_stmt|;
name|set_git_work_tree
argument_list|(
name|work_tree
argument_list|)
expr_stmt|;
block|}
name|junk_git_dir
operator|=
name|git_dir
expr_stmt|;
name|atexit
argument_list|(
name|remove_junk
argument_list|)
expr_stmt|;
name|sigchain_push_common
argument_list|(
name|remove_junk_on_signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_create_leading_directories_const
argument_list|(
name|git_dir
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not create leading directories of '%s'"
argument_list|)
argument_list|,
name|git_dir
argument_list|)
expr_stmt|;
name|set_git_dir_init
argument_list|(
name|git_dir
argument_list|,
name|real_git_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_git_dir
condition|)
block|{
name|git_dir
operator|=
name|real_git_dir
expr_stmt|;
name|junk_git_dir
operator|=
name|real_git_dir
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|option_verbosity
condition|)
block|{
if|if
condition|(
name|option_bare
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Cloning into bare repository '%s'...\n"
argument_list|)
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Cloning into '%s'...\n"
argument_list|)
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
name|init_db
argument_list|(
name|option_template
argument_list|,
name|INIT_DB_QUIET
argument_list|)
expr_stmt|;
name|write_config
argument_list|(
operator|&
name|option_config
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_bare
condition|)
block|{
if|if
condition|(
name|option_mirror
condition|)
name|src_ref_prefix
operator|=
literal|"refs/"
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|branch_top
argument_list|,
name|src_ref_prefix
argument_list|)
expr_stmt|;
name|git_config_set
argument_list|(
literal|"core.bare"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
operator|&
name|branch_top
argument_list|,
literal|"refs/remotes/%s/"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|value
argument_list|,
literal|"+%s*:%s*"
argument_list|,
name|src_ref_prefix
argument_list|,
name|branch_top
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|key
argument_list|,
literal|"remote.%s.url"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|git_config_set
argument_list|(
name|key
operator|.
name|buf
argument_list|,
name|repo
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_reference
operator|.
name|nr
condition|)
name|setup_reference
argument_list|()
expr_stmt|;
name|fetch_pattern
operator|=
name|value
operator|.
name|buf
expr_stmt|;
name|refspec
operator|=
name|parse_fetch_refspec
argument_list|(
literal|1
argument_list|,
operator|&
name|fetch_pattern
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|remote
operator|=
name|remote_get
argument_list|(
name|option_origin
argument_list|)
expr_stmt|;
name|transport
operator|=
name|transport_get
argument_list|(
name|remote
argument_list|,
name|remote
operator|->
name|url
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transport
operator|->
name|get_refs_list
operator|||
operator|(
operator|!
name|is_local
operator|&&
operator|!
name|transport
operator|->
name|fetch
operator|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Don't know how to clone %s"
argument_list|)
argument_list|,
name|transport
operator|->
name|url
argument_list|)
expr_stmt|;
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_KEEP
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_depth
condition|)
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_DEPTH
argument_list|,
name|option_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_single_branch
condition|)
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_FOLLOWTAGS
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|transport_set_verbosity
argument_list|(
name|transport
argument_list|,
name|option_verbosity
argument_list|,
name|option_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_upload_pack
condition|)
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_UPLOADPACK
argument_list|,
name|option_upload_pack
argument_list|)
expr_stmt|;
if|if
condition|(
name|transport
operator|->
name|smart_options
operator|&&
operator|!
name|option_depth
condition|)
name|transport
operator|->
name|smart_options
operator|->
name|check_self_contained_and_connected
operator|=
literal|1
expr_stmt|;
name|refs
operator|=
name|transport_get_remote_refs
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
condition|)
block|{
name|mapped_refs
operator|=
name|wanted_peer_refs
argument_list|(
name|refs
argument_list|,
name|refspec
argument_list|)
expr_stmt|;
comment|/* 		 * transport_get_remote_refs() may return refs with null sha-1 		 * in mapped_refs (see struct transport->get_refs_list 		 * comment). In that case we need fetch it early because 		 * remote_head code below relies on it. 		 * 		 * for normal clones, transport_get_remote_refs() should 		 * return reliable ref set, we can delay cloning until after 		 * remote HEAD check. 		 */
for|for
control|(
name|ref
operator|=
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
if|if
condition|(
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
name|complete_refs_before_fetch
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|is_local
operator|&&
operator|!
name|complete_refs_before_fetch
condition|)
name|transport_fetch_refs
argument_list|(
name|transport
argument_list|,
name|mapped_refs
argument_list|)
expr_stmt|;
name|remote_head
operator|=
name|find_ref_by_name
argument_list|(
name|refs
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
name|remote_head_points_at
operator|=
name|guess_remote_head
argument_list|(
name|remote_head
argument_list|,
name|mapped_refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_branch
condition|)
block|{
name|our_head_points_at
operator|=
name|find_remote_branch
argument_list|(
name|mapped_refs
argument_list|,
name|option_branch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|our_head_points_at
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Remote branch %s not found in upstream %s"
argument_list|)
argument_list|,
name|option_branch
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
block|}
else|else
name|our_head_points_at
operator|=
name|remote_head_points_at
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|option_branch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Remote branch %s not found in upstream %s"
argument_list|)
argument_list|,
name|option_branch
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"You appear to have cloned an empty repository."
argument_list|)
argument_list|)
expr_stmt|;
name|mapped_refs
operator|=
name|NULL
expr_stmt|;
name|our_head_points_at
operator|=
name|NULL
expr_stmt|;
name|remote_head_points_at
operator|=
name|NULL
expr_stmt|;
name|remote_head
operator|=
name|NULL
expr_stmt|;
name|option_no_checkout
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|option_bare
condition|)
name|install_branch_config
argument_list|(
literal|0
argument_list|,
literal|"master"
argument_list|,
name|option_origin
argument_list|,
literal|"refs/heads/master"
argument_list|)
expr_stmt|;
block|}
name|write_refspec_config
argument_list|(
name|src_ref_prefix
argument_list|,
name|our_head_points_at
argument_list|,
name|remote_head_points_at
argument_list|,
operator|&
name|branch_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
name|clone_local
argument_list|(
name|path
argument_list|,
name|git_dir
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|refs
operator|&&
name|complete_refs_before_fetch
condition|)
name|transport_fetch_refs
argument_list|(
name|transport
argument_list|,
name|mapped_refs
argument_list|)
expr_stmt|;
name|update_remote_refs
argument_list|(
name|refs
argument_list|,
name|mapped_refs
argument_list|,
name|remote_head_points_at
argument_list|,
name|branch_top
operator|.
name|buf
argument_list|,
name|reflog_msg
operator|.
name|buf
argument_list|,
name|transport
argument_list|,
operator|!
name|is_local
argument_list|)
expr_stmt|;
name|update_head
argument_list|(
name|our_head_points_at
argument_list|,
name|remote_head
argument_list|,
name|reflog_msg
operator|.
name|buf
argument_list|)
expr_stmt|;
name|transport_unlock_pack
argument_list|(
name|transport
argument_list|)
expr_stmt|;
name|transport_disconnect
argument_list|(
name|transport
argument_list|)
expr_stmt|;
name|junk_mode
operator|=
name|JUNK_LEAVE_REPO
expr_stmt|;
name|err
operator|=
name|checkout
argument_list|()
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|reflog_msg
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|branch_top
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|junk_mode
operator|=
name|JUNK_LEAVE_ALL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
end_unit
