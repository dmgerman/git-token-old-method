begin_unit
begin_comment
comment|/*  * Builtin "git clone"  *  * Copyright (c) 2007 Kristian HÃ¸gsberg<krh@redhat.com>,  *		 2008 Daniel Barkalow<barkalow@iabervon.org>  * Based on git-commit.sh by Junio C Hamano and Linus Torvalds  *  * Clone a repository into a different directory that does not yet exist.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"fetch-pack.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"transport.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"pack-refs.h"
end_include
begin_include
include|#
directive|include
file|"sigchain.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_comment
comment|/*  * Overall FIXMEs:  *  - respect DB_ENVIRONMENT for .git/objects.  *  * Implementation notes:  *  - dropping use-separate-remote and no-separate-remote compatibility  *  */
end_comment
begin_decl_stmt
DECL|variable|builtin_clone_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_clone_usage
index|[]
init|=
block|{
literal|"git clone [options] [--]<repo> [<dir>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_no_checkout
DECL|variable|option_bare
DECL|variable|option_mirror
specifier|static
name|int
name|option_no_checkout
decl_stmt|,
name|option_bare
decl_stmt|,
name|option_mirror
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_local
DECL|variable|option_no_hardlinks
DECL|variable|option_shared
DECL|variable|option_recursive
specifier|static
name|int
name|option_local
decl_stmt|,
name|option_no_hardlinks
decl_stmt|,
name|option_shared
decl_stmt|,
name|option_recursive
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_template
DECL|variable|option_reference
DECL|variable|option_depth
specifier|static
name|char
modifier|*
name|option_template
decl_stmt|,
modifier|*
name|option_reference
decl_stmt|,
modifier|*
name|option_depth
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_origin
specifier|static
name|char
modifier|*
name|option_origin
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_branch
specifier|static
name|char
modifier|*
name|option_branch
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|real_git_dir
specifier|static
specifier|const
name|char
modifier|*
name|real_git_dir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_upload_pack
specifier|static
name|char
modifier|*
name|option_upload_pack
init|=
literal|"git-upload-pack"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_verbosity
specifier|static
name|int
name|option_verbosity
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_progress
specifier|static
name|int
name|option_progress
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|builtin_clone_options
specifier|static
name|struct
name|option
name|builtin_clone_options
index|[]
init|=
block|{
name|OPT__VERBOSITY
argument_list|(
operator|&
name|option_verbosity
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"progress"
argument_list|,
operator|&
name|option_progress
argument_list|,
literal|"force progress reporting"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'n'
argument_list|,
literal|"no-checkout"
argument_list|,
operator|&
name|option_no_checkout
argument_list|,
literal|"don't create a checkout"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"bare"
argument_list|,
operator|&
name|option_bare
argument_list|,
literal|"create a bare repository"
argument_list|)
block|,
block|{
name|OPTION_BOOLEAN
block|,
literal|0
block|,
literal|"naked"
block|,
operator|&
name|option_bare
block|,
name|NULL
block|,
literal|"create a bare repository"
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_HIDDEN
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"mirror"
argument_list|,
operator|&
name|option_mirror
argument_list|,
literal|"create a mirror repository (implies bare)"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'l'
argument_list|,
literal|"local"
argument_list|,
operator|&
name|option_local
argument_list|,
literal|"to clone from a local repository"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"no-hardlinks"
argument_list|,
operator|&
name|option_no_hardlinks
argument_list|,
literal|"don't use local hardlinks, always copy"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'s'
argument_list|,
literal|"shared"
argument_list|,
operator|&
name|option_shared
argument_list|,
literal|"setup as shared repository"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"recursive"
argument_list|,
operator|&
name|option_recursive
argument_list|,
literal|"initialize submodules in the clone"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"recurse-submodules"
argument_list|,
operator|&
name|option_recursive
argument_list|,
literal|"initialize submodules in the clone"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"template"
argument_list|,
operator|&
name|option_template
argument_list|,
literal|"template-directory"
argument_list|,
literal|"directory from which templates will be used"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"reference"
argument_list|,
operator|&
name|option_reference
argument_list|,
literal|"repo"
argument_list|,
literal|"reference repository"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'o'
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|option_origin
argument_list|,
literal|"branch"
argument_list|,
literal|"use<branch> instead of 'origin' to track upstream"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'b'
argument_list|,
literal|"branch"
argument_list|,
operator|&
name|option_branch
argument_list|,
literal|"branch"
argument_list|,
literal|"checkout<branch> instead of the remote's HEAD"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'u'
argument_list|,
literal|"upload-pack"
argument_list|,
operator|&
name|option_upload_pack
argument_list|,
literal|"path"
argument_list|,
literal|"path to git-upload-pack on the remote"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"depth"
argument_list|,
operator|&
name|option_depth
argument_list|,
literal|"depth"
argument_list|,
literal|"create a shallow clone of that depth"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'L'
argument_list|,
literal|"separate-git-dir"
argument_list|,
operator|&
name|real_git_dir
argument_list|,
literal|"gitdir"
argument_list|,
literal|"separate git dir from working tree"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|argv_submodule
specifier|static
specifier|const
name|char
modifier|*
name|argv_submodule
index|[]
init|=
block|{
literal|"submodule"
block|,
literal|"update"
block|,
literal|"--init"
block|,
literal|"--recursive"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_repo_path
specifier|static
name|char
modifier|*
name|get_repo_path
parameter_list|(
specifier|const
name|char
modifier|*
name|repo
parameter_list|,
name|int
modifier|*
name|is_bundle
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|suffix
index|[]
init|=
block|{
literal|"/.git"
block|,
literal|".git"
block|,
literal|""
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|bundle_suffix
index|[]
init|=
block|{
literal|".bundle"
block|,
literal|""
block|}
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|suffix
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|mkpath
argument_list|(
literal|"%s%s"
argument_list|,
name|repo
argument_list|,
name|suffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_directory
argument_list|(
name|path
argument_list|)
condition|)
block|{
operator|*
name|is_bundle
operator|=
literal|0
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bundle_suffix
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|mkpath
argument_list|(
literal|"%s%s"
argument_list|,
name|repo
argument_list|,
name|bundle_suffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|*
name|is_bundle
operator|=
literal|1
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|guess_dir_name
specifier|static
name|char
modifier|*
name|guess_dir_name
parameter_list|(
specifier|const
name|char
modifier|*
name|repo
parameter_list|,
name|int
name|is_bundle
parameter_list|,
name|int
name|is_bare
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|repo
operator|+
name|strlen
argument_list|(
name|repo
argument_list|)
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* 	 * Strip trailing spaces, slashes and /.git 	 */
while|while
condition|(
name|repo
operator|<
name|end
operator|&&
operator|(
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isspace
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|end
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|repo
operator|>
literal|5
operator|&&
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|5
index|]
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|end
operator|-
literal|4
argument_list|,
literal|".git"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|end
operator|-=
literal|5
expr_stmt|;
while|while
condition|(
name|repo
operator|<
name|end
operator|&&
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|end
operator|--
expr_stmt|;
block|}
comment|/* 	 * Find last component, but be prepared that repo could have 	 * the form  "remote.example.com:foo.git", i.e. no slash 	 * in the directory part. 	 */
name|start
operator|=
name|end
expr_stmt|;
while|while
condition|(
name|repo
operator|<
name|start
operator|&&
operator|!
name|is_dir_sep
argument_list|(
name|start
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|start
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
name|start
operator|--
expr_stmt|;
comment|/* 	 * Strip .{bundle,git}. 	 */
if|if
condition|(
name|is_bundle
condition|)
block|{
if|if
condition|(
name|end
operator|-
name|start
operator|>
literal|7
operator|&&
operator|!
name|strncmp
argument_list|(
name|end
operator|-
literal|7
argument_list|,
literal|".bundle"
argument_list|,
literal|7
argument_list|)
condition|)
name|end
operator|-=
literal|7
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end
operator|-
name|start
operator|>
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|end
operator|-
literal|4
argument_list|,
literal|".git"
argument_list|,
literal|4
argument_list|)
condition|)
name|end
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|is_bare
condition|)
block|{
name|struct
name|strbuf
name|result
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|result
argument_list|,
literal|"%.*s.git"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|dir
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|result
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|dir
operator|=
name|xstrndup
argument_list|(
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * Replace sequences of 'control' characters and whitespace 	 * with one ascii space, remove leading and trailing spaces. 	 */
if|if
condition|(
operator|*
name|dir
condition|)
block|{
name|char
modifier|*
name|out
init|=
name|dir
decl_stmt|;
name|int
name|prev_space
init|=
literal|1
comment|/* strip leading whitespace */
decl_stmt|;
for|for
control|(
name|end
operator|=
name|dir
init|;
operator|*
name|end
condition|;
operator|++
name|end
control|)
block|{
name|char
name|ch
init|=
operator|*
name|end
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|ch
operator|<
literal|'\x20'
condition|)
name|ch
operator|=
literal|'\x20'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev_space
condition|)
continue|continue;
name|prev_space
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev_space
operator|=
literal|0
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|out
operator|>
name|dir
operator|&&
name|prev_space
condition|)
name|out
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|dir
return|;
block|}
end_function
begin_function
DECL|function|strip_trailing_slashes
specifier|static
name|void
name|strip_trailing_slashes
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
decl_stmt|;
while|while
condition|(
name|dir
operator|<
name|end
operator|-
literal|1
operator|&&
name|is_dir_sep
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|end
operator|--
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setup_reference
specifier|static
name|void
name|setup_reference
parameter_list|(
specifier|const
name|char
modifier|*
name|repo
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ref_git
decl_stmt|;
name|char
modifier|*
name|ref_git_copy
decl_stmt|;
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
name|struct
name|transport
modifier|*
name|transport
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|extra
decl_stmt|;
name|ref_git
operator|=
name|real_path
argument_list|(
name|option_reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_directory
argument_list|(
name|mkpath
argument_list|(
literal|"%s/.git/objects"
argument_list|,
name|ref_git
argument_list|)
argument_list|)
condition|)
name|ref_git
operator|=
name|mkpath
argument_list|(
literal|"%s/.git"
argument_list|,
name|ref_git
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_directory
argument_list|(
name|mkpath
argument_list|(
literal|"%s/objects"
argument_list|,
name|ref_git
argument_list|)
argument_list|)
condition|)
name|die
argument_list|(
literal|"reference repository '%s' is not a local directory."
argument_list|,
name|option_reference
argument_list|)
expr_stmt|;
name|ref_git_copy
operator|=
name|xstrdup
argument_list|(
name|ref_git
argument_list|)
expr_stmt|;
name|add_to_alternates_file
argument_list|(
name|ref_git_copy
argument_list|)
expr_stmt|;
name|remote
operator|=
name|remote_get
argument_list|(
name|ref_git_copy
argument_list|)
expr_stmt|;
name|transport
operator|=
name|transport_get
argument_list|(
name|remote
argument_list|,
name|ref_git_copy
argument_list|)
expr_stmt|;
for|for
control|(
name|extra
operator|=
name|transport_get_remote_refs
argument_list|(
name|transport
argument_list|)
init|;
name|extra
condition|;
name|extra
operator|=
name|extra
operator|->
name|next
control|)
name|add_extra_ref
argument_list|(
name|extra
operator|->
name|name
argument_list|,
name|extra
operator|->
name|old_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|transport_disconnect
argument_list|(
name|transport
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_git_copy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|copy_or_link_directory
specifier|static
name|void
name|copy_or_link_directory
parameter_list|(
name|struct
name|strbuf
modifier|*
name|src
parameter_list|,
name|struct
name|strbuf
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|src_len
decl_stmt|,
name|dest_len
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|src
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
name|die_errno
argument_list|(
literal|"failed to open '%s'"
argument_list|,
name|src
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|dest
operator|->
name|buf
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
name|die_errno
argument_list|(
literal|"failed to create directory '%s'"
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|dest
operator|->
name|buf
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"failed to stat '%s'"
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
name|die
argument_list|(
literal|"%s exists and is not a directory"
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|src
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|src_len
operator|=
name|src
operator|->
name|len
expr_stmt|;
name|strbuf_addch
argument_list|(
name|dest
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|dest_len
operator|=
name|dest
operator|->
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strbuf_setlen
argument_list|(
name|src
argument_list|,
name|src_len
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|src
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|dest
argument_list|,
name|dest_len
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|dest
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|src
operator|->
name|buf
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"failed to stat %s\n"
argument_list|,
name|src
operator|->
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|de
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
name|copy_or_link_directory
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|dest
operator|->
name|buf
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|die_errno
argument_list|(
literal|"failed to unlink '%s'"
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_no_hardlinks
condition|)
block|{
if|if
condition|(
operator|!
name|link
argument_list|(
name|src
operator|->
name|buf
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|option_local
condition|)
name|die_errno
argument_list|(
literal|"failed to create link '%s'"
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
name|option_no_hardlinks
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|copy_file_with_time
argument_list|(
name|dest
operator|->
name|buf
argument_list|,
name|src
operator|->
name|buf
argument_list|,
literal|0666
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"failed to copy file to '%s'"
argument_list|,
name|dest
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clone_local
specifier|static
specifier|const
name|struct
name|ref
modifier|*
name|clone_local
parameter_list|(
specifier|const
name|char
modifier|*
name|src_repo
parameter_list|,
specifier|const
name|char
modifier|*
name|dest_repo
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ret
decl_stmt|;
name|struct
name|strbuf
name|src
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|dest
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
name|struct
name|transport
modifier|*
name|transport
decl_stmt|;
if|if
condition|(
name|option_shared
condition|)
name|add_to_alternates_file
argument_list|(
name|src_repo
argument_list|)
expr_stmt|;
else|else
block|{
name|strbuf_addf
argument_list|(
operator|&
name|src
argument_list|,
literal|"%s/objects"
argument_list|,
name|src_repo
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|dest
argument_list|,
literal|"%s/objects"
argument_list|,
name|dest_repo
argument_list|)
expr_stmt|;
name|copy_or_link_directory
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|dest
argument_list|)
expr_stmt|;
block|}
name|remote
operator|=
name|remote_get
argument_list|(
name|src_repo
argument_list|)
expr_stmt|;
name|transport
operator|=
name|transport_get
argument_list|(
name|remote
argument_list|,
name|src_repo
argument_list|)
expr_stmt|;
name|ret
operator|=
name|transport_get_remote_refs
argument_list|(
name|transport
argument_list|)
expr_stmt|;
name|transport_disconnect
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|option_verbosity
condition|)
name|printf
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|junk_work_tree
specifier|static
specifier|const
name|char
modifier|*
name|junk_work_tree
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|junk_git_dir
specifier|static
specifier|const
name|char
modifier|*
name|junk_git_dir
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|junk_pid
specifier|static
name|pid_t
name|junk_pid
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|remove_junk
specifier|static
name|void
name|remove_junk
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|getpid
argument_list|()
operator|!=
name|junk_pid
condition|)
return|return;
if|if
condition|(
name|junk_git_dir
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|junk_git_dir
argument_list|)
expr_stmt|;
name|remove_dir_recursively
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|junk_work_tree
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|junk_work_tree
argument_list|)
expr_stmt|;
name|remove_dir_recursively
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|remove_junk_on_signal
specifier|static
name|void
name|remove_junk_on_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|remove_junk
argument_list|()
expr_stmt|;
name|sigchain_pop
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|wanted_peer_refs
specifier|static
name|struct
name|ref
modifier|*
name|wanted_peer_refs
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|local_refs
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|local_refs
decl_stmt|;
name|get_fetch_map
argument_list|(
name|refs
argument_list|,
name|refspec
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_mirror
condition|)
name|get_fetch_map
argument_list|(
name|refs
argument_list|,
name|tag_refspec
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|local_refs
return|;
block|}
end_function
begin_function
DECL|function|write_remote_refs
specifier|static
name|void
name|write_remote_refs
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|local_refs
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|local_refs
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|add_extra_ref
argument_list|(
name|r
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
name|r
operator|->
name|old_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pack_refs
argument_list|(
name|PACK_REFS_ALL
argument_list|)
expr_stmt|;
name|clear_extra_refs
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cmd_clone
name|int
name|cmd_clone
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|is_bundle
init|=
literal|0
decl_stmt|,
name|is_local
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|repo_name
decl_stmt|,
modifier|*
name|repo
decl_stmt|,
modifier|*
name|work_tree
decl_stmt|,
modifier|*
name|git_dir
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
name|int
name|dest_exists
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|refs
decl_stmt|,
modifier|*
name|remote_head
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|remote_head_points_at
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|our_head_points_at
decl_stmt|;
name|struct
name|ref
modifier|*
name|mapped_refs
decl_stmt|;
name|struct
name|strbuf
name|key
init|=
name|STRBUF_INIT
decl_stmt|,
name|value
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|branch_top
init|=
name|STRBUF_INIT
decl_stmt|,
name|reflog_msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|transport
modifier|*
name|transport
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|src_ref_prefix
init|=
literal|"refs/heads/"
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|refspec
modifier|*
name|refspec
decl_stmt|;
specifier|const
name|char
modifier|*
name|fetch_pattern
decl_stmt|;
name|junk_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_clone_options
argument_list|,
name|builtin_clone_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|usage_msg_opt
argument_list|(
literal|"Too many arguments."
argument_list|,
name|builtin_clone_usage
argument_list|,
name|builtin_clone_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage_msg_opt
argument_list|(
literal|"You must specify a repository to clone."
argument_list|,
name|builtin_clone_usage
argument_list|,
name|builtin_clone_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_mirror
condition|)
name|option_bare
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|option_bare
condition|)
block|{
if|if
condition|(
name|option_origin
condition|)
name|die
argument_list|(
literal|"--bare and --origin %s options are incompatible."
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|option_no_checkout
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|option_origin
condition|)
name|option_origin
operator|=
literal|"origin"
expr_stmt|;
name|repo_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|path
operator|=
name|get_repo_path
argument_list|(
name|repo_name
argument_list|,
operator|&
name|is_bundle
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|repo
operator|=
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|repo_name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|repo_name
argument_list|,
literal|':'
argument_list|)
condition|)
name|die
argument_list|(
literal|"repository '%s' does not exist"
argument_list|,
name|repo_name
argument_list|)
expr_stmt|;
else|else
name|repo
operator|=
name|repo_name
expr_stmt|;
name|is_local
operator|=
name|path
operator|&&
operator|!
name|is_bundle
expr_stmt|;
if|if
condition|(
name|is_local
operator|&&
name|option_depth
condition|)
name|warning
argument_list|(
literal|"--depth is ignored in local clones; use file:// instead."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|dir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|dir
operator|=
name|guess_dir_name
argument_list|(
name|repo_name
argument_list|,
name|is_bundle
argument_list|,
name|option_bare
argument_list|)
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dest_exists
operator|=
operator|!
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_exists
operator|&&
operator|!
name|is_empty_dir
argument_list|(
name|dir
argument_list|)
condition|)
name|die
argument_list|(
literal|"destination path '%s' already exists and is not "
literal|"an empty directory."
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|reflog_msg
argument_list|,
literal|"clone: from %s"
argument_list|,
name|repo
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_bare
condition|)
name|work_tree
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|work_tree
operator|=
name|getenv
argument_list|(
literal|"GIT_WORK_TREE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|work_tree
operator|&&
operator|!
name|stat
argument_list|(
name|work_tree
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|die
argument_list|(
literal|"working tree '%s' already exists."
argument_list|,
name|work_tree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|option_bare
operator|||
name|work_tree
condition|)
name|git_dir
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
else|else
block|{
name|work_tree
operator|=
name|dir
expr_stmt|;
name|git_dir
operator|=
name|xstrdup
argument_list|(
name|mkpath
argument_list|(
literal|"%s/.git"
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|option_bare
condition|)
block|{
name|junk_work_tree
operator|=
name|work_tree
expr_stmt|;
if|if
condition|(
name|safe_create_leading_directories_const
argument_list|(
name|work_tree
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"could not create leading directories of '%s'"
argument_list|,
name|work_tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest_exists
operator|&&
name|mkdir
argument_list|(
name|work_tree
argument_list|,
literal|0755
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"could not create work tree dir '%s'."
argument_list|,
name|work_tree
argument_list|)
expr_stmt|;
name|set_git_work_tree
argument_list|(
name|work_tree
argument_list|)
expr_stmt|;
block|}
name|junk_git_dir
operator|=
name|git_dir
expr_stmt|;
name|atexit
argument_list|(
name|remove_junk
argument_list|)
expr_stmt|;
name|sigchain_push_common
argument_list|(
name|remove_junk_on_signal
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|CONFIG_ENVIRONMENT
argument_list|,
name|mkpath
argument_list|(
literal|"%s/config"
argument_list|,
name|git_dir
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_create_leading_directories_const
argument_list|(
name|git_dir
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not create leading directories of '%s'"
argument_list|,
name|git_dir
argument_list|)
expr_stmt|;
name|set_git_dir_init
argument_list|(
name|git_dir
argument_list|,
name|real_git_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_git_dir
condition|)
block|{
name|git_dir
operator|=
name|real_git_dir
expr_stmt|;
name|junk_git_dir
operator|=
name|real_git_dir
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|option_verbosity
condition|)
name|printf
argument_list|(
literal|"Cloning into %s%s...\n"
argument_list|,
name|option_bare
condition|?
literal|"bare repository "
else|:
literal|""
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|init_db
argument_list|(
name|option_template
argument_list|,
name|INIT_DB_QUIET
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, the config exists, so we do not need the 	 * environment variable.  We actually need to unset it, too, to 	 * re-enable parsing of the global configs. 	 */
name|unsetenv
argument_list|(
name|CONFIG_ENVIRONMENT
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_bare
condition|)
block|{
if|if
condition|(
name|option_mirror
condition|)
name|src_ref_prefix
operator|=
literal|"refs/"
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|branch_top
argument_list|,
name|src_ref_prefix
argument_list|)
expr_stmt|;
name|git_config_set
argument_list|(
literal|"core.bare"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
operator|&
name|branch_top
argument_list|,
literal|"refs/remotes/%s/"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|value
argument_list|,
literal|"+%s*:%s*"
argument_list|,
name|src_ref_prefix
argument_list|,
name|branch_top
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_mirror
operator|||
operator|!
name|option_bare
condition|)
block|{
comment|/* Configure the remote */
name|strbuf_addf
argument_list|(
operator|&
name|key
argument_list|,
literal|"remote.%s.fetch"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|git_config_set_multivar
argument_list|(
name|key
operator|.
name|buf
argument_list|,
name|value
operator|.
name|buf
argument_list|,
literal|"^$"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_mirror
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|key
argument_list|,
literal|"remote.%s.mirror"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|git_config_set
argument_list|(
name|key
operator|.
name|buf
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_addf
argument_list|(
operator|&
name|key
argument_list|,
literal|"remote.%s.url"
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|git_config_set
argument_list|(
name|key
operator|.
name|buf
argument_list|,
name|repo
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_reference
condition|)
name|setup_reference
argument_list|(
name|git_dir
argument_list|)
expr_stmt|;
name|fetch_pattern
operator|=
name|value
operator|.
name|buf
expr_stmt|;
name|refspec
operator|=
name|parse_fetch_refspec
argument_list|(
literal|1
argument_list|,
operator|&
name|fetch_pattern
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
block|{
name|refs
operator|=
name|clone_local
argument_list|(
name|path
argument_list|,
name|git_dir
argument_list|)
expr_stmt|;
name|mapped_refs
operator|=
name|wanted_peer_refs
argument_list|(
name|refs
argument_list|,
name|refspec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|remote
modifier|*
name|remote
init|=
name|remote_get
argument_list|(
name|option_origin
argument_list|)
decl_stmt|;
name|transport
operator|=
name|transport_get
argument_list|(
name|remote
argument_list|,
name|remote
operator|->
name|url
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transport
operator|->
name|get_refs_list
operator|||
operator|!
name|transport
operator|->
name|fetch
condition|)
name|die
argument_list|(
literal|"Don't know how to clone %s"
argument_list|,
name|transport
operator|->
name|url
argument_list|)
expr_stmt|;
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_KEEP
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_depth
condition|)
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_DEPTH
argument_list|,
name|option_depth
argument_list|)
expr_stmt|;
name|transport_set_verbosity
argument_list|(
name|transport
argument_list|,
name|option_verbosity
argument_list|,
name|option_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_upload_pack
condition|)
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_UPLOADPACK
argument_list|,
name|option_upload_pack
argument_list|)
expr_stmt|;
name|refs
operator|=
name|transport_get_remote_refs
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
condition|)
block|{
name|mapped_refs
operator|=
name|wanted_peer_refs
argument_list|(
name|refs
argument_list|,
name|refspec
argument_list|)
expr_stmt|;
name|transport_fetch_refs
argument_list|(
name|transport
argument_list|,
name|mapped_refs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|refs
condition|)
block|{
name|clear_extra_refs
argument_list|()
expr_stmt|;
name|write_remote_refs
argument_list|(
name|mapped_refs
argument_list|)
expr_stmt|;
name|remote_head
operator|=
name|find_ref_by_name
argument_list|(
name|refs
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
name|remote_head_points_at
operator|=
name|guess_remote_head
argument_list|(
name|remote_head
argument_list|,
name|mapped_refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|option_branch
condition|)
block|{
name|struct
name|strbuf
name|head
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head
argument_list|,
name|src_ref_prefix
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head
argument_list|,
name|option_branch
argument_list|)
expr_stmt|;
name|our_head_points_at
operator|=
name|find_ref_by_name
argument_list|(
name|mapped_refs
argument_list|,
name|head
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|our_head_points_at
condition|)
block|{
name|warning
argument_list|(
literal|"Remote branch %s not found in "
literal|"upstream %s, using HEAD instead"
argument_list|,
name|option_branch
argument_list|,
name|option_origin
argument_list|)
expr_stmt|;
name|our_head_points_at
operator|=
name|remote_head_points_at
expr_stmt|;
block|}
block|}
else|else
name|our_head_points_at
operator|=
name|remote_head_points_at
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"You appear to have cloned an empty repository."
argument_list|)
expr_stmt|;
name|our_head_points_at
operator|=
name|NULL
expr_stmt|;
name|remote_head_points_at
operator|=
name|NULL
expr_stmt|;
name|remote_head
operator|=
name|NULL
expr_stmt|;
name|option_no_checkout
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|option_bare
condition|)
name|install_branch_config
argument_list|(
literal|0
argument_list|,
literal|"master"
argument_list|,
name|option_origin
argument_list|,
literal|"refs/heads/master"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_head_points_at
operator|&&
operator|!
name|option_bare
condition|)
block|{
name|struct
name|strbuf
name|head_ref
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head_ref
argument_list|,
name|branch_top
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|head_ref
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
name|create_symref
argument_list|(
name|head_ref
operator|.
name|buf
argument_list|,
name|remote_head_points_at
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
name|reflog_msg
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|our_head_points_at
condition|)
block|{
comment|/* Local default branch link */
name|create_symref
argument_list|(
literal|"HEAD"
argument_list|,
name|our_head_points_at
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_bare
condition|)
block|{
specifier|const
name|char
modifier|*
name|head
init|=
name|skip_prefix
argument_list|(
name|our_head_points_at
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
decl_stmt|;
name|update_ref
argument_list|(
name|reflog_msg
operator|.
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|our_head_points_at
operator|->
name|old_sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
name|install_branch_config
argument_list|(
literal|0
argument_list|,
name|head
argument_list|,
name|option_origin
argument_list|,
name|our_head_points_at
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|remote_head
condition|)
block|{
comment|/* Source had detached HEAD pointing somewhere. */
if|if
condition|(
operator|!
name|option_bare
condition|)
block|{
name|update_ref
argument_list|(
name|reflog_msg
operator|.
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|remote_head
operator|->
name|old_sha1
argument_list|,
name|NULL
argument_list|,
name|REF_NODEREF
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
name|our_head_points_at
operator|=
name|remote_head
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing to checkout out */
if|if
condition|(
operator|!
name|option_no_checkout
condition|)
name|warning
argument_list|(
literal|"remote HEAD refers to nonexistent ref, "
literal|"unable to checkout.\n"
argument_list|)
expr_stmt|;
name|option_no_checkout
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|transport
condition|)
block|{
name|transport_unlock_pack
argument_list|(
name|transport
argument_list|)
expr_stmt|;
name|transport_disconnect
argument_list|(
name|transport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|option_no_checkout
condition|)
block|{
name|struct
name|lock_file
modifier|*
name|lock_file
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|tree_desc
name|t
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* We need to be in the new work tree for the checkout */
name|setup_work_tree
argument_list|()
expr_stmt|;
name|fd
operator|=
name|hold_locked_index
argument_list|(
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|opts
operator|.
name|verbose_update
operator|=
operator|(
name|option_verbosity
operator|>
literal|0
operator|)
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|our_head_points_at
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
name|unpack_trees
argument_list|(
literal|1
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock_file
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write new index file"
argument_list|)
expr_stmt|;
name|err
operator||=
name|run_hook
argument_list|(
name|NULL
argument_list|,
literal|"post-checkout"
argument_list|,
name|sha1_to_hex
argument_list|(
name|null_sha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|our_head_points_at
operator|->
name|old_sha1
argument_list|)
argument_list|,
literal|"1"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|option_recursive
condition|)
name|err
operator|=
name|run_command_v_opt
argument_list|(
name|argv_submodule
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|reflog_msg
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|branch_top
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
name|junk_pid
operator|=
literal|0
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
end_unit
