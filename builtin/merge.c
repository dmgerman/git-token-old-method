begin_unit
begin_comment
comment|/*  * Builtin "git merge"  *  * Copyright (c) 2008 Miklos Vajna<vmiklos@frugalware.org>  *  * Based on git-merge.sh by Junio C Hamano.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"rerere.h"
end_include
begin_include
include|#
directive|include
file|"help.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"resolve-undo.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"fmt-merge-msg.h"
end_include
begin_include
include|#
directive|include
file|"gpg-interface.h"
end_include
begin_define
DECL|macro|DEFAULT_TWOHEAD
define|#
directive|define
name|DEFAULT_TWOHEAD
value|(1<<0)
end_define
begin_define
DECL|macro|DEFAULT_OCTOPUS
define|#
directive|define
name|DEFAULT_OCTOPUS
value|(1<<1)
end_define
begin_define
DECL|macro|NO_FAST_FORWARD
define|#
directive|define
name|NO_FAST_FORWARD
value|(1<<2)
end_define
begin_define
DECL|macro|NO_TRIVIAL
define|#
directive|define
name|NO_TRIVIAL
value|(1<<3)
end_define
begin_struct
DECL|struct|strategy
struct|struct
name|strategy
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|attr
name|unsigned
name|attr
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|builtin_merge_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_merge_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git merge [options] [<commit>...]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git merge [options]<msg> HEAD<commit>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git merge --abort"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|show_diffstat
DECL|variable|shortlog_len
DECL|variable|squash
specifier|static
name|int
name|show_diffstat
init|=
literal|1
decl_stmt|,
name|shortlog_len
init|=
operator|-
literal|1
decl_stmt|,
name|squash
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_commit
DECL|variable|allow_fast_forward
specifier|static
name|int
name|option_commit
init|=
literal|1
decl_stmt|,
name|allow_fast_forward
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fast_forward_only
DECL|variable|option_edit
specifier|static
name|int
name|fast_forward_only
decl_stmt|,
name|option_edit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allow_trivial
DECL|variable|have_message
DECL|variable|verify_signatures
specifier|static
name|int
name|allow_trivial
init|=
literal|1
decl_stmt|,
name|have_message
decl_stmt|,
name|verify_signatures
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|overwrite_ignore
specifier|static
name|int
name|overwrite_ignore
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|merge_msg
specifier|static
name|struct
name|strbuf
name|merge_msg
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_strategies
specifier|static
name|struct
name|strategy
modifier|*
modifier|*
name|use_strategies
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_strategies_nr
DECL|variable|use_strategies_alloc
specifier|static
name|size_t
name|use_strategies_nr
decl_stmt|,
name|use_strategies_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xopts
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|xopts
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xopts_nr
DECL|variable|xopts_alloc
specifier|static
name|size_t
name|xopts_nr
decl_stmt|,
name|xopts_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch
specifier|static
specifier|const
name|char
modifier|*
name|branch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_mergeoptions
specifier|static
name|char
modifier|*
name|branch_mergeoptions
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|option_renormalize
specifier|static
name|int
name|option_renormalize
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|verbosity
specifier|static
name|int
name|verbosity
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allow_rerere_auto
specifier|static
name|int
name|allow_rerere_auto
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|abort_current_merge
specifier|static
name|int
name|abort_current_merge
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|show_progress
specifier|static
name|int
name|show_progress
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_to_upstream
specifier|static
name|int
name|default_to_upstream
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sign_commit
specifier|static
specifier|const
name|char
modifier|*
name|sign_commit
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|all_strategy
specifier|static
name|struct
name|strategy
name|all_strategy
index|[]
init|=
block|{
block|{
literal|"recursive"
block|,
name|DEFAULT_TWOHEAD
operator||
name|NO_TRIVIAL
block|}
block|,
block|{
literal|"octopus"
block|,
name|DEFAULT_OCTOPUS
block|}
block|,
block|{
literal|"resolve"
block|,
literal|0
block|}
block|,
block|{
literal|"ours"
block|,
name|NO_FAST_FORWARD
operator||
name|NO_TRIVIAL
block|}
block|,
block|{
literal|"subtree"
block|,
name|NO_FAST_FORWARD
operator||
name|NO_TRIVIAL
block|}
block|, }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pull_twohead
DECL|variable|pull_octopus
specifier|static
specifier|const
name|char
modifier|*
name|pull_twohead
decl_stmt|,
modifier|*
name|pull_octopus
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|option_parse_message
specifier|static
name|int
name|option_parse_message
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|buf
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|unset
condition|)
name|strbuf_setlen
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
condition|)
block|{
name|strbuf_addf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|buf
operator|->
name|len
condition|?
literal|"\n\n"
else|:
literal|""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|have_message
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"switch `m' requires a value"
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_strategy
specifier|static
name|struct
name|strategy
modifier|*
name|get_strategy
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|strategy
modifier|*
name|ret
decl_stmt|;
specifier|static
name|struct
name|cmdnames
name|main_cmds
decl_stmt|,
name|other_cmds
decl_stmt|;
specifier|static
name|int
name|loaded
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|all_strategy
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|all_strategy
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
operator|&
name|all_strategy
index|[
name|i
index|]
return|;
if|if
condition|(
operator|!
name|loaded
condition|)
block|{
name|struct
name|cmdnames
name|not_strategies
decl_stmt|;
name|loaded
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|not_strategies
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cmdnames
argument_list|)
argument_list|)
expr_stmt|;
name|load_command_list
argument_list|(
literal|"git-merge-"
argument_list|,
operator|&
name|main_cmds
argument_list|,
operator|&
name|other_cmds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|main_cmds
operator|.
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|cmdname
modifier|*
name|ent
init|=
name|main_cmds
operator|.
name|names
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|all_strategy
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ent
operator|->
name|name
argument_list|,
name|all_strategy
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|ent
operator|->
name|len
argument_list|)
operator|&&
operator|!
name|all_strategy
index|[
name|j
index|]
operator|.
name|name
index|[
name|ent
operator|->
name|len
index|]
condition|)
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|add_cmdname
argument_list|(
operator|&
name|not_strategies
argument_list|,
name|ent
operator|->
name|name
argument_list|,
name|ent
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|exclude_cmds
argument_list|(
operator|&
name|main_cmds
argument_list|,
operator|&
name|not_strategies
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_in_cmdlist
argument_list|(
operator|&
name|main_cmds
argument_list|,
name|name
argument_list|)
operator|&&
operator|!
name|is_in_cmdlist
argument_list|(
operator|&
name|other_cmds
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Could not find merge strategy '%s'.\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Available strategies are:"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|main_cmds
operator|.
name|cnt
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|main_cmds
operator|.
name|names
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_cmds
operator|.
name|cnt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Available custom strategies are:"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|other_cmds
operator|.
name|cnt
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|other_cmds
operator|.
name|names
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|strategy
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|attr
operator|=
name|NO_TRIVIAL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|append_strategy
specifier|static
name|void
name|append_strategy
parameter_list|(
name|struct
name|strategy
modifier|*
name|s
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|use_strategies
argument_list|,
name|use_strategies_nr
operator|+
literal|1
argument_list|,
name|use_strategies_alloc
argument_list|)
expr_stmt|;
name|use_strategies
index|[
name|use_strategies_nr
operator|++
index|]
operator|=
name|s
expr_stmt|;
block|}
end_function
begin_function
DECL|function|option_parse_strategy
specifier|static
name|int
name|option_parse_strategy
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
return|return
literal|0
return|;
name|append_strategy
argument_list|(
name|get_strategy
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_x
specifier|static
name|int
name|option_parse_x
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
return|return
literal|0
return|;
name|ALLOC_GROW
argument_list|(
name|xopts
argument_list|,
name|xopts_nr
operator|+
literal|1
argument_list|,
name|xopts_alloc
argument_list|)
expr_stmt|;
name|xopts
index|[
name|xopts_nr
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_n
specifier|static
name|int
name|option_parse_n
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|show_diffstat
operator|=
name|unset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|builtin_merge_options
specifier|static
name|struct
name|option
name|builtin_merge_options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|'n'
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"do not show a diffstat at the end of the merge"
argument_list|)
block|,
name|PARSE_OPT_NOARG
block|,
name|option_parse_n
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"stat"
argument_list|,
operator|&
name|show_diffstat
argument_list|,
name|N_
argument_list|(
literal|"show a diffstat at the end of the merge"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"summary"
argument_list|,
operator|&
name|show_diffstat
argument_list|,
name|N_
argument_list|(
literal|"(synonym to --stat)"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_INTEGER
block|,
literal|0
block|,
literal|"log"
block|,
operator|&
name|shortlog_len
block|,
name|N_
argument_list|(
literal|"n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"add (at most<n>) entries from shortlog to merge commit message"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
name|DEFAULT_MERGE_LOG_LEN
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"squash"
argument_list|,
operator|&
name|squash
argument_list|,
name|N_
argument_list|(
literal|"create a single commit instead of doing a merge"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"commit"
argument_list|,
operator|&
name|option_commit
argument_list|,
name|N_
argument_list|(
literal|"perform a commit if the merge succeeds (default)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'e'
argument_list|,
literal|"edit"
argument_list|,
operator|&
name|option_edit
argument_list|,
name|N_
argument_list|(
literal|"edit message before committing"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"ff"
argument_list|,
operator|&
name|allow_fast_forward
argument_list|,
name|N_
argument_list|(
literal|"allow fast-forward (default)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"ff-only"
argument_list|,
operator|&
name|fast_forward_only
argument_list|,
name|N_
argument_list|(
literal|"abort if fast-forward is not possible"
argument_list|)
argument_list|)
block|,
name|OPT_RERERE_AUTOUPDATE
argument_list|(
operator|&
name|allow_rerere_auto
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"verify-signatures"
argument_list|,
operator|&
name|verify_signatures
argument_list|,
name|N_
argument_list|(
literal|"Verify that the named commit has a valid GPG signature"
argument_list|)
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|'s'
argument_list|,
literal|"strategy"
argument_list|,
operator|&
name|use_strategies
argument_list|,
name|N_
argument_list|(
literal|"strategy"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"merge strategy to use"
argument_list|)
argument_list|,
name|option_parse_strategy
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|'X'
argument_list|,
literal|"strategy-option"
argument_list|,
operator|&
name|xopts
argument_list|,
name|N_
argument_list|(
literal|"option=value"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"option for selected merge strategy"
argument_list|)
argument_list|,
name|option_parse_x
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|'m'
argument_list|,
literal|"message"
argument_list|,
operator|&
name|merge_msg
argument_list|,
name|N_
argument_list|(
literal|"message"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"merge commit message (for a non-fast-forward merge)"
argument_list|)
argument_list|,
name|option_parse_message
argument_list|)
block|,
name|OPT__VERBOSITY
argument_list|(
operator|&
name|verbosity
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"abort"
argument_list|,
operator|&
name|abort_current_merge
argument_list|,
name|N_
argument_list|(
literal|"abort the current in-progress merge"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"progress"
argument_list|,
operator|&
name|show_progress
argument_list|,
name|N_
argument_list|(
literal|"force progress reporting"
argument_list|)
argument_list|,
literal|1
argument_list|)
block|,
block|{
name|OPTION_STRING
block|,
literal|'S'
block|,
literal|"gpg-sign"
block|,
operator|&
name|sign_commit
block|,
name|N_
argument_list|(
literal|"key id"
argument_list|)
block|,
name|N_
argument_list|(
literal|"GPG sign commit"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
operator|(
name|intptr_t
operator|)
literal|""
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"overwrite-ignore"
argument_list|,
operator|&
name|overwrite_ignore
argument_list|,
name|N_
argument_list|(
literal|"update ignored files (default)"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Cleans up metadata that is uninteresting after a succeeded merge. */
end_comment
begin_function
DECL|function|drop_save
specifier|static
name|void
name|drop_save
parameter_list|(
name|void
parameter_list|)
block|{
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|save_state
specifier|static
name|int
name|save_state
parameter_list|(
name|unsigned
name|char
modifier|*
name|stash
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|child_process
name|cp
decl_stmt|;
name|struct
name|strbuf
name|buffer
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[]
init|=
block|{
literal|"stash"
block|,
literal|"create"
block|,
name|NULL
block|}
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|cp
operator|.
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_command
argument_list|(
operator|&
name|cp
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not run stash."
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strbuf_read
argument_list|(
operator|&
name|buffer
argument_list|,
name|cp
operator|.
name|out
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cp
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|cp
argument_list|)
operator|||
name|len
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"stash failed"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|len
condition|)
comment|/* no changes */
return|return
operator|-
literal|1
return|;
name|strbuf_setlen
argument_list|(
operator|&
name|buffer
argument_list|,
name|buffer
operator|.
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|buffer
operator|.
name|buf
argument_list|,
name|stash
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"not a valid object: %s"
argument_list|)
argument_list|,
name|buffer
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_empty
specifier|static
name|void
name|read_empty
parameter_list|(
name|unsigned
specifier|const
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
index|[
literal|7
index|]
decl_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"read-tree"
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-v"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-m"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-u"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|EMPTY_TREE_SHA1_HEX
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|run_command_v_opt
argument_list|(
name|args
argument_list|,
name|RUN_GIT_CMD
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"read-tree failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reset_hard
specifier|static
name|void
name|reset_hard
parameter_list|(
name|unsigned
specifier|const
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
index|[
literal|6
index|]
decl_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"read-tree"
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-v"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"--reset"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-u"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|run_command_v_opt
argument_list|(
name|args
argument_list|,
name|RUN_GIT_CMD
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"read-tree failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|restore_state
specifier|static
name|void
name|restore_state
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|stash
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
index|[]
init|=
block|{
literal|"stash"
block|,
literal|"apply"
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|stash
argument_list|)
condition|)
return|return;
name|reset_hard
argument_list|(
name|head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|sha1_to_hex
argument_list|(
name|stash
argument_list|)
expr_stmt|;
comment|/* 	 * It is OK to ignore error here, for example when there was 	 * nothing to restore. 	 */
name|run_command_v_opt
argument_list|(
name|args
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* This is called when no merge was necessary. */
end_comment
begin_function
DECL|function|finish_up_to_date
specifier|static
name|void
name|finish_up_to_date
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
name|squash
condition|?
name|_
argument_list|(
literal|" (nothing to squash)"
argument_list|)
else|:
literal|""
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|drop_save
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|squash_message
specifier|static
name|void
name|squash_message
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|strbuf
name|out
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|pretty_print_context
name|ctx
init|=
block|{
literal|0
block|}
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Squash commit -- not updating HEAD\n"
argument_list|)
argument_list|)
expr_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|ignore_merges
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|commit_format
operator|=
name|CMIT_FMT_MEDIUM
expr_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|rev
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|remoteheads
init|;
name|j
condition|;
name|j
operator|=
name|j
operator|->
name|next
control|)
name|add_pending_object
argument_list|(
operator|&
name|rev
argument_list|,
operator|&
name|j
operator|->
name|item
operator|->
name|object
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|rev
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|abbrev
operator|=
name|rev
operator|.
name|abbrev
expr_stmt|;
name|ctx
operator|.
name|date_mode
operator|=
name|rev
operator|.
name|date_mode
expr_stmt|;
name|ctx
operator|.
name|fmt
operator|=
name|rev
operator|.
name|commit_format
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|out
argument_list|,
literal|"Squashed commit of the following:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
operator|&
name|rev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strbuf_addch
argument_list|(
operator|&
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out
argument_list|,
literal|"commit %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|pretty_print_commit
argument_list|(
operator|&
name|ctx
argument_list|,
name|commit
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|out
operator|.
name|buf
argument_list|,
name|out
operator|.
name|len
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Writing SQUASH_MSG"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Finishing SQUASH_MSG"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finish
specifier|static
name|void
name|finish
parameter_list|(
name|struct
name|commit
modifier|*
name|head_commit
parameter_list|,
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|new_head
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|strbuf
name|reflog_message
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|head
init|=
name|head_commit
operator|->
name|object
operator|.
name|sha1
decl_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|reflog_message
argument_list|,
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|reflog_message
argument_list|,
literal|"%s: %s"
argument_list|,
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|squash
condition|)
block|{
name|squash_message
argument_list|(
name|head_commit
argument_list|,
name|remoteheads
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|0
operator|&&
operator|!
name|merge_msg
operator|.
name|len
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"No merge message -- not updating HEAD\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|argv_gc_auto
index|[]
init|=
block|{
literal|"gc"
block|,
literal|"--auto"
block|,
name|NULL
block|}
decl_stmt|;
name|update_ref
argument_list|(
name|reflog_message
operator|.
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|new_head
argument_list|,
name|head
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
comment|/* 			 * We ignore errors in 'gc --auto', since the 			 * user should see them. 			 */
name|run_command_v_opt
argument_list|(
name|argv_gc_auto
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_head
operator|&&
name|show_diffstat
condition|)
block|{
name|struct
name|diff_options
name|opts
decl_stmt|;
name|diff_setup
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|.
name|stat_width
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* use full terminal width */
name|opts
operator|.
name|stat_graph_width
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* respect statGraphWidth config */
name|opts
operator|.
name|output_format
operator||=
name|DIFF_FORMAT_SUMMARY
operator||
name|DIFF_FORMAT_DIFFSTAT
expr_stmt|;
name|opts
operator|.
name|detect_rename
operator|=
name|DIFF_DETECT_RENAME
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|head
argument_list|,
name|new_head
argument_list|,
literal|""
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
block|}
comment|/* Run a post-merge hook */
name|run_hook
argument_list|(
name|NULL
argument_list|,
literal|"post-merge"
argument_list|,
name|squash
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|reflog_message
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Get the name for the merge commit's message. */
end_comment
begin_function
DECL|function|merge_name
specifier|static
name|void
name|merge_name
parameter_list|(
specifier|const
name|char
modifier|*
name|remote
parameter_list|,
name|struct
name|strbuf
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|remote_head
decl_stmt|;
name|unsigned
name|char
name|branch_head
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|bname
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|found_ref
decl_stmt|;
name|int
name|len
decl_stmt|,
name|early
decl_stmt|;
name|strbuf_branchname
argument_list|(
operator|&
name|bname
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|remote
operator|=
name|bname
operator|.
name|buf
expr_stmt|;
name|memset
argument_list|(
name|branch_head
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|branch_head
argument_list|)
argument_list|)
expr_stmt|;
name|remote_head
operator|=
name|get_merge_parent
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_head
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' does not point to a commit"
argument_list|)
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwim_ref
argument_list|(
name|remote
argument_list|,
name|strlen
argument_list|(
name|remote
argument_list|)
argument_list|,
name|branch_head
argument_list|,
operator|&
name|found_ref
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|found_ref
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
name|msg
argument_list|,
literal|"%s\t\tbranch '%s' of .\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|branch_head
argument_list|)
argument_list|,
name|remote
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|found_ref
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
name|msg
argument_list|,
literal|"%s\t\ttag '%s' of .\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|branch_head
argument_list|)
argument_list|,
name|remote
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|found_ref
argument_list|,
literal|"refs/remotes/"
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
name|msg
argument_list|,
literal|"%s\t\tremote-tracking branch '%s' of .\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|branch_head
argument_list|)
argument_list|,
name|remote
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* See if remote matches<name>^^^.. or<name>~<number> */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|ptr
operator|=
name|remote
operator|+
name|strlen
argument_list|(
name|remote
argument_list|)
init|;
name|remote
operator|<
name|ptr
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'^'
condition|;
name|ptr
operator|--
control|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|early
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|early
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|strrchr
argument_list|(
name|remote
argument_list|,
literal|'~'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|int
name|seen_nonzero
init|=
literal|0
decl_stmt|;
name|len
operator|++
expr_stmt|;
comment|/* count ~ */
while|while
condition|(
operator|*
operator|++
name|ptr
operator|&&
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
name|seen_nonzero
operator||=
operator|(
operator|*
name|ptr
operator|!=
literal|'0'
operator|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* not ...~<number> */
elseif|else
if|if
condition|(
name|seen_nonzero
condition|)
name|early
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|1
condition|)
name|early
operator|=
literal|1
expr_stmt|;
comment|/* "name~" is "name~1"! */
block|}
block|}
if|if
condition|(
name|len
condition|)
block|{
name|struct
name|strbuf
name|truname
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|truname
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|truname
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|truname
argument_list|,
name|truname
operator|.
name|len
operator|-
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_exists
argument_list|(
name|truname
operator|.
name|buf
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
name|msg
argument_list|,
literal|"%s\t\tbranch '%s'%s of .\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_head
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|truname
operator|.
name|buf
operator|+
literal|11
argument_list|,
operator|(
name|early
condition|?
literal|" (early part)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|truname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|remote
argument_list|,
literal|"FETCH_HEAD"
argument_list|)
operator|&&
operator|!
name|access
argument_list|(
name|git_path
argument_list|(
literal|"FETCH_HEAD"
argument_list|)
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|strbuf
name|line
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
literal|"FETCH_HEAD"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not open '%s' for reading"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strbuf_getline
argument_list|(
operator|&
name|line
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strstr
argument_list|(
name|line
operator|.
name|buf
argument_list|,
literal|"\tnot-for-merge\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|strbuf_remove
argument_list|(
operator|&
name|line
argument_list|,
name|ptr
operator|-
name|line
operator|.
name|buf
operator|+
literal|1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
name|msg
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|remote_head
operator|->
name|util
condition|)
block|{
name|struct
name|merge_remote_desc
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|merge_remote_util
argument_list|(
name|remote_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|&&
name|desc
operator|->
name|obj
operator|&&
name|desc
operator|->
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|strbuf_addf
argument_list|(
name|msg
argument_list|,
literal|"%s\t\t%s '%s'\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|desc
operator|->
name|obj
operator|->
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|desc
operator|->
name|obj
operator|->
name|type
argument_list|)
argument_list|,
name|remote
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|strbuf_addf
argument_list|(
name|msg
argument_list|,
literal|"%s\t\tcommit '%s'\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|remote_head
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|bname
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_branch_merge_options
specifier|static
name|void
name|parse_branch_merge_options
parameter_list|(
name|char
modifier|*
name|bmo
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
if|if
condition|(
operator|!
name|bmo
condition|)
return|return;
name|argc
operator|=
name|split_cmdline
argument_list|(
name|bmo
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Bad branch.%s.mergeoptions string: %s"
argument_list|)
argument_list|,
name|branch
argument_list|,
name|split_cmdline_strerror
argument_list|(
name|argc
argument_list|)
argument_list|)
expr_stmt|;
name|argv
operator|=
name|xrealloc
argument_list|(
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|"branch.*.mergeoptions"
expr_stmt|;
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
name|builtin_merge_options
argument_list|,
name|builtin_merge_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_merge_config
specifier|static
name|int
name|git_merge_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|branch
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|k
argument_list|,
literal|"branch."
argument_list|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|k
operator|+
literal|7
argument_list|,
name|branch
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|k
operator|+
literal|7
operator|+
name|strlen
argument_list|(
name|branch
argument_list|)
argument_list|,
literal|".mergeoptions"
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|branch_mergeoptions
argument_list|)
expr_stmt|;
name|branch_mergeoptions
operator|=
name|xstrdup
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"merge.diffstat"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"merge.stat"
argument_list|)
condition|)
name|show_diffstat
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"pull.twohead"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|pull_twohead
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"pull.octopus"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|pull_octopus
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"merge.renormalize"
argument_list|)
condition|)
name|option_renormalize
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"merge.ff"
argument_list|)
condition|)
block|{
name|int
name|boolval
init|=
name|git_config_maybe_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|boolval
condition|)
block|{
name|allow_fast_forward
operator|=
name|boolval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|&&
operator|!
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"only"
argument_list|)
condition|)
block|{
name|allow_fast_forward
operator|=
literal|1
expr_stmt|;
name|fast_forward_only
operator|=
literal|1
expr_stmt|;
block|}
comment|/* do not barf on values from future versions of git */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"merge.defaulttoupstream"
argument_list|)
condition|)
block|{
name|default_to_upstream
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|fmt_merge_msg_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|status
operator|=
name|git_gpg_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
return|return
name|git_diff_ui_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read_tree_trivial
specifier|static
name|int
name|read_tree_trivial
parameter_list|(
name|unsigned
name|char
modifier|*
name|common
parameter_list|,
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
name|unsigned
name|char
modifier|*
name|one
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nr_trees
init|=
literal|0
decl_stmt|;
name|struct
name|tree
modifier|*
name|trees
index|[
name|MAX_UNPACK_TREES
index|]
decl_stmt|;
name|struct
name|tree_desc
name|t
index|[
name|MAX_UNPACK_TREES
index|]
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|2
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|verbose_update
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|trivial_merges_only
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|trees
index|[
name|nr_trees
index|]
operator|=
name|parse_tree_indirect
argument_list|(
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trees
index|[
name|nr_trees
operator|++
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|trees
index|[
name|nr_trees
index|]
operator|=
name|parse_tree_indirect
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trees
index|[
name|nr_trees
operator|++
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|trees
index|[
name|nr_trees
index|]
operator|=
name|parse_tree_indirect
argument_list|(
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trees
index|[
name|nr_trees
operator|++
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|opts
operator|.
name|fn
operator|=
name|threeway_merge
expr_stmt|;
name|cache_tree_free
argument_list|(
operator|&
name|active_cache_tree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_trees
condition|;
name|i
operator|++
control|)
block|{
name|parse_tree
argument_list|(
name|trees
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
name|t
operator|+
name|i
argument_list|,
name|trees
index|[
name|i
index|]
operator|->
name|buffer
argument_list|,
name|trees
index|[
name|i
index|]
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unpack_trees
argument_list|(
name|nr_trees
argument_list|,
name|t
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_tree_trivial
specifier|static
name|void
name|write_tree_trivial
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
if|if
condition|(
name|write_cache_as_tree
argument_list|(
name|sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git write-tree failed to write a tree"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|try_merge_strategy
specifier|static
name|int
name|try_merge_strategy
parameter_list|(
specifier|const
name|char
modifier|*
name|strategy
parameter_list|,
name|struct
name|commit_list
modifier|*
name|common
parameter_list|,
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|,
name|struct
name|commit
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|head_arg
parameter_list|)
block|{
name|int
name|index_fd
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|index_fd
operator|=
name|hold_locked_index
argument_list|(
name|lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|&&
operator|(
name|write_cache
argument_list|(
name|index_fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock
argument_list|)
operator|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to write index."
argument_list|)
argument_list|)
return|;
name|rollback_lock_file
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"recursive"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"subtree"
argument_list|)
condition|)
block|{
name|int
name|clean
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|commit
modifier|*
name|result
decl_stmt|;
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|index_fd
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|reversed
init|=
name|NULL
decl_stmt|;
name|struct
name|merge_options
name|o
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|j
decl_stmt|;
if|if
condition|(
name|remoteheads
operator|->
name|next
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Not handling anything other than two heads merge."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|init_merge_options
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"subtree"
argument_list|)
condition|)
name|o
operator|.
name|subtree_shift
operator|=
literal|""
expr_stmt|;
name|o
operator|.
name|renormalize
operator|=
name|option_renormalize
expr_stmt|;
name|o
operator|.
name|show_rename_progress
operator|=
name|show_progress
operator|==
operator|-
literal|1
condition|?
name|isatty
argument_list|(
literal|2
argument_list|)
else|:
name|show_progress
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xopts_nr
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|parse_merge_opt
argument_list|(
operator|&
name|o
argument_list|,
name|xopts
index|[
name|x
index|]
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unknown option for merge-recursive: -X%s"
argument_list|)
argument_list|,
name|xopts
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|o
operator|.
name|branch1
operator|=
name|head_arg
expr_stmt|;
name|o
operator|.
name|branch2
operator|=
name|merge_remote_util
argument_list|(
name|remoteheads
operator|->
name|item
argument_list|)
operator|->
name|name
expr_stmt|;
for|for
control|(
name|j
operator|=
name|common
init|;
name|j
condition|;
name|j
operator|=
name|j
operator|->
name|next
control|)
name|commit_list_insert
argument_list|(
name|j
operator|->
name|item
argument_list|,
operator|&
name|reversed
argument_list|)
expr_stmt|;
name|index_fd
operator|=
name|hold_locked_index
argument_list|(
name|lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clean
operator|=
name|merge_recursive
argument_list|(
operator|&
name|o
argument_list|,
name|head
argument_list|,
name|remoteheads
operator|->
name|item
argument_list|,
name|reversed
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|&&
operator|(
name|write_cache
argument_list|(
name|index_fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
name|lock
argument_list|)
operator|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write %s"
argument_list|)
argument_list|,
name|get_index_file
argument_list|()
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
name|clean
condition|?
literal|0
else|:
literal|1
return|;
block|}
else|else
block|{
return|return
name|try_merge_command
argument_list|(
name|strategy
argument_list|,
name|xopts_nr
argument_list|,
name|xopts
argument_list|,
name|common
argument_list|,
name|head_arg
argument_list|,
name|remoteheads
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|count_diff_files
specifier|static
name|void
name|count_diff_files
parameter_list|(
name|struct
name|diff_queue_struct
modifier|*
name|q
parameter_list|,
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|count
init|=
name|data
decl_stmt|;
operator|(
operator|*
name|count
operator|)
operator|+=
name|q
operator|->
name|nr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|count_unmerged_entries
specifier|static
name|int
name|count_unmerged_entries
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ce_stage
argument_list|(
name|active_cache
index|[
name|i
index|]
argument_list|)
condition|)
name|ret
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|split_merge_strategies
specifier|static
name|void
name|split_merge_strategies
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|struct
name|strategy
modifier|*
modifier|*
name|list
parameter_list|,
name|int
modifier|*
name|nr
parameter_list|,
name|int
modifier|*
name|alloc
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
return|return;
name|buf
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|q
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|ALLOC_GROW
argument_list|(
operator|*
name|list
argument_list|,
operator|*
name|nr
operator|+
literal|1
argument_list|,
operator|*
name|alloc
argument_list|)
expr_stmt|;
operator|(
operator|*
name|list
operator|)
index|[
operator|(
operator|*
name|nr
operator|)
operator|++
index|]
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ALLOC_GROW
argument_list|(
operator|*
name|list
argument_list|,
operator|*
name|nr
operator|+
literal|1
argument_list|,
operator|*
name|alloc
argument_list|)
expr_stmt|;
operator|(
operator|*
name|list
operator|)
index|[
operator|(
operator|*
name|nr
operator|)
operator|++
index|]
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|add_strategies
specifier|static
name|void
name|add_strategies
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|attr
parameter_list|)
block|{
name|struct
name|strategy
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|int
name|list_alloc
init|=
literal|0
decl_stmt|,
name|list_nr
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|split_merge_strategies
argument_list|(
name|string
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|list_nr
argument_list|,
operator|&
name|list_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list_nr
condition|;
name|i
operator|++
control|)
name|append_strategy
argument_list|(
name|get_strategy
argument_list|(
name|list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|all_strategy
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|all_strategy
index|[
name|i
index|]
operator|.
name|attr
operator|&
name|attr
condition|)
name|append_strategy
argument_list|(
operator|&
name|all_strategy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write_merge_msg
specifier|static
name|void
name|write_merge_msg
parameter_list|(
name|struct
name|strbuf
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|msg
operator|->
name|buf
argument_list|,
name|msg
operator|->
name|len
argument_list|)
operator|!=
name|msg
operator|->
name|len
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_merge_msg
specifier|static
name|void
name|read_merge_msg
parameter_list|(
name|struct
name|strbuf
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
decl_stmt|;
name|strbuf_reset
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read_file
argument_list|(
name|msg
argument_list|,
name|filename
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not read from '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|write_merge_state
parameter_list|(
name|struct
name|commit_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|abort_commit
specifier|static
name|void
name|abort_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|,
specifier|const
name|char
modifier|*
name|err_msg
parameter_list|)
block|{
if|if
condition|(
name|err_msg
condition|)
name|error
argument_list|(
literal|"%s"
argument_list|,
name|err_msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Not committing merge; use 'git commit' to complete the merge.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|write_merge_state
argument_list|(
name|remoteheads
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|merge_editor_comment
specifier|static
specifier|const
name|char
name|merge_editor_comment
index|[]
init|=
name|N_
argument_list|(
literal|"Please enter a commit message to explain why this merge is necessary,\n"
literal|"especially if it merges an updated upstream into a topic branch.\n"
literal|"\n"
literal|"Lines starting with '%c' will be ignored, and an empty message aborts\n"
literal|"the commit.\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|prepare_to_commit
specifier|static
name|void
name|prepare_to_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|)
block|{
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|msg
argument_list|,
operator|&
name|merge_msg
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|msg
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|option_edit
condition|)
name|strbuf_commented_addf
argument_list|(
operator|&
name|msg
argument_list|,
name|_
argument_list|(
name|merge_editor_comment
argument_list|)
argument_list|,
name|comment_line_char
argument_list|)
expr_stmt|;
name|write_merge_msg
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_hook
argument_list|(
name|get_index_file
argument_list|()
argument_list|,
literal|"prepare-commit-msg"
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
literal|"merge"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|abort_commit
argument_list|(
name|remoteheads
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|option_edit
condition|)
block|{
if|if
condition|(
name|launch_editor
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|abort_commit
argument_list|(
name|remoteheads
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|read_merge_msg
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|stripspace
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
operator|<
name|option_edit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|len
condition|)
name|abort_commit
argument_list|(
name|remoteheads
argument_list|,
name|_
argument_list|(
literal|"Empty commit message."
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|merge_msg
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|merge_msg
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|merge_trivial
specifier|static
name|int
name|merge_trivial
parameter_list|(
name|struct
name|commit
modifier|*
name|head
parameter_list|,
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|)
block|{
name|unsigned
name|char
name|result_tree
index|[
literal|20
index|]
decl_stmt|,
name|result_commit
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parent
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|parent
argument_list|)
argument_list|)
decl_stmt|;
name|write_tree_trivial
argument_list|(
name|result_tree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Wonderful.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|item
operator|=
name|head
expr_stmt|;
name|parent
operator|->
name|next
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|parent
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|next
operator|->
name|item
operator|=
name|remoteheads
operator|->
name|item
expr_stmt|;
name|parent
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|prepare_to_commit
argument_list|(
name|remoteheads
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_tree
argument_list|(
operator|&
name|merge_msg
argument_list|,
name|result_tree
argument_list|,
name|parent
argument_list|,
name|result_commit
argument_list|,
name|NULL
argument_list|,
name|sign_commit
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to write commit object"
argument_list|)
argument_list|)
expr_stmt|;
name|finish
argument_list|(
name|head
argument_list|,
name|remoteheads
argument_list|,
name|result_commit
argument_list|,
literal|"In-index merge"
argument_list|)
expr_stmt|;
name|drop_save
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|finish_automerge
specifier|static
name|int
name|finish_automerge
parameter_list|(
name|struct
name|commit
modifier|*
name|head
parameter_list|,
name|int
name|head_subsumed
parameter_list|,
name|struct
name|commit_list
modifier|*
name|common
parameter_list|,
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_tree
parameter_list|,
specifier|const
name|char
modifier|*
name|wt_strategy
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|result_commit
index|[
literal|20
index|]
decl_stmt|;
name|free_commit_list
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|parents
operator|=
name|remoteheads
expr_stmt|;
if|if
condition|(
operator|!
name|head_subsumed
operator|||
operator|!
name|allow_fast_forward
condition|)
name|commit_list_insert
argument_list|(
name|head
argument_list|,
operator|&
name|parents
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|merge_msg
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|prepare_to_commit
argument_list|(
name|remoteheads
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_tree
argument_list|(
operator|&
name|merge_msg
argument_list|,
name|result_tree
argument_list|,
name|parents
argument_list|,
name|result_commit
argument_list|,
name|NULL
argument_list|,
name|sign_commit
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to write commit object"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"Merge made by the '%s' strategy."
argument_list|,
name|wt_strategy
argument_list|)
expr_stmt|;
name|finish
argument_list|(
name|head
argument_list|,
name|remoteheads
argument_list|,
name|result_commit
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|drop_save
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|suggest_conflicts
specifier|static
name|int
name|suggest_conflicts
parameter_list|(
name|int
name|renormalizing
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nConflicts:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|active_nr
condition|;
name|pos
operator|++
control|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s\n"
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|+
literal|1
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|active_cache
index|[
name|pos
operator|+
literal|1
index|]
operator|->
name|name
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|rerere
argument_list|(
name|allow_rerere_auto
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Automatic merge failed; "
literal|"fix conflicts and then commit the result.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|is_old_style_invocation
specifier|static
name|struct
name|commit
modifier|*
name|is_old_style_invocation
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|second_token
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|unsigned
name|char
name|second_sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|second_sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|second_token
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|second_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|second_token
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' is not a commit"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|second_token
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|second_token
return|;
block|}
end_function
begin_function
DECL|function|evaluate_result
specifier|static
name|int
name|evaluate_result
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|rev_info
name|rev
decl_stmt|;
comment|/* Check how many files differ. */
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator||=
name|DIFF_FORMAT_CALLBACK
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|format_callback
operator|=
name|count_diff_files
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|format_callback_data
operator|=
operator|&
name|cnt
expr_stmt|;
name|run_diff_files
argument_list|(
operator|&
name|rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check how many unmerged entries are 	 * there. 	 */
name|cnt
operator|+=
name|count_unmerged_entries
argument_list|()
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function
begin_comment
comment|/*  * Pretend as if the user told us to merge with the tracking  * branch we have for the upstream of the current branch  */
end_comment
begin_function
DECL|function|setup_with_upstream
specifier|static
name|int
name|setup_with_upstream
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|branch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No current branch."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
operator|->
name|remote
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No remote for the current branch."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
operator|->
name|merge_nr
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No default upstream defined for the current branch."
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|xcalloc
argument_list|(
name|branch
operator|->
name|merge_nr
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|branch
operator|->
name|merge_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|branch
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|dst
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No remote tracking branch for %s from %s"
argument_list|)
argument_list|,
name|branch
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
argument_list|,
name|branch
operator|->
name|remote_name
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|branch
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|dst
expr_stmt|;
block|}
name|args
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argv
operator|=
name|args
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|write_merge_state
specifier|static
name|void
name|write_merge_state
parameter_list|(
name|struct
name|commit_list
modifier|*
name|remoteheads
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|j
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
for|for
control|(
name|j
operator|=
name|remoteheads
init|;
name|j
condition|;
name|j
operator|=
name|j
operator|->
name|next
control|)
block|{
name|unsigned
specifier|const
name|char
modifier|*
name|sha1
decl_stmt|;
name|struct
name|commit
modifier|*
name|c
init|=
name|j
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|util
operator|&&
name|merge_remote_util
argument_list|(
name|c
argument_list|)
operator|->
name|obj
condition|)
block|{
name|sha1
operator|=
name|merge_remote_util
argument_list|(
name|c
argument_list|)
operator|->
name|obj
operator|->
name|sha1
expr_stmt|;
block|}
else|else
block|{
name|sha1
operator|=
name|c
operator|->
name|object
operator|.
name|sha1
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
operator|!=
name|buf
operator|.
name|len
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|merge_msg
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|write_merge_msg
argument_list|(
operator|&
name|merge_msg
argument_list|)
expr_stmt|;
name|filename
operator|=
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allow_fast_forward
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"no-ff"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
operator|!=
name|buf
operator|.
name|len
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to '%s'"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|default_edit_option
specifier|static
name|int
name|default_edit_option
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|name
index|[]
init|=
literal|"GIT_MERGE_AUTOEDIT"
decl_stmt|;
specifier|const
name|char
modifier|*
name|e
init|=
name|getenv
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|stat
name|st_stdin
decl_stmt|,
name|st_stdout
decl_stmt|;
if|if
condition|(
name|have_message
condition|)
comment|/* an explicit -m msg without --[no-]edit */
return|return
literal|0
return|;
if|if
condition|(
name|e
condition|)
block|{
name|int
name|v
init|=
name|git_config_maybe_bool
argument_list|(
name|name
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Bad value '%s' in environment '%s'"
argument_list|,
name|e
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/* Use editor if stdin and stdout are the same and is a tty */
return|return
operator|(
operator|!
name|fstat
argument_list|(
literal|0
argument_list|,
operator|&
name|st_stdin
argument_list|)
operator|&&
operator|!
name|fstat
argument_list|(
literal|1
argument_list|,
operator|&
name|st_stdout
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|0
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|1
argument_list|)
operator|&&
name|st_stdin
operator|.
name|st_dev
operator|==
name|st_stdout
operator|.
name|st_dev
operator|&&
name|st_stdin
operator|.
name|st_ino
operator|==
name|st_stdout
operator|.
name|st_ino
operator|&&
name|st_stdin
operator|.
name|st_mode
operator|==
name|st_stdout
operator|.
name|st_mode
operator|)
return|;
block|}
end_function
begin_function
DECL|function|collect_parents
specifier|static
name|struct
name|commit_list
modifier|*
name|collect_parents
parameter_list|(
name|struct
name|commit
modifier|*
name|head_commit
parameter_list|,
name|int
modifier|*
name|head_subsumed
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|remoteheads
init|=
name|NULL
decl_stmt|,
modifier|*
name|parents
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|remotes
init|=
operator|&
name|remoteheads
decl_stmt|;
if|if
condition|(
name|head_commit
condition|)
name|remotes
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|head_commit
argument_list|,
name|remotes
argument_list|)
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|get_merge_parent
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|help_unknown_ref
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"merge"
argument_list|,
literal|"not something we can merge"
argument_list|)
expr_stmt|;
name|remotes
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
name|remotes
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|remotes
operator|=
name|NULL
expr_stmt|;
name|parents
operator|=
name|reduce_heads
argument_list|(
name|remoteheads
argument_list|)
expr_stmt|;
operator|*
name|head_subsumed
operator|=
literal|1
expr_stmt|;
comment|/* we will flip this to 0 when we find it */
for|for
control|(
name|remoteheads
operator|=
name|NULL
operator|,
name|remotes
operator|=
operator|&
name|remoteheads
init|;
name|parents
condition|;
name|parents
operator|=
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|next
operator|=
name|parents
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|commit
operator|==
name|head_commit
condition|)
operator|*
name|head_subsumed
operator|=
literal|0
expr_stmt|;
else|else
name|remotes
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
name|remotes
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
return|return
name|remoteheads
return|;
block|}
end_function
begin_function
DECL|function|cmd_merge
name|int
name|cmd_merge
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|unsigned
name|char
name|result_tree
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
name|stash
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|head_commit
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|head_arg
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|head_subsumed
decl_stmt|;
name|int
name|best_cnt
init|=
operator|-
literal|1
decl_stmt|,
name|merge_was_ok
init|=
literal|0
decl_stmt|,
name|automerge_was_ok
init|=
literal|0
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|common
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|best_strategy
init|=
name|NULL
decl_stmt|,
modifier|*
name|wt_strategy
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|remoteheads
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|branch_to_free
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage_with_options
argument_list|(
name|builtin_merge_usage
argument_list|,
name|builtin_merge_options
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we are _not_ on a detached HEAD, i.e. if there is a 	 * current branch. 	 */
name|branch
operator|=
name|branch_to_free
operator|=
name|resolve_refdup
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|branch
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|branch
operator|+=
literal|11
expr_stmt|;
if|if
condition|(
operator|!
name|branch
operator|||
name|is_null_sha1
argument_list|(
name|head_sha1
argument_list|)
condition|)
name|head_commit
operator|=
name|NULL
expr_stmt|;
else|else
name|head_commit
operator|=
name|lookup_commit_or_die
argument_list|(
name|head_sha1
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_merge_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_mergeoptions
condition|)
name|parse_branch_merge_options
argument_list|(
name|branch_mergeoptions
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_merge_options
argument_list|,
name|builtin_merge_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortlog_len
operator|<
literal|0
condition|)
name|shortlog_len
operator|=
operator|(
name|merge_log_config
operator|>
literal|0
operator|)
condition|?
name|merge_log_config
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|verbosity
operator|<
literal|0
operator|&&
name|show_progress
operator|==
operator|-
literal|1
condition|)
name|show_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abort_current_merge
condition|)
block|{
name|int
name|nargc
init|=
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|nargv
index|[]
init|=
block|{
literal|"reset"
block|,
literal|"--merge"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"There is no merge to abort (MERGE_HEAD missing)."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Invoke 'git reset --merge' */
name|ret
operator|=
name|cmd_reset
argument_list|(
name|nargc
argument_list|,
name|nargv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|read_cache_unmerged
argument_list|()
condition|)
name|die_resolve_conflict
argument_list|(
literal|"merge"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * There is no unmerged entry, don't advise 'git 		 * add/rm<file>', just 'git commit'. 		 */
if|if
condition|(
name|advice_resolve_conflict
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You have not concluded your merge (MERGE_HEAD exists).\n"
literal|"Please, commit your changes before you can merge."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"You have not concluded your merge (MERGE_HEAD exists)."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|advice_resolve_conflict
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).\n"
literal|"Please, commit your changes before you can merge."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists)."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|resolve_undo_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbosity
operator|<
literal|0
condition|)
name|show_diffstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|squash
condition|)
block|{
if|if
condition|(
operator|!
name|allow_fast_forward
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You cannot combine --squash with --no-ff."
argument_list|)
argument_list|)
expr_stmt|;
name|option_commit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allow_fast_forward
operator|&&
name|fast_forward_only
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You cannot combine --no-ff with --ff-only."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abort_current_merge
condition|)
block|{
if|if
condition|(
operator|!
name|argc
condition|)
block|{
if|if
condition|(
name|default_to_upstream
condition|)
name|argc
operator|=
name|setup_with_upstream
argument_list|(
operator|&
name|argv
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"No commit specified and merge.defaultToUpstream not set."
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
name|argv
index|[
literal|0
index|]
operator|=
literal|"@{-1}"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argc
condition|)
name|usage_with_options
argument_list|(
name|builtin_merge_usage
argument_list|,
name|builtin_merge_options
argument_list|)
expr_stmt|;
comment|/* 	 * This could be traditional "merge<msg> HEAD<commit>..."  and 	 * the way we can tell it is to see if the second token is HEAD, 	 * but some people might have misused the interface and used a 	 * committish that is the same as HEAD there instead. 	 * Traditional format never would have "-m" so it is an 	 * additional safety measure to check for it. 	 */
if|if
condition|(
operator|!
name|have_message
operator|&&
name|head_commit
operator|&&
name|is_old_style_invocation
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|merge_msg
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|head_arg
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|remoteheads
operator|=
name|collect_parents
argument_list|(
name|head_commit
argument_list|,
operator|&
name|head_subsumed
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|head_commit
condition|)
block|{
name|struct
name|commit
modifier|*
name|remote_head
decl_stmt|;
comment|/* 		 * If the merged head is a valid one there is no reason 		 * to forbid "git merge" into a branch yet to be born. 		 * We do the same for "git pull". 		 */
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Can merge only exactly one commit into "
literal|"empty head"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|squash
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Squash commit into empty head not supported yet"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allow_fast_forward
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Non-fast-forward commit does not make sense into "
literal|"an empty head"
argument_list|)
argument_list|)
expr_stmt|;
name|remoteheads
operator|=
name|collect_parents
argument_list|(
name|head_commit
argument_list|,
operator|&
name|head_subsumed
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|remote_head
operator|=
name|remoteheads
operator|->
name|item
expr_stmt|;
if|if
condition|(
operator|!
name|remote_head
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"%s - not something we can merge"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read_empty
argument_list|(
name|remote_head
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update_ref
argument_list|(
literal|"initial pull"
argument_list|,
literal|"HEAD"
argument_list|,
name|remote_head
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|struct
name|strbuf
name|merge_names
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* We are invoked directly as the first-class UI. */
name|head_arg
operator|=
literal|"HEAD"
expr_stmt|;
comment|/* 		 * All the rest are the commits being merged; prepare 		 * the standard merge summary message to be appended 		 * to the given message. 		 */
name|remoteheads
operator|=
name|collect_parents
argument_list|(
name|head_commit
argument_list|,
operator|&
name|head_subsumed
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|remoteheads
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|merge_name
argument_list|(
name|merge_remote_util
argument_list|(
name|p
operator|->
name|item
argument_list|)
operator|->
name|name
argument_list|,
operator|&
name|merge_names
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_message
operator|||
name|shortlog_len
condition|)
block|{
name|struct
name|fmt_merge_msg_opts
name|opts
decl_stmt|;
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|add_title
operator|=
operator|!
name|have_message
expr_stmt|;
name|opts
operator|.
name|shortlog_len
operator|=
name|shortlog_len
expr_stmt|;
name|opts
operator|.
name|credit_people
operator|=
operator|(
literal|0
operator|<
name|option_edit
operator|)
expr_stmt|;
name|fmt_merge_msg
argument_list|(
operator|&
name|merge_names
argument_list|,
operator|&
name|merge_msg
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_msg
operator|.
name|len
condition|)
name|strbuf_setlen
argument_list|(
operator|&
name|merge_msg
argument_list|,
name|merge_msg
operator|.
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|head_commit
operator|||
operator|!
name|argc
condition|)
name|usage_with_options
argument_list|(
name|builtin_merge_usage
argument_list|,
name|builtin_merge_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_signatures
condition|)
block|{
for|for
control|(
name|p
operator|=
name|remoteheads
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|p
operator|->
name|item
decl_stmt|;
name|char
name|hex
index|[
literal|41
index|]
decl_stmt|;
name|struct
name|signature_check
name|signature_check
decl_stmt|;
name|memset
argument_list|(
operator|&
name|signature_check
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|signature_check
argument_list|)
argument_list|)
expr_stmt|;
name|check_commit_signature
argument_list|(
name|commit
argument_list|,
operator|&
name|signature_check
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hex
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|signature_check
operator|.
name|result
condition|)
block|{
case|case
literal|'G'
case|:
break|break;
case|case
literal|'U'
case|:
name|die
argument_list|(
name|_
argument_list|(
literal|"Commit %s has an untrusted GPG signature, "
literal|"allegedly by %s."
argument_list|)
argument_list|,
name|hex
argument_list|,
name|signature_check
operator|.
name|signer
argument_list|)
expr_stmt|;
case|case
literal|'B'
case|:
name|die
argument_list|(
name|_
argument_list|(
literal|"Commit %s has a bad GPG signature "
literal|"allegedly by %s."
argument_list|)
argument_list|,
name|hex
argument_list|,
name|signature_check
operator|.
name|signer
argument_list|)
expr_stmt|;
default|default:
comment|/* 'N' */
name|die
argument_list|(
name|_
argument_list|(
literal|"Commit %s does not have a GPG signature."
argument_list|)
argument_list|,
name|hex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|0
operator|&&
name|signature_check
operator|.
name|result
operator|==
literal|'G'
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Commit %s has a good GPG signature by %s\n"
argument_list|)
argument_list|,
name|hex
argument_list|,
name|signature_check
operator|.
name|signer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|signature_check
operator|.
name|gpg_output
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|signature_check
operator|.
name|gpg_status
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|signature_check
operator|.
name|signer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|signature_check
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"merge"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|remoteheads
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|" %s"
argument_list|,
name|merge_remote_util
argument_list|(
name|p
operator|->
name|item
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|remoteheads
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|p
operator|->
name|item
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"GITHEAD_%s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|merge_remote_util
argument_list|(
name|commit
argument_list|)
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fast_forward_only
operator|&&
name|merge_remote_util
argument_list|(
name|commit
argument_list|)
operator|&&
name|merge_remote_util
argument_list|(
name|commit
argument_list|)
operator|->
name|obj
operator|&&
name|merge_remote_util
argument_list|(
name|commit
argument_list|)
operator|->
name|obj
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
name|allow_fast_forward
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|option_edit
operator|<
literal|0
condition|)
name|option_edit
operator|=
name|default_edit_option
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|use_strategies
condition|)
block|{
if|if
condition|(
operator|!
name|remoteheads
condition|)
empty_stmt|;
comment|/* already up-to-date */
elseif|else
if|if
condition|(
operator|!
name|remoteheads
operator|->
name|next
condition|)
name|add_strategies
argument_list|(
name|pull_twohead
argument_list|,
name|DEFAULT_TWOHEAD
argument_list|)
expr_stmt|;
else|else
name|add_strategies
argument_list|(
name|pull_octopus
argument_list|,
name|DEFAULT_OCTOPUS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|use_strategies_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|use_strategies
index|[
name|i
index|]
operator|->
name|attr
operator|&
name|NO_FAST_FORWARD
condition|)
name|allow_fast_forward
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|use_strategies
index|[
name|i
index|]
operator|->
name|attr
operator|&
name|NO_TRIVIAL
condition|)
name|allow_trivial
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|remoteheads
condition|)
empty_stmt|;
comment|/* already up-to-date */
elseif|else
if|if
condition|(
operator|!
name|remoteheads
operator|->
name|next
condition|)
name|common
operator|=
name|get_merge_bases
argument_list|(
name|head_commit
argument_list|,
name|remoteheads
operator|->
name|item
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|remoteheads
decl_stmt|;
name|commit_list_insert
argument_list|(
name|head_commit
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|common
operator|=
name|get_octopus_merge_bases
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|update_ref
argument_list|(
literal|"updating ORIG_HEAD"
argument_list|,
literal|"ORIG_HEAD"
argument_list|,
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|DIE_ON_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|remoteheads
operator|&&
operator|!
name|common
condition|)
empty_stmt|;
comment|/* No common ancestors found. We need a real merge. */
elseif|else
if|if
condition|(
operator|!
name|remoteheads
operator|||
operator|(
operator|!
name|remoteheads
operator|->
name|next
operator|&&
operator|!
name|common
operator|->
name|next
operator|&&
name|common
operator|->
name|item
operator|==
name|remoteheads
operator|->
name|item
operator|)
condition|)
block|{
comment|/* 		 * If head can reach all the merge then we are up to date. 		 * but first the most common case of merging one remote. 		 */
name|finish_up_to_date
argument_list|(
literal|"Already up-to-date."
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|allow_fast_forward
operator|&&
operator|!
name|remoteheads
operator|->
name|next
operator|&&
operator|!
name|common
operator|->
name|next
operator|&&
operator|!
name|hashcmp
argument_list|(
name|common
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
comment|/* Again the most common case of merging one remote. */
name|struct
name|strbuf
name|msg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|char
name|hex
index|[
literal|41
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|hex
argument_list|,
name|find_unique_abbrev
argument_list|(
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Updating %s..%s\n"
argument_list|)
argument_list|,
name|hex
argument_list|,
name|find_unique_abbrev
argument_list|(
name|remoteheads
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msg
argument_list|,
literal|"Fast-forward"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_message
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|msg
argument_list|,
literal|" (no commit created; -m option ignored)"
argument_list|)
expr_stmt|;
name|commit
operator|=
name|remoteheads
operator|->
name|item
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|checkout_fast_forward
argument_list|(
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|overwrite_ignore
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|finish
argument_list|(
name|head_commit
argument_list|,
name|remoteheads
argument_list|,
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|msg
operator|.
name|buf
argument_list|)
expr_stmt|;
name|drop_save
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|remoteheads
operator|->
name|next
operator|&&
name|common
operator|->
name|next
condition|)
empty_stmt|;
comment|/* 		 * We are not doing octopus and not fast-forward.  Need 		 * a real merge. 		 */
elseif|else
if|if
condition|(
operator|!
name|remoteheads
operator|->
name|next
operator|&&
operator|!
name|common
operator|->
name|next
operator|&&
name|option_commit
condition|)
block|{
comment|/* 		 * We are not doing octopus, not fast-forward, and have 		 * only one common. 		 */
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|allow_trivial
operator|&&
operator|!
name|fast_forward_only
condition|)
block|{
comment|/* See if it is really trivial. */
name|git_committer_info
argument_list|(
name|IDENT_STRICT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Trying really trivial in-index merge...\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read_tree_trivial
argument_list|(
name|common
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|remoteheads
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|ret
operator|=
name|merge_trivial
argument_list|(
name|head_commit
argument_list|,
name|remoteheads
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Nope.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * An octopus.  If we can reach all the remote we are up 		 * to date. 		 */
name|int
name|up_to_date
init|=
literal|1
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|remoteheads
init|;
name|j
condition|;
name|j
operator|=
name|j
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|common_one
decl_stmt|;
comment|/* 			 * Here we *have* to calculate the individual 			 * merge_bases again, otherwise "git merge HEAD^ 			 * HEAD^^" would be missed. 			 */
name|common_one
operator|=
name|get_merge_bases
argument_list|(
name|head_commit
argument_list|,
name|j
operator|->
name|item
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|common_one
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|j
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|up_to_date
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|up_to_date
condition|)
block|{
name|finish_up_to_date
argument_list|(
literal|"Already up-to-date. Yeeah!"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|fast_forward_only
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Not possible to fast-forward, aborting."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are going to make a new commit. */
name|git_committer_info
argument_list|(
name|IDENT_STRICT
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, we need a real merge.  No matter what strategy 	 * we use, it would operate on the index, possibly affecting the 	 * working tree, and when resolved cleanly, have the desired 	 * tree in the index -- this means that the index must be in 	 * sync with the head commit.  The strategies are responsible 	 * to ensure this. 	 */
if|if
condition|(
name|use_strategies_nr
operator|==
literal|1
operator|||
comment|/* 	     * Stash away the local changes so that we can try more than one. 	     */
name|save_state
argument_list|(
name|stash
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|stash
argument_list|,
name|null_sha1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|use_strategies_nr
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Rewinding the tree to pristine...\n"
argument_list|)
argument_list|)
expr_stmt|;
name|restore_state
argument_list|(
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|stash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_strategies_nr
operator|!=
literal|1
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Trying merge strategy %s...\n"
argument_list|)
argument_list|,
name|use_strategies
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * Remember which strategy left the state in the working 		 * tree. 		 */
name|wt_strategy
operator|=
name|use_strategies
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|ret
operator|=
name|try_merge_strategy
argument_list|(
name|use_strategies
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|common
argument_list|,
name|remoteheads
argument_list|,
name|head_commit
argument_list|,
name|head_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|option_commit
operator|&&
operator|!
name|ret
condition|)
block|{
name|merge_was_ok
operator|=
literal|1
expr_stmt|;
comment|/* 			 * This is necessary here just to avoid writing 			 * the tree, but later we will *not* exit with 			 * status code 1 because merge_was_ok is set. 			 */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 			 * The backend exits with 1 when conflicts are 			 * left to be resolved, with 2 when it does not 			 * handle the given merge at all. 			 */
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|int
name|cnt
init|=
name|evaluate_result
argument_list|()
decl_stmt|;
if|if
condition|(
name|best_cnt
operator|<=
literal|0
operator|||
name|cnt
operator|<=
name|best_cnt
condition|)
block|{
name|best_strategy
operator|=
name|use_strategies
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|best_cnt
operator|=
name|cnt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|merge_was_ok
condition|)
break|break;
else|else
continue|continue;
block|}
comment|/* Automerge succeeded. */
name|write_tree_trivial
argument_list|(
name|result_tree
argument_list|)
expr_stmt|;
name|automerge_was_ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * If we have a resulting tree, that means the strategy module 	 * auto resolved the merge cleanly. 	 */
if|if
condition|(
name|automerge_was_ok
condition|)
block|{
name|ret
operator|=
name|finish_automerge
argument_list|(
name|head_commit
argument_list|,
name|head_subsumed
argument_list|,
name|common
argument_list|,
name|remoteheads
argument_list|,
name|result_tree
argument_list|,
name|wt_strategy
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Pick the result from the best strategy and have the user fix 	 * it up. 	 */
if|if
condition|(
operator|!
name|best_strategy
condition|)
block|{
name|restore_state
argument_list|(
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_strategies_nr
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"No merge strategy handled the merge.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Merge with strategy %s failed.\n"
argument_list|)
argument_list|,
name|use_strategies
index|[
literal|0
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|2
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|best_strategy
operator|==
name|wt_strategy
condition|)
empty_stmt|;
comment|/* We already have its result in the working tree. */
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Rewinding the tree to pristine...\n"
argument_list|)
argument_list|)
expr_stmt|;
name|restore_state
argument_list|(
name|head_commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|stash
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Using the %s to prepare resolving by hand.\n"
argument_list|)
argument_list|,
name|best_strategy
argument_list|)
expr_stmt|;
name|try_merge_strategy
argument_list|(
name|best_strategy
argument_list|,
name|common
argument_list|,
name|remoteheads
argument_list|,
name|head_commit
argument_list|,
name|head_arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|squash
condition|)
name|finish
argument_list|(
name|head_commit
argument_list|,
name|remoteheads
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|write_merge_state
argument_list|(
name|remoteheads
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_was_ok
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Automatic merge went well; "
literal|"stopped before committing as requested\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|suggest_conflicts
argument_list|(
name|option_renormalize
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|branch_to_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
end_unit
