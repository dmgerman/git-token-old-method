begin_unit
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_comment
comment|/* Quoting styles */
end_comment
begin_define
DECL|macro|QUOTE_NONE
define|#
directive|define
name|QUOTE_NONE
value|0
end_define
begin_define
DECL|macro|QUOTE_SHELL
define|#
directive|define
name|QUOTE_SHELL
value|1
end_define
begin_define
DECL|macro|QUOTE_PERL
define|#
directive|define
name|QUOTE_PERL
value|2
end_define
begin_define
DECL|macro|QUOTE_PYTHON
define|#
directive|define
name|QUOTE_PYTHON
value|4
end_define
begin_define
DECL|macro|QUOTE_TCL
define|#
directive|define
name|QUOTE_TCL
value|8
end_define
begin_typedef
DECL|enumerator|FIELD_STR
DECL|enumerator|FIELD_ULONG
DECL|enumerator|FIELD_TIME
DECL|typedef|cmp_type
typedef|typedef
enum|enum
block|{
name|FIELD_STR
block|,
name|FIELD_ULONG
block|,
name|FIELD_TIME
block|}
name|cmp_type
typedef|;
end_typedef
begin_struct
DECL|struct|atom_value
struct|struct
name|atom_value
block|{
DECL|member|s
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
DECL|member|ul
name|unsigned
name|long
name|ul
decl_stmt|;
comment|/* used for sorting when not FIELD_STR */
block|}
struct|;
end_struct
begin_struct
DECL|struct|ref_sort
struct|struct
name|ref_sort
block|{
DECL|member|next
name|struct
name|ref_sort
modifier|*
name|next
decl_stmt|;
DECL|member|atom
name|int
name|atom
decl_stmt|;
comment|/* index into used_atom array */
DECL|member|reverse
name|unsigned
name|reverse
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|refinfo
struct|struct
name|refinfo
block|{
DECL|member|refname
name|char
modifier|*
name|refname
decl_stmt|;
DECL|member|objectname
name|unsigned
name|char
name|objectname
index|[
literal|20
index|]
decl_stmt|;
DECL|member|flag
name|int
name|flag
decl_stmt|;
DECL|member|symref
specifier|const
name|char
modifier|*
name|symref
decl_stmt|;
DECL|member|value
name|struct
name|atom_value
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
specifier|static
struct|struct
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|cmp_type
name|cmp_type
name|cmp_type
decl_stmt|;
block|}
DECL|variable|valid_atom
name|valid_atom
index|[]
init|=
block|{
block|{
literal|"refname"
block|}
block|,
block|{
literal|"objecttype"
block|}
block|,
block|{
literal|"objectsize"
block|,
name|FIELD_ULONG
block|}
block|,
block|{
literal|"objectname"
block|}
block|,
block|{
literal|"tree"
block|}
block|,
block|{
literal|"parent"
block|}
block|,
block|{
literal|"numparent"
block|,
name|FIELD_ULONG
block|}
block|,
block|{
literal|"object"
block|}
block|,
block|{
literal|"type"
block|}
block|,
block|{
literal|"tag"
block|}
block|,
block|{
literal|"author"
block|}
block|,
block|{
literal|"authorname"
block|}
block|,
block|{
literal|"authoremail"
block|}
block|,
block|{
literal|"authordate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"committer"
block|}
block|,
block|{
literal|"committername"
block|}
block|,
block|{
literal|"committeremail"
block|}
block|,
block|{
literal|"committerdate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"tagger"
block|}
block|,
block|{
literal|"taggername"
block|}
block|,
block|{
literal|"taggeremail"
block|}
block|,
block|{
literal|"taggerdate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"creator"
block|}
block|,
block|{
literal|"creatordate"
block|,
name|FIELD_TIME
block|}
block|,
block|{
literal|"subject"
block|}
block|,
block|{
literal|"body"
block|}
block|,
block|{
literal|"contents"
block|}
block|,
block|{
literal|"contents:subject"
block|}
block|,
block|{
literal|"contents:body"
block|}
block|,
block|{
literal|"contents:signature"
block|}
block|,
block|{
literal|"upstream"
block|}
block|,
block|{
literal|"symref"
block|}
block|,
block|{
literal|"flag"
block|}
block|,
block|{
literal|"HEAD"
block|}
block|,
block|{
literal|"color"
block|}
block|, }
struct|;
end_struct
begin_comment
comment|/*  * An atom is a valid field atom listed above, possibly prefixed with  * a "*" to denote deref_tag().  *  * We parse given format string and sort specifiers, and make a list  * of properties that we need to extract out of objects.  refinfo  * structure will hold an array of values extracted that can be  * indexed with the "atom number", which is an index into this  * array.  */
end_comment
begin_decl_stmt
DECL|variable|used_atom
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|used_atom
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|used_atom_type
specifier|static
name|cmp_type
modifier|*
name|used_atom_type
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|used_atom_cnt
DECL|variable|sort_atom_limit
DECL|variable|need_tagged
DECL|variable|need_symref
specifier|static
name|int
name|used_atom_cnt
decl_stmt|,
name|sort_atom_limit
decl_stmt|,
name|need_tagged
decl_stmt|,
name|need_symref
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Used to parse format string and sort specifiers  */
end_comment
begin_function
DECL|function|parse_atom
specifier|static
name|int
name|parse_atom
parameter_list|(
specifier|const
name|char
modifier|*
name|atom
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|at
decl_stmt|;
name|sp
operator|=
name|atom
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'*'
operator|&&
name|sp
operator|<
name|ep
condition|)
name|sp
operator|++
expr_stmt|;
comment|/* deref */
if|if
condition|(
name|ep
operator|<=
name|sp
condition|)
name|die
argument_list|(
literal|"malformed field name: %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|atom
argument_list|)
argument_list|,
name|atom
argument_list|)
expr_stmt|;
comment|/* Do we have the atom already used elsewhere? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|used_atom
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|ep
operator|-
name|atom
operator|&&
operator|!
name|memcmp
argument_list|(
name|used_atom
index|[
name|i
index|]
argument_list|,
name|atom
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|i
return|;
block|}
comment|/* Is the atom a valid one? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|valid_atom
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|valid_atom
index|[
name|i
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
comment|/* 		 * If the atom name has a colon, strip it and everything after 		 * it off - it specifies the format for this entry, and 		 * shouldn't be used for checking against the valid_atom 		 * table. 		 */
specifier|const
name|char
modifier|*
name|formatp
init|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|formatp
operator|||
name|ep
operator|<
name|formatp
condition|)
name|formatp
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|formatp
operator|-
name|sp
operator|&&
operator|!
name|memcmp
argument_list|(
name|valid_atom
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|valid_atom
argument_list|)
operator|<=
name|i
condition|)
name|die
argument_list|(
literal|"unknown field name: %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|atom
argument_list|)
argument_list|,
name|atom
argument_list|)
expr_stmt|;
comment|/* Add it in, including the deref prefix */
name|at
operator|=
name|used_atom_cnt
expr_stmt|;
name|used_atom_cnt
operator|++
expr_stmt|;
name|used_atom
operator|=
name|xrealloc
argument_list|(
name|used_atom
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|used_atom
operator|)
operator|*
name|used_atom_cnt
argument_list|)
expr_stmt|;
name|used_atom_type
operator|=
name|xrealloc
argument_list|(
name|used_atom_type
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|used_atom_type
argument_list|)
operator|*
name|used_atom_cnt
operator|)
argument_list|)
expr_stmt|;
name|used_atom
index|[
name|at
index|]
operator|=
name|xmemdupz
argument_list|(
name|atom
argument_list|,
name|ep
operator|-
name|atom
argument_list|)
expr_stmt|;
name|used_atom_type
index|[
name|at
index|]
operator|=
name|valid_atom
index|[
name|i
index|]
operator|.
name|cmp_type
expr_stmt|;
if|if
condition|(
operator|*
name|atom
operator|==
literal|'*'
condition|)
name|need_tagged
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|used_atom
index|[
name|at
index|]
argument_list|,
literal|"symref"
argument_list|)
condition|)
name|need_symref
operator|=
literal|1
expr_stmt|;
return|return
name|at
return|;
block|}
end_function
begin_comment
comment|/*  * In a format string, find the next occurrence of %(atom).  */
end_comment
begin_function
DECL|function|find_next
specifier|static
specifier|const
name|char
modifier|*
name|find_next
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
comment|/* 			 * %( is the start of an atom; 			 * %% is a quoted per-cent. 			 */
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
return|return
name|cp
return|;
elseif|else
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* skip over two % */
comment|/* otherwise this is a singleton, literal % */
block|}
name|cp
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Make sure the format string is well formed, and parse out  * the used atoms.  */
end_comment
begin_function
DECL|function|verify_format
specifier|static
name|int
name|verify_format
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|format
init|;
operator|*
name|cp
operator|&&
operator|(
name|sp
operator|=
name|find_next
argument_list|(
name|cp
argument_list|)
operator|)
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|ep
init|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
return|return
name|error
argument_list|(
literal|"malformed format string %s"
argument_list|,
name|sp
argument_list|)
return|;
comment|/* sp points at "%(" and ep points at the closing ")" */
name|parse_atom
argument_list|(
name|sp
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given an object name, read the object data and size, and return a  * "struct object".  If the object data we are returning is also borrowed  * by the "struct object" representation, set *eaten as well---it is a  * signal from parse_object_buffer to us not to free the buffer.  */
end_comment
begin_function
DECL|function|get_obj
specifier|static
name|void
modifier|*
name|get_obj
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|object
modifier|*
modifier|*
name|obj
parameter_list|,
name|unsigned
name|long
modifier|*
name|sz
parameter_list|,
name|int
modifier|*
name|eaten
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
condition|)
operator|*
name|obj
operator|=
name|parse_object_buffer
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
operator|*
name|sz
argument_list|,
name|buf
argument_list|,
name|eaten
argument_list|)
expr_stmt|;
else|else
operator|*
name|obj
operator|=
name|NULL
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_common_values
specifier|static
name|void
name|grab_common_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objecttype"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|typename
argument_list|(
name|obj
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objectsize"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|40
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|v
operator|->
name|ul
operator|=
name|sz
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objectname"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|sha1_to_hex
argument_list|(
name|obj
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"objectname:short"
argument_list|)
condition|)
block|{
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|find_unique_abbrev
argument_list|(
name|obj
operator|->
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_tag_values
specifier|static
name|void
name|grab_tag_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tag
modifier|*
name|tag
init|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|obj
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"tag"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|tag
operator|->
name|tag
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"type"
argument_list|)
operator|&&
name|tag
operator|->
name|tagged
condition|)
name|v
operator|->
name|s
operator|=
name|typename
argument_list|(
name|tag
operator|->
name|tagged
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"object"
argument_list|)
operator|&&
name|tag
operator|->
name|tagged
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|sha1_to_hex
argument_list|(
name|tag
operator|->
name|tagged
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|num_parents
specifier|static
name|int
name|num_parents
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_commit_values
specifier|static
name|void
name|grab_commit_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"tree"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"numparent"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|40
argument_list|)
decl_stmt|;
name|v
operator|->
name|ul
operator|=
name|num_parents
argument_list|(
name|commit
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
name|v
operator|->
name|ul
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"parent"
argument_list|)
condition|)
block|{
name|int
name|num
init|=
name|num_parents
argument_list|(
name|commit
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
literal|41
operator|*
name|num
operator|+
literal|1
argument_list|)
decl_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
operator|,
name|i
operator|=
name|i
operator|+
literal|41
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
name|i
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parents
operator|->
name|next
condition|)
name|s
index|[
name|i
operator|+
literal|40
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|find_wholine
specifier|static
specifier|const
name|char
modifier|*
name|find_wholine
parameter_list|(
specifier|const
name|char
modifier|*
name|who
parameter_list|,
name|int
name|wholen
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
while|while
condition|(
operator|*
name|buf
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|who
argument_list|,
name|wholen
argument_list|)
operator|&&
name|buf
index|[
name|wholen
index|]
operator|==
literal|' '
condition|)
return|return
name|buf
operator|+
name|wholen
operator|+
literal|1
return|;
name|eol
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
condition|)
return|return
literal|""
return|;
name|eol
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|eol
operator|==
literal|'\n'
condition|)
return|return
literal|""
return|;
comment|/* end of header */
name|buf
operator|=
name|eol
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function
begin_function
DECL|function|copy_line
specifier|static
specifier|const
name|char
modifier|*
name|copy_line
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
init|=
name|strchrnul
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
return|return
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|eol
operator|-
name|buf
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|copy_name
specifier|static
specifier|const
name|char
modifier|*
name|copy_name
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"<"
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|buf
argument_list|)
return|;
block|}
return|return
literal|""
return|;
block|}
end_function
begin_function
DECL|function|copy_email
specifier|static
specifier|const
name|char
modifier|*
name|copy_email
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|email
init|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'<'
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|eoemail
decl_stmt|;
if|if
condition|(
operator|!
name|email
condition|)
return|return
literal|""
return|;
name|eoemail
operator|=
name|strchr
argument_list|(
name|email
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eoemail
condition|)
return|return
literal|""
return|;
return|return
name|xmemdupz
argument_list|(
name|email
argument_list|,
name|eoemail
operator|+
literal|1
operator|-
name|email
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|copy_subject
specifier|static
name|char
modifier|*
name|copy_subject
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|char
modifier|*
name|r
init|=
name|xmemdupz
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|r
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|grab_date
specifier|static
name|void
name|grab_date
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|struct
name|atom_value
modifier|*
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|atomname
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eoemail
init|=
name|strstr
argument_list|(
name|buf
argument_list|,
literal|"> "
argument_list|)
decl_stmt|;
name|char
modifier|*
name|zone
decl_stmt|;
name|unsigned
name|long
name|timestamp
decl_stmt|;
name|long
name|tz
decl_stmt|;
name|enum
name|date_mode
name|date_mode
init|=
name|DATE_NORMAL
decl_stmt|;
specifier|const
name|char
modifier|*
name|formatp
decl_stmt|;
comment|/* 	 * We got here because atomname ends in "date" or "date<something>"; 	 * it's not possible that<something> is not ":<format>" because 	 * parse_atom() wouldn't have allowed it, so we can assume that no 	 * ":" means no format is specified, and use the default. 	 */
name|formatp
operator|=
name|strchr
argument_list|(
name|atomname
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatp
operator|!=
name|NULL
condition|)
block|{
name|formatp
operator|++
expr_stmt|;
name|date_mode
operator|=
name|parse_date_format
argument_list|(
name|formatp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eoemail
condition|)
goto|goto
name|bad
goto|;
name|timestamp
operator|=
name|strtoul
argument_list|(
name|eoemail
operator|+
literal|2
argument_list|,
operator|&
name|zone
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp
operator|==
name|ULONG_MAX
condition|)
goto|goto
name|bad
goto|;
name|tz
operator|=
name|strtol
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tz
operator|==
name|LONG_MIN
operator|||
name|tz
operator|==
name|LONG_MAX
operator|)
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
goto|goto
name|bad
goto|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|show_date
argument_list|(
name|timestamp
argument_list|,
name|tz
argument_list|,
name|date_mode
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|ul
operator|=
name|timestamp
expr_stmt|;
return|return;
name|bad
label|:
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
name|v
operator|->
name|ul
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_person
specifier|static
name|void
name|grab_person
parameter_list|(
specifier|const
name|char
modifier|*
name|who
parameter_list|,
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|wholen
init|=
name|strlen
argument_list|(
name|who
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|wholine
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|who
argument_list|,
name|name
argument_list|,
name|wholen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|name
index|[
name|wholen
index|]
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"name"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"email"
argument_list|)
operator|&&
name|prefixcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"date"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|wholine
condition|)
name|wholine
operator|=
name|find_wholine
argument_list|(
name|who
argument_list|,
name|wholen
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wholine
condition|)
return|return;
comment|/* no point looking for it */
if|if
condition|(
name|name
index|[
name|wholen
index|]
operator|==
literal|0
condition|)
name|v
operator|->
name|s
operator|=
name|copy_line
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"name"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_name
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"email"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_email
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
operator|+
name|wholen
argument_list|,
literal|"date"
argument_list|)
condition|)
name|grab_date
argument_list|(
name|wholine
argument_list|,
name|v
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For a tag or a commit object, if "creator" or "creatordate" is 	 * requested, do something special. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|who
argument_list|,
literal|"tagger"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|who
argument_list|,
literal|"committer"
argument_list|)
condition|)
return|return;
comment|/* "author" for commit object is not wanted */
if|if
condition|(
operator|!
name|wholine
condition|)
name|wholine
operator|=
name|find_wholine
argument_list|(
name|who
argument_list|,
name|wholen
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wholine
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"creatordate"
argument_list|)
condition|)
name|grab_date
argument_list|(
name|wholine
argument_list|,
name|v
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"creator"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_line
argument_list|(
name|wholine
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|find_subpos
specifier|static
name|void
name|find_subpos
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sub
parameter_list|,
name|unsigned
name|long
modifier|*
name|sublen
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|body
parameter_list|,
name|unsigned
name|long
modifier|*
name|bodylen
parameter_list|,
name|unsigned
name|long
modifier|*
name|nonsiglen
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|sig
parameter_list|,
name|unsigned
name|long
modifier|*
name|siglen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
comment|/* skip past header until we hit empty line */
while|while
condition|(
operator|*
name|buf
operator|&&
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
name|eol
operator|=
name|strchrnul
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eol
condition|)
name|eol
operator|++
expr_stmt|;
name|buf
operator|=
name|eol
expr_stmt|;
block|}
comment|/* skip any empty lines */
while|while
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
name|buf
operator|++
expr_stmt|;
comment|/* parse signature first; we might not even have a subject line */
operator|*
name|sig
operator|=
name|buf
operator|+
name|parse_signature
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|siglen
operator|=
name|strlen
argument_list|(
operator|*
name|sig
argument_list|)
expr_stmt|;
comment|/* subject is first non-empty line */
operator|*
name|sub
operator|=
name|buf
expr_stmt|;
comment|/* subject goes to first empty line */
while|while
condition|(
name|buf
operator|<
operator|*
name|sig
operator|&&
operator|*
name|buf
operator|&&
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
name|eol
operator|=
name|strchrnul
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eol
condition|)
name|eol
operator|++
expr_stmt|;
name|buf
operator|=
name|eol
expr_stmt|;
block|}
operator|*
name|sublen
operator|=
name|buf
operator|-
operator|*
name|sub
expr_stmt|;
comment|/* drop trailing newline, if present */
if|if
condition|(
operator|*
name|sublen
operator|&&
operator|(
operator|*
name|sub
operator|)
index|[
operator|*
name|sublen
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|*
name|sublen
operator|-=
literal|1
expr_stmt|;
comment|/* skip any empty lines */
while|while
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
name|buf
operator|++
expr_stmt|;
operator|*
name|body
operator|=
name|buf
expr_stmt|;
operator|*
name|bodylen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|nonsiglen
operator|=
operator|*
name|sig
operator|-
name|buf
expr_stmt|;
block|}
end_function
begin_comment
comment|/* See grab_values */
end_comment
begin_function
DECL|function|grab_sub_body_contents
specifier|static
name|void
name|grab_sub_body_contents
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|subpos
init|=
name|NULL
decl_stmt|,
modifier|*
name|bodypos
init|=
name|NULL
decl_stmt|,
modifier|*
name|sigpos
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|sublen
init|=
literal|0
decl_stmt|,
name|bodylen
init|=
literal|0
decl_stmt|,
name|nonsiglen
init|=
literal|0
decl_stmt|,
name|siglen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|!
name|deref
operator|!=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|deref
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"subject"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"body"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:subject"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:body"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:signature"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|subpos
condition|)
name|find_subpos
argument_list|(
name|buf
argument_list|,
name|sz
argument_list|,
operator|&
name|subpos
argument_list|,
operator|&
name|sublen
argument_list|,
operator|&
name|bodypos
argument_list|,
operator|&
name|bodylen
argument_list|,
operator|&
name|nonsiglen
argument_list|,
operator|&
name|sigpos
argument_list|,
operator|&
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"subject"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_subject
argument_list|(
name|subpos
argument_list|,
name|sublen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:subject"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|copy_subject
argument_list|(
name|subpos
argument_list|,
name|sublen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"body"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xmemdupz
argument_list|(
name|bodypos
argument_list|,
name|bodylen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:body"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xmemdupz
argument_list|(
name|bodypos
argument_list|,
name|nonsiglen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents:signature"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xmemdupz
argument_list|(
name|sigpos
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"contents"
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|subpos
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * We want to have empty print-string for field requests  * that do not apply (e.g. "authordate" for a tag object)  */
end_comment
begin_function
DECL|function|fill_missing_values
specifier|static
name|void
name|fill_missing_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|val
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|s
operator|==
name|NULL
condition|)
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * val is a list of atom_value to hold returned values.  Extract  * the values for atoms in used_atom array out of (obj, buf, sz).  * when deref is false, (obj, buf, sz) is the object that is  * pointed at by the ref itself; otherwise it is the object the  * ref (which is a tag) refers to.  */
end_comment
begin_function
DECL|function|grab_values
specifier|static
name|void
name|grab_values
parameter_list|(
name|struct
name|atom_value
modifier|*
name|val
parameter_list|,
name|int
name|deref
parameter_list|,
name|struct
name|object
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|sz
parameter_list|)
block|{
name|grab_common_values
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|OBJ_TAG
case|:
name|grab_tag_values
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_sub_body_contents
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_person
argument_list|(
literal|"tagger"
argument_list|,
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
name|grab_commit_values
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_sub_body_contents
argument_list|(
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_person
argument_list|(
literal|"author"
argument_list|,
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|grab_person
argument_list|(
literal|"committer"
argument_list|,
name|val
argument_list|,
name|deref
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_TREE
case|:
comment|/* grab_tree_values(val, deref, obj, buf, sz); */
break|break;
case|case
name|OBJ_BLOB
case|:
comment|/* grab_blob_values(val, deref, obj, buf, sz); */
break|break;
default|default:
name|die
argument_list|(
literal|"Eh?  Object of type %d?"
argument_list|,
name|obj
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copy_advance
specifier|static
specifier|inline
name|char
modifier|*
name|copy_advance
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
while|while
condition|(
operator|*
name|src
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function
begin_comment
comment|/*  * Parse the object referred by ref, and grab needed value.  */
end_comment
begin_function
DECL|function|populate_value
specifier|static
name|void
name|populate_value
parameter_list|(
name|struct
name|refinfo
modifier|*
name|ref
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
name|int
name|eaten
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|tagged
decl_stmt|;
name|ref
operator|->
name|value
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|atom_value
argument_list|)
argument_list|,
name|used_atom_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_symref
operator|&&
operator|(
name|ref
operator|->
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
operator|!
name|ref
operator|->
name|symref
condition|)
block|{
name|unsigned
name|char
name|unused1
index|[
literal|20
index|]
decl_stmt|;
name|ref
operator|->
name|symref
operator|=
name|resolve_refdup
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
name|unused1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|->
name|symref
condition|)
name|ref
operator|->
name|symref
operator|=
literal|""
expr_stmt|;
block|}
comment|/* Fill in specials first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|used_atom
index|[
name|i
index|]
decl_stmt|;
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|ref
operator|->
name|value
index|[
name|i
index|]
decl_stmt|;
name|int
name|deref
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|refname
decl_stmt|;
specifier|const
name|char
modifier|*
name|formatp
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'*'
condition|)
block|{
name|deref
operator|=
literal|1
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refname"
argument_list|)
condition|)
name|refname
operator|=
name|ref
operator|->
name|refname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"symref"
argument_list|)
condition|)
name|refname
operator|=
name|ref
operator|->
name|symref
condition|?
name|ref
operator|->
name|symref
else|:
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"upstream"
argument_list|)
condition|)
block|{
comment|/* only local branches may have an upstream */
if|if
condition|(
name|prefixcmp
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
continue|continue;
name|branch
operator|=
name|branch_get
argument_list|(
name|ref
operator|->
name|refname
operator|+
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
operator|||
operator|!
name|branch
operator|->
name|merge
operator|||
operator|!
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|||
operator|!
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
condition|)
continue|continue;
name|refname
operator|=
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"color:"
argument_list|)
condition|)
block|{
name|char
name|color
index|[
name|COLOR_MAXLEN
index|]
init|=
literal|""
decl_stmt|;
name|color_parse
argument_list|(
name|name
operator|+
literal|6
argument_list|,
literal|"--format"
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|color
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"flag"
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|ref
operator|->
name|flag
operator|&
name|REF_ISSYMREF
condition|)
name|cp
operator|=
name|copy_advance
argument_list|(
name|cp
argument_list|,
literal|",symref"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|flag
operator|&
name|REF_ISPACKED
condition|)
name|cp
operator|=
name|copy_advance
argument_list|(
name|cp
argument_list|,
literal|",packed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
else|else
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|head
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|head
operator|=
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ref
operator|->
name|refname
argument_list|,
name|head
argument_list|)
condition|)
name|v
operator|->
name|s
operator|=
literal|"*"
expr_stmt|;
else|else
name|v
operator|->
name|s
operator|=
literal|" "
expr_stmt|;
continue|continue;
block|}
else|else
continue|continue;
name|formatp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatp
condition|)
block|{
name|int
name|num_ours
decl_stmt|,
name|num_theirs
decl_stmt|;
name|formatp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|formatp
argument_list|,
literal|"short"
argument_list|)
condition|)
name|refname
operator|=
name|shorten_unambiguous_ref
argument_list|(
name|refname
argument_list|,
name|warn_ambiguous_refs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|formatp
argument_list|,
literal|"track"
argument_list|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"upstream"
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|num_ours
argument_list|,
operator|&
name|num_theirs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_ours
operator|&&
operator|!
name|num_theirs
condition|)
name|v
operator|->
name|s
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num_ours
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[behind %d]"
argument_list|,
name|num_theirs
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|num_theirs
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[ahead %d]"
argument_list|,
name|num_ours
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[ahead %d, behind %d]"
argument_list|,
name|num_ours
argument_list|,
name|num_theirs
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|formatp
argument_list|,
literal|"trackshort"
argument_list|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"upstream"
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|num_ours
argument_list|,
operator|&
name|num_theirs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_ours
operator|&&
operator|!
name|num_theirs
condition|)
name|v
operator|->
name|s
operator|=
literal|"="
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num_ours
condition|)
name|v
operator|->
name|s
operator|=
literal|"<"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num_theirs
condition|)
name|v
operator|->
name|s
operator|=
literal|">"
expr_stmt|;
else|else
name|v
operator|->
name|s
operator|=
literal|"<>"
expr_stmt|;
continue|continue;
block|}
else|else
name|die
argument_list|(
literal|"unknown %.*s format %s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|formatp
operator|-
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|formatp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|deref
condition|)
name|v
operator|->
name|s
operator|=
name|refname
expr_stmt|;
else|else
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|4
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s^{}"
argument_list|,
name|refname
argument_list|)
expr_stmt|;
name|v
operator|->
name|s
operator|=
name|s
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used_atom_cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|atom_value
modifier|*
name|v
init|=
operator|&
name|ref
operator|->
name|value
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|s
operator|==
name|NULL
condition|)
goto|goto
name|need_obj
goto|;
block|}
return|return;
name|need_obj
label|:
name|buf
operator|=
name|get_obj
argument_list|(
name|ref
operator|->
name|objectname
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|eaten
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"missing object %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|objectname
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|die
argument_list|(
literal|"parse_object_buffer failed on %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|objectname
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
name|grab_values
argument_list|(
name|ref
operator|->
name|value
argument_list|,
literal|0
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eaten
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no atom that wants to know about tagged 	 * object, we are done. 	 */
if|if
condition|(
operator|!
name|need_tagged
operator|||
operator|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_TAG
operator|)
condition|)
return|return;
comment|/* 	 * If it is a tag object, see if we use a value that derefs 	 * the object, and if we do grab the object it refers to. 	 */
name|tagged
operator|=
operator|(
operator|(
expr|struct
name|tag
operator|*
operator|)
name|obj
operator|)
operator|->
name|tagged
operator|->
name|sha1
expr_stmt|;
comment|/* 	 * NEEDSWORK: This derefs tag only once, which 	 * is good to deal with chains of trust, but 	 * is not consistent with what deref_tag() does 	 * which peels the onion to the core. 	 */
name|buf
operator|=
name|get_obj
argument_list|(
name|tagged
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|eaten
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|die
argument_list|(
literal|"missing object %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tagged
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|die
argument_list|(
literal|"parse_object_buffer failed on %s for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tagged
argument_list|)
argument_list|,
name|ref
operator|->
name|refname
argument_list|)
expr_stmt|;
name|grab_values
argument_list|(
name|ref
operator|->
name|value
argument_list|,
literal|1
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eaten
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Given a ref, return the value for the atom.  This lazily gets value  * out of the object by calling populate value.  */
end_comment
begin_function
DECL|function|get_value
specifier|static
name|void
name|get_value
parameter_list|(
name|struct
name|refinfo
modifier|*
name|ref
parameter_list|,
name|int
name|atom
parameter_list|,
name|struct
name|atom_value
modifier|*
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ref
operator|->
name|value
condition|)
block|{
name|populate_value
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|fill_missing_values
argument_list|(
name|ref
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
operator|*
name|v
operator|=
operator|&
name|ref
operator|->
name|value
index|[
name|atom
index|]
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|grab_ref_cbdata
struct|struct
name|grab_ref_cbdata
block|{
DECL|member|grab_array
name|struct
name|refinfo
modifier|*
modifier|*
name|grab_array
decl_stmt|;
DECL|member|grab_pattern
specifier|const
name|char
modifier|*
modifier|*
name|grab_pattern
decl_stmt|;
DECL|member|grab_cnt
name|int
name|grab_cnt
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * A call-back given to for_each_ref().  Filter refs and keep them for  * later object processing.  */
end_comment
begin_function
DECL|function|grab_single_ref
specifier|static
name|int
name|grab_single_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|grab_ref_cbdata
modifier|*
name|cb
init|=
name|cb_data
decl_stmt|;
name|struct
name|refinfo
modifier|*
name|ref
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
operator|*
name|cb
operator|->
name|grab_pattern
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|pattern
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|refname
argument_list|)
decl_stmt|;
for|for
control|(
name|pattern
operator|=
name|cb
operator|->
name|grab_pattern
init|;
operator|*
name|pattern
condition|;
name|pattern
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pattern
decl_stmt|;
name|int
name|plen
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|plen
operator|<=
name|namelen
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|refname
argument_list|,
name|p
argument_list|,
name|plen
argument_list|)
operator|&&
operator|(
name|refname
index|[
name|plen
index|]
operator|==
literal|'\0'
operator|||
name|refname
index|[
name|plen
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
name|plen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
name|p
argument_list|,
name|refname
argument_list|,
name|FNM_PATHNAME
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
return|return
literal|0
return|;
block|}
comment|/* 	 * We do not open the object yet; sort may only need refname 	 * to do its job and the resulting list may yet to be pruned 	 * by maxcount logic. 	 */
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|->
name|refname
operator|=
name|xstrdup
argument_list|(
name|refname
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|objectname
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|ref
operator|->
name|flag
operator|=
name|flag
expr_stmt|;
name|cnt
operator|=
name|cb
operator|->
name|grab_cnt
expr_stmt|;
name|cb
operator|->
name|grab_array
operator|=
name|xrealloc
argument_list|(
name|cb
operator|->
name|grab_array
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cb
operator|->
name|grab_array
argument_list|)
operator|*
operator|(
name|cnt
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|grab_array
index|[
name|cnt
operator|++
index|]
operator|=
name|ref
expr_stmt|;
name|cb
operator|->
name|grab_cnt
operator|=
name|cnt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmp_ref_sort
specifier|static
name|int
name|cmp_ref_sort
parameter_list|(
name|struct
name|ref_sort
modifier|*
name|s
parameter_list|,
name|struct
name|refinfo
modifier|*
name|a
parameter_list|,
name|struct
name|refinfo
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|atom_value
modifier|*
name|va
decl_stmt|,
modifier|*
name|vb
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|cmp_type
name|cmp_type
init|=
name|used_atom_type
index|[
name|s
operator|->
name|atom
index|]
decl_stmt|;
name|get_value
argument_list|(
name|a
argument_list|,
name|s
operator|->
name|atom
argument_list|,
operator|&
name|va
argument_list|)
expr_stmt|;
name|get_value
argument_list|(
name|b
argument_list|,
name|s
operator|->
name|atom
argument_list|,
operator|&
name|vb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmp_type
condition|)
block|{
case|case
name|FIELD_STR
case|:
name|cmp
operator|=
name|strcmp
argument_list|(
name|va
operator|->
name|s
argument_list|,
name|vb
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|va
operator|->
name|ul
operator|<
name|vb
operator|->
name|ul
condition|)
name|cmp
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|va
operator|->
name|ul
operator|==
name|vb
operator|->
name|ul
condition|)
name|cmp
operator|=
literal|0
expr_stmt|;
else|else
name|cmp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|s
operator|->
name|reverse
operator|)
condition|?
operator|-
name|cmp
else|:
name|cmp
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|ref_sort
specifier|static
name|struct
name|ref_sort
modifier|*
name|ref_sort
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compare_refs
specifier|static
name|int
name|compare_refs
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|)
block|{
name|struct
name|refinfo
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
expr|struct
name|refinfo
operator|*
operator|*
operator|)
name|a_
operator|)
decl_stmt|;
name|struct
name|refinfo
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
expr|struct
name|refinfo
operator|*
operator|*
operator|)
name|b_
operator|)
decl_stmt|;
name|struct
name|ref_sort
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|ref_sort
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|int
name|cmp
init|=
name|cmp_ref_sort
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
condition|)
return|return
name|cmp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sort_refs
specifier|static
name|void
name|sort_refs
parameter_list|(
name|struct
name|ref_sort
modifier|*
name|sort
parameter_list|,
name|struct
name|refinfo
modifier|*
modifier|*
name|refs
parameter_list|,
name|int
name|num_refs
parameter_list|)
block|{
name|ref_sort
operator|=
name|sort
expr_stmt|;
name|qsort
argument_list|(
name|refs
argument_list|,
name|num_refs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refinfo
operator|*
argument_list|)
argument_list|,
name|compare_refs
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|print_value
specifier|static
name|void
name|print_value
parameter_list|(
name|struct
name|refinfo
modifier|*
name|ref
parameter_list|,
name|int
name|atom
parameter_list|,
name|int
name|quote_style
parameter_list|)
block|{
name|struct
name|atom_value
modifier|*
name|v
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|get_value
argument_list|(
name|ref
argument_list|,
name|atom
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|quote_style
condition|)
block|{
case|case
name|QUOTE_NONE
case|:
name|fputs
argument_list|(
name|v
operator|->
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_SHELL
case|:
name|sq_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|v
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_PERL
case|:
name|perl_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|v
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_PYTHON
case|:
name|python_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|v
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUOTE_TCL
case|:
name|tcl_quote_buf
argument_list|(
operator|&
name|sb
argument_list|,
name|v
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|quote_style
operator|!=
name|QUOTE_NONE
condition|)
block|{
name|fputs
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|hex1
specifier|static
name|int
name|hex1
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
literal|'0'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|hex2
specifier|static
name|int
name|hex2
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|&&
name|cp
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|hex1
argument_list|(
name|cp
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hex1
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|emit
specifier|static
name|void
name|emit
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|!
name|ep
operator|||
name|cp
operator|<
name|ep
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
name|int
name|ch
init|=
name|hex2
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|ch
condition|)
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|show_ref
specifier|static
name|void
name|show_ref
parameter_list|(
name|struct
name|refinfo
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|quote_style
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|format
init|;
operator|*
name|cp
operator|&&
operator|(
name|sp
operator|=
name|find_next
argument_list|(
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|=
name|ep
operator|+
literal|1
control|)
block|{
name|ep
operator|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|sp
condition|)
name|emit
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|info
argument_list|,
name|parse_atom
argument_list|(
name|sp
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
argument_list|,
name|quote_style
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|sp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|emit
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|default_sort
specifier|static
name|struct
name|ref_sort
modifier|*
name|default_sort
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|cstr_name
index|[]
init|=
literal|"refname"
decl_stmt|;
name|struct
name|ref_sort
modifier|*
name|sort
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sort
argument_list|)
argument_list|)
decl_stmt|;
name|sort
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sort
operator|->
name|atom
operator|=
name|parse_atom
argument_list|(
name|cstr_name
argument_list|,
name|cstr_name
operator|+
name|strlen
argument_list|(
name|cstr_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sort
return|;
block|}
end_function
begin_function
DECL|function|opt_parse_sort
specifier|static
name|int
name|opt_parse_sort
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|ref_sort
modifier|*
modifier|*
name|sort_tail
init|=
name|opt
operator|->
name|value
decl_stmt|;
name|struct
name|ref_sort
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
comment|/* should --no-sort void the list ? */
return|return
operator|-
literal|1
return|;
name|s
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
operator|*
name|sort_tail
expr_stmt|;
operator|*
name|sort_tail
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
name|s
operator|->
name|reverse
operator|=
literal|1
expr_stmt|;
name|arg
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|s
operator|->
name|atom
operator|=
name|parse_atom
argument_list|(
name|arg
argument_list|,
name|arg
operator|+
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|for_each_ref_usage
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|for_each_ref_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git for-each-ref [options] [<pattern>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cmd_for_each_ref
name|int
name|cmd_for_each_ref
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_refs
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
init|=
literal|"%(objectname) %(objecttype)\t%(refname)"
decl_stmt|;
name|struct
name|ref_sort
modifier|*
name|sort
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|sort_tail
init|=
operator|&
name|sort
decl_stmt|;
name|int
name|maxcount
init|=
literal|0
decl_stmt|,
name|quote_style
init|=
literal|0
decl_stmt|;
name|struct
name|refinfo
modifier|*
modifier|*
name|refs
decl_stmt|;
name|struct
name|grab_ref_cbdata
name|cbdata
decl_stmt|;
name|struct
name|option
name|opts
index|[]
init|=
block|{
name|OPT_BIT
argument_list|(
literal|'s'
argument_list|,
literal|"shell"
argument_list|,
operator|&
name|quote_style
argument_list|,
name|N_
argument_list|(
literal|"quote placeholders suitably for shells"
argument_list|)
argument_list|,
name|QUOTE_SHELL
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'p'
argument_list|,
literal|"perl"
argument_list|,
operator|&
name|quote_style
argument_list|,
name|N_
argument_list|(
literal|"quote placeholders suitably for perl"
argument_list|)
argument_list|,
name|QUOTE_PERL
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"python"
argument_list|,
operator|&
name|quote_style
argument_list|,
name|N_
argument_list|(
literal|"quote placeholders suitably for python"
argument_list|)
argument_list|,
name|QUOTE_PYTHON
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"tcl"
argument_list|,
operator|&
name|quote_style
argument_list|,
name|N_
argument_list|(
literal|"quote placeholders suitably for tcl"
argument_list|)
argument_list|,
name|QUOTE_TCL
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
literal|""
argument_list|)
block|,
name|OPT_INTEGER
argument_list|(
literal|0
argument_list|,
literal|"count"
argument_list|,
operator|&
name|maxcount
argument_list|,
name|N_
argument_list|(
literal|"show only<n> matched refs"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"format"
argument_list|,
operator|&
name|format
argument_list|,
name|N_
argument_list|(
literal|"format"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"format to use for the output"
argument_list|)
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|0
argument_list|,
literal|"sort"
argument_list|,
name|sort_tail
argument_list|,
name|N_
argument_list|(
literal|"key"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"field name to sort on"
argument_list|)
argument_list|,
operator|&
name|opt_parse_sort
argument_list|)
block|,
name|OPT_END
argument_list|()
block|, 	}
decl_stmt|;
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|opts
argument_list|,
name|for_each_ref_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxcount
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid --count argument: `%d'"
argument_list|,
name|maxcount
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|for_each_ref_usage
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAS_MULTI_BITS
argument_list|(
name|quote_style
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"more than one quoting style?"
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|for_each_ref_usage
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verify_format
argument_list|(
name|format
argument_list|)
condition|)
name|usage_with_options
argument_list|(
name|for_each_ref_usage
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sort
condition|)
name|sort
operator|=
name|default_sort
argument_list|()
expr_stmt|;
name|sort_atom_limit
operator|=
name|used_atom_cnt
expr_stmt|;
comment|/* for warn_ambiguous_refs */
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cbdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cbdata
argument_list|)
argument_list|)
expr_stmt|;
name|cbdata
operator|.
name|grab_pattern
operator|=
name|argv
expr_stmt|;
name|for_each_rawref
argument_list|(
name|grab_single_ref
argument_list|,
operator|&
name|cbdata
argument_list|)
expr_stmt|;
name|refs
operator|=
name|cbdata
operator|.
name|grab_array
expr_stmt|;
name|num_refs
operator|=
name|cbdata
operator|.
name|grab_cnt
expr_stmt|;
name|sort_refs
argument_list|(
name|sort
argument_list|,
name|refs
argument_list|,
name|num_refs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maxcount
operator|||
name|num_refs
operator|<
name|maxcount
condition|)
name|maxcount
operator|=
name|num_refs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxcount
condition|;
name|i
operator|++
control|)
name|show_ref
argument_list|(
name|refs
index|[
name|i
index|]
argument_list|,
name|format
argument_list|,
name|quote_style
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
