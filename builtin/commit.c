begin_unit
begin_comment
comment|/*  * Builtin "git commit"  *  * Copyright (c) 2007 Kristian HÃ¸gsberg<krh@redhat.com>  * Based on git-commit.sh by Junio C Hamano and Linus Torvalds  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"wt-status.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"rerere.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"submodule.h"
end_include
begin_include
include|#
directive|include
file|"gpg-interface.h"
end_include
begin_include
include|#
directive|include
file|"column.h"
end_include
begin_include
include|#
directive|include
file|"sequencer.h"
end_include
begin_include
include|#
directive|include
file|"notes-utils.h"
end_include
begin_include
include|#
directive|include
file|"mailmap.h"
end_include
begin_decl_stmt
DECL|variable|builtin_commit_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_commit_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git commit [options] [--]<pathspec>..."
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|builtin_status_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_status_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git status [options] [--]<pathspec>..."
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|implicit_ident_advice_noconfig
specifier|static
specifier|const
name|char
name|implicit_ident_advice_noconfig
index|[]
init|=
name|N_
argument_list|(
literal|"Your name and email address were configured automatically based\n"
literal|"on your username and hostname. Please check that they are accurate.\n"
literal|"You can suppress this message by setting them explicitly. Run the\n"
literal|"following command and follow the instructions in your editor to edit\n"
literal|"your configuration file:\n"
literal|"\n"
literal|"    git config --global --edit\n"
literal|"\n"
literal|"After doing this, you may fix the identity used for this commit with:\n"
literal|"\n"
literal|"    git commit --amend --reset-author\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|implicit_ident_advice_config
specifier|static
specifier|const
name|char
name|implicit_ident_advice_config
index|[]
init|=
name|N_
argument_list|(
literal|"Your name and email address were configured automatically based\n"
literal|"on your username and hostname. Please check that they are accurate.\n"
literal|"You can suppress this message by setting them explicitly:\n"
literal|"\n"
literal|"    git config --global user.name \"Your Name\"\n"
literal|"    git config --global user.email you@example.com\n"
literal|"\n"
literal|"After doing this, you may fix the identity used for this commit with:\n"
literal|"\n"
literal|"    git commit --amend --reset-author\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|empty_amend_advice
specifier|static
specifier|const
name|char
name|empty_amend_advice
index|[]
init|=
name|N_
argument_list|(
literal|"You asked to amend the most recent commit, but doing so would make\n"
literal|"it empty. You can repeat your command with --allow-empty, or you can\n"
literal|"remove the commit entirely with \"git reset HEAD^\".\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|empty_cherry_pick_advice
specifier|static
specifier|const
name|char
name|empty_cherry_pick_advice
index|[]
init|=
name|N_
argument_list|(
literal|"The previous cherry-pick is now empty, possibly due to conflict resolution.\n"
literal|"If you wish to commit it anyway, use:\n"
literal|"\n"
literal|"    git commit --allow-empty\n"
literal|"\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|empty_cherry_pick_advice_single
specifier|static
specifier|const
name|char
name|empty_cherry_pick_advice_single
index|[]
init|=
name|N_
argument_list|(
literal|"Otherwise, please use 'git reset'\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|empty_cherry_pick_advice_multi
specifier|static
specifier|const
name|char
name|empty_cherry_pick_advice_multi
index|[]
init|=
name|N_
argument_list|(
literal|"If you wish to skip this commit, use:\n"
literal|"\n"
literal|"    git reset\n"
literal|"\n"
literal|"Then \"git cherry-pick --continue\" will resume cherry-picking\n"
literal|"the remaining commits.\n"
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_message_buffer
specifier|static
specifier|const
name|char
modifier|*
name|use_message_buffer
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_editmsg
specifier|static
specifier|const
name|char
name|commit_editmsg
index|[]
init|=
literal|"COMMIT_EDITMSG"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|index_lock
specifier|static
name|struct
name|lock_file
name|index_lock
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|index_lock
comment|/* real index */
end_comment
begin_decl_stmt
DECL|variable|false_lock
specifier|static
name|struct
name|lock_file
name|false_lock
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|false_lock
comment|/* used only for partial commits */
end_comment
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|COMMIT_AS_IS
name|COMMIT_AS_IS
init|=
literal|1
block|,
DECL|enumerator|COMMIT_NORMAL
name|COMMIT_NORMAL
block|,
DECL|enumerator|COMMIT_PARTIAL
name|COMMIT_PARTIAL
block|}
DECL|variable|commit_style
name|commit_style
enum|;
end_enum
begin_decl_stmt
DECL|variable|logfile
DECL|variable|force_author
specifier|static
specifier|const
name|char
modifier|*
name|logfile
decl_stmt|,
modifier|*
name|force_author
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|template_file
specifier|static
specifier|const
name|char
modifier|*
name|template_file
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * The _message variables are commit names from which to take  * the commit message and/or authorship.  */
end_comment
begin_decl_stmt
DECL|variable|author_message
DECL|variable|author_message_buffer
specifier|static
specifier|const
name|char
modifier|*
name|author_message
decl_stmt|,
modifier|*
name|author_message_buffer
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|edit_message
DECL|variable|use_message
specifier|static
name|char
modifier|*
name|edit_message
decl_stmt|,
modifier|*
name|use_message
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fixup_message
DECL|variable|squash_message
specifier|static
name|char
modifier|*
name|fixup_message
decl_stmt|,
modifier|*
name|squash_message
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|all
DECL|variable|also
DECL|variable|interactive
DECL|variable|patch_interactive
DECL|variable|only
DECL|variable|amend
DECL|variable|signoff
specifier|static
name|int
name|all
decl_stmt|,
name|also
decl_stmt|,
name|interactive
decl_stmt|,
name|patch_interactive
decl_stmt|,
name|only
decl_stmt|,
name|amend
decl_stmt|,
name|signoff
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|edit_flag
specifier|static
name|int
name|edit_flag
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|edit_flag
comment|/* unspecified */
end_comment
begin_decl_stmt
DECL|variable|quiet
DECL|variable|verbose
DECL|variable|no_verify
DECL|variable|allow_empty
DECL|variable|dry_run
DECL|variable|renew_authorship
specifier|static
name|int
name|quiet
decl_stmt|,
name|verbose
decl_stmt|,
name|no_verify
decl_stmt|,
name|allow_empty
decl_stmt|,
name|dry_run
decl_stmt|,
name|renew_authorship
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_post_rewrite
DECL|variable|allow_empty_message
specifier|static
name|int
name|no_post_rewrite
decl_stmt|,
name|allow_empty_message
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|untracked_files_arg
DECL|variable|force_date
DECL|variable|ignore_submodule_arg
specifier|static
name|char
modifier|*
name|untracked_files_arg
decl_stmt|,
modifier|*
name|force_date
decl_stmt|,
modifier|*
name|ignore_submodule_arg
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sign_commit
specifier|static
name|char
modifier|*
name|sign_commit
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * The default commit message cleanup mode will remove the lines  * beginning with # (shell comments) and leading and trailing  * whitespaces (empty lines or containing only whitespaces)  * if editor is used, and only the whitespaces if the message  * is specified explicitly.  */
end_comment
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|CLEANUP_SPACE
name|CLEANUP_SPACE
block|,
DECL|enumerator|CLEANUP_NONE
name|CLEANUP_NONE
block|,
DECL|enumerator|CLEANUP_SCISSORS
name|CLEANUP_SCISSORS
block|,
DECL|enumerator|CLEANUP_ALL
name|CLEANUP_ALL
block|}
DECL|variable|cleanup_mode
name|cleanup_mode
enum|;
end_enum
begin_decl_stmt
DECL|variable|cleanup_arg
specifier|static
specifier|const
name|char
modifier|*
name|cleanup_arg
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|whence
specifier|static
name|enum
name|commit_whence
name|whence
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sequencer_in_use
specifier|static
name|int
name|sequencer_in_use
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_editor
DECL|variable|include_status
specifier|static
name|int
name|use_editor
init|=
literal|1
decl_stmt|,
name|include_status
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|show_ignored_in_status
DECL|variable|have_option_m
specifier|static
name|int
name|show_ignored_in_status
decl_stmt|,
name|have_option_m
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|only_include_assumed
specifier|static
specifier|const
name|char
modifier|*
name|only_include_assumed
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|message
specifier|static
name|struct
name|strbuf
name|message
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|status_format
specifier|static
enum|enum
name|status_format
block|{
DECL|enumerator|STATUS_FORMAT_NONE
name|STATUS_FORMAT_NONE
init|=
literal|0
block|,
DECL|enumerator|STATUS_FORMAT_LONG
name|STATUS_FORMAT_LONG
block|,
DECL|enumerator|STATUS_FORMAT_SHORT
name|STATUS_FORMAT_SHORT
block|,
DECL|enumerator|STATUS_FORMAT_PORCELAIN
name|STATUS_FORMAT_PORCELAIN
block|,
DECL|enumerator|STATUS_FORMAT_UNSPECIFIED
name|STATUS_FORMAT_UNSPECIFIED
block|}
DECL|variable|status_format
name|status_format
init|=
name|STATUS_FORMAT_UNSPECIFIED
enum|;
end_enum
begin_function
DECL|function|opt_parse_m
specifier|static
name|int
name|opt_parse_m
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|buf
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|unset
condition|)
block|{
name|have_option_m
operator|=
literal|0
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|have_option_m
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
condition|)
name|strbuf_addch
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strbuf_complete_line
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|determine_whence
specifier|static
name|void
name|determine_whence
parameter_list|(
name|struct
name|wt_status
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
condition|)
name|whence
operator|=
name|FROM_MERGE
expr_stmt|;
elseif|else
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
condition|)
block|{
name|whence
operator|=
name|FROM_CHERRY_PICK
expr_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"sequencer"
argument_list|)
argument_list|)
condition|)
name|sequencer_in_use
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|whence
operator|=
name|FROM_COMMIT
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|->
name|whence
operator|=
name|whence
expr_stmt|;
block|}
end_function
begin_function
DECL|function|status_init_config
specifier|static
name|void
name|status_init_config
parameter_list|(
name|struct
name|wt_status
modifier|*
name|s
parameter_list|,
name|config_fn_t
name|fn
parameter_list|)
block|{
name|wt_status_prepare
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|gitmodules_config
argument_list|()
expr_stmt|;
name|git_config
argument_list|(
name|fn
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|determine_whence
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|hints
operator|=
name|advice_status_hints
expr_stmt|;
comment|/* must come after git_config() */
block|}
end_function
begin_function
DECL|function|rollback_index_files
specifier|static
name|void
name|rollback_index_files
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|commit_style
condition|)
block|{
case|case
name|COMMIT_AS_IS
case|:
break|break;
comment|/* nothing to do */
case|case
name|COMMIT_NORMAL
case|:
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMIT_PARTIAL
case|:
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|commit_index_files
specifier|static
name|int
name|commit_index_files
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|commit_style
condition|)
block|{
case|case
name|COMMIT_AS_IS
case|:
break|break;
comment|/* nothing to do */
case|case
name|COMMIT_NORMAL
case|:
name|err
operator|=
name|commit_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMIT_PARTIAL
case|:
name|err
operator|=
name|commit_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function
begin_comment
comment|/*  * Take a union of paths in the index and the named tree (typically, "HEAD"),  * and return the paths that match the given pattern in list.  */
end_comment
begin_function
DECL|function|list_paths
specifier|static
name|int
name|list_paths
parameter_list|(
name|struct
name|string_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|with_tree
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|struct
name|pathspec
modifier|*
name|pattern
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
operator|->
name|nr
condition|)
return|return
literal|0
return|;
name|m
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|pattern
operator|->
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_tree
condition|)
block|{
name|char
modifier|*
name|max_prefix
init|=
name|common_prefix
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|overlay_tree_on_cache
argument_list|(
name|with_tree
argument_list|,
name|max_prefix
condition|?
name|max_prefix
else|:
name|prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|max_prefix
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_flags
operator|&
name|CE_UPDATE
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ce_path_match
argument_list|(
name|ce
argument_list|,
name|pattern
argument_list|,
name|m
argument_list|)
condition|)
continue|continue;
name|item
operator|=
name|string_list_insert
argument_list|(
name|list
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce_skip_worktree
argument_list|(
name|ce
argument_list|)
condition|)
name|item
operator|->
name|util
operator|=
name|item
expr_stmt|;
comment|/* better a valid pointer than a fake one */
block|}
return|return
name|report_path_error
argument_list|(
name|m
argument_list|,
name|pattern
argument_list|,
name|prefix
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|add_remove_files
specifier|static
name|void
name|add_remove_files
parameter_list|(
name|struct
name|string_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|p
init|=
operator|&
operator|(
name|list
operator|->
name|items
index|[
name|i
index|]
operator|)
decl_stmt|;
comment|/* p->util is skip-worktree */
if|if
condition|(
name|p
operator|->
name|util
condition|)
continue|continue;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|p
operator|->
name|string
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
name|add_to_cache
argument_list|(
name|p
operator|->
name|string
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"updating files failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|remove_file_from_cache
argument_list|(
name|p
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|create_base_index
specifier|static
name|void
name|create_base_index
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|current_head
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|current_head
condition|)
block|{
name|discard_cache
argument_list|()
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|index_only
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|current_head
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to unpack HEAD tree object"
argument_list|)
argument_list|)
expr_stmt|;
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_trees
argument_list|(
literal|1
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
comment|/* We've already reported the error, finish dying */
block|}
end_function
begin_function
DECL|function|refresh_cache_or_die
specifier|static
name|void
name|refresh_cache_or_die
parameter_list|(
name|int
name|refresh_flags
parameter_list|)
block|{
comment|/* 	 * refresh_flags contains REFRESH_QUIET, so the only errors 	 * are for unmerged entries. 	 */
if|if
condition|(
name|refresh_cache
argument_list|(
name|refresh_flags
operator||
name|REFRESH_IN_PORCELAIN
argument_list|)
condition|)
name|die_resolve_conflict
argument_list|(
literal|"commit"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_index
specifier|static
name|char
modifier|*
name|prepare_index
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|current_head
parameter_list|,
name|int
name|is_status
parameter_list|)
block|{
name|struct
name|string_list
name|partial
decl_stmt|;
name|struct
name|pathspec
name|pathspec
decl_stmt|;
name|int
name|refresh_flags
init|=
name|REFRESH_QUIET
decl_stmt|;
if|if
condition|(
name|is_status
condition|)
name|refresh_flags
operator||=
name|REFRESH_UNMERGED
expr_stmt|;
name|parse_pathspec
argument_list|(
operator|&
name|pathspec
argument_list|,
literal|0
argument_list|,
name|PATHSPEC_PREFER_FULL
argument_list|,
name|prefix
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cache_preload
argument_list|(
operator|&
name|pathspec
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"index file corrupt"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
block|{
name|char
modifier|*
name|old_index_env
init|=
name|NULL
decl_stmt|;
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache_or_die
argument_list|(
name|refresh_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
operator|&
name|index_lock
argument_list|,
name|CLOSE_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to create temporary index"
argument_list|)
argument_list|)
expr_stmt|;
name|old_index_env
operator|=
name|getenv
argument_list|(
name|INDEX_ENVIRONMENT
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|INDEX_ENVIRONMENT
argument_list|,
name|index_lock
operator|.
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive_add
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|patch_interactive
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"interactive add failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_index_env
operator|&&
operator|*
name|old_index_env
condition|)
name|setenv
argument_list|(
name|INDEX_ENVIRONMENT
argument_list|,
name|old_index_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|unsetenv
argument_list|(
name|INDEX_ENVIRONMENT
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|index_lock
operator|.
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_main_cache_tree
argument_list|(
name|WRITE_TREE_SILENT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reopen_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write index file"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
operator|&
name|index_lock
argument_list|,
name|CLOSE_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to update temporary index"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
name|_
argument_list|(
literal|"Failed to update main cache tree"
argument_list|)
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_NORMAL
expr_stmt|;
return|return
name|index_lock
operator|.
name|filename
return|;
block|}
comment|/* 	 * Non partial, non as-is commit. 	 * 	 * (1) get the real index; 	 * (2) update the_index as necessary; 	 * (3) write the_index out to the real index (still locked); 	 * (4) return the name of the locked index file. 	 * 	 * The caller should run hooks on the locked real index, and 	 * (A) if all goes well, commit the real index; 	 * (B) on failure, rollback the real index. 	 */
if|if
condition|(
name|all
operator|||
operator|(
name|also
operator|&&
name|pathspec
operator|.
name|nr
operator|)
condition|)
block|{
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_files_to_cache
argument_list|(
name|also
condition|?
name|prefix
else|:
name|NULL
argument_list|,
operator|&
name|pathspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh_cache_or_die
argument_list|(
name|refresh_flags
argument_list|)
expr_stmt|;
name|update_main_cache_tree
argument_list|(
name|WRITE_TREE_SILENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
operator|&
name|index_lock
argument_list|,
name|CLOSE_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new_index file"
argument_list|)
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_NORMAL
expr_stmt|;
return|return
name|index_lock
operator|.
name|filename
return|;
block|}
comment|/* 	 * As-is commit. 	 * 	 * (1) return the name of the real index file. 	 * 	 * The caller should run hooks on the real index, 	 * and create commit from the_index. 	 * We still need to refresh the index here. 	 */
if|if
condition|(
operator|!
name|only
operator|&&
operator|!
name|pathspec
operator|.
name|nr
condition|)
block|{
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache_or_die
argument_list|(
name|refresh_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|||
operator|!
name|cache_tree_fully_valid
argument_list|(
name|active_cache_tree
argument_list|)
condition|)
block|{
name|update_main_cache_tree
argument_list|(
name|WRITE_TREE_SILENT
argument_list|)
expr_stmt|;
name|active_cache_changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|active_cache_changed
condition|)
block|{
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
operator|&
name|index_lock
argument_list|,
name|COMMIT_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new_index file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
block|}
name|commit_style
operator|=
name|COMMIT_AS_IS
expr_stmt|;
return|return
name|get_index_file
argument_list|()
return|;
block|}
comment|/* 	 * A partial commit. 	 * 	 * (0) find the set of affected paths; 	 * (1) get lock on the real index file; 	 * (2) update the_index with the given paths; 	 * (3) write the_index out to the real index (still locked); 	 * (4) get lock on the false index file; 	 * (5) reset the_index from HEAD; 	 * (6) update the_index the same way as (2); 	 * (7) write the_index out to the false index file; 	 * (8) return the name of the false index file (still locked); 	 * 	 * The caller should run hooks on the locked false index, and 	 * create commit from it.  Then 	 * (A) if all goes well, commit the real index; 	 * (B) on failure, rollback the real index; 	 * In either case, rollback the false index. 	 */
name|commit_style
operator|=
name|COMMIT_PARTIAL
expr_stmt|;
if|if
condition|(
name|whence
operator|!=
name|FROM_COMMIT
condition|)
block|{
if|if
condition|(
name|whence
operator|==
name|FROM_MERGE
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot do a partial commit during a merge."
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|whence
operator|==
name|FROM_CHERRY_PICK
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot do a partial commit during a cherry-pick."
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|string_list_init
argument_list|(
operator|&
name|partial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_paths
argument_list|(
operator|&
name|partial
argument_list|,
operator|!
name|current_head
condition|?
name|NULL
else|:
literal|"HEAD"
argument_list|,
name|prefix
argument_list|,
operator|&
name|pathspec
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot read the index"
argument_list|)
argument_list|)
expr_stmt|;
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_remove_files
argument_list|(
operator|&
name|partial
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
name|update_main_cache_tree
argument_list|(
name|WRITE_TREE_SILENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
operator|&
name|index_lock
argument_list|,
name|CLOSE_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write new_index file"
argument_list|)
argument_list|)
expr_stmt|;
name|hold_lock_file_for_update
argument_list|(
operator|&
name|false_lock
argument_list|,
name|git_path
argument_list|(
literal|"next-index-%"
name|PRIuMAX
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getpid
argument_list|()
argument_list|)
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
name|create_base_index
argument_list|(
name|current_head
argument_list|)
expr_stmt|;
name|add_remove_files
argument_list|(
operator|&
name|partial
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_locked_index
argument_list|(
operator|&
name|the_index
argument_list|,
operator|&
name|false_lock
argument_list|,
name|CLOSE_LOCK
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to write temporary index file"
argument_list|)
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|false_lock
operator|.
name|filename
argument_list|)
expr_stmt|;
return|return
name|false_lock
operator|.
name|filename
return|;
block|}
end_function
begin_function
DECL|function|run_status
specifier|static
name|int
name|run_status
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|nowarn
parameter_list|,
name|struct
name|wt_status
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|relative_paths
condition|)
name|s
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
if|if
condition|(
name|amend
condition|)
block|{
name|s
operator|->
name|amend
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|reference
operator|=
literal|"HEAD^1"
expr_stmt|;
block|}
name|s
operator|->
name|verbose
operator|=
name|verbose
expr_stmt|;
name|s
operator|->
name|index_file
operator|=
name|index_file
expr_stmt|;
name|s
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|s
operator|->
name|nowarn
operator|=
name|nowarn
expr_stmt|;
name|s
operator|->
name|is_initial
operator|=
name|get_sha1
argument_list|(
name|s
operator|->
name|reference
argument_list|,
name|sha1
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|wt_status_collect
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status_format
condition|)
block|{
case|case
name|STATUS_FORMAT_SHORT
case|:
name|wt_shortstatus_print
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_FORMAT_PORCELAIN
case|:
name|wt_porcelain_print
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_FORMAT_UNSPECIFIED
case|:
name|die
argument_list|(
literal|"BUG: finalize_deferred_config() should have been called"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_FORMAT_NONE
case|:
case|case
name|STATUS_FORMAT_LONG
case|:
name|wt_status_print
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|s
operator|->
name|commitable
return|;
block|}
end_function
begin_function
DECL|function|is_a_merge
specifier|static
name|int
name|is_a_merge
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|current_head
parameter_list|)
block|{
return|return
operator|!
operator|!
operator|(
name|current_head
operator|->
name|parents
operator|&&
name|current_head
operator|->
name|parents
operator|->
name|next
operator|)
return|;
block|}
end_function
begin_function
DECL|function|export_one
specifier|static
name|void
name|export_one
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|e
parameter_list|,
name|int
name|hack
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|hack
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
name|hack
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|e
operator|-
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|var
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sane_ident_split
specifier|static
name|int
name|sane_ident_split
parameter_list|(
name|struct
name|ident_split
modifier|*
name|person
parameter_list|)
block|{
if|if
condition|(
operator|!
name|person
operator|->
name|name_begin
operator|||
operator|!
name|person
operator|->
name|name_end
operator|||
name|person
operator|->
name|name_begin
operator|==
name|person
operator|->
name|name_end
condition|)
return|return
literal|0
return|;
comment|/* no human readable name */
if|if
condition|(
operator|!
name|person
operator|->
name|mail_begin
operator|||
operator|!
name|person
operator|->
name|mail_end
operator|||
name|person
operator|->
name|mail_begin
operator|==
name|person
operator|->
name|mail_end
condition|)
return|return
literal|0
return|;
comment|/* no usable mail */
if|if
condition|(
operator|!
name|person
operator|->
name|date_begin
operator|||
operator|!
name|person
operator|->
name|date_end
operator|||
operator|!
name|person
operator|->
name|tz_begin
operator|||
operator|!
name|person
operator|->
name|tz_end
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|parse_force_date
specifier|static
name|int
name|parse_force_date
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|struct
name|strbuf
modifier|*
name|out
parameter_list|)
block|{
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_date
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|t
init|=
name|approxidate_careful
argument_list|(
name|in
argument_list|,
operator|&
name|errors
argument_list|)
decl_stmt|;
if|if
condition|(
name|errors
condition|)
return|return
operator|-
literal|1
return|;
name|strbuf_addf
argument_list|(
name|out
argument_list|,
literal|"%lu"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|set_ident_var
specifier|static
name|void
name|set_ident_var
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
name|free
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|val
expr_stmt|;
block|}
end_function
begin_function
DECL|function|envdup
specifier|static
name|char
modifier|*
name|envdup
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|getenv
argument_list|(
name|var
argument_list|)
decl_stmt|;
return|return
name|val
condition|?
name|xstrdup
argument_list|(
name|val
argument_list|)
else|:
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|determine_author_info
specifier|static
name|void
name|determine_author_info
parameter_list|(
name|struct
name|strbuf
modifier|*
name|author_ident
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|email
decl_stmt|,
modifier|*
name|date
decl_stmt|;
name|struct
name|ident_split
name|author
decl_stmt|;
name|name
operator|=
name|envdup
argument_list|(
literal|"GIT_AUTHOR_NAME"
argument_list|)
expr_stmt|;
name|email
operator|=
name|envdup
argument_list|(
literal|"GIT_AUTHOR_EMAIL"
argument_list|)
expr_stmt|;
name|date
operator|=
name|envdup
argument_list|(
literal|"GIT_AUTHOR_DATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|author_message
condition|)
block|{
name|struct
name|ident_split
name|ident
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|find_commit_header
argument_list|(
name|author_message_buffer
argument_list|,
literal|"author"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"commit '%s' lacks author header"
argument_list|)
argument_list|,
name|author_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|ident
argument_list|,
name|a
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"commit '%s' has malformed author line"
argument_list|)
argument_list|,
name|author_message
argument_list|)
expr_stmt|;
name|set_ident_var
argument_list|(
operator|&
name|name
argument_list|,
name|xmemdupz
argument_list|(
name|ident
operator|.
name|name_begin
argument_list|,
name|ident
operator|.
name|name_end
operator|-
name|ident
operator|.
name|name_begin
argument_list|)
argument_list|)
expr_stmt|;
name|set_ident_var
argument_list|(
operator|&
name|email
argument_list|,
name|xmemdupz
argument_list|(
name|ident
operator|.
name|mail_begin
argument_list|,
name|ident
operator|.
name|mail_end
operator|-
name|ident
operator|.
name|mail_begin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
operator|.
name|date_begin
condition|)
block|{
name|struct
name|strbuf
name|date_buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|date_buf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|date_buf
argument_list|,
name|ident
operator|.
name|date_begin
argument_list|,
name|ident
operator|.
name|date_end
operator|-
name|ident
operator|.
name|date_begin
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|date_buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|date_buf
argument_list|,
name|ident
operator|.
name|tz_begin
argument_list|,
name|ident
operator|.
name|tz_end
operator|-
name|ident
operator|.
name|tz_begin
argument_list|)
expr_stmt|;
name|set_ident_var
argument_list|(
operator|&
name|date
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|date_buf
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|force_author
condition|)
block|{
name|struct
name|ident_split
name|ident
decl_stmt|;
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|ident
argument_list|,
name|force_author
argument_list|,
name|strlen
argument_list|(
name|force_author
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"malformed --author parameter"
argument_list|)
argument_list|)
expr_stmt|;
name|set_ident_var
argument_list|(
operator|&
name|name
argument_list|,
name|xmemdupz
argument_list|(
name|ident
operator|.
name|name_begin
argument_list|,
name|ident
operator|.
name|name_end
operator|-
name|ident
operator|.
name|name_begin
argument_list|)
argument_list|)
expr_stmt|;
name|set_ident_var
argument_list|(
operator|&
name|email
argument_list|,
name|xmemdupz
argument_list|(
name|ident
operator|.
name|mail_begin
argument_list|,
name|ident
operator|.
name|mail_end
operator|-
name|ident
operator|.
name|mail_begin
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_date
condition|)
block|{
name|struct
name|strbuf
name|date_buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|parse_force_date
argument_list|(
name|force_date
argument_list|,
operator|&
name|date_buf
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"invalid date format: %s"
argument_list|)
argument_list|,
name|force_date
argument_list|)
expr_stmt|;
name|set_ident_var
argument_list|(
operator|&
name|date
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|date_buf
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
name|author_ident
argument_list|,
name|fmt_ident
argument_list|(
name|name
argument_list|,
name|email
argument_list|,
name|date
argument_list|,
name|IDENT_STRICT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|split_ident_line
argument_list|(
operator|&
name|author
argument_list|,
name|author_ident
operator|->
name|buf
argument_list|,
name|author_ident
operator|->
name|len
argument_list|)
operator|&&
name|sane_ident_split
argument_list|(
operator|&
name|author
argument_list|)
condition|)
block|{
name|export_one
argument_list|(
literal|"GIT_AUTHOR_NAME"
argument_list|,
name|author
operator|.
name|name_begin
argument_list|,
name|author
operator|.
name|name_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|export_one
argument_list|(
literal|"GIT_AUTHOR_EMAIL"
argument_list|,
name|author
operator|.
name|mail_begin
argument_list|,
name|author
operator|.
name|mail_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|export_one
argument_list|(
literal|"GIT_AUTHOR_DATE"
argument_list|,
name|author
operator|.
name|date_begin
argument_list|,
name|author
operator|.
name|tz_end
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|email
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|split_ident_or_die
specifier|static
name|void
name|split_ident_or_die
parameter_list|(
name|struct
name|ident_split
modifier|*
name|id
parameter_list|,
specifier|const
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|split_ident_line
argument_list|(
name|id
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|len
argument_list|)
operator|||
operator|!
name|sane_ident_split
argument_list|(
name|id
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Malformed ident string: '%s'"
argument_list|)
argument_list|,
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|author_date_is_interesting
specifier|static
name|int
name|author_date_is_interesting
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|author_message
operator|||
name|force_date
return|;
block|}
end_function
begin_function
DECL|function|adjust_comment_line_char
specifier|static
name|void
name|adjust_comment_line_char
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|char
name|candidates
index|[]
init|=
literal|"#;@!$%^&|:"
decl_stmt|;
name|char
modifier|*
name|candidate
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|comment_line_char
operator|=
name|candidates
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|memchr
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
name|comment_line_char
argument_list|,
name|sb
operator|->
name|len
argument_list|)
condition|)
return|return;
name|p
operator|=
name|sb
operator|->
name|buf
expr_stmt|;
name|candidate
operator|=
name|strchr
argument_list|(
name|candidates
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidate
condition|)
operator|*
name|candidate
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sb
operator|->
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
condition|)
block|{
name|candidate
operator|=
name|strchr
argument_list|(
name|candidates
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidate
condition|)
operator|*
name|candidate
operator|=
literal|' '
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|candidates
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to select a comment character that is not used\n"
literal|"in the current commit message"
argument_list|)
argument_list|)
expr_stmt|;
name|comment_line_char
operator|=
operator|*
name|p
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_to_commit
specifier|static
name|int
name|prepare_to_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|commit
modifier|*
name|current_head
parameter_list|,
name|struct
name|wt_status
modifier|*
name|s
parameter_list|,
name|struct
name|strbuf
modifier|*
name|author_ident
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|struct
name|strbuf
name|committer_ident
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|commitable
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|hook_arg1
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|hook_arg2
init|=
name|NULL
decl_stmt|;
name|int
name|clean_message_contents
init|=
operator|(
name|cleanup_mode
operator|!=
name|CLEANUP_NONE
operator|)
decl_stmt|;
name|int
name|old_display_comment_prefix
decl_stmt|;
comment|/* This checks and barfs if author is badly specified */
name|determine_author_info
argument_list|(
name|author_ident
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_verify
operator|&&
name|run_commit_hook
argument_list|(
name|use_editor
argument_list|,
name|index_file
argument_list|,
literal|"pre-commit"
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|squash_message
condition|)
block|{
comment|/* 		 * Insert the proper subject line before other commit 		 * message options add their content. 		 */
if|if
condition|(
name|use_message
operator|&&
operator|!
name|strcmp
argument_list|(
name|use_message
argument_list|,
name|squash_message
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|"squash! "
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|pretty_print_context
name|ctx
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|commit
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|lookup_commit_reference_by_name
argument_list|(
name|squash_message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not lookup commit %s"
argument_list|)
argument_list|,
name|squash_message
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|output_encoding
operator|=
name|get_commit_output_encoding
argument_list|()
expr_stmt|;
name|format_commit_message
argument_list|(
name|c
argument_list|,
literal|"squash! %s\n\n"
argument_list|,
operator|&
name|sb
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|message
operator|.
name|len
condition|)
block|{
name|strbuf_addbuf
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logfile
operator|&&
operator|!
name|strcmp
argument_list|(
name|logfile
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"(reading log message from standard input)\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read log from standard input"
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logfile
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|logfile
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read log file '%s'"
argument_list|)
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_message
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|strstr
argument_list|(
name|use_message_buffer
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|buffer
operator|+
literal|2
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"commit"
expr_stmt|;
name|hook_arg2
operator|=
name|use_message
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixup_message
condition|)
block|{
name|struct
name|pretty_print_context
name|ctx
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|commit
operator|=
name|lookup_commit_reference_by_name
argument_list|(
name|fixup_message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not lookup commit %s"
argument_list|)
argument_list|,
name|fixup_message
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|output_encoding
operator|=
name|get_commit_output_encoding
argument_list|()
expr_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
literal|"fixup! %s\n\n"
argument_list|,
operator|&
name|sb
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read MERGE_MSG"
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"merge"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read SQUASH_MSG"
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"squash"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|template_file
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|template_file
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read '%s'"
argument_list|)
argument_list|,
name|template_file
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"template"
expr_stmt|;
name|clean_message_contents
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * The remaining cases don't modify the template message, but 	 * just set the argument(s) to the prepare-commit-msg hook. 	 */
elseif|else
if|if
condition|(
name|whence
operator|==
name|FROM_MERGE
condition|)
name|hook_arg1
operator|=
literal|"merge"
expr_stmt|;
elseif|else
if|if
condition|(
name|whence
operator|==
name|FROM_CHERRY_PICK
condition|)
block|{
name|hook_arg1
operator|=
literal|"commit"
expr_stmt|;
name|hook_arg2
operator|=
literal|"CHERRY_PICK_HEAD"
expr_stmt|;
block|}
if|if
condition|(
name|squash_message
condition|)
block|{
comment|/* 		 * If squash_commit was used for the commit subject, 		 * then we're possibly hijacking other commit log options. 		 * Reset the hook args to tell the real story. 		 */
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
name|hook_arg2
operator|=
literal|""
expr_stmt|;
block|}
name|s
operator|->
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fp
operator|==
name|NULL
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not open '%s'"
argument_list|)
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore status.displayCommentPrefix: we do need comments in COMMIT_EDITMSG. */
name|old_display_comment_prefix
operator|=
name|s
operator|->
name|display_comment_prefix
expr_stmt|;
name|s
operator|->
name|display_comment_prefix
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Most hints are counter-productive when the commit has 	 * already started. 	 */
name|s
operator|->
name|hints
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clean_message_contents
condition|)
name|stripspace
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|signoff
condition|)
block|{
comment|/* 		 * See if we have a Conflicts: block at the end. If yes, count 		 * its size, so we can ignore it. 		 */
name|int
name|ignore_footer
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|eol
decl_stmt|,
name|previous
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|nl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|i
argument_list|,
literal|'\n'
argument_list|,
name|sb
operator|.
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|eol
operator|=
name|nl
operator|-
name|sb
operator|.
name|buf
expr_stmt|;
else|else
name|eol
operator|=
name|sb
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|previous
argument_list|,
literal|"\nConflicts:\n"
argument_list|)
condition|)
block|{
name|ignore_footer
operator|=
name|sb
operator|.
name|len
operator|-
name|previous
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|i
operator|<
name|eol
condition|)
name|i
operator|++
expr_stmt|;
name|previous
operator|=
name|eol
expr_stmt|;
block|}
name|append_signoff
argument_list|(
operator|&
name|sb
argument_list|,
name|ignore_footer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|s
operator|->
name|fp
argument_list|)
operator|<
name|sb
operator|.
name|len
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not write commit template"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_comment_line_char
condition|)
name|adjust_comment_line_char
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
comment|/* This checks if committer ident is explicitly given */
name|strbuf_addstr
argument_list|(
operator|&
name|committer_ident
argument_list|,
name|git_committer_info
argument_list|(
name|IDENT_STRICT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_editor
operator|&&
name|include_status
condition|)
block|{
name|int
name|ident_shown
init|=
literal|0
decl_stmt|;
name|int
name|saved_color_setting
decl_stmt|;
name|struct
name|ident_split
name|ci
decl_stmt|,
name|ai
decl_stmt|;
if|if
condition|(
name|whence
operator|!=
name|FROM_COMMIT
condition|)
block|{
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_SCISSORS
condition|)
name|wt_status_add_cut_line
argument_list|(
name|s
operator|->
name|fp
argument_list|)
expr_stmt|;
name|status_printf_ln
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
name|whence
operator|==
name|FROM_MERGE
condition|?
name|_
argument_list|(
literal|"\n"
literal|"It looks like you may be committing a merge.\n"
literal|"If this is not correct, please remove the file\n"
literal|"	%s\n"
literal|"and try again.\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"\n"
literal|"It looks like you may be committing a cherry-pick.\n"
literal|"If this is not correct, please remove the file\n"
literal|"	%s\n"
literal|"and try again.\n"
argument_list|)
argument_list|,
name|git_path
argument_list|(
name|whence
operator|==
name|FROM_MERGE
condition|?
literal|"MERGE_HEAD"
else|:
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|s
operator|->
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_ALL
condition|)
name|status_printf
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
name|_
argument_list|(
literal|"Please enter the commit message for your changes."
literal|" Lines starting\nwith '%c' will be ignored, and an empty"
literal|" message aborts the commit.\n"
argument_list|)
argument_list|,
name|comment_line_char
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_SCISSORS
operator|&&
name|whence
operator|==
name|FROM_COMMIT
condition|)
name|wt_status_add_cut_line
argument_list|(
name|s
operator|->
name|fp
argument_list|)
expr_stmt|;
else|else
comment|/* CLEANUP_SPACE, that is. */
name|status_printf
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
name|_
argument_list|(
literal|"Please enter the commit message for your changes."
literal|" Lines starting\n"
literal|"with '%c' will be kept; you may remove them"
literal|" yourself if you want to.\n"
literal|"An empty message aborts the commit.\n"
argument_list|)
argument_list|,
name|comment_line_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_include_assumed
condition|)
name|status_printf_ln
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
literal|"%s"
argument_list|,
name|only_include_assumed
argument_list|)
expr_stmt|;
name|split_ident_or_die
argument_list|(
operator|&
name|ai
argument_list|,
name|author_ident
argument_list|)
expr_stmt|;
name|split_ident_or_die
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|committer_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_cmp
argument_list|(
operator|&
name|ai
argument_list|,
operator|&
name|ci
argument_list|)
condition|)
name|status_printf_ln
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
name|_
argument_list|(
literal|"%s"
literal|"Author:    %.*s<%.*s>"
argument_list|)
argument_list|,
name|ident_shown
operator|++
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ai
operator|.
name|name_end
operator|-
name|ai
operator|.
name|name_begin
argument_list|)
argument_list|,
name|ai
operator|.
name|name_begin
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ai
operator|.
name|mail_end
operator|-
name|ai
operator|.
name|mail_begin
argument_list|)
argument_list|,
name|ai
operator|.
name|mail_begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|author_date_is_interesting
argument_list|()
condition|)
name|status_printf_ln
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
name|_
argument_list|(
literal|"%s"
literal|"Date:      %s"
argument_list|)
argument_list|,
name|ident_shown
operator|++
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
name|show_ident_date
argument_list|(
operator|&
name|ai
argument_list|,
name|DATE_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|committer_ident_sufficiently_given
argument_list|()
condition|)
name|status_printf_ln
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
name|_
argument_list|(
literal|"%s"
literal|"Committer: %.*s<%.*s>"
argument_list|)
argument_list|,
name|ident_shown
operator|++
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ci
operator|.
name|name_end
operator|-
name|ci
operator|.
name|name_begin
argument_list|)
argument_list|,
name|ci
operator|.
name|name_begin
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ci
operator|.
name|mail_end
operator|-
name|ci
operator|.
name|mail_begin
argument_list|)
argument_list|,
name|ci
operator|.
name|mail_begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_shown
condition|)
name|status_printf_ln
argument_list|(
name|s
argument_list|,
name|GIT_COLOR_NORMAL
argument_list|,
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|saved_color_setting
operator|=
name|s
operator|->
name|use_color
expr_stmt|;
name|s
operator|->
name|use_color
operator|=
literal|0
expr_stmt|;
name|commitable
operator|=
name|run_status
argument_list|(
name|s
operator|->
name|fp
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|use_color
operator|=
name|saved_color_setting
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
init|=
literal|"HEAD"
decl_stmt|;
if|if
condition|(
operator|!
name|active_nr
operator|&&
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot read index"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
condition|)
name|parent
operator|=
literal|"HEAD^1"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|parent
argument_list|,
name|sha1
argument_list|)
condition|)
name|commitable
operator|=
operator|!
operator|!
name|active_nr
expr_stmt|;
else|else
block|{
comment|/* 			 * Unless the user did explicitly request a submodule 			 * ignore mode by passing a command line option we do 			 * not ignore any changed submodule SHA-1s when 			 * comparing index and parent, no matter what is 			 * configured. Otherwise we won't commit any 			 * submodules which were manually staged, which would 			 * be really confusing. 			 */
name|int
name|diff_flags
init|=
name|DIFF_OPT_OVERRIDE_SUBMODULE_CONFIG
decl_stmt|;
if|if
condition|(
name|ignore_submodule_arg
operator|&&
operator|!
name|strcmp
argument_list|(
name|ignore_submodule_arg
argument_list|,
literal|"all"
argument_list|)
condition|)
name|diff_flags
operator||=
name|DIFF_OPT_IGNORE_SUBMODULES
expr_stmt|;
name|commitable
operator|=
name|index_differs_from
argument_list|(
name|parent
argument_list|,
name|diff_flags
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_release
argument_list|(
operator|&
name|committer_ident
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|s
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* 	 * Reject an attempt to record a non-merge empty commit without 	 * explicit --allow-empty. In the cherry-pick case, it may be 	 * empty due to conflict resolution, which the user should okay. 	 */
if|if
condition|(
operator|!
name|commitable
operator|&&
name|whence
operator|!=
name|FROM_MERGE
operator|&&
operator|!
name|allow_empty
operator|&&
operator|!
operator|(
name|amend
operator|&&
name|is_a_merge
argument_list|(
name|current_head
argument_list|)
operator|)
condition|)
block|{
name|s
operator|->
name|display_comment_prefix
operator|=
name|old_display_comment_prefix
expr_stmt|;
name|run_status
argument_list|(
name|stdout
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
name|empty_amend_advice
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|whence
operator|==
name|FROM_CHERRY_PICK
condition|)
block|{
name|fputs
argument_list|(
name|_
argument_list|(
name|empty_cherry_pick_advice
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sequencer_in_use
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
name|empty_cherry_pick_advice_single
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|_
argument_list|(
name|empty_cherry_pick_advice_multi
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* 	 * Re-read the index as pre-commit hook could have updated it, 	 * and write it out as a tree.  We must do this before we invoke 	 * the editor and after we invoke run_status above. 	 */
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|index_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_main_cache_tree
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Error building trees"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|run_commit_hook
argument_list|(
name|use_editor
argument_list|,
name|index_file
argument_list|,
literal|"prepare-commit-msg"
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|hook_arg1
argument_list|,
name|hook_arg2
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|use_editor
condition|)
block|{
name|char
name|index
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|env
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|env
index|[
literal|0
index|]
operator|=
name|index
expr_stmt|;
name|snprintf
argument_list|(
name|index
argument_list|,
sizeof|sizeof
argument_list|(
name|index
argument_list|)
argument_list|,
literal|"GIT_INDEX_FILE=%s"
argument_list|,
name|index_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|launch_editor
argument_list|(
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|env
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Please supply the message using either -m or -F option.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|no_verify
operator|&&
name|run_commit_hook
argument_list|(
name|use_editor
argument_list|,
name|index_file
argument_list|,
literal|"commit-msg"
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|rest_is_empty
specifier|static
name|int
name|rest_is_empty
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|eol
decl_stmt|;
specifier|const
name|char
modifier|*
name|nl
decl_stmt|;
comment|/* Check if the rest is just whitespace and Signed-of-by's. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|sb
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|i
argument_list|,
literal|'\n'
argument_list|,
name|sb
operator|->
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|eol
operator|=
name|nl
operator|-
name|sb
operator|->
name|buf
expr_stmt|;
else|else
name|eol
operator|=
name|sb
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|sign_off_header
argument_list|)
operator|<=
name|eol
operator|-
name|i
operator|&&
name|starts_with
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|i
argument_list|,
name|sign_off_header
argument_list|)
condition|)
block|{
name|i
operator|=
name|eol
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|i
operator|<
name|eol
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|sb
operator|->
name|buf
index|[
name|i
operator|++
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Find out if the message in the strbuf contains only whitespace and  * Signed-off-by lines.  */
end_comment
begin_function
DECL|function|message_is_empty
specifier|static
name|int
name|message_is_empty
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_NONE
operator|&&
name|sb
operator|->
name|len
condition|)
return|return
literal|0
return|;
return|return
name|rest_is_empty
argument_list|(
name|sb
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * See if the user edited the message in the editor or left what  * was in the template intact  */
end_comment
begin_function
DECL|function|template_untouched
specifier|static
name|int
name|template_untouched
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|strbuf
name|tmpl
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_NONE
operator|&&
name|sb
operator|->
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|template_file
operator|||
name|strbuf_read_file
argument_list|(
operator|&
name|tmpl
argument_list|,
name|template_file
argument_list|,
literal|0
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|stripspace
argument_list|(
operator|&
name|tmpl
argument_list|,
name|cleanup_mode
operator|==
name|CLEANUP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|sb
operator|->
name|buf
argument_list|,
name|tmpl
operator|.
name|buf
argument_list|,
operator|&
name|start
argument_list|)
condition|)
name|start
operator|=
name|sb
operator|->
name|buf
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|rest_is_empty
argument_list|(
name|sb
argument_list|,
name|start
operator|-
name|sb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|find_author_by_nickname
specifier|static
specifier|const
name|char
modifier|*
name|find_author_by_nickname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|string_list
name|mailmap
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
specifier|const
name|char
modifier|*
name|av
index|[
literal|20
index|]
decl_stmt|;
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"--author=%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
literal|"--all"
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
literal|"-i"
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
name|NULL
expr_stmt|;
name|setup_revisions
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|revs
operator|.
name|mailmap
operator|=
operator|&
name|mailmap
expr_stmt|;
name|read_mailmap
argument_list|(
name|revs
operator|.
name|mailmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
name|commit
operator|=
name|get_revision
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
name|struct
name|pretty_print_context
name|ctx
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ctx
operator|.
name|date_mode
operator|=
name|DATE_NORMAL
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
literal|"%aN<%aE>"
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|clear_mailmap
argument_list|(
operator|&
name|mailmap
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|die
argument_list|(
name|_
argument_list|(
literal|"No existing author found with '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handle_untracked_files_arg
specifier|static
name|void
name|handle_untracked_files_arg
parameter_list|(
name|struct
name|wt_status
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|untracked_files_arg
condition|)
empty_stmt|;
comment|/* default already initialized */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|untracked_files_arg
argument_list|,
literal|"no"
argument_list|)
condition|)
name|s
operator|->
name|show_untracked_files
operator|=
name|SHOW_NO_UNTRACKED_FILES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|untracked_files_arg
argument_list|,
literal|"normal"
argument_list|)
condition|)
name|s
operator|->
name|show_untracked_files
operator|=
name|SHOW_NORMAL_UNTRACKED_FILES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|untracked_files_arg
argument_list|,
literal|"all"
argument_list|)
condition|)
name|s
operator|->
name|show_untracked_files
operator|=
name|SHOW_ALL_UNTRACKED_FILES
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"Invalid untracked files mode '%s'"
argument_list|)
argument_list|,
name|untracked_files_arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_commit_message
specifier|static
specifier|const
name|char
modifier|*
name|read_commit_message
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|out_enc
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|commit
operator|=
name|lookup_commit_reference_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not lookup commit %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|out_enc
operator|=
name|get_commit_output_encoding
argument_list|()
expr_stmt|;
return|return
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|,
name|out_enc
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Enumerate what needs to be propagated when --porcelain  * is not in effect here.  */
end_comment
begin_struct
DECL|struct|status_deferred_config
specifier|static
struct|struct
name|status_deferred_config
block|{
DECL|member|status_format
name|enum
name|status_format
name|status_format
decl_stmt|;
DECL|member|show_branch
name|int
name|show_branch
decl_stmt|;
block|}
DECL|variable|status_deferred_config
name|status_deferred_config
init|=
block|{
name|STATUS_FORMAT_UNSPECIFIED
block|,
operator|-
literal|1
comment|/* unspecified */
block|}
struct|;
end_struct
begin_function
DECL|function|finalize_deferred_config
specifier|static
name|void
name|finalize_deferred_config
parameter_list|(
name|struct
name|wt_status
modifier|*
name|s
parameter_list|)
block|{
name|int
name|use_deferred_config
init|=
operator|(
name|status_format
operator|!=
name|STATUS_FORMAT_PORCELAIN
operator|&&
operator|!
name|s
operator|->
name|null_termination
operator|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|null_termination
condition|)
block|{
if|if
condition|(
name|status_format
operator|==
name|STATUS_FORMAT_NONE
operator|||
name|status_format
operator|==
name|STATUS_FORMAT_UNSPECIFIED
condition|)
name|status_format
operator|=
name|STATUS_FORMAT_PORCELAIN
expr_stmt|;
elseif|else
if|if
condition|(
name|status_format
operator|==
name|STATUS_FORMAT_LONG
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--long and -z are incompatible"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_deferred_config
operator|&&
name|status_format
operator|==
name|STATUS_FORMAT_UNSPECIFIED
condition|)
name|status_format
operator|=
name|status_deferred_config
operator|.
name|status_format
expr_stmt|;
if|if
condition|(
name|status_format
operator|==
name|STATUS_FORMAT_UNSPECIFIED
condition|)
name|status_format
operator|=
name|STATUS_FORMAT_NONE
expr_stmt|;
if|if
condition|(
name|use_deferred_config
operator|&&
name|s
operator|->
name|show_branch
operator|<
literal|0
condition|)
name|s
operator|->
name|show_branch
operator|=
name|status_deferred_config
operator|.
name|show_branch
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|show_branch
operator|<
literal|0
condition|)
name|s
operator|->
name|show_branch
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_and_validate_options
specifier|static
name|int
name|parse_and_validate_options
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|struct
name|option
modifier|*
name|options
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|usage
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|commit
modifier|*
name|current_head
parameter_list|,
name|struct
name|wt_status
modifier|*
name|s
parameter_list|)
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finalize_deferred_config
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_author
operator|&&
operator|!
name|strchr
argument_list|(
name|force_author
argument_list|,
literal|'>'
argument_list|)
condition|)
name|force_author
operator|=
name|find_author_by_nickname
argument_list|(
name|force_author
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_author
operator|&&
name|renew_authorship
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Using both --reset-author and --author does not make sense"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|||
name|have_option_m
operator|||
name|use_message
operator|||
name|fixup_message
condition|)
name|use_editor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|edit_flag
condition|)
name|use_editor
operator|=
name|edit_flag
expr_stmt|;
comment|/* Sanity check options */
if|if
condition|(
name|amend
operator|&&
operator|!
name|current_head
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You have nothing to amend."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
operator|&&
name|whence
operator|!=
name|FROM_COMMIT
condition|)
block|{
if|if
condition|(
name|whence
operator|==
name|FROM_MERGE
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You are in the middle of a merge -- cannot amend."
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|whence
operator|==
name|FROM_CHERRY_PICK
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You are in the middle of a cherry-pick -- cannot amend."
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixup_message
operator|&&
name|squash_message
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Options --squash and --fixup cannot be used together"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|edit_message
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|fixup_message
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|logfile
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|f
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Only one of -c/-C/-F/--fixup can be used."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|.
name|len
operator|&&
name|f
operator|>
literal|0
condition|)
name|die
argument_list|(
operator|(
name|_
argument_list|(
literal|"Option -m cannot be combined with -c/-C/-F/--fixup."
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|||
name|message
operator|.
name|len
condition|)
name|template_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|edit_message
condition|)
name|use_message
operator|=
name|edit_message
expr_stmt|;
if|if
condition|(
name|amend
operator|&&
operator|!
name|use_message
operator|&&
operator|!
name|fixup_message
condition|)
name|use_message
operator|=
literal|"HEAD"
expr_stmt|;
if|if
condition|(
operator|!
name|use_message
operator|&&
name|whence
operator|!=
name|FROM_CHERRY_PICK
operator|&&
name|renew_authorship
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--reset-author can be used only with -C, -c or --amend."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
block|{
name|use_message_buffer
operator|=
name|read_commit_message
argument_list|(
name|use_message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|renew_authorship
condition|)
block|{
name|author_message
operator|=
name|use_message
expr_stmt|;
name|author_message_buffer
operator|=
name|use_message_buffer
expr_stmt|;
block|}
block|}
if|if
condition|(
name|whence
operator|==
name|FROM_CHERRY_PICK
operator|&&
operator|!
name|renew_authorship
condition|)
block|{
name|author_message
operator|=
literal|"CHERRY_PICK_HEAD"
expr_stmt|;
name|author_message_buffer
operator|=
name|read_commit_message
argument_list|(
name|author_message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|patch_interactive
condition|)
name|interactive
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|also
operator|+
name|only
operator|+
name|all
operator|+
name|interactive
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Only one of --include/--only/--all/--interactive/--patch can be used."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
operator|(
name|also
operator|||
operator|(
name|only
operator|&&
operator|!
name|amend
operator|)
operator|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No paths with --include/--only does not make sense."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|only
operator|&&
name|amend
condition|)
name|only_include_assumed
operator|=
name|_
argument_list|(
literal|"Clever... amending the last one with dirty index."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|!
name|also
operator|&&
operator|!
name|only
condition|)
name|only_include_assumed
operator|=
name|_
argument_list|(
literal|"Explicit paths specified without -i or -o; assuming --only paths..."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cleanup_arg
operator|||
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"default"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|use_editor
condition|?
name|CLEANUP_ALL
else|:
name|CLEANUP_SPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"verbatim"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_NONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"whitespace"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_SPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"strip"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_ALL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"scissors"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|use_editor
condition|?
name|CLEANUP_SCISSORS
else|:
name|CLEANUP_SPACE
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"Invalid cleanup mode %s"
argument_list|)
argument_list|,
name|cleanup_arg
argument_list|)
expr_stmt|;
name|handle_untracked_files_arg
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
operator|&&
name|argc
operator|>
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Paths with -a does not make sense."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_format
operator|!=
name|STATUS_FORMAT_NONE
condition|)
name|dry_run
operator|=
literal|1
expr_stmt|;
return|return
name|argc
return|;
block|}
end_function
begin_function
DECL|function|dry_run_commit
specifier|static
name|int
name|dry_run_commit
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|current_head
parameter_list|,
name|struct
name|wt_status
modifier|*
name|s
parameter_list|)
block|{
name|int
name|commitable
decl_stmt|;
specifier|const
name|char
modifier|*
name|index_file
decl_stmt|;
name|index_file
operator|=
name|prepare_index
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|current_head
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|commitable
operator|=
name|run_status
argument_list|(
name|stdout
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|rollback_index_files
argument_list|()
expr_stmt|;
return|return
name|commitable
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|parse_status_slot
specifier|static
name|int
name|parse_status_slot
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"header"
argument_list|)
condition|)
return|return
name|WT_STATUS_HEADER
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"branch"
argument_list|)
condition|)
return|return
name|WT_STATUS_ONBRANCH
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"updated"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"added"
argument_list|)
condition|)
return|return
name|WT_STATUS_UPDATED
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"changed"
argument_list|)
condition|)
return|return
name|WT_STATUS_CHANGED
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"untracked"
argument_list|)
condition|)
return|return
name|WT_STATUS_UNTRACKED
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"nobranch"
argument_list|)
condition|)
return|return
name|WT_STATUS_NOBRANCH
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|offset
argument_list|,
literal|"unmerged"
argument_list|)
condition|)
return|return
name|WT_STATUS_UNMERGED
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|git_status_config
specifier|static
name|int
name|git_status_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|wt_status
modifier|*
name|s
init|=
name|cb
decl_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|k
argument_list|,
literal|"column."
argument_list|)
condition|)
return|return
name|git_column_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
literal|"status"
argument_list|,
operator|&
name|s
operator|->
name|colopts
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"status.submodulesummary"
argument_list|)
condition|)
block|{
name|int
name|is_bool
decl_stmt|;
name|s
operator|->
name|submodule_summary
operator|=
name|git_config_bool_or_int
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
operator|&
name|is_bool
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_bool
operator|&&
name|s
operator|->
name|submodule_summary
condition|)
name|s
operator|->
name|submodule_summary
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"status.short"
argument_list|)
condition|)
block|{
if|if
condition|(
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
condition|)
name|status_deferred_config
operator|.
name|status_format
operator|=
name|STATUS_FORMAT_SHORT
expr_stmt|;
else|else
name|status_deferred_config
operator|.
name|status_format
operator|=
name|STATUS_FORMAT_NONE
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"status.branch"
argument_list|)
condition|)
block|{
name|status_deferred_config
operator|.
name|show_branch
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"status.color"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"color.status"
argument_list|)
condition|)
block|{
name|s
operator|->
name|use_color
operator|=
name|git_config_colorbool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"status.displaycommentprefix"
argument_list|)
condition|)
block|{
name|s
operator|->
name|display_comment_prefix
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|starts_with
argument_list|(
name|k
argument_list|,
literal|"status.color."
argument_list|)
operator|||
name|starts_with
argument_list|(
name|k
argument_list|,
literal|"color.status."
argument_list|)
condition|)
block|{
name|int
name|slot
init|=
name|parse_status_slot
argument_list|(
name|k
argument_list|,
literal|13
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|v
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|k
argument_list|)
return|;
name|color_parse
argument_list|(
name|v
argument_list|,
name|k
argument_list|,
name|s
operator|->
name|color_palette
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"status.relativepaths"
argument_list|)
condition|)
block|{
name|s
operator|->
name|relative_paths
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"status.showuntrackedfiles"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|v
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|k
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"no"
argument_list|)
condition|)
name|s
operator|->
name|show_untracked_files
operator|=
name|SHOW_NO_UNTRACKED_FILES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"normal"
argument_list|)
condition|)
name|s
operator|->
name|show_untracked_files
operator|=
name|SHOW_NORMAL_UNTRACKED_FILES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"all"
argument_list|)
condition|)
name|s
operator|->
name|show_untracked_files
operator|=
name|SHOW_ALL_UNTRACKED_FILES
expr_stmt|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid untracked files mode '%s'"
argument_list|)
argument_list|,
name|v
argument_list|)
return|;
return|return
literal|0
return|;
block|}
return|return
name|git_diff_ui_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_status
name|int
name|cmd_status
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|static
name|struct
name|wt_status
name|s
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|struct
name|option
name|builtin_status_options
index|[]
init|=
block|{
name|OPT__VERBOSE
argument_list|(
operator|&
name|verbose
argument_list|,
name|N_
argument_list|(
literal|"be verbose"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'s'
argument_list|,
literal|"short"
argument_list|,
operator|&
name|status_format
argument_list|,
name|N_
argument_list|(
literal|"show status concisely"
argument_list|)
argument_list|,
name|STATUS_FORMAT_SHORT
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'b'
argument_list|,
literal|"branch"
argument_list|,
operator|&
name|s
operator|.
name|show_branch
argument_list|,
name|N_
argument_list|(
literal|"show branch information"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"porcelain"
argument_list|,
operator|&
name|status_format
argument_list|,
name|N_
argument_list|(
literal|"machine-readable output"
argument_list|)
argument_list|,
name|STATUS_FORMAT_PORCELAIN
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"long"
argument_list|,
operator|&
name|status_format
argument_list|,
name|N_
argument_list|(
literal|"show status in long format (default)"
argument_list|)
argument_list|,
name|STATUS_FORMAT_LONG
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'z'
argument_list|,
literal|"null"
argument_list|,
operator|&
name|s
operator|.
name|null_termination
argument_list|,
name|N_
argument_list|(
literal|"terminate entries with NUL"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_STRING
block|,
literal|'u'
block|,
literal|"untracked-files"
block|,
operator|&
name|untracked_files_arg
block|,
name|N_
argument_list|(
literal|"mode"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show untracked files, optional modes: all, normal, no. (Default: all)"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
operator|(
name|intptr_t
operator|)
literal|"all"
block|}
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"ignored"
argument_list|,
operator|&
name|show_ignored_in_status
argument_list|,
name|N_
argument_list|(
literal|"show ignored files"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_STRING
block|,
literal|0
block|,
literal|"ignore-submodules"
block|,
operator|&
name|ignore_submodule_arg
block|,
name|N_
argument_list|(
literal|"when"
argument_list|)
block|,
name|N_
argument_list|(
literal|"ignore changes to submodules, optional when: all, dirty, untracked. (Default: all)"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
operator|(
name|intptr_t
operator|)
literal|"all"
block|}
block|,
name|OPT_COLUMN
argument_list|(
literal|0
argument_list|,
literal|"column"
argument_list|,
operator|&
name|s
operator|.
name|colopts
argument_list|,
name|N_
argument_list|(
literal|"list untracked files in columns"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|, 	}
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage_with_options
argument_list|(
name|builtin_status_usage
argument_list|,
name|builtin_status_options
argument_list|)
expr_stmt|;
name|status_init_config
argument_list|(
operator|&
name|s
argument_list|,
name|git_status_config
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_status_options
argument_list|,
name|builtin_status_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finalize_colopts
argument_list|(
operator|&
name|s
operator|.
name|colopts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|finalize_deferred_config
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|handle_untracked_files_arg
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_ignored_in_status
condition|)
name|s
operator|.
name|show_ignored_files
operator|=
literal|1
expr_stmt|;
name|parse_pathspec
argument_list|(
operator|&
name|s
operator|.
name|pathspec
argument_list|,
literal|0
argument_list|,
name|PATHSPEC_PREFER_FULL
argument_list|,
name|prefix
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|read_cache_preload
argument_list|(
operator|&
name|s
operator|.
name|pathspec
argument_list|)
expr_stmt|;
name|refresh_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|REFRESH_QUIET
operator||
name|REFRESH_UNMERGED
argument_list|,
operator|&
name|s
operator|.
name|pathspec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|update_index_if_able
argument_list|(
operator|&
name|the_index
argument_list|,
operator|&
name|index_lock
argument_list|)
expr_stmt|;
name|s
operator|.
name|is_initial
operator|=
name|get_sha1
argument_list|(
name|s
operator|.
name|reference
argument_list|,
name|sha1
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|s
operator|.
name|ignore_submodule_arg
operator|=
name|ignore_submodule_arg
expr_stmt|;
name|wt_status_collect
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|relative_paths
condition|)
name|s
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
switch|switch
condition|(
name|status_format
condition|)
block|{
case|case
name|STATUS_FORMAT_SHORT
case|:
name|wt_shortstatus_print
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_FORMAT_PORCELAIN
case|:
name|wt_porcelain_print
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_FORMAT_UNSPECIFIED
case|:
name|die
argument_list|(
literal|"BUG: finalize_deferred_config() should have been called"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATUS_FORMAT_NONE
case|:
case|case
name|STATUS_FORMAT_LONG
case|:
name|s
operator|.
name|verbose
operator|=
name|verbose
expr_stmt|;
name|s
operator|.
name|ignore_submodule_arg
operator|=
name|ignore_submodule_arg
expr_stmt|;
name|wt_status_print
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|implicit_ident_advice
specifier|static
specifier|const
name|char
modifier|*
name|implicit_ident_advice
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|user_config
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|xdg_config
init|=
name|NULL
decl_stmt|;
name|int
name|config_exists
decl_stmt|;
name|home_config_paths
argument_list|(
operator|&
name|user_config
argument_list|,
operator|&
name|xdg_config
argument_list|,
literal|"config"
argument_list|)
expr_stmt|;
name|config_exists
operator|=
name|file_exists
argument_list|(
name|user_config
argument_list|)
operator|||
name|file_exists
argument_list|(
name|xdg_config
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|user_config
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xdg_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_exists
condition|)
return|return
name|_
argument_list|(
name|implicit_ident_advice_config
argument_list|)
return|;
else|else
return|return
name|_
argument_list|(
name|implicit_ident_advice_noconfig
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|print_summary
specifier|static
name|void
name|print_summary
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|initial_commit
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|strbuf
name|format
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|junk_sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|head
decl_stmt|;
name|struct
name|pretty_print_context
name|pctx
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|strbuf
name|author_ident
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|committer_ident
init|=
name|STRBUF_INIT
decl_stmt|;
name|commit
operator|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"couldn't look up newly created commit"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse newly created commit"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|format
argument_list|,
literal|"format:%h] %s"
argument_list|)
expr_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
literal|"%an<%ae>"
argument_list|,
operator|&
name|author_ident
argument_list|,
operator|&
name|pctx
argument_list|)
expr_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
literal|"%cn<%ce>"
argument_list|,
operator|&
name|committer_ident
argument_list|,
operator|&
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_cmp
argument_list|(
operator|&
name|author_ident
argument_list|,
operator|&
name|committer_ident
argument_list|)
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|format
argument_list|,
literal|"\n Author: "
argument_list|)
expr_stmt|;
name|strbuf_addbuf_percentquote
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|author_ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|author_date_is_interesting
argument_list|()
condition|)
block|{
name|struct
name|strbuf
name|date
init|=
name|STRBUF_INIT
decl_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
literal|"%ad"
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|pctx
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|format
argument_list|,
literal|"\n Date: "
argument_list|)
expr_stmt|;
name|strbuf_addbuf_percentquote
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|committer_ident_sufficiently_given
argument_list|()
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|format
argument_list|,
literal|"\n Committer: "
argument_list|)
expr_stmt|;
name|strbuf_addbuf_percentquote
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|committer_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_implicit_identity
condition|)
block|{
name|strbuf_addch
argument_list|(
operator|&
name|format
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|format
argument_list|,
name|implicit_ident_advice
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_release
argument_list|(
operator|&
name|author_ident
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|committer_ident
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_SHORTSTAT
operator||
name|DIFF_FORMAT_SUMMARY
expr_stmt|;
name|rev
operator|.
name|verbose_header
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|show_root_diff
operator|=
literal|1
expr_stmt|;
name|get_commit_format
argument_list|(
name|format
operator|.
name|buf
argument_list|,
operator|&
name|rev
argument_list|)
expr_stmt|;
name|rev
operator|.
name|always_show_header
operator|=
literal|0
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|detect_rename
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|break_opt
operator|=
literal|0
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|)
expr_stmt|;
name|head
operator|=
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
name|junk_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s%s "
argument_list|,
name|starts_with
argument_list|(
name|head
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|?
name|head
operator|+
literal|11
else|:
operator|!
name|strcmp
argument_list|(
name|head
argument_list|,
literal|"HEAD"
argument_list|)
condition|?
name|_
argument_list|(
literal|"detached HEAD"
argument_list|)
else|:
name|head
argument_list|,
name|initial_commit
condition|?
name|_
argument_list|(
literal|" (root-commit)"
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_tree_commit
argument_list|(
operator|&
name|rev
argument_list|,
name|commit
argument_list|)
condition|)
block|{
name|rev
operator|.
name|always_show_header
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|use_terminator
operator|=
literal|1
expr_stmt|;
name|log_tree_commit
argument_list|(
operator|&
name|rev
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|format
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|git_commit_config
specifier|static
name|int
name|git_commit_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|wt_status
modifier|*
name|s
init|=
name|cb
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"commit.template"
argument_list|)
condition|)
return|return
name|git_config_pathname
argument_list|(
operator|&
name|template_file
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"commit.status"
argument_list|)
condition|)
block|{
name|include_status
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"commit.cleanup"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|cleanup_arg
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"commit.gpgsign"
argument_list|)
condition|)
block|{
name|sign_commit
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
condition|?
literal|""
else|:
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|git_gpg_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
return|return
name|git_status_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|run_rewrite_hook
specifier|static
name|int
name|run_rewrite_hook
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|oldsha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|newsha1
parameter_list|)
block|{
comment|/* oldsha1 SP newsha1 LF NUL */
specifier|static
name|char
name|buf
index|[
literal|2
operator|*
literal|40
operator|+
literal|3
index|]
decl_stmt|;
name|struct
name|child_process
name|proc
init|=
name|CHILD_PROCESS_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|3
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|find_hook
argument_list|(
literal|"post-rewrite"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argv
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
name|argv
index|[
literal|1
index|]
operator|=
literal|"amend"
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|proc
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|proc
operator|.
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|proc
operator|.
name|stdout_to_stderr
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|start_command
argument_list|(
operator|&
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
return|return
name|code
return|;
name|n
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|oldsha1
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|newsha1
argument_list|)
argument_list|)
expr_stmt|;
name|write_in_full
argument_list|(
name|proc
operator|.
name|in
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|proc
operator|.
name|in
argument_list|)
expr_stmt|;
return|return
name|finish_command
argument_list|(
operator|&
name|proc
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|run_commit_hook
name|int
name|run_commit_hook
parameter_list|(
name|int
name|editor_is_used
parameter_list|,
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hook_env
index|[
literal|3
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|char
name|index
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|snprintf
argument_list|(
name|index
argument_list|,
sizeof|sizeof
argument_list|(
name|index
argument_list|)
argument_list|,
literal|"GIT_INDEX_FILE=%s"
argument_list|,
name|index_file
argument_list|)
expr_stmt|;
name|hook_env
index|[
literal|0
index|]
operator|=
name|index
expr_stmt|;
comment|/* 	 * Let the hook know that no editor will be launched. 	 */
if|if
condition|(
operator|!
name|editor_is_used
condition|)
name|hook_env
index|[
literal|1
index|]
operator|=
literal|"GIT_EDITOR=:"
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|run_hook_ve
argument_list|(
name|hook_env
argument_list|,
name|name
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|cmd_commit
name|int
name|cmd_commit
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|static
name|struct
name|wt_status
name|s
decl_stmt|;
specifier|static
name|struct
name|option
name|builtin_commit_options
index|[]
init|=
block|{
name|OPT__QUIET
argument_list|(
operator|&
name|quiet
argument_list|,
name|N_
argument_list|(
literal|"suppress summary after successful commit"
argument_list|)
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|verbose
argument_list|,
name|N_
argument_list|(
literal|"show diff in commit message template"
argument_list|)
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Commit message options"
argument_list|)
argument_list|)
block|,
name|OPT_FILENAME
argument_list|(
literal|'F'
argument_list|,
literal|"file"
argument_list|,
operator|&
name|logfile
argument_list|,
name|N_
argument_list|(
literal|"read message from file"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"author"
argument_list|,
operator|&
name|force_author
argument_list|,
name|N_
argument_list|(
literal|"author"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"override author for commit"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"date"
argument_list|,
operator|&
name|force_date
argument_list|,
name|N_
argument_list|(
literal|"date"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"override date for commit"
argument_list|)
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|'m'
argument_list|,
literal|"message"
argument_list|,
operator|&
name|message
argument_list|,
name|N_
argument_list|(
literal|"message"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"commit message"
argument_list|)
argument_list|,
name|opt_parse_m
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'c'
argument_list|,
literal|"reedit-message"
argument_list|,
operator|&
name|edit_message
argument_list|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"reuse and edit message from specified commit"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'C'
argument_list|,
literal|"reuse-message"
argument_list|,
operator|&
name|use_message
argument_list|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"reuse message from specified commit"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"fixup"
argument_list|,
operator|&
name|fixup_message
argument_list|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"use autosquash formatted message to fixup specified commit"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"squash"
argument_list|,
operator|&
name|squash_message
argument_list|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"use autosquash formatted message to squash specified commit"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"reset-author"
argument_list|,
operator|&
name|renew_authorship
argument_list|,
name|N_
argument_list|(
literal|"the commit is authored by me now (used with -C/-c/--amend)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'s'
argument_list|,
literal|"signoff"
argument_list|,
operator|&
name|signoff
argument_list|,
name|N_
argument_list|(
literal|"add Signed-off-by:"
argument_list|)
argument_list|)
block|,
name|OPT_FILENAME
argument_list|(
literal|'t'
argument_list|,
literal|"template"
argument_list|,
operator|&
name|template_file
argument_list|,
name|N_
argument_list|(
literal|"use specified template file"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'e'
argument_list|,
literal|"edit"
argument_list|,
operator|&
name|edit_flag
argument_list|,
name|N_
argument_list|(
literal|"force edit of commit"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"cleanup"
argument_list|,
operator|&
name|cleanup_arg
argument_list|,
name|N_
argument_list|(
literal|"default"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"how to strip spaces and #comments from message"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"status"
argument_list|,
operator|&
name|include_status
argument_list|,
name|N_
argument_list|(
literal|"include status in commit message template"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_STRING
block|,
literal|'S'
block|,
literal|"gpg-sign"
block|,
operator|&
name|sign_commit
block|,
name|N_
argument_list|(
literal|"key-id"
argument_list|)
block|,
name|N_
argument_list|(
literal|"GPG sign commit"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
operator|(
name|intptr_t
operator|)
literal|""
block|}
block|,
comment|/* end commit message options */
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Commit contents options"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'a'
argument_list|,
literal|"all"
argument_list|,
operator|&
name|all
argument_list|,
name|N_
argument_list|(
literal|"commit all changed files"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'i'
argument_list|,
literal|"include"
argument_list|,
operator|&
name|also
argument_list|,
name|N_
argument_list|(
literal|"add specified files to index for commit"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"interactive"
argument_list|,
operator|&
name|interactive
argument_list|,
name|N_
argument_list|(
literal|"interactively add files"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'p'
argument_list|,
literal|"patch"
argument_list|,
operator|&
name|patch_interactive
argument_list|,
name|N_
argument_list|(
literal|"interactively add changes"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'o'
argument_list|,
literal|"only"
argument_list|,
operator|&
name|only
argument_list|,
name|N_
argument_list|(
literal|"commit only specified files"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'n'
argument_list|,
literal|"no-verify"
argument_list|,
operator|&
name|no_verify
argument_list|,
name|N_
argument_list|(
literal|"bypass pre-commit hook"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"dry-run"
argument_list|,
operator|&
name|dry_run
argument_list|,
name|N_
argument_list|(
literal|"show what would be committed"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"short"
argument_list|,
operator|&
name|status_format
argument_list|,
name|N_
argument_list|(
literal|"show status concisely"
argument_list|)
argument_list|,
name|STATUS_FORMAT_SHORT
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"branch"
argument_list|,
operator|&
name|s
operator|.
name|show_branch
argument_list|,
name|N_
argument_list|(
literal|"show branch information"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"porcelain"
argument_list|,
operator|&
name|status_format
argument_list|,
name|N_
argument_list|(
literal|"machine-readable output"
argument_list|)
argument_list|,
name|STATUS_FORMAT_PORCELAIN
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"long"
argument_list|,
operator|&
name|status_format
argument_list|,
name|N_
argument_list|(
literal|"show status in long format (default)"
argument_list|)
argument_list|,
name|STATUS_FORMAT_LONG
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'z'
argument_list|,
literal|"null"
argument_list|,
operator|&
name|s
operator|.
name|null_termination
argument_list|,
name|N_
argument_list|(
literal|"terminate entries with NUL"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"amend"
argument_list|,
operator|&
name|amend
argument_list|,
name|N_
argument_list|(
literal|"amend previous commit"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"no-post-rewrite"
argument_list|,
operator|&
name|no_post_rewrite
argument_list|,
name|N_
argument_list|(
literal|"bypass post-rewrite hook"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_STRING
block|,
literal|'u'
block|,
literal|"untracked-files"
block|,
operator|&
name|untracked_files_arg
block|,
name|N_
argument_list|(
literal|"mode"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show untracked files, optional modes: all, normal, no. (Default: all)"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
operator|(
name|intptr_t
operator|)
literal|"all"
block|}
block|,
comment|/* end commit contents options */
name|OPT_HIDDEN_BOOL
argument_list|(
literal|0
argument_list|,
literal|"allow-empty"
argument_list|,
operator|&
name|allow_empty
argument_list|,
name|N_
argument_list|(
literal|"ok to record an empty change"
argument_list|)
argument_list|)
block|,
name|OPT_HIDDEN_BOOL
argument_list|(
literal|0
argument_list|,
literal|"allow-empty-message"
argument_list|,
operator|&
name|allow_empty_message
argument_list|,
name|N_
argument_list|(
literal|"ok to record a change with an empty message"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|author_ident
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|index_file
decl_stmt|,
modifier|*
name|reflog_msg
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|pptr
init|=
operator|&
name|parents
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|struct
name|commit
modifier|*
name|current_head
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_extra_header
modifier|*
name|extra
init|=
name|NULL
decl_stmt|;
name|struct
name|ref_transaction
modifier|*
name|transaction
decl_stmt|;
name|struct
name|strbuf
name|err
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage_with_options
argument_list|(
name|builtin_commit_usage
argument_list|,
name|builtin_commit_options
argument_list|)
expr_stmt|;
name|status_init_config
argument_list|(
operator|&
name|s
argument_list|,
name|git_commit_config
argument_list|)
expr_stmt|;
name|status_format
operator|=
name|STATUS_FORMAT_NONE
expr_stmt|;
comment|/* Ignore status.short */
name|s
operator|.
name|colopts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|)
condition|)
name|current_head
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|current_head
operator|=
name|lookup_commit_or_die
argument_list|(
name|sha1
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|current_head
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse HEAD commit"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argc
operator|=
name|parse_and_validate_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|builtin_commit_options
argument_list|,
name|builtin_commit_usage
argument_list|,
name|prefix
argument_list|,
name|current_head
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
return|return
name|dry_run_commit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|current_head
argument_list|,
operator|&
name|s
argument_list|)
return|;
name|index_file
operator|=
name|prepare_index
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|current_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up everything for writing the commit object.  This includes 	   running hooks, writing the trees, and interacting with the user.  */
if|if
condition|(
operator|!
name|prepare_to_commit
argument_list|(
name|index_file
argument_list|,
name|prefix
argument_list|,
name|current_head
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|author_ident
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Determine parents */
name|reflog_msg
operator|=
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_head
condition|)
block|{
if|if
condition|(
operator|!
name|reflog_msg
condition|)
name|reflog_msg
operator|=
literal|"commit (initial)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amend
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|reflog_msg
condition|)
name|reflog_msg
operator|=
literal|"commit (amend)"
expr_stmt|;
for|for
control|(
name|c
operator|=
name|current_head
operator|->
name|parents
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|c
operator|->
name|item
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|whence
operator|==
name|FROM_MERGE
condition|)
block|{
name|struct
name|strbuf
name|m
init|=
name|STRBUF_INIT
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|allow_fast_forward
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|reflog_msg
condition|)
name|reflog_msg
operator|=
literal|"commit (merge)"
expr_stmt|;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|current_head
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not open '%s' for reading"
argument_list|)
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|m
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
decl_stmt|;
name|parent
operator|=
name|get_merge_parent
argument_list|(
name|m
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Corrupt MERGE_HEAD file (%s)"
argument_list|)
argument_list|,
name|m
operator|.
name|buf
argument_list|)
expr_stmt|;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"could not read MERGE_MODE"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"no-ff"
argument_list|)
condition|)
name|allow_fast_forward
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|allow_fast_forward
condition|)
name|parents
operator|=
name|reduce_heads
argument_list|(
name|parents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reflog_msg
condition|)
name|reflog_msg
operator|=
operator|(
name|whence
operator|==
name|FROM_CHERRY_PICK
operator|)
condition|?
literal|"commit (cherry-pick)"
else|:
literal|"commit"
expr_stmt|;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|current_head
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
comment|/* Finally, get the commit message */
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"could not read commit message: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|saved_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|||
comment|/* Truncate the message just before the diff, if any. */
name|cleanup_mode
operator|==
name|CLEANUP_SCISSORS
condition|)
name|wt_status_truncate_message_at_cut_line
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_mode
operator|!=
name|CLEANUP_NONE
condition|)
name|stripspace
argument_list|(
operator|&
name|sb
argument_list|,
name|cleanup_mode
operator|==
name|CLEANUP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_untouched
argument_list|(
operator|&
name|sb
argument_list|)
operator|&&
operator|!
name|allow_empty_message
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Aborting commit; you did not edit the message.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|message_is_empty
argument_list|(
operator|&
name|sb
argument_list|)
operator|&&
operator|!
name|allow_empty_message
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Aborting commit due to empty commit message.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|amend
condition|)
block|{
specifier|const
name|char
modifier|*
name|exclude_gpgsig
index|[
literal|2
index|]
init|=
block|{
literal|"gpgsig"
block|,
name|NULL
block|}
decl_stmt|;
name|extra
operator|=
name|read_commit_extra_headers
argument_list|(
name|current_head
argument_list|,
name|exclude_gpgsig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|commit_extra_header
modifier|*
modifier|*
name|tail
init|=
operator|&
name|extra
decl_stmt|;
name|append_merge_tag_headers
argument_list|(
name|parents
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit_tree_extended
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|active_cache_tree
operator|->
name|sha1
argument_list|,
name|parents
argument_list|,
name|sha1
argument_list|,
name|author_ident
operator|.
name|buf
argument_list|,
name|sign_commit
argument_list|,
name|extra
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"failed to write commit object"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|author_ident
argument_list|)
expr_stmt|;
name|free_commit_extra_headers
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|strbuf_setlen
argument_list|(
operator|&
name|sb
argument_list|,
name|nl
operator|+
literal|1
operator|-
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|reflog_msg
argument_list|,
name|strlen
argument_list|(
name|reflog_msg
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|sb
argument_list|,
name|strlen
argument_list|(
name|reflog_msg
argument_list|)
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|transaction
operator|=
name|ref_transaction_begin
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transaction
operator|||
name|ref_transaction_update
argument_list|(
name|transaction
argument_list|,
literal|"HEAD"
argument_list|,
name|sha1
argument_list|,
name|current_head
condition|?
name|current_head
operator|->
name|object
operator|.
name|sha1
else|:
name|NULL
argument_list|,
literal|0
argument_list|,
operator|!
operator|!
name|current_head
argument_list|,
operator|&
name|err
argument_list|)
operator|||
name|ref_transaction_commit
argument_list|(
name|transaction
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"%s"
argument_list|,
name|err
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|ref_transaction_free
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"REVERT_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_index_files
argument_list|()
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Repository has been updated, but unable to write\n"
literal|"new_index file. Check that disk is not full or quota is\n"
literal|"not exceeded, and then \"git reset HEAD\" to recover."
argument_list|)
argument_list|)
expr_stmt|;
name|rerere
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|run_commit_hook
argument_list|(
name|use_editor
argument_list|,
name|get_index_file
argument_list|()
argument_list|,
literal|"post-commit"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
operator|&&
operator|!
name|no_post_rewrite
condition|)
block|{
name|struct
name|notes_rewrite_cfg
modifier|*
name|cfg
decl_stmt|;
name|cfg
operator|=
name|init_copy_notes_for_rewrite
argument_list|(
literal|"amend"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
block|{
comment|/* we are amending, so current_head is not NULL */
name|copy_note_for_rewrite
argument_list|(
name|cfg
argument_list|,
name|current_head
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|finish_copy_notes_for_rewrite
argument_list|(
name|cfg
argument_list|,
literal|"Notes added by 'git commit --amend'"
argument_list|)
expr_stmt|;
block|}
name|run_rewrite_hook
argument_list|(
name|current_head
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|print_summary
argument_list|(
name|prefix
argument_list|,
name|sha1
argument_list|,
operator|!
name|current_head
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
