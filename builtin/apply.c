begin_unit
begin_comment
comment|/*  * apply.c  *  * Copyright (C) Linus Torvalds, 2005  *  * This applies patches on top of some (arbitrary) version of the SCM.  *  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"delta.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"ll-merge.h"
end_include
begin_include
include|#
directive|include
file|"rerere.h"
end_include
begin_comment
comment|/*  *  --check turns on checking that the working tree matches the  *    files that are being modified, but doesn't apply the patch  *  --stat does just a diffstat, and doesn't actually apply  *  --numstat does numeric diffstat, and doesn't actually apply  *  --index-info shows the old and new index info for paths if available.  *  --index updates the cache as well.  *  --cached updates only the cache without ever touching the working tree.  */
end_comment
begin_decl_stmt
DECL|variable|prefix
specifier|static
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|prefix_length
specifier|static
name|int
name|prefix_length
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|newfd
specifier|static
name|int
name|newfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|unidiff_zero
specifier|static
name|int
name|unidiff_zero
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|p_value
specifier|static
name|int
name|p_value
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|p_value_known
specifier|static
name|int
name|p_value_known
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|check_index
specifier|static
name|int
name|check_index
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|update_index
specifier|static
name|int
name|update_index
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cached
specifier|static
name|int
name|cached
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|diffstat
specifier|static
name|int
name|diffstat
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|numstat
specifier|static
name|int
name|numstat
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|summary
specifier|static
name|int
name|summary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|check
specifier|static
name|int
name|check
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apply
specifier|static
name|int
name|apply
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apply_in_reverse
specifier|static
name|int
name|apply_in_reverse
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apply_with_reject
specifier|static
name|int
name|apply_with_reject
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apply_verbosely
specifier|static
name|int
name|apply_verbosely
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allow_overlap
specifier|static
name|int
name|allow_overlap
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_add
specifier|static
name|int
name|no_add
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|threeway
specifier|static
name|int
name|threeway
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fake_ancestor
specifier|static
specifier|const
name|char
modifier|*
name|fake_ancestor
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|line_termination
specifier|static
name|int
name|line_termination
init|=
literal|'\n'
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|p_context
specifier|static
name|unsigned
name|int
name|p_context
init|=
name|UINT_MAX
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|apply_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|apply_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git apply [options] [<patch>...]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|ws_error_action
specifier|static
enum|enum
name|ws_error_action
block|{
DECL|enumerator|nowarn_ws_error
name|nowarn_ws_error
block|,
DECL|enumerator|warn_on_ws_error
name|warn_on_ws_error
block|,
DECL|enumerator|die_on_ws_error
name|die_on_ws_error
block|,
DECL|enumerator|correct_ws_error
name|correct_ws_error
block|}
DECL|variable|ws_error_action
name|ws_error_action
init|=
name|warn_on_ws_error
enum|;
end_enum
begin_decl_stmt
DECL|variable|whitespace_error
specifier|static
name|int
name|whitespace_error
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|squelch_whitespace_errors
specifier|static
name|int
name|squelch_whitespace_errors
init|=
literal|5
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|applied_after_fixing_ws
specifier|static
name|int
name|applied_after_fixing_ws
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|ws_ignore
specifier|static
enum|enum
name|ws_ignore
block|{
DECL|enumerator|ignore_ws_none
name|ignore_ws_none
block|,
DECL|enumerator|ignore_ws_change
name|ignore_ws_change
block|}
DECL|variable|ws_ignore_action
name|ws_ignore_action
init|=
name|ignore_ws_none
enum|;
end_enum
begin_decl_stmt
DECL|variable|patch_input_file
specifier|static
specifier|const
name|char
modifier|*
name|patch_input_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|root
specifier|static
specifier|const
name|char
modifier|*
name|root
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|root_len
specifier|static
name|int
name|root_len
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|read_stdin
specifier|static
name|int
name|read_stdin
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|options
specifier|static
name|int
name|options
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parse_whitespace_option
specifier|static
name|void
name|parse_whitespace_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|)
block|{
if|if
condition|(
operator|!
name|option
condition|)
block|{
name|ws_error_action
operator|=
name|warn_on_ws_error
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"warn"
argument_list|)
condition|)
block|{
name|ws_error_action
operator|=
name|warn_on_ws_error
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"nowarn"
argument_list|)
condition|)
block|{
name|ws_error_action
operator|=
name|nowarn_ws_error
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"error"
argument_list|)
condition|)
block|{
name|ws_error_action
operator|=
name|die_on_ws_error
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"error-all"
argument_list|)
condition|)
block|{
name|ws_error_action
operator|=
name|die_on_ws_error
expr_stmt|;
name|squelch_whitespace_errors
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"strip"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"fix"
argument_list|)
condition|)
block|{
name|ws_error_action
operator|=
name|correct_ws_error
expr_stmt|;
return|return;
block|}
name|die
argument_list|(
name|_
argument_list|(
literal|"unrecognized whitespace option '%s'"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_ignorewhitespace_option
specifier|static
name|void
name|parse_ignorewhitespace_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|)
block|{
if|if
condition|(
operator|!
name|option
operator|||
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"no"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"never"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"none"
argument_list|)
condition|)
block|{
name|ws_ignore_action
operator|=
name|ignore_ws_none
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"change"
argument_list|)
condition|)
block|{
name|ws_ignore_action
operator|=
name|ignore_ws_change
expr_stmt|;
return|return;
block|}
name|die
argument_list|(
name|_
argument_list|(
literal|"unrecognized whitespace ignore option '%s'"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|set_default_whitespace_mode
specifier|static
name|void
name|set_default_whitespace_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|whitespace_option
parameter_list|)
block|{
if|if
condition|(
operator|!
name|whitespace_option
operator|&&
operator|!
name|apply_default_whitespace
condition|)
name|ws_error_action
operator|=
operator|(
name|apply
condition|?
name|warn_on_ws_error
else|:
name|nowarn_ws_error
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * For "diff-stat" like behaviour, we keep track of the biggest change  * we've seen, and the longest filename. That allows us to do simple  * scaling.  */
end_comment
begin_decl_stmt
DECL|variable|max_change
DECL|variable|max_len
specifier|static
name|int
name|max_change
decl_stmt|,
name|max_len
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Various "current state", notably line numbers and what  * file (and how) we're patching right now.. The "is_xxxx"  * things are flags, where -1 means "don't know yet".  */
end_comment
begin_decl_stmt
DECL|variable|linenr
specifier|static
name|int
name|linenr
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * This represents one "hunk" from a patch, starting with  * "@@ -oldpos,oldlines +newpos,newlines @@" marker.  The  * patch text is pointed at by patch, and its byte length  * is stored in size.  leading and trailing are the number  * of context lines.  */
end_comment
begin_struct
DECL|struct|fragment
struct|struct
name|fragment
block|{
DECL|member|leading
DECL|member|trailing
name|unsigned
name|long
name|leading
decl_stmt|,
name|trailing
decl_stmt|;
DECL|member|oldpos
DECL|member|oldlines
name|unsigned
name|long
name|oldpos
decl_stmt|,
name|oldlines
decl_stmt|;
DECL|member|newpos
DECL|member|newlines
name|unsigned
name|long
name|newpos
decl_stmt|,
name|newlines
decl_stmt|;
comment|/* 	 * 'patch' is usually borrowed from buf in apply_patch(), 	 * but some codepaths store an allocated buffer. 	 */
DECL|member|patch
specifier|const
name|char
modifier|*
name|patch
decl_stmt|;
DECL|member|free_patch
name|unsigned
name|free_patch
range|:
literal|1
decl_stmt|,
DECL|member|rejected
name|rejected
range|:
literal|1
decl_stmt|;
DECL|member|size
name|int
name|size
decl_stmt|;
DECL|member|linenr
name|int
name|linenr
decl_stmt|;
DECL|member|next
name|struct
name|fragment
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * When dealing with a binary patch, we reuse "leading" field  * to store the type of the binary hunk, either deflated "delta"  * or deflated "literal".  */
end_comment
begin_define
DECL|macro|binary_patch_method
define|#
directive|define
name|binary_patch_method
value|leading
end_define
begin_define
DECL|macro|BINARY_DELTA_DEFLATED
define|#
directive|define
name|BINARY_DELTA_DEFLATED
value|1
end_define
begin_define
DECL|macro|BINARY_LITERAL_DEFLATED
define|#
directive|define
name|BINARY_LITERAL_DEFLATED
value|2
end_define
begin_comment
comment|/*  * This represents a "patch" to a file, both metainfo changes  * such as creation/deletion, filemode and content changes represented  * as a series of fragments.  */
end_comment
begin_struct
DECL|struct|patch
struct|struct
name|patch
block|{
DECL|member|new_name
DECL|member|old_name
DECL|member|def_name
name|char
modifier|*
name|new_name
decl_stmt|,
modifier|*
name|old_name
decl_stmt|,
modifier|*
name|def_name
decl_stmt|;
DECL|member|old_mode
DECL|member|new_mode
name|unsigned
name|int
name|old_mode
decl_stmt|,
name|new_mode
decl_stmt|;
DECL|member|is_new
DECL|member|is_delete
name|int
name|is_new
decl_stmt|,
name|is_delete
decl_stmt|;
comment|/* -1 = unknown, 0 = false, 1 = true */
DECL|member|rejected
name|int
name|rejected
decl_stmt|;
DECL|member|ws_rule
name|unsigned
name|ws_rule
decl_stmt|;
DECL|member|lines_added
DECL|member|lines_deleted
name|int
name|lines_added
decl_stmt|,
name|lines_deleted
decl_stmt|;
DECL|member|score
name|int
name|score
decl_stmt|;
DECL|member|is_toplevel_relative
name|unsigned
name|int
name|is_toplevel_relative
range|:
literal|1
decl_stmt|;
DECL|member|inaccurate_eof
name|unsigned
name|int
name|inaccurate_eof
range|:
literal|1
decl_stmt|;
DECL|member|is_binary
name|unsigned
name|int
name|is_binary
range|:
literal|1
decl_stmt|;
DECL|member|is_copy
name|unsigned
name|int
name|is_copy
range|:
literal|1
decl_stmt|;
DECL|member|is_rename
name|unsigned
name|int
name|is_rename
range|:
literal|1
decl_stmt|;
DECL|member|recount
name|unsigned
name|int
name|recount
range|:
literal|1
decl_stmt|;
DECL|member|conflicted_threeway
name|unsigned
name|int
name|conflicted_threeway
range|:
literal|1
decl_stmt|;
DECL|member|direct_to_threeway
name|unsigned
name|int
name|direct_to_threeway
range|:
literal|1
decl_stmt|;
DECL|member|fragments
name|struct
name|fragment
modifier|*
name|fragments
decl_stmt|;
DECL|member|result
name|char
modifier|*
name|result
decl_stmt|;
DECL|member|resultsize
name|size_t
name|resultsize
decl_stmt|;
DECL|member|old_sha1_prefix
name|char
name|old_sha1_prefix
index|[
literal|41
index|]
decl_stmt|;
DECL|member|new_sha1_prefix
name|char
name|new_sha1_prefix
index|[
literal|41
index|]
decl_stmt|;
DECL|member|next
name|struct
name|patch
modifier|*
name|next
decl_stmt|;
comment|/* three-way fallback result */
DECL|member|threeway_stage
name|unsigned
name|char
name|threeway_stage
index|[
literal|3
index|]
index|[
literal|20
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|free_fragment_list
specifier|static
name|void
name|free_fragment_list
parameter_list|(
name|struct
name|fragment
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|fragment
modifier|*
name|next
init|=
name|list
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|free_patch
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list
operator|->
name|patch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|free_patch
specifier|static
name|void
name|free_patch
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|free_fragment_list
argument_list|(
name|patch
operator|->
name|fragments
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|def_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patch
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_patch_list
specifier|static
name|void
name|free_patch_list
parameter_list|(
name|struct
name|patch
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|patch
modifier|*
name|next
init|=
name|list
operator|->
name|next
decl_stmt|;
name|free_patch
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * A line in a file, len-bytes long (includes the terminating LF,  * except for an incomplete line at the end if the file ends with  * one), and its contents hashes to 'hash'.  */
end_comment
begin_struct
DECL|struct|line
struct|struct
name|line
block|{
DECL|member|len
name|size_t
name|len
decl_stmt|;
DECL|member|hash
name|unsigned
name|hash
range|:
literal|24
decl_stmt|;
DECL|member|flag
name|unsigned
name|flag
range|:
literal|8
decl_stmt|;
DECL|macro|LINE_COMMON
define|#
directive|define
name|LINE_COMMON
value|1
DECL|macro|LINE_PATCHED
define|#
directive|define
name|LINE_PATCHED
value|2
block|}
struct|;
end_struct
begin_comment
comment|/*  * This represents a "file", which is an array of "lines".  */
end_comment
begin_struct
DECL|struct|image
struct|struct
name|image
block|{
DECL|member|buf
name|char
modifier|*
name|buf
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
DECL|member|nr
name|size_t
name|nr
decl_stmt|;
DECL|member|alloc
name|size_t
name|alloc
decl_stmt|;
DECL|member|line_allocated
name|struct
name|line
modifier|*
name|line_allocated
decl_stmt|;
DECL|member|line
name|struct
name|line
modifier|*
name|line
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Records filenames that have been touched, in order to handle  * the case where more than one patches touch the same file.  */
end_comment
begin_decl_stmt
DECL|variable|fn_table
specifier|static
name|struct
name|string_list
name|fn_table
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|hash_line
specifier|static
name|uint32_t
name|hash_line
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|h
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|h
operator|=
name|h
operator|*
literal|3
operator|+
operator|(
name|cp
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
block|}
return|return
name|h
return|;
block|}
end_function
begin_comment
comment|/*  * Compare lines s1 of length n1 and s2 of length n2, ignoring  * whitespace difference. Returns 1 if they match, 0 otherwise  */
end_comment
begin_function
DECL|function|fuzzy_matchlines
specifier|static
name|int
name|fuzzy_matchlines
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
name|size_t
name|n1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|n2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last1
init|=
name|s1
operator|+
name|n1
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|last2
init|=
name|s2
operator|+
name|n2
operator|-
literal|1
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* ignore line endings */
while|while
condition|(
operator|(
operator|*
name|last1
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|last1
operator|==
literal|'\n'
operator|)
condition|)
name|last1
operator|--
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|last2
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|last2
operator|==
literal|'\n'
operator|)
condition|)
name|last2
operator|--
expr_stmt|;
comment|/* skip leading whitespace */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
operator|(
name|s1
operator|<=
name|last1
operator|)
condition|)
name|s1
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
operator|&&
operator|(
name|s2
operator|<=
name|last2
operator|)
condition|)
name|s2
operator|++
expr_stmt|;
comment|/* early return if both lines are empty */
if|if
condition|(
operator|(
name|s1
operator|>
name|last1
operator|)
operator|&&
operator|(
name|s2
operator|>
name|last2
operator|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|!
name|result
condition|)
block|{
name|result
operator|=
operator|*
name|s1
operator|++
operator|-
operator|*
name|s2
operator|++
expr_stmt|;
comment|/* 		 * Skip whitespace inside. We check for whitespace on 		 * both buffers because we don't want "a b" to match 		 * "ab" 		 */
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
name|s1
operator|<=
name|last1
condition|)
name|s1
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s2
argument_list|)
operator|&&
name|s2
operator|<=
name|last2
condition|)
name|s2
operator|++
expr_stmt|;
block|}
comment|/* 		 * If we reached the end on one side only, 		 * lines don't match 		 */
if|if
condition|(
operator|(
operator|(
name|s2
operator|>
name|last2
operator|)
operator|&&
operator|(
name|s1
operator|<=
name|last1
operator|)
operator|)
operator|||
operator|(
operator|(
name|s1
operator|>
name|last1
operator|)
operator|&&
operator|(
name|s2
operator|<=
name|last2
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|s1
operator|>
name|last1
operator|)
operator|&&
operator|(
name|s2
operator|>
name|last2
operator|)
condition|)
break|break;
block|}
return|return
operator|!
name|result
return|;
block|}
end_function
begin_function
DECL|function|add_line_info
specifier|static
name|void
name|add_line_info
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
specifier|const
name|char
modifier|*
name|bol
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|flag
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|img
operator|->
name|line_allocated
argument_list|,
name|img
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|img
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|img
operator|->
name|line_allocated
index|[
name|img
operator|->
name|nr
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|img
operator|->
name|line_allocated
index|[
name|img
operator|->
name|nr
index|]
operator|.
name|hash
operator|=
name|hash_line
argument_list|(
name|bol
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|img
operator|->
name|line_allocated
index|[
name|img
operator|->
name|nr
index|]
operator|.
name|flag
operator|=
name|flag
expr_stmt|;
name|img
operator|->
name|nr
operator|++
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * "buf" has the file contents to be patched (read from various sources).  * attach it to "image" and add line-based index to it.  * "image" now owns the "buf".  */
end_comment
begin_function
DECL|function|prepare_image
specifier|static
name|void
name|prepare_image
parameter_list|(
name|struct
name|image
modifier|*
name|image
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|prepare_linetable
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|memset
argument_list|(
name|image
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|image
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|image
operator|->
name|len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|prepare_linetable
condition|)
return|return;
name|ep
operator|=
name|image
operator|->
name|buf
operator|+
name|image
operator|->
name|len
expr_stmt|;
name|cp
operator|=
name|image
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|cp
init|;
name|next
operator|<
name|ep
operator|&&
operator|*
name|next
operator|!=
literal|'\n'
condition|;
name|next
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|next
operator|<
name|ep
condition|)
name|next
operator|++
expr_stmt|;
name|add_line_info
argument_list|(
name|image
argument_list|,
name|cp
argument_list|,
name|next
operator|-
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|next
expr_stmt|;
block|}
name|image
operator|->
name|line
operator|=
name|image
operator|->
name|line_allocated
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear_image
specifier|static
name|void
name|clear_image
parameter_list|(
name|struct
name|image
modifier|*
name|image
parameter_list|)
block|{
name|free
argument_list|(
name|image
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|image
operator|->
name|line_allocated
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|image
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|image
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* fmt must contain _one_ %s and no other substitution */
end_comment
begin_function
DECL|function|say_patch_name
specifier|static
name|void
name|say_patch_name
parameter_list|(
name|FILE
modifier|*
name|output
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|patch
operator|->
name|old_name
operator|&&
name|patch
operator|->
name|new_name
operator|&&
name|strcmp
argument_list|(
name|patch
operator|->
name|old_name
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
condition|)
block|{
name|quote_c_style
argument_list|(
name|patch
operator|->
name|old_name
argument_list|,
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
literal|" => "
argument_list|)
expr_stmt|;
name|quote_c_style
argument_list|(
name|patch
operator|->
name|new_name
argument_list|,
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|n
init|=
name|patch
operator|->
name|new_name
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|patch
operator|->
name|old_name
expr_stmt|;
name|quote_c_style
argument_list|(
name|n
argument_list|,
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|output
argument_list|,
name|fmt
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|SLOP
define|#
directive|define
name|SLOP
value|(16)
end_define
begin_function
DECL|function|read_patch_file
specifier|static
name|void
name|read_patch_file
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|strbuf_read
argument_list|(
name|sb
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"git apply: failed to read"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that we have some slop in the buffer 	 * so that we can do speculative "memcmp" etc, and 	 * see to it that it is NUL-filled. 	 */
name|strbuf_grow
argument_list|(
name|sb
argument_list|,
name|SLOP
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|sb
operator|->
name|len
argument_list|,
literal|0
argument_list|,
name|SLOP
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|linelen
specifier|static
name|unsigned
name|long
name|linelen
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|unsigned
name|long
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|++
operator|==
literal|'\n'
condition|)
break|break;
block|}
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|is_dev_null
specifier|static
name|int
name|is_dev_null
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
operator|!
name|memcmp
argument_list|(
literal|"/dev/null"
argument_list|,
name|str
argument_list|,
literal|9
argument_list|)
operator|&&
name|isspace
argument_list|(
name|str
index|[
literal|9
index|]
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|TERM_SPACE
define|#
directive|define
name|TERM_SPACE
value|1
end_define
begin_define
DECL|macro|TERM_TAB
define|#
directive|define
name|TERM_TAB
value|2
end_define
begin_function
DECL|function|name_terminate
specifier|static
name|int
name|name_terminate
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|terminate
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
operator|!
operator|(
name|terminate
operator|&
name|TERM_SPACE
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|&&
operator|!
operator|(
name|terminate
operator|&
name|TERM_TAB
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/* remove double slashes to make --index work with such filenames */
end_comment
begin_function
DECL|function|squash_slash
specifier|static
name|char
modifier|*
name|squash_slash
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|name
index|[
name|j
operator|++
index|]
operator|=
name|name
index|[
name|i
operator|++
index|]
operator|)
operator|==
literal|'/'
condition|)
while|while
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
block|}
name|name
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|find_name_gnu
specifier|static
name|char
modifier|*
name|find_name_gnu
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|,
name|int
name|p_value
parameter_list|)
block|{
name|struct
name|strbuf
name|name
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Proposed "new-style" GNU patch/diff format; see 	 * http://marc.info/?l=git&m=112927316408690&w=2 	 */
if|if
condition|(
name|unquote_c_style
argument_list|(
operator|&
name|name
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|cp
operator|=
name|name
operator|.
name|buf
init|;
name|p_value
condition|;
name|p_value
operator|--
control|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
name|strbuf_remove
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
name|cp
operator|-
name|name
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
condition|)
name|strbuf_insert
argument_list|(
operator|&
name|name
argument_list|,
literal|0
argument_list|,
name|root
argument_list|,
name|root_len
argument_list|)
expr_stmt|;
return|return
name|squash_slash
argument_list|(
name|strbuf_detach
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sane_tz_len
specifier|static
name|size_t
name|sane_tz_len
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tz
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|strlen
argument_list|(
literal|" +0500"
argument_list|)
operator|||
name|line
index|[
name|len
operator|-
name|strlen
argument_list|(
literal|" +0500"
argument_list|)
index|]
operator|!=
literal|' '
condition|)
return|return
literal|0
return|;
name|tz
operator|=
name|line
operator|+
name|len
operator|-
name|strlen
argument_list|(
literal|" +0500"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tz
index|[
literal|1
index|]
operator|!=
literal|'+'
operator|&&
name|tz
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|tz
operator|+
literal|2
init|;
name|p
operator|!=
name|line
operator|+
name|len
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|line
operator|+
name|len
operator|-
name|tz
return|;
block|}
end_function
begin_function
DECL|function|tz_with_colon_len
specifier|static
name|size_t
name|tz_with_colon_len
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tz
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|strlen
argument_list|(
literal|" +08:00"
argument_list|)
operator|||
name|line
index|[
name|len
operator|-
name|strlen
argument_list|(
literal|":00"
argument_list|)
index|]
operator|!=
literal|':'
condition|)
return|return
literal|0
return|;
name|tz
operator|=
name|line
operator|+
name|len
operator|-
name|strlen
argument_list|(
literal|" +08:00"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tz
index|[
literal|0
index|]
operator|!=
literal|' '
operator|||
operator|(
name|tz
index|[
literal|1
index|]
operator|!=
literal|'+'
operator|&&
name|tz
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|)
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|tz
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|*
name|p
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|line
operator|+
name|len
operator|-
name|tz
return|;
block|}
end_function
begin_function
DECL|function|date_len
specifier|static
name|size_t
name|date_len
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|date
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|strlen
argument_list|(
literal|"72-02-05"
argument_list|)
operator|||
name|line
index|[
name|len
operator|-
name|strlen
argument_list|(
literal|"-05"
argument_list|)
index|]
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|date
operator|=
name|line
operator|+
name|len
operator|-
name|strlen
argument_list|(
literal|"72-02-05"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|*
name|p
operator|++
operator|!=
literal|'-'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|*
name|p
operator|++
operator|!=
literal|'-'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
comment|/* Not a date. */
return|return
literal|0
return|;
if|if
condition|(
name|date
operator|-
name|line
operator|>=
name|strlen
argument_list|(
literal|"19"
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|date
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|date
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
comment|/* 4-digit year */
name|date
operator|-=
name|strlen
argument_list|(
literal|"19"
argument_list|)
expr_stmt|;
return|return
name|line
operator|+
name|len
operator|-
name|date
return|;
block|}
end_function
begin_function
DECL|function|short_time_len
specifier|static
name|size_t
name|short_time_len
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|time
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|strlen
argument_list|(
literal|" 07:01:32"
argument_list|)
operator|||
name|line
index|[
name|len
operator|-
name|strlen
argument_list|(
literal|":32"
argument_list|)
index|]
operator|!=
literal|':'
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|time
operator|=
name|line
operator|+
name|len
operator|-
name|strlen
argument_list|(
literal|" 07:01:32"
argument_list|)
expr_stmt|;
comment|/* Permit 1-digit hours? */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|' '
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|*
name|p
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|*
name|p
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
comment|/* Not a time. */
return|return
literal|0
return|;
return|return
name|line
operator|+
name|len
operator|-
name|time
return|;
block|}
end_function
begin_function
DECL|function|fractional_time_len
specifier|static
name|size_t
name|fractional_time_len
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
comment|/* Expected format: 19:41:17.620000023 */
if|if
condition|(
operator|!
name|len
operator|||
operator|!
name|isdigit
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|line
operator|+
name|len
operator|-
literal|1
expr_stmt|;
comment|/* Fractional seconds. */
while|while
condition|(
name|p
operator|>
name|line
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
comment|/* Hours, minutes, and whole seconds. */
name|n
operator|=
name|short_time_len
argument_list|(
name|line
argument_list|,
name|p
operator|-
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
return|return
name|line
operator|+
name|len
operator|-
name|p
operator|+
name|n
return|;
block|}
end_function
begin_function
DECL|function|trailing_spaces_len
specifier|static
name|size_t
name|trailing_spaces_len
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Expected format: ' ' x (1 or more)  */
if|if
condition|(
operator|!
name|len
operator|||
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|line
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|line
condition|)
block|{
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
return|return
name|line
operator|+
name|len
operator|-
operator|(
name|p
operator|+
literal|1
operator|)
return|;
block|}
comment|/* All spaces! */
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|diff_timestamp_len
specifier|static
name|size_t
name|diff_timestamp_len
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|line
operator|+
name|len
decl_stmt|;
name|size_t
name|n
decl_stmt|;
comment|/* 	 * Posix: 2010-07-05 19:41:17 	 * GNU: 2010-07-05 19:41:17.620000023 -0500 	 */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|sane_tz_len
argument_list|(
name|line
argument_list|,
name|end
operator|-
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|tz_with_colon_len
argument_list|(
name|line
argument_list|,
name|end
operator|-
name|line
argument_list|)
expr_stmt|;
name|end
operator|-=
name|n
expr_stmt|;
name|n
operator|=
name|short_time_len
argument_list|(
name|line
argument_list|,
name|end
operator|-
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|n
operator|=
name|fractional_time_len
argument_list|(
name|line
argument_list|,
name|end
operator|-
name|line
argument_list|)
expr_stmt|;
name|end
operator|-=
name|n
expr_stmt|;
name|n
operator|=
name|date_len
argument_list|(
name|line
argument_list|,
name|end
operator|-
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
comment|/* No date.  Too bad. */
return|return
literal|0
return|;
name|end
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|line
condition|)
comment|/* No space before date. */
return|return
literal|0
return|;
if|if
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
block|{
comment|/* Success! */
name|end
operator|--
expr_stmt|;
return|return
name|line
operator|+
name|len
operator|-
name|end
return|;
block|}
if|if
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
comment|/* No space before date. */
return|return
literal|0
return|;
comment|/* Whitespace damage. */
name|end
operator|-=
name|trailing_spaces_len
argument_list|(
name|line
argument_list|,
name|end
operator|-
name|line
argument_list|)
expr_stmt|;
return|return
name|line
operator|+
name|len
operator|-
name|end
return|;
block|}
end_function
begin_function
DECL|function|null_strdup
specifier|static
name|char
modifier|*
name|null_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
condition|?
name|xstrdup
argument_list|(
name|s
argument_list|)
else|:
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|find_name_common
specifier|static
name|char
modifier|*
name|find_name_common
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|,
name|int
name|p_value
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|int
name|terminate
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|p_value
operator|==
literal|0
condition|)
name|start
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|line
operator|!=
name|end
condition|)
block|{
name|char
name|c
init|=
operator|*
name|line
decl_stmt|;
if|if
condition|(
operator|!
name|end
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|name_terminate
argument_list|(
name|start
argument_list|,
name|line
operator|-
name|start
argument_list|,
name|c
argument_list|,
name|terminate
argument_list|)
condition|)
break|break;
block|}
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|!
operator|--
name|p_value
condition|)
name|start
operator|=
name|line
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|start
condition|)
return|return
name|squash_slash
argument_list|(
name|null_strdup
argument_list|(
name|def
argument_list|)
argument_list|)
return|;
name|len
operator|=
name|line
operator|-
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
name|squash_slash
argument_list|(
name|null_strdup
argument_list|(
name|def
argument_list|)
argument_list|)
return|;
comment|/* 	 * Generally we prefer the shorter name, especially 	 * if the other one is just a variation of that with 	 * something else tacked on to the end (ie "file.orig" 	 * or "file~"). 	 */
if|if
condition|(
name|def
condition|)
block|{
name|int
name|deflen
init|=
name|strlen
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|deflen
operator|<
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|start
argument_list|,
name|def
argument_list|,
name|deflen
argument_list|)
condition|)
return|return
name|squash_slash
argument_list|(
name|xstrdup
argument_list|(
name|def
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|root
condition|)
block|{
name|char
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
name|root_len
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
operator|+
name|root_len
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
index|[
name|root_len
operator|+
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|squash_slash
argument_list|(
name|ret
argument_list|)
return|;
block|}
return|return
name|squash_slash
argument_list|(
name|xmemdupz
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|find_name
specifier|static
name|char
modifier|*
name|find_name
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|def
parameter_list|,
name|int
name|p_value
parameter_list|,
name|int
name|terminate
parameter_list|)
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'"'
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|find_name_gnu
argument_list|(
name|line
argument_list|,
name|def
argument_list|,
name|p_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
return|return
name|name
return|;
block|}
return|return
name|find_name_common
argument_list|(
name|line
argument_list|,
name|def
argument_list|,
name|p_value
argument_list|,
name|NULL
argument_list|,
name|terminate
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|find_name_traditional
specifier|static
name|char
modifier|*
name|find_name_traditional
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|def
parameter_list|,
name|int
name|p_value
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|size_t
name|date_len
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'"'
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|find_name_gnu
argument_list|(
name|line
argument_list|,
name|def
argument_list|,
name|p_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
return|return
name|name
return|;
block|}
name|len
operator|=
name|strchrnul
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|-
name|line
expr_stmt|;
name|date_len
operator|=
name|diff_timestamp_len
argument_list|(
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date_len
condition|)
return|return
name|find_name_common
argument_list|(
name|line
argument_list|,
name|def
argument_list|,
name|p_value
argument_list|,
name|NULL
argument_list|,
name|TERM_TAB
argument_list|)
return|;
name|len
operator|-=
name|date_len
expr_stmt|;
return|return
name|find_name_common
argument_list|(
name|line
argument_list|,
name|def
argument_list|,
name|p_value
argument_list|,
name|line
operator|+
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|count_slashes
specifier|static
name|int
name|count_slashes
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
condition|)
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
name|cnt
operator|++
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function
begin_comment
comment|/*  * Given the string after "--- " or "+++ ", guess the appropriate  * p_value for the given patch.  */
end_comment
begin_function
DECL|function|guess_p_value
specifier|static
name|int
name|guess_p_value
parameter_list|(
specifier|const
name|char
modifier|*
name|nameline
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|val
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|is_dev_null
argument_list|(
name|nameline
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|name
operator|=
name|find_name_traditional
argument_list|(
name|nameline
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
operator|-
literal|1
return|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|val
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
condition|)
block|{
comment|/* 		 * Does it begin with "a/$our-prefix" and such?  Then this is 		 * very likely to apply to our directory. 		 */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|prefix
argument_list|,
name|prefix_length
argument_list|)
condition|)
name|val
operator|=
name|count_slashes
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
else|else
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|prefix
argument_list|,
name|prefix_length
argument_list|)
condition|)
name|val
operator|=
name|count_slashes
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*  * Does the ---/+++ line has the POSIX timestamp after the last HT?  * GNU diff puts epoch there to signal a creation/deletion event.  Is  * this such a timestamp?  */
end_comment
begin_function
DECL|function|has_epoch_timestamp
specifier|static
name|int
name|has_epoch_timestamp
parameter_list|(
specifier|const
name|char
modifier|*
name|nameline
parameter_list|)
block|{
comment|/* 	 * We are only interested in epoch timestamp; any non-zero 	 * fraction cannot be one, hence "(\.0+)?" in the regexp below. 	 * For the same reason, the date must be either 1969-12-31 or 	 * 1970-01-01, and the seconds part must be "00". 	 */
specifier|const
name|char
name|stamp_regexp
index|[]
init|=
literal|"^(1969-12-31|1970-01-01)"
literal|" "
literal|"[0-2][0-9]:[0-5][0-9]:00(\\.0+)?"
literal|" "
literal|"([-+][0-2][0-9]:?[0-5][0-9])\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|timestamp
init|=
name|NULL
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|colon
decl_stmt|;
specifier|static
name|regex_t
modifier|*
name|stamp
decl_stmt|;
name|regmatch_t
name|m
index|[
literal|10
index|]
decl_stmt|;
name|int
name|zoneoffset
decl_stmt|;
name|int
name|hourminute
decl_stmt|;
name|int
name|status
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|nameline
init|;
operator|*
name|cp
operator|!=
literal|'\n'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|timestamp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timestamp
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|stamp
condition|)
block|{
name|stamp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|stamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
name|stamp
argument_list|,
name|stamp_regexp
argument_list|,
name|REG_EXTENDED
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"Cannot prepare timestamp regexp %s"
argument_list|)
argument_list|,
name|stamp_regexp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|status
operator|=
name|regexec
argument_list|(
name|stamp
argument_list|,
name|timestamp
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|m
argument_list|)
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|!=
name|REG_NOMATCH
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"regexec returned %d for input: %s"
argument_list|)
argument_list|,
name|status
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|zoneoffset
operator|=
name|strtol
argument_list|(
name|timestamp
operator|+
name|m
index|[
literal|3
index|]
operator|.
name|rm_so
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|colon
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|colon
operator|==
literal|':'
condition|)
name|zoneoffset
operator|=
name|zoneoffset
operator|*
literal|60
operator|+
name|strtol
argument_list|(
name|colon
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|zoneoffset
operator|=
operator|(
name|zoneoffset
operator|/
literal|100
operator|)
operator|*
literal|60
operator|+
operator|(
name|zoneoffset
operator|%
literal|100
operator|)
expr_stmt|;
if|if
condition|(
name|timestamp
index|[
name|m
index|[
literal|3
index|]
operator|.
name|rm_so
index|]
operator|==
literal|'-'
condition|)
name|zoneoffset
operator|=
operator|-
name|zoneoffset
expr_stmt|;
comment|/* 	 * YYYY-MM-DD hh:mm:ss must be from either 1969-12-31 	 * (west of GMT) or 1970-01-01 (east of GMT) 	 */
if|if
condition|(
operator|(
name|zoneoffset
operator|<
literal|0
operator|&&
name|memcmp
argument_list|(
name|timestamp
argument_list|,
literal|"1969-12-31"
argument_list|,
literal|10
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|<=
name|zoneoffset
operator|&&
name|memcmp
argument_list|(
name|timestamp
argument_list|,
literal|"1970-01-01"
argument_list|,
literal|10
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|hourminute
operator|=
operator|(
name|strtol
argument_list|(
name|timestamp
operator|+
literal|11
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|*
literal|60
operator|+
name|strtol
argument_list|(
name|timestamp
operator|+
literal|14
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|-
name|zoneoffset
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|zoneoffset
operator|<
literal|0
operator|&&
name|hourminute
operator|==
literal|1440
operator|)
operator|||
operator|(
literal|0
operator|<=
name|zoneoffset
operator|&&
operator|!
name|hourminute
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*  * Get the name etc info from the ---/+++ lines of a traditional patch header  *  * FIXME! The end-of-filename heuristics are kind of screwy. For existing  * files, we can happily check the index for a match, but for creating a  * new file we should try to match whatever "patch" does. I have no idea.  */
end_comment
begin_function
DECL|function|parse_traditional_patch
specifier|static
name|void
name|parse_traditional_patch
parameter_list|(
specifier|const
name|char
modifier|*
name|first
parameter_list|,
specifier|const
name|char
modifier|*
name|second
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|first
operator|+=
literal|4
expr_stmt|;
comment|/* skip "--- " */
name|second
operator|+=
literal|4
expr_stmt|;
comment|/* skip "+++ " */
if|if
condition|(
operator|!
name|p_value_known
condition|)
block|{
name|int
name|p
decl_stmt|,
name|q
decl_stmt|;
name|p
operator|=
name|guess_p_value
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|q
operator|=
name|guess_p_value
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|p
operator|&&
name|p
operator|==
name|q
condition|)
block|{
name|p_value
operator|=
name|p
expr_stmt|;
name|p_value_known
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_dev_null
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|patch
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
name|patch
operator|->
name|is_delete
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|find_name_traditional
argument_list|(
name|second
argument_list|,
name|NULL
argument_list|,
name|p_value
argument_list|)
expr_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_dev_null
argument_list|(
name|second
argument_list|)
condition|)
block|{
name|patch
operator|->
name|is_new
operator|=
literal|0
expr_stmt|;
name|patch
operator|->
name|is_delete
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|find_name_traditional
argument_list|(
name|first
argument_list|,
name|NULL
argument_list|,
name|p_value
argument_list|)
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|first_name
decl_stmt|;
name|first_name
operator|=
name|find_name_traditional
argument_list|(
name|first
argument_list|,
name|NULL
argument_list|,
name|p_value
argument_list|)
expr_stmt|;
name|name
operator|=
name|find_name_traditional
argument_list|(
name|second
argument_list|,
name|first_name
argument_list|,
name|p_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|first_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_epoch_timestamp
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|patch
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
name|patch
operator|->
name|is_delete
operator|=
literal|0
expr_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_epoch_timestamp
argument_list|(
name|second
argument_list|)
condition|)
block|{
name|patch
operator|->
name|is_new
operator|=
literal|0
expr_stmt|;
name|patch
operator|->
name|is_delete
operator|=
literal|1
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|patch
operator|->
name|old_name
operator|=
name|name
expr_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|null_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|name
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to find filename in patch at line %d"
argument_list|)
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|gitdiff_hdrend
specifier|static
name|int
name|gitdiff_hdrend
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * We're anal about diff header consistency, to make  * sure that we don't end up having strange ambiguous  * patches floating around.  *  * As a result, gitdiff_{old|new}name() will check  * their names against any previous information, just  * to make sure..  */
end_comment
begin_define
DECL|macro|DIFF_OLD_NAME
define|#
directive|define
name|DIFF_OLD_NAME
value|0
end_define
begin_define
DECL|macro|DIFF_NEW_NAME
define|#
directive|define
name|DIFF_NEW_NAME
value|1
end_define
begin_function
DECL|function|gitdiff_verify_name
specifier|static
name|char
modifier|*
name|gitdiff_verify_name
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|isnull
parameter_list|,
name|char
modifier|*
name|orig_name
parameter_list|,
name|int
name|side
parameter_list|)
block|{
if|if
condition|(
operator|!
name|orig_name
operator|&&
operator|!
name|isnull
condition|)
return|return
name|find_name
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
name|p_value
argument_list|,
name|TERM_TAB
argument_list|)
return|;
if|if
condition|(
name|orig_name
condition|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|another
decl_stmt|;
name|name
operator|=
name|orig_name
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnull
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git apply: bad git-diff - expected /dev/null, got %s on line %d"
argument_list|)
argument_list|,
name|name
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
name|another
operator|=
name|find_name
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
name|p_value
argument_list|,
name|TERM_TAB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|another
operator|||
name|memcmp
argument_list|(
name|another
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
name|die
argument_list|(
operator|(
name|side
operator|==
name|DIFF_NEW_NAME
operator|)
condition|?
name|_
argument_list|(
literal|"git apply: bad git-diff - inconsistent new filename on line %d"
argument_list|)
else|:
name|_
argument_list|(
literal|"git apply: bad git-diff - inconsistent old filename on line %d"
argument_list|)
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|another
argument_list|)
expr_stmt|;
return|return
name|orig_name
return|;
block|}
else|else
block|{
comment|/* expect "/dev/null" */
if|if
condition|(
name|memcmp
argument_list|(
literal|"/dev/null"
argument_list|,
name|line
argument_list|,
literal|9
argument_list|)
operator|||
name|line
index|[
literal|9
index|]
operator|!=
literal|'\n'
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git apply: bad git-diff - expected /dev/null on line %d"
argument_list|)
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_function
DECL|function|gitdiff_oldname
specifier|static
name|int
name|gitdiff_oldname
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|char
modifier|*
name|orig
init|=
name|patch
operator|->
name|old_name
decl_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|gitdiff_verify_name
argument_list|(
name|line
argument_list|,
name|patch
operator|->
name|is_new
argument_list|,
name|patch
operator|->
name|old_name
argument_list|,
name|DIFF_OLD_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
operator|!=
name|patch
operator|->
name|old_name
condition|)
name|free
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_newname
specifier|static
name|int
name|gitdiff_newname
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|char
modifier|*
name|orig
init|=
name|patch
operator|->
name|new_name
decl_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|gitdiff_verify_name
argument_list|(
name|line
argument_list|,
name|patch
operator|->
name|is_delete
argument_list|,
name|patch
operator|->
name|new_name
argument_list|,
name|DIFF_NEW_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
operator|!=
name|patch
operator|->
name|new_name
condition|)
name|free
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_oldmode
specifier|static
name|int
name|gitdiff_oldmode
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|old_mode
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_newmode
specifier|static
name|int
name|gitdiff_newmode
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|new_mode
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_delete
specifier|static
name|int
name|gitdiff_delete
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|is_delete
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|null_strdup
argument_list|(
name|patch
operator|->
name|def_name
argument_list|)
expr_stmt|;
return|return
name|gitdiff_oldmode
argument_list|(
name|line
argument_list|,
name|patch
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_newfile
specifier|static
name|int
name|gitdiff_newfile
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|null_strdup
argument_list|(
name|patch
operator|->
name|def_name
argument_list|)
expr_stmt|;
return|return
name|gitdiff_newmode
argument_list|(
name|line
argument_list|,
name|patch
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_copysrc
specifier|static
name|int
name|gitdiff_copysrc
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|is_copy
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|find_name
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
name|p_value
condition|?
name|p_value
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_copydst
specifier|static
name|int
name|gitdiff_copydst
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|is_copy
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|find_name
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
name|p_value
condition|?
name|p_value
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_renamesrc
specifier|static
name|int
name|gitdiff_renamesrc
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|is_rename
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|find_name
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
name|p_value
condition|?
name|p_value
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_renamedst
specifier|static
name|int
name|gitdiff_renamedst
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|patch
operator|->
name|is_rename
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|find_name
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
name|p_value
condition|?
name|p_value
operator|-
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_similarity
specifier|static
name|int
name|gitdiff_similarity
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|unsigned
name|long
name|val
init|=
name|strtoul
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|<=
literal|100
condition|)
name|patch
operator|->
name|score
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_dissimilarity
specifier|static
name|int
name|gitdiff_dissimilarity
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|unsigned
name|long
name|val
init|=
name|strtoul
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|<=
literal|100
condition|)
name|patch
operator|->
name|score
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|gitdiff_index
specifier|static
name|int
name|gitdiff_index
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
comment|/* 	 * index line is N hexadecimal, "..", N hexadecimal, 	 * and optional space with octal mode. 	 */
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ptr
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
name|ptr
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
literal|40
operator|<
name|ptr
operator|-
name|line
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|ptr
operator|-
name|line
expr_stmt|;
name|memcpy
argument_list|(
name|patch
operator|->
name|old_sha1_prefix
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|patch
operator|->
name|old_sha1_prefix
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|ptr
operator|+
literal|2
expr_stmt|;
name|ptr
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|eol
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
name|eol
operator|<
name|ptr
condition|)
name|ptr
operator|=
name|eol
expr_stmt|;
name|len
operator|=
name|ptr
operator|-
name|line
expr_stmt|;
if|if
condition|(
literal|40
operator|<
name|len
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|patch
operator|->
name|new_sha1_prefix
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|patch
operator|->
name|new_sha1_prefix
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|patch
operator|->
name|old_mode
operator|=
name|strtoul
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * This is normal for a diff that doesn't change anything: we'll fall through  * into the next diff. Tell the parser to break out.  */
end_comment
begin_function
DECL|function|gitdiff_unrecognized
specifier|static
name|int
name|gitdiff_unrecognized
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Skip p_value leading components from "line"; as we do not accept  * absolute paths, return NULL in that case.  */
end_comment
begin_function
DECL|function|skip_tree_prefix
specifier|static
specifier|const
name|char
modifier|*
name|skip_tree_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|llen
parameter_list|)
block|{
name|int
name|nslash
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_value
condition|)
return|return
operator|(
name|llen
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
condition|?
name|NULL
else|:
name|line
return|;
name|nslash
operator|=
name|p_value
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|llen
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|line
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'/'
operator|&&
operator|--
name|nslash
operator|<=
literal|0
condition|)
return|return
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|NULL
else|:
operator|&
name|line
index|[
name|i
operator|+
literal|1
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * This is to extract the same name that appears on "diff --git"  * line.  We do not find and return anything if it is a rename  * patch, and it is OK because we will find the name elsewhere.  * We need to reliably find name only when it is mode-change only,  * creation or deletion of an empty file.  In any of these cases,  * both sides are the same name under a/ and b/ respectively.  */
end_comment
begin_function
DECL|function|git_header_name
specifier|static
name|char
modifier|*
name|git_header_name
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|llen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|second
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|line_len
decl_stmt|;
name|line
operator|+=
name|strlen
argument_list|(
literal|"diff --git "
argument_list|)
expr_stmt|;
name|llen
operator|-=
name|strlen
argument_list|(
literal|"diff --git "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'"'
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|strbuf
name|first
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|sp
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|unquote_c_style
argument_list|(
operator|&
name|first
argument_list|,
name|line
argument_list|,
operator|&
name|second
argument_list|)
condition|)
goto|goto
name|free_and_fail1
goto|;
comment|/* strip the a/b prefix including trailing slash */
name|cp
operator|=
name|skip_tree_prefix
argument_list|(
name|first
operator|.
name|buf
argument_list|,
name|first
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|free_and_fail1
goto|;
name|strbuf_remove
argument_list|(
operator|&
name|first
argument_list|,
literal|0
argument_list|,
name|cp
operator|-
name|first
operator|.
name|buf
argument_list|)
expr_stmt|;
comment|/* 		 * second points at one past closing dq of name. 		 * find the second name. 		 */
while|while
condition|(
operator|(
name|second
operator|<
name|line
operator|+
name|llen
operator|)
operator|&&
name|isspace
argument_list|(
operator|*
name|second
argument_list|)
condition|)
name|second
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|+
name|llen
operator|<=
name|second
condition|)
goto|goto
name|free_and_fail1
goto|;
if|if
condition|(
operator|*
name|second
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|unquote_c_style
argument_list|(
operator|&
name|sp
argument_list|,
name|second
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|free_and_fail1
goto|;
name|cp
operator|=
name|skip_tree_prefix
argument_list|(
name|sp
operator|.
name|buf
argument_list|,
name|sp
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|free_and_fail1
goto|;
comment|/* They must match, otherwise ignore */
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|first
operator|.
name|buf
argument_list|)
condition|)
goto|goto
name|free_and_fail1
goto|;
name|strbuf_release
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|first
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/* unquoted second */
name|cp
operator|=
name|skip_tree_prefix
argument_list|(
name|second
argument_list|,
name|line
operator|+
name|llen
operator|-
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|free_and_fail1
goto|;
if|if
condition|(
name|line
operator|+
name|llen
operator|-
name|cp
operator|!=
name|first
operator|.
name|len
operator|||
name|memcmp
argument_list|(
name|first
operator|.
name|buf
argument_list|,
name|cp
argument_list|,
name|first
operator|.
name|len
argument_list|)
condition|)
goto|goto
name|free_and_fail1
goto|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|first
argument_list|,
name|NULL
argument_list|)
return|;
name|free_and_fail1
label|:
name|strbuf_release
argument_list|(
operator|&
name|first
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* unquoted first name */
name|name
operator|=
name|skip_tree_prefix
argument_list|(
name|line
argument_list|,
name|llen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
comment|/* 	 * since the first name is unquoted, a dq if exists must be 	 * the beginning of the second name. 	 */
for|for
control|(
name|second
operator|=
name|name
init|;
name|second
operator|<
name|line
operator|+
name|llen
condition|;
name|second
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|second
operator|==
literal|'"'
condition|)
block|{
name|struct
name|strbuf
name|sp
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|unquote_c_style
argument_list|(
operator|&
name|sp
argument_list|,
name|second
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|free_and_fail2
goto|;
name|np
operator|=
name|skip_tree_prefix
argument_list|(
name|sp
operator|.
name|buf
argument_list|,
name|sp
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
goto|goto
name|free_and_fail2
goto|;
name|len
operator|=
name|sp
operator|.
name|buf
operator|+
name|sp
operator|.
name|len
operator|-
name|np
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|second
operator|-
name|name
operator|&&
operator|!
name|strncmp
argument_list|(
name|np
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|&&
name|isspace
argument_list|(
name|name
index|[
name|len
index|]
argument_list|)
condition|)
block|{
comment|/* Good */
name|strbuf_remove
argument_list|(
operator|&
name|sp
argument_list|,
literal|0
argument_list|,
name|np
operator|-
name|sp
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|sp
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|free_and_fail2
label|:
name|strbuf_release
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* 	 * Accept a name only if it shows up twice, exactly the same 	 * form. 	 */
name|second
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|second
condition|)
return|return
name|NULL
return|;
name|line_len
operator|=
name|second
operator|-
name|name
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
condition|;
name|len
operator|++
control|)
block|{
switch|switch
condition|(
name|name
index|[
name|len
index|]
condition|)
block|{
default|default:
continue|continue;
case|case
literal|'\n'
case|:
return|return
name|NULL
return|;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
comment|/* 			 * Is this the separator between the preimage 			 * and the postimage pathname?  Again, we are 			 * only interested in the case where there is 			 * no rename, as this is only to set def_name 			 * and a rename patch has the names elsewhere 			 * in an unambiguous form. 			 */
if|if
condition|(
operator|!
name|name
index|[
name|len
operator|+
literal|1
index|]
condition|)
return|return
name|NULL
return|;
comment|/* no postimage name */
name|second
operator|=
name|skip_tree_prefix
argument_list|(
name|name
operator|+
name|len
operator|+
literal|1
argument_list|,
name|line_len
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|second
condition|)
return|return
name|NULL
return|;
comment|/* 			 * Does len bytes starting at "name" and "second" 			 * (that are separated by one HT or SP we just 			 * found) exactly match? 			 */
if|if
condition|(
name|second
index|[
name|len
index|]
operator|==
literal|'\n'
operator|&&
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|second
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|xmemdupz
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Verify that we recognize the lines following a git header */
end_comment
begin_function
DECL|function|parse_git_header
specifier|static
name|int
name|parse_git_header
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* A git diff has explicit new/delete information, so we don't guess */
name|patch
operator|->
name|is_new
operator|=
literal|0
expr_stmt|;
name|patch
operator|->
name|is_delete
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Some things may not have the old name in the 	 * rest of the headers anywhere (pure mode changes, 	 * or removing or adding empty files), so we get 	 * the default name from the header. 	 */
name|patch
operator|->
name|def_name
operator|=
name|git_header_name
argument_list|(
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|def_name
operator|&&
name|root
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|xmalloc
argument_list|(
name|root_len
operator|+
name|strlen
argument_list|(
name|patch
operator|->
name|def_name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
name|root_len
argument_list|,
name|patch
operator|->
name|def_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|def_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|def_name
operator|=
name|s
expr_stmt|;
block|}
name|line
operator|+=
name|len
expr_stmt|;
name|size
operator|-=
name|len
expr_stmt|;
name|linenr
operator|++
expr_stmt|;
for|for
control|(
name|offset
operator|=
name|len
init|;
name|size
operator|>
literal|0
condition|;
name|offset
operator|+=
name|len
operator|,
name|size
operator|-=
name|len
operator|,
name|line
operator|+=
name|len
operator|,
name|linenr
operator|++
control|)
block|{
specifier|static
specifier|const
struct|struct
name|opentry
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|patch
modifier|*
parameter_list|)
function_decl|;
block|}
name|optable
index|[]
init|=
block|{
block|{
literal|"@@ -"
block|,
name|gitdiff_hdrend
block|}
block|,
block|{
literal|"--- "
block|,
name|gitdiff_oldname
block|}
block|,
block|{
literal|"+++ "
block|,
name|gitdiff_newname
block|}
block|,
block|{
literal|"old mode "
block|,
name|gitdiff_oldmode
block|}
block|,
block|{
literal|"new mode "
block|,
name|gitdiff_newmode
block|}
block|,
block|{
literal|"deleted file mode "
block|,
name|gitdiff_delete
block|}
block|,
block|{
literal|"new file mode "
block|,
name|gitdiff_newfile
block|}
block|,
block|{
literal|"copy from "
block|,
name|gitdiff_copysrc
block|}
block|,
block|{
literal|"copy to "
block|,
name|gitdiff_copydst
block|}
block|,
block|{
literal|"rename old "
block|,
name|gitdiff_renamesrc
block|}
block|,
block|{
literal|"rename new "
block|,
name|gitdiff_renamedst
block|}
block|,
block|{
literal|"rename from "
block|,
name|gitdiff_renamesrc
block|}
block|,
block|{
literal|"rename to "
block|,
name|gitdiff_renamedst
block|}
block|,
block|{
literal|"similarity index "
block|,
name|gitdiff_similarity
block|}
block|,
block|{
literal|"dissimilarity index "
block|,
name|gitdiff_dissimilarity
block|}
block|,
block|{
literal|"index "
block|,
name|gitdiff_index
block|}
block|,
block|{
literal|""
block|,
name|gitdiff_unrecognized
block|}
block|, 		}
struct|;
name|int
name|i
decl_stmt|;
name|len
operator|=
name|linelen
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|opentry
modifier|*
name|p
init|=
name|optable
operator|+
name|i
decl_stmt|;
name|int
name|oplen
init|=
name|strlen
argument_list|(
name|p
operator|->
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|oplen
operator|||
name|memcmp
argument_list|(
name|p
operator|->
name|str
argument_list|,
name|line
argument_list|,
name|oplen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|fn
argument_list|(
name|line
operator|+
name|oplen
argument_list|,
name|patch
argument_list|)
operator|<
literal|0
condition|)
return|return
name|offset
return|;
break|break;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function
begin_function
DECL|function|parse_num
specifier|static
name|int
name|parse_num
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|line
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|p
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
operator|&
name|ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
name|ptr
operator|-
name|line
return|;
block|}
end_function
begin_function
DECL|function|parse_range
specifier|static
name|int
name|parse_range
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|expect
parameter_list|,
name|unsigned
name|long
modifier|*
name|p1
parameter_list|,
name|unsigned
name|long
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|digits
decl_stmt|,
name|ex
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|len
condition|)
return|return
operator|-
literal|1
return|;
name|line
operator|+=
name|offset
expr_stmt|;
name|len
operator|-=
name|offset
expr_stmt|;
name|digits
operator|=
name|parse_num
argument_list|(
name|line
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|digits
condition|)
return|return
operator|-
literal|1
return|;
name|offset
operator|+=
name|digits
expr_stmt|;
name|line
operator|+=
name|digits
expr_stmt|;
name|len
operator|-=
name|digits
expr_stmt|;
operator|*
name|p2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|','
condition|)
block|{
name|digits
operator|=
name|parse_num
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|digits
condition|)
return|return
operator|-
literal|1
return|;
name|offset
operator|+=
name|digits
operator|+
literal|1
expr_stmt|;
name|line
operator|+=
name|digits
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|digits
operator|+
literal|1
expr_stmt|;
block|}
name|ex
operator|=
name|strlen
argument_list|(
name|expect
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|>
name|len
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|line
argument_list|,
name|expect
argument_list|,
name|ex
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|offset
operator|+
name|ex
return|;
block|}
end_function
begin_function
DECL|function|recount_diff
specifier|static
name|void
name|recount_diff
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|fragment
modifier|*
name|fragment
parameter_list|)
block|{
name|int
name|oldlines
init|=
literal|0
decl_stmt|,
name|newlines
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"recount: ignore empty hunk"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|len
init|=
name|linelen
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|size
operator|-=
name|len
expr_stmt|;
name|line
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
condition|)
break|break;
switch|switch
condition|(
operator|*
name|line
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
name|newlines
operator|++
expr_stmt|;
comment|/* fall through */
case|case
literal|'-'
case|:
name|oldlines
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
name|newlines
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
continue|continue;
case|case
literal|'@'
case|:
name|ret
operator|=
name|size
operator|<
literal|3
operator|||
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"@@ "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ret
operator|=
name|size
operator|<
literal|5
operator|||
name|prefixcmp
argument_list|(
name|line
argument_list|,
literal|"diff "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"recount: unexpected line: %.*s"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|linelen
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|fragment
operator|->
name|oldlines
operator|=
name|oldlines
expr_stmt|;
name|fragment
operator|->
name|newlines
operator|=
name|newlines
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Parse a unified diff fragment header of the  * form "@@ -a,b +c,d @@"  */
end_comment
begin_function
DECL|function|parse_fragment_header
specifier|static
name|int
name|parse_fragment_header
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|fragment
modifier|*
name|fragment
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Figure out the number of lines in a fragment */
name|offset
operator|=
name|parse_range
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
literal|4
argument_list|,
literal|" +"
argument_list|,
operator|&
name|fragment
operator|->
name|oldpos
argument_list|,
operator|&
name|fragment
operator|->
name|oldlines
argument_list|)
expr_stmt|;
name|offset
operator|=
name|parse_range
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|offset
argument_list|,
literal|" @@"
argument_list|,
operator|&
name|fragment
operator|->
name|newpos
argument_list|,
operator|&
name|fragment
operator|->
name|newlines
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_function
DECL|function|find_header
specifier|static
name|int
name|find_header
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|int
modifier|*
name|hdrsize
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|unsigned
name|long
name|offset
decl_stmt|,
name|len
decl_stmt|;
name|patch
operator|->
name|is_toplevel_relative
operator|=
literal|0
expr_stmt|;
name|patch
operator|->
name|is_rename
operator|=
name|patch
operator|->
name|is_copy
operator|=
literal|0
expr_stmt|;
name|patch
operator|->
name|is_new
operator|=
name|patch
operator|->
name|is_delete
operator|=
operator|-
literal|1
expr_stmt|;
name|patch
operator|->
name|old_mode
operator|=
name|patch
operator|->
name|new_mode
operator|=
literal|0
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|patch
operator|->
name|new_name
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|size
operator|>
literal|0
condition|;
name|offset
operator|+=
name|len
operator|,
name|size
operator|-=
name|len
operator|,
name|line
operator|+=
name|len
operator|,
name|linenr
operator|++
control|)
block|{
name|unsigned
name|long
name|nextlen
decl_stmt|;
name|len
operator|=
name|linelen
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
comment|/* Testing this early allows us to take a few shortcuts.. */
if|if
condition|(
name|len
operator|<
literal|6
condition|)
continue|continue;
comment|/* 		 * Make sure we don't find any unconnected patch fragments. 		 * That's a sign that we didn't find a header, and that a 		 * patch has become corrupted/broken up. 		 */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"@@ -"
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|struct
name|fragment
name|dummy
decl_stmt|;
if|if
condition|(
name|parse_fragment_header
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
operator|&
name|dummy
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|die
argument_list|(
name|_
argument_list|(
literal|"patch fragment without header at line %d: %.*s"
argument_list|)
argument_list|,
name|linenr
argument_list|,
operator|(
name|int
operator|)
name|len
operator|-
literal|1
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<
name|len
operator|+
literal|6
condition|)
break|break;
comment|/* 		 * Git patch? It might not have a real patch, just a rename 		 * or mode change, so we handle that specially 		 */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|"diff --git "
argument_list|,
name|line
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|int
name|git_hdr_len
init|=
name|parse_git_header
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|size
argument_list|,
name|patch
argument_list|)
decl_stmt|;
if|if
condition|(
name|git_hdr_len
operator|<=
name|len
condition|)
continue|continue;
if|if
condition|(
operator|!
name|patch
operator|->
name|old_name
operator|&&
operator|!
name|patch
operator|->
name|new_name
condition|)
block|{
if|if
condition|(
operator|!
name|patch
operator|->
name|def_name
condition|)
name|die
argument_list|(
name|Q_
argument_list|(
literal|"git diff header lacks filename information when removing "
literal|"%d leading pathname component (line %d)"
argument_list|,
literal|"git diff header lacks filename information when removing "
literal|"%d leading pathname components (line %d)"
argument_list|,
name|p_value
argument_list|)
argument_list|,
name|p_value
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|xstrdup
argument_list|(
name|patch
operator|->
name|def_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|new_name
operator|=
name|xstrdup
argument_list|(
name|patch
operator|->
name|def_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|patch
operator|->
name|is_delete
operator|&&
operator|!
name|patch
operator|->
name|new_name
condition|)
name|die
argument_list|(
literal|"git diff header lacks filename information "
literal|"(line %d)"
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
name|patch
operator|->
name|is_toplevel_relative
operator|=
literal|1
expr_stmt|;
operator|*
name|hdrsize
operator|=
name|git_hdr_len
expr_stmt|;
return|return
name|offset
return|;
block|}
comment|/* --- followed by +++ ? */
if|if
condition|(
name|memcmp
argument_list|(
literal|"--- "
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
operator|||
name|memcmp
argument_list|(
literal|"+++ "
argument_list|,
name|line
operator|+
name|len
argument_list|,
literal|4
argument_list|)
condition|)
continue|continue;
comment|/* 		 * We only accept unified patches, so we want it to 		 * at least have "@@ -a,b +c,d @@\n", which is 14 chars 		 * minimum ("@@ -0,0 +1 @@\n" is the shortest). 		 */
name|nextlen
operator|=
name|linelen
argument_list|(
name|line
operator|+
name|len
argument_list|,
name|size
operator|-
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|nextlen
operator|+
literal|14
operator|||
name|memcmp
argument_list|(
literal|"@@ -"
argument_list|,
name|line
operator|+
name|len
operator|+
name|nextlen
argument_list|,
literal|4
argument_list|)
condition|)
continue|continue;
comment|/* Ok, we'll consider it a patch */
name|parse_traditional_patch
argument_list|(
name|line
argument_list|,
name|line
operator|+
name|len
argument_list|,
name|patch
argument_list|)
expr_stmt|;
operator|*
name|hdrsize
operator|=
name|len
operator|+
name|nextlen
expr_stmt|;
name|linenr
operator|+=
literal|2
expr_stmt|;
return|return
name|offset
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|record_ws_error
specifier|static
name|void
name|record_ws_error
parameter_list|(
name|unsigned
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|linenr
parameter_list|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return;
name|whitespace_error
operator|++
expr_stmt|;
if|if
condition|(
name|squelch_whitespace_errors
operator|&&
name|squelch_whitespace_errors
operator|<
name|whitespace_error
condition|)
return|return;
name|err
operator|=
name|whitespace_error_string
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s.\n%.*s\n"
argument_list|,
name|patch_input_file
argument_list|,
name|linenr
argument_list|,
name|err
argument_list|,
name|len
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_whitespace
specifier|static
name|void
name|check_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|ws_rule
parameter_list|)
block|{
name|unsigned
name|result
init|=
name|ws_check
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|ws_rule
argument_list|)
decl_stmt|;
name|record_ws_error
argument_list|(
name|result
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|2
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Parse a unified diff. Note that this really needs to parse each  * fragment separately, since the only way to know the difference  * between a "---" that is part of a patch, and a "---" that starts  * the next patch is to look at the line counts..  */
end_comment
begin_function
DECL|function|parse_fragment
specifier|static
name|int
name|parse_fragment
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|struct
name|fragment
modifier|*
name|fragment
parameter_list|)
block|{
name|int
name|added
decl_stmt|,
name|deleted
decl_stmt|;
name|int
name|len
init|=
name|linelen
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
decl_stmt|,
name|offset
decl_stmt|;
name|unsigned
name|long
name|oldlines
decl_stmt|,
name|newlines
decl_stmt|;
name|unsigned
name|long
name|leading
decl_stmt|,
name|trailing
decl_stmt|;
name|offset
operator|=
name|parse_fragment_header
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|patch
operator|->
name|recount
condition|)
name|recount_diff
argument_list|(
name|line
operator|+
name|offset
argument_list|,
name|size
operator|-
name|offset
argument_list|,
name|fragment
argument_list|)
expr_stmt|;
name|oldlines
operator|=
name|fragment
operator|->
name|oldlines
expr_stmt|;
name|newlines
operator|=
name|fragment
operator|->
name|newlines
expr_stmt|;
name|leading
operator|=
literal|0
expr_stmt|;
name|trailing
operator|=
literal|0
expr_stmt|;
comment|/* Parse the thing.. */
name|line
operator|+=
name|len
expr_stmt|;
name|size
operator|-=
name|len
expr_stmt|;
name|linenr
operator|++
expr_stmt|;
name|added
operator|=
name|deleted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|offset
operator|=
name|len
init|;
literal|0
operator|<
name|size
condition|;
name|offset
operator|+=
name|len
operator|,
name|size
operator|-=
name|len
operator|,
name|line
operator|+=
name|len
operator|,
name|linenr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|oldlines
operator|&&
operator|!
name|newlines
condition|)
break|break;
name|len
operator|=
name|linelen
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
operator|*
name|line
condition|)
block|{
default|default:
return|return
operator|-
literal|1
return|;
case|case
literal|'\n'
case|:
comment|/* newer GNU diff, an empty context line */
case|case
literal|' '
case|:
name|oldlines
operator|--
expr_stmt|;
name|newlines
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|deleted
operator|&&
operator|!
name|added
condition|)
name|leading
operator|++
expr_stmt|;
name|trailing
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|apply_in_reverse
operator|&&
name|ws_error_action
operator|!=
name|nowarn_ws_error
condition|)
name|check_whitespace
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|patch
operator|->
name|ws_rule
argument_list|)
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
name|oldlines
operator|--
expr_stmt|;
name|trailing
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
name|apply_in_reverse
operator|&&
name|ws_error_action
operator|!=
name|nowarn_ws_error
condition|)
name|check_whitespace
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|patch
operator|->
name|ws_rule
argument_list|)
expr_stmt|;
name|added
operator|++
expr_stmt|;
name|newlines
operator|--
expr_stmt|;
name|trailing
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * We allow "\ No newline at end of file". Depending                  * on locale settings when the patch was produced we                  * don't know what this line looks like. The only                  * thing we do know is that it begins with "\ ". 		 * Checking for 12 is just for sanity check -- any 		 * l10n of "\ No newline..." is at least that long. 		 */
case|case
literal|'\\'
case|:
if|if
condition|(
name|len
operator|<
literal|12
operator|||
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"\\ "
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
block|}
if|if
condition|(
name|oldlines
operator|||
name|newlines
condition|)
return|return
operator|-
literal|1
return|;
name|fragment
operator|->
name|leading
operator|=
name|leading
expr_stmt|;
name|fragment
operator|->
name|trailing
operator|=
name|trailing
expr_stmt|;
comment|/* 	 * If a fragment ends with an incomplete line, we failed to include 	 * it in the above loop because we hit oldlines == newlines == 0 	 * before seeing it. 	 */
if|if
condition|(
literal|12
operator|<
name|size
operator|&&
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"\\ "
argument_list|,
literal|2
argument_list|)
condition|)
name|offset
operator|+=
name|linelen
argument_list|(
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|patch
operator|->
name|lines_added
operator|+=
name|added
expr_stmt|;
name|patch
operator|->
name|lines_deleted
operator|+=
name|deleted
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|patch
operator|->
name|is_new
operator|&&
name|oldlines
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"new file depends on old contents"
argument_list|)
argument_list|)
return|;
if|if
condition|(
literal|0
operator|<
name|patch
operator|->
name|is_delete
operator|&&
name|newlines
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"deleted file still has contents"
argument_list|)
argument_list|)
return|;
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/*  * We have seen "diff --git a/... b/..." header (or a traditional patch  * header).  Read hunks that belong to this patch into fragments and hang  * them to the given patch structure.  *  * The (fragment->patch, fragment->size) pair points into the memory given  * by the caller, not a copy, when we return.  */
end_comment
begin_function
DECL|function|parse_single_patch
specifier|static
name|int
name|parse_single_patch
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|unsigned
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|oldlines
init|=
literal|0
decl_stmt|,
name|newlines
init|=
literal|0
decl_stmt|,
name|context
init|=
literal|0
decl_stmt|;
name|struct
name|fragment
modifier|*
modifier|*
name|fragp
init|=
operator|&
name|patch
operator|->
name|fragments
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|4
operator|&&
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|struct
name|fragment
modifier|*
name|fragment
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fragment
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fragment
argument_list|)
argument_list|)
expr_stmt|;
name|fragment
operator|->
name|linenr
operator|=
name|linenr
expr_stmt|;
name|len
operator|=
name|parse_fragment
argument_list|(
name|line
argument_list|,
name|size
argument_list|,
name|patch
argument_list|,
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"corrupt patch at line %d"
argument_list|)
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
name|fragment
operator|->
name|patch
operator|=
name|line
expr_stmt|;
name|fragment
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|oldlines
operator|+=
name|fragment
operator|->
name|oldlines
expr_stmt|;
name|newlines
operator|+=
name|fragment
operator|->
name|newlines
expr_stmt|;
name|context
operator|+=
name|fragment
operator|->
name|leading
operator|+
name|fragment
operator|->
name|trailing
expr_stmt|;
operator|*
name|fragp
operator|=
name|fragment
expr_stmt|;
name|fragp
operator|=
operator|&
name|fragment
operator|->
name|next
expr_stmt|;
name|offset
operator|+=
name|len
expr_stmt|;
name|line
operator|+=
name|len
expr_stmt|;
name|size
operator|-=
name|len
expr_stmt|;
block|}
comment|/* 	 * If something was removed (i.e. we have old-lines) it cannot 	 * be creation, and if something was added it cannot be 	 * deletion.  However, the reverse is not true; --unified=0 	 * patches that only add are not necessarily creation even 	 * though they do not have any old lines, and ones that only 	 * delete are not necessarily deletion. 	 * 	 * Unfortunately, a real creation/deletion patch do _not_ have 	 * any context line by definition, so we cannot safely tell it 	 * apart with --unified=0 insanity.  At least if the patch has 	 * more than one hunk it is not creation or deletion. 	 */
if|if
condition|(
name|patch
operator|->
name|is_new
operator|<
literal|0
operator|&&
operator|(
name|oldlines
operator|||
operator|(
name|patch
operator|->
name|fragments
operator|&&
name|patch
operator|->
name|fragments
operator|->
name|next
operator|)
operator|)
condition|)
name|patch
operator|->
name|is_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|is_delete
operator|<
literal|0
operator|&&
operator|(
name|newlines
operator|||
operator|(
name|patch
operator|->
name|fragments
operator|&&
name|patch
operator|->
name|fragments
operator|->
name|next
operator|)
operator|)
condition|)
name|patch
operator|->
name|is_delete
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|patch
operator|->
name|is_new
operator|&&
name|oldlines
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"new file %s depends on old contents"
argument_list|)
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|patch
operator|->
name|is_delete
operator|&&
name|newlines
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"deleted file %s still has contents"
argument_list|)
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patch
operator|->
name|is_delete
operator|&&
operator|!
name|newlines
operator|&&
name|context
condition|)
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"** warning: "
literal|"file %s becomes empty but is not deleted"
argument_list|)
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_function
DECL|function|metadata_changes
specifier|static
specifier|inline
name|int
name|metadata_changes
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
return|return
name|patch
operator|->
name|is_rename
operator|>
literal|0
operator|||
name|patch
operator|->
name|is_copy
operator|>
literal|0
operator|||
name|patch
operator|->
name|is_new
operator|>
literal|0
operator|||
name|patch
operator|->
name|is_delete
operator|||
operator|(
name|patch
operator|->
name|old_mode
operator|&&
name|patch
operator|->
name|new_mode
operator|&&
name|patch
operator|->
name|old_mode
operator|!=
name|patch
operator|->
name|new_mode
operator|)
return|;
block|}
end_function
begin_function
DECL|function|inflate_it
specifier|static
name|char
modifier|*
name|inflate_it
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|unsigned
name|long
name|inflated_size
parameter_list|)
block|{
name|git_zstream
name|stream
decl_stmt|;
name|void
modifier|*
name|out
decl_stmt|;
name|int
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|size
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|out
operator|=
name|xmalloc
argument_list|(
name|inflated_size
argument_list|)
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|inflated_size
expr_stmt|;
name|git_inflate_init
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|st
operator|=
name|git_inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
name|git_inflate_end
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|Z_STREAM_END
operator|)
operator|||
name|stream
operator|.
name|total_out
operator|!=
name|inflated_size
condition|)
block|{
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*  * Read a binary hunk and return a new fragment; fragment->patch  * points at an allocated memory that the caller must free, so  * it is marked as "->free_patch = 1".  */
end_comment
begin_function
DECL|function|parse_binary_hunk
specifier|static
name|struct
name|fragment
modifier|*
name|parse_binary_hunk
parameter_list|(
name|char
modifier|*
modifier|*
name|buf_p
parameter_list|,
name|unsigned
name|long
modifier|*
name|sz_p
parameter_list|,
name|int
modifier|*
name|status_p
parameter_list|,
name|int
modifier|*
name|used_p
parameter_list|)
block|{
comment|/* 	 * Expect a line that begins with binary patch method ("literal" 	 * or "delta"), followed by the length of data before deflating. 	 * a sequence of 'length-byte' followed by base-85 encoded data 	 * should follow, terminated by a newline. 	 * 	 * Each 5-byte sequence of base-85 encodes up to 4 bytes, 	 * and we would limit the patch line to 66 characters, 	 * so one line can fit up to 13 groups that would decode 	 * to 52 bytes max.  The length byte 'A'-'Z' corresponds 	 * to 1-26 bytes, and 'a'-'z' corresponds to 27-52 bytes. 	 */
name|int
name|llen
decl_stmt|,
name|used
decl_stmt|;
name|unsigned
name|long
name|size
init|=
operator|*
name|sz_p
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|*
name|buf_p
decl_stmt|;
name|int
name|patch_method
decl_stmt|;
name|unsigned
name|long
name|origlen
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|int
name|hunk_size
init|=
literal|0
decl_stmt|;
name|struct
name|fragment
modifier|*
name|frag
decl_stmt|;
name|llen
operator|=
name|linelen
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|used
operator|=
name|llen
expr_stmt|;
operator|*
name|status_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"delta "
argument_list|)
condition|)
block|{
name|patch_method
operator|=
name|BINARY_DELTA_DEFLATED
expr_stmt|;
name|origlen
operator|=
name|strtoul
argument_list|(
name|buffer
operator|+
literal|6
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"literal "
argument_list|)
condition|)
block|{
name|patch_method
operator|=
name|BINARY_LITERAL_DEFLATED
expr_stmt|;
name|origlen
operator|=
name|strtoul
argument_list|(
name|buffer
operator|+
literal|8
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL
return|;
name|linenr
operator|++
expr_stmt|;
name|buffer
operator|+=
name|llen
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|byte_length
decl_stmt|,
name|max_byte_length
decl_stmt|,
name|newsize
decl_stmt|;
name|llen
operator|=
name|linelen
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|used
operator|+=
name|llen
expr_stmt|;
name|linenr
operator|++
expr_stmt|;
if|if
condition|(
name|llen
operator|==
literal|1
condition|)
block|{
comment|/* consume the blank line */
name|buffer
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
break|break;
block|}
comment|/* 		 * Minimum line is "A00000\n" which is 7-byte long, 		 * and the line length must be multiple of 5 plus 2. 		 */
if|if
condition|(
operator|(
name|llen
operator|<
literal|7
operator|)
operator|||
operator|(
name|llen
operator|-
literal|2
operator|)
operator|%
literal|5
condition|)
goto|goto
name|corrupt
goto|;
name|max_byte_length
operator|=
operator|(
name|llen
operator|-
literal|2
operator|)
operator|/
literal|5
operator|*
literal|4
expr_stmt|;
name|byte_length
operator|=
operator|*
name|buffer
expr_stmt|;
if|if
condition|(
literal|'A'
operator|<=
name|byte_length
operator|&&
name|byte_length
operator|<=
literal|'Z'
condition|)
name|byte_length
operator|=
name|byte_length
operator|-
literal|'A'
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|byte_length
operator|&&
name|byte_length
operator|<=
literal|'z'
condition|)
name|byte_length
operator|=
name|byte_length
operator|-
literal|'a'
operator|+
literal|27
expr_stmt|;
else|else
goto|goto
name|corrupt
goto|;
comment|/* if the input length was not multiple of 4, we would 		 * have filler at the end but the filler should never 		 * exceed 3 bytes 		 */
if|if
condition|(
name|max_byte_length
operator|<
name|byte_length
operator|||
name|byte_length
operator|<=
name|max_byte_length
operator|-
literal|4
condition|)
goto|goto
name|corrupt
goto|;
name|newsize
operator|=
name|hunk_size
operator|+
name|byte_length
expr_stmt|;
name|data
operator|=
name|xrealloc
argument_list|(
name|data
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode_85
argument_list|(
name|data
operator|+
name|hunk_size
argument_list|,
name|buffer
operator|+
literal|1
argument_list|,
name|byte_length
argument_list|)
condition|)
goto|goto
name|corrupt
goto|;
name|hunk_size
operator|=
name|newsize
expr_stmt|;
name|buffer
operator|+=
name|llen
expr_stmt|;
name|size
operator|-=
name|llen
expr_stmt|;
block|}
name|frag
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|patch
operator|=
name|inflate_it
argument_list|(
name|data
argument_list|,
name|hunk_size
argument_list|,
name|origlen
argument_list|)
expr_stmt|;
name|frag
operator|->
name|free_patch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|frag
operator|->
name|patch
condition|)
goto|goto
name|corrupt
goto|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|frag
operator|->
name|size
operator|=
name|origlen
expr_stmt|;
operator|*
name|buf_p
operator|=
name|buffer
expr_stmt|;
operator|*
name|sz_p
operator|=
name|size
expr_stmt|;
operator|*
name|used_p
operator|=
name|used
expr_stmt|;
name|frag
operator|->
name|binary_patch_method
operator|=
name|patch_method
expr_stmt|;
return|return
name|frag
return|;
name|corrupt
label|:
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
operator|*
name|status_p
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"corrupt binary patch at line %d: %.*s"
argument_list|)
argument_list|,
name|linenr
operator|-
literal|1
argument_list|,
name|llen
operator|-
literal|1
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|parse_binary
specifier|static
name|int
name|parse_binary
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
comment|/* 	 * We have read "GIT binary patch\n"; what follows is a line 	 * that says the patch method (currently, either "literal" or 	 * "delta") and the length of data before deflating; a 	 * sequence of 'length-byte' followed by base-85 encoded data 	 * follows. 	 * 	 * When a binary patch is reversible, there is another binary 	 * hunk in the same format, starting with patch method (either 	 * "literal" or "delta") with the length of data, and a sequence 	 * of length-byte + base-85 encoded data, terminated with another 	 * empty line.  This data, when applied to the postimage, produces 	 * the preimage. 	 */
name|struct
name|fragment
modifier|*
name|forward
decl_stmt|;
name|struct
name|fragment
modifier|*
name|reverse
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|used
decl_stmt|,
name|used_1
decl_stmt|;
name|forward
operator|=
name|parse_binary_hunk
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forward
operator|&&
operator|!
name|status
condition|)
comment|/* there has to be one hunk (forward hunk) */
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"unrecognized binary patch at line %d"
argument_list|)
argument_list|,
name|linenr
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|status
condition|)
comment|/* otherwise we already gave an error message */
return|return
name|status
return|;
name|reverse
operator|=
name|parse_binary_hunk
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|used_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|used
operator|+=
name|used_1
expr_stmt|;
elseif|else
if|if
condition|(
name|status
condition|)
block|{
comment|/* 		 * Not having reverse hunk is not an error, but having 		 * a corrupt reverse hunk is. 		 */
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|forward
operator|->
name|patch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|forward
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|forward
operator|->
name|next
operator|=
name|reverse
expr_stmt|;
name|patch
operator|->
name|fragments
operator|=
name|forward
expr_stmt|;
name|patch
operator|->
name|is_binary
operator|=
literal|1
expr_stmt|;
return|return
name|used
return|;
block|}
end_function
begin_comment
comment|/*  * Read the patch text in "buffer" that extends for "size" bytes; stop  * reading after seeing a single patch (i.e. changes to a single file).  * Create fragments (i.e. patch hunks) and hang them to the given patch.  * Return the number of bytes consumed, so that the caller can call us  * again for the next patch.  */
end_comment
begin_function
DECL|function|parse_chunk
specifier|static
name|int
name|parse_chunk
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|int
name|hdrsize
decl_stmt|,
name|patchsize
decl_stmt|;
name|int
name|offset
init|=
name|find_header
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
operator|&
name|hdrsize
argument_list|,
name|patch
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
name|offset
return|;
name|patch
operator|->
name|ws_rule
operator|=
name|whitespace_rule
argument_list|(
name|patch
operator|->
name|new_name
condition|?
name|patch
operator|->
name|new_name
else|:
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|patchsize
operator|=
name|parse_single_patch
argument_list|(
name|buffer
operator|+
name|offset
operator|+
name|hdrsize
argument_list|,
name|size
operator|-
name|offset
operator|-
name|hdrsize
argument_list|,
name|patch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patchsize
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|binhdr
index|[]
init|=
block|{
literal|"Binary files "
block|,
literal|"Files "
block|,
name|NULL
block|, 		}
decl_stmt|;
specifier|static
specifier|const
name|char
name|git_binary
index|[]
init|=
literal|"GIT binary patch\n"
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hd
init|=
name|hdrsize
operator|+
name|offset
decl_stmt|;
name|unsigned
name|long
name|llen
init|=
name|linelen
argument_list|(
name|buffer
operator|+
name|hd
argument_list|,
name|size
operator|-
name|hd
argument_list|)
decl_stmt|;
if|if
condition|(
name|llen
operator|==
sizeof|sizeof
argument_list|(
name|git_binary
argument_list|)
operator|-
literal|1
operator|&&
operator|!
name|memcmp
argument_list|(
name|git_binary
argument_list|,
name|buffer
operator|+
name|hd
argument_list|,
name|llen
argument_list|)
condition|)
block|{
name|int
name|used
decl_stmt|;
name|linenr
operator|++
expr_stmt|;
name|used
operator|=
name|parse_binary
argument_list|(
name|buffer
operator|+
name|hd
operator|+
name|llen
argument_list|,
name|size
operator|-
name|hd
operator|-
name|llen
argument_list|,
name|patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
condition|)
name|patchsize
operator|=
name|used
operator|+
name|llen
expr_stmt|;
else|else
name|patchsize
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|memcmp
argument_list|(
literal|" differ\n"
argument_list|,
name|buffer
operator|+
name|hd
operator|+
name|llen
operator|-
literal|8
argument_list|,
literal|8
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|binhdr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|binhdr
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|size
operator|-
name|hd
operator|&&
operator|!
name|memcmp
argument_list|(
name|binhdr
index|[
name|i
index|]
argument_list|,
name|buffer
operator|+
name|hd
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|linenr
operator|++
expr_stmt|;
name|patch
operator|->
name|is_binary
operator|=
literal|1
expr_stmt|;
name|patchsize
operator|=
name|llen
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Empty patch cannot be applied if it is a text patch 		 * without metadata change.  A binary patch appears 		 * empty to us here. 		 */
if|if
condition|(
operator|(
name|apply
operator|||
name|check
operator|)
operator|&&
operator|(
operator|!
name|patch
operator|->
name|is_binary
operator|&&
operator|!
name|metadata_changes
argument_list|(
name|patch
argument_list|)
operator|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"patch with only garbage at line %d"
argument_list|)
argument_list|,
name|linenr
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
operator|+
name|hdrsize
operator|+
name|patchsize
return|;
block|}
end_function
begin_define
DECL|macro|swap
define|#
directive|define
name|swap
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|myswap((a),(b),sizeof(a))
end_define
begin_define
DECL|macro|myswap
define|#
directive|define
name|myswap
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|size
parameter_list|)
value|do {		\ 	unsigned char mytmp[size];	\ 	memcpy(mytmp,&a, size);		\ 	memcpy(&a,&b, size);		\ 	memcpy(&b, mytmp, size);		\ } while (0)
end_define
begin_function
DECL|function|reverse_patches
specifier|static
name|void
name|reverse_patches
parameter_list|(
name|struct
name|patch
modifier|*
name|p
parameter_list|)
block|{
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|fragment
modifier|*
name|frag
init|=
name|p
operator|->
name|fragments
decl_stmt|;
name|swap
argument_list|(
name|p
operator|->
name|new_name
argument_list|,
name|p
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|p
operator|->
name|new_mode
argument_list|,
name|p
operator|->
name|old_mode
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|p
operator|->
name|is_new
argument_list|,
name|p
operator|->
name|is_delete
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|p
operator|->
name|lines_added
argument_list|,
name|p
operator|->
name|lines_deleted
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|p
operator|->
name|old_sha1_prefix
argument_list|,
name|p
operator|->
name|new_sha1_prefix
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|frag
condition|;
name|frag
operator|=
name|frag
operator|->
name|next
control|)
block|{
name|swap
argument_list|(
name|frag
operator|->
name|newpos
argument_list|,
name|frag
operator|->
name|oldpos
argument_list|)
expr_stmt|;
name|swap
argument_list|(
name|frag
operator|->
name|newlines
argument_list|,
name|frag
operator|->
name|oldlines
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|pluses
specifier|static
specifier|const
name|char
name|pluses
index|[]
init|=
literal|"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|minuses
specifier|static
specifier|const
name|char
name|minuses
index|[]
init|=
literal|"----------------------------------------------------------------------"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|show_stats
specifier|static
name|void
name|show_stats
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|strbuf
name|qname
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|patch
operator|->
name|new_name
condition|?
name|patch
operator|->
name|new_name
else|:
name|patch
operator|->
name|old_name
decl_stmt|;
name|int
name|max
decl_stmt|,
name|add
decl_stmt|,
name|del
decl_stmt|;
name|quote_c_style
argument_list|(
name|cp
argument_list|,
operator|&
name|qname
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * "scale" the filename 	 */
name|max
operator|=
name|max_len
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|50
condition|)
name|max
operator|=
literal|50
expr_stmt|;
if|if
condition|(
name|qname
operator|.
name|len
operator|>
name|max
condition|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|qname
operator|.
name|buf
operator|+
name|qname
operator|.
name|len
operator|+
literal|3
operator|-
name|max
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|cp
operator|=
name|qname
operator|.
name|buf
operator|+
name|qname
operator|.
name|len
operator|+
literal|3
operator|-
name|max
expr_stmt|;
name|strbuf_splice
argument_list|(
operator|&
name|qname
argument_list|,
literal|0
argument_list|,
name|cp
operator|-
name|qname
operator|.
name|buf
argument_list|,
literal|"..."
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|patch
operator|->
name|is_binary
condition|)
block|{
name|printf
argument_list|(
literal|" %-*s |  Bin\n"
argument_list|,
name|max
argument_list|,
name|qname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|qname
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" %-*s |"
argument_list|,
name|max
argument_list|,
name|qname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|qname
argument_list|)
expr_stmt|;
comment|/* 	 * scale the add/delete 	 */
name|max
operator|=
name|max
operator|+
name|max_change
operator|>
literal|70
condition|?
literal|70
operator|-
name|max
else|:
name|max_change
expr_stmt|;
name|add
operator|=
name|patch
operator|->
name|lines_added
expr_stmt|;
name|del
operator|=
name|patch
operator|->
name|lines_deleted
expr_stmt|;
if|if
condition|(
name|max_change
operator|>
literal|0
condition|)
block|{
name|int
name|total
init|=
operator|(
operator|(
name|add
operator|+
name|del
operator|)
operator|*
name|max
operator|+
name|max_change
operator|/
literal|2
operator|)
operator|/
name|max_change
decl_stmt|;
name|add
operator|=
operator|(
name|add
operator|*
name|max
operator|+
name|max_change
operator|/
literal|2
operator|)
operator|/
name|max_change
expr_stmt|;
name|del
operator|=
name|total
operator|-
name|add
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%5d %.*s%.*s\n"
argument_list|,
name|patch
operator|->
name|lines_added
operator|+
name|patch
operator|->
name|lines_deleted
argument_list|,
name|add
argument_list|,
name|pluses
argument_list|,
name|del
argument_list|,
name|minuses
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_old_data
specifier|static
name|int
name|read_old_data
parameter_list|(
name|struct
name|stat
modifier|*
name|st
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|)
block|{
switch|switch
condition|(
name|st
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFLNK
case|:
if|if
condition|(
name|strbuf_readlink
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
name|st
operator|->
name|st_size
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"unable to read symlink %s"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|S_IFREG
case|:
if|if
condition|(
name|strbuf_read_file
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
name|st
operator|->
name|st_size
argument_list|)
operator|!=
name|st
operator|->
name|st_size
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"unable to open or read %s"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|convert_to_git
argument_list|(
name|path
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_comment
comment|/*  * Update the preimage, and the common lines in postimage,  * from buffer buf of length len. If postlen is 0 the postimage  * is updated in place, otherwise it's updated on a new buffer  * of length postlen  */
end_comment
begin_function
DECL|function|update_pre_post_images
specifier|static
name|void
name|update_pre_post_images
parameter_list|(
name|struct
name|image
modifier|*
name|preimage
parameter_list|,
name|struct
name|image
modifier|*
name|postimage
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
name|postlen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ctx
decl_stmt|,
name|reduced
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|,
modifier|*
name|fixed
decl_stmt|;
name|struct
name|image
name|fixed_preimage
decl_stmt|;
comment|/* 	 * Update the preimage with whitespace fixes.  Note that we 	 * are not losing preimage->buf -- apply_one_fragment() will 	 * free "oldlines". 	 */
name|prepare_image
argument_list|(
operator|&
name|fixed_preimage
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|postlen
condition|?
name|fixed_preimage
operator|.
name|nr
operator|==
name|preimage
operator|->
name|nr
else|:
name|fixed_preimage
operator|.
name|nr
operator|<=
name|preimage
operator|->
name|nr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fixed_preimage
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|fixed_preimage
operator|.
name|line
index|[
name|i
index|]
operator|.
name|flag
operator|=
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|flag
expr_stmt|;
name|free
argument_list|(
name|preimage
operator|->
name|line_allocated
argument_list|)
expr_stmt|;
operator|*
name|preimage
operator|=
name|fixed_preimage
expr_stmt|;
comment|/* 	 * Adjust the common context lines in postimage. This can be 	 * done in-place when we are shrinking it with whitespace 	 * fixing, but needs a new buffer when ignoring whitespace or 	 * expanding leading tabs to spaces. 	 * 	 * We trust the caller to tell us if the update can be done 	 * in place (postlen==0) or not. 	 */
name|old
operator|=
name|postimage
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|postlen
condition|)
name|new
operator|=
name|postimage
operator|->
name|buf
operator|=
name|xmalloc
argument_list|(
name|postlen
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|old
expr_stmt|;
name|fixed
operator|=
name|preimage
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
name|reduced
operator|=
name|ctx
operator|=
literal|0
init|;
name|i
operator|<
name|postimage
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|postimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|postimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|LINE_COMMON
operator|)
condition|)
block|{
comment|/* an added line -- no counterparts in preimage */
name|memmove
argument_list|(
name|new
argument_list|,
name|old
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|old
operator|+=
name|len
expr_stmt|;
name|new
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
comment|/* a common context -- skip it in the original postimage */
name|old
operator|+=
name|len
expr_stmt|;
comment|/* and find the corresponding one in the fixed preimage */
while|while
condition|(
name|ctx
operator|<
name|preimage
operator|->
name|nr
operator|&&
operator|!
operator|(
name|preimage
operator|->
name|line
index|[
name|ctx
index|]
operator|.
name|flag
operator|&
name|LINE_COMMON
operator|)
condition|)
block|{
name|fixed
operator|+=
name|preimage
operator|->
name|line
index|[
name|ctx
index|]
operator|.
name|len
expr_stmt|;
name|ctx
operator|++
expr_stmt|;
block|}
comment|/* 		 * preimage is expected to run out, if the caller 		 * fixed addition of trailing blank lines. 		 */
if|if
condition|(
name|preimage
operator|->
name|nr
operator|<=
name|ctx
condition|)
block|{
name|reduced
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* and copy it in, while fixing the line length */
name|len
operator|=
name|preimage
operator|->
name|line
index|[
name|ctx
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
name|fixed
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new
operator|+=
name|len
expr_stmt|;
name|fixed
operator|+=
name|len
expr_stmt|;
name|postimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ctx
operator|++
expr_stmt|;
block|}
comment|/* Fix the length of the whole thing */
name|postimage
operator|->
name|len
operator|=
name|new
operator|-
name|postimage
operator|->
name|buf
expr_stmt|;
name|postimage
operator|->
name|nr
operator|-=
name|reduced
expr_stmt|;
block|}
end_function
begin_function
DECL|function|match_fragment
specifier|static
name|int
name|match_fragment
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
name|struct
name|image
modifier|*
name|preimage
parameter_list|,
name|struct
name|image
modifier|*
name|postimage
parameter_list|,
name|unsigned
name|long
name|try
parameter_list|,
name|int
name|try_lno
parameter_list|,
name|unsigned
name|ws_rule
parameter_list|,
name|int
name|match_beginning
parameter_list|,
name|int
name|match_end
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|fixed_buf
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|orig
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|struct
name|strbuf
name|fixed
decl_stmt|;
name|size_t
name|fixed_len
decl_stmt|,
name|postlen
decl_stmt|;
name|int
name|preimage_limit
decl_stmt|;
if|if
condition|(
name|preimage
operator|->
name|nr
operator|+
name|try_lno
operator|<=
name|img
operator|->
name|nr
condition|)
block|{
comment|/* 		 * The hunk falls within the boundaries of img. 		 */
name|preimage_limit
operator|=
name|preimage
operator|->
name|nr
expr_stmt|;
if|if
condition|(
name|match_end
operator|&&
operator|(
name|preimage
operator|->
name|nr
operator|+
name|try_lno
operator|!=
name|img
operator|->
name|nr
operator|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ws_error_action
operator|==
name|correct_ws_error
operator|&&
operator|(
name|ws_rule
operator|&
name|WS_BLANK_AT_EOF
operator|)
condition|)
block|{
comment|/* 		 * This hunk extends beyond the end of img, and we are 		 * removing blank lines at the end of the file.  This 		 * many lines from the beginning of the preimage must 		 * match with img, and the remainder of the preimage 		 * must be blank. 		 */
name|preimage_limit
operator|=
name|img
operator|->
name|nr
operator|-
name|try_lno
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The hunk extends beyond the end of the img and 		 * we are not removing blanks at the end, so we 		 * should reject the hunk at this position. 		 */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|match_beginning
operator|&&
name|try_lno
condition|)
return|return
literal|0
return|;
comment|/* Quick hash check */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preimage_limit
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|img
operator|->
name|line
index|[
name|try_lno
operator|+
name|i
index|]
operator|.
name|flag
operator|&
name|LINE_PATCHED
operator|)
operator|||
operator|(
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|hash
operator|!=
name|img
operator|->
name|line
index|[
name|try_lno
operator|+
name|i
index|]
operator|.
name|hash
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|preimage_limit
operator|==
name|preimage
operator|->
name|nr
condition|)
block|{
comment|/* 		 * Do we have an exact match?  If we were told to match 		 * at the end, size must be exactly at try+fragsize, 		 * otherwise try+fragsize must be still within the preimage, 		 * and either case, the old piece should match the preimage 		 * exactly. 		 */
if|if
condition|(
operator|(
name|match_end
condition|?
operator|(
name|try
operator|+
name|preimage
operator|->
name|len
operator|==
name|img
operator|->
name|len
operator|)
else|:
operator|(
name|try
operator|+
name|preimage
operator|->
name|len
operator|<=
name|img
operator|->
name|len
operator|)
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|img
operator|->
name|buf
operator|+
name|try
argument_list|,
name|preimage
operator|->
name|buf
argument_list|,
name|preimage
operator|->
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* 		 * The preimage extends beyond the end of img, so 		 * there cannot be an exact match. 		 * 		 * There must be one non-blank context line that match 		 * a line before the end of img. 		 */
name|char
modifier|*
name|buf_end
decl_stmt|;
name|buf
operator|=
name|preimage
operator|->
name|buf
expr_stmt|;
name|buf_end
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preimage_limit
condition|;
name|i
operator|++
control|)
name|buf_end
operator|+=
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
for|for
control|(
init|;
name|buf
operator|<
name|buf_end
condition|;
name|buf
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
break|break;
if|if
condition|(
name|buf
operator|==
name|buf_end
condition|)
return|return
literal|0
return|;
block|}
comment|/* 	 * No exact match. If we are ignoring whitespace, run a line-by-line 	 * fuzzy matching. We collect all the line length information because 	 * we need it to adjust whitespace if we match. 	 */
if|if
condition|(
name|ws_ignore_action
operator|==
name|ignore_ws_change
condition|)
block|{
name|size_t
name|imgoff
init|=
literal|0
decl_stmt|;
name|size_t
name|preoff
init|=
literal|0
decl_stmt|;
name|size_t
name|postlen
init|=
name|postimage
operator|->
name|len
decl_stmt|;
name|size_t
name|extra_chars
decl_stmt|;
name|char
modifier|*
name|preimage_eof
decl_stmt|;
name|char
modifier|*
name|preimage_end
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preimage_limit
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|prelen
init|=
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
name|size_t
name|imglen
init|=
name|img
operator|->
name|line
index|[
name|try_lno
operator|+
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|fuzzy_matchlines
argument_list|(
name|img
operator|->
name|buf
operator|+
name|try
operator|+
name|imgoff
argument_list|,
name|imglen
argument_list|,
name|preimage
operator|->
name|buf
operator|+
name|preoff
argument_list|,
name|prelen
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|LINE_COMMON
condition|)
name|postlen
operator|+=
name|imglen
operator|-
name|prelen
expr_stmt|;
name|imgoff
operator|+=
name|imglen
expr_stmt|;
name|preoff
operator|+=
name|prelen
expr_stmt|;
block|}
comment|/* 		 * Ok, the preimage matches with whitespace fuzz. 		 * 		 * imgoff now holds the true length of the target that 		 * matches the preimage before the end of the file. 		 * 		 * Count the number of characters in the preimage that fall 		 * beyond the end of the file and make sure that all of them 		 * are whitespace characters. (This can only happen if 		 * we are removing blank lines at the end of the file.) 		 */
name|buf
operator|=
name|preimage_eof
operator|=
name|preimage
operator|->
name|buf
operator|+
name|preoff
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|preimage
operator|->
name|nr
condition|;
name|i
operator|++
control|)
name|preoff
operator|+=
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|preimage_end
operator|=
name|preimage
operator|->
name|buf
operator|+
name|preoff
expr_stmt|;
for|for
control|(
init|;
name|buf
operator|<
name|preimage_end
condition|;
name|buf
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 		 * Update the preimage and the common postimage context 		 * lines to use the same whitespace as the target. 		 * If whitespace is missing in the target (i.e. 		 * if the preimage extends beyond the end of the file), 		 * use the whitespace from the preimage. 		 */
name|extra_chars
operator|=
name|preimage_end
operator|-
name|preimage_eof
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|fixed
argument_list|,
name|imgoff
operator|+
name|extra_chars
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|fixed
argument_list|,
name|img
operator|->
name|buf
operator|+
name|try
argument_list|,
name|imgoff
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|fixed
argument_list|,
name|preimage_eof
argument_list|,
name|extra_chars
argument_list|)
expr_stmt|;
name|fixed_buf
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|fixed
argument_list|,
operator|&
name|fixed_len
argument_list|)
expr_stmt|;
name|update_pre_post_images
argument_list|(
name|preimage
argument_list|,
name|postimage
argument_list|,
name|fixed_buf
argument_list|,
name|fixed_len
argument_list|,
name|postlen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ws_error_action
operator|!=
name|correct_ws_error
condition|)
return|return
literal|0
return|;
comment|/* 	 * The hunk does not apply byte-by-byte, but the hash says 	 * it might with whitespace fuzz. We haven't been asked to 	 * ignore whitespace, we were asked to correct whitespace 	 * errors, so let's try matching after whitespace correction. 	 * 	 * The preimage may extend beyond the end of the file, 	 * but in this loop we will only handle the part of the 	 * preimage that falls within the file. 	 */
name|strbuf_init
argument_list|(
operator|&
name|fixed
argument_list|,
name|preimage
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|orig
operator|=
name|preimage
operator|->
name|buf
expr_stmt|;
name|target
operator|=
name|img
operator|->
name|buf
operator|+
name|try
expr_stmt|;
name|postlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preimage_limit
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|oldlen
init|=
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
name|size_t
name|tgtlen
init|=
name|img
operator|->
name|line
index|[
name|try_lno
operator|+
name|i
index|]
operator|.
name|len
decl_stmt|;
name|size_t
name|fixstart
init|=
name|fixed
operator|.
name|len
decl_stmt|;
name|struct
name|strbuf
name|tgtfix
decl_stmt|;
name|int
name|match
decl_stmt|;
comment|/* Try fixing the line in the preimage */
name|ws_fix_copy
argument_list|(
operator|&
name|fixed
argument_list|,
name|orig
argument_list|,
name|oldlen
argument_list|,
name|ws_rule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Try fixing the line in the target */
name|strbuf_init
argument_list|(
operator|&
name|tgtfix
argument_list|,
name|tgtlen
argument_list|)
expr_stmt|;
name|ws_fix_copy
argument_list|(
operator|&
name|tgtfix
argument_list|,
name|target
argument_list|,
name|tgtlen
argument_list|,
name|ws_rule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If they match, either the preimage was based on 		 * a version before our tree fixed whitespace breakage, 		 * or we are lacking a whitespace-fix patch the tree 		 * the preimage was based on already had (i.e. target 		 * has whitespace breakage, the preimage doesn't). 		 * In either case, we are fixing the whitespace breakages 		 * so we might as well take the fix together with their 		 * real change. 		 */
name|match
operator|=
operator|(
name|tgtfix
operator|.
name|len
operator|==
name|fixed
operator|.
name|len
operator|-
name|fixstart
operator|&&
operator|!
name|memcmp
argument_list|(
name|tgtfix
operator|.
name|buf
argument_list|,
name|fixed
operator|.
name|buf
operator|+
name|fixstart
argument_list|,
name|fixed
operator|.
name|len
operator|-
name|fixstart
argument_list|)
operator|)
expr_stmt|;
name|postlen
operator|+=
name|tgtfix
operator|.
name|len
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|tgtfix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
goto|goto
name|unmatch_exit
goto|;
name|orig
operator|+=
name|oldlen
expr_stmt|;
name|target
operator|+=
name|tgtlen
expr_stmt|;
block|}
comment|/* 	 * Now handle the lines in the preimage that falls beyond the 	 * end of the file (if any). They will only match if they are 	 * empty or only contain whitespace (if WS_BLANK_AT_EOL is 	 * false). 	 */
for|for
control|(
init|;
name|i
operator|<
name|preimage
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|fixstart
init|=
name|fixed
operator|.
name|len
decl_stmt|;
comment|/* start of the fixed preimage */
name|size_t
name|oldlen
init|=
name|preimage
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Try fixing the line in the preimage */
name|ws_fix_copy
argument_list|(
operator|&
name|fixed
argument_list|,
name|orig
argument_list|,
name|oldlen
argument_list|,
name|ws_rule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|fixstart
init|;
name|j
operator|<
name|fixed
operator|.
name|len
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|fixed
operator|.
name|buf
index|[
name|j
index|]
argument_list|)
condition|)
goto|goto
name|unmatch_exit
goto|;
name|orig
operator|+=
name|oldlen
expr_stmt|;
block|}
comment|/* 	 * Yes, the preimage is based on an older version that still 	 * has whitespace breakages unfixed, and fixing them makes the 	 * hunk match.  Update the context lines in the postimage. 	 */
name|fixed_buf
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|fixed
argument_list|,
operator|&
name|fixed_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|postlen
operator|<
name|postimage
operator|->
name|len
condition|)
name|postlen
operator|=
literal|0
expr_stmt|;
name|update_pre_post_images
argument_list|(
name|preimage
argument_list|,
name|postimage
argument_list|,
name|fixed_buf
argument_list|,
name|fixed_len
argument_list|,
name|postlen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|unmatch_exit
label|:
name|strbuf_release
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_pos
specifier|static
name|int
name|find_pos
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
name|struct
name|image
modifier|*
name|preimage
parameter_list|,
name|struct
name|image
modifier|*
name|postimage
parameter_list|,
name|int
name|line
parameter_list|,
name|unsigned
name|ws_rule
parameter_list|,
name|int
name|match_beginning
parameter_list|,
name|int
name|match_end
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|backwards
decl_stmt|,
name|forwards
decl_stmt|,
name|try
decl_stmt|;
name|int
name|backwards_lno
decl_stmt|,
name|forwards_lno
decl_stmt|,
name|try_lno
decl_stmt|;
comment|/* 	 * If match_beginning or match_end is specified, there is no 	 * point starting from a wrong line that will never match and 	 * wander around and wait for a match at the specified end. 	 */
if|if
condition|(
name|match_beginning
condition|)
name|line
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|match_end
condition|)
name|line
operator|=
name|img
operator|->
name|nr
operator|-
name|preimage
operator|->
name|nr
expr_stmt|;
comment|/* 	 * Because the comparison is unsigned, the following test 	 * will also take care of a negative line number that can 	 * result when match_end and preimage is larger than the target. 	 */
if|if
condition|(
operator|(
name|size_t
operator|)
name|line
operator|>
name|img
operator|->
name|nr
condition|)
name|line
operator|=
name|img
operator|->
name|nr
expr_stmt|;
name|try
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|line
condition|;
name|i
operator|++
control|)
name|try
operator|+=
name|img
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
comment|/* 	 * There's probably some smart way to do this, but I'll leave 	 * that to the smart and beautiful people. I'm simple and stupid. 	 */
name|backwards
operator|=
name|try
expr_stmt|;
name|backwards_lno
operator|=
name|line
expr_stmt|;
name|forwards
operator|=
name|try
expr_stmt|;
name|forwards_lno
operator|=
name|line
expr_stmt|;
name|try_lno
operator|=
name|line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|match_fragment
argument_list|(
name|img
argument_list|,
name|preimage
argument_list|,
name|postimage
argument_list|,
name|try
argument_list|,
name|try_lno
argument_list|,
name|ws_rule
argument_list|,
name|match_beginning
argument_list|,
name|match_end
argument_list|)
condition|)
return|return
name|try_lno
return|;
name|again
label|:
if|if
condition|(
name|backwards_lno
operator|==
literal|0
operator|&&
name|forwards_lno
operator|==
name|img
operator|->
name|nr
condition|)
break|break;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|backwards_lno
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|backwards_lno
operator|--
expr_stmt|;
name|backwards
operator|-=
name|img
operator|->
name|line
index|[
name|backwards_lno
index|]
operator|.
name|len
expr_stmt|;
name|try
operator|=
name|backwards
expr_stmt|;
name|try_lno
operator|=
name|backwards_lno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|forwards_lno
operator|==
name|img
operator|->
name|nr
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|forwards
operator|+=
name|img
operator|->
name|line
index|[
name|forwards_lno
index|]
operator|.
name|len
expr_stmt|;
name|forwards_lno
operator|++
expr_stmt|;
name|try
operator|=
name|forwards
expr_stmt|;
name|try_lno
operator|=
name|forwards_lno
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|remove_first_line
specifier|static
name|void
name|remove_first_line
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|)
block|{
name|img
operator|->
name|buf
operator|+=
name|img
operator|->
name|line
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|img
operator|->
name|len
operator|-=
name|img
operator|->
name|line
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|img
operator|->
name|line
operator|++
expr_stmt|;
name|img
operator|->
name|nr
operator|--
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove_last_line
specifier|static
name|void
name|remove_last_line
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|)
block|{
name|img
operator|->
name|len
operator|-=
name|img
operator|->
name|line
index|[
operator|--
name|img
operator|->
name|nr
index|]
operator|.
name|len
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * The change from "preimage" and "postimage" has been found to  * apply at applied_pos (counts in line numbers) in "img".  * Update "img" to remove "preimage" and replace it with "postimage".  */
end_comment
begin_function
DECL|function|update_image
specifier|static
name|void
name|update_image
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
name|int
name|applied_pos
parameter_list|,
name|struct
name|image
modifier|*
name|preimage
parameter_list|,
name|struct
name|image
modifier|*
name|postimage
parameter_list|)
block|{
comment|/* 	 * remove the copy of preimage at offset in img 	 * and replace it with postimage 	 */
name|int
name|i
decl_stmt|,
name|nr
decl_stmt|;
name|size_t
name|remove_count
decl_stmt|,
name|insert_count
decl_stmt|,
name|applied_at
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|preimage_limit
decl_stmt|;
comment|/* 	 * If we are removing blank lines at the end of img, 	 * the preimage may extend beyond the end. 	 * If that is the case, we must be careful only to 	 * remove the part of the preimage that falls within 	 * the boundaries of img. Initialize preimage_limit 	 * to the number of lines in the preimage that falls 	 * within the boundaries. 	 */
name|preimage_limit
operator|=
name|preimage
operator|->
name|nr
expr_stmt|;
if|if
condition|(
name|preimage_limit
operator|>
name|img
operator|->
name|nr
operator|-
name|applied_pos
condition|)
name|preimage_limit
operator|=
name|img
operator|->
name|nr
operator|-
name|applied_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|applied_pos
condition|;
name|i
operator|++
control|)
name|applied_at
operator|+=
name|img
operator|->
name|line
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|remove_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preimage_limit
condition|;
name|i
operator|++
control|)
name|remove_count
operator|+=
name|img
operator|->
name|line
index|[
name|applied_pos
operator|+
name|i
index|]
operator|.
name|len
expr_stmt|;
name|insert_count
operator|=
name|postimage
operator|->
name|len
expr_stmt|;
comment|/* Adjust the contents */
name|result
operator|=
name|xmalloc
argument_list|(
name|img
operator|->
name|len
operator|+
name|insert_count
operator|-
name|remove_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|img
operator|->
name|buf
argument_list|,
name|applied_at
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|+
name|applied_at
argument_list|,
name|postimage
operator|->
name|buf
argument_list|,
name|postimage
operator|->
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|+
name|applied_at
operator|+
name|postimage
operator|->
name|len
argument_list|,
name|img
operator|->
name|buf
operator|+
operator|(
name|applied_at
operator|+
name|remove_count
operator|)
argument_list|,
name|img
operator|->
name|len
operator|-
operator|(
name|applied_at
operator|+
name|remove_count
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|img
operator|->
name|buf
argument_list|)
expr_stmt|;
name|img
operator|->
name|buf
operator|=
name|result
expr_stmt|;
name|img
operator|->
name|len
operator|+=
name|insert_count
operator|-
name|remove_count
expr_stmt|;
name|result
index|[
name|img
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Adjust the line table */
name|nr
operator|=
name|img
operator|->
name|nr
operator|+
name|postimage
operator|->
name|nr
operator|-
name|preimage_limit
expr_stmt|;
if|if
condition|(
name|preimage_limit
operator|<
name|postimage
operator|->
name|nr
condition|)
block|{
comment|/* 		 * NOTE: this knows that we never call remove_first_line() 		 * on anything other than pre/post image. 		 */
name|img
operator|->
name|line
operator|=
name|xrealloc
argument_list|(
name|img
operator|->
name|line
argument_list|,
name|nr
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|img
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|img
operator|->
name|line_allocated
operator|=
name|img
operator|->
name|line
expr_stmt|;
block|}
if|if
condition|(
name|preimage_limit
operator|!=
name|postimage
operator|->
name|nr
condition|)
name|memmove
argument_list|(
name|img
operator|->
name|line
operator|+
name|applied_pos
operator|+
name|postimage
operator|->
name|nr
argument_list|,
name|img
operator|->
name|line
operator|+
name|applied_pos
operator|+
name|preimage_limit
argument_list|,
operator|(
name|img
operator|->
name|nr
operator|-
operator|(
name|applied_pos
operator|+
name|preimage_limit
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|img
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|img
operator|->
name|line
operator|+
name|applied_pos
argument_list|,
name|postimage
operator|->
name|line
argument_list|,
name|postimage
operator|->
name|nr
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|img
operator|->
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allow_overlap
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|postimage
operator|->
name|nr
condition|;
name|i
operator|++
control|)
name|img
operator|->
name|line
index|[
name|applied_pos
operator|+
name|i
index|]
operator|.
name|flag
operator||=
name|LINE_PATCHED
expr_stmt|;
name|img
operator|->
name|nr
operator|=
name|nr
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Use the patch-hunk text in "frag" to prepare two images (preimage and  * postimage) for the hunk.  Find lines that match "preimage" in "img" and  * replace the part of "img" with "postimage" text.  */
end_comment
begin_function
DECL|function|apply_one_fragment
specifier|static
name|int
name|apply_one_fragment
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
name|struct
name|fragment
modifier|*
name|frag
parameter_list|,
name|int
name|inaccurate_eof
parameter_list|,
name|unsigned
name|ws_rule
parameter_list|,
name|int
name|nth_fragment
parameter_list|)
block|{
name|int
name|match_beginning
decl_stmt|,
name|match_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|patch
init|=
name|frag
operator|->
name|patch
decl_stmt|;
name|int
name|size
init|=
name|frag
operator|->
name|size
decl_stmt|;
name|char
modifier|*
name|old
decl_stmt|,
modifier|*
name|oldlines
decl_stmt|;
name|struct
name|strbuf
name|newlines
decl_stmt|;
name|int
name|new_blank_lines_at_end
init|=
literal|0
decl_stmt|;
name|int
name|found_new_blank_lines_at_end
init|=
literal|0
decl_stmt|;
name|int
name|hunk_linenr
init|=
name|frag
operator|->
name|linenr
decl_stmt|;
name|unsigned
name|long
name|leading
decl_stmt|,
name|trailing
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|applied_pos
decl_stmt|;
name|struct
name|image
name|preimage
decl_stmt|;
name|struct
name|image
name|postimage
decl_stmt|;
name|memset
argument_list|(
operator|&
name|preimage
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|preimage
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|postimage
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|postimage
argument_list|)
argument_list|)
expr_stmt|;
name|oldlines
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|newlines
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|old
operator|=
name|oldlines
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|char
name|first
decl_stmt|;
name|int
name|len
init|=
name|linelen
argument_list|(
name|patch
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|int
name|added_blank_line
init|=
literal|0
decl_stmt|;
name|int
name|is_blank_context
init|=
literal|0
decl_stmt|;
name|size_t
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
break|break;
comment|/* 		 * "plen" is how much of the line we should use for 		 * the actual patch data. Normally we just remove the 		 * first character on the line, but if the line is 		 * followed by "\ No newline", then we also remove the 		 * last one (which is the newline, of course). 		 */
name|plen
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|size
operator|&&
name|patch
index|[
name|len
index|]
operator|==
literal|'\\'
condition|)
name|plen
operator|--
expr_stmt|;
name|first
operator|=
operator|*
name|patch
expr_stmt|;
if|if
condition|(
name|apply_in_reverse
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|'-'
condition|)
name|first
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|first
operator|==
literal|'+'
condition|)
name|first
operator|=
literal|'-'
expr_stmt|;
block|}
switch|switch
condition|(
name|first
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Newer GNU diff, empty context line */
if|if
condition|(
name|plen
operator|<
literal|0
condition|)
comment|/* ... followed by '\No newline'; nothing */
break|break;
operator|*
name|old
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|newlines
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|add_line_info
argument_list|(
operator|&
name|preimage
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
name|LINE_COMMON
argument_list|)
expr_stmt|;
name|add_line_info
argument_list|(
operator|&
name|postimage
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
name|LINE_COMMON
argument_list|)
expr_stmt|;
name|is_blank_context
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|' '
case|:
if|if
condition|(
name|plen
operator|&&
operator|(
name|ws_rule
operator|&
name|WS_BLANK_AT_EOF
operator|)
operator|&&
name|ws_blank_line
argument_list|(
name|patch
operator|+
literal|1
argument_list|,
name|plen
argument_list|,
name|ws_rule
argument_list|)
condition|)
name|is_blank_context
operator|=
literal|1
expr_stmt|;
case|case
literal|'-'
case|:
name|memcpy
argument_list|(
name|old
argument_list|,
name|patch
operator|+
literal|1
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|add_line_info
argument_list|(
operator|&
name|preimage
argument_list|,
name|old
argument_list|,
name|plen
argument_list|,
operator|(
name|first
operator|==
literal|' '
condition|?
name|LINE_COMMON
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|old
operator|+=
name|plen
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|'-'
condition|)
break|break;
comment|/* Fall-through for ' ' */
case|case
literal|'+'
case|:
comment|/* --no-add does not add new lines */
if|if
condition|(
name|first
operator|==
literal|'+'
operator|&&
name|no_add
condition|)
break|break;
name|start
operator|=
name|newlines
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|first
operator|!=
literal|'+'
operator|||
operator|!
name|whitespace_error
operator|||
name|ws_error_action
operator|!=
name|correct_ws_error
condition|)
block|{
name|strbuf_add
argument_list|(
operator|&
name|newlines
argument_list|,
name|patch
operator|+
literal|1
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ws_fix_copy
argument_list|(
operator|&
name|newlines
argument_list|,
name|patch
operator|+
literal|1
argument_list|,
name|plen
argument_list|,
name|ws_rule
argument_list|,
operator|&
name|applied_after_fixing_ws
argument_list|)
expr_stmt|;
block|}
name|add_line_info
argument_list|(
operator|&
name|postimage
argument_list|,
name|newlines
operator|.
name|buf
operator|+
name|start
argument_list|,
name|newlines
operator|.
name|len
operator|-
name|start
argument_list|,
operator|(
name|first
operator|==
literal|'+'
condition|?
literal|0
else|:
name|LINE_COMMON
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|'+'
operator|&&
operator|(
name|ws_rule
operator|&
name|WS_BLANK_AT_EOF
operator|)
operator|&&
name|ws_blank_line
argument_list|(
name|patch
operator|+
literal|1
argument_list|,
name|plen
argument_list|,
name|ws_rule
argument_list|)
condition|)
name|added_blank_line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
case|case
literal|'\\'
case|:
comment|/* Ignore it, we already handled it */
break|break;
default|default:
if|if
condition|(
name|apply_verbosely
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid start of line: '%c'"
argument_list|)
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|added_blank_line
condition|)
block|{
if|if
condition|(
operator|!
name|new_blank_lines_at_end
condition|)
name|found_new_blank_lines_at_end
operator|=
name|hunk_linenr
expr_stmt|;
name|new_blank_lines_at_end
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_blank_context
condition|)
empty_stmt|;
else|else
name|new_blank_lines_at_end
operator|=
literal|0
expr_stmt|;
name|patch
operator|+=
name|len
expr_stmt|;
name|size
operator|-=
name|len
expr_stmt|;
name|hunk_linenr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|inaccurate_eof
operator|&&
name|old
operator|>
name|oldlines
operator|&&
name|old
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|newlines
operator|.
name|len
operator|>
literal|0
operator|&&
name|newlines
operator|.
name|buf
index|[
name|newlines
operator|.
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|old
operator|--
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|newlines
argument_list|,
name|newlines
operator|.
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|leading
operator|=
name|frag
operator|->
name|leading
expr_stmt|;
name|trailing
operator|=
name|frag
operator|->
name|trailing
expr_stmt|;
comment|/* 	 * A hunk to change lines at the beginning would begin with 	 * @@ -1,L +N,M @@ 	 * but we need to be careful.  -U0 that inserts before the second 	 * line also has this pattern. 	 * 	 * And a hunk to add to an empty file would begin with 	 * @@ -0,0 +N,M @@ 	 * 	 * In other words, a hunk that is (frag->oldpos<= 1) with or 	 * without leading context must match at the beginning. 	 */
name|match_beginning
operator|=
operator|(
operator|!
name|frag
operator|->
name|oldpos
operator|||
operator|(
name|frag
operator|->
name|oldpos
operator|==
literal|1
operator|&&
operator|!
name|unidiff_zero
operator|)
operator|)
expr_stmt|;
comment|/* 	 * A hunk without trailing lines must match at the end. 	 * However, we simply cannot tell if a hunk must match end 	 * from the lack of trailing lines if the patch was generated 	 * with unidiff without any context. 	 */
name|match_end
operator|=
operator|!
name|unidiff_zero
operator|&&
operator|!
name|trailing
expr_stmt|;
name|pos
operator|=
name|frag
operator|->
name|newpos
condition|?
operator|(
name|frag
operator|->
name|newpos
operator|-
literal|1
operator|)
else|:
literal|0
expr_stmt|;
name|preimage
operator|.
name|buf
operator|=
name|oldlines
expr_stmt|;
name|preimage
operator|.
name|len
operator|=
name|old
operator|-
name|oldlines
expr_stmt|;
name|postimage
operator|.
name|buf
operator|=
name|newlines
operator|.
name|buf
expr_stmt|;
name|postimage
operator|.
name|len
operator|=
name|newlines
operator|.
name|len
expr_stmt|;
name|preimage
operator|.
name|line
operator|=
name|preimage
operator|.
name|line_allocated
expr_stmt|;
name|postimage
operator|.
name|line
operator|=
name|postimage
operator|.
name|line_allocated
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|applied_pos
operator|=
name|find_pos
argument_list|(
name|img
argument_list|,
operator|&
name|preimage
argument_list|,
operator|&
name|postimage
argument_list|,
name|pos
argument_list|,
name|ws_rule
argument_list|,
name|match_beginning
argument_list|,
name|match_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|applied_pos
operator|>=
literal|0
condition|)
break|break;
comment|/* Am I at my context limits? */
if|if
condition|(
operator|(
name|leading
operator|<=
name|p_context
operator|)
operator|&&
operator|(
name|trailing
operator|<=
name|p_context
operator|)
condition|)
break|break;
if|if
condition|(
name|match_beginning
operator|||
name|match_end
condition|)
block|{
name|match_beginning
operator|=
name|match_end
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Reduce the number of context lines; reduce both 		 * leading and trailing if they are equal otherwise 		 * just reduce the larger context. 		 */
if|if
condition|(
name|leading
operator|>=
name|trailing
condition|)
block|{
name|remove_first_line
argument_list|(
operator|&
name|preimage
argument_list|)
expr_stmt|;
name|remove_first_line
argument_list|(
operator|&
name|postimage
argument_list|)
expr_stmt|;
name|pos
operator|--
expr_stmt|;
name|leading
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|trailing
operator|>
name|leading
condition|)
block|{
name|remove_last_line
argument_list|(
operator|&
name|preimage
argument_list|)
expr_stmt|;
name|remove_last_line
argument_list|(
operator|&
name|postimage
argument_list|)
expr_stmt|;
name|trailing
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|applied_pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|new_blank_lines_at_end
operator|&&
name|preimage
operator|.
name|nr
operator|+
name|applied_pos
operator|>=
name|img
operator|->
name|nr
operator|&&
operator|(
name|ws_rule
operator|&
name|WS_BLANK_AT_EOF
operator|)
operator|&&
name|ws_error_action
operator|!=
name|nowarn_ws_error
condition|)
block|{
name|record_ws_error
argument_list|(
name|WS_BLANK_AT_EOF
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|,
name|found_new_blank_lines_at_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws_error_action
operator|==
name|correct_ws_error
condition|)
block|{
while|while
condition|(
name|new_blank_lines_at_end
operator|--
condition|)
name|remove_last_line
argument_list|(
operator|&
name|postimage
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We would want to prevent write_out_results() 			 * from taking place in apply_patch() that follows 			 * the callchain led us here, which is: 			 * apply_patch->check_patch_list->check_patch-> 			 * apply_data->apply_fragments->apply_one_fragment 			 */
if|if
condition|(
name|ws_error_action
operator|==
name|die_on_ws_error
condition|)
name|apply
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|apply_verbosely
operator|&&
name|applied_pos
operator|!=
name|pos
condition|)
block|{
name|int
name|offset
init|=
name|applied_pos
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|apply_in_reverse
condition|)
name|offset
operator|=
literal|0
operator|-
name|offset
expr_stmt|;
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|Q_
argument_list|(
literal|"Hunk #%d succeeded at %d (offset %d line)."
argument_list|,
literal|"Hunk #%d succeeded at %d (offset %d lines)."
argument_list|,
name|offset
argument_list|)
argument_list|,
name|nth_fragment
argument_list|,
name|applied_pos
operator|+
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Warn if it was necessary to reduce the number 		 * of context lines. 		 */
if|if
condition|(
operator|(
name|leading
operator|!=
name|frag
operator|->
name|leading
operator|)
operator|||
operator|(
name|trailing
operator|!=
name|frag
operator|->
name|trailing
operator|)
condition|)
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Context reduced to (%ld/%ld)"
literal|" to apply fragment at %d"
argument_list|)
argument_list|,
name|leading
argument_list|,
name|trailing
argument_list|,
name|applied_pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|update_image
argument_list|(
name|img
argument_list|,
name|applied_pos
argument_list|,
operator|&
name|preimage
argument_list|,
operator|&
name|postimage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|apply_verbosely
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"while searching for:\n%.*s"
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|old
operator|-
name|oldlines
argument_list|)
argument_list|,
name|oldlines
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|oldlines
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|newlines
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preimage
operator|.
name|line_allocated
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|postimage
operator|.
name|line_allocated
argument_list|)
expr_stmt|;
return|return
operator|(
name|applied_pos
operator|<
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|apply_binary_fragment
specifier|static
name|int
name|apply_binary_fragment
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|fragment
modifier|*
name|fragment
init|=
name|patch
operator|->
name|fragments
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|void
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
operator|!
name|fragment
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"missing binary patch data for '%s'"
argument_list|)
argument_list|,
name|patch
operator|->
name|new_name
condition|?
name|patch
operator|->
name|new_name
else|:
name|patch
operator|->
name|old_name
argument_list|)
return|;
comment|/* Binary patch is irreversible without the optional second hunk */
if|if
condition|(
name|apply_in_reverse
condition|)
block|{
if|if
condition|(
operator|!
name|fragment
operator|->
name|next
condition|)
return|return
name|error
argument_list|(
literal|"cannot reverse-apply a binary patch "
literal|"without the reverse hunk to '%s'"
argument_list|,
name|patch
operator|->
name|new_name
condition|?
name|patch
operator|->
name|new_name
else|:
name|patch
operator|->
name|old_name
argument_list|)
return|;
name|fragment
operator|=
name|fragment
operator|->
name|next
expr_stmt|;
block|}
switch|switch
condition|(
name|fragment
operator|->
name|binary_patch_method
condition|)
block|{
case|case
name|BINARY_DELTA_DEFLATED
case|:
name|dst
operator|=
name|patch_delta
argument_list|(
name|img
operator|->
name|buf
argument_list|,
name|img
operator|->
name|len
argument_list|,
name|fragment
operator|->
name|patch
argument_list|,
name|fragment
operator|->
name|size
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
condition|)
return|return
operator|-
literal|1
return|;
name|clear_image
argument_list|(
name|img
argument_list|)
expr_stmt|;
name|img
operator|->
name|buf
operator|=
name|dst
expr_stmt|;
name|img
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BINARY_LITERAL_DEFLATED
case|:
name|clear_image
argument_list|(
name|img
argument_list|)
expr_stmt|;
name|img
operator|->
name|len
operator|=
name|fragment
operator|->
name|size
expr_stmt|;
name|img
operator|->
name|buf
operator|=
name|xmalloc
argument_list|(
name|img
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|img
operator|->
name|buf
argument_list|,
name|fragment
operator|->
name|patch
argument_list|,
name|img
operator|->
name|len
argument_list|)
expr_stmt|;
name|img
operator|->
name|buf
index|[
name|img
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Replace "img" with the result of applying the binary patch.  * The binary patch data itself in patch->fragment is still kept  * but the preimage prepared by the caller in "img" is freed here  * or in the helper function apply_binary_fragment() this calls.  */
end_comment
begin_function
DECL|function|apply_binary
specifier|static
name|int
name|apply_binary
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|patch
operator|->
name|old_name
condition|?
name|patch
operator|->
name|old_name
else|:
name|patch
operator|->
name|new_name
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * For safety, we require patch index line to contain 	 * full 40-byte textual SHA1 for old and new, at least for now. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|patch
operator|->
name|old_sha1_prefix
argument_list|)
operator|!=
literal|40
operator|||
name|strlen
argument_list|(
name|patch
operator|->
name|new_sha1_prefix
argument_list|)
operator|!=
literal|40
operator|||
name|get_sha1_hex
argument_list|(
name|patch
operator|->
name|old_sha1_prefix
argument_list|,
name|sha1
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
name|patch
operator|->
name|new_sha1_prefix
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"cannot apply binary patch to '%s' "
literal|"without full index line"
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|patch
operator|->
name|old_name
condition|)
block|{
comment|/* 		 * See if the old one matches what the patch 		 * applies to. 		 */
name|hash_sha1_file
argument_list|(
name|img
operator|->
name|buf
argument_list|,
name|img
operator|->
name|len
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|patch
operator|->
name|old_sha1_prefix
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"the patch applies to '%s' (%s), "
literal|"which does not match the "
literal|"current contents."
argument_list|,
name|name
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Otherwise, the old one must be empty. */
if|if
condition|(
name|img
operator|->
name|len
condition|)
return|return
name|error
argument_list|(
literal|"the patch applies to an empty "
literal|"'%s' but it is not empty"
argument_list|,
name|name
argument_list|)
return|;
block|}
name|get_sha1_hex
argument_list|(
name|patch
operator|->
name|new_sha1_prefix
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
condition|)
block|{
name|clear_image
argument_list|(
name|img
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* deletion patch */
block|}
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
condition|)
block|{
comment|/* We already have the postimage */
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|error
argument_list|(
literal|"the necessary postimage %s for "
literal|"'%s' cannot be read"
argument_list|,
name|patch
operator|->
name|new_sha1_prefix
argument_list|,
name|name
argument_list|)
return|;
name|clear_image
argument_list|(
name|img
argument_list|)
expr_stmt|;
name|img
operator|->
name|buf
operator|=
name|result
expr_stmt|;
name|img
operator|->
name|len
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We have verified buf matches the preimage; 		 * apply the patch data to it, which is stored 		 * in the patch->fragments->{patch,size}. 		 */
if|if
condition|(
name|apply_binary_fragment
argument_list|(
name|img
argument_list|,
name|patch
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"binary patch does not apply to '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* verify that the result matches */
name|hash_sha1_file
argument_list|(
name|img
operator|->
name|buf
argument_list|,
name|img
operator|->
name|len
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|patch
operator|->
name|new_sha1_prefix
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"binary patch to '%s' creates incorrect result (expecting %s, got %s)"
argument_list|)
argument_list|,
name|name
argument_list|,
name|patch
operator|->
name|new_sha1_prefix
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|apply_fragments
specifier|static
name|int
name|apply_fragments
parameter_list|(
name|struct
name|image
modifier|*
name|img
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|fragment
modifier|*
name|frag
init|=
name|patch
operator|->
name|fragments
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|patch
operator|->
name|old_name
condition|?
name|patch
operator|->
name|old_name
else|:
name|patch
operator|->
name|new_name
decl_stmt|;
name|unsigned
name|ws_rule
init|=
name|patch
operator|->
name|ws_rule
decl_stmt|;
name|unsigned
name|inaccurate_eof
init|=
name|patch
operator|->
name|inaccurate_eof
decl_stmt|;
name|int
name|nth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|patch
operator|->
name|is_binary
condition|)
return|return
name|apply_binary
argument_list|(
name|img
argument_list|,
name|patch
argument_list|)
return|;
while|while
condition|(
name|frag
condition|)
block|{
name|nth
operator|++
expr_stmt|;
if|if
condition|(
name|apply_one_fragment
argument_list|(
name|img
argument_list|,
name|frag
argument_list|,
name|inaccurate_eof
argument_list|,
name|ws_rule
argument_list|,
name|nth
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"patch failed: %s:%ld"
argument_list|)
argument_list|,
name|name
argument_list|,
name|frag
operator|->
name|oldpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_with_reject
condition|)
return|return
operator|-
literal|1
return|;
name|frag
operator|->
name|rejected
operator|=
literal|1
expr_stmt|;
block|}
name|frag
operator|=
name|frag
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_blob_object
specifier|static
name|int
name|read_blob_object
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|mode
parameter_list|)
block|{
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|strbuf_grow
argument_list|(
name|buf
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|buf
argument_list|,
literal|"Subproject commit %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
operator|-
literal|1
return|;
comment|/* XXX read_sha1_file NUL-terminates */
name|strbuf_attach
argument_list|(
name|buf
argument_list|,
name|result
argument_list|,
name|sz
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_file_or_gitlink
specifier|static
name|int
name|read_file_or_gitlink
parameter_list|(
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ce
condition|)
return|return
literal|0
return|;
return|return
name|read_blob_object
argument_list|(
name|buf
argument_list|,
name|ce
operator|->
name|sha1
argument_list|,
name|ce
operator|->
name|ce_mode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|in_fn_table
specifier|static
name|struct
name|patch
modifier|*
name|in_fn_table
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|item
operator|=
name|string_list_lookup
argument_list|(
operator|&
name|fn_table
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
return|return
operator|(
expr|struct
name|patch
operator|*
operator|)
name|item
operator|->
name|util
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * item->util in the filename table records the status of the path.  * Usually it points at a patch (whose result records the contents  * of it after applying it), but it could be PATH_WAS_DELETED for a  * path that a previously applied patch has already removed, or  * PATH_TO_BE_DELETED for a path that a later patch would remove.  *  * The latter is needed to deal with a case where two paths A and B  * are swapped by first renaming A to B and then renaming B to A;  * moving A to B should not be prevented due to presence of B as we  * will remove it in a later patch.  */
end_comment
begin_define
DECL|macro|PATH_TO_BE_DELETED
define|#
directive|define
name|PATH_TO_BE_DELETED
value|((struct patch *) -2)
end_define
begin_define
DECL|macro|PATH_WAS_DELETED
define|#
directive|define
name|PATH_WAS_DELETED
value|((struct patch *) -1)
end_define
begin_function
DECL|function|to_be_deleted
specifier|static
name|int
name|to_be_deleted
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
return|return
name|patch
operator|==
name|PATH_TO_BE_DELETED
return|;
block|}
end_function
begin_function
DECL|function|was_deleted
specifier|static
name|int
name|was_deleted
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
return|return
name|patch
operator|==
name|PATH_WAS_DELETED
return|;
block|}
end_function
begin_function
DECL|function|add_to_fn_table
specifier|static
name|void
name|add_to_fn_table
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
comment|/* 	 * Always add new_name unless patch is a deletion 	 * This should cover the cases for normal diffs, 	 * file creations and copies 	 */
if|if
condition|(
name|patch
operator|->
name|new_name
operator|!=
name|NULL
condition|)
block|{
name|item
operator|=
name|string_list_insert
argument_list|(
operator|&
name|fn_table
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|patch
expr_stmt|;
block|}
comment|/* 	 * store a failure on rename/deletion cases because 	 * later chunks shouldn't patch old names 	 */
if|if
condition|(
operator|(
name|patch
operator|->
name|new_name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|patch
operator|->
name|is_rename
operator|)
condition|)
block|{
name|item
operator|=
name|string_list_insert
argument_list|(
operator|&
name|fn_table
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|PATH_WAS_DELETED
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|prepare_fn_table
specifier|static
name|void
name|prepare_fn_table
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
comment|/* 	 * store information about incoming file deletion 	 */
while|while
condition|(
name|patch
condition|)
block|{
if|if
condition|(
operator|(
name|patch
operator|->
name|new_name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|patch
operator|->
name|is_rename
operator|)
condition|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|string_list_insert
argument_list|(
operator|&
name|fn_table
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|PATH_TO_BE_DELETED
expr_stmt|;
block|}
name|patch
operator|=
name|patch
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|checkout_target
specifier|static
name|int
name|checkout_target
parameter_list|(
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|checkout
name|costate
decl_stmt|;
name|memset
argument_list|(
operator|&
name|costate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|costate
argument_list|)
argument_list|)
expr_stmt|;
name|costate
operator|.
name|base_dir
operator|=
literal|""
expr_stmt|;
name|costate
operator|.
name|refresh_cache
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|checkout_entry
argument_list|(
name|ce
argument_list|,
operator|&
name|costate
argument_list|,
name|NULL
argument_list|)
operator|||
name|lstat
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|st
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot checkout %s"
argument_list|)
argument_list|,
name|ce
operator|->
name|name
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|previous_patch
specifier|static
name|struct
name|patch
modifier|*
name|previous_patch
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|int
modifier|*
name|gone
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|previous
decl_stmt|;
operator|*
name|gone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|is_copy
operator|||
name|patch
operator|->
name|is_rename
condition|)
return|return
name|NULL
return|;
comment|/* "git" patches do not depend on the order */
name|previous
operator|=
name|in_fn_table
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|previous
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|to_be_deleted
argument_list|(
name|previous
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* the deletion hasn't happened yet */
if|if
condition|(
name|was_deleted
argument_list|(
name|previous
argument_list|)
condition|)
operator|*
name|gone
operator|=
literal|1
expr_stmt|;
return|return
name|previous
return|;
block|}
end_function
begin_function
DECL|function|verify_index_match
specifier|static
name|int
name|verify_index_match
parameter_list|(
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
name|ce_match_stat
argument_list|(
name|ce
argument_list|,
name|st
argument_list|,
name|CE_MATCH_IGNORE_VALID
operator||
name|CE_MATCH_IGNORE_SKIP_WORKTREE
argument_list|)
return|;
block|}
end_function
begin_define
DECL|macro|SUBMODULE_PATCH_WITHOUT_INDEX
define|#
directive|define
name|SUBMODULE_PATCH_WITHOUT_INDEX
value|1
end_define
begin_function
DECL|function|load_patch_target
specifier|static
name|int
name|load_patch_target
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|expected_mode
parameter_list|)
block|{
if|if
condition|(
name|cached
condition|)
block|{
if|if
condition|(
name|read_file_or_gitlink
argument_list|(
name|ce
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"read of %s failed"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|expected_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|ce
condition|)
return|return
name|read_file_or_gitlink
argument_list|(
name|ce
argument_list|,
name|buf
argument_list|)
return|;
else|else
return|return
name|SUBMODULE_PATCH_WITHOUT_INDEX
return|;
block|}
else|else
block|{
if|if
condition|(
name|read_old_data
argument_list|(
name|st
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"read of %s failed"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * We are about to apply "patch"; populate the "image" with the  * current version we have, from the working tree or from the index,  * depending on the situation e.g. --cached/--index.  If we are  * applying a non-git patch that incrementally updates the tree,  * we read from the result of a previous diff.  */
end_comment
begin_function
DECL|function|load_preimage
specifier|static
name|int
name|load_preimage
parameter_list|(
name|struct
name|image
modifier|*
name|image
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|img
decl_stmt|;
name|struct
name|patch
modifier|*
name|previous
decl_stmt|;
name|int
name|status
decl_stmt|;
name|previous
operator|=
name|previous_patch
argument_list|(
name|patch
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path %s has been renamed/deleted"
argument_list|)
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
return|;
if|if
condition|(
name|previous
condition|)
block|{
comment|/* We have a patched copy in memory; use that. */
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|previous
operator|->
name|result
argument_list|,
name|previous
operator|->
name|resultsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|load_patch_target
argument_list|(
operator|&
name|buf
argument_list|,
name|ce
argument_list|,
name|st
argument_list|,
name|patch
operator|->
name|old_name
argument_list|,
name|patch
operator|->
name|old_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
elseif|else
if|if
condition|(
name|status
operator|==
name|SUBMODULE_PATCH_WITHOUT_INDEX
condition|)
block|{
comment|/* 			 * There is no way to apply subproject 			 * patch without looking at the index. 			 * NEEDSWORK: shouldn't this be flagged 			 * as an error??? 			 */
name|free_fragment_list
argument_list|(
name|patch
operator|->
name|fragments
argument_list|)
expr_stmt|;
name|patch
operator|->
name|fragments
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
condition|)
block|{
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"read of %s failed"
argument_list|)
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
return|;
block|}
block|}
name|img
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|prepare_image
argument_list|(
name|image
argument_list|,
name|img
argument_list|,
name|len
argument_list|,
operator|!
name|patch
operator|->
name|is_binary
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|three_way_merge
specifier|static
name|int
name|three_way_merge
parameter_list|(
name|struct
name|image
modifier|*
name|image
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ours
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|theirs
parameter_list|)
block|{
name|mmfile_t
name|base_file
decl_stmt|,
name|our_file
decl_stmt|,
name|their_file
decl_stmt|;
name|mmbuffer_t
name|result
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|status
decl_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|base_file
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|our_file
argument_list|,
name|ours
argument_list|)
expr_stmt|;
name|read_mmblob
argument_list|(
operator|&
name|their_file
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
name|status
operator|=
name|ll_merge
argument_list|(
operator|&
name|result
argument_list|,
name|path
argument_list|,
operator|&
name|base_file
argument_list|,
literal|"base"
argument_list|,
operator|&
name|our_file
argument_list|,
literal|"ours"
argument_list|,
operator|&
name|their_file
argument_list|,
literal|"theirs"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base_file
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|our_file
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|their_file
operator|.
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
operator|||
operator|!
name|result
operator|.
name|ptr
condition|)
block|{
name|free
argument_list|(
name|result
operator|.
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|clear_image
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|->
name|buf
operator|=
name|result
operator|.
name|ptr
expr_stmt|;
name|image
operator|->
name|len
operator|=
name|result
operator|.
name|size
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_comment
comment|/*  * When directly falling back to add/add three-way merge, we read from  * the current contents of the new_name.  In no cases other than that  * this function will be called.  */
end_comment
begin_function
DECL|function|load_current
specifier|static
name|int
name|load_current
parameter_list|(
name|struct
name|image
modifier|*
name|image
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|status
decl_stmt|,
name|pos
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|img
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|patch
operator|->
name|new_name
decl_stmt|;
name|unsigned
name|mode
init|=
name|patch
operator|->
name|new_mode
decl_stmt|;
if|if
condition|(
operator|!
name|patch
operator|->
name|is_new
condition|)
name|die
argument_list|(
literal|"BUG: patch to %s is not a creation"
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: does not exist in index"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
name|ce
operator|=
name|active_cache
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|checkout_target
argument_list|(
name|ce
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|verify_index_match
argument_list|(
name|ce
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: does not match index"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
name|status
operator|=
name|load_patch_target
argument_list|(
operator|&
name|buf
argument_list|,
name|ce
argument_list|,
operator|&
name|st
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
elseif|else
if|if
condition|(
name|status
condition|)
return|return
operator|-
literal|1
return|;
name|img
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|prepare_image
argument_list|(
name|image
argument_list|,
name|img
argument_list|,
name|len
argument_list|,
operator|!
name|patch
operator|->
name|is_binary
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|try_threeway
specifier|static
name|int
name|try_threeway
parameter_list|(
name|struct
name|image
modifier|*
name|image
parameter_list|,
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|)
block|{
name|unsigned
name|char
name|pre_sha1
index|[
literal|20
index|]
decl_stmt|,
name|post_sha1
index|[
literal|20
index|]
decl_stmt|,
name|our_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|img
decl_stmt|;
name|struct
name|image
name|tmp_image
decl_stmt|;
comment|/* No point falling back to 3-way merge in these cases */
if|if
condition|(
name|patch
operator|->
name|is_delete
operator|||
name|S_ISGITLINK
argument_list|(
name|patch
operator|->
name|old_mode
argument_list|)
operator|||
name|S_ISGITLINK
argument_list|(
name|patch
operator|->
name|new_mode
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Preimage the patch was prepared for */
if|if
condition|(
name|patch
operator|->
name|is_new
condition|)
name|write_sha1_file
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
name|blob_type
argument_list|,
name|pre_sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|get_sha1
argument_list|(
name|patch
operator|->
name|old_sha1_prefix
argument_list|,
name|pre_sha1
argument_list|)
operator|||
name|read_blob_object
argument_list|(
operator|&
name|buf
argument_list|,
name|pre_sha1
argument_list|,
name|patch
operator|->
name|old_mode
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"repository lacks the necessary blob to fall back on 3-way merge."
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Falling back to three-way merge...\n"
argument_list|)
expr_stmt|;
name|img
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|prepare_image
argument_list|(
operator|&
name|tmp_image
argument_list|,
name|img
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Apply the patch to get the post image */
if|if
condition|(
name|apply_fragments
argument_list|(
operator|&
name|tmp_image
argument_list|,
name|patch
argument_list|)
operator|<
literal|0
condition|)
block|{
name|clear_image
argument_list|(
operator|&
name|tmp_image
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* post_sha1[] is theirs */
name|write_sha1_file
argument_list|(
name|tmp_image
operator|.
name|buf
argument_list|,
name|tmp_image
operator|.
name|len
argument_list|,
name|blob_type
argument_list|,
name|post_sha1
argument_list|)
expr_stmt|;
name|clear_image
argument_list|(
operator|&
name|tmp_image
argument_list|)
expr_stmt|;
comment|/* our_sha1[] is ours */
if|if
condition|(
name|patch
operator|->
name|is_new
condition|)
block|{
if|if
condition|(
name|load_current
argument_list|(
operator|&
name|tmp_image
argument_list|,
name|patch
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"cannot read the current contents of '%s'"
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|load_preimage
argument_list|(
operator|&
name|tmp_image
argument_list|,
name|patch
argument_list|,
name|st
argument_list|,
name|ce
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"cannot read the current contents of '%s'"
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
return|;
block|}
name|write_sha1_file
argument_list|(
name|tmp_image
operator|.
name|buf
argument_list|,
name|tmp_image
operator|.
name|len
argument_list|,
name|blob_type
argument_list|,
name|our_sha1
argument_list|)
expr_stmt|;
name|clear_image
argument_list|(
operator|&
name|tmp_image
argument_list|)
expr_stmt|;
comment|/* in-core three-way merge between post and our using pre as base */
name|status
operator|=
name|three_way_merge
argument_list|(
name|image
argument_list|,
name|patch
operator|->
name|new_name
argument_list|,
name|pre_sha1
argument_list|,
name|our_sha1
argument_list|,
name|post_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to fall back on three-way merge...\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|patch
operator|->
name|conflicted_threeway
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|is_new
condition|)
name|hashclr
argument_list|(
name|patch
operator|->
name|threeway_stage
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|hashcpy
argument_list|(
name|patch
operator|->
name|threeway_stage
index|[
literal|0
index|]
argument_list|,
name|pre_sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|patch
operator|->
name|threeway_stage
index|[
literal|1
index|]
argument_list|,
name|our_sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|patch
operator|->
name|threeway_stage
index|[
literal|2
index|]
argument_list|,
name|post_sha1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Applied patch to '%s' with conflicts.\n"
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Applied patch to '%s' cleanly.\n"
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|apply_data
specifier|static
name|int
name|apply_data
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|)
block|{
name|struct
name|image
name|image
decl_stmt|;
if|if
condition|(
name|load_preimage
argument_list|(
operator|&
name|image
argument_list|,
name|patch
argument_list|,
name|st
argument_list|,
name|ce
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|patch
operator|->
name|direct_to_threeway
operator|||
name|apply_fragments
argument_list|(
operator|&
name|image
argument_list|,
name|patch
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Note: with --reject, apply_fragments() returns 0 */
if|if
condition|(
operator|!
name|threeway
operator|||
name|try_threeway
argument_list|(
operator|&
name|image
argument_list|,
name|patch
argument_list|,
name|st
argument_list|,
name|ce
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|patch
operator|->
name|result
operator|=
name|image
operator|.
name|buf
expr_stmt|;
name|patch
operator|->
name|resultsize
operator|=
name|image
operator|.
name|len
expr_stmt|;
name|add_to_fn_table
argument_list|(
name|patch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|image
operator|.
name|line_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|patch
operator|->
name|is_delete
operator|&&
name|patch
operator|->
name|resultsize
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"removal patch leaves file contents"
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * If "patch" that we are looking at modifies or deletes what we have,  * we would want it not to lose any local modification we have, either  * in the working tree or in the index.  *  * This also decides if a non-git patch is a creation patch or a  * modification to an existing empty file.  We do not check the state  * of the current tree for a creation patch in this function; the caller  * check_patch() separately makes sure (and errors out otherwise) that  * the path the patch creates does not exist in the current tree.  */
end_comment
begin_function
DECL|function|check_preimage
specifier|static
name|int
name|check_preimage
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|struct
name|cache_entry
modifier|*
modifier|*
name|ce
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|old_name
init|=
name|patch
operator|->
name|old_name
decl_stmt|;
name|struct
name|patch
modifier|*
name|previous
init|=
name|NULL
decl_stmt|;
name|int
name|stat_ret
init|=
literal|0
decl_stmt|,
name|status
decl_stmt|;
name|unsigned
name|st_mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|old_name
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|patch
operator|->
name|is_new
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|previous
operator|=
name|previous_patch
argument_list|(
name|patch
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"path %s has been renamed/deleted"
argument_list|)
argument_list|,
name|old_name
argument_list|)
return|;
if|if
condition|(
name|previous
condition|)
block|{
name|st_mode
operator|=
name|previous
operator|->
name|new_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cached
condition|)
block|{
name|stat_ret
operator|=
name|lstat
argument_list|(
name|old_name
argument_list|,
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_ret
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: %s"
argument_list|)
argument_list|,
name|old_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|check_index
operator|&&
operator|!
name|previous
condition|)
block|{
name|int
name|pos
init|=
name|cache_name_pos
argument_list|(
name|old_name
argument_list|,
name|strlen
argument_list|(
name|old_name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|patch
operator|->
name|is_new
operator|<
literal|0
condition|)
goto|goto
name|is_new
goto|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: does not exist in index"
argument_list|)
argument_list|,
name|old_name
argument_list|)
return|;
block|}
operator|*
name|ce
operator|=
name|active_cache
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|stat_ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|checkout_target
argument_list|(
operator|*
name|ce
argument_list|,
name|st
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|cached
operator|&&
name|verify_index_match
argument_list|(
operator|*
name|ce
argument_list|,
name|st
argument_list|)
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: does not match index"
argument_list|)
argument_list|,
name|old_name
argument_list|)
return|;
if|if
condition|(
name|cached
condition|)
name|st_mode
operator|=
operator|(
operator|*
name|ce
operator|)
operator|->
name|ce_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat_ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|patch
operator|->
name|is_new
operator|<
literal|0
condition|)
goto|goto
name|is_new
goto|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: %s"
argument_list|)
argument_list|,
name|old_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|cached
operator|&&
operator|!
name|previous
condition|)
name|st_mode
operator|=
name|ce_mode_from_stat
argument_list|(
operator|*
name|ce
argument_list|,
name|st
operator|->
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|is_new
operator|<
literal|0
condition|)
name|patch
operator|->
name|is_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|patch
operator|->
name|old_mode
condition|)
name|patch
operator|->
name|old_mode
operator|=
name|st_mode
expr_stmt|;
if|if
condition|(
operator|(
name|st_mode
operator|^
name|patch
operator|->
name|old_mode
operator|)
operator|&
name|S_IFMT
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: wrong type"
argument_list|)
argument_list|,
name|old_name
argument_list|)
return|;
if|if
condition|(
name|st_mode
operator|!=
name|patch
operator|->
name|old_mode
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"%s has type %o, expected %o"
argument_list|)
argument_list|,
name|old_name
argument_list|,
name|st_mode
argument_list|,
name|patch
operator|->
name|old_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|patch
operator|->
name|new_mode
operator|&&
operator|!
name|patch
operator|->
name|is_delete
condition|)
name|patch
operator|->
name|new_mode
operator|=
name|st_mode
expr_stmt|;
return|return
literal|0
return|;
name|is_new
label|:
name|patch
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
name|patch
operator|->
name|is_delete
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
name|patch
operator|->
name|old_name
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|EXISTS_IN_INDEX
define|#
directive|define
name|EXISTS_IN_INDEX
value|1
end_define
begin_define
DECL|macro|EXISTS_IN_WORKTREE
define|#
directive|define
name|EXISTS_IN_WORKTREE
value|2
end_define
begin_function
DECL|function|check_to_create
specifier|static
name|int
name|check_to_create
parameter_list|(
specifier|const
name|char
modifier|*
name|new_name
parameter_list|,
name|int
name|ok_if_exists
parameter_list|)
block|{
name|struct
name|stat
name|nst
decl_stmt|;
if|if
condition|(
name|check_index
operator|&&
name|cache_name_pos
argument_list|(
name|new_name
argument_list|,
name|strlen
argument_list|(
name|new_name
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|ok_if_exists
condition|)
return|return
name|EXISTS_IN_INDEX
return|;
if|if
condition|(
name|cached
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|new_name
argument_list|,
operator|&
name|nst
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|nst
operator|.
name|st_mode
argument_list|)
operator|||
name|ok_if_exists
condition|)
return|return
literal|0
return|;
comment|/* 		 * A leading component of new_name might be a symlink 		 * that is going to be removed with this patch, but 		 * still pointing at somewhere that has the path. 		 * In such a case, path "new_name" does not exist as 		 * far as git is concerned. 		 */
if|if
condition|(
name|has_symlink_leading_path
argument_list|(
name|new_name
argument_list|,
name|strlen
argument_list|(
name|new_name
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|EXISTS_IN_WORKTREE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|errno
operator|!=
name|ENOENT
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ENOTDIR
operator|)
condition|)
block|{
return|return
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|new_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Check and apply the patch in-core; leave the result in patch->result  * for the caller to write it out to the final destination.  */
end_comment
begin_function
DECL|function|check_patch
specifier|static
name|int
name|check_patch
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_name
init|=
name|patch
operator|->
name|old_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
init|=
name|patch
operator|->
name|new_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|old_name
condition|?
name|old_name
else|:
name|new_name
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|NULL
decl_stmt|;
name|struct
name|patch
modifier|*
name|tpatch
decl_stmt|;
name|int
name|ok_if_exists
decl_stmt|;
name|int
name|status
decl_stmt|;
name|patch
operator|->
name|rejected
operator|=
literal|1
expr_stmt|;
comment|/* we will drop this after we succeed */
name|status
operator|=
name|check_preimage
argument_list|(
name|patch
argument_list|,
operator|&
name|ce
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
name|old_name
operator|=
name|patch
operator|->
name|old_name
expr_stmt|;
comment|/* 	 * A type-change diff is always split into a patch to delete 	 * old, immediately followed by a patch to create new (see 	 * diff.c::run_diff()); in such a case it is Ok that the entry 	 * to be deleted by the previous patch is still in the working 	 * tree and in the index. 	 * 	 * A patch to swap-rename between A and B would first rename A 	 * to B and then rename B to A.  While applying the first one, 	 * the presence of B should not stop A from getting renamed to 	 * B; ask to_be_deleted() about the later rename.  Removal of 	 * B and rename from A to B is handled the same way by asking 	 * was_deleted(). 	 */
if|if
condition|(
operator|(
name|tpatch
operator|=
name|in_fn_table
argument_list|(
name|new_name
argument_list|)
operator|)
operator|&&
operator|(
name|was_deleted
argument_list|(
name|tpatch
argument_list|)
operator|||
name|to_be_deleted
argument_list|(
name|tpatch
argument_list|)
operator|)
condition|)
name|ok_if_exists
operator|=
literal|1
expr_stmt|;
else|else
name|ok_if_exists
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_name
operator|&&
operator|(
operator|(
literal|0
operator|<
name|patch
operator|->
name|is_new
operator|)
operator|||
name|patch
operator|->
name|is_rename
operator|||
name|patch
operator|->
name|is_copy
operator|)
condition|)
block|{
name|int
name|err
init|=
name|check_to_create
argument_list|(
name|new_name
argument_list|,
name|ok_if_exists
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|threeway
condition|)
block|{
name|patch
operator|->
name|direct_to_threeway
operator|=
literal|1
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|err
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* happy */
case|case
name|EXISTS_IN_INDEX
case|:
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: already exists in index"
argument_list|)
argument_list|,
name|new_name
argument_list|)
return|;
break|break;
case|case
name|EXISTS_IN_WORKTREE
case|:
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: already exists in working directory"
argument_list|)
argument_list|,
name|new_name
argument_list|)
return|;
default|default:
return|return
name|err
return|;
block|}
if|if
condition|(
operator|!
name|patch
operator|->
name|new_mode
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|patch
operator|->
name|is_new
condition|)
name|patch
operator|->
name|new_mode
operator|=
name|S_IFREG
operator||
literal|0644
expr_stmt|;
else|else
name|patch
operator|->
name|new_mode
operator|=
name|patch
operator|->
name|old_mode
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_name
operator|&&
name|old_name
condition|)
block|{
name|int
name|same
init|=
operator|!
name|strcmp
argument_list|(
name|old_name
argument_list|,
name|new_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|patch
operator|->
name|new_mode
condition|)
name|patch
operator|->
name|new_mode
operator|=
name|patch
operator|->
name|old_mode
expr_stmt|;
if|if
condition|(
operator|(
name|patch
operator|->
name|old_mode
operator|^
name|patch
operator|->
name|new_mode
operator|)
operator|&
name|S_IFMT
condition|)
block|{
if|if
condition|(
name|same
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"new mode (%o) of %s does not "
literal|"match old mode (%o)"
argument_list|)
argument_list|,
name|patch
operator|->
name|new_mode
argument_list|,
name|new_name
argument_list|,
name|patch
operator|->
name|old_mode
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"new mode (%o) of %s does not "
literal|"match old mode (%o) of %s"
argument_list|)
argument_list|,
name|patch
operator|->
name|new_mode
argument_list|,
name|new_name
argument_list|,
name|patch
operator|->
name|old_mode
argument_list|,
name|old_name
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|apply_data
argument_list|(
name|patch
argument_list|,
operator|&
name|st
argument_list|,
name|ce
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: patch does not apply"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
name|patch
operator|->
name|rejected
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|check_patch_list
specifier|static
name|int
name|check_patch_list
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|prepare_fn_table
argument_list|(
name|patch
argument_list|)
expr_stmt|;
while|while
condition|(
name|patch
condition|)
block|{
if|if
condition|(
name|apply_verbosely
condition|)
name|say_patch_name
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Checking patch %s..."
argument_list|)
argument_list|,
name|patch
argument_list|)
expr_stmt|;
name|err
operator||=
name|check_patch
argument_list|(
name|patch
argument_list|)
expr_stmt|;
name|patch
operator|=
name|patch
operator|->
name|next
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function
begin_comment
comment|/* This function tries to read the sha1 from the current index */
end_comment
begin_function
DECL|function|get_current_sha1
specifier|static
name|int
name|get_current_sha1
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|active_cache
index|[
name|pos
index|]
operator|->
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|preimage_sha1_in_gitlink_patch
specifier|static
name|int
name|preimage_sha1_in_gitlink_patch
parameter_list|(
name|struct
name|patch
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
parameter_list|)
block|{
comment|/* 	 * A usable gitlink patch has only one fragment (hunk) that looks like: 	 * @@ -1 +1 @@ 	 * -Subproject commit<old sha1> 	 * +Subproject commit<new sha1> 	 * or 	 * @@ -1 +0,0 @@ 	 * -Subproject commit<old sha1> 	 * for a removal patch. 	 */
name|struct
name|fragment
modifier|*
name|hunk
init|=
name|p
operator|->
name|fragments
decl_stmt|;
specifier|static
specifier|const
name|char
name|heading
index|[]
init|=
literal|"-Subproject commit "
decl_stmt|;
name|char
modifier|*
name|preimage
decl_stmt|;
if|if
condition|(
comment|/* does the patch have only one hunk? */
name|hunk
operator|&&
operator|!
name|hunk
operator|->
name|next
operator|&&
comment|/* is its preimage one line? */
name|hunk
operator|->
name|oldpos
operator|==
literal|1
operator|&&
name|hunk
operator|->
name|oldlines
operator|==
literal|1
operator|&&
comment|/* does preimage begin with the heading? */
operator|(
name|preimage
operator|=
name|memchr
argument_list|(
name|hunk
operator|->
name|patch
argument_list|,
literal|'\n'
argument_list|,
name|hunk
operator|->
name|size
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|prefixcmp
argument_list|(
operator|++
name|preimage
argument_list|,
name|heading
argument_list|)
operator|&&
comment|/* does it record full SHA-1? */
operator|!
name|get_sha1_hex
argument_list|(
name|preimage
operator|+
sizeof|sizeof
argument_list|(
name|heading
argument_list|)
operator|-
literal|1
argument_list|,
name|sha1
argument_list|)
operator|&&
name|preimage
index|[
sizeof|sizeof
argument_list|(
name|heading
argument_list|)
operator|+
literal|40
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
comment|/* does the abbreviated name on the index line agree with it? */
operator|!
name|prefixcmp
argument_list|(
name|preimage
operator|+
sizeof|sizeof
argument_list|(
name|heading
argument_list|)
operator|-
literal|1
argument_list|,
name|p
operator|->
name|old_sha1_prefix
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* it all looks fine */
comment|/* we may have full object name on the index line */
return|return
name|get_sha1_hex
argument_list|(
name|p
operator|->
name|old_sha1_prefix
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Build an index that contains the just the files needed for a 3way merge */
end_comment
begin_function
DECL|function|build_fake_ancestor
specifier|static
name|void
name|build_fake_ancestor
parameter_list|(
name|struct
name|patch
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|patch
decl_stmt|;
name|struct
name|index_state
name|result
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Once we start supporting the reverse patch, it may be 	 * worth showing the new sha1 prefix, but until then... 	 */
for|for
control|(
name|patch
operator|=
name|list
init|;
name|patch
condition|;
name|patch
operator|=
name|patch
operator|->
name|next
control|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|patch
operator|->
name|old_name
condition|?
name|patch
operator|->
name|old_name
else|:
name|patch
operator|->
name|new_name
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|patch
operator|->
name|is_new
condition|)
continue|continue;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|patch
operator|->
name|old_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|preimage_sha1_in_gitlink_patch
argument_list|(
name|patch
argument_list|,
name|sha1
argument_list|)
condition|)
empty_stmt|;
comment|/* ok, the textual part looks sane */
else|else
name|die
argument_list|(
literal|"sha1 information is lacking or useless for submodule %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_sha1_blob
argument_list|(
name|patch
operator|->
name|old_sha1_prefix
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* ok */
block|}
elseif|else
if|if
condition|(
operator|!
name|patch
operator|->
name|lines_added
operator|&&
operator|!
name|patch
operator|->
name|lines_deleted
condition|)
block|{
comment|/* mode-only change: update the current */
if|if
condition|(
name|get_current_sha1
argument_list|(
name|patch
operator|->
name|old_name
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"mode change for %s, which is not "
literal|"in current HEAD"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"sha1 information is lacking or useless "
literal|"(%s)."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ce
operator|=
name|make_cache_entry
argument_list|(
name|patch
operator|->
name|old_mode
argument_list|,
name|sha1
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"make_cache_entry failed for path '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_index_entry
argument_list|(
operator|&
name|result
argument_list|,
name|ce
argument_list|,
name|ADD_CACHE_OK_TO_ADD
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not add %s to temporary index"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|write_index
argument_list|(
operator|&
name|result
argument_list|,
name|fd
argument_list|)
operator|||
name|close
argument_list|(
name|fd
argument_list|)
condition|)
name|die
argument_list|(
literal|"Could not write temporary index to %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|discard_index
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|stat_patch_list
specifier|static
name|void
name|stat_patch_list
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|int
name|files
decl_stmt|,
name|adds
decl_stmt|,
name|dels
decl_stmt|;
for|for
control|(
name|files
operator|=
name|adds
operator|=
name|dels
operator|=
literal|0
init|;
name|patch
condition|;
name|patch
operator|=
name|patch
operator|->
name|next
control|)
block|{
name|files
operator|++
expr_stmt|;
name|adds
operator|+=
name|patch
operator|->
name|lines_added
expr_stmt|;
name|dels
operator|+=
name|patch
operator|->
name|lines_deleted
expr_stmt|;
name|show_stats
argument_list|(
name|patch
argument_list|)
expr_stmt|;
block|}
name|print_stat_summary
argument_list|(
name|stdout
argument_list|,
name|files
argument_list|,
name|adds
argument_list|,
name|dels
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|numstat_patch_list
specifier|static
name|void
name|numstat_patch_list
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
for|for
control|(
init|;
name|patch
condition|;
name|patch
operator|=
name|patch
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|patch
operator|->
name|new_name
condition|?
name|patch
operator|->
name|new_name
else|:
name|patch
operator|->
name|old_name
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|is_binary
condition|)
name|printf
argument_list|(
literal|"-\t-\t"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d\t%d\t"
argument_list|,
name|patch
operator|->
name|lines_added
argument_list|,
name|patch
operator|->
name|lines_deleted
argument_list|)
expr_stmt|;
name|write_name_quoted
argument_list|(
name|name
argument_list|,
name|stdout
argument_list|,
name|line_termination
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|show_file_mode_name
specifier|static
name|void
name|show_file_mode_name
parameter_list|(
specifier|const
name|char
modifier|*
name|newdelete
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|mode
condition|)
name|printf
argument_list|(
literal|" %s mode %06o %s\n"
argument_list|,
name|newdelete
argument_list|,
name|mode
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s %s\n"
argument_list|,
name|newdelete
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_mode_change
specifier|static
name|void
name|show_mode_change
parameter_list|(
name|struct
name|patch
modifier|*
name|p
parameter_list|,
name|int
name|show_name
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|old_mode
operator|&&
name|p
operator|->
name|new_mode
operator|&&
name|p
operator|->
name|old_mode
operator|!=
name|p
operator|->
name|new_mode
condition|)
block|{
if|if
condition|(
name|show_name
condition|)
name|printf
argument_list|(
literal|" mode change %06o => %06o %s\n"
argument_list|,
name|p
operator|->
name|old_mode
argument_list|,
name|p
operator|->
name|new_mode
argument_list|,
name|p
operator|->
name|new_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" mode change %06o => %06o\n"
argument_list|,
name|p
operator|->
name|old_mode
argument_list|,
name|p
operator|->
name|new_mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|show_rename_copy
specifier|static
name|void
name|show_rename_copy
parameter_list|(
name|struct
name|patch
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|renamecopy
init|=
name|p
operator|->
name|is_rename
condition|?
literal|"rename"
else|:
literal|"copy"
decl_stmt|;
specifier|const
name|char
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
comment|/* Find common prefix */
name|old
operator|=
name|p
operator|->
name|old_name
expr_stmt|;
name|new
operator|=
name|p
operator|->
name|new_name
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|slash_old
decl_stmt|,
modifier|*
name|slash_new
decl_stmt|;
name|slash_old
operator|=
name|strchr
argument_list|(
name|old
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|slash_new
operator|=
name|strchr
argument_list|(
name|new
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slash_old
operator|||
operator|!
name|slash_new
operator|||
name|slash_old
operator|-
name|old
operator|!=
name|slash_new
operator|-
name|new
operator|||
name|memcmp
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|slash_new
operator|-
name|new
argument_list|)
condition|)
break|break;
name|old
operator|=
name|slash_old
operator|+
literal|1
expr_stmt|;
name|new
operator|=
name|slash_new
operator|+
literal|1
expr_stmt|;
block|}
comment|/* p->old_name thru old is the common prefix, and old and new 	 * through the end of names are renames 	 */
if|if
condition|(
name|old
operator|!=
name|p
operator|->
name|old_name
condition|)
name|printf
argument_list|(
literal|" %s %.*s{%s => %s} (%d%%)\n"
argument_list|,
name|renamecopy
argument_list|,
call|(
name|int
call|)
argument_list|(
name|old
operator|-
name|p
operator|->
name|old_name
argument_list|)
argument_list|,
name|p
operator|->
name|old_name
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|p
operator|->
name|score
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s %s => %s (%d%%)\n"
argument_list|,
name|renamecopy
argument_list|,
name|p
operator|->
name|old_name
argument_list|,
name|p
operator|->
name|new_name
argument_list|,
name|p
operator|->
name|score
argument_list|)
expr_stmt|;
name|show_mode_change
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|summary_patch_list
specifier|static
name|void
name|summary_patch_list
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|struct
name|patch
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|patch
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|is_new
condition|)
name|show_file_mode_name
argument_list|(
literal|"create"
argument_list|,
name|p
operator|->
name|new_mode
argument_list|,
name|p
operator|->
name|new_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|is_delete
condition|)
name|show_file_mode_name
argument_list|(
literal|"delete"
argument_list|,
name|p
operator|->
name|old_mode
argument_list|,
name|p
operator|->
name|old_name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|is_rename
operator|||
name|p
operator|->
name|is_copy
condition|)
name|show_rename_copy
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|score
condition|)
block|{
name|printf
argument_list|(
literal|" rewrite %s (%d%%)\n"
argument_list|,
name|p
operator|->
name|new_name
argument_list|,
name|p
operator|->
name|score
argument_list|)
expr_stmt|;
name|show_mode_change
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|show_mode_change
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|patch_stats
specifier|static
name|void
name|patch_stats
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|int
name|lines
init|=
name|patch
operator|->
name|lines_added
operator|+
name|patch
operator|->
name|lines_deleted
decl_stmt|;
if|if
condition|(
name|lines
operator|>
name|max_change
condition|)
name|max_change
operator|=
name|lines
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|old_name
condition|)
block|{
name|int
name|len
init|=
name|quote_c_style
argument_list|(
name|patch
operator|->
name|old_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|patch
operator|->
name|new_name
condition|)
block|{
name|int
name|len
init|=
name|quote_c_style
argument_list|(
name|patch
operator|->
name|new_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|len
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|remove_file
specifier|static
name|void
name|remove_file
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|int
name|rmdir_empty
parameter_list|)
block|{
if|if
condition|(
name|update_index
condition|)
block|{
if|if
condition|(
name|remove_file_from_cache
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to remove %s from index"
argument_list|)
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cached
condition|)
block|{
if|if
condition|(
operator|!
name|remove_or_warn
argument_list|(
name|patch
operator|->
name|old_mode
argument_list|,
name|patch
operator|->
name|old_name
argument_list|)
operator|&&
name|rmdir_empty
condition|)
block|{
name|remove_path
argument_list|(
name|patch
operator|->
name|old_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|add_index_file
specifier|static
name|void
name|add_index_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|mode
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|unsigned
name|ce_size
init|=
name|cache_entry_size
argument_list|(
name|namelen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|update_index
condition|)
return|return;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|ce_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_namelen
operator|=
name|namelen
expr_stmt|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|s
operator|+
name|strlen
argument_list|(
literal|"Subproject commit "
argument_list|)
argument_list|,
name|ce
operator|->
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"corrupt patch for submodule %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cached
condition|)
block|{
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"unable to stat newly created file '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|fill_stat_cache_info
argument_list|(
name|ce
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|blob_type
argument_list|,
name|ce
operator|->
name|sha1
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to create backing store for newly created file %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|ADD_CACHE_OK_TO_ADD
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to add cache entry for %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|try_create_file
specifier|static
name|int
name|try_create_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|strbuf
name|nbuf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|mkdir
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
return|;
block|}
if|if
condition|(
name|has_symlinks
operator|&&
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
comment|/* Although buf:size is counted string, it also is NUL 		 * terminated. 		 */
return|return
name|symlink
argument_list|(
name|buf
argument_list|,
name|path
argument_list|)
return|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_WRONLY
argument_list|,
operator|(
name|mode
operator|&
literal|0100
operator|)
condition|?
literal|0777
else|:
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|convert_to_working_tree
argument_list|(
name|path
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|nbuf
argument_list|)
condition|)
block|{
name|size
operator|=
name|nbuf
operator|.
name|len
expr_stmt|;
name|buf
operator|=
name|nbuf
operator|.
name|buf
expr_stmt|;
block|}
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"closing file '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * We optimistically assume that the directories exist,  * which is true 99% of the time anyway. If they don't,  * we create them and try again.  */
end_comment
begin_function
DECL|function|create_one_file
specifier|static
name|void
name|create_one_file
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
if|if
condition|(
name|cached
condition|)
return|return;
if|if
condition|(
operator|!
name|try_create_file
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
condition|)
return|return;
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
name|safe_create_leading_directories
argument_list|(
name|path
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|try_create_file
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|errno
operator|==
name|EEXIST
operator|||
name|errno
operator|==
name|EACCES
condition|)
block|{
comment|/* We may be trying to create a file where a directory 		 * used to be. 		 */
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|||
operator|!
name|rmdir
argument_list|(
name|path
argument_list|)
operator|)
condition|)
name|errno
operator|=
name|EEXIST
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|unsigned
name|int
name|nr
init|=
name|getpid
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|newpath
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|mksnpath
argument_list|(
name|newpath
argument_list|,
sizeof|sizeof
argument_list|(
name|newpath
argument_list|)
argument_list|,
literal|"%s~%u"
argument_list|,
name|path
argument_list|,
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|try_create_file
argument_list|(
name|newpath
argument_list|,
name|mode
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rename
argument_list|(
name|newpath
argument_list|,
name|path
argument_list|)
condition|)
return|return;
name|unlink_or_warn
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
break|break;
operator|++
name|nr
expr_stmt|;
block|}
block|}
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"unable to write file '%s' mode %o"
argument_list|)
argument_list|,
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_conflicted_stages_file
specifier|static
name|void
name|add_conflicted_stages_file
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|int
name|stage
decl_stmt|,
name|namelen
decl_stmt|;
name|unsigned
name|ce_size
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
operator|!
name|update_index
condition|)
return|return;
name|namelen
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|ce_size
operator|=
name|cache_entry_size
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
name|mode
operator|=
name|patch
operator|->
name|new_mode
condition|?
name|patch
operator|->
name|new_mode
else|:
operator|(
name|S_IFREG
operator||
literal|0644
operator|)
expr_stmt|;
name|remove_file_from_cache
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
for|for
control|(
name|stage
operator|=
literal|1
init|;
name|stage
operator|<
literal|4
condition|;
name|stage
operator|++
control|)
block|{
if|if
condition|(
name|is_null_sha1
argument_list|(
name|patch
operator|->
name|threeway_stage
index|[
name|stage
operator|-
literal|1
index|]
argument_list|)
condition|)
continue|continue;
name|ce
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|ce_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|patch
operator|->
name|new_name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_mode
operator|=
name|create_ce_mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_flags
operator|=
name|create_ce_flags
argument_list|(
name|stage
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_namelen
operator|=
name|namelen
expr_stmt|;
name|hashcpy
argument_list|(
name|ce
operator|->
name|sha1
argument_list|,
name|patch
operator|->
name|threeway_stage
index|[
name|stage
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_cache_entry
argument_list|(
name|ce
argument_list|,
name|ADD_CACHE_OK_TO_ADD
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to add cache entry for %s"
argument_list|)
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|create_file
specifier|static
name|void
name|create_file
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|char
modifier|*
name|path
init|=
name|patch
operator|->
name|new_name
decl_stmt|;
name|unsigned
name|mode
init|=
name|patch
operator|->
name|new_mode
decl_stmt|;
name|unsigned
name|long
name|size
init|=
name|patch
operator|->
name|resultsize
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|patch
operator|->
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
name|mode
operator|=
name|S_IFREG
operator||
literal|0644
expr_stmt|;
name|create_one_file
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|conflicted_threeway
condition|)
name|add_conflicted_stages_file
argument_list|(
name|patch
argument_list|)
expr_stmt|;
else|else
name|add_index_file
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* phase zero is to remove, phase one is to create */
end_comment
begin_function
DECL|function|write_out_one_result
specifier|static
name|void
name|write_out_one_result
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|,
name|int
name|phase
parameter_list|)
block|{
if|if
condition|(
name|patch
operator|->
name|is_delete
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|phase
operator|==
literal|0
condition|)
name|remove_file
argument_list|(
name|patch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|patch
operator|->
name|is_new
operator|>
literal|0
operator|||
name|patch
operator|->
name|is_copy
condition|)
block|{
if|if
condition|(
name|phase
operator|==
literal|1
condition|)
name|create_file
argument_list|(
name|patch
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Rename or modification boils down to the same 	 * thing: remove the old, write the new 	 */
if|if
condition|(
name|phase
operator|==
literal|0
condition|)
name|remove_file
argument_list|(
name|patch
argument_list|,
name|patch
operator|->
name|is_rename
argument_list|)
expr_stmt|;
if|if
condition|(
name|phase
operator|==
literal|1
condition|)
name|create_file
argument_list|(
name|patch
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write_out_one_reject
specifier|static
name|int
name|write_out_one_reject
parameter_list|(
name|struct
name|patch
modifier|*
name|patch
parameter_list|)
block|{
name|FILE
modifier|*
name|rej
decl_stmt|;
name|char
name|namebuf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|frag
operator|=
name|patch
operator|->
name|fragments
init|;
name|frag
condition|;
name|frag
operator|=
name|frag
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|frag
operator|->
name|rejected
condition|)
continue|continue;
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cnt
condition|)
block|{
if|if
condition|(
name|apply_verbosely
condition|)
name|say_patch_name
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Applied patch %s cleanly."
argument_list|)
argument_list|,
name|patch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* This should not happen, because a removal patch that leaves 	 * contents are marked "rejected" at the patch level. 	 */
if|if
condition|(
operator|!
name|patch
operator|->
name|new_name
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"internal error"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Say this even without --verbose */
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
name|Q_
argument_list|(
literal|"Applying patch %%s with %d reject..."
argument_list|,
literal|"Applying patch %%s with %d rejects..."
argument_list|,
name|cnt
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|say_patch_name
argument_list|(
name|stderr
argument_list|,
name|sb
operator|.
name|buf
argument_list|,
name|patch
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|namebuf
argument_list|)
operator|<=
name|cnt
operator|+
literal|5
condition|)
block|{
name|cnt
operator|=
name|ARRAY_SIZE
argument_list|(
name|namebuf
argument_list|)
operator|-
literal|5
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"truncating .rej filename to %.*s.rej"
argument_list|)
argument_list|,
name|cnt
operator|-
literal|1
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|namebuf
argument_list|,
name|patch
operator|->
name|new_name
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|namebuf
operator|+
name|cnt
argument_list|,
literal|".rej"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|rej
operator|=
name|fopen
argument_list|(
name|namebuf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rej
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot open %s: %s"
argument_list|)
argument_list|,
name|namebuf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
comment|/* Normal git tools never deal with .rej, so do not pretend 	 * this is a git patch by saying --git nor give extended 	 * headers.  While at it, maybe please "kompare" that wants 	 * the trailing TAB and some garbage at the end of line ;-). 	 */
name|fprintf
argument_list|(
name|rej
argument_list|,
literal|"diff a/%s b/%s\t(rejected hunks)\n"
argument_list|,
name|patch
operator|->
name|new_name
argument_list|,
name|patch
operator|->
name|new_name
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|frag
operator|=
name|patch
operator|->
name|fragments
init|;
name|frag
condition|;
name|cnt
operator|++
operator|,
name|frag
operator|=
name|frag
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|frag
operator|->
name|rejected
condition|)
block|{
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Hunk #%d applied cleanly."
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fprintf_ln
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Rejected hunk #%d."
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rej
argument_list|,
literal|"%.*s"
argument_list|,
name|frag
operator|->
name|size
argument_list|,
name|frag
operator|->
name|patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|->
name|patch
index|[
name|frag
operator|->
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rej
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|rej
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|write_out_results
specifier|static
name|int
name|write_out_results
parameter_list|(
name|struct
name|patch
modifier|*
name|list
parameter_list|)
block|{
name|int
name|phase
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|struct
name|patch
modifier|*
name|l
decl_stmt|;
name|struct
name|string_list
name|cpath
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
for|for
control|(
name|phase
operator|=
literal|0
init|;
name|phase
operator|<
literal|2
condition|;
name|phase
operator|++
control|)
block|{
name|l
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|rejected
condition|)
name|errs
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|write_out_one_result
argument_list|(
name|l
argument_list|,
name|phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|phase
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|write_out_one_reject
argument_list|(
name|l
argument_list|)
condition|)
name|errs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|conflicted_threeway
condition|)
block|{
name|string_list_append
argument_list|(
operator|&
name|cpath
argument_list|,
name|l
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cpath
operator|.
name|nr
condition|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|sort_string_list
argument_list|(
operator|&
name|cpath
argument_list|)
expr_stmt|;
name|for_each_string_list_item
argument_list|(
argument|item
argument_list|,
argument|&cpath
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"U %s\n"
argument_list|,
name|item
operator|->
name|string
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|cpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rerere
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|errs
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|lock_file
specifier|static
name|struct
name|lock_file
name|lock_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|limit_by_name
specifier|static
name|struct
name|string_list
name|limit_by_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|has_include
specifier|static
name|int
name|has_include
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|add_name_limit
specifier|static
name|void
name|add_name_limit
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|exclude
parameter_list|)
block|{
name|struct
name|string_list_item
modifier|*
name|it
decl_stmt|;
name|it
operator|=
name|string_list_append
argument_list|(
operator|&
name|limit_by_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|it
operator|->
name|util
operator|=
name|exclude
condition|?
name|NULL
else|:
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|use_patch
specifier|static
name|int
name|use_patch
parameter_list|(
name|struct
name|patch
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pathname
init|=
name|p
operator|->
name|new_name
condition|?
name|p
operator|->
name|new_name
else|:
name|p
operator|->
name|old_name
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Paths outside are not touched regardless of "--include" */
if|if
condition|(
literal|0
operator|<
name|prefix_length
condition|)
block|{
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pathlen
operator|<=
name|prefix_length
operator|||
name|memcmp
argument_list|(
name|prefix
argument_list|,
name|pathname
argument_list|,
name|prefix_length
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* See if it matches any of exclude/include rule */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit_by_name
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|it
init|=
operator|&
name|limit_by_name
operator|.
name|items
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
name|it
operator|->
name|string
argument_list|,
name|pathname
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|it
operator|->
name|util
operator|!=
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If we had any include, a path that does not match any rule is 	 * not used.  Otherwise, we saw bunch of exclude rules (or none) 	 * and such a path is used. 	 */
return|return
operator|!
name|has_include
return|;
block|}
end_function
begin_function
DECL|function|prefix_one
specifier|static
name|void
name|prefix_one
parameter_list|(
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|old_name
init|=
operator|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|old_name
condition|)
return|return;
operator|*
name|name
operator|=
name|xstrdup
argument_list|(
name|prefix_filename
argument_list|(
name|prefix
argument_list|,
name|prefix_length
argument_list|,
operator|*
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prefix_patches
specifier|static
name|void
name|prefix_patches
parameter_list|(
name|struct
name|patch
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefix
operator|||
name|p
operator|->
name|is_toplevel_relative
condition|)
return|return;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|prefix_one
argument_list|(
operator|&
name|p
operator|->
name|new_name
argument_list|)
expr_stmt|;
name|prefix_one
argument_list|(
operator|&
name|p
operator|->
name|old_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_define
DECL|macro|INACCURATE_EOF
define|#
directive|define
name|INACCURATE_EOF
value|(1<<0)
end_define
begin_define
DECL|macro|RECOUNT
define|#
directive|define
name|RECOUNT
value|(1<<1)
end_define
begin_function
DECL|function|apply_patch
specifier|static
name|int
name|apply_patch
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|size_t
name|offset
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
comment|/* owns the patch text */
name|struct
name|patch
modifier|*
name|list
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|listp
init|=
operator|&
name|list
decl_stmt|;
name|int
name|skipped_patch
init|=
literal|0
decl_stmt|;
name|patch_input_file
operator|=
name|filename
expr_stmt|;
name|read_patch_file
argument_list|(
operator|&
name|buf
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|buf
operator|.
name|len
condition|)
block|{
name|struct
name|patch
modifier|*
name|patch
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|patch
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|patch
argument_list|)
argument_list|)
expr_stmt|;
name|patch
operator|->
name|inaccurate_eof
operator|=
operator|!
operator|!
operator|(
name|options
operator|&
name|INACCURATE_EOF
operator|)
expr_stmt|;
name|patch
operator|->
name|recount
operator|=
operator|!
operator|!
operator|(
name|options
operator|&
name|RECOUNT
operator|)
expr_stmt|;
name|nr
operator|=
name|parse_chunk
argument_list|(
name|buf
operator|.
name|buf
operator|+
name|offset
argument_list|,
name|buf
operator|.
name|len
operator|-
name|offset
argument_list|,
name|patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|apply_in_reverse
condition|)
name|reverse_patches
argument_list|(
name|patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|prefix_patches
argument_list|(
name|patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_patch
argument_list|(
name|patch
argument_list|)
condition|)
block|{
name|patch_stats
argument_list|(
name|patch
argument_list|)
expr_stmt|;
operator|*
name|listp
operator|=
name|patch
expr_stmt|;
name|listp
operator|=
operator|&
name|patch
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|free_patch
argument_list|(
name|patch
argument_list|)
expr_stmt|;
name|skipped_patch
operator|++
expr_stmt|;
block|}
name|offset
operator|+=
name|nr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|list
operator|&&
operator|!
name|skipped_patch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unrecognized input"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|whitespace_error
operator|&&
operator|(
name|ws_error_action
operator|==
name|die_on_ws_error
operator|)
condition|)
name|apply
operator|=
literal|0
expr_stmt|;
name|update_index
operator|=
name|check_index
operator|&&
name|apply
expr_stmt|;
if|if
condition|(
name|update_index
operator|&&
name|newfd
operator|<
literal|0
condition|)
name|newfd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|lock_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_index
condition|)
block|{
if|if
condition|(
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unable to read index file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|check
operator|||
name|apply
operator|)
operator|&&
name|check_patch_list
argument_list|(
name|list
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|apply_with_reject
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply
operator|&&
name|write_out_results
argument_list|(
name|list
argument_list|)
condition|)
block|{
if|if
condition|(
name|apply_with_reject
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* with --3way, we still need to write the index out */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fake_ancestor
condition|)
name|build_fake_ancestor
argument_list|(
name|list
argument_list|,
name|fake_ancestor
argument_list|)
expr_stmt|;
if|if
condition|(
name|diffstat
condition|)
name|stat_patch_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|numstat
condition|)
name|numstat_patch_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
name|summary_patch_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|free_patch_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|fn_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_apply_config
specifier|static
name|int
name|git_apply_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"apply.whitespace"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|apply_default_whitespace
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"apply.ignorewhitespace"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|apply_default_ignorewhitespace
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
return|return
name|git_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|option_parse_exclude
specifier|static
name|int
name|option_parse_exclude
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|add_name_limit
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_include
specifier|static
name|int
name|option_parse_include
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|add_name_limit
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|has_include
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_p
specifier|static
name|int
name|option_parse_p
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|p_value
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|p_value_known
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_z
specifier|static
name|int
name|option_parse_z
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
name|line_termination
operator|=
literal|'\n'
expr_stmt|;
else|else
name|line_termination
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_space_change
specifier|static
name|int
name|option_parse_space_change
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
name|ws_ignore_action
operator|=
name|ignore_ws_none
expr_stmt|;
else|else
name|ws_ignore_action
operator|=
name|ignore_ws_change
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_whitespace
specifier|static
name|int
name|option_parse_whitespace
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|whitespace_option
init|=
name|opt
operator|->
name|value
decl_stmt|;
operator|*
name|whitespace_option
operator|=
name|arg
expr_stmt|;
name|parse_whitespace_option
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|option_parse_directory
specifier|static
name|int
name|option_parse_directory
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|root_len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|root_len
operator|&&
name|arg
index|[
name|root_len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|char
modifier|*
name|new_root
decl_stmt|;
name|root
operator|=
name|new_root
operator|=
name|xmalloc
argument_list|(
name|root_len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_root
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_root
operator|+
name|root_len
operator|++
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
name|root
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmd_apply
name|int
name|cmd_apply
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|int
name|is_not_gitdir
init|=
operator|!
name|startup_info
operator|->
name|have_repository
decl_stmt|;
name|int
name|force_apply
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|whitespace_option
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|builtin_apply_options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"exclude"
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"path"
argument_list|)
block|,
name|N_
argument_list|(
literal|"don't apply changes matching the given path"
argument_list|)
block|,
literal|0
block|,
name|option_parse_exclude
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"include"
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"path"
argument_list|)
block|,
name|N_
argument_list|(
literal|"apply changes matching the given path"
argument_list|)
block|,
literal|0
block|,
name|option_parse_include
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'p'
block|,
name|NULL
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"num"
argument_list|)
block|,
name|N_
argument_list|(
literal|"remove<num> leading slashes from traditional diff paths"
argument_list|)
block|,
literal|0
block|,
name|option_parse_p
block|}
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"no-add"
argument_list|,
operator|&
name|no_add
argument_list|,
name|N_
argument_list|(
literal|"ignore additions made by the patch"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"stat"
argument_list|,
operator|&
name|diffstat
argument_list|,
name|N_
argument_list|(
literal|"instead of applying the patch, output diffstat for the input"
argument_list|)
argument_list|)
block|,
name|OPT_NOOP_NOARG
argument_list|(
literal|0
argument_list|,
literal|"allow-binary-replacement"
argument_list|)
block|,
name|OPT_NOOP_NOARG
argument_list|(
literal|0
argument_list|,
literal|"binary"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"numstat"
argument_list|,
operator|&
name|numstat
argument_list|,
name|N_
argument_list|(
literal|"show number of added and deleted lines in decimal notation"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"summary"
argument_list|,
operator|&
name|summary
argument_list|,
name|N_
argument_list|(
literal|"instead of applying the patch, output a summary for the input"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"check"
argument_list|,
operator|&
name|check
argument_list|,
name|N_
argument_list|(
literal|"instead of applying the patch, see if the patch is applicable"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"index"
argument_list|,
operator|&
name|check_index
argument_list|,
name|N_
argument_list|(
literal|"make sure the patch is applicable to the current index"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"cached"
argument_list|,
operator|&
name|cached
argument_list|,
name|N_
argument_list|(
literal|"apply a patch without touching the working tree"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"apply"
argument_list|,
operator|&
name|force_apply
argument_list|,
name|N_
argument_list|(
literal|"also apply the patch (use with --stat/--summary/--check)"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'3'
argument_list|,
literal|"3way"
argument_list|,
operator|&
name|threeway
argument_list|,
name|N_
argument_list|(
literal|"attempt three-way merge if a patch does not apply"
argument_list|)
argument_list|)
block|,
name|OPT_FILENAME
argument_list|(
literal|0
argument_list|,
literal|"build-fake-ancestor"
argument_list|,
operator|&
name|fake_ancestor
argument_list|,
name|N_
argument_list|(
literal|"build a temporary index based on embedded index information"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'z'
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"paths are separated with NUL character"
argument_list|)
block|,
name|PARSE_OPT_NOARG
block|,
name|option_parse_z
block|}
block|,
name|OPT_INTEGER
argument_list|(
literal|'C'
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_context
argument_list|,
name|N_
argument_list|(
literal|"ensure at least<n> lines of context match"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"whitespace"
block|,
operator|&
name|whitespace_option
block|,
name|N_
argument_list|(
literal|"action"
argument_list|)
block|,
name|N_
argument_list|(
literal|"detect new or modified lines that have whitespace errors"
argument_list|)
block|,
literal|0
block|,
name|option_parse_whitespace
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"ignore-space-change"
block|,
name|NULL
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"ignore changes in whitespace when finding context"
argument_list|)
block|,
name|PARSE_OPT_NOARG
block|,
name|option_parse_space_change
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"ignore-whitespace"
block|,
name|NULL
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"ignore changes in whitespace when finding context"
argument_list|)
block|,
name|PARSE_OPT_NOARG
block|,
name|option_parse_space_change
block|}
block|,
name|OPT_BOOL
argument_list|(
literal|'R'
argument_list|,
literal|"reverse"
argument_list|,
operator|&
name|apply_in_reverse
argument_list|,
name|N_
argument_list|(
literal|"apply the patch in reverse"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"unidiff-zero"
argument_list|,
operator|&
name|unidiff_zero
argument_list|,
name|N_
argument_list|(
literal|"don't expect at least one line of context"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"reject"
argument_list|,
operator|&
name|apply_with_reject
argument_list|,
name|N_
argument_list|(
literal|"leave the rejected hunks in corresponding *.rej files"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"allow-overlap"
argument_list|,
operator|&
name|allow_overlap
argument_list|,
name|N_
argument_list|(
literal|"allow overlapping hunks"
argument_list|)
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|apply_verbosely
argument_list|,
name|N_
argument_list|(
literal|"be verbose"
argument_list|)
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"inaccurate-eof"
argument_list|,
operator|&
name|options
argument_list|,
name|N_
argument_list|(
literal|"tolerate incorrectly detected missing new-line at the end of file"
argument_list|)
argument_list|,
name|INACCURATE_EOF
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|0
argument_list|,
literal|"recount"
argument_list|,
operator|&
name|options
argument_list|,
name|N_
argument_list|(
literal|"do not trust the line counts in the hunk headers"
argument_list|)
argument_list|,
name|RECOUNT
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"directory"
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"root"
argument_list|)
block|,
name|N_
argument_list|(
literal|"prepend<root> to all filenames"
argument_list|)
block|,
literal|0
block|,
name|option_parse_directory
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|prefix
operator|=
name|prefix_
expr_stmt|;
name|prefix_length
operator|=
name|prefix
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
expr_stmt|;
name|git_config
argument_list|(
name|git_apply_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_default_whitespace
condition|)
name|parse_whitespace_option
argument_list|(
name|apply_default_whitespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_default_ignorewhitespace
condition|)
name|parse_ignorewhitespace_option
argument_list|(
name|apply_default_ignorewhitespace
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_apply_options
argument_list|,
name|apply_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_with_reject
operator|&&
name|threeway
condition|)
name|die
argument_list|(
literal|"--reject and --3way cannot be used together."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached
operator|&&
name|threeway
condition|)
name|die
argument_list|(
literal|"--cached and --3way cannot be used together."
argument_list|)
expr_stmt|;
if|if
condition|(
name|threeway
condition|)
block|{
if|if
condition|(
name|is_not_gitdir
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--3way outside a repository"
argument_list|)
argument_list|)
expr_stmt|;
name|check_index
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|apply_with_reject
condition|)
name|apply
operator|=
name|apply_verbosely
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|force_apply
operator|&&
operator|(
name|diffstat
operator|||
name|numstat
operator|||
name|summary
operator|||
name|check
operator|||
name|fake_ancestor
operator|)
condition|)
name|apply
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|check_index
operator|&&
name|is_not_gitdir
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--index outside a repository"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached
condition|)
block|{
if|if
condition|(
name|is_not_gitdir
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--cached outside a repository"
argument_list|)
argument_list|)
expr_stmt|;
name|check_index
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|errs
operator||=
name|apply_patch
argument_list|(
literal|0
argument_list|,
literal|"<stdin>"
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|read_stdin
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|<
name|prefix_length
condition|)
name|arg
operator|=
name|prefix_filename
argument_list|(
name|prefix
argument_list|,
name|prefix_length
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|arg
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"can't open patch '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|read_stdin
operator|=
literal|0
expr_stmt|;
name|set_default_whitespace_mode
argument_list|(
name|whitespace_option
argument_list|)
expr_stmt|;
name|errs
operator||=
name|apply_patch
argument_list|(
name|fd
argument_list|,
name|arg
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|set_default_whitespace_mode
argument_list|(
name|whitespace_option
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_stdin
condition|)
name|errs
operator||=
name|apply_patch
argument_list|(
literal|0
argument_list|,
literal|"<stdin>"
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|whitespace_error
condition|)
block|{
if|if
condition|(
name|squelch_whitespace_errors
operator|&&
name|squelch_whitespace_errors
operator|<
name|whitespace_error
condition|)
block|{
name|int
name|squelched
init|=
name|whitespace_error
operator|-
name|squelch_whitespace_errors
decl_stmt|;
name|warning
argument_list|(
name|Q_
argument_list|(
literal|"squelched %d whitespace error"
argument_list|,
literal|"squelched %d whitespace errors"
argument_list|,
name|squelched
argument_list|)
argument_list|,
name|squelched
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ws_error_action
operator|==
name|die_on_ws_error
condition|)
name|die
argument_list|(
name|Q_
argument_list|(
literal|"%d line adds whitespace errors."
argument_list|,
literal|"%d lines add whitespace errors."
argument_list|,
name|whitespace_error
argument_list|)
argument_list|,
name|whitespace_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|applied_after_fixing_ws
operator|&&
name|apply
condition|)
name|warning
argument_list|(
literal|"%d line%s applied after"
literal|" fixing whitespace errors."
argument_list|,
name|applied_after_fixing_ws
argument_list|,
name|applied_after_fixing_ws
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|whitespace_error
condition|)
name|warning
argument_list|(
name|Q_
argument_list|(
literal|"%d line adds whitespace errors."
argument_list|,
literal|"%d lines add whitespace errors."
argument_list|,
name|whitespace_error
argument_list|)
argument_list|,
name|whitespace_error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_index
condition|)
block|{
if|if
condition|(
name|write_cache
argument_list|(
name|newfd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
operator|&
name|lock_file
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unable to write new index file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
operator|!
name|errs
return|;
block|}
end_function
end_unit
