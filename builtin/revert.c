begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"object.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"exec_cmd.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"rerere.h"
end_include
begin_include
include|#
directive|include
file|"merge-recursive.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_comment
comment|/*  * This implements the builtins revert and cherry-pick.  *  * Copyright (c) 2007 Johannes E. Schindelin  *  * Based on git-revert.sh, which is  *  * Copyright (c) 2005 Linus Torvalds  * Copyright (c) 2005 Junio C Hamano  */
end_comment
begin_decl_stmt
DECL|variable|revert_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|revert_usage
index|[]
init|=
block|{
literal|"git revert [options]<commit-ish>"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cherry_pick_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cherry_pick_usage
index|[]
init|=
block|{
literal|"git cherry-pick [options]<commit-ish>"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|edit
DECL|variable|no_replay
DECL|variable|no_commit
DECL|variable|mainline
DECL|variable|signoff
DECL|variable|allow_ff
specifier|static
name|int
name|edit
decl_stmt|,
name|no_replay
decl_stmt|,
name|no_commit
decl_stmt|,
name|mainline
decl_stmt|,
name|signoff
decl_stmt|,
name|allow_ff
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|REVERT
DECL|enumerator|CHERRY_PICK
DECL|variable|action
specifier|static
enum|enum
block|{
name|REVERT
block|,
name|CHERRY_PICK
block|}
name|action
enum|;
end_enum
begin_decl_stmt
DECL|variable|commit
specifier|static
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_argc
specifier|static
name|int
name|commit_argc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_argv
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|commit_argv
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allow_rerere_auto
specifier|static
name|int
name|allow_rerere_auto
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|me
specifier|static
specifier|const
name|char
modifier|*
name|me
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Merge strategy. */
end_comment
begin_decl_stmt
DECL|variable|strategy
specifier|static
specifier|const
name|char
modifier|*
name|strategy
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xopts
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|xopts
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|xopts_nr
DECL|variable|xopts_alloc
specifier|static
name|size_t
name|xopts_nr
decl_stmt|,
name|xopts_alloc
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|GIT_REFLOG_ACTION
define|#
directive|define
name|GIT_REFLOG_ACTION
value|"GIT_REFLOG_ACTION"
end_define
begin_function_decl
specifier|static
name|char
modifier|*
name|get_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|revert_or_cherry_pick_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|revert_or_cherry_pick_usage
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|action
operator|==
name|REVERT
condition|?
name|revert_usage
else|:
name|cherry_pick_usage
return|;
block|}
end_function
begin_function
DECL|function|option_parse_x
specifier|static
name|int
name|option_parse_x
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
return|return
literal|0
return|;
name|ALLOC_GROW
argument_list|(
name|xopts
argument_list|,
name|xopts_nr
operator|+
literal|1
argument_list|,
name|xopts_alloc
argument_list|)
expr_stmt|;
name|xopts
index|[
name|xopts_nr
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_args
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|usage_str
init|=
name|revert_or_cherry_pick_usage
argument_list|()
decl_stmt|;
name|int
name|noop
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_BOOLEAN
argument_list|(
literal|'n'
argument_list|,
literal|"no-commit"
argument_list|,
operator|&
name|no_commit
argument_list|,
literal|"don't automatically commit"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'e'
argument_list|,
literal|"edit"
argument_list|,
operator|&
name|edit
argument_list|,
literal|"edit the commit message"
argument_list|)
block|,
block|{
name|OPTION_BOOLEAN
block|,
literal|'r'
block|,
name|NULL
block|,
operator|&
name|noop
block|,
name|NULL
block|,
literal|"no-op (backward compatibility)"
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_HIDDEN
block|,
name|NULL
block|,
literal|0
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'s'
argument_list|,
literal|"signoff"
argument_list|,
operator|&
name|signoff
argument_list|,
literal|"add Signed-off-by:"
argument_list|)
block|,
name|OPT_INTEGER
argument_list|(
literal|'m'
argument_list|,
literal|"mainline"
argument_list|,
operator|&
name|mainline
argument_list|,
literal|"parent number"
argument_list|)
block|,
name|OPT_RERERE_AUTOUPDATE
argument_list|(
operator|&
name|allow_rerere_auto
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"strategy"
argument_list|,
operator|&
name|strategy
argument_list|,
literal|"strategy"
argument_list|,
literal|"merge strategy"
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|'X'
argument_list|,
literal|"strategy-option"
argument_list|,
operator|&
name|xopts
argument_list|,
literal|"option"
argument_list|,
literal|"option for merge strategy"
argument_list|,
name|option_parse_x
argument_list|)
block|,
name|OPT_END
argument_list|()
block|,
name|OPT_END
argument_list|()
block|,
name|OPT_END
argument_list|()
block|, 	}
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|CHERRY_PICK
condition|)
block|{
name|struct
name|option
name|cp_extra
index|[]
init|=
block|{
name|OPT_BOOLEAN
argument_list|(
literal|'x'
argument_list|,
name|NULL
argument_list|,
operator|&
name|no_replay
argument_list|,
literal|"append commit name"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"ff"
argument_list|,
operator|&
name|allow_ff
argument_list|,
literal|"allow fast-forward"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|, 		}
decl_stmt|;
if|if
condition|(
name|parse_options_concat
argument_list|(
name|options
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|options
argument_list|)
argument_list|,
name|cp_extra
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"program error"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|commit_argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
name|options
argument_list|,
name|usage_str
argument_list|,
name|PARSE_OPT_KEEP_ARGV0
operator||
name|PARSE_OPT_KEEP_UNKNOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_argc
operator|<
literal|2
condition|)
name|usage_with_options
argument_list|(
name|usage_str
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|commit_argv
operator|=
name|argv
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|commit_message
struct|struct
name|commit_message
block|{
DECL|member|parent_label
name|char
modifier|*
name|parent_label
decl_stmt|;
DECL|member|label
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
DECL|member|subject
specifier|const
name|char
modifier|*
name|subject
decl_stmt|;
DECL|member|reencoded_message
name|char
modifier|*
name|reencoded_message
decl_stmt|;
DECL|member|message
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|get_message
specifier|static
name|int
name|get_message
parameter_list|(
specifier|const
name|char
modifier|*
name|raw_message
parameter_list|,
name|struct
name|commit_message
modifier|*
name|out
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|encoding
decl_stmt|;
specifier|const
name|char
modifier|*
name|abbrev
decl_stmt|,
modifier|*
name|subject
decl_stmt|;
name|int
name|abbrev_len
decl_stmt|,
name|subject_len
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|raw_message
condition|)
return|return
operator|-
literal|1
return|;
name|encoding
operator|=
name|get_encoding
argument_list|(
name|raw_message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
condition|)
name|encoding
operator|=
literal|"UTF-8"
expr_stmt|;
if|if
condition|(
operator|!
name|git_commit_encoding
condition|)
name|git_commit_encoding
operator|=
literal|"UTF-8"
expr_stmt|;
name|out
operator|->
name|reencoded_message
operator|=
name|NULL
expr_stmt|;
name|out
operator|->
name|message
operator|=
name|raw_message
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
name|git_commit_encoding
argument_list|)
condition|)
name|out
operator|->
name|reencoded_message
operator|=
name|reencode_string
argument_list|(
name|raw_message
argument_list|,
name|git_commit_encoding
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|->
name|reencoded_message
condition|)
name|out
operator|->
name|message
operator|=
name|out
operator|->
name|reencoded_message
expr_stmt|;
name|abbrev
operator|=
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
expr_stmt|;
name|abbrev_len
operator|=
name|strlen
argument_list|(
name|abbrev
argument_list|)
expr_stmt|;
name|subject_len
operator|=
name|find_commit_subject
argument_list|(
name|out
operator|->
name|message
argument_list|,
operator|&
name|subject
argument_list|)
expr_stmt|;
name|out
operator|->
name|parent_label
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
literal|"parent of "
argument_list|)
operator|+
name|abbrev_len
operator|+
name|strlen
argument_list|(
literal|"... "
argument_list|)
operator|+
name|subject_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|q
operator|=
name|out
operator|->
name|parent_label
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
literal|"parent of "
argument_list|,
name|strlen
argument_list|(
literal|"parent of "
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|label
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
name|abbrev
argument_list|,
name|abbrev_len
argument_list|)
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
literal|"... "
argument_list|,
name|strlen
argument_list|(
literal|"... "
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|subject
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|mempcpy
argument_list|(
name|q
argument_list|,
name|subject
argument_list|,
name|subject_len
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|free_message
specifier|static
name|void
name|free_message
parameter_list|(
name|struct
name|commit_message
modifier|*
name|msg
parameter_list|)
block|{
name|free
argument_list|(
name|msg
operator|->
name|parent_label
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
operator|->
name|reencoded_message
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_encoding
specifier|static
name|char
modifier|*
name|get_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|message
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Could not read commit message of %s"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
block|{
for|for
control|(
name|eol
operator|=
name|p
operator|+
literal|1
init|;
operator|*
name|eol
operator|&&
operator|*
name|eol
operator|!=
literal|'\n'
condition|;
name|eol
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|p
argument_list|,
literal|"encoding "
argument_list|)
condition|)
block|{
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|eol
operator|-
literal|8
operator|-
name|p
argument_list|)
decl_stmt|;
name|strlcpy
argument_list|(
name|result
argument_list|,
name|p
operator|+
literal|9
argument_list|,
name|eol
operator|-
literal|8
operator|-
name|p
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|p
operator|=
name|eol
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|write_cherry_pick_head
specifier|static
name|void
name|write_cherry_pick_head
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not open '%s' for writing"
argument_list|)
argument_list|,
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
operator|!=
name|buf
operator|.
name|len
operator|||
name|close
argument_list|(
name|fd
argument_list|)
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to '%s'"
argument_list|)
argument_list|,
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|print_advice
specifier|static
name|void
name|print_advice
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
name|getenv
argument_list|(
literal|"GIT_CHERRY_PICK_HELP"
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 		 * A conflict has occured but the porcelain 		 * (typically rebase --interactive) wants to take care 		 * of the commit itself so remove CHERRY_PICK_HEAD 		 */
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"CHERRY_PICK_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|advise
argument_list|(
literal|"after resolving the conflicts, mark the corrected paths"
argument_list|)
expr_stmt|;
name|advise
argument_list|(
literal|"with 'git add<paths>' or 'git rm<paths>'"
argument_list|)
expr_stmt|;
name|advise
argument_list|(
literal|"and commit the result with 'git commit'"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write_message
specifier|static
name|void
name|write_message
parameter_list|(
name|struct
name|strbuf
modifier|*
name|msgbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|static
name|struct
name|lock_file
name|msg_file
decl_stmt|;
name|int
name|msg_fd
init|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|msg_file
argument_list|,
name|filename
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
decl_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|msg_fd
argument_list|,
name|msgbuf
operator|->
name|buf
argument_list|,
name|msgbuf
operator|->
name|len
argument_list|)
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not write to %s."
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_lock_file
argument_list|(
operator|&
name|msg_file
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Error wrapping up %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|empty_tree
specifier|static
name|struct
name|tree
modifier|*
name|empty_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|tree
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree
argument_list|)
argument_list|)
decl_stmt|;
name|tree
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|tree
operator|->
name|object
operator|.
name|type
operator|=
name|OBJ_TREE
expr_stmt|;
name|pretend_sha1_file
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|OBJ_TREE
argument_list|,
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
return|return
name|tree
return|;
block|}
end_function
begin_function
DECL|function|die_dirty_index
specifier|static
name|NORETURN
name|void
name|die_dirty_index
parameter_list|(
specifier|const
name|char
modifier|*
name|me
parameter_list|)
block|{
if|if
condition|(
name|read_cache_unmerged
argument_list|()
condition|)
block|{
name|die_resolve_conflict
argument_list|(
name|me
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|advice_commit_before_merge
condition|)
block|{
if|if
condition|(
name|action
operator|==
name|REVERT
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Your local changes would be overwritten by revert.\n"
literal|"Please, commit your changes or stash them to proceed."
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"Your local changes would be overwritten by cherry-pick.\n"
literal|"Please, commit your changes or stash them to proceed."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|action
operator|==
name|REVERT
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Your local changes would be overwritten by revert.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"Your local changes would be overwritten by cherry-pick.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|fast_forward_to
specifier|static
name|int
name|fast_forward_to
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|ref_lock
modifier|*
name|ref_lock
decl_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkout_fast_forward
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* the callee should have complained already */
name|ref_lock
operator|=
name|lock_any_ref_for_update
argument_list|(
literal|"HEAD"
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|write_ref_sha1
argument_list|(
name|ref_lock
argument_list|,
name|to
argument_list|,
literal|"cherry-pick"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|do_recursive_merge
specifier|static
name|int
name|do_recursive_merge
parameter_list|(
name|struct
name|commit
modifier|*
name|base
parameter_list|,
name|struct
name|commit
modifier|*
name|next
parameter_list|,
specifier|const
name|char
modifier|*
name|base_label
parameter_list|,
specifier|const
name|char
modifier|*
name|next_label
parameter_list|,
name|unsigned
name|char
modifier|*
name|head
parameter_list|,
name|struct
name|strbuf
modifier|*
name|msgbuf
parameter_list|)
block|{
name|struct
name|merge_options
name|o
decl_stmt|;
name|struct
name|tree
modifier|*
name|result
decl_stmt|,
modifier|*
name|next_tree
decl_stmt|,
modifier|*
name|base_tree
decl_stmt|,
modifier|*
name|head_tree
decl_stmt|;
name|int
name|clean
decl_stmt|,
name|index_fd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|xopt
decl_stmt|;
specifier|static
name|struct
name|lock_file
name|index_lock
decl_stmt|;
name|index_fd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_cache
argument_list|()
expr_stmt|;
name|init_merge_options
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|ancestor
operator|=
name|base
condition|?
name|base_label
else|:
literal|"(empty tree)"
expr_stmt|;
name|o
operator|.
name|branch1
operator|=
literal|"HEAD"
expr_stmt|;
name|o
operator|.
name|branch2
operator|=
name|next
condition|?
name|next_label
else|:
literal|"(empty tree)"
expr_stmt|;
name|head_tree
operator|=
name|parse_tree_indirect
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|next_tree
operator|=
name|next
condition|?
name|next
operator|->
name|tree
else|:
name|empty_tree
argument_list|()
expr_stmt|;
name|base_tree
operator|=
name|base
condition|?
name|base
operator|->
name|tree
else|:
name|empty_tree
argument_list|()
expr_stmt|;
for|for
control|(
name|xopt
operator|=
name|xopts
init|;
name|xopt
operator|!=
name|xopts
operator|+
name|xopts_nr
condition|;
name|xopt
operator|++
control|)
name|parse_merge_opt
argument_list|(
operator|&
name|o
argument_list|,
operator|*
name|xopt
argument_list|)
expr_stmt|;
name|clean
operator|=
name|merge_trees
argument_list|(
operator|&
name|o
argument_list|,
name|head_tree
argument_list|,
name|next_tree
argument_list|,
name|base_tree
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_cache_changed
operator|&&
operator|(
name|write_cache
argument_list|(
name|index_fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|)
operator|)
condition|)
comment|/* TRANSLATORS: %s will be "revert" or "cherry-pick" */
name|die
argument_list|(
name|_
argument_list|(
literal|"%s: Unable to write new index file"
argument_list|)
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clean
condition|)
block|{
name|int
name|i
decl_stmt|;
name|strbuf_addstr
argument_list|(
name|msgbuf
argument_list|,
literal|"\nConflicts:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
block|{
name|strbuf_addch
argument_list|(
name|msgbuf
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|msgbuf
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|msgbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|active_cache
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|!
name|clean
return|;
block|}
end_function
begin_comment
comment|/*  * If we are cherry-pick, and if the merge did not result in  * hand-editing, we will hit this commit and inherit the original  * author date and name.  * If we are revert, or if our cherry-pick results in a hand merge,  * we had better say that the current user is responsible for that.  */
end_comment
begin_function
DECL|function|run_git_commit
specifier|static
name|int
name|run_git_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|defmsg
parameter_list|)
block|{
comment|/* 6 is max possible length of our args array including NULL */
specifier|const
name|char
modifier|*
name|args
index|[
literal|6
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"commit"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-n"
expr_stmt|;
if|if
condition|(
name|signoff
condition|)
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-s"
expr_stmt|;
if|if
condition|(
operator|!
name|edit
condition|)
block|{
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-F"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|defmsg
expr_stmt|;
block|}
name|args
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|run_command_v_opt
argument_list|(
name|args
argument_list|,
name|RUN_GIT_CMD
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|do_pick_commit
specifier|static
name|int
name|do_pick_commit
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|head
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|base
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_label
decl_stmt|,
modifier|*
name|next_label
decl_stmt|;
name|struct
name|commit_message
name|msg
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
name|defmsg
init|=
name|NULL
decl_stmt|;
name|struct
name|strbuf
name|msgbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|no_commit
condition|)
block|{
comment|/* 		 * We do not intend to commit immediately.  We just want to 		 * merge the differences in, so let's compute the tree 		 * that represents the "current" state for merge-recursive 		 * to work on. 		 */
if|if
condition|(
name|write_cache_as_tree
argument_list|(
name|head
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Your index file is unmerged."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You do not have a valid HEAD"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_differs_from
argument_list|(
literal|"HEAD"
argument_list|,
literal|0
argument_list|)
condition|)
name|die_dirty_index
argument_list|(
name|me
argument_list|)
expr_stmt|;
block|}
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|parents
condition|)
block|{
name|parent
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commit
operator|->
name|parents
operator|->
name|next
condition|)
block|{
comment|/* Reverting or cherry-picking a merge commit */
name|int
name|cnt
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|mainline
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Commit %s is a merge but no -m option was given."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|p
operator|=
name|commit
operator|->
name|parents
init|;
name|cnt
operator|!=
name|mainline
operator|&&
name|p
condition|;
name|cnt
operator|++
control|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|mainline
operator|||
operator|!
name|p
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Commit %s does not have parent %d"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
name|parent
operator|=
name|p
operator|->
name|item
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|<
name|mainline
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Mainline was specified but commit %s is not a merge."
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|parent
operator|=
name|commit
operator|->
name|parents
operator|->
name|item
expr_stmt|;
if|if
condition|(
name|allow_ff
operator|&&
name|parent
operator|&&
operator|!
name|hashcmp
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head
argument_list|)
condition|)
return|return
name|fast_forward_to
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head
argument_list|)
return|;
if|if
condition|(
name|parent
operator|&&
name|parse_commit
argument_list|(
name|parent
argument_list|)
operator|<
literal|0
condition|)
comment|/* TRANSLATORS: The first %s will be "revert" or 		   "cherry-pick", the second %s a SHA1 */
name|die
argument_list|(
name|_
argument_list|(
literal|"%s: cannot parse parent commit %s"
argument_list|)
argument_list|,
name|me
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_message
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
operator|&
name|msg
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot get commit message for %s"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * "commit" is an existing commit.  We would want to apply 	 * the difference it introduces since its first parent "prev" 	 * on top of the current HEAD if we are cherry-pick.  Or the 	 * reverse of it if we are revert. 	 */
name|defmsg
operator|=
name|git_pathdup
argument_list|(
literal|"MERGE_MSG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|REVERT
condition|)
block|{
name|base
operator|=
name|commit
expr_stmt|;
name|base_label
operator|=
name|msg
operator|.
name|label
expr_stmt|;
name|next
operator|=
name|parent
expr_stmt|;
name|next_label
operator|=
name|msg
operator|.
name|parent_label
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|"Revert \""
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|msg
operator|.
name|subject
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|"\"\n\nThis reverts commit "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|parents
operator|&&
name|commit
operator|->
name|parents
operator|->
name|next
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|", reversing\nchanges made to "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|base
operator|=
name|parent
expr_stmt|;
name|base_label
operator|=
name|msg
operator|.
name|parent_label
expr_stmt|;
name|next
operator|=
name|commit
expr_stmt|;
name|next_label
operator|=
name|msg
operator|.
name|label
expr_stmt|;
comment|/* 		 * Append the commit log message to msgbuf; it starts 		 * after the tree, parent, author, committer 		 * information followed by "\n\n". 		 */
name|p
operator|=
name|strstr
argument_list|(
name|msg
operator|.
name|message
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|no_replay
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|"(cherry picked from commit "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_commit
condition|)
name|write_cherry_pick_head
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strategy
operator|||
operator|!
name|strcmp
argument_list|(
name|strategy
argument_list|,
literal|"recursive"
argument_list|)
operator|||
name|action
operator|==
name|REVERT
condition|)
block|{
name|res
operator|=
name|do_recursive_merge
argument_list|(
name|base
argument_list|,
name|next
argument_list|,
name|base_label
argument_list|,
name|next_label
argument_list|,
name|head
argument_list|,
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|write_message
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|defmsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|commit_list
modifier|*
name|common
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|remotes
init|=
name|NULL
decl_stmt|;
name|write_message
argument_list|(
operator|&
name|msgbuf
argument_list|,
name|defmsg
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|base
argument_list|,
operator|&
name|common
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|next
argument_list|,
operator|&
name|remotes
argument_list|)
expr_stmt|;
name|res
operator|=
name|try_merge_command
argument_list|(
name|strategy
argument_list|,
name|xopts_nr
argument_list|,
name|xopts
argument_list|,
name|common
argument_list|,
name|sha1_to_hex
argument_list|(
name|head
argument_list|)
argument_list|,
name|remotes
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|remotes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
block|{
name|error
argument_list|(
name|action
operator|==
name|REVERT
condition|?
name|_
argument_list|(
literal|"could not revert %s... %s"
argument_list|)
else|:
name|_
argument_list|(
literal|"could not apply %s... %s"
argument_list|)
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|,
name|msg
operator|.
name|subject
argument_list|)
expr_stmt|;
name|print_advice
argument_list|()
expr_stmt|;
name|rerere
argument_list|(
name|allow_rerere_auto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|no_commit
condition|)
name|res
operator|=
name|run_git_commit
argument_list|(
name|defmsg
argument_list|)
expr_stmt|;
block|}
name|free_message
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defmsg
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|prepare_revs
specifier|static
name|void
name|prepare_revs
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
name|init_revisions
argument_list|(
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|revs
operator|->
name|no_walk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|REVERT
condition|)
name|revs
operator|->
name|reverse
operator|=
literal|1
expr_stmt|;
name|argc
operator|=
name|setup_revisions
argument_list|(
name|commit_argc
argument_list|,
name|commit_argv
argument_list|,
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|usage
argument_list|(
operator|*
name|revert_or_cherry_pick_usage
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
name|revs
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|revs
operator|->
name|commits
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"empty commit set passed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_and_refresh_cache
specifier|static
name|void
name|read_and_refresh_cache
parameter_list|(
specifier|const
name|char
modifier|*
name|me
parameter_list|)
block|{
specifier|static
name|struct
name|lock_file
name|index_lock
decl_stmt|;
name|int
name|index_fd
init|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|read_index_preload
argument_list|(
operator|&
name|the_index
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git %s: failed to read the index"
argument_list|)
argument_list|,
name|me
argument_list|)
expr_stmt|;
name|refresh_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|REFRESH_QUIET
operator||
name|REFRESH_UNMERGED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_index
operator|.
name|cache_changed
condition|)
block|{
if|if
condition|(
name|write_index
argument_list|(
operator|&
name|the_index
argument_list|,
name|index_fd
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"git %s: failed to refresh the index"
argument_list|)
argument_list|,
name|me
argument_list|)
expr_stmt|;
block|}
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|revert_or_cherry_pick
specifier|static
name|int
name|revert_or_cherry_pick
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
name|git_config
argument_list|(
name|git_default_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|me
operator|=
name|action
operator|==
name|REVERT
condition|?
literal|"revert"
else|:
literal|"cherry-pick"
expr_stmt|;
name|setenv
argument_list|(
name|GIT_REFLOG_ACTION
argument_list|,
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|allow_ff
condition|)
block|{
if|if
condition|(
name|signoff
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cherry-pick --ff cannot be used with --signoff"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_commit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cherry-pick --ff cannot be used with --no-commit"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_replay
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cherry-pick --ff cannot be used with -x"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cherry-pick --ff cannot be used with --edit"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|read_and_refresh_cache
argument_list|(
name|me
argument_list|)
expr_stmt|;
name|prepare_revs
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
operator|&
name|revs
argument_list|)
operator|)
condition|)
block|{
name|int
name|res
init|=
name|do_pick_commit
argument_list|()
decl_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmd_revert
name|int
name|cmd_revert
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|edit
operator|=
literal|1
expr_stmt|;
name|action
operator|=
name|REVERT
expr_stmt|;
return|return
name|revert_or_cherry_pick
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_cherry_pick
name|int
name|cmd_cherry_pick
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|action
operator|=
name|CHERRY_PICK
expr_stmt|;
return|return
name|revert_or_cherry_pick
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function
end_unit
