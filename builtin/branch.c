begin_unit
begin_comment
comment|/*  * Builtin "git branch"  *  * Copyright (c) 2006 Kristian HÃ¸gsberg<krh@redhat.com>  * Based on git-branch.sh by Junio C Hamano.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"column.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_decl_stmt
DECL|variable|builtin_branch_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_branch_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git branch [options] [-r | -a] [--merged | --no-merged]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git branch [options] [-l] [-f]<branchname> [<start-point>]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git branch [options] [-r] (-d | -D)<branchname>..."
argument_list|)
block|,
name|N_
argument_list|(
literal|"git branch [options] (-m | -M) [<oldbranch>]<newbranch>"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|REF_LOCAL_BRANCH
define|#
directive|define
name|REF_LOCAL_BRANCH
value|0x01
end_define
begin_define
DECL|macro|REF_REMOTE_BRANCH
define|#
directive|define
name|REF_REMOTE_BRANCH
value|0x02
end_define
begin_decl_stmt
DECL|variable|head
specifier|static
specifier|const
name|char
modifier|*
name|head
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|head_sha1
specifier|static
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_use_color
specifier|static
name|int
name|branch_use_color
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_colors
specifier|static
name|char
name|branch_colors
index|[]
index|[
name|COLOR_MAXLEN
index|]
init|=
block|{
name|GIT_COLOR_RESET
block|,
name|GIT_COLOR_NORMAL
block|,
comment|/* PLAIN */
name|GIT_COLOR_RED
block|,
comment|/* REMOTE */
name|GIT_COLOR_NORMAL
block|,
comment|/* LOCAL */
name|GIT_COLOR_GREEN
block|,
comment|/* CURRENT */
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|color_branch
enum|enum
name|color_branch
block|{
DECL|enumerator|BRANCH_COLOR_RESET
name|BRANCH_COLOR_RESET
init|=
literal|0
block|,
DECL|enumerator|BRANCH_COLOR_PLAIN
name|BRANCH_COLOR_PLAIN
init|=
literal|1
block|,
DECL|enumerator|BRANCH_COLOR_REMOTE
name|BRANCH_COLOR_REMOTE
init|=
literal|2
block|,
DECL|enumerator|BRANCH_COLOR_LOCAL
name|BRANCH_COLOR_LOCAL
init|=
literal|3
block|,
DECL|enumerator|BRANCH_COLOR_CURRENT
name|BRANCH_COLOR_CURRENT
init|=
literal|4
block|}
enum|;
end_enum
begin_enum
DECL|enum|merge_filter
specifier|static
enum|enum
name|merge_filter
block|{
DECL|enumerator|NO_FILTER
name|NO_FILTER
init|=
literal|0
block|,
DECL|enumerator|SHOW_NOT_MERGED
name|SHOW_NOT_MERGED
block|,
DECL|enumerator|SHOW_MERGED
name|SHOW_MERGED
block|}
DECL|variable|merge_filter
name|merge_filter
enum|;
end_enum
begin_decl_stmt
DECL|variable|merge_filter_ref
specifier|static
name|unsigned
name|char
name|merge_filter_ref
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|output
specifier|static
name|struct
name|string_list
name|output
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|colopts
specifier|static
name|unsigned
name|int
name|colopts
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parse_branch_color_slot
specifier|static
name|int
name|parse_branch_color_slot
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
name|int
name|ofs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|ofs
argument_list|,
literal|"plain"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_PLAIN
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|ofs
argument_list|,
literal|"reset"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_RESET
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|ofs
argument_list|,
literal|"remote"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_REMOTE
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|ofs
argument_list|,
literal|"local"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_LOCAL
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|var
operator|+
name|ofs
argument_list|,
literal|"current"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_CURRENT
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|git_branch_config
specifier|static
name|int
name|git_branch_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"column."
argument_list|)
condition|)
return|return
name|git_column_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
literal|"branch"
argument_list|,
operator|&
name|colopts
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"color.branch"
argument_list|)
condition|)
block|{
name|branch_use_color
operator|=
name|git_config_colorbool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"color.branch."
argument_list|)
condition|)
block|{
name|int
name|slot
init|=
name|parse_branch_color_slot
argument_list|(
name|var
argument_list|,
literal|13
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
name|color_parse
argument_list|(
name|value
argument_list|,
name|var
argument_list|,
name|branch_colors
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_color_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|branch_get_color
specifier|static
specifier|const
name|char
modifier|*
name|branch_get_color
parameter_list|(
name|enum
name|color_branch
name|ix
parameter_list|)
block|{
if|if
condition|(
name|want_color
argument_list|(
name|branch_use_color
argument_list|)
condition|)
return|return
name|branch_colors
index|[
name|ix
index|]
return|;
return|return
literal|""
return|;
block|}
end_function
begin_function
DECL|function|branch_merged
specifier|static
name|int
name|branch_merged
parameter_list|(
name|int
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|commit
modifier|*
name|rev
parameter_list|,
name|struct
name|commit
modifier|*
name|head_rev
parameter_list|)
block|{
comment|/* 	 * This checks whether the merge bases of branch and HEAD (or 	 * the other branch this branch builds upon) contains the 	 * branch, which means that the branch has already been merged 	 * safely to HEAD (or the other branch). 	 */
name|struct
name|commit
modifier|*
name|reference_rev
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|reference_name
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|reference_name_to_free
init|=
name|NULL
decl_stmt|;
name|int
name|merged
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|REF_LOCAL_BRANCH
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|branch
operator|&&
name|branch
operator|->
name|merge
operator|&&
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|&&
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
operator|&&
operator|(
name|reference_name
operator|=
name|reference_name_to_free
operator|=
name|resolve_refdup
argument_list|(
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|reference_rev
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reference_rev
condition|)
name|reference_rev
operator|=
name|head_rev
expr_stmt|;
name|merged
operator|=
name|in_merge_bases
argument_list|(
name|rev
argument_list|,
operator|&
name|reference_rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * After the safety valve is fully redefined to "check with 	 * upstream, if any, otherwise with HEAD", we should just 	 * return the result of the in_merge_bases() above without 	 * any of the following code, but during the transition period, 	 * a gentle reminder is in order. 	 */
if|if
condition|(
operator|(
name|head_rev
operator|!=
name|reference_rev
operator|)
operator|&&
name|in_merge_bases
argument_list|(
name|rev
argument_list|,
operator|&
name|head_rev
argument_list|,
literal|1
argument_list|)
operator|!=
name|merged
condition|)
block|{
if|if
condition|(
name|merged
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"deleting branch '%s' that has been merged to\n"
literal|"         '%s', but not yet merged to HEAD."
argument_list|)
argument_list|,
name|name
argument_list|,
name|reference_name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|_
argument_list|(
literal|"not deleting branch '%s' that is not yet merged to\n"
literal|"         '%s', even though it is merged to HEAD."
argument_list|)
argument_list|,
name|name
argument_list|,
name|reference_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|reference_name_to_free
argument_list|)
expr_stmt|;
return|return
name|merged
return|;
block|}
end_function
begin_function
DECL|function|delete_branches
specifier|static
name|int
name|delete_branches
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|kinds
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|rev
decl_stmt|,
modifier|*
name|head_rev
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|remote_branch
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|bname
init|=
name|STRBUF_INIT
decl_stmt|;
switch|switch
condition|(
name|kinds
condition|)
block|{
case|case
name|REF_REMOTE_BRANCH
case|:
name|fmt
operator|=
literal|"refs/remotes/%s"
expr_stmt|;
comment|/* For subsequent UI messages */
name|remote_branch
operator|=
literal|1
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|REF_LOCAL_BRANCH
case|:
name|fmt
operator|=
literal|"refs/heads/%s"
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot use -a with -d"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|head_rev
operator|=
name|lookup_commit_reference
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head_rev
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Couldn't look up commit object for HEAD"
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|strbuf_release
argument_list|(
operator|&
name|bname
argument_list|)
control|)
block|{
name|strbuf_branchname
argument_list|(
operator|&
name|bname
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|kinds
operator|==
name|REF_LOCAL_BRANCH
operator|&&
operator|!
name|strcmp
argument_list|(
name|head
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot delete the branch '%s' "
literal|"which you are currently on."
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|mkpath
argument_list|(
name|fmt
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_ref
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|remote_branch
condition|?
name|_
argument_list|(
literal|"remote branch '%s' not found."
argument_list|)
else|:
name|_
argument_list|(
literal|"branch '%s' not found."
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|rev
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Couldn't look up commit object for '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|branch_merged
argument_list|(
name|kinds
argument_list|,
name|bname
operator|.
name|buf
argument_list|,
name|rev
argument_list|,
name|head_rev
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"The branch '%s' is not fully merged.\n"
literal|"If you are sure you want to delete it, "
literal|"run 'git branch -D %s'."
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|delete_ref
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|remote_branch
condition|?
name|_
argument_list|(
literal|"Error deleting remote branch '%s'"
argument_list|)
else|:
name|_
argument_list|(
literal|"Error deleting branch '%s'"
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
name|remote_branch
condition|?
name|_
argument_list|(
literal|"Deleted remote branch %s (was %s).\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"Deleted branch %s (was %s).\n"
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|,
name|find_unique_abbrev
argument_list|(
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"branch.%s"
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_rename_section
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Update of config-file failed"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function
begin_struct
DECL|struct|ref_item
struct|struct
name|ref_item
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|dest
name|char
modifier|*
name|dest
decl_stmt|;
DECL|member|kind
DECL|member|width
name|unsigned
name|int
name|kind
decl_stmt|,
name|width
decl_stmt|;
DECL|member|commit
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|ref_list
struct|struct
name|ref_list
block|{
DECL|member|revs
name|struct
name|rev_info
name|revs
decl_stmt|;
DECL|member|index
DECL|member|alloc
DECL|member|maxwidth
DECL|member|verbose
DECL|member|abbrev
name|int
name|index
decl_stmt|,
name|alloc
decl_stmt|,
name|maxwidth
decl_stmt|,
name|verbose
decl_stmt|,
name|abbrev
decl_stmt|;
DECL|member|list
name|struct
name|ref_item
modifier|*
name|list
decl_stmt|;
DECL|member|with_commit
name|struct
name|commit_list
modifier|*
name|with_commit
decl_stmt|;
DECL|member|kinds
name|int
name|kinds
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|resolve_symref
specifier|static
name|char
modifier|*
name|resolve_symref
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|dst
operator|=
name|resolve_ref_unsafe
argument_list|(
name|src
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dst
operator|&&
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|prefix
operator|&&
operator|(
name|cp
operator|=
name|skip_prefix
argument_list|(
name|dst
argument_list|,
name|prefix
argument_list|)
operator|)
condition|)
name|dst
operator|=
name|cp
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|dst
argument_list|)
return|;
block|}
end_function
begin_struct
DECL|struct|append_ref_cb
struct|struct
name|append_ref_cb
block|{
DECL|member|ref_list
name|struct
name|ref_list
modifier|*
name|ref_list
decl_stmt|;
DECL|member|pattern
specifier|const
name|char
modifier|*
modifier|*
name|pattern
decl_stmt|;
DECL|member|ret
name|int
name|ret
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|match_patterns
specifier|static
name|int
name|match_patterns
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
return|return
literal|1
return|;
comment|/* no pattern always matches */
while|while
condition|(
operator|*
name|pattern
condition|)
block|{
if|if
condition|(
operator|!
name|fnmatch
argument_list|(
operator|*
name|pattern
argument_list|,
name|refname
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
name|pattern
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|append_ref
specifier|static
name|int
name|append_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|append_ref_cb
modifier|*
name|cb
init|=
operator|(
expr|struct
name|append_ref_cb
operator|*
operator|)
operator|(
name|cb_data
operator|)
decl_stmt|;
name|struct
name|ref_list
modifier|*
name|ref_list
init|=
name|cb
operator|->
name|ref_list
decl_stmt|;
name|struct
name|ref_item
modifier|*
name|newitem
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|int
name|kind
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|orig_refname
init|=
name|refname
decl_stmt|;
specifier|static
struct|struct
block|{
name|int
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|pfxlen
decl_stmt|;
block|}
name|ref_kind
index|[]
init|=
block|{
block|{
name|REF_LOCAL_BRANCH
block|,
literal|"refs/heads/"
block|,
literal|11
block|}
block|,
block|{
name|REF_REMOTE_BRANCH
block|,
literal|"refs/remotes/"
block|,
literal|13
block|}
block|, 	}
struct|;
comment|/* Detect kind */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|ref_kind
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|prefix
operator|=
name|ref_kind
index|[
name|i
index|]
operator|.
name|prefix
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|refname
argument_list|,
name|prefix
argument_list|,
name|ref_kind
index|[
name|i
index|]
operator|.
name|pfxlen
argument_list|)
condition|)
continue|continue;
name|kind
operator|=
name|ref_kind
index|[
name|i
index|]
operator|.
name|kind
expr_stmt|;
name|refname
operator|+=
name|ref_kind
index|[
name|i
index|]
operator|.
name|pfxlen
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|ref_kind
argument_list|)
operator|<=
name|i
condition|)
return|return
literal|0
return|;
comment|/* Don't add types the caller doesn't want */
if|if
condition|(
operator|(
name|kind
operator|&
name|ref_list
operator|->
name|kinds
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|match_patterns
argument_list|(
name|cb
operator|->
name|pattern
argument_list|,
name|refname
argument_list|)
condition|)
return|return
literal|0
return|;
name|commit
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ref_list
operator|->
name|verbose
operator|||
name|ref_list
operator|->
name|with_commit
operator|||
name|merge_filter
operator|!=
name|NO_FILTER
condition|)
block|{
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
block|{
name|cb
operator|->
name|ret
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"branch '%s' does not point at a commit"
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Filter with with_commit if specified */
if|if
condition|(
operator|!
name|is_descendant_of
argument_list|(
name|commit
argument_list|,
name|ref_list
operator|->
name|with_commit
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|merge_filter
operator|!=
name|NO_FILTER
condition|)
name|add_pending_object
argument_list|(
operator|&
name|ref_list
operator|->
name|revs
argument_list|,
operator|(
expr|struct
name|object
operator|*
operator|)
name|commit
argument_list|,
name|refname
argument_list|)
expr_stmt|;
block|}
name|ALLOC_GROW
argument_list|(
name|ref_list
operator|->
name|list
argument_list|,
name|ref_list
operator|->
name|index
operator|+
literal|1
argument_list|,
name|ref_list
operator|->
name|alloc
argument_list|)
expr_stmt|;
comment|/* Record the new item */
name|newitem
operator|=
operator|&
operator|(
name|ref_list
operator|->
name|list
index|[
name|ref_list
operator|->
name|index
operator|++
index|]
operator|)
expr_stmt|;
name|newitem
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|refname
argument_list|)
expr_stmt|;
name|newitem
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|newitem
operator|->
name|commit
operator|=
name|commit
expr_stmt|;
name|newitem
operator|->
name|width
operator|=
name|utf8_strwidth
argument_list|(
name|refname
argument_list|)
expr_stmt|;
name|newitem
operator|->
name|dest
operator|=
name|resolve_symref
argument_list|(
name|orig_refname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
comment|/* adjust for "remotes/" */
if|if
condition|(
name|newitem
operator|->
name|kind
operator|==
name|REF_REMOTE_BRANCH
operator|&&
name|ref_list
operator|->
name|kinds
operator|!=
name|REF_REMOTE_BRANCH
condition|)
name|newitem
operator|->
name|width
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|newitem
operator|->
name|width
operator|>
name|ref_list
operator|->
name|maxwidth
condition|)
name|ref_list
operator|->
name|maxwidth
operator|=
name|newitem
operator|->
name|width
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|free_ref_list
specifier|static
name|void
name|free_ref_list
parameter_list|(
name|struct
name|ref_list
modifier|*
name|ref_list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ref_list
operator|->
name|index
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|ref_list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ref_list
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ref_cmp
specifier|static
name|int
name|ref_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|r1
parameter_list|,
specifier|const
name|void
modifier|*
name|r2
parameter_list|)
block|{
name|struct
name|ref_item
modifier|*
name|c1
init|=
operator|(
expr|struct
name|ref_item
operator|*
operator|)
operator|(
name|r1
operator|)
decl_stmt|;
name|struct
name|ref_item
modifier|*
name|c2
init|=
operator|(
expr|struct
name|ref_item
operator|*
operator|)
operator|(
name|r2
operator|)
decl_stmt|;
if|if
condition|(
name|c1
operator|->
name|kind
operator|!=
name|c2
operator|->
name|kind
condition|)
return|return
name|c1
operator|->
name|kind
operator|-
name|c2
operator|->
name|kind
return|;
return|return
name|strcmp
argument_list|(
name|c1
operator|->
name|name
argument_list|,
name|c2
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fill_tracking_info
specifier|static
name|void
name|fill_tracking_info
parameter_list|(
name|struct
name|strbuf
modifier|*
name|stat
parameter_list|,
specifier|const
name|char
modifier|*
name|branch_name
parameter_list|,
name|int
name|show_upstream_ref
parameter_list|)
block|{
name|int
name|ours
decl_stmt|,
name|theirs
decl_stmt|;
name|char
modifier|*
name|ref
init|=
name|NULL
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|branch_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|ours
argument_list|,
operator|&
name|theirs
argument_list|)
condition|)
block|{
if|if
condition|(
name|branch
operator|&&
name|branch
operator|->
name|merge
operator|&&
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
operator|&&
name|show_upstream_ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
literal|"[%s] "
argument_list|,
name|shorten_unambiguous_ref
argument_list|(
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|show_upstream_ref
condition|)
name|ref
operator|=
name|shorten_unambiguous_ref
argument_list|(
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ours
condition|)
block|{
if|if
condition|(
name|ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s: behind %d]"
argument_list|)
argument_list|,
name|ref
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[behind %d]"
argument_list|)
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|theirs
condition|)
block|{
if|if
condition|(
name|ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s: ahead %d]"
argument_list|)
argument_list|,
name|ref
argument_list|,
name|ours
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[ahead %d]"
argument_list|)
argument_list|,
name|ours
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s: ahead %d, behind %d]"
argument_list|)
argument_list|,
name|ref
argument_list|,
name|ours
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[ahead %d, behind %d]"
argument_list|)
argument_list|,
name|ours
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
name|stat
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|matches_merge_filter
specifier|static
name|int
name|matches_merge_filter
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|is_merged
decl_stmt|;
if|if
condition|(
name|merge_filter
operator|==
name|NO_FILTER
condition|)
return|return
literal|1
return|;
name|is_merged
operator|=
operator|!
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
expr_stmt|;
return|return
operator|(
name|is_merged
operator|==
operator|(
name|merge_filter
operator|==
name|SHOW_MERGED
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|add_verbose_info
specifier|static
name|void
name|add_verbose_info
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|struct
name|ref_item
modifier|*
name|item
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|abbrev
parameter_list|)
block|{
name|struct
name|strbuf
name|subject
init|=
name|STRBUF_INIT
decl_stmt|,
name|stat
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|sub
init|=
literal|" **** invalid ref ****"
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|item
operator|->
name|commit
decl_stmt|;
if|if
condition|(
name|commit
operator|&&
operator|!
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
block|{
name|pp_commit_easy
argument_list|(
name|CMIT_FMT_ONELINE
argument_list|,
name|commit
argument_list|,
operator|&
name|subject
argument_list|)
expr_stmt|;
name|sub
operator|=
name|subject
operator|.
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|->
name|kind
operator|==
name|REF_LOCAL_BRANCH
condition|)
name|fill_tracking_info
argument_list|(
operator|&
name|stat
argument_list|,
name|item
operator|->
name|name
argument_list|,
name|verbose
operator|>
literal|1
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|out
argument_list|,
literal|" %s %s%s"
argument_list|,
name|find_unique_abbrev
argument_list|(
name|item
operator|->
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|abbrev
argument_list|)
argument_list|,
name|stat
operator|.
name|buf
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|stat
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|subject
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|print_ref_item
specifier|static
name|void
name|print_ref_item
parameter_list|(
name|struct
name|ref_item
modifier|*
name|item
parameter_list|,
name|int
name|maxwidth
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|abbrev
parameter_list|,
name|int
name|current
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|color
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|item
operator|->
name|commit
decl_stmt|;
name|struct
name|strbuf
name|out
init|=
name|STRBUF_INIT
decl_stmt|,
name|name
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|matches_merge_filter
argument_list|(
name|commit
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|item
operator|->
name|kind
condition|)
block|{
case|case
name|REF_LOCAL_BRANCH
case|:
name|color
operator|=
name|BRANCH_COLOR_LOCAL
expr_stmt|;
break|break;
case|case
name|REF_REMOTE_BRANCH
case|:
name|color
operator|=
name|BRANCH_COLOR_REMOTE
expr_stmt|;
break|break;
default|default:
name|color
operator|=
name|BRANCH_COLOR_PLAIN
expr_stmt|;
break|break;
block|}
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|current
condition|)
block|{
name|c
operator|=
literal|'*'
expr_stmt|;
name|color
operator|=
name|BRANCH_COLOR_CURRENT
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|item
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|int
name|utf8_compensation
init|=
name|strlen
argument_list|(
name|name
operator|.
name|buf
argument_list|)
operator|-
name|utf8_strwidth
argument_list|(
name|name
operator|.
name|buf
argument_list|)
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out
argument_list|,
literal|"%c %s%-*s%s"
argument_list|,
name|c
argument_list|,
name|branch_get_color
argument_list|(
name|color
argument_list|)
argument_list|,
name|maxwidth
operator|+
name|utf8_compensation
argument_list|,
name|name
operator|.
name|buf
argument_list|,
name|branch_get_color
argument_list|(
name|BRANCH_COLOR_RESET
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addf
argument_list|(
operator|&
name|out
argument_list|,
literal|"%c %s%s%s"
argument_list|,
name|c
argument_list|,
name|branch_get_color
argument_list|(
name|color
argument_list|)
argument_list|,
name|name
operator|.
name|buf
argument_list|,
name|branch_get_color
argument_list|(
name|BRANCH_COLOR_RESET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|dest
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|out
argument_list|,
literal|" -> %s"
argument_list|,
name|item
operator|->
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
condition|)
comment|/* " f7c0c00 [ahead 58, behind 197] vcs-svn: drop obj_pool.h" */
name|add_verbose_info
argument_list|(
operator|&
name|out
argument_list|,
name|item
argument_list|,
name|verbose
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|column_active
argument_list|(
name|colopts
argument_list|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|verbose
operator|&&
literal|"--column and --verbose are incompatible"
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|output
argument_list|,
name|out
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|out
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|calc_maxwidth
specifier|static
name|int
name|calc_maxwidth
parameter_list|(
name|struct
name|ref_list
modifier|*
name|refs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|w
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|refs
operator|->
name|index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|matches_merge_filter
argument_list|(
name|refs
operator|->
name|list
index|[
name|i
index|]
operator|.
name|commit
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|refs
operator|->
name|list
index|[
name|i
index|]
operator|.
name|width
operator|>
name|w
condition|)
name|w
operator|=
name|refs
operator|->
name|list
index|[
name|i
index|]
operator|.
name|width
expr_stmt|;
block|}
return|return
name|w
return|;
block|}
end_function
begin_function
DECL|function|show_detached
specifier|static
name|void
name|show_detached
parameter_list|(
name|struct
name|ref_list
modifier|*
name|ref_list
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|head_commit
init|=
name|lookup_commit_reference_gently
argument_list|(
name|head_sha1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|head_commit
operator|&&
name|is_descendant_of
argument_list|(
name|head_commit
argument_list|,
name|ref_list
operator|->
name|with_commit
argument_list|)
condition|)
block|{
name|struct
name|ref_item
name|item
decl_stmt|;
name|item
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|_
argument_list|(
literal|"(no branch)"
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|.
name|width
operator|=
name|utf8_strwidth
argument_list|(
name|item
operator|.
name|name
argument_list|)
expr_stmt|;
name|item
operator|.
name|kind
operator|=
name|REF_LOCAL_BRANCH
expr_stmt|;
name|item
operator|.
name|dest
operator|=
name|NULL
expr_stmt|;
name|item
operator|.
name|commit
operator|=
name|head_commit
expr_stmt|;
if|if
condition|(
name|item
operator|.
name|width
operator|>
name|ref_list
operator|->
name|maxwidth
condition|)
name|ref_list
operator|->
name|maxwidth
operator|=
name|item
operator|.
name|width
expr_stmt|;
name|print_ref_item
argument_list|(
operator|&
name|item
argument_list|,
name|ref_list
operator|->
name|maxwidth
argument_list|,
name|ref_list
operator|->
name|verbose
argument_list|,
name|ref_list
operator|->
name|abbrev
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|item
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|print_ref_list
specifier|static
name|int
name|print_ref_list
parameter_list|(
name|int
name|kinds
parameter_list|,
name|int
name|detached
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|abbrev
parameter_list|,
name|struct
name|commit_list
modifier|*
name|with_commit
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|append_ref_cb
name|cb
decl_stmt|;
name|struct
name|ref_list
name|ref_list
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ref_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ref_list
argument_list|)
argument_list|)
expr_stmt|;
name|ref_list
operator|.
name|kinds
operator|=
name|kinds
expr_stmt|;
name|ref_list
operator|.
name|verbose
operator|=
name|verbose
expr_stmt|;
name|ref_list
operator|.
name|abbrev
operator|=
name|abbrev
expr_stmt|;
name|ref_list
operator|.
name|with_commit
operator|=
name|with_commit
expr_stmt|;
if|if
condition|(
name|merge_filter
operator|!=
name|NO_FILTER
condition|)
name|init_revisions
argument_list|(
operator|&
name|ref_list
operator|.
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|.
name|ref_list
operator|=
operator|&
name|ref_list
expr_stmt|;
name|cb
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
name|cb
operator|.
name|ret
operator|=
literal|0
expr_stmt|;
name|for_each_rawref
argument_list|(
name|append_ref
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_filter
operator|!=
name|NO_FILTER
condition|)
block|{
name|struct
name|commit
modifier|*
name|filter
decl_stmt|;
name|filter
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|merge_filter_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filter
condition|)
name|die
argument_list|(
literal|"object '%s' does not point to a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|merge_filter_ref
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|ref_list
operator|.
name|revs
argument_list|,
operator|(
expr|struct
name|object
operator|*
operator|)
name|filter
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ref_list
operator|.
name|revs
operator|.
name|limited
operator|=
literal|1
expr_stmt|;
name|prepare_revision_walk
argument_list|(
operator|&
name|ref_list
operator|.
name|revs
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|ref_list
operator|.
name|maxwidth
operator|=
name|calc_maxwidth
argument_list|(
operator|&
name|ref_list
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|ref_list
operator|.
name|list
argument_list|,
name|ref_list
operator|.
name|index
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref_item
argument_list|)
argument_list|,
name|ref_cmp
argument_list|)
expr_stmt|;
name|detached
operator|=
operator|(
name|detached
operator|&&
operator|(
name|kinds
operator|&
name|REF_LOCAL_BRANCH
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|detached
operator|&&
name|match_patterns
argument_list|(
name|pattern
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|show_detached
argument_list|(
operator|&
name|ref_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ref_list
operator|.
name|index
condition|;
name|i
operator|++
control|)
block|{
name|int
name|current
init|=
operator|!
name|detached
operator|&&
operator|(
name|ref_list
operator|.
name|list
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|REF_LOCAL_BRANCH
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|ref_list
operator|.
name|list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|head
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
operator|(
name|kinds
operator|!=
name|REF_REMOTE_BRANCH
operator|&&
name|ref_list
operator|.
name|list
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|REF_REMOTE_BRANCH
operator|)
condition|?
literal|"remotes/"
else|:
literal|""
decl_stmt|;
name|print_ref_item
argument_list|(
operator|&
name|ref_list
operator|.
name|list
index|[
name|i
index|]
argument_list|,
name|ref_list
operator|.
name|maxwidth
argument_list|,
name|verbose
argument_list|,
name|abbrev
argument_list|,
name|current
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
name|free_ref_list
argument_list|(
operator|&
name|ref_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|ret
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"some refs could not be read"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|ret
return|;
block|}
end_function
begin_function
DECL|function|rename_branch
specifier|static
name|void
name|rename_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|strbuf
name|oldref
init|=
name|STRBUF_INIT
decl_stmt|,
name|newref
init|=
name|STRBUF_INIT
decl_stmt|,
name|logmsg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|oldsection
init|=
name|STRBUF_INIT
decl_stmt|,
name|newsection
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|recovery
init|=
literal|0
decl_stmt|;
name|int
name|clobber_head_ok
decl_stmt|;
if|if
condition|(
operator|!
name|oldname
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot rename the current branch while not on any."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_check_branch_ref
argument_list|(
operator|&
name|oldref
argument_list|,
name|oldname
argument_list|)
condition|)
block|{
comment|/* 		 * Bad name --- this could be an attempt to rename a 		 * ref that we used to allow to be created by accident. 		 */
if|if
condition|(
name|ref_exists
argument_list|(
name|oldref
operator|.
name|buf
argument_list|)
condition|)
name|recovery
operator|=
literal|1
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"Invalid branch name: '%s'"
argument_list|)
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A command like "git branch -M currentbranch currentbranch" cannot 	 * cause the worktree to become inconsistent with HEAD, so allow it. 	 */
name|clobber_head_ok
operator|=
operator|!
name|strcmp
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|validate_new_branchname
argument_list|(
name|newname
argument_list|,
operator|&
name|newref
argument_list|,
name|force
argument_list|,
name|clobber_head_ok
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|logmsg
argument_list|,
literal|"Branch: renamed %s to %s"
argument_list|,
name|oldref
operator|.
name|buf
argument_list|,
name|newref
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename_ref
argument_list|(
name|oldref
operator|.
name|buf
argument_list|,
name|newref
operator|.
name|buf
argument_list|,
name|logmsg
operator|.
name|buf
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch rename failed"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|recovery
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Renamed a misnamed branch '%s' away"
argument_list|)
argument_list|,
name|oldref
operator|.
name|buf
operator|+
literal|11
argument_list|)
expr_stmt|;
comment|/* no need to pass logmsg here as HEAD didn't really move */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|oldname
argument_list|,
name|head
argument_list|)
operator|&&
name|create_symref
argument_list|(
literal|"HEAD"
argument_list|,
name|newref
operator|.
name|buf
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch renamed to %s, but HEAD is not updated!"
argument_list|)
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|oldsection
argument_list|,
literal|"branch.%s"
argument_list|,
name|oldref
operator|.
name|buf
operator|+
literal|11
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|oldref
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|newsection
argument_list|,
literal|"branch.%s"
argument_list|,
name|newref
operator|.
name|buf
operator|+
literal|11
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|newref
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_rename_section
argument_list|(
name|oldsection
operator|.
name|buf
argument_list|,
name|newsection
operator|.
name|buf
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch is renamed, but update of config-file failed"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|oldsection
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|newsection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|opt_parse_merge_filter
specifier|static
name|int
name|opt_parse_merge_filter
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|merge_filter
operator|=
operator|(
operator|(
name|opt
operator|->
name|long_name
index|[
literal|0
index|]
operator|==
literal|'n'
operator|)
condition|?
name|SHOW_NOT_MERGED
else|:
name|SHOW_MERGED
operator|)
expr_stmt|;
if|if
condition|(
name|unset
condition|)
name|merge_filter
operator|=
name|SHOW_NOT_MERGED
expr_stmt|;
comment|/* b/c for --no-merged */
if|if
condition|(
operator|!
name|arg
condition|)
name|arg
operator|=
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|arg
argument_list|,
name|merge_filter_ref
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"malformed object name %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|edit_description
specifier|static
specifier|const
name|char
name|edit_description
index|[]
init|=
literal|"BRANCH_DESCRIPTION"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|edit_branch_description
specifier|static
name|int
name|edit_branch_description
parameter_list|(
specifier|const
name|char
modifier|*
name|branch_name
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|name
init|=
name|STRBUF_INIT
decl_stmt|;
name|read_branch_desc
argument_list|(
operator|&
name|buf
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|.
name|len
operator|||
name|buf
operator|.
name|buf
index|[
name|buf
operator|.
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"# Please edit the description for the branch\n"
literal|"#   %s\n"
literal|"# Lines starting with '#' will be stripped.\n"
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
name|edit_description
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fwrite
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|buf
operator|.
name|len
argument_list|,
name|fp
argument_list|)
operator|<
name|buf
operator|.
name|len
operator|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"could not write branch description template: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|launch_editor
argument_list|(
name|git_path
argument_list|(
name|edit_description
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|stripspace
argument_list|(
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|name
argument_list|,
literal|"branch.%s.description"
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
name|status
operator|=
name|git_config_set
argument_list|(
name|name
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|cmd_branch
name|int
name|cmd_branch
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|delete
init|=
literal|0
decl_stmt|,
name|rename
init|=
literal|0
decl_stmt|,
name|force_create
init|=
literal|0
decl_stmt|,
name|list
init|=
literal|0
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|,
name|abbrev
init|=
operator|-
literal|1
decl_stmt|,
name|detached
init|=
literal|0
decl_stmt|;
name|int
name|reflog
init|=
literal|0
decl_stmt|,
name|edit_description
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|,
name|unset_upstream
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_upstream
init|=
name|NULL
decl_stmt|;
name|enum
name|branch_track
name|track
decl_stmt|;
name|int
name|kinds
init|=
name|REF_LOCAL_BRANCH
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|with_commit
init|=
name|NULL
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Generic options"
argument_list|)
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|verbose
argument_list|,
name|N_
argument_list|(
literal|"show hash and subject, give twice for upstream branch"
argument_list|)
argument_list|)
block|,
name|OPT__QUIET
argument_list|(
operator|&
name|quiet
argument_list|,
name|N_
argument_list|(
literal|"suppress informational messages"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'t'
argument_list|,
literal|"track"
argument_list|,
operator|&
name|track
argument_list|,
name|N_
argument_list|(
literal|"set up tracking mode (see git-pull(1))"
argument_list|)
argument_list|,
name|BRANCH_TRACK_EXPLICIT
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"set-upstream"
argument_list|,
operator|&
name|track
argument_list|,
name|N_
argument_list|(
literal|"change upstream info"
argument_list|)
argument_list|,
name|BRANCH_TRACK_OVERRIDE
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'u'
argument_list|,
literal|"set-upstream-to"
argument_list|,
operator|&
name|new_upstream
argument_list|,
literal|"upstream"
argument_list|,
literal|"change the upstream info"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"unset-upstream"
argument_list|,
operator|&
name|unset_upstream
argument_list|,
literal|"Unset the upstream info"
argument_list|)
block|,
name|OPT__COLOR
argument_list|(
operator|&
name|branch_use_color
argument_list|,
name|N_
argument_list|(
literal|"use colored output"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'r'
argument_list|,
literal|"remotes"
argument_list|,
operator|&
name|kinds
argument_list|,
name|N_
argument_list|(
literal|"act on remote-tracking branches"
argument_list|)
argument_list|,
name|REF_REMOTE_BRANCH
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"contains"
block|,
operator|&
name|with_commit
block|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
block|,
name|N_
argument_list|(
literal|"print only branches that contain the commit"
argument_list|)
block|,
name|PARSE_OPT_LASTARG_DEFAULT
block|,
name|parse_opt_with_commit
block|,
operator|(
name|intptr_t
operator|)
literal|"HEAD"
block|, 		}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"with"
block|,
operator|&
name|with_commit
block|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
block|,
name|N_
argument_list|(
literal|"print only branches that contain the commit"
argument_list|)
block|,
name|PARSE_OPT_HIDDEN
operator||
name|PARSE_OPT_LASTARG_DEFAULT
block|,
name|parse_opt_with_commit
block|,
operator|(
name|intptr_t
operator|)
literal|"HEAD"
block|, 		}
block|,
name|OPT__ABBREV
argument_list|(
operator|&
name|abbrev
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Specific git-branch actions:"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'a'
argument_list|,
literal|"all"
argument_list|,
operator|&
name|kinds
argument_list|,
name|N_
argument_list|(
literal|"list both remote-tracking and local branches"
argument_list|)
argument_list|,
name|REF_REMOTE_BRANCH
operator||
name|REF_LOCAL_BRANCH
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'d'
argument_list|,
literal|"delete"
argument_list|,
operator|&
name|delete
argument_list|,
name|N_
argument_list|(
literal|"delete fully merged branch"
argument_list|)
argument_list|,
literal|1
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'D'
argument_list|,
name|NULL
argument_list|,
operator|&
name|delete
argument_list|,
name|N_
argument_list|(
literal|"delete branch (even if not merged)"
argument_list|)
argument_list|,
literal|2
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'m'
argument_list|,
literal|"move"
argument_list|,
operator|&
name|rename
argument_list|,
name|N_
argument_list|(
literal|"move/rename a branch and its reflog"
argument_list|)
argument_list|,
literal|1
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'M'
argument_list|,
name|NULL
argument_list|,
operator|&
name|rename
argument_list|,
name|N_
argument_list|(
literal|"move/rename a branch, even if target exists"
argument_list|)
argument_list|,
literal|2
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"list"
argument_list|,
operator|&
name|list
argument_list|,
name|N_
argument_list|(
literal|"list branch names"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'l'
argument_list|,
literal|"create-reflog"
argument_list|,
operator|&
name|reflog
argument_list|,
name|N_
argument_list|(
literal|"create the branch's reflog"
argument_list|)
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"edit-description"
argument_list|,
operator|&
name|edit_description
argument_list|,
name|N_
argument_list|(
literal|"edit the description for the branch"
argument_list|)
argument_list|)
block|,
name|OPT__FORCE
argument_list|(
operator|&
name|force_create
argument_list|,
name|N_
argument_list|(
literal|"force creation (when already exists)"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"no-merged"
block|,
operator|&
name|merge_filter_ref
block|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
block|,
name|N_
argument_list|(
literal|"print only not merged branches"
argument_list|)
block|,
name|PARSE_OPT_LASTARG_DEFAULT
operator||
name|PARSE_OPT_NONEG
block|,
name|opt_parse_merge_filter
block|,
operator|(
name|intptr_t
operator|)
literal|"HEAD"
block|, 		}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"merged"
block|,
operator|&
name|merge_filter_ref
block|,
name|N_
argument_list|(
literal|"commit"
argument_list|)
block|,
name|N_
argument_list|(
literal|"print only merged branches"
argument_list|)
block|,
name|PARSE_OPT_LASTARG_DEFAULT
operator||
name|PARSE_OPT_NONEG
block|,
name|opt_parse_merge_filter
block|,
operator|(
name|intptr_t
operator|)
literal|"HEAD"
block|, 		}
block|,
name|OPT_COLUMN
argument_list|(
literal|0
argument_list|,
literal|"column"
argument_list|,
operator|&
name|colopts
argument_list|,
name|N_
argument_list|(
literal|"list branches in columns"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|, 	}
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_branch_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|track
operator|=
name|git_branch_track
expr_stmt|;
name|head
operator|=
name|resolve_refdup
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve HEAD as a valid ref."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|head
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
name|detached
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|head
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"HEAD not found below refs/heads!"
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|+=
literal|11
expr_stmt|;
block|}
name|hashcpy
argument_list|(
name|merge_filter_ref
argument_list|,
name|head_sha1
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|builtin_branch_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delete
operator|&&
operator|!
name|rename
operator|&&
operator|!
name|edit_description
operator|&&
operator|!
name|new_upstream
operator|&&
operator|!
name|unset_upstream
operator|&&
name|argc
operator|==
literal|0
condition|)
name|list
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|delete
operator|+
operator|!
operator|!
name|rename
operator|+
operator|!
operator|!
name|force_create
operator|+
operator|!
operator|!
name|list
operator|+
operator|!
operator|!
name|new_upstream
operator|+
operator|!
operator|!
name|unset_upstream
operator|>
literal|1
condition|)
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|abbrev
operator|==
operator|-
literal|1
condition|)
name|abbrev
operator|=
name|DEFAULT_ABBREV
expr_stmt|;
name|finalize_colopts
argument_list|(
operator|&
name|colopts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|explicitly_enable_column
argument_list|(
name|colopts
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--column and --verbose are incompatible"
argument_list|)
argument_list|)
expr_stmt|;
name|colopts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|delete
condition|)
return|return
name|delete_branches
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|delete
operator|>
literal|1
argument_list|,
name|kinds
argument_list|,
name|quiet
argument_list|)
return|;
elseif|else
if|if
condition|(
name|list
condition|)
block|{
name|int
name|ret
init|=
name|print_ref_list
argument_list|(
name|kinds
argument_list|,
name|detached
argument_list|,
name|verbose
argument_list|,
name|abbrev
argument_list|,
name|with_commit
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|print_columns
argument_list|(
operator|&
name|output
argument_list|,
name|colopts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|edit_description
condition|)
block|{
specifier|const
name|char
modifier|*
name|branch_name
decl_stmt|;
name|struct
name|strbuf
name|branch_ref
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|detached
condition|)
name|die
argument_list|(
literal|"Cannot give description to detached HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
name|branch_name
operator|=
name|head
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|branch_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|branch_ref
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref_exists
argument_list|(
name|branch_ref
operator|.
name|buf
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|branch_ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
return|return
name|error
argument_list|(
literal|"No commit on branch '%s' yet."
argument_list|,
name|branch_name
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
literal|"No such branch '%s'."
argument_list|,
name|branch_name
argument_list|)
return|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|branch_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_branch_description
argument_list|(
name|branch_name
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rename
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|rename_branch
argument_list|(
name|head
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|rename
operator|>
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|rename_branch
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|rename
operator|>
literal|1
argument_list|)
expr_stmt|;
else|else
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_upstream
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ref_exists
argument_list|(
name|branch
operator|->
name|refname
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"branch '%s' does not exist"
argument_list|)
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * create_branch takes care of setting up the tracking 		 * info and making sure new_upstream is correct 		 */
name|create_branch
argument_list|(
name|head
argument_list|,
name|branch
operator|->
name|name
argument_list|,
name|new_upstream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|quiet
argument_list|,
name|BRANCH_TRACK_OVERRIDE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unset_upstream
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|branch_has_merge_config
argument_list|(
name|branch
argument_list|)
condition|)
block|{
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch '%s' has no upstream information"
argument_list|)
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"branch.%s.remote"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|git_config_set_multivar
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"branch.%s.merge"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|git_config_set_multivar
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|argc
operator|<=
literal|2
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|branch_existed
init|=
literal|0
decl_stmt|,
name|remote_tracking
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|kinds
operator|!=
name|REF_LOCAL_BRANCH
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"-a and -r options to 'git branch' do not make sense with a branch name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|track
operator|==
name|BRANCH_TRACK_OVERRIDE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"The --set-upstream flag is deprecated and will be removed. Consider using --track or --set-upstream-to\n"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"refs/remotes/%s"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|remote_tracking
operator|=
name|ref_exists
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|branch_existed
operator|=
name|ref_exists
argument_list|(
name|branch
operator|->
name|refname
argument_list|)
expr_stmt|;
name|create_branch
argument_list|(
name|head
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|argc
operator|==
literal|2
operator|)
condition|?
name|argv
index|[
literal|1
index|]
else|:
name|head
argument_list|,
name|force_create
argument_list|,
name|reflog
argument_list|,
literal|0
argument_list|,
name|quiet
argument_list|,
name|track
argument_list|)
expr_stmt|;
comment|/* 		 * We only show the instructions if the user gave us 		 * one branch which doesn't exist locally, but is the 		 * name of a remote-tracking branch. 		 */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|track
operator|==
name|BRANCH_TRACK_OVERRIDE
operator|&&
operator|!
name|branch_existed
operator|&&
name|remote_tracking
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\nIf you wanted to make '%s' track '%s', do this:\n\n"
argument_list|)
argument_list|,
name|head
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"    git branch -d %s\n"
argument_list|)
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"    git branch --set-upstream-to %s\n"
argument_list|)
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
