begin_unit
begin_comment
comment|/*  * Builtin "git branch"  *  * Copyright (c) 2006 Kristian HÃ¸gsberg<krh@redhat.com>  * Based on git-branch.sh by Junio C Hamano.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"column.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"wt-status.h"
end_include
begin_include
include|#
directive|include
file|"ref-filter.h"
end_include
begin_include
include|#
directive|include
file|"worktree.h"
end_include
begin_decl_stmt
DECL|variable|builtin_branch_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_branch_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git branch [<options>] [-r | -a] [--merged | --no-merged]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git branch [<options>] [-l] [-f]<branch-name> [<start-point>]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git branch [<options>] [-r] (-d | -D)<branch-name>..."
argument_list|)
block|,
name|N_
argument_list|(
literal|"git branch [<options>] (-m | -M) [<old-branch>]<new-branch>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git branch [<options>] [-r | -a] [--points-at]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|head
specifier|static
specifier|const
name|char
modifier|*
name|head
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|head_sha1
specifier|static
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_use_color
specifier|static
name|int
name|branch_use_color
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branch_colors
specifier|static
name|char
name|branch_colors
index|[]
index|[
name|COLOR_MAXLEN
index|]
init|=
block|{
name|GIT_COLOR_RESET
block|,
name|GIT_COLOR_NORMAL
block|,
comment|/* PLAIN */
name|GIT_COLOR_RED
block|,
comment|/* REMOTE */
name|GIT_COLOR_NORMAL
block|,
comment|/* LOCAL */
name|GIT_COLOR_GREEN
block|,
comment|/* CURRENT */
name|GIT_COLOR_BLUE
block|,
comment|/* UPSTREAM */
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enum|color_branch
enum|enum
name|color_branch
block|{
DECL|enumerator|BRANCH_COLOR_RESET
name|BRANCH_COLOR_RESET
init|=
literal|0
block|,
DECL|enumerator|BRANCH_COLOR_PLAIN
name|BRANCH_COLOR_PLAIN
init|=
literal|1
block|,
DECL|enumerator|BRANCH_COLOR_REMOTE
name|BRANCH_COLOR_REMOTE
init|=
literal|2
block|,
DECL|enumerator|BRANCH_COLOR_LOCAL
name|BRANCH_COLOR_LOCAL
init|=
literal|3
block|,
DECL|enumerator|BRANCH_COLOR_CURRENT
name|BRANCH_COLOR_CURRENT
init|=
literal|4
block|,
DECL|enumerator|BRANCH_COLOR_UPSTREAM
name|BRANCH_COLOR_UPSTREAM
init|=
literal|5
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|output
specifier|static
name|struct
name|string_list
name|output
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|colopts
specifier|static
name|unsigned
name|int
name|colopts
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parse_branch_color_slot
specifier|static
name|int
name|parse_branch_color_slot
parameter_list|(
specifier|const
name|char
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|slot
argument_list|,
literal|"plain"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_PLAIN
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|slot
argument_list|,
literal|"reset"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_RESET
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|slot
argument_list|,
literal|"remote"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_REMOTE
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|slot
argument_list|,
literal|"local"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_LOCAL
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|slot
argument_list|,
literal|"current"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_CURRENT
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|slot
argument_list|,
literal|"upstream"
argument_list|)
condition|)
return|return
name|BRANCH_COLOR_UPSTREAM
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|git_branch_config
specifier|static
name|int
name|git_branch_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|slot_name
decl_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|var
argument_list|,
literal|"column."
argument_list|)
condition|)
return|return
name|git_column_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
literal|"branch"
argument_list|,
operator|&
name|colopts
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"color.branch"
argument_list|)
condition|)
block|{
name|branch_use_color
operator|=
name|git_config_colorbool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|skip_prefix
argument_list|(
name|var
argument_list|,
literal|"color.branch."
argument_list|,
operator|&
name|slot_name
argument_list|)
condition|)
block|{
name|int
name|slot
init|=
name|parse_branch_color_slot
argument_list|(
name|slot_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
return|return
name|color_parse
argument_list|(
name|value
argument_list|,
name|branch_colors
index|[
name|slot
index|]
argument_list|)
return|;
block|}
return|return
name|git_color_default_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|branch_get_color
specifier|static
specifier|const
name|char
modifier|*
name|branch_get_color
parameter_list|(
name|enum
name|color_branch
name|ix
parameter_list|)
block|{
if|if
condition|(
name|want_color
argument_list|(
name|branch_use_color
argument_list|)
condition|)
return|return
name|branch_colors
index|[
name|ix
index|]
return|;
return|return
literal|""
return|;
block|}
end_function
begin_function
DECL|function|branch_merged
specifier|static
name|int
name|branch_merged
parameter_list|(
name|int
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|commit
modifier|*
name|rev
parameter_list|,
name|struct
name|commit
modifier|*
name|head_rev
parameter_list|)
block|{
comment|/* 	 * This checks whether the merge bases of branch and HEAD (or 	 * the other branch this branch builds upon) contains the 	 * branch, which means that the branch has already been merged 	 * safely to HEAD (or the other branch). 	 */
name|struct
name|commit
modifier|*
name|reference_rev
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|reference_name
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|reference_name_to_free
init|=
name|NULL
decl_stmt|;
name|int
name|merged
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|FILTER_REFS_BRANCHES
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|upstream
init|=
name|branch_get_upstream
argument_list|(
name|branch
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|upstream
operator|&&
operator|(
name|reference_name
operator|=
name|reference_name_to_free
operator|=
name|resolve_refdup
argument_list|(
name|upstream
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|reference_rev
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reference_rev
condition|)
name|reference_rev
operator|=
name|head_rev
expr_stmt|;
name|merged
operator|=
name|in_merge_bases
argument_list|(
name|rev
argument_list|,
name|reference_rev
argument_list|)
expr_stmt|;
comment|/* 	 * After the safety valve is fully redefined to "check with 	 * upstream, if any, otherwise with HEAD", we should just 	 * return the result of the in_merge_bases() above without 	 * any of the following code, but during the transition period, 	 * a gentle reminder is in order. 	 */
if|if
condition|(
operator|(
name|head_rev
operator|!=
name|reference_rev
operator|)
operator|&&
name|in_merge_bases
argument_list|(
name|rev
argument_list|,
name|head_rev
argument_list|)
operator|!=
name|merged
condition|)
block|{
if|if
condition|(
name|merged
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"deleting branch '%s' that has been merged to\n"
literal|"         '%s', but not yet merged to HEAD."
argument_list|)
argument_list|,
name|name
argument_list|,
name|reference_name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|_
argument_list|(
literal|"not deleting branch '%s' that is not yet merged to\n"
literal|"         '%s', even though it is merged to HEAD."
argument_list|)
argument_list|,
name|name
argument_list|,
name|reference_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|reference_name_to_free
argument_list|)
expr_stmt|;
return|return
name|merged
return|;
block|}
end_function
begin_function
DECL|function|check_branch_commit
specifier|static
name|int
name|check_branch_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|branchname
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|commit
modifier|*
name|head_rev
parameter_list|,
name|int
name|kinds
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|rev
init|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rev
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Couldn't look up commit object for '%s'"
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|branch_merged
argument_list|(
name|kinds
argument_list|,
name|branchname
argument_list|,
name|rev
argument_list|,
name|head_rev
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"The branch '%s' is not fully merged.\n"
literal|"If you are sure you want to delete it, "
literal|"run 'git branch -D %s'."
argument_list|)
argument_list|,
name|branchname
argument_list|,
name|branchname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|delete_branch_config
specifier|static
name|void
name|delete_branch_config
parameter_list|(
specifier|const
name|char
modifier|*
name|branchname
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"branch.%s"
argument_list|,
name|branchname
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_rename_section
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Update of config-file failed"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|delete_branches
specifier|static
name|int
name|delete_branches
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|kinds
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|head_rev
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|remote_branch
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|bname
init|=
name|STRBUF_INIT
decl_stmt|;
switch|switch
condition|(
name|kinds
condition|)
block|{
case|case
name|FILTER_REFS_REMOTES
case|:
name|fmt
operator|=
literal|"refs/remotes/%s"
expr_stmt|;
comment|/* For subsequent UI messages */
name|remote_branch
operator|=
literal|1
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FILTER_REFS_BRANCHES
case|:
name|fmt
operator|=
literal|"refs/heads/%s"
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot use -a with -d"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|head_rev
operator|=
name|lookup_commit_reference
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head_rev
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Couldn't look up commit object for HEAD"
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|strbuf_release
argument_list|(
operator|&
name|bname
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|strbuf_branchname
argument_list|(
operator|&
name|bname
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|mkpathdup
argument_list|(
name|fmt
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kinds
operator|==
name|FILTER_REFS_BRANCHES
condition|)
block|{
name|char
modifier|*
name|worktree
init|=
name|find_shared_symref
argument_list|(
literal|"HEAD"
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|worktree
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot delete branch '%s' "
literal|"checked out at '%s'"
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|,
name|worktree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|worktree
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|target
operator|=
name|resolve_ref_unsafe
argument_list|(
name|name
argument_list|,
name|RESOLVE_REF_READING
operator||
name|RESOLVE_REF_NO_RECURSE
operator||
name|RESOLVE_REF_ALLOW_BAD_NAME
argument_list|,
name|sha1
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|error
argument_list|(
name|remote_branch
condition|?
name|_
argument_list|(
literal|"remote-tracking branch '%s' not found."
argument_list|)
else|:
name|_
argument_list|(
literal|"branch '%s' not found."
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|REF_ISSYMREF
operator||
name|REF_ISBROKEN
operator|)
operator|)
operator|&&
name|check_branch_commit
argument_list|(
name|bname
operator|.
name|buf
argument_list|,
name|name
argument_list|,
name|sha1
argument_list|,
name|head_rev
argument_list|,
name|kinds
argument_list|,
name|force
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|delete_ref
argument_list|(
name|name
argument_list|,
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
condition|?
name|NULL
else|:
name|sha1
argument_list|,
name|REF_NODEREF
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|remote_branch
condition|?
name|_
argument_list|(
literal|"Error deleting remote-tracking branch '%s'"
argument_list|)
else|:
name|_
argument_list|(
literal|"Error deleting branch '%s'"
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
name|remote_branch
condition|?
name|_
argument_list|(
literal|"Deleted remote-tracking branch %s (was %s).\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"Deleted branch %s (was %s).\n"
argument_list|)
argument_list|,
name|bname
operator|.
name|buf
argument_list|,
operator|(
name|flags
operator|&
name|REF_ISBROKEN
operator|)
condition|?
literal|"broken"
else|:
operator|(
name|flags
operator|&
name|REF_ISSYMREF
operator|)
condition|?
name|target
else|:
name|find_unique_abbrev
argument_list|(
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|delete_branch_config
argument_list|(
name|bname
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function
begin_function
DECL|function|fill_tracking_info
specifier|static
name|void
name|fill_tracking_info
parameter_list|(
name|struct
name|strbuf
modifier|*
name|stat
parameter_list|,
specifier|const
name|char
modifier|*
name|branch_name
parameter_list|,
name|int
name|show_upstream_ref
parameter_list|)
block|{
name|int
name|ours
decl_stmt|,
name|theirs
decl_stmt|;
name|char
modifier|*
name|ref
init|=
name|NULL
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|branch_name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|upstream
decl_stmt|;
name|struct
name|strbuf
name|fancy
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|upstream_is_gone
init|=
literal|0
decl_stmt|;
name|int
name|added_decoration
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|ours
argument_list|,
operator|&
name|theirs
argument_list|,
operator|&
name|upstream
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|upstream
condition|)
return|return;
name|upstream_is_gone
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|show_upstream_ref
condition|)
block|{
name|ref
operator|=
name|shorten_unambiguous_ref
argument_list|(
name|upstream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_color
argument_list|(
name|branch_use_color
argument_list|)
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|fancy
argument_list|,
literal|"%s%s%s"
argument_list|,
name|branch_get_color
argument_list|(
name|BRANCH_COLOR_UPSTREAM
argument_list|)
argument_list|,
name|ref
argument_list|,
name|branch_get_color
argument_list|(
name|BRANCH_COLOR_RESET
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|fancy
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|upstream_is_gone
condition|)
block|{
if|if
condition|(
name|show_upstream_ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s: gone]"
argument_list|)
argument_list|,
name|fancy
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
name|added_decoration
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ours
operator|&&
operator|!
name|theirs
condition|)
block|{
if|if
condition|(
name|show_upstream_ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s]"
argument_list|)
argument_list|,
name|fancy
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
name|added_decoration
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ours
condition|)
block|{
if|if
condition|(
name|show_upstream_ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s: behind %d]"
argument_list|)
argument_list|,
name|fancy
operator|.
name|buf
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[behind %d]"
argument_list|)
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|theirs
condition|)
block|{
if|if
condition|(
name|show_upstream_ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s: ahead %d]"
argument_list|)
argument_list|,
name|fancy
operator|.
name|buf
argument_list|,
name|ours
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[ahead %d]"
argument_list|)
argument_list|,
name|ours
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|show_upstream_ref
condition|)
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[%s: ahead %d, behind %d]"
argument_list|)
argument_list|,
name|fancy
operator|.
name|buf
argument_list|,
name|ours
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
name|stat
argument_list|,
name|_
argument_list|(
literal|"[ahead %d, behind %d]"
argument_list|)
argument_list|,
name|ours
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|fancy
argument_list|)
expr_stmt|;
if|if
condition|(
name|added_decoration
condition|)
name|strbuf_addch
argument_list|(
name|stat
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_verbose_info
specifier|static
name|void
name|add_verbose_info
parameter_list|(
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
name|struct
name|ref_array_item
modifier|*
name|item
parameter_list|,
name|struct
name|ref_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|struct
name|strbuf
name|subject
init|=
name|STRBUF_INIT
decl_stmt|,
name|stat
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|sub
init|=
name|_
argument_list|(
literal|" **** invalid ref ****"
argument_list|)
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|item
operator|->
name|commit
decl_stmt|;
if|if
condition|(
operator|!
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
block|{
name|pp_commit_easy
argument_list|(
name|CMIT_FMT_ONELINE
argument_list|,
name|commit
argument_list|,
operator|&
name|subject
argument_list|)
expr_stmt|;
name|sub
operator|=
name|subject
operator|.
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|->
name|kind
operator|==
name|FILTER_REFS_BRANCHES
condition|)
name|fill_tracking_info
argument_list|(
operator|&
name|stat
argument_list|,
name|refname
argument_list|,
name|filter
operator|->
name|verbose
operator|>
literal|1
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|out
argument_list|,
literal|" %s %s%s"
argument_list|,
name|find_unique_abbrev
argument_list|(
name|item
operator|->
name|commit
operator|->
name|object
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|filter
operator|->
name|abbrev
argument_list|)
argument_list|,
name|stat
operator|.
name|buf
argument_list|,
name|sub
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|stat
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|subject
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_head_description
specifier|static
name|char
modifier|*
name|get_head_description
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|strbuf
name|desc
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|wt_status_state
name|state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|wt_status_get_state
argument_list|(
operator|&
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|rebase_in_progress
operator|||
name|state
operator|.
name|rebase_interactive_in_progress
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|desc
argument_list|,
name|_
argument_list|(
literal|"(no branch, rebasing %s)"
argument_list|)
argument_list|,
name|state
operator|.
name|branch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|.
name|bisect_in_progress
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|desc
argument_list|,
name|_
argument_list|(
literal|"(no branch, bisect started on %s)"
argument_list|)
argument_list|,
name|state
operator|.
name|branch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|.
name|detached_from
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|detached_at
condition|)
comment|/* TRANSLATORS: make sure this matches 			   "HEAD detached at " in wt-status.c */
name|strbuf_addf
argument_list|(
operator|&
name|desc
argument_list|,
name|_
argument_list|(
literal|"(HEAD detached at %s)"
argument_list|)
argument_list|,
name|state
operator|.
name|detached_from
argument_list|)
expr_stmt|;
else|else
comment|/* TRANSLATORS: make sure this matches 			   "HEAD detached from " in wt-status.c */
name|strbuf_addf
argument_list|(
operator|&
name|desc
argument_list|,
name|_
argument_list|(
literal|"(HEAD detached from %s)"
argument_list|)
argument_list|,
name|state
operator|.
name|detached_from
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|desc
argument_list|,
name|_
argument_list|(
literal|"(no branch)"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|onto
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|detached_from
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|format_and_print_ref_item
specifier|static
name|void
name|format_and_print_ref_item
parameter_list|(
name|struct
name|ref_array_item
modifier|*
name|item
parameter_list|,
name|int
name|maxwidth
parameter_list|,
name|struct
name|ref_filter
modifier|*
name|filter
parameter_list|,
specifier|const
name|char
modifier|*
name|remote_prefix
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|current
init|=
literal|0
decl_stmt|;
name|int
name|color
decl_stmt|;
name|struct
name|strbuf
name|out
init|=
name|STRBUF_INIT
decl_stmt|,
name|name
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix_to_show
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix_to_skip
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
init|=
name|item
operator|->
name|refname
decl_stmt|;
name|char
modifier|*
name|to_free
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|item
operator|->
name|kind
condition|)
block|{
case|case
name|FILTER_REFS_BRANCHES
case|:
name|prefix_to_skip
operator|=
literal|"refs/heads/"
expr_stmt|;
name|skip_prefix
argument_list|(
name|desc
argument_list|,
name|prefix_to_skip
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filter
operator|->
name|detached
operator|&&
operator|!
name|strcmp
argument_list|(
name|desc
argument_list|,
name|head
argument_list|)
condition|)
name|current
operator|=
literal|1
expr_stmt|;
else|else
name|color
operator|=
name|BRANCH_COLOR_LOCAL
expr_stmt|;
break|break;
case|case
name|FILTER_REFS_REMOTES
case|:
name|prefix_to_skip
operator|=
literal|"refs/remotes/"
expr_stmt|;
name|skip_prefix
argument_list|(
name|desc
argument_list|,
name|prefix_to_skip
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|color
operator|=
name|BRANCH_COLOR_REMOTE
expr_stmt|;
name|prefix_to_show
operator|=
name|remote_prefix
expr_stmt|;
break|break;
case|case
name|FILTER_REFS_DETACHED_HEAD
case|:
name|desc
operator|=
name|to_free
operator|=
name|get_head_description
argument_list|()
expr_stmt|;
name|current
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|color
operator|=
name|BRANCH_COLOR_PLAIN
expr_stmt|;
break|break;
block|}
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|current
condition|)
block|{
name|c
operator|=
literal|'*'
expr_stmt|;
name|color
operator|=
name|BRANCH_COLOR_CURRENT
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
operator|&
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix_to_show
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|->
name|verbose
condition|)
block|{
name|int
name|utf8_compensation
init|=
name|strlen
argument_list|(
name|name
operator|.
name|buf
argument_list|)
operator|-
name|utf8_strwidth
argument_list|(
name|name
operator|.
name|buf
argument_list|)
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out
argument_list|,
literal|"%c %s%-*s%s"
argument_list|,
name|c
argument_list|,
name|branch_get_color
argument_list|(
name|color
argument_list|)
argument_list|,
name|maxwidth
operator|+
name|utf8_compensation
argument_list|,
name|name
operator|.
name|buf
argument_list|,
name|branch_get_color
argument_list|(
name|BRANCH_COLOR_RESET
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addf
argument_list|(
operator|&
name|out
argument_list|,
literal|"%c %s%s%s"
argument_list|,
name|c
argument_list|,
name|branch_get_color
argument_list|(
name|color
argument_list|)
argument_list|,
name|name
operator|.
name|buf
argument_list|,
name|branch_get_color
argument_list|(
name|BRANCH_COLOR_RESET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|symref
condition|)
block|{
specifier|const
name|char
modifier|*
name|symref
init|=
name|item
operator|->
name|symref
decl_stmt|;
if|if
condition|(
name|prefix_to_skip
condition|)
name|skip_prefix
argument_list|(
name|symref
argument_list|,
name|prefix_to_skip
argument_list|,
operator|&
name|symref
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|out
argument_list|,
literal|" -> %s"
argument_list|,
name|symref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filter
operator|->
name|verbose
condition|)
comment|/* " f7c0c00 [ahead 58, behind 197] vcs-svn: drop obj_pool.h" */
name|add_verbose_info
argument_list|(
operator|&
name|out
argument_list|,
name|item
argument_list|,
name|filter
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|column_active
argument_list|(
name|colopts
argument_list|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|filter
operator|->
name|verbose
operator|&&
literal|"--column and --verbose are incompatible"
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|output
argument_list|,
name|out
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|out
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|calc_maxwidth
specifier|static
name|int
name|calc_maxwidth
parameter_list|(
name|struct
name|ref_array
modifier|*
name|refs
parameter_list|,
name|int
name|remote_bonus
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|refs
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ref_array_item
modifier|*
name|it
init|=
name|refs
operator|->
name|items
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
init|=
name|it
operator|->
name|refname
decl_stmt|;
name|int
name|w
decl_stmt|;
name|skip_prefix
argument_list|(
name|it
operator|->
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|skip_prefix
argument_list|(
name|it
operator|->
name|refname
argument_list|,
literal|"refs/remotes/"
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|w
operator|=
name|utf8_strwidth
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|kind
operator|==
name|FILTER_REFS_REMOTES
condition|)
name|w
operator|+=
name|remote_bonus
expr_stmt|;
if|if
condition|(
name|w
operator|>
name|max
condition|)
name|max
operator|=
name|w
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
end_function
begin_function
DECL|function|print_ref_list
specifier|static
name|void
name|print_ref_list
parameter_list|(
name|struct
name|ref_filter
modifier|*
name|filter
parameter_list|,
name|struct
name|ref_sorting
modifier|*
name|sorting
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ref_array
name|array
decl_stmt|;
name|int
name|maxwidth
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|remote_prefix
init|=
literal|""
decl_stmt|;
comment|/* 	 * If we are listing more than just remote branches, 	 * then remote branches will have a "remotes/" prefix. 	 * We need to account for this in the width. 	 */
if|if
condition|(
name|filter
operator|->
name|kind
operator|!=
name|FILTER_REFS_REMOTES
condition|)
name|remote_prefix
operator|=
literal|"remotes/"
expr_stmt|;
name|memset
argument_list|(
operator|&
name|array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|verify_ref_format
argument_list|(
literal|"%(refname)%(symref)"
argument_list|)
expr_stmt|;
name|filter_refs
argument_list|(
operator|&
name|array
argument_list|,
name|filter
argument_list|,
name|filter
operator|->
name|kind
operator||
name|FILTER_REFS_INCLUDE_BROKEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|->
name|verbose
condition|)
name|maxwidth
operator|=
name|calc_maxwidth
argument_list|(
operator|&
name|array
argument_list|,
name|strlen
argument_list|(
name|remote_prefix
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If no sorting parameter is given then we default to sorting 	 * by 'refname'. This would give us an alphabetically sorted 	 * array with the 'HEAD' ref at the beginning followed by 	 * local branches 'refs/heads/...' and finally remote-tacking 	 * branches 'refs/remotes/...'. 	 */
if|if
condition|(
operator|!
name|sorting
condition|)
name|sorting
operator|=
name|ref_default_sorting
argument_list|()
expr_stmt|;
name|ref_array_sort
argument_list|(
name|sorting
argument_list|,
operator|&
name|array
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|format_and_print_ref_item
argument_list|(
name|array
operator|.
name|items
index|[
name|i
index|]
argument_list|,
name|maxwidth
argument_list|,
name|filter
argument_list|,
name|remote_prefix
argument_list|)
expr_stmt|;
name|ref_array_clear
argument_list|(
operator|&
name|array
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rename_branch
specifier|static
name|void
name|rename_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|strbuf
name|oldref
init|=
name|STRBUF_INIT
decl_stmt|,
name|newref
init|=
name|STRBUF_INIT
decl_stmt|,
name|logmsg
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|oldsection
init|=
name|STRBUF_INIT
decl_stmt|,
name|newsection
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|recovery
init|=
literal|0
decl_stmt|;
name|int
name|clobber_head_ok
decl_stmt|;
if|if
condition|(
operator|!
name|oldname
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot rename the current branch while not on any."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_check_branch_ref
argument_list|(
operator|&
name|oldref
argument_list|,
name|oldname
argument_list|)
condition|)
block|{
comment|/* 		 * Bad name --- this could be an attempt to rename a 		 * ref that we used to allow to be created by accident. 		 */
if|if
condition|(
name|ref_exists
argument_list|(
name|oldref
operator|.
name|buf
argument_list|)
condition|)
name|recovery
operator|=
literal|1
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"Invalid branch name: '%s'"
argument_list|)
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A command like "git branch -M currentbranch currentbranch" cannot 	 * cause the worktree to become inconsistent with HEAD, so allow it. 	 */
name|clobber_head_ok
operator|=
operator|!
name|strcmp
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|validate_new_branchname
argument_list|(
name|newname
argument_list|,
operator|&
name|newref
argument_list|,
name|force
argument_list|,
name|clobber_head_ok
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|logmsg
argument_list|,
literal|"Branch: renamed %s to %s"
argument_list|,
name|oldref
operator|.
name|buf
argument_list|,
name|newref
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename_ref
argument_list|(
name|oldref
operator|.
name|buf
argument_list|,
name|newref
operator|.
name|buf
argument_list|,
name|logmsg
operator|.
name|buf
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch rename failed"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|logmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|recovery
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Renamed a misnamed branch '%s' away"
argument_list|)
argument_list|,
name|oldref
operator|.
name|buf
operator|+
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|replace_each_worktree_head_symref
argument_list|(
name|oldref
operator|.
name|buf
argument_list|,
name|newref
operator|.
name|buf
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch renamed to %s, but HEAD is not updated!"
argument_list|)
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|oldsection
argument_list|,
literal|"branch.%s"
argument_list|,
name|oldref
operator|.
name|buf
operator|+
literal|11
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|oldref
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|newsection
argument_list|,
literal|"branch.%s"
argument_list|,
name|newref
operator|.
name|buf
operator|+
literal|11
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|newref
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_rename_section
argument_list|(
name|oldsection
operator|.
name|buf
argument_list|,
name|newsection
operator|.
name|buf
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch is renamed, but update of config-file failed"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|oldsection
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|newsection
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|edit_description
specifier|static
specifier|const
name|char
name|edit_description
index|[]
init|=
literal|"BRANCH_DESCRIPTION"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|edit_branch_description
specifier|static
name|int
name|edit_branch_description
parameter_list|(
specifier|const
name|char
modifier|*
name|branch_name
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|name
init|=
name|STRBUF_INIT
decl_stmt|;
name|read_branch_desc
argument_list|(
operator|&
name|buf
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|.
name|len
operator|||
name|buf
operator|.
name|buf
index|[
name|buf
operator|.
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_commented_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"Please edit the description for the branch\n"
literal|"  %s\n"
literal|"Lines starting with '%c' will be stripped.\n"
argument_list|,
name|branch_name
argument_list|,
name|comment_line_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_file_gently
argument_list|(
name|git_path
argument_list|(
name|edit_description
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|error_errno
argument_list|(
name|_
argument_list|(
literal|"could not write branch description template"
argument_list|)
argument_list|)
return|;
block|}
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|launch_editor
argument_list|(
name|git_path
argument_list|(
name|edit_description
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strbuf_stripspace
argument_list|(
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|name
argument_list|,
literal|"branch.%s.description"
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
name|git_config_set
argument_list|(
name|name
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
condition|?
name|buf
operator|.
name|buf
else|:
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmd_branch
name|int
name|cmd_branch
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|delete
init|=
literal|0
decl_stmt|,
name|rename
init|=
literal|0
decl_stmt|,
name|force
init|=
literal|0
decl_stmt|,
name|list
init|=
literal|0
decl_stmt|;
name|int
name|reflog
init|=
literal|0
decl_stmt|,
name|edit_description
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|,
name|unset_upstream
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_upstream
init|=
name|NULL
decl_stmt|;
name|enum
name|branch_track
name|track
decl_stmt|;
name|struct
name|ref_filter
name|filter
decl_stmt|;
specifier|static
name|struct
name|ref_sorting
modifier|*
name|sorting
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|sorting_tail
init|=
operator|&
name|sorting
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Generic options"
argument_list|)
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|filter
operator|.
name|verbose
argument_list|,
name|N_
argument_list|(
literal|"show hash and subject, give twice for upstream branch"
argument_list|)
argument_list|)
block|,
name|OPT__QUIET
argument_list|(
operator|&
name|quiet
argument_list|,
name|N_
argument_list|(
literal|"suppress informational messages"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'t'
argument_list|,
literal|"track"
argument_list|,
operator|&
name|track
argument_list|,
name|N_
argument_list|(
literal|"set up tracking mode (see git-pull(1))"
argument_list|)
argument_list|,
name|BRANCH_TRACK_EXPLICIT
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|0
argument_list|,
literal|"set-upstream"
argument_list|,
operator|&
name|track
argument_list|,
name|N_
argument_list|(
literal|"change upstream info"
argument_list|)
argument_list|,
name|BRANCH_TRACK_OVERRIDE
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'u'
argument_list|,
literal|"set-upstream-to"
argument_list|,
operator|&
name|new_upstream
argument_list|,
name|N_
argument_list|(
literal|"upstream"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"change the upstream info"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"unset-upstream"
argument_list|,
operator|&
name|unset_upstream
argument_list|,
literal|"Unset the upstream info"
argument_list|)
block|,
name|OPT__COLOR
argument_list|(
operator|&
name|branch_use_color
argument_list|,
name|N_
argument_list|(
literal|"use colored output"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'r'
argument_list|,
literal|"remotes"
argument_list|,
operator|&
name|filter
operator|.
name|kind
argument_list|,
name|N_
argument_list|(
literal|"act on remote-tracking branches"
argument_list|)
argument_list|,
name|FILTER_REFS_REMOTES
argument_list|)
block|,
name|OPT_CONTAINS
argument_list|(
operator|&
name|filter
operator|.
name|with_commit
argument_list|,
name|N_
argument_list|(
literal|"print only branches that contain the commit"
argument_list|)
argument_list|)
block|,
name|OPT_WITH
argument_list|(
operator|&
name|filter
operator|.
name|with_commit
argument_list|,
name|N_
argument_list|(
literal|"print only branches that contain the commit"
argument_list|)
argument_list|)
block|,
name|OPT__ABBREV
argument_list|(
operator|&
name|filter
operator|.
name|abbrev
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
name|N_
argument_list|(
literal|"Specific git-branch actions:"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'a'
argument_list|,
literal|"all"
argument_list|,
operator|&
name|filter
operator|.
name|kind
argument_list|,
name|N_
argument_list|(
literal|"list both remote-tracking and local branches"
argument_list|)
argument_list|,
name|FILTER_REFS_REMOTES
operator||
name|FILTER_REFS_BRANCHES
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'d'
argument_list|,
literal|"delete"
argument_list|,
operator|&
name|delete
argument_list|,
name|N_
argument_list|(
literal|"delete fully merged branch"
argument_list|)
argument_list|,
literal|1
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'D'
argument_list|,
name|NULL
argument_list|,
operator|&
name|delete
argument_list|,
name|N_
argument_list|(
literal|"delete branch (even if not merged)"
argument_list|)
argument_list|,
literal|2
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'m'
argument_list|,
literal|"move"
argument_list|,
operator|&
name|rename
argument_list|,
name|N_
argument_list|(
literal|"move/rename a branch and its reflog"
argument_list|)
argument_list|,
literal|1
argument_list|)
block|,
name|OPT_BIT
argument_list|(
literal|'M'
argument_list|,
name|NULL
argument_list|,
operator|&
name|rename
argument_list|,
name|N_
argument_list|(
literal|"move/rename a branch, even if target exists"
argument_list|)
argument_list|,
literal|2
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"list"
argument_list|,
operator|&
name|list
argument_list|,
name|N_
argument_list|(
literal|"list branch names"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'l'
argument_list|,
literal|"create-reflog"
argument_list|,
operator|&
name|reflog
argument_list|,
name|N_
argument_list|(
literal|"create the branch's reflog"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"edit-description"
argument_list|,
operator|&
name|edit_description
argument_list|,
name|N_
argument_list|(
literal|"edit the description for the branch"
argument_list|)
argument_list|)
block|,
name|OPT__FORCE
argument_list|(
operator|&
name|force
argument_list|,
name|N_
argument_list|(
literal|"force creation, move/rename, deletion"
argument_list|)
argument_list|)
block|,
name|OPT_MERGED
argument_list|(
operator|&
name|filter
argument_list|,
name|N_
argument_list|(
literal|"print only branches that are merged"
argument_list|)
argument_list|)
block|,
name|OPT_NO_MERGED
argument_list|(
operator|&
name|filter
argument_list|,
name|N_
argument_list|(
literal|"print only branches that are not merged"
argument_list|)
argument_list|)
block|,
name|OPT_COLUMN
argument_list|(
literal|0
argument_list|,
literal|"column"
argument_list|,
operator|&
name|colopts
argument_list|,
name|N_
argument_list|(
literal|"list branches in columns"
argument_list|)
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|0
argument_list|,
literal|"sort"
argument_list|,
name|sorting_tail
argument_list|,
name|N_
argument_list|(
literal|"key"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"field name to sort on"
argument_list|)
argument_list|,
operator|&
name|parse_opt_ref_sorting
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"points-at"
block|,
operator|&
name|filter
operator|.
name|points_at
block|,
name|N_
argument_list|(
literal|"object"
argument_list|)
block|,
name|N_
argument_list|(
literal|"print only branches of the object"
argument_list|)
block|,
literal|0
block|,
name|parse_opt_object_name
block|}
block|,
name|OPT_END
argument_list|()
block|, 	}
decl_stmt|;
name|memset
argument_list|(
operator|&
name|filter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|filter
operator|.
name|kind
operator|=
name|FILTER_REFS_BRANCHES
expr_stmt|;
name|filter
operator|.
name|abbrev
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_branch_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|track
operator|=
name|git_branch_track
expr_stmt|;
name|head
operator|=
name|resolve_refdup
argument_list|(
literal|"HEAD"
argument_list|,
literal|0
argument_list|,
name|head_sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to resolve HEAD as a valid ref."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|head
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|filter
operator|.
name|detached
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|head
argument_list|,
literal|"refs/heads/"
argument_list|,
operator|&
name|head
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"HEAD not found below refs/heads!"
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|builtin_branch_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delete
operator|&&
operator|!
name|rename
operator|&&
operator|!
name|edit_description
operator|&&
operator|!
name|new_upstream
operator|&&
operator|!
name|unset_upstream
operator|&&
name|argc
operator|==
literal|0
condition|)
name|list
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|filter
operator|.
name|with_commit
operator|||
name|filter
operator|.
name|merge
operator|!=
name|REF_FILTER_MERGED_NONE
operator|||
name|filter
operator|.
name|points_at
operator|.
name|nr
condition|)
name|list
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|delete
operator|+
operator|!
operator|!
name|rename
operator|+
operator|!
operator|!
name|new_upstream
operator|+
name|list
operator|+
name|unset_upstream
operator|>
literal|1
condition|)
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|.
name|abbrev
operator|==
operator|-
literal|1
condition|)
name|filter
operator|.
name|abbrev
operator|=
name|DEFAULT_ABBREV
expr_stmt|;
name|finalize_colopts
argument_list|(
operator|&
name|colopts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|.
name|verbose
condition|)
block|{
if|if
condition|(
name|explicitly_enable_column
argument_list|(
name|colopts
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--column and --verbose are incompatible"
argument_list|)
argument_list|)
expr_stmt|;
name|colopts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
block|{
name|delete
operator|*=
literal|2
expr_stmt|;
name|rename
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|delete
condition|)
block|{
if|if
condition|(
operator|!
name|argc
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"branch name required"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delete_branches
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|delete
operator|>
literal|1
argument_list|,
name|filter
operator|.
name|kind
argument_list|,
name|quiet
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|list
condition|)
block|{
comment|/*  git branch --local also shows HEAD when it is detached */
if|if
condition|(
operator|(
name|filter
operator|.
name|kind
operator|&
name|FILTER_REFS_BRANCHES
operator|)
operator|&&
name|filter
operator|.
name|detached
condition|)
name|filter
operator|.
name|kind
operator||=
name|FILTER_REFS_DETACHED_HEAD
expr_stmt|;
name|filter
operator|.
name|name_patterns
operator|=
name|argv
expr_stmt|;
name|print_ref_list
argument_list|(
operator|&
name|filter
argument_list|,
name|sorting
argument_list|)
expr_stmt|;
name|print_columns
argument_list|(
operator|&
name|output
argument_list|,
name|colopts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|edit_description
condition|)
block|{
specifier|const
name|char
modifier|*
name|branch_name
decl_stmt|;
name|struct
name|strbuf
name|branch_ref
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
block|{
if|if
condition|(
name|filter
operator|.
name|detached
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Cannot give description to detached HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|branch_name
operator|=
name|head
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|branch_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot edit description of more than one branch"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|branch_ref
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref_exists
argument_list|(
name|branch_ref
operator|.
name|buf
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|branch_ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"No commit on branch '%s' yet."
argument_list|)
argument_list|,
name|branch_name
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"No branch named '%s'."
argument_list|)
argument_list|,
name|branch_name
argument_list|)
return|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|branch_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_branch_description
argument_list|(
name|branch_name
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rename
condition|)
block|{
if|if
condition|(
operator|!
name|argc
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"branch name required"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|rename_branch
argument_list|(
name|head
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|rename
operator|>
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|rename_branch
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|rename
operator|>
literal|1
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
name|_
argument_list|(
literal|"too many branches for a rename operation"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_upstream
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"too many branches to set new upstream"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
condition|)
block|{
if|if
condition|(
operator|!
name|argc
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not set upstream of HEAD to %s when "
literal|"it does not point to any branch."
argument_list|)
argument_list|,
name|new_upstream
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"no such branch '%s'"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ref_exists
argument_list|(
name|branch
operator|->
name|refname
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"branch '%s' does not exist"
argument_list|)
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * create_branch takes care of setting up the tracking 		 * info and making sure new_upstream is correct 		 */
name|create_branch
argument_list|(
name|head
argument_list|,
name|branch
operator|->
name|name
argument_list|,
name|new_upstream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|quiet
argument_list|,
name|BRANCH_TRACK_OVERRIDE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unset_upstream
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"too many branches to unset upstream"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
condition|)
block|{
if|if
condition|(
operator|!
name|argc
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not unset upstream of HEAD when "
literal|"it does not point to any branch."
argument_list|)
argument_list|)
expr_stmt|;
name|die
argument_list|(
name|_
argument_list|(
literal|"no such branch '%s'"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|branch_has_merge_config
argument_list|(
name|branch
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Branch '%s' has no upstream information"
argument_list|)
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"branch.%s.remote"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|git_config_set_multivar
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"branch.%s.merge"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|git_config_set_multivar
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|argc
operator|<=
literal|2
condition|)
block|{
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|branch_existed
init|=
literal|0
decl_stmt|,
name|remote_tracking
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"it does not make sense to create 'HEAD' manually"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"no such branch '%s'"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|.
name|kind
operator|!=
name|FILTER_REFS_BRANCHES
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"-a and -r options to 'git branch' do not make sense with a branch name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|track
operator|==
name|BRANCH_TRACK_OVERRIDE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"The --set-upstream flag is deprecated and will be removed. Consider using --track or --set-upstream-to\n"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"refs/remotes/%s"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|remote_tracking
operator|=
name|ref_exists
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|branch_existed
operator|=
name|ref_exists
argument_list|(
name|branch
operator|->
name|refname
argument_list|)
expr_stmt|;
name|create_branch
argument_list|(
name|head
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|argc
operator|==
literal|2
operator|)
condition|?
name|argv
index|[
literal|1
index|]
else|:
name|head
argument_list|,
name|force
argument_list|,
name|reflog
argument_list|,
literal|0
argument_list|,
name|quiet
argument_list|,
name|track
argument_list|)
expr_stmt|;
comment|/* 		 * We only show the instructions if the user gave us 		 * one branch which doesn't exist locally, but is the 		 * name of a remote-tracking branch. 		 */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|track
operator|==
name|BRANCH_TRACK_OVERRIDE
operator|&&
operator|!
name|branch_existed
operator|&&
name|remote_tracking
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\nIf you wanted to make '%s' track '%s', do this:\n\n"
argument_list|)
argument_list|,
name|head
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    git branch -d %s\n"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    git branch --set-upstream-to %s\n"
argument_list|,
name|branch
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|usage_with_options
argument_list|(
name|builtin_branch_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
