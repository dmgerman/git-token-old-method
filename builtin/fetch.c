begin_unit
begin_comment
comment|/*  * "git fetch"  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"transport.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"sigchain.h"
end_include
begin_include
include|#
directive|include
file|"transport.h"
end_include
begin_include
include|#
directive|include
file|"submodule.h"
end_include
begin_include
include|#
directive|include
file|"connected.h"
end_include
begin_include
include|#
directive|include
file|"argv-array.h"
end_include
begin_decl_stmt
DECL|variable|builtin_fetch_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_fetch_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git fetch [<options>] [<repository> [<refspec>...]]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git fetch [<options>]<group>"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git fetch --multiple [<options>] [(<repository> |<group>)...]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"git fetch --all [<options>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_enum
enum|enum
block|{
DECL|enumerator|TAGS_UNSET
name|TAGS_UNSET
init|=
literal|0
block|,
DECL|enumerator|TAGS_DEFAULT
name|TAGS_DEFAULT
init|=
literal|1
block|,
DECL|enumerator|TAGS_SET
name|TAGS_SET
init|=
literal|2
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|fetch_prune_config
specifier|static
name|int
name|fetch_prune_config
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|fetch_prune_config
comment|/* unspecified */
end_comment
begin_decl_stmt
DECL|variable|prune
specifier|static
name|int
name|prune
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|prune
comment|/* unspecified */
end_comment
begin_define
DECL|macro|PRUNE_BY_DEFAULT
define|#
directive|define
name|PRUNE_BY_DEFAULT
value|0
end_define
begin_comment
DECL|macro|PRUNE_BY_DEFAULT
comment|/* do we prune by default? */
end_comment
begin_decl_stmt
DECL|variable|all
DECL|variable|append
DECL|variable|dry_run
DECL|variable|force
DECL|variable|keep
DECL|variable|multiple
DECL|variable|update_head_ok
DECL|variable|verbosity
specifier|static
name|int
name|all
decl_stmt|,
name|append
decl_stmt|,
name|dry_run
decl_stmt|,
name|force
decl_stmt|,
name|keep
decl_stmt|,
name|multiple
decl_stmt|,
name|update_head_ok
decl_stmt|,
name|verbosity
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|progress
DECL|variable|recurse_submodules
specifier|static
name|int
name|progress
init|=
operator|-
literal|1
decl_stmt|,
name|recurse_submodules
init|=
name|RECURSE_SUBMODULES_DEFAULT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tags
DECL|variable|unshallow
specifier|static
name|int
name|tags
init|=
name|TAGS_DEFAULT
decl_stmt|,
name|unshallow
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|depth
specifier|static
specifier|const
name|char
modifier|*
name|depth
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|upload_pack
specifier|static
specifier|const
name|char
modifier|*
name|upload_pack
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_rla
specifier|static
name|struct
name|strbuf
name|default_rla
init|=
name|STRBUF_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|gtransport
specifier|static
name|struct
name|transport
modifier|*
name|gtransport
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|gsecondary
specifier|static
name|struct
name|transport
modifier|*
name|gsecondary
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|submodule_prefix
specifier|static
specifier|const
name|char
modifier|*
name|submodule_prefix
init|=
literal|""
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|recurse_submodules_default
specifier|static
specifier|const
name|char
modifier|*
name|recurse_submodules_default
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|option_parse_recurse_submodules
specifier|static
name|int
name|option_parse_recurse_submodules
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
block|{
name|recurse_submodules
operator|=
name|RECURSE_SUBMODULES_OFF
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|arg
condition|)
name|recurse_submodules
operator|=
name|parse_fetch_recurse_submodules_arg
argument_list|(
name|opt
operator|->
name|long_name
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|recurse_submodules
operator|=
name|RECURSE_SUBMODULES_ON
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_fetch_config
specifier|static
name|int
name|git_fetch_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"fetch.prune"
argument_list|)
condition|)
block|{
name|fetch_prune_config
operator|=
name|git_config_bool
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|builtin_fetch_options
specifier|static
name|struct
name|option
name|builtin_fetch_options
index|[]
init|=
block|{
name|OPT__VERBOSITY
argument_list|(
operator|&
name|verbosity
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"all"
argument_list|,
operator|&
name|all
argument_list|,
name|N_
argument_list|(
literal|"fetch from all remotes"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'a'
argument_list|,
literal|"append"
argument_list|,
operator|&
name|append
argument_list|,
name|N_
argument_list|(
literal|"append to .git/FETCH_HEAD instead of overwriting"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"upload-pack"
argument_list|,
operator|&
name|upload_pack
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"path to upload pack on remote end"
argument_list|)
argument_list|)
block|,
name|OPT__FORCE
argument_list|(
operator|&
name|force
argument_list|,
name|N_
argument_list|(
literal|"force overwrite of local branch"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'m'
argument_list|,
literal|"multiple"
argument_list|,
operator|&
name|multiple
argument_list|,
name|N_
argument_list|(
literal|"fetch from multiple remotes"
argument_list|)
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'t'
argument_list|,
literal|"tags"
argument_list|,
operator|&
name|tags
argument_list|,
name|N_
argument_list|(
literal|"fetch all tags and associated objects"
argument_list|)
argument_list|,
name|TAGS_SET
argument_list|)
block|,
name|OPT_SET_INT
argument_list|(
literal|'n'
argument_list|,
name|NULL
argument_list|,
operator|&
name|tags
argument_list|,
name|N_
argument_list|(
literal|"do not fetch all tags (--no-tags)"
argument_list|)
argument_list|,
name|TAGS_UNSET
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'p'
argument_list|,
literal|"prune"
argument_list|,
operator|&
name|prune
argument_list|,
name|N_
argument_list|(
literal|"prune remote-tracking branches no longer on remote"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"recurse-submodules"
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"on-demand"
argument_list|)
block|,
name|N_
argument_list|(
literal|"control recursive fetching of submodules"
argument_list|)
block|,
name|PARSE_OPT_OPTARG
block|,
name|option_parse_recurse_submodules
block|}
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"dry-run"
argument_list|,
operator|&
name|dry_run
argument_list|,
name|N_
argument_list|(
literal|"dry run"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'k'
argument_list|,
literal|"keep"
argument_list|,
operator|&
name|keep
argument_list|,
name|N_
argument_list|(
literal|"keep downloaded pack"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'u'
argument_list|,
literal|"update-head-ok"
argument_list|,
operator|&
name|update_head_ok
argument_list|,
name|N_
argument_list|(
literal|"allow updating of HEAD ref"
argument_list|)
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|0
argument_list|,
literal|"progress"
argument_list|,
operator|&
name|progress
argument_list|,
name|N_
argument_list|(
literal|"force progress reporting"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"depth"
argument_list|,
operator|&
name|depth
argument_list|,
name|N_
argument_list|(
literal|"depth"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"deepen history of shallow clone"
argument_list|)
argument_list|)
block|,
block|{
name|OPTION_SET_INT
block|,
literal|0
block|,
literal|"unshallow"
block|,
operator|&
name|unshallow
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"convert to a complete repository"
argument_list|)
block|,
name|PARSE_OPT_NONEG
operator||
name|PARSE_OPT_NOARG
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
name|OPTION_STRING
block|,
literal|0
block|,
literal|"submodule-prefix"
block|,
operator|&
name|submodule_prefix
block|,
name|N_
argument_list|(
literal|"dir"
argument_list|)
block|,
name|N_
argument_list|(
literal|"prepend this to submodule path output"
argument_list|)
block|,
name|PARSE_OPT_HIDDEN
block|}
block|,
block|{
name|OPTION_STRING
block|,
literal|0
block|,
literal|"recurse-submodules-default"
block|,
operator|&
name|recurse_submodules_default
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"default mode for recursion"
argument_list|)
block|,
name|PARSE_OPT_HIDDEN
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|unlock_pack
specifier|static
name|void
name|unlock_pack
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|gtransport
condition|)
name|transport_unlock_pack
argument_list|(
name|gtransport
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsecondary
condition|)
name|transport_unlock_pack
argument_list|(
name|gsecondary
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unlock_pack_on_signal
specifier|static
name|void
name|unlock_pack_on_signal
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|unlock_pack
argument_list|()
expr_stmt|;
name|sigchain_pop
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_merge_config
specifier|static
name|void
name|add_merge_config
parameter_list|(
name|struct
name|ref
modifier|*
modifier|*
name|head
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|branch
operator|->
name|merge_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ref
modifier|*
name|rm
decl_stmt|,
modifier|*
modifier|*
name|old_tail
init|=
operator|*
name|tail
decl_stmt|;
name|struct
name|refspec
name|refspec
decl_stmt|;
for|for
control|(
name|rm
operator|=
operator|*
name|head
init|;
name|rm
condition|;
name|rm
operator|=
name|rm
operator|->
name|next
control|)
block|{
if|if
condition|(
name|branch_merge_matches
argument_list|(
name|branch
argument_list|,
name|i
argument_list|,
name|rm
operator|->
name|name
argument_list|)
condition|)
block|{
name|rm
operator|->
name|fetch_head_status
operator|=
name|FETCH_HEAD_MERGE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rm
condition|)
continue|continue;
comment|/* 		 * Not fetched to a remote-tracking branch?  We need to fetch 		 * it anyway to allow this branch's "branch.$name.merge" 		 * to be honored by 'git pull', but we do not have to 		 * fail if branch.$name.merge is misconfigured to point 		 * at a nonexisting branch.  If we were indeed called by 		 * 'git pull', it will notice the misconfiguration because 		 * there is no entry in the resulting FETCH_HEAD marked 		 * for merging. 		 */
name|memset
argument_list|(
operator|&
name|refspec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|refspec
argument_list|)
argument_list|)
expr_stmt|;
name|refspec
operator|.
name|src
operator|=
name|branch
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
expr_stmt|;
name|get_fetch_map
argument_list|(
name|remote_refs
argument_list|,
operator|&
name|refspec
argument_list|,
name|tail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|rm
operator|=
operator|*
name|old_tail
init|;
name|rm
condition|;
name|rm
operator|=
name|rm
operator|->
name|next
control|)
name|rm
operator|->
name|fetch_head_status
operator|=
name|FETCH_HEAD_MERGE
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_existing
specifier|static
name|int
name|add_existing
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cbdata
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|list
init|=
operator|(
expr|struct
name|string_list
operator|*
operator|)
name|cbdata
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
init|=
name|string_list_insert
argument_list|(
name|list
argument_list|,
name|refname
argument_list|)
decl_stmt|;
name|item
operator|->
name|util
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|item
operator|->
name|util
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|will_fetch
specifier|static
name|int
name|will_fetch
parameter_list|(
name|struct
name|ref
modifier|*
modifier|*
name|head
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|rm
init|=
operator|*
name|head
decl_stmt|;
while|while
condition|(
name|rm
condition|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|rm
operator|->
name|old_sha1
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
literal|1
return|;
name|rm
operator|=
name|rm
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_non_local_tags
specifier|static
name|void
name|find_non_local_tags
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|head
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|string_list
name|existing_refs
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
name|struct
name|string_list
name|remote_refs
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|for_each_ref
argument_list|(
name|add_existing
argument_list|,
operator|&
name|existing_refs
argument_list|)
expr_stmt|;
for|for
control|(
name|ref
operator|=
name|transport_get_remote_refs
argument_list|(
name|transport
argument_list|)
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
continue|continue;
comment|/* 		 * The peeled ref always follows the matching base 		 * ref, so if we see a peeled ref that we don't want 		 * to fetch then we can mark the ref entry in the list 		 * as one to ignore by setting util to NULL. 		 */
if|if
condition|(
operator|!
name|suffixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"^{}"
argument_list|)
condition|)
block|{
if|if
condition|(
name|item
operator|&&
operator|!
name|has_sha1_file
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
operator|&&
operator|!
name|will_fetch
argument_list|(
name|head
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|)
operator|&&
operator|!
name|has_sha1_file
argument_list|(
name|item
operator|->
name|util
argument_list|)
operator|&&
operator|!
name|will_fetch
argument_list|(
name|head
argument_list|,
name|item
operator|->
name|util
argument_list|)
condition|)
name|item
operator|->
name|util
operator|=
name|NULL
expr_stmt|;
name|item
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If item is non-NULL here, then we previously saw a 		 * ref not followed by a peeled reference, so we need 		 * to check if it is a lightweight tag that we want to 		 * fetch. 		 */
if|if
condition|(
name|item
operator|&&
operator|!
name|has_sha1_file
argument_list|(
name|item
operator|->
name|util
argument_list|)
operator|&&
operator|!
name|will_fetch
argument_list|(
name|head
argument_list|,
name|item
operator|->
name|util
argument_list|)
condition|)
name|item
operator|->
name|util
operator|=
name|NULL
expr_stmt|;
name|item
operator|=
name|NULL
expr_stmt|;
comment|/* skip duplicates and refs that we already have */
if|if
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|remote_refs
argument_list|,
name|ref
operator|->
name|name
argument_list|)
operator|||
name|string_list_has_string
argument_list|(
operator|&
name|existing_refs
argument_list|,
name|ref
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|item
operator|=
name|string_list_insert
argument_list|(
operator|&
name|remote_refs
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
operator|(
name|void
operator|*
operator|)
name|ref
operator|->
name|old_sha1
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
operator|&
name|existing_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * We may have a final lightweight tag that needs to be 	 * checked to see if it needs fetching. 	 */
if|if
condition|(
name|item
operator|&&
operator|!
name|has_sha1_file
argument_list|(
name|item
operator|->
name|util
argument_list|)
operator|&&
operator|!
name|will_fetch
argument_list|(
name|head
argument_list|,
name|item
operator|->
name|util
argument_list|)
condition|)
name|item
operator|->
name|util
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For all the tags in the remote_refs string list, 	 * add them to the list of refs to be fetched 	 */
name|for_each_string_list_item
argument_list|(
argument|item
argument_list|,
argument|&remote_refs
argument_list|)
block|{
comment|/* Unless we have already decided to ignore this item... */
if|if
condition|(
name|item
operator|->
name|util
condition|)
block|{
name|struct
name|ref
modifier|*
name|rm
init|=
name|alloc_ref
argument_list|(
name|item
operator|->
name|string
argument_list|)
decl_stmt|;
name|rm
operator|->
name|peer_ref
operator|=
name|alloc_ref
argument_list|(
name|item
operator|->
name|string
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|rm
operator|->
name|old_sha1
argument_list|,
name|item
operator|->
name|util
argument_list|)
expr_stmt|;
operator|*
operator|*
name|tail
operator|=
name|rm
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|rm
operator|->
name|next
expr_stmt|;
block|}
block|}
name|string_list_clear
argument_list|(
operator|&
name|remote_refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_ref_map
specifier|static
name|struct
name|ref
modifier|*
name|get_ref_map
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|refspec
modifier|*
name|refspecs
parameter_list|,
name|int
name|refspec_count
parameter_list|,
name|int
name|tags
parameter_list|,
name|int
modifier|*
name|autotags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ref
modifier|*
name|rm
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref_map
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ref_map
decl_stmt|;
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
init|=
name|transport_get_remote_refs
argument_list|(
name|transport
argument_list|)
decl_stmt|;
if|if
condition|(
name|refspec_count
operator|||
name|tags
operator|==
name|TAGS_SET
condition|)
block|{
comment|/* opportunistically-updated references: */
name|struct
name|ref
modifier|*
name|orefs
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|oref_tail
init|=
operator|&
name|orefs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|refspec_count
condition|;
name|i
operator|++
control|)
block|{
name|get_fetch_map
argument_list|(
name|remote_refs
argument_list|,
operator|&
name|refspecs
index|[
name|i
index|]
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|refspecs
index|[
name|i
index|]
operator|.
name|dst
operator|&&
name|refspecs
index|[
name|i
index|]
operator|.
name|dst
index|[
literal|0
index|]
condition|)
operator|*
name|autotags
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Merge everything on the command line (but not --tags) */
for|for
control|(
name|rm
operator|=
name|ref_map
init|;
name|rm
condition|;
name|rm
operator|=
name|rm
operator|->
name|next
control|)
name|rm
operator|->
name|fetch_head_status
operator|=
name|FETCH_HEAD_MERGE
expr_stmt|;
comment|/* 		 * For any refs that we happen to be fetching via 		 * command-line arguments, the destination ref might 		 * have been missing or have been different than the 		 * remote-tracking ref that would be derived from the 		 * configured refspec.  In these cases, we want to 		 * take the opportunity to update their configured 		 * remote-tracking reference.  However, we do not want 		 * to mention these entries in FETCH_HEAD at all, as 		 * they would simply be duplicates of existing 		 * entries, so we set them FETCH_HEAD_IGNORE below. 		 * 		 * We compute these entries now, based only on the 		 * refspecs specified on the command line.  But we add 		 * them to the list following the refspecs resulting 		 * from the tags option so that one of the latter, 		 * which has FETCH_HEAD_NOT_FOR_MERGE, is not removed 		 * by ref_remove_duplicates() in favor of one of these 		 * opportunistic entries with FETCH_HEAD_IGNORE. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|transport
operator|->
name|remote
operator|->
name|fetch_refspec_nr
condition|;
name|i
operator|++
control|)
name|get_fetch_map
argument_list|(
name|ref_map
argument_list|,
operator|&
name|transport
operator|->
name|remote
operator|->
name|fetch
index|[
name|i
index|]
argument_list|,
operator|&
name|oref_tail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tags
operator|==
name|TAGS_SET
condition|)
name|get_fetch_map
argument_list|(
name|remote_refs
argument_list|,
name|tag_refspec
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|tail
operator|=
name|orefs
expr_stmt|;
for|for
control|(
name|rm
operator|=
name|orefs
init|;
name|rm
condition|;
name|rm
operator|=
name|rm
operator|->
name|next
control|)
block|{
name|rm
operator|->
name|fetch_head_status
operator|=
name|FETCH_HEAD_IGNORE
expr_stmt|;
name|tail
operator|=
operator|&
name|rm
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use the defaults */
name|struct
name|remote
modifier|*
name|remote
init|=
name|transport
operator|->
name|remote
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
init|=
name|branch_get
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|has_merge
init|=
name|branch_has_merge_config
argument_list|(
name|branch
argument_list|)
decl_stmt|;
if|if
condition|(
name|remote
operator|&&
operator|(
name|remote
operator|->
name|fetch_refspec_nr
operator|||
comment|/* Note: has_merge implies non-NULL branch->remote_name */
operator|(
name|has_merge
operator|&&
operator|!
name|strcmp
argument_list|(
name|branch
operator|->
name|remote_name
argument_list|,
name|remote
operator|->
name|name
argument_list|)
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remote
operator|->
name|fetch_refspec_nr
condition|;
name|i
operator|++
control|)
block|{
name|get_fetch_map
argument_list|(
name|remote_refs
argument_list|,
operator|&
name|remote
operator|->
name|fetch
index|[
name|i
index|]
argument_list|,
operator|&
name|tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote
operator|->
name|fetch
index|[
name|i
index|]
operator|.
name|dst
operator|&&
name|remote
operator|->
name|fetch
index|[
name|i
index|]
operator|.
name|dst
index|[
literal|0
index|]
condition|)
operator|*
name|autotags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|has_merge
operator|&&
name|ref_map
operator|&&
operator|!
name|remote
operator|->
name|fetch
index|[
literal|0
index|]
operator|.
name|pattern
condition|)
name|ref_map
operator|->
name|fetch_head_status
operator|=
name|FETCH_HEAD_MERGE
expr_stmt|;
block|}
comment|/* 			 * if the remote we're fetching from is the same 			 * as given in branch.<name>.remote, we add the 			 * ref given in branch.<name>.merge, too. 			 * 			 * Note: has_merge implies non-NULL branch->remote_name 			 */
if|if
condition|(
name|has_merge
operator|&&
operator|!
name|strcmp
argument_list|(
name|branch
operator|->
name|remote_name
argument_list|,
name|remote
operator|->
name|name
argument_list|)
condition|)
name|add_merge_config
argument_list|(
operator|&
name|ref_map
argument_list|,
name|remote_refs
argument_list|,
name|branch
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref_map
operator|=
name|get_remote_ref
argument_list|(
name|remote_refs
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref_map
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Couldn't find remote ref HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|ref_map
operator|->
name|fetch_head_status
operator|=
name|FETCH_HEAD_MERGE
expr_stmt|;
name|tail
operator|=
operator|&
name|ref_map
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tags
operator|==
name|TAGS_DEFAULT
operator|&&
operator|*
name|autotags
condition|)
name|find_non_local_tags
argument_list|(
name|transport
argument_list|,
operator|&
name|ref_map
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|ref_remove_duplicates
argument_list|(
name|ref_map
argument_list|)
expr_stmt|;
return|return
name|ref_map
return|;
block|}
end_function
begin_define
DECL|macro|STORE_REF_ERROR_OTHER
define|#
directive|define
name|STORE_REF_ERROR_OTHER
value|1
end_define
begin_define
DECL|macro|STORE_REF_ERROR_DF_CONFLICT
define|#
directive|define
name|STORE_REF_ERROR_DF_CONFLICT
value|2
end_define
begin_function
DECL|function|s_update_ref
specifier|static
name|int
name|s_update_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|action
parameter_list|,
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|int
name|check_old
parameter_list|)
block|{
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|rla
init|=
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|ref_lock
modifier|*
name|lock
decl_stmt|;
if|if
condition|(
name|dry_run
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|rla
condition|)
name|rla
operator|=
name|default_rla
operator|.
name|buf
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"%s: %s"
argument_list|,
name|rla
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|lock
operator|=
name|lock_any_ref_for_update
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|check_old
condition|?
name|ref
operator|->
name|old_sha1
else|:
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
name|errno
operator|==
name|ENOTDIR
condition|?
name|STORE_REF_ERROR_DF_CONFLICT
else|:
name|STORE_REF_ERROR_OTHER
return|;
if|if
condition|(
name|write_ref_sha1
argument_list|(
name|lock
argument_list|,
name|ref
operator|->
name|new_sha1
argument_list|,
name|msg
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
operator|==
name|ENOTDIR
condition|?
name|STORE_REF_ERROR_DF_CONFLICT
else|:
name|STORE_REF_ERROR_OTHER
return|;
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|REFCOL_WIDTH
define|#
directive|define
name|REFCOL_WIDTH
value|10
end_define
begin_function
DECL|function|update_local_ref
specifier|static
name|int
name|update_local_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
specifier|const
name|char
modifier|*
name|remote
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|remote_ref
parameter_list|,
name|struct
name|strbuf
modifier|*
name|display
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|current
init|=
name|NULL
decl_stmt|,
modifier|*
name|updated
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|struct
name|branch
modifier|*
name|current_branch
init|=
name|branch_get
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|pretty_ref
init|=
name|prettify_refname
argument_list|(
name|ref
operator|->
name|name
argument_list|)
decl_stmt|;
name|type
operator|=
name|sha1_object_info
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"object %s not found"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|ref
operator|->
name|new_sha1
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|0
condition|)
name|strbuf_addf
argument_list|(
name|display
argument_list|,
literal|"= %-*s %-*s -> %s"
argument_list|,
name|TRANSPORT_SUMMARY
argument_list|(
name|_
argument_list|(
literal|"[up to date]"
argument_list|)
argument_list|)
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|remote
argument_list|,
name|pretty_ref
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|current_branch
operator|&&
operator|!
name|strcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|current_branch
operator|->
name|name
argument_list|)
operator|&&
operator|!
operator|(
name|update_head_ok
operator|||
name|is_bare_repository
argument_list|()
operator|)
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
comment|/* 		 * If this is the head, and it's not okay to update 		 * the head, and the old value of the head isn't empty... 		 */
name|strbuf_addf
argument_list|(
name|display
argument_list|,
name|_
argument_list|(
literal|"! %-*s %-*s -> %s  (can't fetch in current branch)"
argument_list|)
argument_list|,
name|TRANSPORT_SUMMARY
argument_list|(
name|_
argument_list|(
literal|"[rejected]"
argument_list|)
argument_list|)
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|remote
argument_list|,
name|pretty_ref
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|s_update_ref
argument_list|(
literal|"updating tag"
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|display
argument_list|,
literal|"%c %-*s %-*s -> %s%s"
argument_list|,
name|r
condition|?
literal|'!'
else|:
literal|'-'
argument_list|,
name|TRANSPORT_SUMMARY
argument_list|(
name|_
argument_list|(
literal|"[tag update]"
argument_list|)
argument_list|)
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|remote
argument_list|,
name|pretty_ref
argument_list|,
name|r
condition|?
name|_
argument_list|(
literal|"  (unable to update local ref)"
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|current
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|updated
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|||
operator|!
name|updated
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* 		 * Nicely describe the new ref we're fetching. 		 * Base this on the remote's ref name, as it's 		 * more likely to follow a standard layout. 		 */
specifier|const
name|char
modifier|*
name|name
init|=
name|remote_ref
condition|?
name|remote_ref
operator|->
name|name
else|:
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
name|msg
operator|=
literal|"storing tag"
expr_stmt|;
name|what
operator|=
name|_
argument_list|(
literal|"[new tag]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
block|{
name|msg
operator|=
literal|"storing head"
expr_stmt|;
name|what
operator|=
name|_
argument_list|(
literal|"[new branch]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
literal|"storing ref"
expr_stmt|;
name|what
operator|=
name|_
argument_list|(
literal|"[new ref]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_OFF
operator|)
operator|&&
operator|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_ON
operator|)
condition|)
name|check_for_new_submodule_commits
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|r
operator|=
name|s_update_ref
argument_list|(
name|msg
argument_list|,
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|display
argument_list|,
literal|"%c %-*s %-*s -> %s%s"
argument_list|,
name|r
condition|?
literal|'!'
else|:
literal|'*'
argument_list|,
name|TRANSPORT_SUMMARY
argument_list|(
name|what
argument_list|)
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|remote
argument_list|,
name|pretty_ref
argument_list|,
name|r
condition|?
name|_
argument_list|(
literal|"  (unable to update local ref)"
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|in_merge_bases
argument_list|(
name|current
argument_list|,
name|updated
argument_list|)
condition|)
block|{
name|char
name|quickref
index|[
literal|83
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|strcpy
argument_list|(
name|quickref
argument_list|,
name|find_unique_abbrev
argument_list|(
name|current
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|quickref
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|quickref
argument_list|,
name|find_unique_abbrev
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_OFF
operator|)
operator|&&
operator|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_ON
operator|)
condition|)
name|check_for_new_submodule_commits
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|r
operator|=
name|s_update_ref
argument_list|(
literal|"fast-forward"
argument_list|,
name|ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|display
argument_list|,
literal|"%c %-*s %-*s -> %s%s"
argument_list|,
name|r
condition|?
literal|'!'
else|:
literal|' '
argument_list|,
name|TRANSPORT_SUMMARY_WIDTH
argument_list|,
name|quickref
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|remote
argument_list|,
name|pretty_ref
argument_list|,
name|r
condition|?
name|_
argument_list|(
literal|"  (unable to update local ref)"
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|force
operator|||
name|ref
operator|->
name|force
condition|)
block|{
name|char
name|quickref
index|[
literal|84
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|strcpy
argument_list|(
name|quickref
argument_list|,
name|find_unique_abbrev
argument_list|(
name|current
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|quickref
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|quickref
argument_list|,
name|find_unique_abbrev
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_OFF
operator|)
operator|&&
operator|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_ON
operator|)
condition|)
name|check_for_new_submodule_commits
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|r
operator|=
name|s_update_ref
argument_list|(
literal|"forced-update"
argument_list|,
name|ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|display
argument_list|,
literal|"%c %-*s %-*s -> %s  (%s)"
argument_list|,
name|r
condition|?
literal|'!'
else|:
literal|'+'
argument_list|,
name|TRANSPORT_SUMMARY_WIDTH
argument_list|,
name|quickref
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|remote
argument_list|,
name|pretty_ref
argument_list|,
name|r
condition|?
name|_
argument_list|(
literal|"unable to update local ref"
argument_list|)
else|:
name|_
argument_list|(
literal|"forced update"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
name|display
argument_list|,
literal|"! %-*s %-*s -> %s  %s"
argument_list|,
name|TRANSPORT_SUMMARY
argument_list|(
name|_
argument_list|(
literal|"[rejected]"
argument_list|)
argument_list|)
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|remote
argument_list|,
name|pretty_ref
argument_list|,
name|_
argument_list|(
literal|"(non-fast-forward)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function
begin_function
DECL|function|iterate_ref_map
specifier|static
name|int
name|iterate_ref_map
parameter_list|(
name|void
modifier|*
name|cb_data
parameter_list|,
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|rm
init|=
name|cb_data
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
init|=
operator|*
name|rm
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
return|return
operator|-
literal|1
return|;
comment|/* end of the list */
operator|*
name|rm
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|store_updated_refs
specifier|static
name|int
name|store_updated_refs
parameter_list|(
specifier|const
name|char
modifier|*
name|raw_url
parameter_list|,
specifier|const
name|char
modifier|*
name|remote_name
parameter_list|,
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|int
name|url_len
decl_stmt|,
name|i
decl_stmt|,
name|shown_url
init|=
literal|0
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|strbuf
name|note
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|kind
decl_stmt|;
name|struct
name|ref
modifier|*
name|rm
decl_stmt|;
name|char
modifier|*
name|url
decl_stmt|,
modifier|*
name|filename
init|=
name|dry_run
condition|?
literal|"/dev/null"
else|:
name|git_path
argument_list|(
literal|"FETCH_HEAD"
argument_list|)
decl_stmt|;
name|int
name|want_status
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot open %s: %s\n"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|raw_url
condition|)
name|url
operator|=
name|transport_anonymize_url
argument_list|(
name|raw_url
argument_list|)
expr_stmt|;
else|else
name|url
operator|=
name|xstrdup
argument_list|(
literal|"foreign"
argument_list|)
expr_stmt|;
name|rm
operator|=
name|ref_map
expr_stmt|;
if|if
condition|(
name|check_everything_connected
argument_list|(
name|iterate_ref_map
argument_list|,
literal|0
argument_list|,
operator|&
name|rm
argument_list|)
condition|)
block|{
name|rc
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"%s did not send all necessary objects\n"
argument_list|)
argument_list|,
name|url
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* 	 * We do a pass for each fetch_head_status type in their enum order, so 	 * merged entries are written before not-for-merge. That lets readers 	 * use FETCH_HEAD as a refname to refer to the ref to be merged. 	 */
for|for
control|(
name|want_status
operator|=
name|FETCH_HEAD_MERGE
init|;
name|want_status
operator|<=
name|FETCH_HEAD_IGNORE
condition|;
name|want_status
operator|++
control|)
block|{
for|for
control|(
name|rm
operator|=
name|ref_map
init|;
name|rm
condition|;
name|rm
operator|=
name|rm
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_status_marker
init|=
literal|""
decl_stmt|;
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|rm
operator|->
name|old_sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|rm
operator|->
name|fetch_head_status
operator|=
name|FETCH_HEAD_NOT_FOR_MERGE
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|fetch_head_status
operator|!=
name|want_status
condition|)
continue|continue;
if|if
condition|(
name|rm
operator|->
name|peer_ref
condition|)
block|{
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
operator|+
name|strlen
argument_list|(
name|rm
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|rm
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|rm
operator|->
name|peer_ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|rm
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
name|ref
operator|->
name|force
operator|=
name|rm
operator|->
name|peer_ref
operator|->
name|force
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rm
operator|->
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|""
expr_stmt|;
name|what
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|rm
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|"branch"
expr_stmt|;
name|what
operator|=
name|rm
operator|->
name|name
operator|+
literal|11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|rm
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|"tag"
expr_stmt|;
name|what
operator|=
name|rm
operator|->
name|name
operator|+
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|rm
operator|->
name|name
argument_list|,
literal|"refs/remotes/"
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|"remote-tracking branch"
expr_stmt|;
name|what
operator|=
name|rm
operator|->
name|name
operator|+
literal|13
expr_stmt|;
block|}
else|else
block|{
name|kind
operator|=
literal|""
expr_stmt|;
name|what
operator|=
name|rm
operator|->
name|name
expr_stmt|;
block|}
name|url_len
operator|=
name|strlen
argument_list|(
name|url
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|url_len
operator|-
literal|1
init|;
name|url
index|[
name|i
index|]
operator|==
literal|'/'
operator|&&
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
empty_stmt|;
name|url_len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
literal|4
operator|<
name|i
operator|&&
operator|!
name|strncmp
argument_list|(
literal|".git"
argument_list|,
name|url
operator|+
name|i
operator|-
literal|3
argument_list|,
literal|4
argument_list|)
condition|)
name|url_len
operator|=
name|i
operator|-
literal|3
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|what
condition|)
block|{
if|if
condition|(
operator|*
name|kind
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|note
argument_list|,
literal|"%s "
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|note
argument_list|,
literal|"'%s' of "
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rm
operator|->
name|fetch_head_status
condition|)
block|{
case|case
name|FETCH_HEAD_NOT_FOR_MERGE
case|:
name|merge_status_marker
operator|=
literal|"not-for-merge"
expr_stmt|;
comment|/* fall-through */
case|case
name|FETCH_HEAD_MERGE
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t%s\t%s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|rm
operator|->
name|old_sha1
argument_list|)
argument_list|,
name|merge_status_marker
argument_list|,
name|note
operator|.
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|url_len
condition|;
operator|++
name|i
control|)
if|if
condition|(
literal|'\n'
operator|==
name|url
index|[
name|i
index|]
condition|)
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
name|url
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* do not write anything to FETCH_HEAD */
break|break;
block|}
name|strbuf_reset
argument_list|(
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
condition|)
block|{
name|rc
operator||=
name|update_local_ref
argument_list|(
name|ref
argument_list|,
name|what
argument_list|,
name|rm
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addf
argument_list|(
operator|&
name|note
argument_list|,
literal|"* %-*s %-*s -> FETCH_HEAD"
argument_list|,
name|TRANSPORT_SUMMARY_WIDTH
argument_list|,
operator|*
name|kind
condition|?
name|kind
else|:
literal|"branch"
argument_list|,
name|REFCOL_WIDTH
argument_list|,
operator|*
name|what
condition|?
name|what
else|:
literal|"HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|len
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|0
operator|&&
operator|!
name|shown_url
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"From %.*s\n"
argument_list|)
argument_list|,
name|url_len
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|shown_url
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|note
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rc
operator|&
name|STORE_REF_ERROR_DF_CONFLICT
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"some local refs could not be updated; try running\n"
literal|" 'git remote prune %s' to remove any old, conflicting "
literal|"branches"
argument_list|)
argument_list|,
name|remote_name
argument_list|)
expr_stmt|;
name|abort
label|:
name|strbuf_release
argument_list|(
operator|&
name|note
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_comment
comment|/*  * We would want to bypass the object transfer altogether if  * everything we are going to fetch already exists and is connected  * locally.  */
end_comment
begin_function
DECL|function|quickfetch
specifier|static
name|int
name|quickfetch
parameter_list|(
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|rm
init|=
name|ref_map
decl_stmt|;
comment|/* 	 * If we are deepening a shallow clone we already have these 	 * objects reachable.  Running rev-list here will return with 	 * a good (0) exit status and we'll bypass the fetch that we 	 * really need to perform.  Claiming failure now will ensure 	 * we perform the network exchange to deepen our history. 	 */
if|if
condition|(
name|depth
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|check_everything_connected
argument_list|(
name|iterate_ref_map
argument_list|,
literal|1
argument_list|,
operator|&
name|rm
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fetch_refs
specifier|static
name|int
name|fetch_refs
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|int
name|ret
init|=
name|quickfetch
argument_list|(
name|ref_map
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|transport_fetch_refs
argument_list|(
name|transport
argument_list|,
name|ref_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator||=
name|store_updated_refs
argument_list|(
name|transport
operator|->
name|url
argument_list|,
name|transport
operator|->
name|remote
operator|->
name|name
argument_list|,
name|ref_map
argument_list|)
expr_stmt|;
name|transport_unlock_pack
argument_list|(
name|transport
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|prune_refs
specifier|static
name|int
name|prune_refs
parameter_list|(
name|struct
name|refspec
modifier|*
name|refs
parameter_list|,
name|int
name|ref_count
parameter_list|,
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|stale_refs
init|=
name|get_stale_heads
argument_list|(
name|refs
argument_list|,
name|ref_count
argument_list|,
name|ref_map
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dangling_msg
init|=
name|dry_run
condition|?
name|_
argument_list|(
literal|"   (%s will become dangling)"
argument_list|)
else|:
name|_
argument_list|(
literal|"   (%s has become dangling)"
argument_list|)
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|stale_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|dry_run
condition|)
name|result
operator||=
name|delete_ref
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" x %-*s %-*s -> %s\n"
argument_list|,
name|TRANSPORT_SUMMARY
argument_list|(
name|_
argument_list|(
literal|"[deleted]"
argument_list|)
argument_list|)
argument_list|,
name|REFCOL_WIDTH
argument_list|,
name|_
argument_list|(
literal|"(none)"
argument_list|)
argument_list|,
name|prettify_refname
argument_list|(
name|ref
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|warn_dangling_symref
argument_list|(
name|stderr
argument_list|,
name|dangling_msg
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|free_refs
argument_list|(
name|stale_refs
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|check_not_current_branch
specifier|static
name|void
name|check_not_current_branch
parameter_list|(
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|current_branch
init|=
name|branch_get
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_bare_repository
argument_list|()
operator|||
operator|!
name|current_branch
condition|)
return|return;
for|for
control|(
init|;
name|ref_map
condition|;
name|ref_map
operator|=
name|ref_map
operator|->
name|next
control|)
if|if
condition|(
name|ref_map
operator|->
name|peer_ref
operator|&&
operator|!
name|strcmp
argument_list|(
name|current_branch
operator|->
name|refname
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Refusing to fetch into current branch %s "
literal|"of non-bare repository"
argument_list|)
argument_list|,
name|current_branch
operator|->
name|refname
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|truncate_fetch_head
specifier|static
name|int
name|truncate_fetch_head
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|filename
init|=
name|git_path
argument_list|(
literal|"FETCH_HEAD"
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"cannot open %s: %s\n"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|set_option
specifier|static
name|void
name|set_option
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|r
init|=
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Option \"%s\" value \"%s\" is not valid for %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|transport
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"Option \"%s\" is ignored for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|transport
operator|->
name|url
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_transport
specifier|static
name|struct
name|transport
modifier|*
name|prepare_transport
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
name|struct
name|transport
modifier|*
name|transport
decl_stmt|;
name|transport
operator|=
name|transport_get
argument_list|(
name|remote
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|transport_set_verbosity
argument_list|(
name|transport
argument_list|,
name|verbosity
argument_list|,
name|progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|upload_pack
condition|)
name|set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_UPLOADPACK
argument_list|,
name|upload_pack
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
condition|)
name|set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_KEEP
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
condition|)
name|set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_DEPTH
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return
name|transport
return|;
block|}
end_function
begin_function
DECL|function|backfill_tags
specifier|static
name|void
name|backfill_tags
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
if|if
condition|(
name|transport
operator|->
name|cannot_reuse
condition|)
block|{
name|gsecondary
operator|=
name|prepare_transport
argument_list|(
name|transport
operator|->
name|remote
argument_list|)
expr_stmt|;
name|transport
operator|=
name|gsecondary
expr_stmt|;
block|}
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_FOLLOWTAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_DEPTH
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|fetch_refs
argument_list|(
name|transport
argument_list|,
name|ref_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsecondary
condition|)
block|{
name|transport_disconnect
argument_list|(
name|gsecondary
argument_list|)
expr_stmt|;
name|gsecondary
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|do_fetch
specifier|static
name|int
name|do_fetch
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|refspec
modifier|*
name|refs
parameter_list|,
name|int
name|ref_count
parameter_list|)
block|{
name|struct
name|string_list
name|existing_refs
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref_map
decl_stmt|;
name|struct
name|ref
modifier|*
name|rm
decl_stmt|;
name|int
name|autotags
init|=
operator|(
name|transport
operator|->
name|remote
operator|->
name|fetch_tags
operator|==
literal|1
operator|)
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|for_each_ref
argument_list|(
name|add_existing
argument_list|,
operator|&
name|existing_refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tags
operator|==
name|TAGS_DEFAULT
condition|)
block|{
if|if
condition|(
name|transport
operator|->
name|remote
operator|->
name|fetch_tags
operator|==
literal|2
condition|)
name|tags
operator|=
name|TAGS_SET
expr_stmt|;
if|if
condition|(
name|transport
operator|->
name|remote
operator|->
name|fetch_tags
operator|==
operator|-
literal|1
condition|)
name|tags
operator|=
name|TAGS_UNSET
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|transport
operator|->
name|get_refs_list
operator|||
operator|!
name|transport
operator|->
name|fetch
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Don't know how to fetch from %s"
argument_list|)
argument_list|,
name|transport
operator|->
name|url
argument_list|)
expr_stmt|;
comment|/* if not appending, truncate FETCH_HEAD */
if|if
condition|(
operator|!
name|append
operator|&&
operator|!
name|dry_run
condition|)
block|{
name|retcode
operator|=
name|truncate_fetch_head
argument_list|()
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|ref_map
operator|=
name|get_ref_map
argument_list|(
name|transport
argument_list|,
name|refs
argument_list|,
name|ref_count
argument_list|,
name|tags
argument_list|,
operator|&
name|autotags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update_head_ok
condition|)
name|check_not_current_branch
argument_list|(
name|ref_map
argument_list|)
expr_stmt|;
for|for
control|(
name|rm
operator|=
name|ref_map
init|;
name|rm
condition|;
name|rm
operator|=
name|rm
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rm
operator|->
name|peer_ref
condition|)
block|{
name|struct
name|string_list_item
modifier|*
name|peer_item
init|=
name|string_list_lookup
argument_list|(
operator|&
name|existing_refs
argument_list|,
name|rm
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|peer_item
condition|)
name|hashcpy
argument_list|(
name|rm
operator|->
name|peer_ref
operator|->
name|old_sha1
argument_list|,
name|peer_item
operator|->
name|util
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tags
operator|==
name|TAGS_DEFAULT
operator|&&
name|autotags
condition|)
name|transport_set_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_FOLLOWTAGS
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_refs
argument_list|(
name|transport
argument_list|,
name|ref_map
argument_list|)
condition|)
block|{
name|free_refs
argument_list|(
name|ref_map
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|prune
condition|)
block|{
comment|/* 		 * If --tags was specified, pretend that the user gave us 		 * the canonical tags refspec 		 */
if|if
condition|(
name|tags
operator|==
name|TAGS_SET
condition|)
block|{
specifier|const
name|char
modifier|*
name|tags_str
init|=
literal|"refs/tags/*:refs/tags/*"
decl_stmt|;
name|struct
name|refspec
modifier|*
name|tags_refspec
decl_stmt|,
modifier|*
name|refspec
decl_stmt|;
comment|/* Copy the refspec and add the tags to it */
name|refspec
operator|=
name|xcalloc
argument_list|(
name|ref_count
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refspec
argument_list|)
argument_list|)
expr_stmt|;
name|tags_refspec
operator|=
name|parse_fetch_refspec
argument_list|(
literal|1
argument_list|,
operator|&
name|tags_str
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|refspec
argument_list|,
name|refs
argument_list|,
name|ref_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|refspec
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|refspec
index|[
name|ref_count
index|]
argument_list|,
name|tags_refspec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refspec
argument_list|)
argument_list|)
expr_stmt|;
name|ref_count
operator|++
expr_stmt|;
name|prune_refs
argument_list|(
name|refspec
argument_list|,
name|ref_count
argument_list|,
name|ref_map
argument_list|)
expr_stmt|;
name|ref_count
operator|--
expr_stmt|;
comment|/* The rest of the strings belong to fetch_one */
name|free_refspec
argument_list|(
literal|1
argument_list|,
name|tags_refspec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refspec
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ref_count
condition|)
block|{
name|prune_refs
argument_list|(
name|refs
argument_list|,
name|ref_count
argument_list|,
name|ref_map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prune_refs
argument_list|(
name|transport
operator|->
name|remote
operator|->
name|fetch
argument_list|,
name|transport
operator|->
name|remote
operator|->
name|fetch_refspec_nr
argument_list|,
name|ref_map
argument_list|)
expr_stmt|;
block|}
block|}
name|free_refs
argument_list|(
name|ref_map
argument_list|)
expr_stmt|;
comment|/* if neither --no-tags nor --tags was specified, do automated tag 	 * following ... */
if|if
condition|(
name|tags
operator|==
name|TAGS_DEFAULT
operator|&&
name|autotags
condition|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ref_map
decl_stmt|;
name|ref_map
operator|=
name|NULL
expr_stmt|;
name|find_non_local_tags
argument_list|(
name|transport
argument_list|,
operator|&
name|ref_map
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_map
condition|)
name|backfill_tags
argument_list|(
name|transport
argument_list|,
name|ref_map
argument_list|)
expr_stmt|;
name|free_refs
argument_list|(
name|ref_map
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|string_list_clear
argument_list|(
operator|&
name|existing_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function
begin_function
DECL|function|get_one_remote_for_fetch
specifier|static
name|int
name|get_one_remote_for_fetch
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|string_list
modifier|*
name|list
init|=
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|remote
operator|->
name|skip_default_update
condition|)
name|string_list_append
argument_list|(
name|list
argument_list|,
name|remote
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|remote_group_data
struct|struct
name|remote_group_data
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|list
name|struct
name|string_list
modifier|*
name|list
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|get_remote_group
specifier|static
name|int
name|get_remote_group
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|remote_group_data
modifier|*
name|g
init|=
name|priv
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"remotes."
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|key
operator|+
literal|8
argument_list|,
name|g
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* split list by white space */
name|int
name|space
init|=
name|strcspn
argument_list|(
name|value
argument_list|,
literal|" \t\n"
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|value
condition|)
block|{
if|if
condition|(
name|space
operator|>
literal|1
condition|)
block|{
name|string_list_append
argument_list|(
name|g
operator|->
name|list
argument_list|,
name|xstrndup
argument_list|(
name|value
argument_list|,
name|space
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|value
operator|+=
name|space
operator|+
operator|(
name|value
index|[
name|space
index|]
operator|!=
literal|'\0'
operator|)
expr_stmt|;
name|space
operator|=
name|strcspn
argument_list|(
name|value
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|add_remote_or_group
specifier|static
name|int
name|add_remote_or_group
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|string_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|prev_nr
init|=
name|list
operator|->
name|nr
decl_stmt|;
name|struct
name|remote_group_data
name|g
decl_stmt|;
name|g
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|g
operator|.
name|list
operator|=
name|list
expr_stmt|;
name|git_config
argument_list|(
name|get_remote_group
argument_list|,
operator|&
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|nr
operator|==
name|prev_nr
condition|)
block|{
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
if|if
condition|(
operator|!
name|remote_is_configured
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
name|remote
operator|=
name|remote_get
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
name|list
argument_list|,
name|remote
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|add_options_to_argv
specifier|static
name|void
name|add_options_to_argv
parameter_list|(
name|struct
name|argv_array
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|dry_run
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--dry-run"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prune
operator|>
literal|0
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--prune"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_head_ok
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--update-head-ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--force"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--keep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|recurse_submodules
operator|==
name|RECURSE_SUBMODULES_ON
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--recurse-submodules"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|recurse_submodules
operator|==
name|RECURSE_SUBMODULES_ON_DEMAND
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--recurse-submodules=on-demand"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tags
operator|==
name|TAGS_SET
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--tags"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tags
operator|==
name|TAGS_UNSET
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"--no-tags"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"-v"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"-v"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbosity
operator|<
literal|0
condition|)
name|argv_array_push
argument_list|(
name|argv
argument_list|,
literal|"-q"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fetch_multiple
specifier|static
name|int
name|fetch_multiple
parameter_list|(
name|struct
name|string_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|struct
name|argv_array
name|argv
init|=
name|ARGV_ARRAY_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|append
operator|&&
operator|!
name|dry_run
condition|)
block|{
name|int
name|errcode
init|=
name|truncate_fetch_head
argument_list|()
decl_stmt|;
if|if
condition|(
name|errcode
condition|)
return|return
name|errcode
return|;
block|}
name|argv_array_pushl
argument_list|(
operator|&
name|argv
argument_list|,
literal|"fetch"
argument_list|,
literal|"--append"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_options_to_argv
argument_list|(
operator|&
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|list
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|argv
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Fetching %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_command_v_opt
argument_list|(
name|argv
operator|.
name|argv
argument_list|,
name|RUN_GIT_CMD
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not fetch %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
name|argv_array_pop
argument_list|(
operator|&
name|argv
argument_list|)
expr_stmt|;
block|}
name|argv_array_clear
argument_list|(
operator|&
name|argv
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fetch_one
specifier|static
name|int
name|fetch_one
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|refs
init|=
name|NULL
decl_stmt|;
name|struct
name|refspec
modifier|*
name|refspec
decl_stmt|;
name|int
name|ref_nr
init|=
literal|0
decl_stmt|;
name|int
name|exit_code
decl_stmt|;
if|if
condition|(
operator|!
name|remote
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No remote repository specified.  Please, specify either a URL or a\n"
literal|"remote name from which new revisions should be fetched."
argument_list|)
argument_list|)
expr_stmt|;
name|gtransport
operator|=
name|prepare_transport
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|prune
operator|<
literal|0
condition|)
block|{
comment|/* no command line request */
if|if
condition|(
literal|0
operator|<=
name|gtransport
operator|->
name|remote
operator|->
name|prune
condition|)
name|prune
operator|=
name|gtransport
operator|->
name|remote
operator|->
name|prune
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|<=
name|fetch_prune_config
condition|)
name|prune
operator|=
name|fetch_prune_config
expr_stmt|;
else|else
name|prune
operator|=
name|PRUNE_BY_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|refs
operator|=
name|xcalloc
argument_list|(
name|argc
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"tag"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ref
decl_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"You need to specify a tag name."
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|*
literal|2
operator|+
literal|22
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ref
argument_list|,
literal|"refs/tags/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ref
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ref
argument_list|,
literal|":refs/tags/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ref
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|refs
index|[
name|j
operator|++
index|]
operator|=
name|ref
expr_stmt|;
block|}
else|else
name|refs
index|[
name|j
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|refs
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|ref_nr
operator|=
name|j
expr_stmt|;
block|}
name|sigchain_push_common
argument_list|(
name|unlock_pack_on_signal
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|unlock_pack
argument_list|)
expr_stmt|;
name|refspec
operator|=
name|parse_fetch_refspec
argument_list|(
name|ref_nr
argument_list|,
name|refs
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|do_fetch
argument_list|(
name|gtransport
argument_list|,
name|refspec
argument_list|,
name|ref_nr
argument_list|)
expr_stmt|;
name|free_refspec
argument_list|(
name|ref_nr
argument_list|,
name|refspec
argument_list|)
expr_stmt|;
name|transport_disconnect
argument_list|(
name|gtransport
argument_list|)
expr_stmt|;
name|gtransport
operator|=
name|NULL
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function
begin_function
DECL|function|cmd_fetch
name|int
name|cmd_fetch
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|string_list
name|list
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|argv_gc_auto
index|[]
init|=
block|{
literal|"gc"
block|,
literal|"--auto"
block|,
name|NULL
block|, 	}
decl_stmt|;
name|packet_trace_identity
argument_list|(
literal|"fetch"
argument_list|)
expr_stmt|;
comment|/* Record the command line for the reflog */
name|strbuf_addstr
argument_list|(
operator|&
name|default_rla
argument_list|,
literal|"fetch"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|strbuf_addf
argument_list|(
operator|&
name|default_rla
argument_list|,
literal|" %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_fetch_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_fetch_options
argument_list|,
name|builtin_fetch_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unshallow
condition|)
block|{
if|if
condition|(
name|depth
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--depth and --unshallow cannot be used together"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_repository_shallow
argument_list|()
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--unshallow on a complete repository does not make sense"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
name|char
name|inf_depth
index|[
literal|12
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|inf_depth
argument_list|,
literal|"%d"
argument_list|,
name|INFINITE_DEPTH
argument_list|)
expr_stmt|;
name|depth
operator|=
name|inf_depth
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_OFF
condition|)
block|{
if|if
condition|(
name|recurse_submodules_default
condition|)
block|{
name|int
name|arg
init|=
name|parse_fetch_recurse_submodules_arg
argument_list|(
literal|"--recurse-submodules-default"
argument_list|,
name|recurse_submodules_default
argument_list|)
decl_stmt|;
name|set_config_fetch_recurse_submodules
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|gitmodules_config
argument_list|()
expr_stmt|;
name|git_config
argument_list|(
name|submodule_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|all
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"fetch --all does not take a repository argument"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"fetch --all does not make sense with refspecs"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|for_each_remote
argument_list|(
name|get_one_remote_for_fetch
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|result
operator|=
name|fetch_multiple
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* No arguments -- use default remote */
name|remote
operator|=
name|remote_get
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|fetch_one
argument_list|(
name|remote
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|multiple
condition|)
block|{
comment|/* All arguments are assumed to be remotes or groups */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|add_remote_or_group
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|list
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No such remote or remote group: %s"
argument_list|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|result
operator|=
name|fetch_multiple
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Single remote or group */
operator|(
name|void
operator|)
name|add_remote_or_group
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|.
name|nr
operator|>
literal|1
condition|)
block|{
comment|/* More than one remote */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Fetching a group and specifying refspecs does not make sense"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|fetch_multiple
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Zero or one remotes */
name|remote
operator|=
name|remote_get
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|result
operator|=
name|fetch_one
argument_list|(
name|remote
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|result
operator|&&
operator|(
name|recurse_submodules
operator|!=
name|RECURSE_SUBMODULES_OFF
operator|)
condition|)
block|{
name|struct
name|argv_array
name|options
init|=
name|ARGV_ARRAY_INIT
decl_stmt|;
name|add_options_to_argv
argument_list|(
operator|&
name|options
argument_list|)
expr_stmt|;
name|result
operator|=
name|fetch_populated_submodules
argument_list|(
operator|&
name|options
argument_list|,
name|submodule_prefix
argument_list|,
name|recurse_submodules
argument_list|,
name|verbosity
operator|<
literal|0
argument_list|)
expr_stmt|;
name|argv_array_clear
argument_list|(
operator|&
name|options
argument_list|)
expr_stmt|;
block|}
comment|/* All names were strdup()ed or strndup()ed */
name|list
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_command_v_opt
argument_list|(
name|argv_gc_auto
argument_list|,
name|RUN_GIT_CMD
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
end_unit
