begin_unit
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"pathspec.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"submodule.h"
end_include
begin_include
include|#
directive|include
file|"submodule-config.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"connect.h"
end_include
begin_function
DECL|function|get_default_remote
specifier|static
name|char
modifier|*
name|get_default_remote
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|dest
init|=
name|NULL
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|refname
init|=
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
literal|0
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|refname
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No such ref: %s"
argument_list|)
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
comment|/* detached HEAD */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|refname
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
return|return
name|xstrdup
argument_list|(
literal|"origin"
argument_list|)
return|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|,
operator|&
name|refname
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Expecting a full ref name, got %s"
argument_list|)
argument_list|,
name|refname
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"branch.%s.remote"
argument_list|,
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_get_string
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
operator|&
name|dest
argument_list|)
condition|)
name|ret
operator|=
name|xstrdup
argument_list|(
literal|"origin"
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|dest
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|starts_with_dot_slash
specifier|static
name|int
name|starts_with_dot_slash
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|str
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|is_dir_sep
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|starts_with_dot_dot_slash
specifier|static
name|int
name|starts_with_dot_dot_slash
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|str
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|str
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|is_dir_sep
argument_list|(
name|str
index|[
literal|2
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Returns 1 if it was the last chop before ':'.  */
end_comment
begin_function
DECL|function|chop_last_dir
specifier|static
name|int
name|chop_last_dir
parameter_list|(
name|char
modifier|*
modifier|*
name|remoteurl
parameter_list|,
name|int
name|is_relative
parameter_list|)
block|{
name|char
modifier|*
name|rfind
init|=
name|find_last_dir_sep
argument_list|(
operator|*
name|remoteurl
argument_list|)
decl_stmt|;
if|if
condition|(
name|rfind
condition|)
block|{
operator|*
name|rfind
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rfind
operator|=
name|strrchr
argument_list|(
operator|*
name|remoteurl
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfind
condition|)
block|{
operator|*
name|rfind
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|is_relative
operator|||
operator|!
name|strcmp
argument_list|(
literal|"."
argument_list|,
operator|*
name|remoteurl
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"cannot strip one component off url '%s'"
argument_list|)
argument_list|,
operator|*
name|remoteurl
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|remoteurl
argument_list|)
expr_stmt|;
operator|*
name|remoteurl
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * The `url` argument is the URL that navigates to the submodule origin  * repo. When relative, this URL is relative to the superproject origin  * URL repo. The `up_path` argument, if specified, is the relative  * path that navigates from the submodule working tree to the superproject  * working tree. Returns the origin URL of the submodule.  *  * Return either an absolute URL or filesystem path (if the superproject  * origin URL is an absolute URL or filesystem path, respectively) or a  * relative file system path (if the superproject origin URL is a relative  * file system path).  *  * When the output is a relative file system path, the path is either  * relative to the submodule working tree, if up_path is specified, or to  * the superproject working tree otherwise.  *  * NEEDSWORK: This works incorrectly on the domain and protocol part.  * remote_url      url              outcome          expectation  * http://a.com/b  ../c             http://a.com/c   as is  * http://a.com/b  ../../c          http://c         error out  * http://a.com/b  ../../../c       http:/c          error out  * http://a.com/b  ../../../../c    http:c           error out  * http://a.com/b  ../../../../../c    .:c           error out  * NEEDSWORK: Given how chop_last_dir() works, this function is broken  * when a local part has a colon in its path component, too.  */
end_comment
begin_function
DECL|function|relative_url
specifier|static
name|char
modifier|*
name|relative_url
parameter_list|(
specifier|const
name|char
modifier|*
name|remote_url
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|up_path
parameter_list|)
block|{
name|int
name|is_relative
init|=
literal|0
decl_stmt|;
name|int
name|colonsep
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|remoteurl
init|=
name|xstrdup
argument_list|(
name|remote_url
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|remoteurl
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_dir_sep
argument_list|(
name|remoteurl
index|[
name|len
index|]
argument_list|)
condition|)
name|remoteurl
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|url_is_local_not_ssh
argument_list|(
name|remoteurl
argument_list|)
operator|||
name|is_absolute_path
argument_list|(
name|remoteurl
argument_list|)
condition|)
name|is_relative
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|is_relative
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Prepend a './' to ensure all relative 		 * remoteurls start with './' or '../' 		 */
if|if
condition|(
operator|!
name|starts_with_dot_slash
argument_list|(
name|remoteurl
argument_list|)
operator|&&
operator|!
name|starts_with_dot_dot_slash
argument_list|(
name|remoteurl
argument_list|)
condition|)
block|{
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"./%s"
argument_list|,
name|remoteurl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remoteurl
argument_list|)
expr_stmt|;
name|remoteurl
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * When the url starts with '../', remove that and the 	 * last directory in remoteurl. 	 */
while|while
condition|(
name|url
condition|)
block|{
if|if
condition|(
name|starts_with_dot_dot_slash
argument_list|(
name|url
argument_list|)
condition|)
block|{
name|url
operator|+=
literal|3
expr_stmt|;
name|colonsep
operator||=
name|chop_last_dir
argument_list|(
operator|&
name|remoteurl
argument_list|,
name|is_relative
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starts_with_dot_slash
argument_list|(
name|url
argument_list|)
condition|)
name|url
operator|+=
literal|2
expr_stmt|;
else|else
break|break;
block|}
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s%s%s"
argument_list|,
name|remoteurl
argument_list|,
name|colonsep
condition|?
literal|":"
else|:
literal|"/"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remoteurl
argument_list|)
expr_stmt|;
if|if
condition|(
name|starts_with_dot_slash
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
condition|)
name|out
operator|=
name|xstrdup
argument_list|(
name|sb
operator|.
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
name|out
operator|=
name|xstrdup
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|up_path
operator|||
operator|!
name|is_relative
condition|)
return|return
name|out
return|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s%s"
argument_list|,
name|up_path
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|resolve_relative_url
specifier|static
name|int
name|resolve_relative_url
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
modifier|*
name|remoteurl
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|remote
init|=
name|get_default_remote
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|up_path
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
operator|&&
name|argc
operator|!=
literal|3
condition|)
name|die
argument_list|(
literal|"resolve-relative-url only accepts one or two arguments"
argument_list|)
expr_stmt|;
name|url
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"remote.%s.url"
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_get_string
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
operator|&
name|remoteurl
argument_list|)
condition|)
comment|/* the repository is its own authoritative upstream */
name|remoteurl
operator|=
name|xgetcwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|up_path
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|res
operator|=
name|relative_url
argument_list|(
name|remoteurl
argument_list|,
name|url
argument_list|,
name|up_path
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remoteurl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|resolve_relative_url_test
specifier|static
name|int
name|resolve_relative_url_test
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
modifier|*
name|remoteurl
decl_stmt|,
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|up_path
decl_stmt|,
modifier|*
name|url
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
name|die
argument_list|(
literal|"resolve-relative-url-test only accepts three arguments:<up_path><remoteurl><url>"
argument_list|)
expr_stmt|;
name|up_path
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|remoteurl
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|url
operator|=
name|argv
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|up_path
argument_list|,
literal|"(null)"
argument_list|)
condition|)
name|up_path
operator|=
name|NULL
expr_stmt|;
name|res
operator|=
name|relative_url
argument_list|(
name|remoteurl
argument_list|,
name|url
argument_list|,
name|up_path
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remoteurl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|module_list
struct|struct
name|module_list
block|{
DECL|member|entries
specifier|const
name|struct
name|cache_entry
modifier|*
modifier|*
name|entries
decl_stmt|;
DECL|member|alloc
DECL|member|nr
name|int
name|alloc
decl_stmt|,
name|nr
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|MODULE_LIST_INIT
define|#
directive|define
name|MODULE_LIST_INIT
value|{ NULL, 0, 0 }
end_define
begin_function
DECL|function|module_list_compute
specifier|static
name|int
name|module_list_compute
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|,
name|struct
name|module_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ps_matched
init|=
name|NULL
decl_stmt|;
name|parse_pathspec
argument_list|(
name|pathspec
argument_list|,
literal|0
argument_list|,
name|PATHSPEC_PREFER_FULL
operator||
name|PATHSPEC_STRIP_SUBMODULE_SLASH_CHEAP
argument_list|,
name|prefix
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathspec
operator|->
name|nr
condition|)
name|ps_matched
operator|=
name|xcalloc
argument_list|(
name|pathspec
operator|->
name|nr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"index file corrupt"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|match_pathspec
argument_list|(
name|pathspec
argument_list|,
name|ce
operator|->
name|name
argument_list|,
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
literal|0
argument_list|,
name|ps_matched
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
continue|continue;
name|ALLOC_GROW
argument_list|(
name|list
operator|->
name|entries
argument_list|,
name|list
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|list
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|list
operator|->
name|entries
index|[
name|list
operator|->
name|nr
operator|++
index|]
operator|=
name|ce
expr_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|active_nr
operator|&&
operator|!
name|strcmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|active_cache
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|name
argument_list|)
condition|)
comment|/* 			 * Skip entries with the same name in different stages 			 * to make sure an entry is returned only once. 			 */
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ps_matched
operator|&&
name|report_path_error
argument_list|(
name|ps_matched
argument_list|,
name|pathspec
argument_list|,
name|prefix
argument_list|)
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|ps_matched
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|module_list
specifier|static
name|int
name|module_list
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pathspec
name|pathspec
decl_stmt|;
name|struct
name|module_list
name|list
init|=
name|MODULE_LIST_INIT
decl_stmt|;
name|struct
name|option
name|module_list_options
index|[]
init|=
block|{
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"prefix"
argument_list|,
operator|&
name|prefix
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"alternative anchor for relative paths"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|git_submodule_helper_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git submodule--helper list [--prefix=<path>] [<path>...]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|module_list_options
argument_list|,
name|git_submodule_helper_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|module_list_compute
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
operator|&
name|pathspec
argument_list|,
operator|&
name|list
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|list
operator|.
name|entries
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%06o %s U\t"
argument_list|,
name|ce
operator|->
name|ce_mode
argument_list|,
name|sha1_to_hex
argument_list|(
name|null_sha1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%06o %s %d\t"
argument_list|,
name|ce
operator|->
name|ce_mode
argument_list|,
name|sha1_to_hex
argument_list|(
name|ce
operator|->
name|sha1
argument_list|)
argument_list|,
name|ce_stage
argument_list|(
name|ce
argument_list|)
argument_list|)
expr_stmt|;
name|utf8_fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|init_submodule
specifier|static
name|void
name|init_submodule
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
specifier|const
name|struct
name|submodule
modifier|*
name|sub
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|upd
init|=
name|NULL
decl_stmt|,
modifier|*
name|url
init|=
name|NULL
decl_stmt|,
modifier|*
name|displaypath
decl_stmt|;
comment|/* Only loads from .gitmodules, no overlay with .git/config */
name|gitmodules_config
argument_list|()
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|displaypath
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|displaypath
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|sub
operator|=
name|submodule_from_path
argument_list|(
name|null_sha1
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sub
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No url found for submodule path '%s' in .gitmodules"
argument_list|)
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
comment|/* 	 * Copy url setting when it is not set yet. 	 * To look up the url in .git/config, we must not fall back to 	 * .gitmodules, so look it up directly. 	 */
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"submodule.%s.url"
argument_list|,
name|sub
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_get_string
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
operator|&
name|url
argument_list|)
condition|)
block|{
name|url
operator|=
name|xstrdup
argument_list|(
name|sub
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|url
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"No url found for submodule path '%s' in .gitmodules"
argument_list|)
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
comment|/* Possibly a url relative to parent */
if|if
condition|(
name|starts_with_dot_dot_slash
argument_list|(
name|url
argument_list|)
operator|||
name|starts_with_dot_slash
argument_list|(
name|url
argument_list|)
condition|)
block|{
name|char
modifier|*
name|remoteurl
decl_stmt|,
modifier|*
name|relurl
decl_stmt|;
name|char
modifier|*
name|remote
init|=
name|get_default_remote
argument_list|()
decl_stmt|;
name|struct
name|strbuf
name|remotesb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|remotesb
argument_list|,
literal|"remote.%s.url"
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_get_string
argument_list|(
name|remotesb
operator|.
name|buf
argument_list|,
operator|&
name|remoteurl
argument_list|)
condition|)
comment|/* 				 * The repository is its own 				 * authoritative upstream 				 */
name|remoteurl
operator|=
name|xgetcwd
argument_list|()
expr_stmt|;
name|relurl
operator|=
name|relative_url
argument_list|(
name|remoteurl
argument_list|,
name|url
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|remotesb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remoteurl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|url
operator|=
name|relurl
expr_stmt|;
block|}
if|if
condition|(
name|git_config_set_gently
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|url
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to register url for submodule path '%s'"
argument_list|)
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Submodule '%s' (%s) registered for path '%s'\n"
argument_list|)
argument_list|,
name|sub
operator|->
name|name
argument_list|,
name|url
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
block|}
comment|/* Copy "update" setting when it is not set yet */
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"submodule.%s.update"
argument_list|,
name|sub
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_get_string
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
operator|&
name|upd
argument_list|)
operator|&&
name|sub
operator|->
name|update_strategy
operator|.
name|type
operator|!=
name|SM_UPDATE_UNSPECIFIED
condition|)
block|{
if|if
condition|(
name|sub
operator|->
name|update_strategy
operator|.
name|type
operator|==
name|SM_UPDATE_COMMAND
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"warning: command update mode suggested for submodule '%s'\n"
argument_list|)
argument_list|,
name|sub
operator|->
name|name
argument_list|)
expr_stmt|;
name|upd
operator|=
name|xstrdup
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
block|}
else|else
name|upd
operator|=
name|xstrdup
argument_list|(
name|submodule_strategy_to_string
argument_list|(
operator|&
name|sub
operator|->
name|update_strategy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|git_config_set_gently
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|upd
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to register update mode for submodule path '%s'"
argument_list|)
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|displaypath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|upd
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|module_init
specifier|static
name|int
name|module_init
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|pathspec
name|pathspec
decl_stmt|;
name|struct
name|module_list
name|list
init|=
name|MODULE_LIST_INIT
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|option
name|module_init_options
index|[]
init|=
block|{
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"prefix"
argument_list|,
operator|&
name|prefix
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"alternative anchor for relative paths"
argument_list|)
argument_list|)
block|,
name|OPT__QUIET
argument_list|(
operator|&
name|quiet
argument_list|,
name|N_
argument_list|(
literal|"Suppress output for initializing a submodule"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|git_submodule_helper_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git submodule--helper init [<path>]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|module_init_options
argument_list|,
name|git_submodule_helper_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|module_list_compute
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
operator|&
name|pathspec
argument_list|,
operator|&
name|list
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|nr
condition|;
name|i
operator|++
control|)
name|init_submodule
argument_list|(
name|list
operator|.
name|entries
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|prefix
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|module_name
specifier|static
name|int
name|module_name
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|struct
name|submodule
modifier|*
name|sub
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|usage
argument_list|(
name|_
argument_list|(
literal|"git submodule--helper name<path>"
argument_list|)
argument_list|)
expr_stmt|;
name|gitmodules_config
argument_list|()
expr_stmt|;
name|sub
operator|=
name|submodule_from_path
argument_list|(
name|null_sha1
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sub
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"no submodule mapping found in .gitmodules for path '%s'"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sub
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|clone_submodule
specifier|static
name|int
name|clone_submodule
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|gitdir
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|reference
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|child_process
name|cp
decl_stmt|;
name|child_process_init
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"clone"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--no-checkout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--quiet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|&&
operator|*
name|depth
condition|)
name|argv_array_pushl
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--depth"
argument_list|,
name|depth
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference
operator|&&
operator|*
name|reference
condition|)
name|argv_array_pushl
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--reference"
argument_list|,
name|reference
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gitdir
operator|&&
operator|*
name|gitdir
condition|)
name|argv_array_pushl
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
literal|"--separate-git-dir"
argument_list|,
name|gitdir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|cp
operator|.
name|args
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|cp
operator|.
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|prepare_submodule_repo_env
argument_list|(
operator|&
name|cp
operator|.
name|env_array
argument_list|)
expr_stmt|;
name|cp
operator|.
name|no_stdin
operator|=
literal|1
expr_stmt|;
return|return
name|run_command
argument_list|(
operator|&
name|cp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|module_clone
specifier|static
name|int
name|module_clone
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|,
modifier|*
name|url
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|reference
init|=
name|NULL
decl_stmt|,
modifier|*
name|depth
init|=
name|NULL
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|submodule_dot_git
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|path
init|=
name|NULL
decl_stmt|,
modifier|*
name|sm_gitdir
decl_stmt|;
name|struct
name|strbuf
name|rel_path
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|option
name|module_clone_options
index|[]
init|=
block|{
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"prefix"
argument_list|,
operator|&
name|prefix
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"alternative anchor for relative paths"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"path"
argument_list|,
operator|&
name|path
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"where the new submodule will be cloned to"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"name"
argument_list|,
operator|&
name|name
argument_list|,
name|N_
argument_list|(
literal|"string"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"name of the new submodule"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"url"
argument_list|,
operator|&
name|url
argument_list|,
name|N_
argument_list|(
literal|"string"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"url where to clone the submodule from"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"reference"
argument_list|,
operator|&
name|reference
argument_list|,
name|N_
argument_list|(
literal|"string"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"reference repository"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"depth"
argument_list|,
operator|&
name|depth
argument_list|,
name|N_
argument_list|(
literal|"string"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"depth for shallow clones"
argument_list|)
argument_list|)
block|,
name|OPT__QUIET
argument_list|(
operator|&
name|quiet
argument_list|,
literal|"Suppress output for cloning a submodule"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|git_submodule_helper_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git submodule--helper clone [--prefix=<path>] [--quiet] "
literal|"[--reference<repository>] [--name<name>] [--depth<depth>] "
literal|"--url<url> --path<path>"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|module_clone_options
argument_list|,
name|git_submodule_helper_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|||
operator|!
name|url
operator|||
operator|!
name|path
operator|||
operator|!
operator|*
name|path
condition|)
name|usage_with_options
argument_list|(
name|git_submodule_helper_usage
argument_list|,
name|module_clone_options
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s/modules/%s"
argument_list|,
name|get_git_dir
argument_list|()
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sm_gitdir
operator|=
name|xstrdup
argument_list|(
name|absolute_path
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s/%s"
argument_list|,
name|get_git_work_tree
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|path
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_exists
argument_list|(
name|sm_gitdir
argument_list|)
condition|)
block|{
if|if
condition|(
name|safe_create_leading_directories_const
argument_list|(
name|sm_gitdir
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not create directory '%s'"
argument_list|)
argument_list|,
name|sm_gitdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone_submodule
argument_list|(
name|path
argument_list|,
name|sm_gitdir
argument_list|,
name|url
argument_list|,
name|depth
argument_list|,
name|reference
argument_list|,
name|quiet
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"clone of '%s' into submodule path '%s' failed"
argument_list|)
argument_list|,
name|url
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|safe_create_leading_directories_const
argument_list|(
name|path
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not create directory '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s/index"
argument_list|,
name|sm_gitdir
argument_list|)
expr_stmt|;
name|unlink_or_warn
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
comment|/* Write a .git file in the submodule to redirect to the superproject. */
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s/.git"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_create_leading_directories_const
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not create leading directories of '%s'"
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|submodule_dot_git
operator|=
name|fopen
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|submodule_dot_git
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"cannot open file '%s'"
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|fprintf_or_die
argument_list|(
name|submodule_dot_git
argument_list|,
literal|"gitdir: %s\n"
argument_list|,
name|relative_path
argument_list|(
name|sm_gitdir
argument_list|,
name|path
argument_list|,
operator|&
name|rel_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|submodule_dot_git
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not close file %s"
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|rel_path
argument_list|)
expr_stmt|;
comment|/* Redirect the worktree of the submodule in the superproject's config */
name|p
operator|=
name|git_pathdup_submodule
argument_list|(
name|path
argument_list|,
literal|"config"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not get submodule directory for '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|git_config_set_in_file
argument_list|(
name|p
argument_list|,
literal|"core.worktree"
argument_list|,
name|relative_path
argument_list|(
name|path
argument_list|,
name|sm_gitdir
argument_list|,
operator|&
name|rel_path
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|rel_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm_gitdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|submodule_update_clone
struct|struct
name|submodule_update_clone
block|{
comment|/* index into 'list', the list of submodules to look into for cloning */
DECL|member|current
name|int
name|current
decl_stmt|;
DECL|member|list
name|struct
name|module_list
name|list
decl_stmt|;
DECL|member|warn_if_uninitialized
name|unsigned
name|warn_if_uninitialized
range|:
literal|1
decl_stmt|;
comment|/* update parameter passed via commandline */
DECL|member|update
name|struct
name|submodule_update_strategy
name|update
decl_stmt|;
comment|/* configuration parameters which are passed on to the children */
DECL|member|quiet
name|int
name|quiet
decl_stmt|;
DECL|member|reference
specifier|const
name|char
modifier|*
name|reference
decl_stmt|;
DECL|member|depth
specifier|const
name|char
modifier|*
name|depth
decl_stmt|;
DECL|member|recursive_prefix
specifier|const
name|char
modifier|*
name|recursive_prefix
decl_stmt|;
DECL|member|prefix
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* Machine-readable status lines to be consumed by git-submodule.sh */
DECL|member|projectlines
name|struct
name|string_list
name|projectlines
decl_stmt|;
comment|/* If we want to stop as fast as possible and return an error */
DECL|member|quickstop
name|unsigned
name|quickstop
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|SUBMODULE_UPDATE_CLONE_INIT
define|#
directive|define
name|SUBMODULE_UPDATE_CLONE_INIT
value|{0, MODULE_LIST_INIT, 0, \ 	SUBMODULE_UPDATE_STRATEGY_INIT, 0, NULL, NULL, NULL, NULL, \ 	STRING_LIST_INIT_DUP, 0}
end_define
begin_function
DECL|function|next_submodule_warn_missing
specifier|static
name|void
name|next_submodule_warn_missing
parameter_list|(
name|struct
name|submodule_update_clone
modifier|*
name|suc
parameter_list|,
name|struct
name|strbuf
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|displaypath
parameter_list|)
block|{
comment|/* 	 * Only mention uninitialized submodules when their 	 * paths have been specified. 	 */
if|if
condition|(
name|suc
operator|->
name|warn_if_uninitialized
condition|)
block|{
name|strbuf_addf
argument_list|(
name|out
argument_list|,
name|_
argument_list|(
literal|"Submodule path '%s' not initialized"
argument_list|)
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|out
argument_list|,
name|_
argument_list|(
literal|"Maybe you want to use 'update --init'?"
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/**  * Determine whether 'ce' needs to be cloned. If so, prepare the 'child' to  * run the clone. Returns 1 if 'ce' needs to be cloned, 0 otherwise.  */
end_comment
begin_function
DECL|function|prepare_to_clone_next_submodule
specifier|static
name|int
name|prepare_to_clone_next_submodule
parameter_list|(
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
parameter_list|,
name|struct
name|child_process
modifier|*
name|child
parameter_list|,
name|struct
name|submodule_update_clone
modifier|*
name|suc
parameter_list|,
name|struct
name|strbuf
modifier|*
name|out
parameter_list|)
block|{
specifier|const
name|struct
name|submodule
modifier|*
name|sub
init|=
name|NULL
decl_stmt|;
name|struct
name|strbuf
name|displaypath_sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|displaypath
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|url
init|=
name|NULL
decl_stmt|;
name|int
name|needs_cloning
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ce_stage
argument_list|(
name|ce
argument_list|)
condition|)
block|{
if|if
condition|(
name|suc
operator|->
name|recursive_prefix
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s/%s"
argument_list|,
name|suc
operator|->
name|recursive_prefix
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|out
argument_list|,
name|_
argument_list|(
literal|"Skipping unmerged submodule %s"
argument_list|)
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|sub
operator|=
name|submodule_from_path
argument_list|(
name|null_sha1
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|suc
operator|->
name|recursive_prefix
condition|)
name|displaypath
operator|=
name|relative_path
argument_list|(
name|suc
operator|->
name|recursive_prefix
argument_list|,
name|ce
operator|->
name|name
argument_list|,
operator|&
name|displaypath_sb
argument_list|)
expr_stmt|;
else|else
name|displaypath
operator|=
name|ce
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|sub
condition|)
block|{
name|next_submodule_warn_missing
argument_list|(
name|suc
argument_list|,
name|out
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|suc
operator|->
name|update
operator|.
name|type
operator|==
name|SM_UPDATE_NONE
operator|||
operator|(
name|suc
operator|->
name|update
operator|.
name|type
operator|==
name|SM_UPDATE_UNSPECIFIED
operator|&&
name|sub
operator|->
name|update_strategy
operator|.
name|type
operator|==
name|SM_UPDATE_NONE
operator|)
condition|)
block|{
name|strbuf_addf
argument_list|(
name|out
argument_list|,
name|_
argument_list|(
literal|"Skipping submodule '%s'"
argument_list|)
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|out
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Looking up the url in .git/config. 	 * We must not fall back to .gitmodules as we only want 	 * to process configured submodules. 	 */
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"submodule.%s.url"
argument_list|,
name|sub
operator|->
name|name
argument_list|)
expr_stmt|;
name|git_config_get_string
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
operator|&
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|url
condition|)
block|{
name|next_submodule_warn_missing
argument_list|(
name|suc
argument_list|,
name|out
argument_list|,
name|displaypath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s/.git"
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
name|needs_cloning
operator|=
operator|!
name|file_exists
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%06o %s %d %d\t%s\n"
argument_list|,
name|ce
operator|->
name|ce_mode
argument_list|,
name|sha1_to_hex
argument_list|(
name|ce
operator|->
name|sha1
argument_list|)
argument_list|,
name|ce_stage
argument_list|(
name|ce
argument_list|)
argument_list|,
name|needs_cloning
argument_list|,
name|ce
operator|->
name|name
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|suc
operator|->
name|projectlines
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needs_cloning
condition|)
goto|goto
name|cleanup
goto|;
name|child
operator|->
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|child
operator|->
name|no_stdin
operator|=
literal|1
expr_stmt|;
name|child
operator|->
name|stdout_to_stderr
operator|=
literal|1
expr_stmt|;
name|child
operator|->
name|err
operator|=
operator|-
literal|1
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
literal|"submodule--helper"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
literal|"clone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|suc
operator|->
name|quiet
condition|)
name|argv_array_push
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
literal|"--quiet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|suc
operator|->
name|prefix
condition|)
name|argv_array_pushl
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
literal|"--prefix"
argument_list|,
name|suc
operator|->
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argv_array_pushl
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
literal|"--path"
argument_list|,
name|sub
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argv_array_pushl
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
literal|"--name"
argument_list|,
name|sub
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|argv_array_pushl
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
literal|"--url"
argument_list|,
name|url
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|suc
operator|->
name|reference
condition|)
name|argv_array_push
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
name|suc
operator|->
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|suc
operator|->
name|depth
condition|)
name|argv_array_push
argument_list|(
operator|&
name|child
operator|->
name|args
argument_list|,
name|suc
operator|->
name|depth
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|displaypath_sb
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|needs_cloning
return|;
block|}
end_function
begin_function
DECL|function|update_clone_get_next_task
specifier|static
name|int
name|update_clone_get_next_task
parameter_list|(
name|struct
name|child_process
modifier|*
name|child
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|suc_cb
parameter_list|,
name|void
modifier|*
modifier|*
name|void_task_cb
parameter_list|)
block|{
name|struct
name|submodule_update_clone
modifier|*
name|suc
init|=
name|suc_cb
decl_stmt|;
for|for
control|(
init|;
name|suc
operator|->
name|current
operator|<
name|suc
operator|->
name|list
operator|.
name|nr
condition|;
name|suc
operator|->
name|current
operator|++
control|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|suc
operator|->
name|list
operator|.
name|entries
index|[
name|suc
operator|->
name|current
index|]
decl_stmt|;
if|if
condition|(
name|prepare_to_clone_next_submodule
argument_list|(
name|ce
argument_list|,
name|child
argument_list|,
name|suc
argument_list|,
name|err
argument_list|)
condition|)
block|{
name|suc
operator|->
name|current
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|update_clone_start_failure
specifier|static
name|int
name|update_clone_start_failure
parameter_list|(
name|struct
name|strbuf
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|suc_cb
parameter_list|,
name|void
modifier|*
name|void_task_cb
parameter_list|)
block|{
name|struct
name|submodule_update_clone
modifier|*
name|suc
init|=
name|suc_cb
decl_stmt|;
name|suc
operator|->
name|quickstop
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|update_clone_task_finished
specifier|static
name|int
name|update_clone_task_finished
parameter_list|(
name|int
name|result
parameter_list|,
name|struct
name|strbuf
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|suc_cb
parameter_list|,
name|void
modifier|*
name|void_task_cb
parameter_list|)
block|{
name|struct
name|submodule_update_clone
modifier|*
name|suc
init|=
name|suc_cb
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
literal|0
return|;
name|suc
operator|->
name|quickstop
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|update_clone
specifier|static
name|int
name|update_clone
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|update
init|=
name|NULL
decl_stmt|;
name|int
name|max_jobs
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|pathspec
name|pathspec
decl_stmt|;
name|struct
name|submodule_update_clone
name|suc
init|=
name|SUBMODULE_UPDATE_CLONE_INIT
decl_stmt|;
name|struct
name|option
name|module_update_clone_options
index|[]
init|=
block|{
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"prefix"
argument_list|,
operator|&
name|prefix
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"path into the working tree"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"recursive-prefix"
argument_list|,
operator|&
name|suc
operator|.
name|recursive_prefix
argument_list|,
name|N_
argument_list|(
literal|"path"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"path into the working tree, across nested "
literal|"submodule boundaries"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"update"
argument_list|,
operator|&
name|update
argument_list|,
name|N_
argument_list|(
literal|"string"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"rebase, merge, checkout or none"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"reference"
argument_list|,
operator|&
name|suc
operator|.
name|reference
argument_list|,
name|N_
argument_list|(
literal|"repo"
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"reference repository"
argument_list|)
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"depth"
argument_list|,
operator|&
name|suc
operator|.
name|depth
argument_list|,
literal|"<depth>"
argument_list|,
name|N_
argument_list|(
literal|"Create a shallow clone truncated to the "
literal|"specified number of revisions"
argument_list|)
argument_list|)
block|,
name|OPT_INTEGER
argument_list|(
literal|'j'
argument_list|,
literal|"jobs"
argument_list|,
operator|&
name|max_jobs
argument_list|,
name|N_
argument_list|(
literal|"parallel jobs"
argument_list|)
argument_list|)
block|,
name|OPT__QUIET
argument_list|(
operator|&
name|suc
operator|.
name|quiet
argument_list|,
name|N_
argument_list|(
literal|"don't print cloning progress"
argument_list|)
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|git_submodule_helper_usage
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"git submodule--helper update_clone [--prefix=<path>] [<path>...]"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
name|suc
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|module_update_clone_options
argument_list|,
name|git_submodule_helper_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
if|if
condition|(
name|parse_submodule_update_strategy
argument_list|(
name|update
argument_list|,
operator|&
name|suc
operator|.
name|update
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"bad value for update parameter"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|module_list_compute
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
operator|&
name|pathspec
argument_list|,
operator|&
name|suc
operator|.
name|list
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pathspec
operator|.
name|nr
condition|)
name|suc
operator|.
name|warn_if_uninitialized
operator|=
literal|1
expr_stmt|;
comment|/* Overlay the parsed .gitmodules file with .git/config */
name|gitmodules_config
argument_list|()
expr_stmt|;
name|git_config
argument_list|(
name|submodule_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_jobs
operator|<
literal|0
condition|)
name|max_jobs
operator|=
name|parallel_submodules
argument_list|()
expr_stmt|;
name|run_processes_parallel
argument_list|(
name|max_jobs
argument_list|,
name|update_clone_get_next_task
argument_list|,
name|update_clone_start_failure
argument_list|,
name|update_clone_task_finished
argument_list|,
operator|&
name|suc
argument_list|)
expr_stmt|;
comment|/* 	 * We saved the output and put it out all at once now. 	 * That means: 	 * - the listener does not have to interleave their (checkout) 	 *   work with our fetching.  The writes involved in a 	 *   checkout involve more straightforward sequential I/O. 	 * - the listener can avoid doing any work if fetching failed. 	 */
if|if
condition|(
name|suc
operator|.
name|quickstop
condition|)
return|return
literal|1
return|;
name|for_each_string_list_item
argument_list|(
argument|item
argument_list|,
argument|&suc.projectlines
argument_list|)
name|utf8_fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|item
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|resolve_relative_path
specifier|static
name|int
name|resolve_relative_path
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|die
argument_list|(
literal|"submodule--helper relative_path takes exactly 2 arguments, got %d"
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|relative_path
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|cmd_struct
struct|struct
name|cmd_struct
block|{
DECL|member|cmd
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
DECL|member|fn
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|commands
specifier|static
name|struct
name|cmd_struct
name|commands
index|[]
init|=
block|{
block|{
literal|"list"
block|,
name|module_list
block|}
block|,
block|{
literal|"name"
block|,
name|module_name
block|}
block|,
block|{
literal|"clone"
block|,
name|module_clone
block|}
block|,
block|{
literal|"update-clone"
block|,
name|update_clone
block|}
block|,
block|{
literal|"relative-path"
block|,
name|resolve_relative_path
block|}
block|,
block|{
literal|"resolve-relative-url"
block|,
name|resolve_relative_url
block|}
block|,
block|{
literal|"resolve-relative-url-test"
block|,
name|resolve_relative_url_test
block|}
block|,
block|{
literal|"init"
block|,
name|module_init
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|cmd_submodule__helper
name|int
name|cmd_submodule__helper
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"submodule--helper subcommand must be "
literal|"called with a subcommand"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|commands
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|commands
index|[
name|i
index|]
operator|.
name|cmd
argument_list|)
condition|)
return|return
name|commands
index|[
name|i
index|]
operator|.
name|fn
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|prefix
argument_list|)
return|;
name|die
argument_list|(
name|_
argument_list|(
literal|"'%s' is not a valid submodule--helper "
literal|"subcommand"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
