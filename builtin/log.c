begin_unit
begin_comment
comment|/*  * Builtin "git log" and related commands (show, whatchanged)  *  * (C) Copyright 2006 Linus Torvalds  *		 2006 Junio Hamano  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"reflog-walk.h"
end_include
begin_include
include|#
directive|include
file|"patch-ids.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"shortlog.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"branch.h"
end_include
begin_include
include|#
directive|include
file|"streaming.h"
end_include
begin_include
include|#
directive|include
file|"version.h"
end_include
begin_comment
comment|/* Set a default date-time format for git log ("log.date" config variable) */
end_comment
begin_decl_stmt
DECL|variable|default_date_mode
specifier|static
specifier|const
name|char
modifier|*
name|default_date_mode
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_abbrev_commit
specifier|static
name|int
name|default_abbrev_commit
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_show_root
specifier|static
name|int
name|default_show_root
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decoration_style
specifier|static
name|int
name|decoration_style
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|decoration_given
specifier|static
name|int
name|decoration_given
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fmt_patch_subject_prefix
specifier|static
specifier|const
name|char
modifier|*
name|fmt_patch_subject_prefix
init|=
literal|"PATCH"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|fmt_pretty
specifier|static
specifier|const
name|char
modifier|*
name|fmt_pretty
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|builtin_log_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_log_usage
index|[]
init|=
block|{
literal|"git log [<options>] [<since>..<until>] [[--]<path>...]\n"
literal|"   or: git show [options]<object>..."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parse_decoration_style
specifier|static
name|int
name|parse_decoration_style
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|git_config_maybe_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DECORATE_SHORT_REFS
return|;
case|case
literal|0
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"full"
argument_list|)
condition|)
return|return
name|DECORATE_FULL_REFS
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"short"
argument_list|)
condition|)
return|return
name|DECORATE_SHORT_REFS
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|decorate_callback
specifier|static
name|int
name|decorate_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
name|decoration_style
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
condition|)
name|decoration_style
operator|=
name|parse_decoration_style
argument_list|(
literal|"command line"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|decoration_style
operator|=
name|DECORATE_SHORT_REFS
expr_stmt|;
if|if
condition|(
name|decoration_style
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"invalid --decorate option: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|decoration_given
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cmd_log_init_defaults
specifier|static
name|void
name|cmd_log_init_defaults
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
if|if
condition|(
name|fmt_pretty
condition|)
name|get_commit_format
argument_list|(
name|fmt_pretty
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|rev
operator|->
name|verbose_header
operator|=
literal|1
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|rev
operator|->
name|diffopt
operator|.
name|stat_width
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* use full terminal width */
name|rev
operator|->
name|diffopt
operator|.
name|stat_graph_width
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* respect statGraphWidth config */
name|rev
operator|->
name|abbrev_commit
operator|=
name|default_abbrev_commit
expr_stmt|;
name|rev
operator|->
name|show_root_diff
operator|=
name|default_show_root
expr_stmt|;
name|rev
operator|->
name|subject_prefix
operator|=
name|fmt_patch_subject_prefix
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
name|ALLOW_TEXTCONV
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_date_mode
condition|)
name|rev
operator|->
name|date_mode
operator|=
name|parse_date_format
argument_list|(
name|default_date_mode
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cmd_log_init_finish
specifier|static
name|void
name|cmd_log_init_finish
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|setup_revision_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|userformat_want
name|w
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|,
name|source
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|option
name|builtin_log_options
index|[]
init|=
block|{
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"quiet"
argument_list|,
operator|&
name|quiet
argument_list|,
literal|"suppress diff output"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"source"
argument_list|,
operator|&
name|source
argument_list|,
literal|"show source"
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"decorate"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"decorate options"
block|,
name|PARSE_OPT_OPTARG
block|,
name|decorate_callback
block|}
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_log_options
argument_list|,
name|builtin_log_usage
argument_list|,
name|PARSE_OPT_KEEP_ARGV0
operator||
name|PARSE_OPT_KEEP_UNKNOWN
operator||
name|PARSE_OPT_KEEP_DASHDASH
argument_list|)
expr_stmt|;
name|argc
operator|=
name|setup_revisions
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rev
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
name|rev
operator|->
name|diffopt
operator|.
name|output_format
operator||=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
comment|/* Any arguments at this point are not recognized */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|die
argument_list|(
literal|"unrecognized argument: %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|w
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|userformat_find_requirements
argument_list|(
name|NULL
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
operator|->
name|show_notes_given
operator|&&
operator|(
operator|!
name|rev
operator|->
name|pretty_given
operator|||
name|w
operator|.
name|notes
operator|)
condition|)
name|rev
operator|->
name|show_notes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|show_notes
condition|)
name|init_display_notes
argument_list|(
operator|&
name|rev
operator|->
name|notes_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|diffopt
operator|.
name|pickaxe
operator|||
name|rev
operator|->
name|diffopt
operator|.
name|filter
condition|)
name|rev
operator|->
name|always_show_header
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DIFF_OPT_TST
argument_list|(
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
name|FOLLOW_RENAMES
argument_list|)
condition|)
block|{
name|rev
operator|->
name|always_show_header
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|diffopt
operator|.
name|pathspec
operator|.
name|nr
operator|!=
literal|1
condition|)
name|usage
argument_list|(
literal|"git logs can only follow renames on one pathname at a time"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
condition|)
name|rev
operator|->
name|show_source
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|pretty_given
operator|&&
name|rev
operator|->
name|commit_format
operator|==
name|CMIT_FMT_RAW
condition|)
block|{
comment|/* 		 * "log --pretty=raw" is special; ignore UI oriented 		 * configuration variables such as decoration. 		 */
if|if
condition|(
operator|!
name|decoration_given
condition|)
name|decoration_style
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rev
operator|->
name|abbrev_commit_given
condition|)
name|rev
operator|->
name|abbrev_commit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decoration_style
condition|)
block|{
name|rev
operator|->
name|show_decorations
operator|=
literal|1
expr_stmt|;
name|load_ref_decorations
argument_list|(
name|decoration_style
argument_list|)
expr_stmt|;
block|}
name|setup_pager
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cmd_log_init
specifier|static
name|void
name|cmd_log_init
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|setup_revision_opt
modifier|*
name|opt
parameter_list|)
block|{
name|cmd_log_init_defaults
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|cmd_log_init_finish
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|rev
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * This gives a rough estimate for how many commits we  * will print out in the list.  */
end_comment
begin_function
DECL|function|estimate_commit_count
specifier|static
name|int
name|estimate_commit_count
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|list
operator|->
name|item
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
name|commit
operator|->
name|object
operator|.
name|flags
decl_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|TREESAME
operator||
name|UNINTERESTING
operator|)
operator|)
condition|)
name|n
operator|++
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|show_early_header
specifier|static
name|void
name|show_early_header
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|stage
parameter_list|,
name|int
name|nr
parameter_list|)
block|{
if|if
condition|(
name|rev
operator|->
name|shown_one
condition|)
block|{
name|rev
operator|->
name|shown_one
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|commit_format
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|putchar
argument_list|(
name|rev
operator|->
name|diffopt
operator|.
name|line_termination
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Final output: %d %s\n"
argument_list|)
argument_list|,
name|nr
argument_list|,
name|stage
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|early_output_timer
specifier|static
name|struct
name|itimerval
name|early_output_timer
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|log_show_early
specifier|static
name|void
name|log_show_early
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
init|=
name|revs
operator|->
name|early_output
decl_stmt|;
name|int
name|show_header
init|=
literal|1
decl_stmt|;
name|sort_in_topological_order
argument_list|(
operator|&
name|list
argument_list|,
name|revs
operator|->
name|lifo
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
operator|&&
name|i
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|list
operator|->
name|item
decl_stmt|;
switch|switch
condition|(
name|simplify_commit
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
condition|)
block|{
case|case
name|commit_show
case|:
if|if
condition|(
name|show_header
condition|)
block|{
name|int
name|n
init|=
name|estimate_commit_count
argument_list|(
name|revs
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|show_early_header
argument_list|(
name|revs
argument_list|,
literal|"incomplete"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|show_header
operator|=
literal|0
expr_stmt|;
block|}
name|log_tree_commit
argument_list|(
name|revs
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
break|break;
case|case
name|commit_ignore
case|:
break|break;
case|case
name|commit_error
case|:
return|return;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
comment|/* Did we already get enough commits for the early output? */
if|if
condition|(
operator|!
name|i
condition|)
return|return;
comment|/* 	 * ..if no, then repeat it twice a second until we 	 * do. 	 * 	 * NOTE! We don't use "it_interval", because if the 	 * reader isn't listening, we want our output to be 	 * throttled by the writing, and not have the timer 	 * trigger every second even if we're blocked on a 	 * reader! 	 */
name|early_output_timer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|early_output_timer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|early_output_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|early_output
specifier|static
name|void
name|early_output
parameter_list|(
name|int
name|signal
parameter_list|)
block|{
name|show_early_output
operator|=
name|log_show_early
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setup_early_output
specifier|static
name|void
name|setup_early_output
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|;
comment|/* 	 * Set up the signal handler, minimally intrusively: 	 * we only set a single volatile integer word (not 	 * using sigatomic_t - trying to avoid unnecessary 	 * system dependencies and headers), and using 	 * SA_RESTART. 	 */
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|early_output
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If we can get the whole output in less than a 	 * tenth of a second, don't even bother doing the 	 * early-output thing.. 	 * 	 * This is a one-time-only trigger. 	 */
name|early_output_timer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|early_output_timer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|100000
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|early_output_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finish_early_output
specifier|static
name|void
name|finish_early_output
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|int
name|n
init|=
name|estimate_commit_count
argument_list|(
name|rev
argument_list|,
name|rev
operator|->
name|commits
argument_list|)
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|show_early_header
argument_list|(
name|rev
argument_list|,
literal|"done"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cmd_log_walk
specifier|static
name|int
name|cmd_log_walk
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|int
name|saved_nrl
init|=
literal|0
decl_stmt|;
name|int
name|saved_dcctc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rev
operator|->
name|early_output
condition|)
name|setup_early_output
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
name|rev
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|early_output
condition|)
name|finish_early_output
argument_list|(
name|rev
argument_list|)
expr_stmt|;
comment|/* 	 * For --check and --exit-code, the exit code is based on CHECK_FAILED 	 * and HAS_CHANGES being accumulated in rev->diffopt, so be careful to 	 * retain that state information if replacing rev->diffopt in this loop 	 */
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
name|rev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|log_tree_commit
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|)
operator|&&
name|rev
operator|->
name|max_count
operator|>=
literal|0
condition|)
comment|/* 			 * We decremented max_count in get_revision, 			 * but we didn't actually show the commit. 			 */
name|rev
operator|->
name|max_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rev
operator|->
name|reflog_info
condition|)
block|{
comment|/* we allow cycles in reflog ancestry */
name|free
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|commit
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
name|free_commit_list
argument_list|(
name|commit
operator|->
name|parents
argument_list|)
expr_stmt|;
name|commit
operator|->
name|parents
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|saved_nrl
operator|<
name|rev
operator|->
name|diffopt
operator|.
name|needed_rename_limit
condition|)
name|saved_nrl
operator|=
name|rev
operator|->
name|diffopt
operator|.
name|needed_rename_limit
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|diffopt
operator|.
name|degraded_cc_to_c
condition|)
name|saved_dcctc
operator|=
literal|1
expr_stmt|;
block|}
name|rev
operator|->
name|diffopt
operator|.
name|degraded_cc_to_c
operator|=
name|saved_dcctc
expr_stmt|;
name|rev
operator|->
name|diffopt
operator|.
name|needed_rename_limit
operator|=
name|saved_nrl
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|diffopt
operator|.
name|output_format
operator|&
name|DIFF_FORMAT_CHECKDIFF
operator|&&
name|DIFF_OPT_TST
argument_list|(
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
name|CHECK_FAILED
argument_list|)
condition|)
block|{
return|return
literal|02
return|;
block|}
return|return
name|diff_result_code
argument_list|(
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_log_config
specifier|static
name|int
name|git_log_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.pretty"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|fmt_pretty
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.subjectprefix"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|fmt_patch_subject_prefix
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"log.abbrevcommit"
argument_list|)
condition|)
block|{
name|default_abbrev_commit
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"log.date"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|default_date_mode
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"log.decorate"
argument_list|)
condition|)
block|{
name|decoration_style
operator|=
name|parse_decoration_style
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoration_style
operator|<
literal|0
condition|)
name|decoration_style
operator|=
literal|0
expr_stmt|;
comment|/* maybe warn? */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"log.showroot"
argument_list|)
condition|)
block|{
name|default_show_root
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|var
argument_list|,
literal|"color.decorate."
argument_list|)
condition|)
return|return
name|parse_decorate_color_config
argument_list|(
name|var
argument_list|,
literal|15
argument_list|,
name|value
argument_list|)
return|;
return|return
name|git_diff_ui_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_whatchanged
name|int
name|cmd_whatchanged
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|setup_revision_opt
name|opt
decl_stmt|;
name|git_config
argument_list|(
name|git_log_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|rev
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|simplify_history
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|def
operator|=
literal|"HEAD"
expr_stmt|;
name|opt
operator|.
name|revarg_opt
operator|=
name|REVARG_COMMITTISH
expr_stmt|;
name|cmd_log_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
operator|.
name|diffopt
operator|.
name|output_format
condition|)
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_RAW
expr_stmt|;
return|return
name|cmd_log_walk
argument_list|(
operator|&
name|rev
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|show_tagger
specifier|static
name|void
name|show_tagger
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|strbuf
name|out
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|pretty_print_context
name|pp
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pp
operator|.
name|fmt
operator|=
name|rev
operator|->
name|commit_format
expr_stmt|;
name|pp
operator|.
name|date_mode
operator|=
name|rev
operator|->
name|date_mode
expr_stmt|;
name|pp_user_info
argument_list|(
operator|&
name|pp
argument_list|,
literal|"Tagger"
argument_list|,
operator|&
name|out
argument_list|,
name|buf
argument_list|,
name|get_log_output_encoding
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|out
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_blob_object
specifier|static
name|int
name|show_blob_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|stream_blob_to_fd
argument_list|(
literal|1
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|show_tag_object
specifier|static
name|int
name|show_tag_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not read object %s"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
name|assert
argument_list|(
name|type
operator|==
name|OBJ_TAG
argument_list|)
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|size
operator|&&
name|buf
index|[
name|offset
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|int
name|new_offset
init|=
name|offset
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|new_offset
operator|<
name|size
operator|&&
name|buf
index|[
name|new_offset
operator|++
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|"tagger "
argument_list|)
condition|)
name|show_tagger
argument_list|(
name|buf
operator|+
name|offset
operator|+
literal|7
argument_list|,
name|new_offset
operator|-
name|offset
operator|-
literal|7
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|offset
operator|=
name|new_offset
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
name|size
condition|)
name|fwrite
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|size
operator|-
name|offset
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|show_tree_object
specifier|static
name|int
name|show_tree_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|unsigned
name|mode
parameter_list|,
name|int
name|stage
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
name|pathname
argument_list|,
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|?
literal|"/"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|show_rev_tweak_rev
specifier|static
name|void
name|show_rev_tweak_rev
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|setup_revision_opt
modifier|*
name|opt
parameter_list|)
block|{
if|if
condition|(
name|rev
operator|->
name|ignore_merges
condition|)
block|{
comment|/* There was no "-m" on the command line */
name|rev
operator|->
name|ignore_merges
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rev
operator|->
name|first_parent_only
operator|&&
operator|!
name|rev
operator|->
name|combine_merges
condition|)
block|{
comment|/* No "--first-parent", "-c", nor "--cc" */
name|rev
operator|->
name|combine_merges
operator|=
literal|1
expr_stmt|;
name|rev
operator|->
name|dense_combined_merges
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rev
operator|->
name|diffopt
operator|.
name|output_format
condition|)
name|rev
operator|->
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_PATCH
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cmd_show
name|int
name|cmd_show
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|object_array_entry
modifier|*
name|objects
decl_stmt|;
name|struct
name|setup_revision_opt
name|opt
decl_stmt|;
name|struct
name|pathspec
name|match_all
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|git_config
argument_list|(
name|git_log_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_pathspec
argument_list|(
operator|&
name|match_all
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|rev
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|always_show_header
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|no_walk
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|stat_width
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Scale to real terminal size */
name|memset
argument_list|(
operator|&
name|opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|def
operator|=
literal|"HEAD"
expr_stmt|;
name|opt
operator|.
name|tweak
operator|=
name|show_rev_tweak_rev
expr_stmt|;
name|cmd_log_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
operator|.
name|no_walk
condition|)
return|return
name|cmd_log_walk
argument_list|(
operator|&
name|rev
argument_list|)
return|;
name|count
operator|=
name|rev
operator|.
name|pending
operator|.
name|nr
expr_stmt|;
name|objects
operator|=
name|rev
operator|.
name|pending
operator|.
name|objects
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
operator|!
name|ret
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|objects
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
switch|switch
condition|(
name|o
operator|->
name|type
condition|)
block|{
case|case
name|OBJ_BLOB
case|:
name|ret
operator|=
name|show_blob_object
argument_list|(
name|o
operator|->
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_TAG
case|:
block|{
name|struct
name|tag
modifier|*
name|t
init|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|rev
operator|.
name|shown_one
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%stag %s%s\n"
argument_list|,
name|diff_get_color_opt
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|DIFF_COMMIT
argument_list|)
argument_list|,
name|t
operator|->
name|tag
argument_list|,
name|diff_get_color_opt
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|DIFF_RESET
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|show_tag_object
argument_list|(
name|o
operator|->
name|sha1
argument_list|,
operator|&
name|rev
argument_list|)
expr_stmt|;
name|rev
operator|.
name|shown_one
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|o
operator|=
name|parse_object
argument_list|(
name|t
operator|->
name|tagged
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
name|ret
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not read object %s"
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|t
operator|->
name|tagged
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|objects
index|[
name|i
index|]
operator|.
name|item
operator|=
name|o
expr_stmt|;
name|i
operator|--
expr_stmt|;
break|break;
block|}
case|case
name|OBJ_TREE
case|:
if|if
condition|(
name|rev
operator|.
name|shown_one
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%stree %s%s\n\n"
argument_list|,
name|diff_get_color_opt
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|DIFF_COMMIT
argument_list|)
argument_list|,
name|name
argument_list|,
name|diff_get_color_opt
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|DIFF_RESET
argument_list|)
argument_list|)
expr_stmt|;
name|read_tree_recursive
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|)
name|o
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|match_all
argument_list|,
name|show_tree_object
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|shown_one
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
name|rev
operator|.
name|pending
operator|.
name|nr
operator|=
name|rev
operator|.
name|pending
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
name|rev
operator|.
name|pending
operator|.
name|objects
operator|=
name|NULL
expr_stmt|;
name|add_object_array
argument_list|(
name|o
argument_list|,
name|name
argument_list|,
operator|&
name|rev
operator|.
name|pending
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cmd_log_walk
argument_list|(
operator|&
name|rev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|error
argument_list|(
name|_
argument_list|(
literal|"Unknown type: %d"
argument_list|)
argument_list|,
name|o
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|objects
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * This is equivalent to "git log -g --abbrev-commit --pretty=oneline"  */
end_comment
begin_function
DECL|function|cmd_log_reflog
name|int
name|cmd_log_reflog
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|setup_revision_opt
name|opt
decl_stmt|;
name|git_config
argument_list|(
name|git_log_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|init_reflog_walk
argument_list|(
operator|&
name|rev
operator|.
name|reflog_info
argument_list|)
expr_stmt|;
name|rev
operator|.
name|verbose_header
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|def
operator|=
literal|"HEAD"
expr_stmt|;
name|cmd_log_init_defaults
argument_list|(
operator|&
name|rev
argument_list|)
expr_stmt|;
name|rev
operator|.
name|abbrev_commit
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|commit_format
operator|=
name|CMIT_FMT_ONELINE
expr_stmt|;
name|rev
operator|.
name|use_terminator
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|always_show_header
operator|=
literal|1
expr_stmt|;
name|cmd_log_init_finish
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
return|return
name|cmd_log_walk
argument_list|(
operator|&
name|rev
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_log
name|int
name|cmd_log
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|setup_revision_opt
name|opt
decl_stmt|;
name|git_config
argument_list|(
name|git_log_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|rev
operator|.
name|always_show_header
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|def
operator|=
literal|"HEAD"
expr_stmt|;
name|opt
operator|.
name|revarg_opt
operator|=
name|REVARG_COMMITTISH
expr_stmt|;
name|cmd_log_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
return|return
name|cmd_log_walk
argument_list|(
operator|&
name|rev
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* format-patch */
end_comment
begin_decl_stmt
DECL|variable|fmt_patch_suffix
specifier|static
specifier|const
name|char
modifier|*
name|fmt_patch_suffix
init|=
literal|".patch"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|numbered
specifier|static
name|int
name|numbered
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|auto_number
specifier|static
name|int
name|auto_number
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_attach
specifier|static
name|char
modifier|*
name|default_attach
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|extra_hdr
specifier|static
name|struct
name|string_list
name|extra_hdr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|extra_to
specifier|static
name|struct
name|string_list
name|extra_to
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|extra_cc
specifier|static
name|struct
name|string_list
name|extra_cc
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|add_header
specifier|static
name|void
name|add_header
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|value
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|value
argument_list|,
literal|"to: "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|item
operator|=
name|string_list_append
argument_list|(
operator|&
name|extra_to
argument_list|,
name|value
operator|+
literal|4
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|value
argument_list|,
literal|"cc: "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|item
operator|=
name|string_list_append
argument_list|(
operator|&
name|extra_cc
argument_list|,
name|value
operator|+
literal|4
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|string_list_append
argument_list|(
operator|&
name|extra_hdr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|string
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|THREAD_SHALLOW
define|#
directive|define
name|THREAD_SHALLOW
value|1
end_define
begin_define
DECL|macro|THREAD_DEEP
define|#
directive|define
name|THREAD_DEEP
value|2
end_define
begin_decl_stmt
DECL|variable|thread
specifier|static
name|int
name|thread
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|do_signoff
specifier|static
name|int
name|do_signoff
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|signature
specifier|static
specifier|const
name|char
modifier|*
name|signature
init|=
name|git_version_string
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_format_config
specifier|static
name|int
name|git_format_config
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.headers"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"format.headers without value"
argument_list|)
argument_list|)
expr_stmt|;
name|add_header
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.suffix"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|fmt_patch_suffix
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.to"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
name|string_list_append
argument_list|(
operator|&
name|extra_to
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.cc"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|var
argument_list|)
return|;
name|string_list_append
argument_list|(
operator|&
name|extra_cc
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"diff.color"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"color.diff"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"color.ui"
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.numbered"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"auto"
argument_list|)
condition|)
block|{
name|auto_number
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|numbered
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|auto_number
operator|=
name|auto_number
operator|&&
name|numbered
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.attach"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
name|default_attach
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|default_attach
operator|=
name|xstrdup
argument_list|(
name|git_version_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.thread"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"deep"
argument_list|)
condition|)
block|{
name|thread
operator|=
name|THREAD_DEEP
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|value
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|value
argument_list|,
literal|"shallow"
argument_list|)
condition|)
block|{
name|thread
operator|=
name|THREAD_SHALLOW
expr_stmt|;
return|return
literal|0
return|;
block|}
name|thread
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
operator|&&
name|THREAD_SHALLOW
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.signoff"
argument_list|)
condition|)
block|{
name|do_signoff
operator|=
name|git_config_bool
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"format.signature"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|signature
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
return|;
return|return
name|git_log_config
argument_list|(
name|var
argument_list|,
name|value
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|realstdout
specifier|static
name|FILE
modifier|*
name|realstdout
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|output_directory
specifier|static
specifier|const
name|char
modifier|*
name|output_directory
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|outdir_offset
specifier|static
name|int
name|outdir_offset
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|reopen_stdout
specifier|static
name|int
name|reopen_stdout
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|subject
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|strbuf
name|filename
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|suffix_len
init|=
name|strlen
argument_list|(
name|fmt_patch_suffix
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|output_directory
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|filename
argument_list|,
name|output_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|.
name|len
operator|>=
name|PATH_MAX
operator|-
name|FORMAT_PATCH_NAME_MAX
operator|-
name|suffix_len
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"name of output directory is too long"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|filename
operator|.
name|buf
index|[
name|filename
operator|.
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|get_patch_filename
argument_list|(
name|commit
argument_list|,
name|subject
argument_list|,
name|rev
operator|->
name|nr
argument_list|,
name|fmt_patch_suffix
argument_list|,
operator|&
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|realstdout
argument_list|,
literal|"%s\n"
argument_list|,
name|filename
operator|.
name|buf
operator|+
name|outdir_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|filename
operator|.
name|buf
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot open patch file %s"
argument_list|)
argument_list|,
name|filename
operator|.
name|buf
argument_list|)
return|;
name|strbuf_release
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_patch_ids
specifier|static
name|void
name|get_patch_ids
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|struct
name|patch_ids
modifier|*
name|ids
parameter_list|)
block|{
name|struct
name|rev_info
name|check_rev
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|object
modifier|*
name|o1
decl_stmt|,
modifier|*
name|o2
decl_stmt|;
name|unsigned
name|flags1
decl_stmt|,
name|flags2
decl_stmt|;
if|if
condition|(
name|rev
operator|->
name|pending
operator|.
name|nr
operator|!=
literal|2
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Need exactly one range."
argument_list|)
argument_list|)
expr_stmt|;
name|o1
operator|=
name|rev
operator|->
name|pending
operator|.
name|objects
index|[
literal|0
index|]
operator|.
name|item
expr_stmt|;
name|flags1
operator|=
name|o1
operator|->
name|flags
expr_stmt|;
name|o2
operator|=
name|rev
operator|->
name|pending
operator|.
name|objects
index|[
literal|1
index|]
operator|.
name|item
expr_stmt|;
name|flags2
operator|=
name|o2
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags1
operator|&
name|UNINTERESTING
operator|)
operator|==
operator|(
name|flags2
operator|&
name|UNINTERESTING
operator|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Not a range."
argument_list|)
argument_list|)
expr_stmt|;
name|init_patch_ids
argument_list|(
name|ids
argument_list|)
expr_stmt|;
comment|/* given a range a..b get all patch ids for b..a */
name|init_revisions
argument_list|(
operator|&
name|check_rev
argument_list|,
name|rev
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|o1
operator|->
name|flags
operator|^=
name|UNINTERESTING
expr_stmt|;
name|o2
operator|->
name|flags
operator|^=
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|check_rev
argument_list|,
name|o1
argument_list|,
literal|"o1"
argument_list|)
expr_stmt|;
name|add_pending_object
argument_list|(
operator|&
name|check_rev
argument_list|,
name|o2
argument_list|,
literal|"o2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|check_rev
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
operator|&
name|check_rev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* ignore merges */
if|if
condition|(
name|commit
operator|->
name|parents
operator|&&
name|commit
operator|->
name|parents
operator|->
name|next
condition|)
continue|continue;
name|add_commit_patch_id
argument_list|(
name|commit
argument_list|,
name|ids
argument_list|)
expr_stmt|;
block|}
comment|/* reset for next revision walk */
name|clear_commit_marks
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o1
argument_list|,
name|SEEN
operator||
name|UNINTERESTING
operator||
name|SHOWN
operator||
name|ADDED
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o2
argument_list|,
name|SEEN
operator||
name|UNINTERESTING
operator||
name|SHOWN
operator||
name|ADDED
argument_list|)
expr_stmt|;
name|o1
operator|->
name|flags
operator|=
name|flags1
expr_stmt|;
name|o2
operator|->
name|flags
operator|=
name|flags2
expr_stmt|;
block|}
end_function
begin_function
DECL|function|gen_message_id
specifier|static
name|void
name|gen_message_id
parameter_list|(
name|struct
name|rev_info
modifier|*
name|info
parameter_list|,
name|char
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s.%lu.git.%s"
argument_list|,
name|base
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|git_committer_info
argument_list|(
name|IDENT_NO_NAME
operator||
name|IDENT_NO_DATE
operator||
name|IDENT_STRICT
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|message_id
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|print_signature
specifier|static
name|void
name|print_signature
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|signature
operator|&&
operator|*
name|signature
condition|)
name|printf
argument_list|(
literal|"-- \n%s\n\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_branch_description
specifier|static
name|void
name|add_branch_description
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|branch_name
parameter_list|)
block|{
name|struct
name|strbuf
name|desc
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|branch_name
operator|||
operator|!
operator|*
name|branch_name
condition|)
return|return;
name|read_branch_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|.
name|len
condition|)
block|{
name|strbuf_addch
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|buf
argument_list|,
name|desc
operator|.
name|buf
argument_list|,
name|desc
operator|.
name|len
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|make_cover_letter
specifier|static
name|void
name|make_cover_letter
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
name|int
name|use_stdout
parameter_list|,
name|int
name|numbered
parameter_list|,
name|int
name|numbered_files
parameter_list|,
name|struct
name|commit
modifier|*
name|origin
parameter_list|,
name|int
name|nr
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|commit
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|branch_name
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|committer
decl_stmt|;
specifier|const
name|char
modifier|*
name|body
init|=
literal|"*** SUBJECT HERE ***\n\n*** BLURB HERE ***\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|struct
name|shortlog
name|log
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
init|=
literal|"UTF-8"
decl_stmt|;
name|struct
name|diff_options
name|opts
decl_stmt|;
name|int
name|need_8bit_cte
init|=
literal|0
decl_stmt|;
name|struct
name|pretty_print_context
name|pp
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|rev
operator|->
name|commit_format
operator|!=
name|CMIT_FMT_EMAIL
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Cover letter needs email format"
argument_list|)
argument_list|)
expr_stmt|;
name|committer
operator|=
name|git_committer_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_stdout
operator|&&
name|reopen_stdout
argument_list|(
name|NULL
argument_list|,
name|numbered_files
condition|?
name|NULL
else|:
literal|"cover-letter"
argument_list|,
name|rev
argument_list|,
name|quiet
argument_list|)
condition|)
return|return;
name|log_write_email_headers
argument_list|(
name|rev
argument_list|,
name|head
argument_list|,
operator|&
name|pp
operator|.
name|subject
argument_list|,
operator|&
name|pp
operator|.
name|after_subject
argument_list|,
operator|&
name|need_8bit_cte
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|need_8bit_cte
operator|&&
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|has_non_ascii
argument_list|(
name|list
index|[
name|i
index|]
operator|->
name|buffer
argument_list|)
condition|)
name|need_8bit_cte
operator|=
literal|1
expr_stmt|;
name|msg
operator|=
name|body
expr_stmt|;
name|pp
operator|.
name|fmt
operator|=
name|CMIT_FMT_EMAIL
expr_stmt|;
name|pp
operator|.
name|date_mode
operator|=
name|DATE_RFC2822
expr_stmt|;
name|pp_user_info
argument_list|(
operator|&
name|pp
argument_list|,
name|NULL
argument_list|,
operator|&
name|sb
argument_list|,
name|committer
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|pp_title_line
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|sb
argument_list|,
name|encoding
argument_list|,
name|need_8bit_cte
argument_list|)
expr_stmt|;
name|pp_remainder
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_branch_description
argument_list|(
operator|&
name|sb
argument_list|,
name|branch_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|shortlog_init
argument_list|(
operator|&
name|log
argument_list|)
expr_stmt|;
name|log
operator|.
name|wrap_lines
operator|=
literal|1
expr_stmt|;
name|log
operator|.
name|wrap
operator|=
literal|72
expr_stmt|;
name|log
operator|.
name|in1
operator|=
literal|2
expr_stmt|;
name|log
operator|.
name|in2
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
name|shortlog_add_commit
argument_list|(
operator|&
name|log
argument_list|,
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|shortlog_output
argument_list|(
operator|&
name|log
argument_list|)
expr_stmt|;
comment|/* 	 * We can only do diffstat with a unique reference point 	 */
if|if
condition|(
operator|!
name|origin
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|opts
argument_list|,
operator|&
name|rev
operator|->
name|diffopt
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_SUMMARY
operator||
name|DIFF_FORMAT_DIFFSTAT
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|origin
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|head
operator|->
name|tree
operator|->
name|object
operator|.
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|opts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_signature
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clean_message_id
specifier|static
specifier|const
name|char
modifier|*
name|clean_message_id
parameter_list|(
specifier|const
name|char
modifier|*
name|msg_id
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
specifier|const
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|z
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|msg_id
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|m
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'<'
operator|)
operator|)
condition|)
name|m
operator|++
expr_stmt|;
name|a
operator|=
name|m
expr_stmt|;
name|z
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|m
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
operator|&&
operator|(
name|ch
operator|!=
literal|'>'
operator|)
condition|)
name|z
operator|=
name|m
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|z
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"insane in-reply-to: %s"
argument_list|)
argument_list|,
name|msg_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|z
operator|==
name|m
condition|)
return|return
name|a
return|;
return|return
name|xmemdupz
argument_list|(
name|a
argument_list|,
name|z
operator|-
name|a
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|set_outdir
specifier|static
specifier|const
name|char
modifier|*
name|set_outdir
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|output_directory
parameter_list|)
block|{
if|if
condition|(
name|output_directory
operator|&&
name|is_absolute_path
argument_list|(
name|output_directory
argument_list|)
condition|)
return|return
name|output_directory
return|;
if|if
condition|(
operator|!
name|prefix
operator|||
operator|!
operator|*
name|prefix
condition|)
block|{
if|if
condition|(
name|output_directory
condition|)
return|return
name|output_directory
return|;
comment|/* The user did not explicitly ask for "./" */
name|outdir_offset
operator|=
literal|2
expr_stmt|;
return|return
literal|"./"
return|;
block|}
name|outdir_offset
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_directory
condition|)
return|return
name|prefix
return|;
return|return
name|xstrdup
argument_list|(
name|prefix_filename
argument_list|(
name|prefix
argument_list|,
name|outdir_offset
argument_list|,
name|output_directory
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|builtin_format_patch_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_format_patch_usage
index|[]
init|=
block|{
literal|"git format-patch [options] [<since> |<revision range>]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|keep_subject
specifier|static
name|int
name|keep_subject
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|keep_callback
specifier|static
name|int
name|keep_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|rev_info
operator|*
operator|)
name|opt
operator|->
name|value
operator|)
operator|->
name|total
operator|=
operator|-
literal|1
expr_stmt|;
name|keep_subject
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|subject_prefix
specifier|static
name|int
name|subject_prefix
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|subject_prefix_callback
specifier|static
name|int
name|subject_prefix_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|subject_prefix
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|rev_info
operator|*
operator|)
name|opt
operator|->
name|value
operator|)
operator|->
name|subject_prefix
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|numbered_cmdline_opt
specifier|static
name|int
name|numbered_cmdline_opt
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|numbered_callback
specifier|static
name|int
name|numbered_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|opt
operator|->
name|value
operator|=
name|numbered_cmdline_opt
operator|=
name|unset
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|unset
condition|)
name|auto_number
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|no_numbered_callback
specifier|static
name|int
name|no_numbered_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
return|return
name|numbered_callback
argument_list|(
name|opt
argument_list|,
name|arg
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|output_directory_callback
specifier|static
name|int
name|output_directory_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|dir
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
operator|*
name|dir
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Two output directories?"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dir
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|thread_callback
specifier|static
name|int
name|thread_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|int
modifier|*
name|thread
init|=
operator|(
name|int
operator|*
operator|)
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|unset
condition|)
operator|*
name|thread
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"shallow"
argument_list|)
condition|)
operator|*
name|thread
operator|=
name|THREAD_SHALLOW
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"deep"
argument_list|)
condition|)
operator|*
name|thread
operator|=
name|THREAD_DEEP
expr_stmt|;
else|else
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|attach_callback
specifier|static
name|int
name|attach_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|rev_info
modifier|*
name|rev
init|=
operator|(
expr|struct
name|rev_info
operator|*
operator|)
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|unset
condition|)
name|rev
operator|->
name|mime_boundary
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
condition|)
name|rev
operator|->
name|mime_boundary
operator|=
name|arg
expr_stmt|;
else|else
name|rev
operator|->
name|mime_boundary
operator|=
name|git_version_string
expr_stmt|;
name|rev
operator|->
name|no_inline
operator|=
name|unset
condition|?
literal|0
else|:
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|inline_callback
specifier|static
name|int
name|inline_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|rev_info
modifier|*
name|rev
init|=
operator|(
expr|struct
name|rev_info
operator|*
operator|)
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|unset
condition|)
name|rev
operator|->
name|mime_boundary
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
condition|)
name|rev
operator|->
name|mime_boundary
operator|=
name|arg
expr_stmt|;
else|else
name|rev
operator|->
name|mime_boundary
operator|=
name|git_version_string
expr_stmt|;
name|rev
operator|->
name|no_inline
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|header_callback
specifier|static
name|int
name|header_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
block|{
name|string_list_clear
argument_list|(
operator|&
name|extra_hdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|extra_to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|extra_cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_header
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|to_callback
specifier|static
name|int
name|to_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
name|string_list_clear
argument_list|(
operator|&
name|extra_to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|string_list_append
argument_list|(
operator|&
name|extra_to
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|cc_callback
specifier|static
name|int
name|cc_callback
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
if|if
condition|(
name|unset
condition|)
name|string_list_clear
argument_list|(
operator|&
name|extra_cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|string_list_append
argument_list|(
operator|&
name|extra_cc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_branch_name
specifier|static
name|char
modifier|*
name|find_branch_name
parameter_list|(
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|positive
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
name|branch_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rev
operator|->
name|cmdline
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rev
operator|->
name|cmdline
operator|.
name|rev
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
continue|continue;
if|if
condition|(
name|positive
operator|<
literal|0
condition|)
name|positive
operator|=
name|i
expr_stmt|;
else|else
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|positive
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|rev
operator|->
name|cmdline
operator|.
name|rev
index|[
name|positive
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|branch
operator|=
name|resolve_ref_unsafe
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|branch_sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
operator|||
name|prefixcmp
argument_list|(
name|branch
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|||
name|hashcmp
argument_list|(
name|rev
operator|->
name|cmdline
operator|.
name|rev
index|[
name|positive
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|,
name|branch_sha1
argument_list|)
condition|)
name|branch
operator|=
name|NULL
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
return|return
name|xstrdup
argument_list|(
name|rev
operator|->
name|cmdline
operator|.
name|rev
index|[
name|positive
index|]
operator|.
name|name
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|cmd_format_patch
name|int
name|cmd_format_patch
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|setup_revision_opt
name|s_r_opt
decl_stmt|;
name|int
name|nr
init|=
literal|0
decl_stmt|,
name|total
decl_stmt|,
name|i
decl_stmt|;
name|int
name|use_stdout
init|=
literal|0
decl_stmt|;
name|int
name|start_number
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numbered_files
init|=
literal|0
decl_stmt|;
comment|/* _just_ numbers */
name|int
name|ignore_if_in_upstream
init|=
literal|0
decl_stmt|;
name|int
name|cover_letter
init|=
literal|0
decl_stmt|;
name|int
name|boundary_count
init|=
literal|0
decl_stmt|;
name|int
name|no_binary_diff
init|=
literal|0
decl_stmt|;
name|struct
name|commit
modifier|*
name|origin
init|=
name|NULL
decl_stmt|,
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|in_reply_to
init|=
name|NULL
decl_stmt|;
name|struct
name|patch_ids
name|ids
decl_stmt|;
name|char
modifier|*
name|add_signoff
init|=
name|NULL
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|use_patch_format
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|branch_name
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|option
name|builtin_format_patch_options
index|[]
init|=
block|{
block|{
name|OPTION_CALLBACK
block|,
literal|'n'
block|,
literal|"numbered"
block|,
operator|&
name|numbered
block|,
name|NULL
block|,
literal|"use [PATCH n/m] even with a single patch"
block|,
name|PARSE_OPT_NOARG
block|,
name|numbered_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'N'
block|,
literal|"no-numbered"
block|,
operator|&
name|numbered
block|,
name|NULL
block|,
literal|"use [PATCH] even with multiple patches"
block|,
name|PARSE_OPT_NOARG
block|,
name|no_numbered_callback
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'s'
argument_list|,
literal|"signoff"
argument_list|,
operator|&
name|do_signoff
argument_list|,
literal|"add Signed-off-by:"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"stdout"
argument_list|,
operator|&
name|use_stdout
argument_list|,
literal|"print patches to standard out"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"cover-letter"
argument_list|,
operator|&
name|cover_letter
argument_list|,
literal|"generate a cover letter"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"numbered-files"
argument_list|,
operator|&
name|numbered_files
argument_list|,
literal|"use simple number sequence for output file names"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"suffix"
argument_list|,
operator|&
name|fmt_patch_suffix
argument_list|,
literal|"sfx"
argument_list|,
literal|"use<sfx> instead of '.patch'"
argument_list|)
block|,
name|OPT_INTEGER
argument_list|(
literal|0
argument_list|,
literal|"start-number"
argument_list|,
operator|&
name|start_number
argument_list|,
literal|"start numbering patches at<n> instead of 1"
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"subject-prefix"
block|,
operator|&
name|rev
block|,
literal|"prefix"
block|,
literal|"Use [<prefix>] instead of [PATCH]"
block|,
name|PARSE_OPT_NONEG
block|,
name|subject_prefix_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'o'
block|,
literal|"output-directory"
block|,
operator|&
name|output_directory
block|,
literal|"dir"
block|,
literal|"store resulting files in<dir>"
block|,
name|PARSE_OPT_NONEG
block|,
name|output_directory_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|'k'
block|,
literal|"keep-subject"
block|,
operator|&
name|rev
block|,
name|NULL
block|,
literal|"don't strip/add [PATCH]"
block|,
name|PARSE_OPT_NOARG
operator||
name|PARSE_OPT_NONEG
block|,
name|keep_callback
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"no-binary"
argument_list|,
operator|&
name|no_binary_diff
argument_list|,
literal|"don't output binary diffs"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"ignore-if-in-upstream"
argument_list|,
operator|&
name|ignore_if_in_upstream
argument_list|,
literal|"don't include a patch matching a commit upstream"
argument_list|)
block|,
block|{
name|OPTION_BOOLEAN
block|,
literal|'p'
block|,
literal|"no-stat"
block|,
operator|&
name|use_patch_format
block|,
name|NULL
block|,
literal|"show patch format instead of default (patch + stat)"
block|,
name|PARSE_OPT_NONEG
operator||
name|PARSE_OPT_NOARG
block|}
block|,
name|OPT_GROUP
argument_list|(
literal|"Messaging"
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"add-header"
block|,
name|NULL
block|,
literal|"header"
block|,
literal|"add email header"
block|,
literal|0
block|,
name|header_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"to"
block|,
name|NULL
block|,
literal|"email"
block|,
literal|"add To: header"
block|,
literal|0
block|,
name|to_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"cc"
block|,
name|NULL
block|,
literal|"email"
block|,
literal|"add Cc: header"
block|,
literal|0
block|,
name|cc_callback
block|}
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"in-reply-to"
argument_list|,
operator|&
name|in_reply_to
argument_list|,
literal|"message-id"
argument_list|,
literal|"make first mail a reply to<message-id>"
argument_list|)
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"attach"
block|,
operator|&
name|rev
block|,
literal|"boundary"
block|,
literal|"attach the patch"
block|,
name|PARSE_OPT_OPTARG
block|,
name|attach_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"inline"
block|,
operator|&
name|rev
block|,
literal|"boundary"
block|,
literal|"inline the patch"
block|,
name|PARSE_OPT_OPTARG
operator||
name|PARSE_OPT_NONEG
block|,
name|inline_callback
block|}
block|,
block|{
name|OPTION_CALLBACK
block|,
literal|0
block|,
literal|"thread"
block|,
operator|&
name|thread
block|,
literal|"style"
block|,
literal|"enable message threading, styles: shallow, deep"
block|,
name|PARSE_OPT_OPTARG
block|,
name|thread_callback
block|}
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"signature"
argument_list|,
operator|&
name|signature
argument_list|,
literal|"signature"
argument_list|,
literal|"add a signature"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"quiet"
argument_list|,
operator|&
name|quiet
argument_list|,
literal|"don't print the patch filenames"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|extra_hdr
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|extra_to
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|extra_cc
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
name|git_config
argument_list|(
name|git_format_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|rev
operator|.
name|commit_format
operator|=
name|CMIT_FMT_EMAIL
expr_stmt|;
name|rev
operator|.
name|verbose_header
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|max_parents
operator|=
literal|1
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|rev
operator|.
name|subject_prefix
operator|=
name|fmt_patch_subject_prefix
expr_stmt|;
name|memset
argument_list|(
operator|&
name|s_r_opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s_r_opt
argument_list|)
argument_list|)
expr_stmt|;
name|s_r_opt
operator|.
name|def
operator|=
literal|"HEAD"
expr_stmt|;
name|s_r_opt
operator|.
name|revarg_opt
operator|=
name|REVARG_COMMITTISH
expr_stmt|;
if|if
condition|(
name|default_attach
condition|)
block|{
name|rev
operator|.
name|mime_boundary
operator|=
name|default_attach
expr_stmt|;
name|rev
operator|.
name|no_inline
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Parse the arguments before setup_revisions(), or something 	 * like "git format-patch -o a123 HEAD^.." may fail; a123 is 	 * possibly a valid SHA1. 	 */
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|builtin_format_patch_options
argument_list|,
name|builtin_format_patch_usage
argument_list|,
name|PARSE_OPT_KEEP_ARGV0
operator||
name|PARSE_OPT_KEEP_UNKNOWN
operator||
name|PARSE_OPT_KEEP_DASHDASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_signoff
condition|)
block|{
specifier|const
name|char
modifier|*
name|committer
decl_stmt|;
specifier|const
name|char
modifier|*
name|endpos
decl_stmt|;
name|committer
operator|=
name|git_committer_info
argument_list|(
name|IDENT_STRICT
argument_list|)
expr_stmt|;
name|endpos
operator|=
name|strchr
argument_list|(
name|committer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endpos
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"bogus committer info %s"
argument_list|)
argument_list|,
name|committer
argument_list|)
expr_stmt|;
name|add_signoff
operator|=
name|xmemdupz
argument_list|(
name|committer
argument_list|,
name|endpos
operator|-
name|committer
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_hdr
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|extra_hdr
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra_to
operator|.
name|nr
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"To: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_to
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|extra_to
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|extra_to
operator|.
name|nr
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extra_cc
operator|.
name|nr
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"Cc: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extra_cc
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|extra_cc
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|extra_cc
operator|.
name|nr
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|rev
operator|.
name|extra_headers
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_number
operator|<
literal|0
condition|)
name|start_number
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If numbered is set solely due to format.numbered in config, 	 * and it would conflict with --keep-subject (-k) from the 	 * command line, reset "numbered". 	 */
if|if
condition|(
name|numbered
operator|&&
name|keep_subject
operator|&&
operator|!
name|numbered_cmdline_opt
condition|)
name|numbered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numbered
operator|&&
name|keep_subject
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"-n and -k are mutually exclusive."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_subject
operator|&&
name|subject_prefix
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--subject-prefix and -k are mutually exclusive."
argument_list|)
argument_list|)
expr_stmt|;
name|rev
operator|.
name|preserve_subject
operator|=
name|keep_subject
expr_stmt|;
name|argc
operator|=
name|setup_revisions
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|s_r_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"unrecognized argument: %s"
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|&
name|DIFF_FORMAT_NAME
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--name-only does not make sense"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|&
name|DIFF_FORMAT_NAME_STATUS
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--name-status does not make sense"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|&
name|DIFF_FORMAT_CHECKDIFF
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"--check does not make sense"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_patch_format
operator|&&
operator|(
operator|!
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|||
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|==
name|DIFF_FORMAT_PATCH
operator|)
condition|)
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_DIFFSTAT
operator||
name|DIFF_FORMAT_SUMMARY
expr_stmt|;
comment|/* Always generate a patch */
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator||=
name|DIFF_FORMAT_PATCH
expr_stmt|;
if|if
condition|(
operator|!
name|DIFF_OPT_TST
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|TEXT
argument_list|)
operator|&&
operator|!
name|no_binary_diff
condition|)
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|.
name|show_notes
condition|)
name|init_display_notes
argument_list|(
operator|&
name|rev
operator|.
name|notes_opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_stdout
condition|)
name|output_directory
operator|=
name|set_outdir
argument_list|(
name|prefix
argument_list|,
name|output_directory
argument_list|)
expr_stmt|;
else|else
name|setup_pager
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_directory
condition|)
block|{
if|if
condition|(
name|use_stdout
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"standard output, or directory, which one?"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|output_directory
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|die_errno
argument_list|(
name|_
argument_list|(
literal|"Could not create directory '%s'"
argument_list|)
argument_list|,
name|output_directory
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rev
operator|.
name|pending
operator|.
name|nr
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|rev
operator|.
name|max_count
operator|<
literal|0
operator|&&
operator|!
name|rev
operator|.
name|show_root_diff
condition|)
block|{
comment|/* 			 * This is traditional behaviour of "git format-patch 			 * origin" that prepares what the origin side still 			 * does not have. 			 */
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ref
decl_stmt|;
name|rev
operator|.
name|pending
operator|.
name|objects
index|[
literal|0
index|]
operator|.
name|item
operator|->
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
name|add_head_to_pending
argument_list|(
operator|&
name|rev
argument_list|)
expr_stmt|;
name|ref
operator|=
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|ref
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|branch_name
operator|=
name|xstrdup
argument_list|(
name|ref
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|branch_name
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* no branch */
block|}
comment|/* 		 * Otherwise, it is "format-patch -22 HEAD", and/or 		 * "format-patch --root HEAD".  The user wants 		 * get_revision() to do the usual traversal. 		 */
block|}
comment|/* 	 * We cannot move this anywhere earlier because we do want to 	 * know if --root was given explicitly from the command line. 	 */
name|rev
operator|.
name|show_root_diff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cover_letter
condition|)
block|{
comment|/* 		 * NEEDSWORK:randomly pick one positive commit to show 		 * diffstat; this is often the tip and the command 		 * happens to do the right thing in most cases, but a 		 * complex command like "--cover-letter a b c ^bottom" 		 * picks "c" and shows diffstat between bottom..c 		 * which may not match what the series represents at 		 * all and totally broken. 		 */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rev
operator|.
name|pending
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|object
modifier|*
name|o
init|=
name|rev
operator|.
name|pending
operator|.
name|objects
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
name|head
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
expr_stmt|;
block|}
comment|/* There is nothing to show; it is not an error, though. */
if|if
condition|(
operator|!
name|head
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|branch_name
condition|)
name|branch_name
operator|=
name|find_branch_name
argument_list|(
operator|&
name|rev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ignore_if_in_upstream
condition|)
block|{
comment|/* Don't say anything if head and upstream are the same. */
if|if
condition|(
name|rev
operator|.
name|pending
operator|.
name|nr
operator|==
literal|2
condition|)
block|{
name|struct
name|object_array_entry
modifier|*
name|o
init|=
name|rev
operator|.
name|pending
operator|.
name|objects
decl_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|o
index|[
literal|0
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|,
name|o
index|[
literal|1
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|get_patch_ids
argument_list|(
operator|&
name|rev
argument_list|,
operator|&
name|ids
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_stdout
condition|)
name|realstdout
operator|=
name|xfdopen
argument_list|(
name|xdup
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|rev
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
name|rev
operator|.
name|boundary
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
operator|&
name|rev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|BOUNDARY
condition|)
block|{
name|boundary_count
operator|++
expr_stmt|;
name|origin
operator|=
operator|(
name|boundary_count
operator|==
literal|1
operator|)
condition|?
name|commit
else|:
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ignore_if_in_upstream
operator|&&
name|has_commit_patch_id
argument_list|(
name|commit
argument_list|,
operator|&
name|ids
argument_list|)
condition|)
continue|continue;
name|nr
operator|++
expr_stmt|;
name|list
operator|=
name|xrealloc
argument_list|(
name|list
argument_list|,
name|nr
operator|*
sizeof|sizeof
argument_list|(
name|list
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|list
index|[
name|nr
operator|-
literal|1
index|]
operator|=
name|commit
expr_stmt|;
block|}
name|total
operator|=
name|nr
expr_stmt|;
if|if
condition|(
operator|!
name|keep_subject
operator|&&
name|auto_number
operator|&&
name|total
operator|>
literal|1
condition|)
name|numbered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|numbered
condition|)
name|rev
operator|.
name|total
operator|=
name|total
operator|+
name|start_number
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|in_reply_to
operator|||
name|thread
operator|||
name|cover_letter
condition|)
name|rev
operator|.
name|ref_message_ids
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_reply_to
condition|)
block|{
specifier|const
name|char
modifier|*
name|msgid
init|=
name|clean_message_id
argument_list|(
name|in_reply_to
argument_list|)
decl_stmt|;
name|string_list_append
argument_list|(
name|rev
operator|.
name|ref_message_ids
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
block|}
name|rev
operator|.
name|numbered_files
operator|=
name|numbered_files
expr_stmt|;
name|rev
operator|.
name|patch_suffix
operator|=
name|fmt_patch_suffix
expr_stmt|;
if|if
condition|(
name|cover_letter
condition|)
block|{
if|if
condition|(
name|thread
condition|)
name|gen_message_id
argument_list|(
operator|&
name|rev
argument_list|,
literal|"cover"
argument_list|)
expr_stmt|;
name|make_cover_letter
argument_list|(
operator|&
name|rev
argument_list|,
name|use_stdout
argument_list|,
name|numbered
argument_list|,
name|numbered_files
argument_list|,
name|origin
argument_list|,
name|nr
argument_list|,
name|list
argument_list|,
name|head
argument_list|,
name|branch_name
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
name|total
operator|++
expr_stmt|;
name|start_number
operator|--
expr_stmt|;
block|}
name|rev
operator|.
name|add_signoff
operator|=
name|add_signoff
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|--
name|nr
condition|)
block|{
name|int
name|shown
decl_stmt|;
name|commit
operator|=
name|list
index|[
name|nr
index|]
expr_stmt|;
name|rev
operator|.
name|nr
operator|=
name|total
operator|-
name|nr
operator|+
operator|(
name|start_number
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Make the second and subsequent mails replies to the first */
if|if
condition|(
name|thread
condition|)
block|{
comment|/* Have we already had a message ID? */
if|if
condition|(
name|rev
operator|.
name|message_id
condition|)
block|{
comment|/* 				 * For deep threading: make every mail 				 * a reply to the previous one, no 				 * matter what other options are set. 				 * 				 * For shallow threading: 				 * 				 * Without --cover-letter and 				 * --in-reply-to, make every mail a 				 * reply to the one before. 				 * 				 * With --in-reply-to but no 				 * --cover-letter, make every mail a 				 * reply to the<reply-to>. 				 * 				 * With --cover-letter, make every 				 * mail but the cover letter a reply 				 * to the cover letter.  The cover 				 * letter is a reply to the 				 * --in-reply-to, if specified. 				 */
if|if
condition|(
name|thread
operator|==
name|THREAD_SHALLOW
operator|&&
name|rev
operator|.
name|ref_message_ids
operator|->
name|nr
operator|>
literal|0
operator|&&
operator|(
operator|!
name|cover_letter
operator|||
name|rev
operator|.
name|nr
operator|>
literal|1
operator|)
condition|)
name|free
argument_list|(
name|rev
operator|.
name|message_id
argument_list|)
expr_stmt|;
else|else
name|string_list_append
argument_list|(
name|rev
operator|.
name|ref_message_ids
argument_list|,
name|rev
operator|.
name|message_id
argument_list|)
expr_stmt|;
block|}
name|gen_message_id
argument_list|(
operator|&
name|rev
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_stdout
operator|&&
name|reopen_stdout
argument_list|(
name|numbered_files
condition|?
name|NULL
else|:
name|commit
argument_list|,
name|NULL
argument_list|,
operator|&
name|rev
argument_list|,
name|quiet
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Failed to create output files"
argument_list|)
argument_list|)
expr_stmt|;
name|shown
operator|=
name|log_tree_commit
argument_list|(
operator|&
name|rev
argument_list|,
name|commit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|commit
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
comment|/* We put one extra blank line between formatted 		 * patches and this flag is used by log-tree code 		 * to see if it needs to emit a LF before showing 		 * the log; when using one file per patch, we do 		 * not want the extra blank line. 		 */
if|if
condition|(
operator|!
name|use_stdout
condition|)
name|rev
operator|.
name|shown_one
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shown
condition|)
block|{
if|if
condition|(
name|rev
operator|.
name|mime_boundary
condition|)
name|printf
argument_list|(
literal|"\n--%s%s--\n\n\n"
argument_list|,
name|mime_boundary_leader
argument_list|,
name|rev
operator|.
name|mime_boundary
argument_list|)
expr_stmt|;
else|else
name|print_signature
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_stdout
condition|)
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch_name
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|extra_to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|extra_cc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|extra_hdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_if_in_upstream
condition|)
name|free_patch_ids
argument_list|(
operator|&
name|ids
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|add_pending_commit
specifier|static
name|int
name|add_pending_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|arg
argument_list|,
name|sha1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
name|add_pending_object
argument_list|(
name|revs
argument_list|,
operator|&
name|commit
operator|->
name|object
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|cherry_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cherry_usage
index|[]
init|=
block|{
literal|"git cherry [-v] [<upstream> [<head> [<limit>]]]"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|print_commit
specifier|static
name|void
name|print_commit
parameter_list|(
name|char
name|sign
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|abbrev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%c %s\n"
argument_list|,
name|sign
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|pp_commit_easy
argument_list|(
name|CMIT_FMT_ONELINE
argument_list|,
name|commit
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c %s %s\n"
argument_list|,
name|sign
argument_list|,
name|find_unique_abbrev
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|abbrev
argument_list|)
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|cmd_cherry
name|int
name|cmd_cherry
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
name|struct
name|patch_ids
name|ids
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|branch
modifier|*
name|current_branch
decl_stmt|;
specifier|const
name|char
modifier|*
name|upstream
decl_stmt|;
specifier|const
name|char
modifier|*
name|head
init|=
literal|"HEAD"
decl_stmt|;
specifier|const
name|char
modifier|*
name|limit
init|=
name|NULL
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|,
name|abbrev
init|=
literal|0
decl_stmt|;
name|struct
name|option
name|options
index|[]
init|=
block|{
name|OPT__ABBREV
argument_list|(
operator|&
name|abbrev
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|verbose
argument_list|,
literal|"be verbose"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
name|options
argument_list|,
name|cherry_usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|argc
condition|)
block|{
case|case
literal|3
case|:
name|limit
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|head
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|upstream
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|current_branch
operator|=
name|branch_get
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_branch
operator|||
operator|!
name|current_branch
operator|->
name|merge
operator|||
operator|!
name|current_branch
operator|->
name|merge
index|[
literal|0
index|]
operator|||
operator|!
name|current_branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Could not find a tracked"
literal|" remote branch, please"
literal|" specify<upstream> manually.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage_with_options
argument_list|(
name|cherry_usage
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|upstream
operator|=
name|current_branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
expr_stmt|;
block|}
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_pending_commit
argument_list|(
name|head
argument_list|,
operator|&
name|revs
argument_list|,
literal|0
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unknown commit %s"
argument_list|)
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_pending_commit
argument_list|(
name|upstream
argument_list|,
operator|&
name|revs
argument_list|,
name|UNINTERESTING
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unknown commit %s"
argument_list|)
argument_list|,
name|upstream
argument_list|)
expr_stmt|;
comment|/* Don't say anything if head and upstream are the same. */
if|if
condition|(
name|revs
operator|.
name|pending
operator|.
name|nr
operator|==
literal|2
condition|)
block|{
name|struct
name|object_array_entry
modifier|*
name|o
init|=
name|revs
operator|.
name|pending
operator|.
name|objects
decl_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|o
index|[
literal|0
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|,
name|o
index|[
literal|1
index|]
operator|.
name|item
operator|->
name|sha1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|get_patch_ids
argument_list|(
operator|&
name|revs
argument_list|,
operator|&
name|ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|&&
name|add_pending_commit
argument_list|(
name|limit
argument_list|,
operator|&
name|revs
argument_list|,
name|UNINTERESTING
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"Unknown commit %s"
argument_list|)
argument_list|,
name|limit
argument_list|)
expr_stmt|;
comment|/* reverse the list of commits */
if|if
condition|(
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"revision walk setup failed"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|get_revision
argument_list|(
operator|&
name|revs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* ignore merges */
if|if
condition|(
name|commit
operator|->
name|parents
operator|&&
name|commit
operator|->
name|parents
operator|->
name|next
condition|)
continue|continue;
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list
condition|)
block|{
name|char
name|sign
init|=
literal|'+'
decl_stmt|;
name|commit
operator|=
name|list
operator|->
name|item
expr_stmt|;
if|if
condition|(
name|has_commit_patch_id
argument_list|(
name|commit
argument_list|,
operator|&
name|ids
argument_list|)
condition|)
name|sign
operator|=
literal|'-'
expr_stmt|;
name|print_commit
argument_list|(
name|sign
argument_list|,
name|commit
argument_list|,
name|verbose
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|free_patch_ids
argument_list|(
operator|&
name|ids
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
