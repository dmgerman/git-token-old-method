begin_unit
begin_comment
comment|/*  * Copyright (C) 2005 Junio C Hamano  * The delta-parsing part is almost straight copy of patch-delta.c  * which is (C) 2005 Nicolas Pitre<nico@cam.org>.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"delta.h"
end_include
begin_include
include|#
directive|include
file|"count-delta.h"
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_struct
DECL|struct|span
struct|struct
name|span
block|{
DECL|member|next
name|struct
name|span
modifier|*
name|next
decl_stmt|;
DECL|member|ofs
name|unsigned
name|long
name|ofs
decl_stmt|;
DECL|member|end
name|unsigned
name|long
name|end
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|touch_range
specifier|static
name|void
name|touch_range
parameter_list|(
name|struct
name|span
modifier|*
modifier|*
name|span
parameter_list|,
name|unsigned
name|long
name|ofs
parameter_list|,
name|unsigned
name|long
name|end
parameter_list|)
block|{
name|struct
name|span
modifier|*
name|e
init|=
operator|*
name|span
decl_stmt|;
name|struct
name|span
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|e
operator|&&
name|e
operator|->
name|ofs
operator|<=
name|ofs
condition|)
block|{
name|again
label|:
if|if
condition|(
name|ofs
operator|<
name|e
operator|->
name|end
condition|)
block|{
while|while
condition|(
name|e
operator|->
name|end
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|next
operator|&&
name|e
operator|->
name|next
operator|->
name|ofs
operator|<=
name|end
condition|)
block|{
name|e
operator|->
name|end
operator|=
name|e
operator|->
name|next
operator|->
name|ofs
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|end
operator|=
name|end
expr_stmt|;
return|return;
block|}
block|}
return|return;
block|}
name|p
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|&&
name|e
operator|->
name|ofs
operator|<=
name|end
condition|)
block|{
name|e
operator|->
name|ofs
operator|=
name|ofs
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
name|e
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|ofs
operator|=
name|ofs
expr_stmt|;
name|e
operator|->
name|end
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|e
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|next
operator|=
operator|*
name|span
expr_stmt|;
operator|*
name|span
operator|=
name|e
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|count_range
specifier|static
name|unsigned
name|long
name|count_range
parameter_list|(
name|struct
name|span
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|span
modifier|*
name|t
decl_stmt|;
name|unsigned
name|long
name|sz
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|t
operator|=
name|s
expr_stmt|;
name|sz
operator|+=
name|s
operator|->
name|end
operator|-
name|s
operator|->
name|ofs
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|sz
return|;
block|}
end_function
begin_comment
comment|/*  * NOTE.  We do not _interpret_ delta fully.  As an approximation, we  * just count the number of bytes that are copied from the source, and  * the number of literal data bytes that are inserted.  *  * Number of bytes that are _not_ copied from the source is deletion,  * and number of inserted literal bytes are addition, so sum of them  * is the extent of damage.  */
end_comment
begin_function
DECL|function|count_delta
name|int
name|count_delta
parameter_list|(
name|void
modifier|*
name|delta_buf
parameter_list|,
name|unsigned
name|long
name|delta_size
parameter_list|,
name|unsigned
name|long
modifier|*
name|src_copied
parameter_list|,
name|unsigned
name|long
modifier|*
name|literal_added
parameter_list|)
block|{
name|unsigned
name|long
name|added_literal
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|unsigned
name|char
name|cmd
decl_stmt|;
name|unsigned
name|long
name|src_size
decl_stmt|,
name|dst_size
decl_stmt|,
name|out
decl_stmt|;
name|struct
name|span
modifier|*
name|span
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|delta_size
operator|<
name|DELTA_SIZE_MIN
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|=
name|delta_buf
expr_stmt|;
name|top
operator|=
name|delta_buf
operator|+
name|delta_size
expr_stmt|;
name|src_size
operator|=
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|dst_size
operator|=
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|added_literal
operator|=
name|out
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|top
condition|)
block|{
name|cmd
operator|=
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x80
condition|)
block|{
name|unsigned
name|long
name|cp_off
init|=
literal|0
decl_stmt|,
name|cp_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x01
condition|)
name|cp_off
operator|=
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x02
condition|)
name|cp_off
operator||=
operator|(
operator|*
name|data
operator|++
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x04
condition|)
name|cp_off
operator||=
operator|(
operator|*
name|data
operator|++
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x08
condition|)
name|cp_off
operator||=
operator|(
operator|*
name|data
operator|++
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x10
condition|)
name|cp_size
operator|=
operator|*
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x20
condition|)
name|cp_size
operator||=
operator|(
operator|*
name|data
operator|++
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x40
condition|)
name|cp_size
operator||=
operator|(
operator|*
name|data
operator|++
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|cp_size
operator|==
literal|0
condition|)
name|cp_size
operator|=
literal|0x10000
expr_stmt|;
name|touch_range
argument_list|(
operator|&
name|span
argument_list|,
name|cp_off
argument_list|,
name|cp_off
operator|+
name|cp_size
argument_list|)
expr_stmt|;
name|out
operator|+=
name|cp_size
expr_stmt|;
block|}
else|else
block|{
comment|/* write literal into dst */
name|added_literal
operator|+=
name|cmd
expr_stmt|;
name|out
operator|+=
name|cmd
expr_stmt|;
name|data
operator|+=
name|cmd
expr_stmt|;
block|}
block|}
operator|*
name|src_copied
operator|=
name|count_range
argument_list|(
name|span
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|data
operator|!=
name|top
operator|||
name|out
operator|!=
name|dst_size
condition|)
return|return
operator|-
literal|1
return|;
comment|/* delete size is what was _not_ copied from source. 	 * edit size is that and literal additions. 	 */
operator|*
name|literal_added
operator|=
name|added_literal
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
