begin_unit
begin_comment
comment|/*  * Copyright (c) 2005, Jon Seymour  *  * For more information about epoch theory on which this module is based,  * refer to http://blackcubes.dyndns.org/epoch/. That web page defines  * terms such as "epoch" and "minimal, non-linear epoch" and provides rationales  * for some of the algorithms used here.  *  */
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_comment
comment|/* Provides arbitrary precision integers required to accurately represent  * fractional mass: */
end_comment
begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"epoch.h"
end_include
begin_struct
DECL|struct|fraction
struct|struct
name|fraction
block|{
DECL|member|numerator
name|BIGNUM
name|numerator
decl_stmt|;
DECL|member|denominator
name|BIGNUM
name|denominator
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|HAS_EXACTLY_ONE_PARENT
define|#
directive|define
name|HAS_EXACTLY_ONE_PARENT
parameter_list|(
name|n
parameter_list|)
value|((n)->parents&& !(n)->parents->next)
end_define
begin_decl_stmt
DECL|variable|context
specifier|static
name|BN_CTX
modifier|*
name|context
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|one
specifier|static
name|struct
name|fraction
modifier|*
name|one
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|zero
specifier|static
name|struct
name|fraction
modifier|*
name|zero
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_BN_CTX
specifier|static
name|BN_CTX
modifier|*
name|get_BN_CTX
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|context
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
end_function
begin_function
DECL|function|new_zero
specifier|static
name|struct
name|fraction
modifier|*
name|new_zero
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|fraction
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|)
expr_stmt|;
name|BN_zero
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_one
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|clear_fraction
specifier|static
name|void
name|clear_fraction
parameter_list|(
name|struct
name|fraction
modifier|*
name|fraction
parameter_list|)
block|{
name|BN_clear
argument_list|(
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|fraction
operator|->
name|denominator
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|divide
specifier|static
name|struct
name|fraction
modifier|*
name|divide
parameter_list|(
name|struct
name|fraction
modifier|*
name|result
parameter_list|,
name|struct
name|fraction
modifier|*
name|fraction
parameter_list|,
name|int
name|divisor
parameter_list|)
block|{
name|BIGNUM
name|bn_divisor
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|bn_divisor
argument_list|)
expr_stmt|;
name|BN_set_word
argument_list|(
operator|&
name|bn_divisor
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|,
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|fraction
operator|->
name|denominator
argument_list|,
operator|&
name|bn_divisor
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|bn_divisor
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|init_fraction
specifier|static
name|struct
name|fraction
modifier|*
name|init_fraction
parameter_list|(
name|struct
name|fraction
modifier|*
name|fraction
parameter_list|)
block|{
name|BN_init
argument_list|(
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|fraction
operator|->
name|denominator
argument_list|)
expr_stmt|;
name|BN_zero
argument_list|(
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_one
argument_list|(
operator|&
name|fraction
operator|->
name|denominator
argument_list|)
expr_stmt|;
return|return
name|fraction
return|;
block|}
end_function
begin_function
DECL|function|get_one
specifier|static
name|struct
name|fraction
modifier|*
name|get_one
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|one
condition|)
block|{
name|one
operator|=
name|new_zero
argument_list|()
expr_stmt|;
name|BN_one
argument_list|(
operator|&
name|one
operator|->
name|numerator
argument_list|)
expr_stmt|;
block|}
return|return
name|one
return|;
block|}
end_function
begin_function
DECL|function|get_zero
specifier|static
name|struct
name|fraction
modifier|*
name|get_zero
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|zero
condition|)
block|{
name|zero
operator|=
name|new_zero
argument_list|()
expr_stmt|;
block|}
return|return
name|zero
return|;
block|}
end_function
begin_function
DECL|function|copy
specifier|static
name|struct
name|fraction
modifier|*
name|copy
parameter_list|(
name|struct
name|fraction
modifier|*
name|to
parameter_list|,
name|struct
name|fraction
modifier|*
name|from
parameter_list|)
block|{
name|BN_copy
argument_list|(
operator|&
name|to
operator|->
name|numerator
argument_list|,
operator|&
name|from
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
operator|&
name|to
operator|->
name|denominator
argument_list|,
operator|&
name|from
operator|->
name|denominator
argument_list|)
expr_stmt|;
return|return
name|to
return|;
block|}
end_function
begin_function
DECL|function|add
specifier|static
name|struct
name|fraction
modifier|*
name|add
parameter_list|(
name|struct
name|fraction
modifier|*
name|result
parameter_list|,
name|struct
name|fraction
modifier|*
name|left
parameter_list|,
name|struct
name|fraction
modifier|*
name|right
parameter_list|)
block|{
name|BIGNUM
name|a
decl_stmt|,
name|b
decl_stmt|,
name|gcd
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|gcd
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|left
operator|->
name|numerator
argument_list|,
operator|&
name|right
operator|->
name|denominator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|left
operator|->
name|denominator
argument_list|,
operator|&
name|right
operator|->
name|numerator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|left
operator|->
name|denominator
argument_list|,
operator|&
name|right
operator|->
name|denominator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
operator|&
name|gcd
argument_list|,
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|result
operator|->
name|numerator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|,
name|NULL
argument_list|,
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|gcd
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|,
name|NULL
argument_list|,
operator|&
name|result
operator|->
name|numerator
argument_list|,
operator|&
name|gcd
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|gcd
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|compare
specifier|static
name|int
name|compare
parameter_list|(
name|struct
name|fraction
modifier|*
name|left
parameter_list|,
name|struct
name|fraction
modifier|*
name|right
parameter_list|)
block|{
name|BIGNUM
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|result
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|left
operator|->
name|numerator
argument_list|,
operator|&
name|right
operator|->
name|denominator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|left
operator|->
name|denominator
argument_list|,
operator|&
name|right
operator|->
name|numerator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|BN_cmp
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_struct
DECL|struct|mass_counter
struct|struct
name|mass_counter
block|{
DECL|member|seen
name|struct
name|fraction
name|seen
decl_stmt|;
DECL|member|pending
name|struct
name|fraction
name|pending
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|new_mass_counter
specifier|static
name|struct
name|mass_counter
modifier|*
name|new_mass_counter
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|fraction
modifier|*
name|pending
parameter_list|)
block|{
name|struct
name|mass_counter
modifier|*
name|mass_counter
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mass_counter
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|mass_counter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mass_counter
argument_list|)
argument_list|)
expr_stmt|;
name|init_fraction
argument_list|(
operator|&
name|mass_counter
operator|->
name|seen
argument_list|)
expr_stmt|;
name|init_fraction
argument_list|(
operator|&
name|mass_counter
operator|->
name|pending
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|mass_counter
operator|->
name|pending
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|mass_counter
operator|->
name|seen
argument_list|,
name|get_zero
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|util
condition|)
block|{
name|die
argument_list|(
literal|"multiple attempts to initialize mass counter for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|commit
operator|->
name|object
operator|.
name|util
operator|=
name|mass_counter
expr_stmt|;
return|return
name|mass_counter
return|;
block|}
end_function
begin_function
DECL|function|free_mass_counter
specifier|static
name|void
name|free_mass_counter
parameter_list|(
name|struct
name|mass_counter
modifier|*
name|counter
parameter_list|)
block|{
name|clear_fraction
argument_list|(
operator|&
name|counter
operator|->
name|seen
argument_list|)
expr_stmt|;
name|clear_fraction
argument_list|(
operator|&
name|counter
operator|->
name|pending
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|counter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Finds the base commit of a list of commits.  *  * One property of the commit being searched for is that every commit reachable  * from the base commit is reachable from the commits in the starting list only  * via paths that include the base commit.  *  * This algorithm uses a conservation of mass approach to find the base commit.  *  * We start by injecting one unit of mass into the graph at each  * of the commits in the starting list. Injecting mass into a commit  * is achieved by adding to its pending mass counter and, if it is not already  * enqueued, enqueuing the commit in a list of pending commits, in latest  * commit date first order.  *  * The algorithm then preceeds to visit each commit in the pending queue.  * Upon each visit, the pending mass is added to the mass already seen for that  * commit and then divided into N equal portions, where N is the number of  * parents of the commit being visited. The divided portions are then injected  * into each of the parents.  *  * The algorithm continues until we discover a commit which has seen all the  * mass originally injected or until we run out of things to do.  *  * If we find a commit that has seen all the original mass, we have found  * the common base of all the commits in the starting list.  *  * The algorithm does _not_ depend on accurate timestamps for correct operation.  * However, reasonably sane (e.g. non-random) timestamps are required in order  * to prevent an exponential performance characteristic. The occasional  * timestamp inaccuracy will not dramatically affect performance but may  * result in more nodes being processed than strictly necessary.  *  * This procedure sets *boundary to the address of the base commit. It returns  * non-zero if, and only if, there was a problem parsing one of the  * commits discovered during the traversal.  */
end_comment
begin_function
DECL|function|find_base_for_list
specifier|static
name|int
name|find_base_for_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|boundary
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|cleaner
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|pending
init|=
name|NULL
decl_stmt|;
name|struct
name|fraction
name|injected
decl_stmt|;
name|init_fraction
argument_list|(
operator|&
name|injected
argument_list|)
expr_stmt|;
operator|*
name|boundary
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|item
init|=
name|list
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|object
operator|.
name|util
condition|)
block|{
name|new_mass_counter
argument_list|(
name|list
operator|->
name|item
argument_list|,
name|get_one
argument_list|()
argument_list|)
expr_stmt|;
name|add
argument_list|(
operator|&
name|injected
argument_list|,
operator|&
name|injected
argument_list|,
name|get_one
argument_list|()
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|cleaner
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|pending
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
operator|*
name|boundary
operator|&&
name|pending
operator|&&
operator|!
name|ret
condition|)
block|{
name|struct
name|commit
modifier|*
name|latest
init|=
name|pop_commit
argument_list|(
operator|&
name|pending
argument_list|)
decl_stmt|;
name|struct
name|mass_counter
modifier|*
name|latest_node
init|=
operator|(
expr|struct
name|mass_counter
operator|*
operator|)
name|latest
operator|->
name|object
operator|.
name|util
decl_stmt|;
name|int
name|num_parents
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_commit
argument_list|(
name|latest
argument_list|)
operator|)
condition|)
continue|continue;
name|add
argument_list|(
operator|&
name|latest_node
operator|->
name|seen
argument_list|,
operator|&
name|latest_node
operator|->
name|seen
argument_list|,
operator|&
name|latest_node
operator|->
name|pending
argument_list|)
expr_stmt|;
name|num_parents
operator|=
name|count_parents
argument_list|(
name|latest
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_parents
condition|)
block|{
name|struct
name|fraction
name|distribution
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|divide
argument_list|(
name|init_fraction
argument_list|(
operator|&
name|distribution
argument_list|)
argument_list|,
operator|&
name|latest_node
operator|->
name|pending
argument_list|,
name|num_parents
argument_list|)
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|latest
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|struct
name|mass_counter
modifier|*
name|parent_node
init|=
operator|(
expr|struct
name|mass_counter
operator|*
operator|)
name|parent
operator|->
name|object
operator|.
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|parent_node
condition|)
block|{
name|parent_node
operator|=
name|new_mass_counter
argument_list|(
name|parent
argument_list|,
operator|&
name|distribution
argument_list|)
expr_stmt|;
name|insert_by_date
argument_list|(
operator|&
name|pending
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|cleaner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|compare
argument_list|(
operator|&
name|parent_node
operator|->
name|pending
argument_list|,
name|get_zero
argument_list|()
argument_list|)
condition|)
name|insert_by_date
argument_list|(
operator|&
name|pending
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|add
argument_list|(
operator|&
name|parent_node
operator|->
name|pending
argument_list|,
operator|&
name|parent_node
operator|->
name|pending
argument_list|,
operator|&
name|distribution
argument_list|)
expr_stmt|;
block|}
block|}
name|clear_fraction
argument_list|(
operator|&
name|distribution
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compare
argument_list|(
operator|&
name|latest_node
operator|->
name|seen
argument_list|,
operator|&
name|injected
argument_list|)
condition|)
operator|*
name|boundary
operator|=
name|latest
expr_stmt|;
name|copy
argument_list|(
operator|&
name|latest_node
operator|->
name|pending
argument_list|,
name|get_zero
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cleaner
condition|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|pop_commit
argument_list|(
operator|&
name|cleaner
argument_list|)
decl_stmt|;
name|free_mass_counter
argument_list|(
operator|(
expr|struct
name|mass_counter
operator|*
operator|)
name|next
operator|->
name|object
operator|.
name|util
argument_list|)
expr_stmt|;
name|next
operator|->
name|object
operator|.
name|util
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pending
condition|)
name|free_commit_list
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|clear_fraction
argument_list|(
operator|&
name|injected
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Finds the base of an minimal, non-linear epoch, headed at head, by  * applying the find_base_for_list to a list consisting of the parents  */
end_comment
begin_function
DECL|function|find_base
specifier|static
name|int
name|find_base
parameter_list|(
name|struct
name|commit
modifier|*
name|head
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|boundary
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|pending
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|head
operator|->
name|parents
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|commit_list_insert
argument_list|(
name|next
operator|->
name|item
argument_list|,
operator|&
name|pending
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|find_base_for_list
argument_list|(
name|pending
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|pending
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * This procedure traverses to the boundary of the first epoch in the epoch  * sequence of the epoch headed at head_of_epoch. This is either the end of  * the maximal linear epoch or the base of a minimal non-linear epoch.  *  * The queue of pending nodes is sorted in reverse date order and each node  * is currently in the queue at most once.  */
end_comment
begin_function
DECL|function|find_next_epoch_boundary
specifier|static
name|int
name|find_next_epoch_boundary
parameter_list|(
name|struct
name|commit
modifier|*
name|head_of_epoch
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|boundary
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|commit
modifier|*
name|item
init|=
name|head_of_epoch
decl_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|item
argument_list|)
condition|)
block|{
comment|/* 		 * We are at the start of a maximimal linear epoch. 		 * Traverse to the end. 		 */
while|while
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|item
argument_list|)
operator|&&
operator|!
name|ret
condition|)
block|{
name|item
operator|=
name|item
operator|->
name|parents
operator|->
name|item
expr_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
operator|*
name|boundary
operator|=
name|item
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, we are at the start of a minimal, non-linear 		 * epoch - find the common base of all parents. 		 */
name|ret
operator|=
name|find_base
argument_list|(
name|item
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Returns non-zero if parent is known to be a parent of child.  */
end_comment
begin_function
DECL|function|is_parent_of
specifier|static
name|int
name|is_parent_of
parameter_list|(
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|commit
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
for|for
control|(
name|parents
operator|=
name|child
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
sizeof|sizeof
argument_list|(
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Pushes an item onto the merge order stack. If the top of the stack is  * marked as being a possible "break", we check to see whether it actually  * is a break.  */
end_comment
begin_function
DECL|function|push_onto_merge_order_stack
specifier|static
name|void
name|push_onto_merge_order_stack
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|,
name|struct
name|commit
modifier|*
name|item
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|top
init|=
operator|*
name|stack
decl_stmt|;
if|if
condition|(
name|top
operator|&&
operator|(
name|top
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|DISCONTINUITY
operator|)
condition|)
block|{
if|if
condition|(
name|is_parent_of
argument_list|(
name|top
operator|->
name|item
argument_list|,
name|item
argument_list|)
condition|)
block|{
name|top
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|DISCONTINUITY
expr_stmt|;
block|}
block|}
name|commit_list_insert
argument_list|(
name|item
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Marks all interesting, visited commits reachable from this commit  * as uninteresting. We stop recursing when we reach the epoch boundary,  * an unvisited node or a node that has already been marking uninteresting.  *  * This doesn't actually mark all ancestors between the start node and the  * epoch boundary uninteresting, but does ensure that they will eventually  * be marked uninteresting when the main sort_first_epoch() traversal  * eventually reaches them.  */
end_comment
begin_function
DECL|function|mark_ancestors_uninteresting
specifier|static
name|void
name|mark_ancestors_uninteresting
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
name|commit
operator|->
name|object
operator|.
name|flags
decl_stmt|;
name|int
name|visited
init|=
name|flags
operator|&
name|VISITED
decl_stmt|;
name|int
name|boundary
init|=
name|flags
operator|&
name|BOUNDARY
decl_stmt|;
name|int
name|uninteresting
init|=
name|flags
operator|&
name|UNINTERESTING
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
comment|/* 	 * We only need to recurse if 	 *      we are not on the boundary and 	 *      we have not already been marked uninteresting and 	 *      we have already been visited. 	 * 	 * The main sort_first_epoch traverse will mark unreachable 	 * all uninteresting, unvisited parents as they are visited 	 * so there is no need to duplicate that traversal here. 	 * 	 * Similarly, if we are already marked uninteresting 	 * then either all ancestors have already been marked 	 * uninteresting or will be once the sort_first_epoch 	 * traverse reaches them. 	 */
if|if
condition|(
name|uninteresting
operator|||
name|boundary
operator|||
operator|!
name|visited
condition|)
return|return;
for|for
control|(
name|next
operator|=
name|commit
operator|->
name|parents
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
name|mark_ancestors_uninteresting
argument_list|(
name|next
operator|->
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Sorts the nodes of the first epoch of the epoch sequence of the epoch headed at head  * into merge order.  */
end_comment
begin_function
DECL|function|sort_first_epoch
specifier|static
name|void
name|sort_first_epoch
parameter_list|(
name|struct
name|commit
modifier|*
name|head
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|head
operator|->
name|object
operator|.
name|flags
operator||=
name|VISITED
expr_stmt|;
comment|/* 	 * TODO: By sorting the parents in a different order, we can alter the 	 * merge order to show contemporaneous changes in parallel branches 	 * occurring after "local" changes. This is useful for a developer 	 * when a developer wants to see all changes that were incorporated 	 * into the same merge as her own changes occur after her own 	 * changes. 	 */
for|for
control|(
name|parents
operator|=
name|head
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
block|{
comment|/* 			 * Propagates the uninteresting bit to all parents. 			 * if we have already visited this parent, then 			 * the uninteresting bit will be propagated to each 			 * reachable commit that is still not marked 			 * uninteresting and won't otherwise be reached. 			 */
name|mark_ancestors_uninteresting
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|VISITED
operator|)
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|BOUNDARY
condition|)
block|{
if|if
condition|(
operator|*
name|stack
condition|)
block|{
name|die
argument_list|(
literal|"something else is on the stack - %s"
argument_list|,
name|sha1_to_hex
argument_list|(
operator|(
operator|*
name|stack
operator|)
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|push_onto_merge_order_stack
argument_list|(
name|stack
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|object
operator|.
name|flags
operator||=
name|VISITED
expr_stmt|;
block|}
else|else
block|{
name|sort_first_epoch
argument_list|(
name|parent
argument_list|,
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|parents
condition|)
block|{
comment|/* 					 * This indicates a possible 					 * discontinuity it may not be be 					 * actual discontinuity if the head 					 * of parent N happens to be the tail 					 * of parent N+1. 					 * 					 * The next push onto the stack will 					 * resolve the question. 					 */
operator|(
operator|*
name|stack
operator|)
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|DISCONTINUITY
expr_stmt|;
block|}
block|}
block|}
block|}
name|push_onto_merge_order_stack
argument_list|(
name|stack
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Emit the contents of the stack.  *  * The stack is freed and replaced by NULL.  *  * Sets the return value to STOP if no further output should be generated.  */
end_comment
begin_function
DECL|function|emit_stack
specifier|static
name|int
name|emit_stack
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|,
name|emitter_func
name|emitter
parameter_list|,
name|int
name|include_last
parameter_list|)
block|{
name|unsigned
name|int
name|seen
init|=
literal|0
decl_stmt|;
name|int
name|action
init|=
name|CONTINUE
decl_stmt|;
while|while
condition|(
operator|*
name|stack
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|pop_commit
argument_list|(
name|stack
argument_list|)
decl_stmt|;
name|seen
operator||=
name|next
operator|->
name|object
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|*
name|stack
operator|||
name|include_last
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|stack
condition|)
name|next
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
name|action
operator|=
call|(
modifier|*
name|emitter
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|stack
condition|)
block|{
name|free_commit_list
argument_list|(
operator|*
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|action
operator|==
name|STOP
operator|||
operator|(
name|seen
operator|&
name|UNINTERESTING
operator|)
operator|)
condition|?
name|STOP
else|:
name|CONTINUE
return|;
block|}
end_function
begin_comment
comment|/*  * Sorts an arbitrary epoch into merge order by sorting each epoch  * of its epoch sequence into order.  *  * Note: this algorithm currently leaves traces of its execution in the  * object flags of nodes it discovers. This should probably be fixed.  */
end_comment
begin_function
DECL|function|sort_in_merge_order
specifier|static
name|int
name|sort_in_merge_order
parameter_list|(
name|struct
name|commit
modifier|*
name|head_of_epoch
parameter_list|,
name|emitter_func
name|emitter
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|head_of_epoch
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|action
init|=
name|CONTINUE
decl_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|head_of_epoch
argument_list|)
expr_stmt|;
name|next
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|parents
operator|&&
operator|!
name|ret
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
name|find_next_epoch_boundary
argument_list|(
name|next
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|next
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|base
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
if|if
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|next
argument_list|)
condition|)
block|{
while|while
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|next
argument_list|)
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
operator|&&
operator|!
name|ret
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
block|{
name|action
operator|=
name|STOP
expr_stmt|;
block|}
else|else
block|{
name|action
operator|=
call|(
modifier|*
name|emitter
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|!=
name|STOP
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|parents
operator|->
name|item
expr_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|commit_list
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|sort_first_epoch
argument_list|(
name|next
argument_list|,
operator|&
name|stack
argument_list|)
expr_stmt|;
name|action
operator|=
name|emit_stack
argument_list|(
operator|&
name|stack
argument_list|,
name|emitter
argument_list|,
operator|(
name|base
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|base
expr_stmt|;
block|}
block|}
if|if
condition|(
name|next
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
operator|&&
operator|!
name|ret
condition|)
block|{
call|(
modifier|*
name|emitter
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Sorts the nodes reachable from a starting list in merge order, we  * first find the base for the starting list and then sort all nodes  * in this subgraph using the sort_first_epoch algorithm. Once we have  * reached the base we can continue sorting using sort_in_merge_order.  */
end_comment
begin_function
DECL|function|sort_list_in_merge_order
name|int
name|sort_list_in_merge_order
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|,
name|emitter_func
name|emitter
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|struct
name|commit
modifier|*
name|base
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|action
init|=
name|CONTINUE
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|reversed
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|list
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|object
operator|.
name|flags
operator|&
name|DUPCHECK
operator|)
condition|)
block|{
name|next
operator|->
name|object
operator|.
name|flags
operator||=
name|DUPCHECK
expr_stmt|;
name|commit_list_insert
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|reversed
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|reversed
condition|)
return|return
name|ret
return|;
elseif|else
if|if
condition|(
operator|!
name|reversed
operator|->
name|next
condition|)
block|{
comment|/* 		 * If there is only one element in the list, we can sort it 		 * using sort_in_merge_order. 		 */
name|base
operator|=
name|reversed
operator|->
name|item
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, we search for the base of the list. 		 */
name|ret
operator|=
name|find_base_for_list
argument_list|(
name|reversed
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|base
condition|)
name|base
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
while|while
condition|(
name|reversed
condition|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|pop_commit
argument_list|(
operator|&
name|reversed
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|object
operator|.
name|flags
operator|&
name|VISITED
operator|)
condition|)
block|{
name|sort_first_epoch
argument_list|(
name|next
argument_list|,
operator|&
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed
condition|)
block|{
comment|/* 					 * If we have more commits  					 * to push, then the first 					 * push for the next parent may  					 * (or may * not) represent a  					 * discontinuity with respect 					 * to the parent currently on  					 * the top of the stack. 					 * 					 * Mark it for checking here,  					 * and check it with the next  					 * push. See sort_first_epoch() 					 * for more details. 					 */
name|stack
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|DISCONTINUITY
expr_stmt|;
block|}
block|}
block|}
name|action
operator|=
name|emit_stack
argument_list|(
operator|&
name|stack
argument_list|,
name|emitter
argument_list|,
operator|(
name|base
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
condition|)
block|{
name|ret
operator|=
name|sort_in_merge_order
argument_list|(
name|base
argument_list|,
name|emitter
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
end_unit
