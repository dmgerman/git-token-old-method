begin_unit
begin_comment
comment|/*  * Copyright (c) 2005, Jon Seymour  *  * For more information about epoch theory on which this module is based,  * refer to http://blackcubes.dyndns.org/epoch/. That web page defines  * terms such as "epoch" and "minimal, non-linear epoch" and provides rationales  * for some of the algorithms used here.  *  */
end_comment
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include
begin_comment
comment|// provides arbitrary precision integers
end_comment
begin_comment
comment|// required to accurately represent fractional
end_comment
begin_comment
comment|//mass
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"epoch.h"
end_include
begin_struct
DECL|struct|fraction
struct|struct
name|fraction
block|{
DECL|member|numerator
name|BIGNUM
name|numerator
decl_stmt|;
DECL|member|denominator
name|BIGNUM
name|denominator
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|HAS_EXACTLY_ONE_PARENT
define|#
directive|define
name|HAS_EXACTLY_ONE_PARENT
parameter_list|(
name|n
parameter_list|)
value|((n)->parents&& !(n)->parents->next)
end_define
begin_decl_stmt
DECL|variable|context
specifier|static
name|BN_CTX
modifier|*
name|context
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|one
specifier|static
name|struct
name|fraction
modifier|*
name|one
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|zero
specifier|static
name|struct
name|fraction
modifier|*
name|zero
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_BN_CTX
specifier|static
name|BN_CTX
modifier|*
name|get_BN_CTX
parameter_list|()
block|{
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|context
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
end_function
begin_function
DECL|function|new_zero
specifier|static
name|struct
name|fraction
modifier|*
name|new_zero
parameter_list|()
block|{
name|struct
name|fraction
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|)
expr_stmt|;
name|BN_zero
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_one
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|clear_fraction
specifier|static
name|void
name|clear_fraction
parameter_list|(
name|struct
name|fraction
modifier|*
name|fraction
parameter_list|)
block|{
name|BN_clear
argument_list|(
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|fraction
operator|->
name|denominator
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|divide
specifier|static
name|struct
name|fraction
modifier|*
name|divide
parameter_list|(
name|struct
name|fraction
modifier|*
name|result
parameter_list|,
name|struct
name|fraction
modifier|*
name|fraction
parameter_list|,
name|int
name|divisor
parameter_list|)
block|{
name|BIGNUM
name|bn_divisor
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|bn_divisor
argument_list|)
expr_stmt|;
name|BN_set_word
argument_list|(
operator|&
name|bn_divisor
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|,
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|fraction
operator|->
name|denominator
argument_list|,
operator|&
name|bn_divisor
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|bn_divisor
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|init_fraction
specifier|static
name|struct
name|fraction
modifier|*
name|init_fraction
parameter_list|(
name|struct
name|fraction
modifier|*
name|fraction
parameter_list|)
block|{
name|BN_init
argument_list|(
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|fraction
operator|->
name|denominator
argument_list|)
expr_stmt|;
name|BN_zero
argument_list|(
operator|&
name|fraction
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_one
argument_list|(
operator|&
name|fraction
operator|->
name|denominator
argument_list|)
expr_stmt|;
return|return
name|fraction
return|;
block|}
end_function
begin_function
DECL|function|get_one
specifier|static
name|struct
name|fraction
modifier|*
name|get_one
parameter_list|()
block|{
if|if
condition|(
operator|!
name|one
condition|)
block|{
name|one
operator|=
name|new_zero
argument_list|()
expr_stmt|;
name|BN_one
argument_list|(
operator|&
name|one
operator|->
name|numerator
argument_list|)
expr_stmt|;
block|}
return|return
name|one
return|;
block|}
end_function
begin_function
DECL|function|get_zero
specifier|static
name|struct
name|fraction
modifier|*
name|get_zero
parameter_list|()
block|{
if|if
condition|(
operator|!
name|zero
condition|)
block|{
name|zero
operator|=
name|new_zero
argument_list|()
expr_stmt|;
block|}
return|return
name|zero
return|;
block|}
end_function
begin_function
DECL|function|copy
specifier|static
name|struct
name|fraction
modifier|*
name|copy
parameter_list|(
name|struct
name|fraction
modifier|*
name|to
parameter_list|,
name|struct
name|fraction
modifier|*
name|from
parameter_list|)
block|{
name|BN_copy
argument_list|(
operator|&
name|to
operator|->
name|numerator
argument_list|,
operator|&
name|from
operator|->
name|numerator
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
operator|&
name|to
operator|->
name|denominator
argument_list|,
operator|&
name|from
operator|->
name|denominator
argument_list|)
expr_stmt|;
return|return
name|to
return|;
block|}
end_function
begin_function
DECL|function|add
specifier|static
name|struct
name|fraction
modifier|*
name|add
parameter_list|(
name|struct
name|fraction
modifier|*
name|result
parameter_list|,
name|struct
name|fraction
modifier|*
name|left
parameter_list|,
name|struct
name|fraction
modifier|*
name|right
parameter_list|)
block|{
name|BIGNUM
name|a
decl_stmt|,
name|b
decl_stmt|,
name|gcd
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|gcd
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|left
operator|->
name|numerator
argument_list|,
operator|&
name|right
operator|->
name|denominator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|left
operator|->
name|denominator
argument_list|,
operator|&
name|right
operator|->
name|numerator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|left
operator|->
name|denominator
argument_list|,
operator|&
name|right
operator|->
name|denominator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
operator|&
name|gcd
argument_list|,
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|result
operator|->
name|numerator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
operator|&
name|result
operator|->
name|denominator
argument_list|,
name|NULL
argument_list|,
operator|&
name|result
operator|->
name|denominator
argument_list|,
operator|&
name|gcd
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
operator|&
name|result
operator|->
name|numerator
argument_list|,
name|NULL
argument_list|,
operator|&
name|result
operator|->
name|numerator
argument_list|,
operator|&
name|gcd
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|gcd
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|compare
specifier|static
name|int
name|compare
parameter_list|(
name|struct
name|fraction
modifier|*
name|left
parameter_list|,
name|struct
name|fraction
modifier|*
name|right
parameter_list|)
block|{
name|BIGNUM
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|result
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|left
operator|->
name|numerator
argument_list|,
operator|&
name|right
operator|->
name|denominator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|BN_mul
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|left
operator|->
name|denominator
argument_list|,
operator|&
name|right
operator|->
name|numerator
argument_list|,
name|get_BN_CTX
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|BN_cmp
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|BN_clear
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_struct
DECL|struct|mass_counter
struct|struct
name|mass_counter
block|{
DECL|member|seen
name|struct
name|fraction
name|seen
decl_stmt|;
DECL|member|pending
name|struct
name|fraction
name|pending
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|new_mass_counter
specifier|static
name|struct
name|mass_counter
modifier|*
name|new_mass_counter
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|fraction
modifier|*
name|pending
parameter_list|)
block|{
name|struct
name|mass_counter
modifier|*
name|mass_counter
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mass_counter
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|mass_counter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mass_counter
argument_list|)
argument_list|)
expr_stmt|;
name|init_fraction
argument_list|(
operator|&
name|mass_counter
operator|->
name|seen
argument_list|)
expr_stmt|;
name|init_fraction
argument_list|(
operator|&
name|mass_counter
operator|->
name|pending
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|mass_counter
operator|->
name|pending
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|mass_counter
operator|->
name|seen
argument_list|,
name|get_zero
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|util
condition|)
block|{
name|die
argument_list|(
literal|"multiple attempts to initialize mass counter for %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|commit
operator|->
name|object
operator|.
name|util
operator|=
name|mass_counter
expr_stmt|;
return|return
name|mass_counter
return|;
block|}
end_function
begin_function
DECL|function|free_mass_counter
specifier|static
name|void
name|free_mass_counter
parameter_list|(
name|struct
name|mass_counter
modifier|*
name|counter
parameter_list|)
block|{
name|clear_fraction
argument_list|(
operator|&
name|counter
operator|->
name|seen
argument_list|)
expr_stmt|;
name|clear_fraction
argument_list|(
operator|&
name|counter
operator|->
name|pending
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|counter
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Finds the base commit of a list of commits.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// One property of the commit being searched for is that every commit reachable
end_comment
begin_comment
comment|// from the base commit is reachable from the commits in the starting list only
end_comment
begin_comment
comment|// via paths that include the base commit.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This algorithm uses a conservation of mass approach to find the base commit.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// We start by injecting one unit of mass into the graph at each
end_comment
begin_comment
comment|// of the commits in the starting list. Injecting mass into a commit
end_comment
begin_comment
comment|// is achieved by adding to its pending mass counter and, if it is not already
end_comment
begin_comment
comment|// enqueued, enqueuing the commit in a list of pending commits, in latest
end_comment
begin_comment
comment|// commit date first order.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The algorithm then preceeds to visit each commit in the pending queue.
end_comment
begin_comment
comment|// Upon each visit, the pending mass is added to the mass already seen for that
end_comment
begin_comment
comment|// commit and then divided into N equal portions, where N is the number of
end_comment
begin_comment
comment|// parents of the commit being visited. The divided portions are then injected
end_comment
begin_comment
comment|// into each of the parents.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The algorithm continues until we discover a commit which has seen all the
end_comment
begin_comment
comment|// mass originally injected or until we run out of things to do.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// If we find a commit that has seen all the original mass, we have found
end_comment
begin_comment
comment|// the common base of all the commits in the starting list.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The algorithm does _not_ depend on accurate timestamps for correct operation.
end_comment
begin_comment
comment|// However, reasonably sane (e.g. non-random) timestamps are required in order
end_comment
begin_comment
comment|// to prevent an exponential performance characteristic. The occasional
end_comment
begin_comment
comment|// timestamp inaccuracy will not dramatically affect performance but may
end_comment
begin_comment
comment|// result in more nodes being processed than strictly necessary.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This procedure sets *boundary to the address of the base commit. It returns
end_comment
begin_comment
comment|// non-zero if, and only if, there was a problem parsing one of the
end_comment
begin_comment
comment|// commits discovered during the traversal.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|find_base_for_list
specifier|static
name|int
name|find_base_for_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|boundary
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|cleaner
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|pending
init|=
name|NULL
decl_stmt|;
operator|*
name|boundary
operator|=
name|NULL
expr_stmt|;
name|struct
name|fraction
name|injected
decl_stmt|;
name|init_fraction
argument_list|(
operator|&
name|injected
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|item
init|=
name|list
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|util
operator|||
operator|(
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
block|{
name|die
argument_list|(
literal|"%s:%d:%s: logic error: this should not have happened - commit %s\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__FUNCTION__
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_mass_counter
argument_list|(
name|list
operator|->
name|item
argument_list|,
name|get_one
argument_list|()
argument_list|)
expr_stmt|;
name|add
argument_list|(
operator|&
name|injected
argument_list|,
operator|&
name|injected
argument_list|,
name|get_one
argument_list|()
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|cleaner
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|pending
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
operator|*
name|boundary
operator|&&
name|pending
operator|&&
operator|!
name|ret
condition|)
block|{
name|struct
name|commit
modifier|*
name|latest
init|=
name|pop_commit
argument_list|(
operator|&
name|pending
argument_list|)
decl_stmt|;
name|struct
name|mass_counter
modifier|*
name|latest_node
init|=
operator|(
expr|struct
name|mass_counter
operator|*
operator|)
name|latest
operator|->
name|object
operator|.
name|util
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_commit
argument_list|(
name|latest
argument_list|)
operator|)
condition|)
continue|continue;
name|add
argument_list|(
operator|&
name|latest_node
operator|->
name|seen
argument_list|,
operator|&
name|latest_node
operator|->
name|seen
argument_list|,
operator|&
name|latest_node
operator|->
name|pending
argument_list|)
expr_stmt|;
name|int
name|num_parents
init|=
name|count_parents
argument_list|(
name|latest
argument_list|)
decl_stmt|;
if|if
condition|(
name|num_parents
condition|)
block|{
name|struct
name|fraction
name|distribution
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|divide
argument_list|(
name|init_fraction
argument_list|(
operator|&
name|distribution
argument_list|)
argument_list|,
operator|&
name|latest_node
operator|->
name|pending
argument_list|,
name|num_parents
argument_list|)
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|latest
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|struct
name|mass_counter
modifier|*
name|parent_node
init|=
operator|(
expr|struct
name|mass_counter
operator|*
operator|)
name|parent
operator|->
name|object
operator|.
name|util
decl_stmt|;
if|if
condition|(
operator|!
name|parent_node
condition|)
block|{
name|parent_node
operator|=
name|new_mass_counter
argument_list|(
name|parent
argument_list|,
operator|&
name|distribution
argument_list|)
expr_stmt|;
name|insert_by_date
argument_list|(
operator|&
name|pending
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|cleaner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|compare
argument_list|(
operator|&
name|parent_node
operator|->
name|pending
argument_list|,
name|get_zero
argument_list|()
argument_list|)
condition|)
block|{
name|insert_by_date
argument_list|(
operator|&
name|pending
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|add
argument_list|(
operator|&
name|parent_node
operator|->
name|pending
argument_list|,
operator|&
name|parent_node
operator|->
name|pending
argument_list|,
operator|&
name|distribution
argument_list|)
expr_stmt|;
block|}
block|}
name|clear_fraction
argument_list|(
operator|&
name|distribution
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compare
argument_list|(
operator|&
name|latest_node
operator|->
name|seen
argument_list|,
operator|&
name|injected
argument_list|)
condition|)
block|{
operator|*
name|boundary
operator|=
name|latest
expr_stmt|;
block|}
name|copy
argument_list|(
operator|&
name|latest_node
operator|->
name|pending
argument_list|,
name|get_zero
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cleaner
condition|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|pop_commit
argument_list|(
operator|&
name|cleaner
argument_list|)
decl_stmt|;
name|free_mass_counter
argument_list|(
operator|(
expr|struct
name|mass_counter
operator|*
operator|)
name|next
operator|->
name|object
operator|.
name|util
argument_list|)
expr_stmt|;
name|next
operator|->
name|object
operator|.
name|util
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pending
condition|)
name|free_commit_list
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|clear_fraction
argument_list|(
operator|&
name|injected
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Finds the base of an minimal, non-linear epoch, headed at head, by
end_comment
begin_comment
comment|// applying the find_base_for_list to a list consisting of the parents
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|find_base
specifier|static
name|int
name|find_base
parameter_list|(
name|struct
name|commit
modifier|*
name|head
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|boundary
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|pending
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|;
name|commit_list_insert
argument_list|(
name|head
argument_list|,
operator|&
name|pending
argument_list|)
expr_stmt|;
for|for
control|(
name|next
operator|=
name|head
operator|->
name|parents
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|commit_list_insert
argument_list|(
name|next
operator|->
name|item
argument_list|,
operator|&
name|pending
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|find_base_for_list
argument_list|(
name|pending
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|pending
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// This procedure traverses to the boundary of the first epoch in the epoch
end_comment
begin_comment
comment|// sequence of the epoch headed at head_of_epoch. This is either the end of
end_comment
begin_comment
comment|// the maximal linear epoch or the base of a minimal non-linear epoch.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The queue of pending nodes is sorted in reverse date order and each node
end_comment
begin_comment
comment|// is currently in the queue at most once.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|find_next_epoch_boundary
specifier|static
name|int
name|find_next_epoch_boundary
parameter_list|(
name|struct
name|commit
modifier|*
name|head_of_epoch
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|boundary
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|commit
modifier|*
name|item
init|=
name|head_of_epoch
decl_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|item
argument_list|)
condition|)
block|{
comment|// we are at the start of a maximimal linear epoch .. traverse to the end
comment|// traverse to the end of a maximal linear epoch
while|while
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|item
argument_list|)
operator|&&
operator|!
name|ret
condition|)
block|{
name|item
operator|=
name|item
operator|->
name|parents
operator|->
name|item
expr_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
operator|*
name|boundary
operator|=
name|item
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise, we are at the start of a minimal, non-linear
comment|// epoch - find the common base of all parents.
name|ret
operator|=
name|find_base
argument_list|(
name|item
argument_list|,
name|boundary
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Returns non-zero if parent is known to be a parent of child.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|is_parent_of
specifier|static
name|int
name|is_parent_of
parameter_list|(
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|commit
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
for|for
control|(
name|parents
operator|=
name|child
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
sizeof|sizeof
argument_list|(
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Pushes an item onto the merge order stack. If the top of the stack is
end_comment
begin_comment
comment|// marked as being a possible "break", we check to see whether it actually
end_comment
begin_comment
comment|// is a break.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|push_onto_merge_order_stack
specifier|static
name|void
name|push_onto_merge_order_stack
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|,
name|struct
name|commit
modifier|*
name|item
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|top
init|=
operator|*
name|stack
decl_stmt|;
if|if
condition|(
name|top
operator|&&
operator|(
name|top
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|DISCONTINUITY
operator|)
condition|)
block|{
if|if
condition|(
name|is_parent_of
argument_list|(
name|top
operator|->
name|item
argument_list|,
name|item
argument_list|)
condition|)
block|{
name|top
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|DISCONTINUITY
expr_stmt|;
block|}
block|}
name|commit_list_insert
argument_list|(
name|item
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Marks all interesting, visited commits reachable from this commit
end_comment
begin_comment
comment|// as uninteresting. We stop recursing when we reach the epoch boundary,
end_comment
begin_comment
comment|// an unvisited node or a node that has already been marking uninteresting.
end_comment
begin_comment
comment|// This doesn't actually mark all ancestors between the start node and the
end_comment
begin_comment
comment|// epoch boundary uninteresting, but does ensure that they will
end_comment
begin_comment
comment|// eventually be marked uninteresting when the main sort_first_epoch
end_comment
begin_comment
comment|// traversal eventually reaches them.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|mark_ancestors_uninteresting
specifier|static
name|void
name|mark_ancestors_uninteresting
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
name|commit
operator|->
name|object
operator|.
name|flags
decl_stmt|;
name|int
name|visited
init|=
name|flags
operator|&
name|VISITED
decl_stmt|;
name|int
name|boundary
init|=
name|flags
operator|&
name|BOUNDARY
decl_stmt|;
name|int
name|uninteresting
init|=
name|flags
operator|&
name|UNINTERESTING
decl_stmt|;
if|if
condition|(
name|uninteresting
operator|||
name|boundary
operator|||
operator|!
name|visited
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|UNINTERESTING
expr_stmt|;
return|return;
comment|// we only need to recurse if
comment|//      we are not on the boundary, and,
comment|//      we have not already been marked uninteresting, and,
comment|//      we have already been visited.
comment|//
comment|// the main sort_first_epoch traverse will
comment|// mark unreachable all uninteresting, unvisited parents
comment|// as they are visited so there is no need to duplicate
comment|// that traversal here.
comment|//
comment|// similarly, if we are already marked uninteresting
comment|// then either all ancestors have already been marked
comment|// uninteresting or will be once the sort_first_epoch
comment|// traverse reaches them.
comment|//
block|}
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|commit
operator|->
name|parents
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
name|mark_ancestors_uninteresting
argument_list|(
name|next
operator|->
name|item
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Sorts the nodes of the first epoch of the epoch sequence of the epoch headed at head
end_comment
begin_comment
comment|// into merge order.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|sort_first_epoch
specifier|static
name|void
name|sort_first_epoch
parameter_list|(
name|struct
name|commit
modifier|*
name|head
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|reversed_parents
init|=
name|NULL
decl_stmt|;
name|head
operator|->
name|object
operator|.
name|flags
operator||=
name|VISITED
expr_stmt|;
comment|//
comment|// parse_commit builds the parent list in reverse order with respect to the order of
comment|// the git-commit-tree arguments.
comment|//
comment|// so we need to reverse this list to output the oldest (or most "local") commits last.
comment|//
for|for
control|(
name|parents
operator|=
name|head
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
name|commit_list_insert
argument_list|(
name|parents
operator|->
name|item
argument_list|,
operator|&
name|reversed_parents
argument_list|)
expr_stmt|;
comment|//
comment|// todo: by sorting the parents in a different order, we can alter the
comment|// merge order to show contemporaneous changes in parallel branches
comment|// occurring after "local" changes. This is useful for a developer
comment|// when a developer wants to see all changes that were incorporated
comment|// into the same merge as her own changes occur after her own
comment|// changes.
comment|//
while|while
condition|(
name|reversed_parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|pop_commit
argument_list|(
operator|&
name|reversed_parents
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
block|{
comment|// propagates the uninteresting bit to
comment|// all parents. if we have already visited
comment|// this parent, then the uninteresting bit
comment|// will be propagated to each reachable
comment|// commit that is still not marked uninteresting
comment|// and won't otherwise be reached.
name|mark_ancestors_uninteresting
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|VISITED
operator|)
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|BOUNDARY
condition|)
block|{
if|if
condition|(
operator|*
name|stack
condition|)
block|{
name|die
argument_list|(
literal|"something else is on the stack - %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
operator|(
operator|*
name|stack
operator|)
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|push_onto_merge_order_stack
argument_list|(
name|stack
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|object
operator|.
name|flags
operator||=
name|VISITED
expr_stmt|;
block|}
else|else
block|{
name|sort_first_epoch
argument_list|(
name|parent
argument_list|,
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed_parents
condition|)
block|{
comment|//
comment|// this indicates a possible discontinuity
comment|// it may not be be actual discontinuity if
comment|// the head of parent N happens to be the tail
comment|// of parent N+1
comment|//
comment|// the next push onto the stack will resolve the
comment|// question
comment|//
operator|(
operator|*
name|stack
operator|)
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|DISCONTINUITY
expr_stmt|;
block|}
block|}
block|}
block|}
name|push_onto_merge_order_stack
argument_list|(
name|stack
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Emit the contents of the stack.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// The stack is freed and replaced by NULL.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Sets the return value to STOP if no further output should be generated.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|emit_stack
specifier|static
name|int
name|emit_stack
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|,
name|emitter_func
name|emitter
parameter_list|)
block|{
name|unsigned
name|int
name|seen
init|=
literal|0
decl_stmt|;
name|int
name|action
init|=
name|CONTINUE
decl_stmt|;
while|while
condition|(
operator|*
name|stack
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|pop_commit
argument_list|(
name|stack
argument_list|)
decl_stmt|;
name|seen
operator||=
name|next
operator|->
name|object
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|*
name|stack
condition|)
block|{
name|action
operator|=
call|(
modifier|*
name|emitter
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|stack
condition|)
block|{
name|free_commit_list
argument_list|(
operator|*
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|action
operator|==
name|STOP
operator|||
operator|(
name|seen
operator|&
name|UNINTERESTING
operator|)
operator|)
condition|?
name|STOP
else|:
name|CONTINUE
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Sorts an arbitrary epoch into merge order by sorting each epoch
end_comment
begin_comment
comment|// of its epoch sequence into order.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Note: this algorithm currently leaves traces of its execution in the
end_comment
begin_comment
comment|// object flags of nodes it discovers. This should probably be fixed.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|sort_in_merge_order
specifier|static
name|int
name|sort_in_merge_order
parameter_list|(
name|struct
name|commit
modifier|*
name|head_of_epoch
parameter_list|,
name|emitter_func
name|emitter
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|head_of_epoch
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|action
init|=
name|CONTINUE
decl_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|head_of_epoch
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|parents
operator|&&
operator|!
name|ret
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|find_next_epoch_boundary
argument_list|(
name|next
argument_list|,
operator|&
name|base
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|next
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|base
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
block|}
if|if
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|next
argument_list|)
condition|)
block|{
while|while
condition|(
name|HAS_EXACTLY_ONE_PARENT
argument_list|(
name|next
argument_list|)
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
operator|&&
operator|!
name|ret
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
condition|)
block|{
name|action
operator|=
name|STOP
expr_stmt|;
block|}
else|else
block|{
name|action
operator|=
call|(
modifier|*
name|emitter
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|!=
name|STOP
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|parents
operator|->
name|item
expr_stmt|;
name|ret
operator|=
name|parse_commit
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|commit_list
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|sort_first_epoch
argument_list|(
name|next
argument_list|,
operator|&
name|stack
argument_list|)
expr_stmt|;
name|action
operator|=
name|emit_stack
argument_list|(
operator|&
name|stack
argument_list|,
name|emitter
argument_list|)
expr_stmt|;
name|next
operator|=
name|base
expr_stmt|;
block|}
block|}
if|if
condition|(
name|next
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
operator|&&
operator|!
name|ret
condition|)
block|{
call|(
modifier|*
name|emitter
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|//
end_comment
begin_comment
comment|// Sorts the nodes reachable from a starting list in merge order, we
end_comment
begin_comment
comment|// first find the base for the starting list and then sort all nodes in this
end_comment
begin_comment
comment|// subgraph using the sort_first_epoch algorithm. Once we have reached the base
end_comment
begin_comment
comment|// we can continue sorting using sort_in_merge_order.
end_comment
begin_comment
comment|//
end_comment
begin_function
DECL|function|sort_list_in_merge_order
name|int
name|sort_list_in_merge_order
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|,
name|emitter_func
name|emitter
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|struct
name|commit
modifier|*
name|base
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|action
init|=
name|CONTINUE
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|reversed
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|next
init|=
name|list
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|object
operator|.
name|flags
operator|&
name|UNINTERESTING
operator|)
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|object
operator|.
name|flags
operator|&
name|DUPCHECK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: duplicate commit %s ignored\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sha1_to_hex
argument_list|(
name|next
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|->
name|object
operator|.
name|flags
operator||=
name|DUPCHECK
expr_stmt|;
name|commit_list_insert
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|reversed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|reversed
operator|->
name|next
condition|)
block|{
comment|// if there is only one element in the list, we can sort it using
comment|// sort_in_merge_order.
name|base
operator|=
name|reversed
operator|->
name|item
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise, we search for the base of the list
if|if
condition|(
operator|(
name|ret
operator|=
name|find_base_for_list
argument_list|(
name|reversed
argument_list|,
operator|&
name|base
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|base
condition|)
block|{
name|base
operator|->
name|object
operator|.
name|flags
operator||=
name|BOUNDARY
expr_stmt|;
block|}
while|while
condition|(
name|reversed
condition|)
block|{
name|sort_first_epoch
argument_list|(
name|pop_commit
argument_list|(
operator|&
name|reversed
argument_list|)
argument_list|,
operator|&
name|stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed
condition|)
block|{
comment|//
comment|// if we have more commits to push, then the
comment|// first push for the next parent may (or may not)
comment|// represent a discontinuity with respect to the
comment|// parent currently on the top of the stack.
comment|//
comment|// mark it for checking here, and check it
comment|// with the next push...see sort_first_epoch for
comment|// more details.
comment|//
name|stack
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|DISCONTINUITY
expr_stmt|;
block|}
block|}
name|action
operator|=
name|emit_stack
argument_list|(
operator|&
name|stack
argument_list|,
name|emitter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|&&
operator|(
name|action
operator|!=
name|STOP
operator|)
condition|)
block|{
name|ret
operator|=
name|sort_in_merge_order
argument_list|(
name|base
argument_list|,
name|emitter
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
end_unit
