begin_unit
begin_comment
comment|/*  * GIT - The information manager from hell  *  * Copyright (C) Linus Torvalds, 2005  *  * This handles basic git sha1 object files - packing, unpacking,  * creation etc.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"delta.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"tree-walk.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"pack-revindex.h"
end_include
begin_include
include|#
directive|include
file|"sha1-lookup.h"
end_include
begin_include
include|#
directive|include
file|"bulk-checkin.h"
end_include
begin_include
include|#
directive|include
file|"streaming.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|O_NOATIME
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__PPC__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|O_NOATIME
define|#
directive|define
name|O_NOATIME
value|01000000
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|O_NOATIME
define|#
directive|define
name|O_NOATIME
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|SZ_FMT
define|#
directive|define
name|SZ_FMT
value|PRIuMAX
end_define
begin_function
DECL|function|sz_fmt
specifier|static
specifier|inline
name|uintmax_t
name|sz_fmt
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
return|return
name|s
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|null_sha1
specifier|const
name|unsigned
name|char
name|null_sha1
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|no_log_pack_access
specifier|static
specifier|const
name|char
modifier|*
name|no_log_pack_access
init|=
literal|"no_log_pack_access"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|log_pack_access
specifier|static
specifier|const
name|char
modifier|*
name|log_pack_access
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * This is meant to hold a *small* number of objects that you would  * want read_sha1_file() to be able to return, but yet you do not want  * to write them into the object store (e.g. a browse-only  * application).  */
end_comment
begin_struct
DECL|struct|cached_object
specifier|static
struct|struct
name|cached_object
block|{
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|type
name|enum
name|object_type
name|type
decl_stmt|;
DECL|member|buf
name|void
modifier|*
name|buf
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|size
decl_stmt|;
block|}
DECL|variable|cached_objects
modifier|*
name|cached_objects
struct|;
end_struct
begin_decl_stmt
DECL|variable|cached_object_nr
DECL|variable|cached_object_alloc
specifier|static
name|int
name|cached_object_nr
decl_stmt|,
name|cached_object_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|empty_tree
specifier|static
name|struct
name|cached_object
name|empty_tree
init|=
block|{
name|EMPTY_TREE_SHA1_BIN_LITERAL
block|,
name|OBJ_TREE
block|,
literal|""
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|last_found_pack
specifier|static
name|struct
name|packed_git
modifier|*
name|last_found_pack
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|find_cached_object
specifier|static
name|struct
name|cached_object
modifier|*
name|find_cached_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|cached_object
modifier|*
name|co
init|=
name|cached_objects
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cached_object_nr
condition|;
name|i
operator|++
operator|,
name|co
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|co
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|co
return|;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|empty_tree
operator|.
name|sha1
argument_list|)
condition|)
return|return
operator|&
name|empty_tree
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|mkdir_in_gitdir
name|int
name|mkdir_in_gitdir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 		 * Are we looking at a path in a symlinked worktree 		 * whose original repository does not yet have it? 		 * e.g. .git/rr-cache pointing at its original 		 * repository in which the user hasn't performed any 		 * conflict resolution yet? 		 */
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|||
name|strbuf_readlink
argument_list|(
operator|&
name|sb
argument_list|,
name|path
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|||
operator|!
name|is_absolute_path
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
operator|||
name|mkdir
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
return|return
name|adjust_shared_perm
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|safe_create_leading_directories
name|int
name|safe_create_leading_directories
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|pos
init|=
name|path
operator|+
name|offset_1st_component
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
while|while
condition|(
name|pos
condition|)
block|{
name|pos
operator|=
name|strchr
argument_list|(
name|pos
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
while|while
condition|(
operator|*
operator|++
name|pos
operator|==
literal|'/'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|pos
condition|)
break|break;
operator|*
operator|--
name|pos
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* path exists */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
operator|&&
operator|!
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* somebody created it since we checked */
block|}
else|else
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|adjust_shared_perm
argument_list|(
name|path
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
operator|*
name|pos
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|safe_create_leading_directories_const
name|int
name|safe_create_leading_directories_const
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
comment|/* path points to cache entries, so xstrdup before messing with it */
name|char
modifier|*
name|buf
init|=
name|xstrdup
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|safe_create_leading_directories
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|fill_sha1_path
specifier|static
name|void
name|fill_sha1_path
parameter_list|(
name|char
modifier|*
name|pathbuf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|unsigned
name|int
name|val
init|=
name|sha1
index|[
name|i
index|]
decl_stmt|;
name|char
modifier|*
name|pos
init|=
name|pathbuf
operator|+
name|i
operator|*
literal|2
operator|+
operator|(
name|i
operator|>
literal|0
operator|)
decl_stmt|;
operator|*
name|pos
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|pos
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * NOTE! This returns a statically allocated buffer, so you have to be  * careful about using it. Do an "xstrdup()" if you need to save the  * filename.  *  * Also note that this returns the location for creating.  Reading  * SHA1 file can happen from any alternate directory listed in the  * DB_ENVIRONMENT environment variable if it is not found in  * the primary object database.  */
end_comment
begin_function
DECL|function|sha1_file_name
name|char
modifier|*
name|sha1_file_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|objdir
decl_stmt|;
name|int
name|len
decl_stmt|;
name|objdir
operator|=
name|get_object_directory
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|objdir
argument_list|)
expr_stmt|;
comment|/* '/' + sha1(2) + '/' + sha1(38) + '\0' */
if|if
condition|(
name|len
operator|+
literal|43
operator|>
name|PATH_MAX
condition|)
name|die
argument_list|(
literal|"insanely long object directory %s"
argument_list|,
name|objdir
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|objdir
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'/'
expr_stmt|;
name|buf
index|[
name|len
operator|+
literal|3
index|]
operator|=
literal|'/'
expr_stmt|;
name|buf
index|[
name|len
operator|+
literal|42
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fill_sha1_path
argument_list|(
name|buf
operator|+
name|len
operator|+
literal|1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_function
DECL|function|sha1_get_pack_name
specifier|static
name|char
modifier|*
name|sha1_get_pack_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|which
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|base
condition|)
block|{
specifier|const
name|char
modifier|*
name|sha1_file_directory
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|sha1_file_directory
argument_list|)
decl_stmt|;
operator|*
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|60
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|base
argument_list|,
literal|"%s/pack/pack-1234567890123456789012345678901234567890.%s"
argument_list|,
name|sha1_file_directory
argument_list|,
name|which
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
operator|*
name|base
operator|+
name|len
operator|+
literal|11
expr_stmt|;
block|}
name|buf
operator|=
operator|*
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|*
name|sha1
operator|++
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
return|return
operator|*
name|base
return|;
block|}
end_function
begin_function
DECL|function|sha1_pack_name
name|char
modifier|*
name|sha1_pack_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|;
return|return
name|sha1_get_pack_name
argument_list|(
name|sha1
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|base
argument_list|,
literal|"pack"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sha1_pack_index_name
name|char
modifier|*
name|sha1_pack_index_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|;
return|return
name|sha1_get_pack_name
argument_list|(
name|sha1
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|base
argument_list|,
literal|"idx"
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|alt_odb_list
name|struct
name|alternate_object_database
modifier|*
name|alt_odb_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|alt_odb_tail
specifier|static
name|struct
name|alternate_object_database
modifier|*
modifier|*
name|alt_odb_tail
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|int
name|git_open_noatime
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * Prepare alternate object database registry.  *  * The variable alt_odb_list points at the list of struct  * alternate_object_database.  The elements on this list come from  * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT  * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,  * whose contents is similar to that environment variable but can be  * LF separated.  Its base points at a statically allocated buffer that  * contains "/the/directory/corresponding/to/.git/objects/...", while  * its name points just after the slash at the end of ".git/objects/"  * in the example above, and has enough space to hold 40-byte hex  * SHA1, an extra slash for the first level indirection, and the  * terminating NUL.  */
end_comment
begin_function
DECL|function|link_alt_odb_entry
specifier|static
name|int
name|link_alt_odb_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|objdir
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|ent
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
name|int
name|pfxlen
decl_stmt|,
name|entlen
decl_stmt|;
name|struct
name|strbuf
name|pathbuf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|entry
argument_list|)
operator|&&
name|relative_base
condition|)
block|{
name|strbuf_addstr
argument_list|(
operator|&
name|pathbuf
argument_list|,
name|real_path
argument_list|(
name|relative_base
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|pathbuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|strbuf_addstr
argument_list|(
operator|&
name|pathbuf
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|normalize_path_copy
argument_list|(
name|pathbuf
operator|.
name|buf
argument_list|,
name|pathbuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|pfxlen
operator|=
name|strlen
argument_list|(
name|pathbuf
operator|.
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * The trailing slash after the directory name is given by 	 * this function at the end. Remove duplicates. 	 */
while|while
condition|(
name|pfxlen
operator|&&
name|pathbuf
operator|.
name|buf
index|[
name|pfxlen
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|pfxlen
operator|-=
literal|1
expr_stmt|;
name|entlen
operator|=
name|pfxlen
operator|+
literal|43
expr_stmt|;
comment|/* '/' + 2 hex + '/' + 38 hex + NUL */
name|ent
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
operator|+
name|entlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|pathbuf
operator|.
name|buf
argument_list|,
name|pfxlen
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|pathbuf
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
operator|=
name|ent
operator|->
name|base
operator|+
name|pfxlen
operator|+
literal|1
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
operator|+
literal|3
index|]
operator|=
literal|'/'
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
index|]
operator|=
name|ent
operator|->
name|base
index|[
name|entlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Detect cases where alternate disappeared */
if|if
condition|(
operator|!
name|is_directory
argument_list|(
name|ent
operator|->
name|base
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"object directory %s does not exist; "
literal|"check .git/objects/info/alternates."
argument_list|,
name|ent
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Prevent the common mistake of listing the same 	 * thing twice, or object directory itself. 	 */
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|alt
operator|->
name|base
argument_list|,
name|pfxlen
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|objdir
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* add the alternate entry */
operator|*
name|alt_odb_tail
operator|=
name|ent
expr_stmt|;
name|alt_odb_tail
operator|=
operator|&
operator|(
name|ent
operator|->
name|next
operator|)
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* recursively add alternates */
name|read_info_alternates
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
index|]
operator|=
literal|'/'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|link_alt_odb_entries
specifier|static
name|void
name|link_alt_odb_entries
parameter_list|(
specifier|const
name|char
modifier|*
name|alt
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|string_list
name|entries
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|char
modifier|*
name|alt_copy
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|depth
operator|>
literal|5
condition|)
block|{
name|error
argument_list|(
literal|"%s: ignoring alternate object stores, nesting too deep."
argument_list|,
name|relative_base
argument_list|)
expr_stmt|;
return|return;
block|}
name|alt_copy
operator|=
name|xmemdupz
argument_list|(
name|alt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|string_list_split_in_place
argument_list|(
operator|&
name|entries
argument_list|,
name|alt_copy
argument_list|,
name|sep
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|entry
init|=
name|entries
operator|.
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
if|if
condition|(
name|entry
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|entry
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|entry
argument_list|)
operator|&&
name|depth
condition|)
block|{
name|error
argument_list|(
literal|"%s: ignoring relative alternate object store %s"
argument_list|,
name|relative_base
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_alt_odb_entry
argument_list|(
name|entry
argument_list|,
name|relative_base
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
name|string_list_clear
argument_list|(
operator|&
name|entries
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alt_copy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_info_alternates
name|void
name|read_info_alternates
parameter_list|(
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|char
modifier|*
name|map
decl_stmt|;
name|size_t
name|mapsz
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
name|alt_file_name
index|[]
init|=
literal|"info/alternates"
decl_stmt|;
comment|/* Given that relative_base is no longer than PATH_MAX, 	   ensure that "path" has enough space to append "/", the 	   file name, "info/alternates", and a trailing NUL.  */
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|1
operator|+
sizeof|sizeof
name|alt_file_name
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|relative_base
argument_list|,
name|alt_file_name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|git_open_noatime
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|(
name|st
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|mapsz
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|map
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|mapsz
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|link_alt_odb_entries
argument_list|(
name|map
argument_list|,
name|mapsz
argument_list|,
literal|'\n'
argument_list|,
name|relative_base
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsz
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_to_alternates_file
name|void
name|add_to_alternates_file
parameter_list|(
specifier|const
name|char
modifier|*
name|reference
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|hold_lock_file_for_append
argument_list|(
name|lock
argument_list|,
name|git_path
argument_list|(
literal|"objects/info/alternates"
argument_list|)
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
decl_stmt|;
name|char
modifier|*
name|alt
init|=
name|mkpath
argument_list|(
literal|"%s\n"
argument_list|,
name|reference
argument_list|)
decl_stmt|;
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|alt
argument_list|,
name|strlen
argument_list|(
name|alt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_lock_file
argument_list|(
name|lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not close alternates file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_odb_tail
condition|)
name|link_alt_odb_entries
argument_list|(
name|alt
argument_list|,
name|strlen
argument_list|(
name|alt
argument_list|)
argument_list|,
literal|'\n'
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|foreach_alt_odb
name|void
name|foreach_alt_odb
parameter_list|(
name|alt_odb_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|alternate_object_database
modifier|*
name|ent
decl_stmt|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|alt_odb_list
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|fn
argument_list|(
name|ent
argument_list|,
name|cb
argument_list|)
condition|)
return|return;
block|}
end_function
begin_function
DECL|function|prepare_alt_odb
name|void
name|prepare_alt_odb
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|alt_odb_tail
condition|)
return|return;
name|alt
operator|=
name|getenv
argument_list|(
name|ALTERNATE_DB_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt
condition|)
name|alt
operator|=
literal|""
expr_stmt|;
name|alt_odb_tail
operator|=
operator|&
name|alt_odb_list
expr_stmt|;
name|link_alt_odb_entries
argument_list|(
name|alt
argument_list|,
name|strlen
argument_list|(
name|alt
argument_list|)
argument_list|,
name|PATH_SEP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_info_alternates
argument_list|(
name|get_object_directory
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|has_loose_object_local
specifier|static
name|int
name|has_loose_object_local
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
return|return
operator|!
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|has_loose_object_nonlocal
name|int
name|has_loose_object_nonlocal
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|fill_sha1_path
argument_list|(
name|alt
operator|->
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|alt
operator|->
name|base
argument_list|,
name|F_OK
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|has_loose_object
specifier|static
name|int
name|has_loose_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|has_loose_object_local
argument_list|(
name|sha1
argument_list|)
operator|||
name|has_loose_object_nonlocal
argument_list|(
name|sha1
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|pack_used_ctr
specifier|static
name|unsigned
name|int
name|pack_used_ctr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_mmap_calls
specifier|static
name|unsigned
name|int
name|pack_mmap_calls
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|peak_pack_open_windows
specifier|static
name|unsigned
name|int
name|peak_pack_open_windows
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_open_windows
specifier|static
name|unsigned
name|int
name|pack_open_windows
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_open_fds
specifier|static
name|unsigned
name|int
name|pack_open_fds
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_max_fds
specifier|static
name|unsigned
name|int
name|pack_max_fds
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|peak_pack_mapped
specifier|static
name|size_t
name|peak_pack_mapped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_mapped
specifier|static
name|size_t
name|pack_mapped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|packed_git
name|struct
name|packed_git
modifier|*
name|packed_git
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|pack_report
name|void
name|pack_report
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pack_report: getpagesize()            = %10"
name|SZ_FMT
literal|"\n"
literal|"pack_report: core.packedGitWindowSize = %10"
name|SZ_FMT
literal|"\n"
literal|"pack_report: core.packedGitLimit      = %10"
name|SZ_FMT
literal|"\n"
argument_list|,
name|sz_fmt
argument_list|(
name|getpagesize
argument_list|()
argument_list|)
argument_list|,
name|sz_fmt
argument_list|(
name|packed_git_window_size
argument_list|)
argument_list|,
name|sz_fmt
argument_list|(
name|packed_git_limit
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pack_report: pack_used_ctr            = %10u\n"
literal|"pack_report: pack_mmap_calls          = %10u\n"
literal|"pack_report: pack_open_windows        = %10u / %10u\n"
literal|"pack_report: pack_mapped              = "
literal|"%10"
name|SZ_FMT
literal|" / %10"
name|SZ_FMT
literal|"\n"
argument_list|,
name|pack_used_ctr
argument_list|,
name|pack_mmap_calls
argument_list|,
name|pack_open_windows
argument_list|,
name|peak_pack_open_windows
argument_list|,
name|sz_fmt
argument_list|(
name|pack_mapped
argument_list|)
argument_list|,
name|sz_fmt
argument_list|(
name|peak_pack_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_packed_git_idx
specifier|static
name|int
name|check_packed_git_idx
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|void
modifier|*
name|idx_map
decl_stmt|;
name|struct
name|pack_idx_header
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|idx_size
decl_stmt|;
name|uint32_t
name|version
decl_stmt|,
name|nr
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|index
decl_stmt|;
name|int
name|fd
init|=
name|git_open_noatime
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|idx_size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx_size
operator|<
literal|4
operator|*
literal|256
operator|+
literal|20
operator|+
literal|20
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"index file %s is too small"
argument_list|,
name|path
argument_list|)
return|;
block|}
name|idx_map
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|idx_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|idx_map
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|idx_signature
operator|==
name|htonl
argument_list|(
name|PACK_IDX_SIGNATURE
argument_list|)
condition|)
block|{
name|version
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|idx_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|<
literal|2
operator|||
name|version
operator|>
literal|2
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"index file %s is version %"
name|PRIu32
literal|" and is not supported by this binary"
literal|" (try upgrading GIT to a newer version)"
argument_list|,
name|path
argument_list|,
name|version
argument_list|)
return|;
block|}
block|}
else|else
name|version
operator|=
literal|1
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|idx_map
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
condition|)
name|index
operator|+=
literal|2
expr_stmt|;
comment|/* skip index header */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|n
init|=
name|ntohl
argument_list|(
name|index
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|nr
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"non-monotonic index %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
name|nr
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Total size: 		 *  - 256 index entries 4 bytes each 		 *  - 24-byte entries * nr (20-byte sha1 + 4-byte offset) 		 *  - 20-byte SHA1 of the packfile 		 *  - 20-byte SHA1 file checksum 		 */
if|if
condition|(
name|idx_size
operator|!=
literal|4
operator|*
literal|256
operator|+
name|nr
operator|*
literal|24
operator|+
literal|20
operator|+
literal|20
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"wrong index v1 file size in %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|version
operator|==
literal|2
condition|)
block|{
comment|/* 		 * Minimum size: 		 *  - 8 bytes of header 		 *  - 256 index entries 4 bytes each 		 *  - 20-byte sha1 entry * nr 		 *  - 4-byte crc entry * nr 		 *  - 4-byte offset entry * nr 		 *  - 20-byte SHA1 of the packfile 		 *  - 20-byte SHA1 file checksum 		 * And after the 4-byte offset table might be a 		 * variable sized table containing 8-byte entries 		 * for offsets larger than 2^31. 		 */
name|unsigned
name|long
name|min_size
init|=
literal|8
operator|+
literal|4
operator|*
literal|256
operator|+
name|nr
operator|*
operator|(
literal|20
operator|+
literal|4
operator|+
literal|4
operator|)
operator|+
literal|20
operator|+
literal|20
decl_stmt|;
name|unsigned
name|long
name|max_size
init|=
name|min_size
decl_stmt|;
if|if
condition|(
name|nr
condition|)
name|max_size
operator|+=
operator|(
name|nr
operator|-
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|idx_size
operator|<
name|min_size
operator|||
name|idx_size
operator|>
name|max_size
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"wrong index v2 file size in %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
if|if
condition|(
name|idx_size
operator|!=
name|min_size
operator|&&
comment|/* 		     * make sure we can deal with large pack offsets. 		     * 31-bit signed offset won't be enough, neither 		     * 32-bit unsigned one will be. 		     */
operator|(
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|<=
literal|4
operator|)
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"pack too large for current definition of off_t in %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
name|p
operator|->
name|index_version
operator|=
name|version
expr_stmt|;
name|p
operator|->
name|index_data
operator|=
name|idx_map
expr_stmt|;
name|p
operator|->
name|index_size
operator|=
name|idx_size
expr_stmt|;
name|p
operator|->
name|num_objects
operator|=
name|nr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|open_pack_index
name|int
name|open_pack_index
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|idx_name
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|index_data
condition|)
return|return
literal|0
return|;
name|idx_name
operator|=
name|xstrdup
argument_list|(
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|idx_name
operator|+
name|strlen
argument_list|(
name|idx_name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|".pack"
argument_list|)
argument_list|,
literal|".idx"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_packed_git_idx
argument_list|(
name|idx_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idx_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|scan_windows
specifier|static
name|void
name|scan_windows
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|packed_git
modifier|*
modifier|*
name|lru_p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|lru_w
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|lru_l
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w
decl_stmt|,
modifier|*
name|w_l
decl_stmt|;
for|for
control|(
name|w_l
operator|=
name|NULL
operator|,
name|w
operator|=
name|p
operator|->
name|windows
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|inuse_cnt
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lru_w
operator|||
name|w
operator|->
name|last_used
operator|<
operator|(
operator|*
name|lru_w
operator|)
operator|->
name|last_used
condition|)
block|{
operator|*
name|lru_p
operator|=
name|p
expr_stmt|;
operator|*
name|lru_w
operator|=
name|w
expr_stmt|;
operator|*
name|lru_l
operator|=
name|w_l
expr_stmt|;
block|}
block|}
name|w_l
operator|=
name|w
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|unuse_one_window
specifier|static
name|int
name|unuse_one_window
parameter_list|(
name|struct
name|packed_git
modifier|*
name|current
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|,
modifier|*
name|lru_p
init|=
name|NULL
decl_stmt|;
name|struct
name|pack_window
modifier|*
name|lru_w
init|=
name|NULL
decl_stmt|,
modifier|*
name|lru_l
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|current
condition|)
name|scan_windows
argument_list|(
name|current
argument_list|,
operator|&
name|lru_p
argument_list|,
operator|&
name|lru_w
argument_list|,
operator|&
name|lru_l
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|scan_windows
argument_list|(
name|p
argument_list|,
operator|&
name|lru_p
argument_list|,
operator|&
name|lru_w
argument_list|,
operator|&
name|lru_l
argument_list|)
expr_stmt|;
if|if
condition|(
name|lru_p
condition|)
block|{
name|munmap
argument_list|(
name|lru_w
operator|->
name|base
argument_list|,
name|lru_w
operator|->
name|len
argument_list|)
expr_stmt|;
name|pack_mapped
operator|-=
name|lru_w
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|lru_l
condition|)
name|lru_l
operator|->
name|next
operator|=
name|lru_w
operator|->
name|next
expr_stmt|;
else|else
name|lru_p
operator|->
name|windows
operator|=
name|lru_w
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|lru_w
argument_list|)
expr_stmt|;
name|pack_open_windows
operator|--
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|release_pack_memory
name|void
name|release_pack_memory
parameter_list|(
name|size_t
name|need
parameter_list|)
block|{
name|size_t
name|cur
init|=
name|pack_mapped
decl_stmt|;
while|while
condition|(
name|need
operator|>=
operator|(
name|cur
operator|-
name|pack_mapped
operator|)
operator|&&
name|unuse_one_window
argument_list|(
name|NULL
argument_list|)
condition|)
empty_stmt|;
comment|/* nothing */
block|}
end_function
begin_function
DECL|function|xmmap
name|void
modifier|*
name|xmmap
parameter_list|(
name|void
modifier|*
name|start
parameter_list|,
name|size_t
name|length
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|void
modifier|*
name|ret
init|=
name|mmap
argument_list|(
name|start
argument_list|,
name|length
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|MAP_FAILED
condition|)
block|{
if|if
condition|(
operator|!
name|length
condition|)
return|return
name|NULL
return|;
name|release_pack_memory
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mmap
argument_list|(
name|start
argument_list|,
name|length
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|MAP_FAILED
condition|)
name|die_errno
argument_list|(
literal|"Out of memory? mmap failed"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|close_pack_windows
name|void
name|close_pack_windows
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|->
name|windows
condition|)
block|{
name|struct
name|pack_window
modifier|*
name|w
init|=
name|p
operator|->
name|windows
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|inuse_cnt
condition|)
name|die
argument_list|(
literal|"pack '%s' still has open windows to it"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|len
argument_list|)
expr_stmt|;
name|pack_mapped
operator|-=
name|w
operator|->
name|len
expr_stmt|;
name|pack_open_windows
operator|--
expr_stmt|;
name|p
operator|->
name|windows
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * The LRU pack is the one with the oldest MRU window, preferring packs  * with no used windows, or the oldest mtime if it has no windows allocated.  */
end_comment
begin_function
DECL|function|find_lru_pack
specifier|static
name|void
name|find_lru_pack
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|packed_git
modifier|*
modifier|*
name|lru_p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|mru_w
parameter_list|,
name|int
modifier|*
name|accept_windows_inuse
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w
decl_stmt|,
modifier|*
name|this_mru_w
decl_stmt|;
name|int
name|has_windows_inuse
init|=
literal|0
decl_stmt|;
comment|/* 	 * Reject this pack if it has windows and the previously selected 	 * one does not.  If this pack does not have windows, reject 	 * it if the pack file is newer than the previously selected one. 	 */
if|if
condition|(
operator|*
name|lru_p
operator|&&
operator|!
operator|*
name|mru_w
operator|&&
operator|(
name|p
operator|->
name|windows
operator|||
name|p
operator|->
name|mtime
operator|>
operator|(
operator|*
name|lru_p
operator|)
operator|->
name|mtime
operator|)
condition|)
return|return;
for|for
control|(
name|w
operator|=
name|this_mru_w
operator|=
name|p
operator|->
name|windows
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|next
control|)
block|{
comment|/* 		 * Reject this pack if any of its windows are in use, 		 * but the previously selected pack did not have any 		 * inuse windows.  Otherwise, record that this pack 		 * has windows in use. 		 */
if|if
condition|(
name|w
operator|->
name|inuse_cnt
condition|)
block|{
if|if
condition|(
operator|*
name|accept_windows_inuse
condition|)
name|has_windows_inuse
operator|=
literal|1
expr_stmt|;
else|else
return|return;
block|}
if|if
condition|(
name|w
operator|->
name|last_used
operator|>
name|this_mru_w
operator|->
name|last_used
condition|)
name|this_mru_w
operator|=
name|w
expr_stmt|;
comment|/* 		 * Reject this pack if it has windows that have been 		 * used more recently than the previously selected pack. 		 * If the previously selected pack had windows inuse and 		 * we have not encountered a window in this pack that is 		 * inuse, skip this check since we prefer a pack with no 		 * inuse windows to one that has inuse windows. 		 */
if|if
condition|(
operator|*
name|mru_w
operator|&&
operator|*
name|accept_windows_inuse
operator|==
name|has_windows_inuse
operator|&&
name|this_mru_w
operator|->
name|last_used
operator|>
operator|(
operator|*
name|mru_w
operator|)
operator|->
name|last_used
condition|)
return|return;
block|}
comment|/* 	 * Select this pack. 	 */
operator|*
name|mru_w
operator|=
name|this_mru_w
expr_stmt|;
operator|*
name|lru_p
operator|=
name|p
expr_stmt|;
operator|*
name|accept_windows_inuse
operator|=
name|has_windows_inuse
expr_stmt|;
block|}
end_function
begin_function
DECL|function|close_one_pack
specifier|static
name|int
name|close_one_pack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|,
modifier|*
name|lru_p
init|=
name|NULL
decl_stmt|;
name|struct
name|pack_window
modifier|*
name|mru_w
init|=
name|NULL
decl_stmt|;
name|int
name|accept_windows_inuse
init|=
literal|1
decl_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|find_lru_pack
argument_list|(
name|p
argument_list|,
operator|&
name|lru_p
argument_list|,
operator|&
name|mru_w
argument_list|,
operator|&
name|accept_windows_inuse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lru_p
condition|)
block|{
name|close
argument_list|(
name|lru_p
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|pack_open_fds
operator|--
expr_stmt|;
name|lru_p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unuse_pack
name|void
name|unuse_pack
parameter_list|(
name|struct
name|pack_window
modifier|*
modifier|*
name|w_cursor
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w
init|=
operator|*
name|w_cursor
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|w
operator|->
name|inuse_cnt
operator|--
expr_stmt|;
operator|*
name|w_cursor
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|close_pack_index
name|void
name|close_pack_index
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|index_data
condition|)
block|{
name|munmap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
operator|->
name|index_data
argument_list|,
name|p
operator|->
name|index_size
argument_list|)
expr_stmt|;
name|p
operator|->
name|index_data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * This is used by git-repack in case a newly created pack happens to  * contain the same set of objects as an existing one.  In that case  * the resulting file might be different even if its name would be the  * same.  It is best to close any reference to the old pack before it is  * replaced on disk.  Of course no index pointers nor windows for given pack  * must subsist at this point.  If ever objects from this pack are requested  * again, the new version of the pack will be reinitialized through  * reprepare_packed_git().  */
end_comment
begin_function
DECL|function|free_pack_by_name
name|void
name|free_pack_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_name
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
init|=
operator|&
name|packed_git
decl_stmt|;
while|while
condition|(
operator|*
name|pp
condition|)
block|{
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pack_name
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|clear_delta_base_cache
argument_list|()
expr_stmt|;
name|close_pack_windows
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|pack_open_fds
operator|--
expr_stmt|;
block|}
name|close_pack_index
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|bad_object_sha1
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|last_found_pack
operator|==
name|p
condition|)
name|last_found_pack
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|get_max_fd_limit
specifier|static
name|unsigned
name|int
name|get_max_fd_limit
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
block|{
name|struct
name|rlimit
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|lim
argument_list|)
condition|)
return|return
name|lim
operator|.
name|rlim_cur
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_SC_OPEN_MAX
block|{
name|long
name|open_max
init|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|open_max
condition|)
return|return
name|open_max
return|;
comment|/* 		 * Otherwise, we got -1 for one of the two 		 * reasons: 		 * 		 * (1) sysconf() did not understand _SC_OPEN_MAX 		 *     and signaled an error with -1; or 		 * (2) sysconf() said there is no limit. 		 * 		 * We _could_ clear errno before calling sysconf() to 		 * tell these two cases apart and return a huge number 		 * in the latter case to let the caller cap it to a 		 * value that is not so selfish, but letting the 		 * fallback OPEN_MAX codepath take care of these cases 		 * is a lot simpler. 		 */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPEN_MAX
return|return
name|OPEN_MAX
return|;
else|#
directive|else
return|return
literal|1
return|;
comment|/* see the caller ;-) */
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*  * Do not call this directly as this leaks p->pack_fd on error return;  * call open_packed_git() instead.  */
end_comment
begin_function
DECL|function|open_packed_git_1
specifier|static
name|int
name|open_packed_git_1
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|pack_header
name|hdr
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|idx_sha1
decl_stmt|;
name|long
name|fd_flag
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|index_data
operator|&&
name|open_pack_index
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s index unavailable"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
if|if
condition|(
operator|!
name|pack_max_fds
condition|)
block|{
name|unsigned
name|int
name|max_fds
init|=
name|get_max_fd_limit
argument_list|()
decl_stmt|;
comment|/* Save 3 for stdin/stdout/stderr, 22 for work */
if|if
condition|(
literal|25
operator|<
name|max_fds
condition|)
name|pack_max_fds
operator|=
name|max_fds
operator|-
literal|25
expr_stmt|;
else|else
name|pack_max_fds
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|pack_max_fds
operator|<=
name|pack_open_fds
operator|&&
name|close_one_pack
argument_list|()
condition|)
empty_stmt|;
comment|/* nothing */
name|p
operator|->
name|pack_fd
operator|=
name|git_open_noatime
argument_list|(
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|pack_open_fds
operator|++
expr_stmt|;
comment|/* If we created the struct before we had the pack we lack size. */
if|if
condition|(
operator|!
name|p
operator|->
name|pack_size
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s not a regular file"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
name|p
operator|->
name|pack_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|pack_size
operator|!=
name|st
operator|.
name|st_size
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s size changed"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
comment|/* We leave these file descriptors open with sliding mmap; 	 * there is no point keeping them open across exec(), though. 	 */
name|fd_flag
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_flag
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"cannot determine file descriptor flags"
argument_list|)
return|;
name|fd_flag
operator||=
name|FD_CLOEXEC
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd_flag
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"cannot set FD_CLOEXEC"
argument_list|)
return|;
comment|/* Verify we recognize this pack file format. */
if|if
condition|(
name|read_in_full
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"file %s is far too short to be a packfile"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
if|if
condition|(
name|hdr
operator|.
name|hdr_signature
operator|!=
name|htonl
argument_list|(
name|PACK_SIGNATURE
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"file %s is not a GIT packfile"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
if|if
condition|(
operator|!
name|pack_version_ok
argument_list|(
name|hdr
operator|.
name|hdr_version
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s is version %"
name|PRIu32
literal|" and not"
literal|" supported (try upgrading GIT to a newer version)"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|.
name|hdr_version
argument_list|)
argument_list|)
return|;
comment|/* Verify the pack matches its index. */
if|if
condition|(
name|p
operator|->
name|num_objects
operator|!=
name|ntohl
argument_list|(
name|hdr
operator|.
name|hdr_entries
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s claims to have %"
name|PRIu32
literal|" objects"
literal|" while index indicates %"
name|PRIu32
literal|" objects"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|.
name|hdr_entries
argument_list|)
argument_list|,
name|p
operator|->
name|num_objects
argument_list|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|p
operator|->
name|pack_size
operator|-
sizeof|sizeof
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"end of packfile %s is unavailable"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
if|if
condition|(
name|read_in_full
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|sha1
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s signature is unavailable"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
name|idx_sha1
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|index_data
operator|)
operator|+
name|p
operator|->
name|index_size
operator|-
literal|40
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|idx_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s does not match index"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|open_packed_git
specifier|static
name|int
name|open_packed_git
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|open_packed_git_1
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|pack_open_fds
operator|--
expr_stmt|;
name|p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|in_window
specifier|static
name|int
name|in_window
parameter_list|(
name|struct
name|pack_window
modifier|*
name|win
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
comment|/* We must promise at least 20 bytes (one hash) after the 	 * offset is available from this window, otherwise the offset 	 * is not actually in this window and a different window (which 	 * has that one hash excess) must be used.  This is to support 	 * the object header and delta base parsing routines below. 	 */
name|off_t
name|win_off
init|=
name|win
operator|->
name|offset
decl_stmt|;
return|return
name|win_off
operator|<=
name|offset
operator|&&
operator|(
name|offset
operator|+
literal|20
operator|)
operator|<=
operator|(
name|win_off
operator|+
name|win
operator|->
name|len
operator|)
return|;
block|}
end_function
begin_function
DECL|function|use_pack
name|unsigned
name|char
modifier|*
name|use_pack
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_cursor
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|left
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|win
init|=
operator|*
name|w_cursor
decl_stmt|;
comment|/* Since packfiles end in a hash of their content and it's 	 * pointless to ask for an offset into the middle of that 	 * hash, and the in_window function above wouldn't match 	 * don't allow an offset too close to the end of the file. 	 */
if|if
condition|(
operator|!
name|p
operator|->
name|pack_size
operator|&&
name|p
operator|->
name|pack_fd
operator|==
operator|-
literal|1
operator|&&
name|open_packed_git
argument_list|(
name|p
argument_list|)
condition|)
name|die
argument_list|(
literal|"packfile %s cannot be accessed"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|(
name|p
operator|->
name|pack_size
operator|-
literal|20
operator|)
condition|)
name|die
argument_list|(
literal|"offset beyond end of packfile (truncated pack?)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
operator|||
operator|!
name|in_window
argument_list|(
name|win
argument_list|,
name|offset
argument_list|)
condition|)
block|{
if|if
condition|(
name|win
condition|)
name|win
operator|->
name|inuse_cnt
operator|--
expr_stmt|;
for|for
control|(
name|win
operator|=
name|p
operator|->
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
name|in_window
argument_list|(
name|win
argument_list|,
name|offset
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|size_t
name|window_align
init|=
name|packed_git_window_size
operator|/
literal|2
decl_stmt|;
name|off_t
name|len
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|==
operator|-
literal|1
operator|&&
name|open_packed_git
argument_list|(
name|p
argument_list|)
condition|)
name|die
argument_list|(
literal|"packfile %s cannot be accessed"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|win
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|win
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|->
name|offset
operator|=
operator|(
name|offset
operator|/
name|window_align
operator|)
operator|*
name|window_align
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|pack_size
operator|-
name|win
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|packed_git_window_size
condition|)
name|len
operator|=
name|packed_git_window_size
expr_stmt|;
name|win
operator|->
name|len
operator|=
operator|(
name|size_t
operator|)
name|len
expr_stmt|;
name|pack_mapped
operator|+=
name|win
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|packed_git_limit
operator|<
name|pack_mapped
operator|&&
name|unuse_one_window
argument_list|(
name|p
argument_list|)
condition|)
empty_stmt|;
comment|/* nothing */
name|win
operator|->
name|base
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|win
operator|->
name|len
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|p
operator|->
name|pack_fd
argument_list|,
name|win
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|->
name|base
operator|==
name|MAP_FAILED
condition|)
name|die
argument_list|(
literal|"packfile %s cannot be mapped: %s"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
operator|->
name|offset
operator|&&
name|win
operator|->
name|len
operator|==
name|p
operator|->
name|pack_size
operator|&&
operator|!
name|p
operator|->
name|do_not_close
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|pack_open_fds
operator|--
expr_stmt|;
name|p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|pack_mmap_calls
operator|++
expr_stmt|;
name|pack_open_windows
operator|++
expr_stmt|;
if|if
condition|(
name|pack_mapped
operator|>
name|peak_pack_mapped
condition|)
name|peak_pack_mapped
operator|=
name|pack_mapped
expr_stmt|;
if|if
condition|(
name|pack_open_windows
operator|>
name|peak_pack_open_windows
condition|)
name|peak_pack_open_windows
operator|=
name|pack_open_windows
expr_stmt|;
name|win
operator|->
name|next
operator|=
name|p
operator|->
name|windows
expr_stmt|;
name|p
operator|->
name|windows
operator|=
name|win
expr_stmt|;
block|}
block|}
if|if
condition|(
name|win
operator|!=
operator|*
name|w_cursor
condition|)
block|{
name|win
operator|->
name|last_used
operator|=
name|pack_used_ctr
operator|++
expr_stmt|;
name|win
operator|->
name|inuse_cnt
operator|++
expr_stmt|;
operator|*
name|w_cursor
operator|=
name|win
expr_stmt|;
block|}
name|offset
operator|-=
name|win
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
name|left
operator|=
name|win
operator|->
name|len
operator|-
name|xsize_t
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|win
operator|->
name|base
operator|+
name|offset
return|;
block|}
end_function
begin_function
DECL|function|alloc_packed_git
specifier|static
name|struct
name|packed_git
modifier|*
name|alloc_packed_git
parameter_list|(
name|int
name|extra
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|extra
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|try_to_free_pack_memory
specifier|static
name|void
name|try_to_free_pack_memory
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|release_pack_memory
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_packed_git
name|struct
name|packed_git
modifier|*
name|add_packed_git
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|path_len
parameter_list|,
name|int
name|local
parameter_list|)
block|{
specifier|static
name|int
name|have_set_try_to_free_routine
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
init|=
name|alloc_packed_git
argument_list|(
name|path_len
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|have_set_try_to_free_routine
condition|)
block|{
name|have_set_try_to_free_routine
operator|=
literal|1
expr_stmt|;
name|set_try_to_free_routine
argument_list|(
name|try_to_free_pack_memory
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure a corresponding .pack file exists and that 	 * the index looks sane. 	 */
name|path_len
operator|-=
name|strlen
argument_list|(
literal|".idx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_len
operator|<
literal|1
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
operator|+
name|path_len
argument_list|,
literal|".keep"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|F_OK
argument_list|)
condition|)
name|p
operator|->
name|pack_keep
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
operator|+
name|path_len
argument_list|,
literal|".pack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* ok, it looks sane as far as we can check without 	 * actually mapping the pack file. 	 */
name|p
operator|->
name|pack_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|pack_local
operator|=
name|local
expr_stmt|;
name|p
operator|->
name|mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|path_len
operator|<
literal|40
operator|||
name|get_sha1_hex
argument_list|(
name|path
operator|+
name|path_len
operator|-
literal|40
argument_list|,
name|p
operator|->
name|sha1
argument_list|)
condition|)
name|hashclr
argument_list|(
name|p
operator|->
name|sha1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|parse_pack_index
name|struct
name|packed_git
modifier|*
name|parse_pack_index
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|idx_path
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|sha1_pack_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
init|=
name|alloc_packed_git
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_packed_git_idx
argument_list|(
name|idx_path
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|install_packed_git
name|void
name|install_packed_git
parameter_list|(
name|struct
name|packed_git
modifier|*
name|pack
parameter_list|)
block|{
if|if
condition|(
name|pack
operator|->
name|pack_fd
operator|!=
operator|-
literal|1
condition|)
name|pack_open_fds
operator|++
expr_stmt|;
name|pack
operator|->
name|next
operator|=
name|packed_git
expr_stmt|;
name|packed_git
operator|=
name|pack
expr_stmt|;
block|}
end_function
begin_function_decl
DECL|variable|report_garbage
name|void
function_decl|(
modifier|*
name|report_garbage
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|report_helper
specifier|static
name|void
name|report_helper
parameter_list|(
specifier|const
name|struct
name|string_list
modifier|*
name|list
parameter_list|,
name|int
name|seen_bits
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
switch|switch
condition|(
name|seen_bits
condition|)
block|{
case|case
literal|0
case|:
name|msg
operator|=
literal|"no corresponding .idx nor .pack"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|msg
operator|=
literal|"no corresponding .idx"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|msg
operator|=
literal|"no corresponding .pack"
expr_stmt|;
break|break;
default|default:
return|return;
block|}
for|for
control|(
init|;
name|first
operator|<
name|last
condition|;
name|first
operator|++
control|)
name|report_garbage
argument_list|(
name|msg
argument_list|,
name|list
operator|->
name|items
index|[
name|first
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|report_pack_garbage
specifier|static
name|void
name|report_pack_garbage
parameter_list|(
name|struct
name|string_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|baselen
init|=
operator|-
literal|1
decl_stmt|,
name|first
init|=
literal|0
decl_stmt|,
name|seen_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|report_garbage
condition|)
return|return;
name|sort_string_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|list
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
decl_stmt|;
if|if
condition|(
name|baselen
operator|!=
operator|-
literal|1
operator|&&
name|strncmp
argument_list|(
name|path
argument_list|,
name|list
operator|->
name|items
index|[
name|first
index|]
operator|.
name|string
argument_list|,
name|baselen
argument_list|)
condition|)
block|{
name|report_helper
argument_list|(
name|list
argument_list|,
name|seen_bits
argument_list|,
name|first
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|baselen
operator|=
operator|-
literal|1
expr_stmt|;
name|seen_bits
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|baselen
operator|==
operator|-
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|dot
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dot
condition|)
block|{
name|report_garbage
argument_list|(
literal|"garbage found"
argument_list|,
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|baselen
operator|=
name|dot
operator|-
name|path
operator|+
literal|1
expr_stmt|;
name|first
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|path
operator|+
name|baselen
argument_list|,
literal|"pack"
argument_list|)
condition|)
name|seen_bits
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|path
operator|+
name|baselen
argument_list|,
literal|"idx"
argument_list|)
condition|)
name|seen_bits
operator||=
literal|2
expr_stmt|;
block|}
name|report_helper
argument_list|(
name|list
argument_list|,
name|seen_bits
argument_list|,
name|first
argument_list|,
name|list
operator|->
name|nr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_packed_git_one
specifier|static
name|void
name|prepare_packed_git_one
parameter_list|(
name|char
modifier|*
name|objdir
parameter_list|,
name|int
name|local
parameter_list|)
block|{
comment|/* Ensure that this buffer is large enough so that we can 	   append "/pack/" without clobbering the stack even if 	   strlen(objdir) were PATH_MAX.  */
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|struct
name|string_list
name|garbage
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/pack"
argument_list|,
name|objdir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|error
argument_list|(
literal|"unable to open object pack directory: %s: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|path
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|+
name|namelen
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|report_garbage
condition|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%.*s/%s"
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|path
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|report_garbage
argument_list|(
literal|"path too long"
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|is_dot_or_dotdot
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|strcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_extension
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".idx"
argument_list|)
condition|)
block|{
comment|/* Don't reopen a pack we already have. */
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|len
operator|+
name|namelen
operator|-
literal|4
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
comment|/* 			     * See if it really is a valid .idx file with 			     * corresponding .pack file that we can map. 			     */
operator|(
name|p
operator|=
name|add_packed_git
argument_list|(
name|path
argument_list|,
name|len
operator|+
name|namelen
argument_list|,
name|local
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|install_packed_git
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|report_garbage
condition|)
continue|continue;
if|if
condition|(
name|has_extension
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".idx"
argument_list|)
operator|||
name|has_extension
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".pack"
argument_list|)
operator|||
name|has_extension
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".keep"
argument_list|)
condition|)
name|string_list_append
argument_list|(
operator|&
name|garbage
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
name|report_garbage
argument_list|(
literal|"garbage found"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|report_pack_garbage
argument_list|(
operator|&
name|garbage
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|garbage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sort_pack
specifier|static
name|int
name|sort_pack
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
expr|struct
name|packed_git
operator|*
operator|*
operator|)
name|a_
operator|)
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
expr|struct
name|packed_git
operator|*
operator|*
operator|)
name|b_
operator|)
decl_stmt|;
name|int
name|st
decl_stmt|;
comment|/* 	 * Local packs tend to contain objects specific to our 	 * variant of the project than remote ones.  In addition, 	 * remote ones could be on a network mounted filesystem. 	 * Favor local ones for these reasons. 	 */
name|st
operator|=
name|a
operator|->
name|pack_local
operator|-
name|b
operator|->
name|pack_local
expr_stmt|;
if|if
condition|(
name|st
condition|)
return|return
operator|-
name|st
return|;
comment|/* 	 * Younger packs tend to contain more recent objects, 	 * and more recent objects tend to get accessed more 	 * often. 	 */
if|if
condition|(
name|a
operator|->
name|mtime
operator|<
name|b
operator|->
name|mtime
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|mtime
operator|==
name|b
operator|->
name|mtime
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|rearrange_packed_git
specifier|static
name|void
name|rearrange_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
modifier|*
name|ary
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|2
condition|)
return|return;
comment|/* prepare an array of packed_git for easier sorting */
name|ary
operator|=
name|xcalloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|packed_git
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|ary
index|[
name|n
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|qsort
argument_list|(
name|ary
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|packed_git
operator|*
argument_list|)
argument_list|,
name|sort_pack
argument_list|)
expr_stmt|;
comment|/* link them back again */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|ary
index|[
name|i
index|]
operator|->
name|next
operator|=
name|ary
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|ary
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|packed_git
operator|=
name|ary
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|ary
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|prepare_packed_git_run_once
specifier|static
name|int
name|prepare_packed_git_run_once
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|prepare_packed_git
name|void
name|prepare_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|prepare_packed_git_run_once
condition|)
return|return;
name|prepare_packed_git_one
argument_list|(
name|get_object_directory
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|alt
operator|->
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prepare_packed_git_one
argument_list|(
name|alt
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|->
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|rearrange_packed_git
argument_list|()
expr_stmt|;
name|prepare_packed_git_run_once
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reprepare_packed_git
name|void
name|reprepare_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|discard_revindex
argument_list|()
expr_stmt|;
name|prepare_packed_git_run_once
operator|=
literal|0
expr_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mark_bad_packed_object
specifier|static
name|void
name|mark_bad_packed_object
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|num_bad_objects
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|p
operator|->
name|bad_object_sha1
operator|+
literal|20
operator|*
name|i
argument_list|)
condition|)
return|return;
name|p
operator|->
name|bad_object_sha1
operator|=
name|xrealloc
argument_list|(
name|p
operator|->
name|bad_object_sha1
argument_list|,
literal|20
operator|*
operator|(
name|p
operator|->
name|num_bad_objects
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|bad_object_sha1
operator|+
literal|20
operator|*
name|p
operator|->
name|num_bad_objects
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|num_bad_objects
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|has_packed_and_bad
specifier|static
specifier|const
name|struct
name|packed_git
modifier|*
name|has_packed_and_bad
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|num_bad_objects
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|p
operator|->
name|bad_object_sha1
operator|+
literal|20
operator|*
name|i
argument_list|)
condition|)
return|return
name|p
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * With an in-core object data in "map", rehash it to make sure the  * object name actually matches "sha1" to detect object corruption.  * With "map" == NULL, try reading the object named with "sha1" using  * the streaming interface and rehash it to do the same.  */
end_comment
begin_function
DECL|function|check_sha1_signature
name|int
name|check_sha1_signature
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|void
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|char
name|real_sha1
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|object_type
name|obj_type
decl_stmt|;
name|struct
name|git_istream
modifier|*
name|st
decl_stmt|;
name|git_SHA_CTX
name|c
decl_stmt|;
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|hash_sha1_file
argument_list|(
name|map
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|real_sha1
argument_list|)
expr_stmt|;
return|return
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|real_sha1
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|st
operator|=
name|open_istream
argument_list|(
name|sha1
argument_list|,
operator|&
name|obj_type
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Generate the header */
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|typename
argument_list|(
name|obj_type
argument_list|)
argument_list|,
name|size
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Sha1.. */
name|git_SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|buf
index|[
literal|1024
operator|*
literal|16
index|]
decl_stmt|;
name|ssize_t
name|readlen
init|=
name|read_istream
argument_list|(
name|st
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|readlen
operator|<
literal|0
condition|)
block|{
name|close_istream
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|readlen
condition|)
break|break;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
argument_list|,
name|readlen
argument_list|)
expr_stmt|;
block|}
name|git_SHA1_Final
argument_list|(
name|real_sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|close_istream
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|real_sha1
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_open_noatime
specifier|static
name|int
name|git_open_noatime
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|int
name|sha1_file_open_flag
init|=
name|O_NOATIME
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
name|sha1_file_open_flag
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
name|fd
return|;
comment|/* Might the failure be due to O_NOATIME? */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|&&
name|sha1_file_open_flag
condition|)
block|{
name|sha1_file_open_flag
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function
begin_function
DECL|function|stat_sha1_file
specifier|static
name|int
name|stat_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|name
argument_list|,
name|st
argument_list|)
condition|)
return|return
literal|0
return|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|name
operator|=
name|alt
operator|->
name|name
expr_stmt|;
name|fill_sha1_path
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|alt
operator|->
name|base
argument_list|,
name|st
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|open_sha1_file
specifier|static
name|int
name|open_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
name|fd
operator|=
name|git_open_noatime
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
name|fd
return|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|name
operator|=
name|alt
operator|->
name|name
expr_stmt|;
name|fill_sha1_path
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|git_open_noatime
argument_list|(
name|alt
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
name|fd
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|map_sha1_file
name|void
modifier|*
name|map_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|void
modifier|*
name|map
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open_sha1_file
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
operator|*
name|size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|size
condition|)
block|{
comment|/* mmap() is forbidden on empty files */
name|error
argument_list|(
literal|"object file %s is empty"
argument_list|,
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|map
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
operator|*
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function
begin_function
DECL|function|unpack_object_header_buffer
name|unsigned
name|long
name|unpack_object_header_buffer
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|shift
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|c
decl_stmt|;
name|unsigned
name|long
name|used
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|buf
index|[
name|used
operator|++
index|]
expr_stmt|;
operator|*
name|type
operator|=
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|7
expr_stmt|;
name|size
operator|=
name|c
operator|&
literal|15
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|len
operator|<=
name|used
operator|||
name|bitsizeof
argument_list|(
name|long
argument_list|)
operator|<=
name|shift
condition|)
block|{
name|error
argument_list|(
literal|"bad object header"
argument_list|)
expr_stmt|;
name|size
operator|=
name|used
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|buf
index|[
name|used
operator|++
index|]
expr_stmt|;
name|size
operator|+=
operator|(
name|c
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
return|return
name|used
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_header
name|int
name|unpack_sha1_header
parameter_list|(
name|git_zstream
modifier|*
name|stream
parameter_list|,
name|unsigned
name|char
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|mapsize
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|bufsiz
parameter_list|)
block|{
comment|/* Get the data stream */
name|memset
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|next_in
operator|=
name|map
expr_stmt|;
name|stream
operator|->
name|avail_in
operator|=
name|mapsize
expr_stmt|;
name|stream
operator|->
name|next_out
operator|=
name|buffer
expr_stmt|;
name|stream
operator|->
name|avail_out
operator|=
name|bufsiz
expr_stmt|;
name|git_inflate_init
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|git_inflate
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_rest
specifier|static
name|void
modifier|*
name|unpack_sha1_rest
parameter_list|(
name|git_zstream
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|bytes
init|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|xmallocz
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
name|int
name|status
init|=
name|Z_OK
decl_stmt|;
name|n
operator|=
name|stream
operator|->
name|total_out
operator|-
name|bytes
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|size
condition|)
name|n
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
name|bytes
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
name|size
condition|)
block|{
comment|/* 		 * The above condition must be (bytes<= size), not 		 * (bytes< size).  In other words, even though we 		 * expect no more output and set avail_out to zero, 		 * the input zlib stream may have bytes that express 		 * "this concludes the stream", and we *do* want to 		 * eat that input. 		 * 		 * Otherwise we would not be able to test that we 		 * consumed all the input to reach the expected size; 		 * we also want to check that zlib tells us that all 		 * went well with status == Z_STREAM_END at the end. 		 */
name|stream
operator|->
name|next_out
operator|=
name|buf
operator|+
name|bytes
expr_stmt|;
name|stream
operator|->
name|avail_out
operator|=
name|size
operator|-
name|bytes
expr_stmt|;
while|while
condition|(
name|status
operator|==
name|Z_OK
condition|)
name|status
operator|=
name|git_inflate
argument_list|(
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|Z_STREAM_END
operator|&&
operator|!
name|stream
operator|->
name|avail_in
condition|)
block|{
name|git_inflate_end
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"corrupt loose object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stream
operator|->
name|avail_in
condition|)
name|error
argument_list|(
literal|"garbage at end of loose object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * We used to just use "sscanf()", but that's actually way  * too permissive for what we want to check. So do an anal  * object header parse by hand.  */
end_comment
begin_function
DECL|function|parse_sha1_header
name|int
name|parse_sha1_header
parameter_list|(
specifier|const
name|char
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|char
name|type
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* 	 * The type can be at most ten bytes (including the 	 * terminating '\0' that we add), and is followed by 	 * a space. 	 */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|hdr
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
break|break;
name|type
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|type
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The length must follow immediately, and be in canonical 	 * decimal format (ie "010" is not valid). 	 */
name|size
operator|=
operator|*
name|hdr
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|9
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|size
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|long
name|c
init|=
operator|*
name|hdr
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|9
condition|)
break|break;
name|hdr
operator|++
expr_stmt|;
name|size
operator|=
name|size
operator|*
literal|10
operator|+
name|c
expr_stmt|;
block|}
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
comment|/* 	 * The length must be followed by a zero byte 	 */
return|return
operator|*
name|hdr
condition|?
operator|-
literal|1
else|:
name|type_from_string
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_file
specifier|static
name|void
modifier|*
name|unpack_sha1_file
parameter_list|(
name|void
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|mapsize
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|git_zstream
name|stream
decl_stmt|;
name|char
name|hdr
index|[
literal|8192
index|]
decl_stmt|;
name|ret
operator|=
name|unpack_sha1_header
argument_list|(
operator|&
name|stream
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|Z_OK
operator|||
operator|(
operator|*
name|type
operator|=
name|parse_sha1_header
argument_list|(
name|hdr
argument_list|,
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|unpack_sha1_rest
argument_list|(
operator|&
name|stream
argument_list|,
name|hdr
argument_list|,
operator|*
name|size
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_size_from_delta
name|unsigned
name|long
name|get_size_from_delta
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
name|curpos
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
name|delta_head
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|git_zstream
name|stream
decl_stmt|;
name|int
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|delta_head
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
expr_stmt|;
name|git_inflate_init
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
do|do
block|{
name|in
operator|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
name|curpos
argument_list|,
operator|&
name|stream
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|st
operator|=
name|git_inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
name|curpos
operator|+=
name|stream
operator|.
name|next_in
operator|-
name|in
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|st
operator|==
name|Z_OK
operator|||
name|st
operator|==
name|Z_BUF_ERROR
operator|)
operator|&&
name|stream
operator|.
name|total_out
operator|<
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
condition|)
do|;
name|git_inflate_end
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|Z_STREAM_END
operator|)
operator|&&
name|stream
operator|.
name|total_out
operator|!=
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"delta data unpack-initial failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Examine the initial part of the delta to figure out 	 * the result size. 	 */
name|data
operator|=
name|delta_head
expr_stmt|;
comment|/* ignore base size */
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|,
name|delta_head
operator|+
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the result size */
return|return
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|,
name|delta_head
operator|+
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_delta_base
specifier|static
name|off_t
name|get_delta_base
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
modifier|*
name|curpos
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
name|off_t
name|delta_obj_offset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base_info
init|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|*
name|curpos
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|off_t
name|base_offset
decl_stmt|;
comment|/* use_pack() assured us we have [base_info, base_info + 20) 	 * as a range that we can look at without walking off the 	 * end of the mapped window.  Its actually the hash size 	 * that is assured.  An OFS_DELTA longer than the hash size 	 * is stupid, as then a REF_DELTA would be smaller to store. 	 */
if|if
condition|(
name|type
operator|==
name|OBJ_OFS_DELTA
condition|)
block|{
name|unsigned
name|used
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
init|=
name|base_info
index|[
name|used
operator|++
index|]
decl_stmt|;
name|base_offset
operator|=
name|c
operator|&
literal|127
expr_stmt|;
while|while
condition|(
name|c
operator|&
literal|128
condition|)
block|{
name|base_offset
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|base_offset
operator|||
name|MSB
argument_list|(
name|base_offset
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* overflow */
name|c
operator|=
name|base_info
index|[
name|used
operator|++
index|]
expr_stmt|;
name|base_offset
operator|=
operator|(
name|base_offset
operator|<<
literal|7
operator|)
operator|+
operator|(
name|c
operator|&
literal|127
operator|)
expr_stmt|;
block|}
name|base_offset
operator|=
name|delta_obj_offset
operator|-
name|base_offset
expr_stmt|;
if|if
condition|(
name|base_offset
operator|<=
literal|0
operator|||
name|base_offset
operator|>=
name|delta_obj_offset
condition|)
return|return
literal|0
return|;
comment|/* out of bound */
operator|*
name|curpos
operator|+=
name|used
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OBJ_REF_DELTA
condition|)
block|{
comment|/* The base entry _must_ be in the same pack */
name|base_offset
operator|=
name|find_pack_entry_one
argument_list|(
name|base_info
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|curpos
operator|+=
literal|20
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"I am totally screwed"
argument_list|)
expr_stmt|;
return|return
name|base_offset
return|;
block|}
end_function
begin_function
DECL|function|unpack_object_header
name|int
name|unpack_object_header
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
modifier|*
name|curpos
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
name|unsigned
name|long
name|left
decl_stmt|;
name|unsigned
name|long
name|used
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
comment|/* use_pack() assures us we have [base, base + 20) available 	 * as a range that we can look at.  (Its actually the hash 	 * size that is assured.)  With our object header encoding 	 * the maximum deflated object size is 2^137, which is just 	 * insane, so we know won't exceed what we have been given. 	 */
name|base
operator|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|*
name|curpos
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|used
operator|=
name|unpack_object_header_buffer
argument_list|(
name|base
argument_list|,
name|left
argument_list|,
operator|&
name|type
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used
condition|)
block|{
name|type
operator|=
name|OBJ_BAD
expr_stmt|;
block|}
else|else
operator|*
name|curpos
operator|+=
name|used
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|retry_bad_packed_offset
specifier|static
name|int
name|retry_bad_packed_offset
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|struct
name|revindex_entry
modifier|*
name|revidx
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|revidx
operator|=
name|find_pack_revindex
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|revidx
condition|)
return|return
name|OBJ_BAD
return|;
name|sha1
operator|=
name|nth_packed_object_sha1
argument_list|(
name|p
argument_list|,
name|revidx
operator|->
name|nr
argument_list|)
expr_stmt|;
name|mark_bad_packed_object
argument_list|(
name|p
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|type
operator|=
name|sha1_object_info
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|OBJ_NONE
condition|)
return|return
name|OBJ_BAD
return|;
return|return
name|type
return|;
block|}
end_function
begin_define
DECL|macro|POI_STACK_PREALLOC
define|#
directive|define
name|POI_STACK_PREALLOC
value|64
end_define
begin_function
DECL|function|packed_to_object_type
specifier|static
name|enum
name|object_type
name|packed_to_object_type
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
name|curpos
parameter_list|)
block|{
name|off_t
name|small_poi_stack
index|[
name|POI_STACK_PREALLOC
index|]
decl_stmt|;
name|off_t
modifier|*
name|poi_stack
init|=
name|small_poi_stack
decl_stmt|;
name|int
name|poi_stack_nr
init|=
literal|0
decl_stmt|,
name|poi_stack_alloc
init|=
name|POI_STACK_PREALLOC
decl_stmt|;
while|while
condition|(
name|type
operator|==
name|OBJ_OFS_DELTA
operator|||
name|type
operator|==
name|OBJ_REF_DELTA
condition|)
block|{
name|off_t
name|base_offset
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* Push the object we're going to leave behind */
if|if
condition|(
name|poi_stack_nr
operator|>=
name|poi_stack_alloc
operator|&&
name|poi_stack
operator|==
name|small_poi_stack
condition|)
block|{
name|poi_stack_alloc
operator|=
name|alloc_nr
argument_list|(
name|poi_stack_nr
argument_list|)
expr_stmt|;
name|poi_stack
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|*
name|poi_stack_alloc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|poi_stack
argument_list|,
name|small_poi_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|*
name|poi_stack_nr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ALLOC_GROW
argument_list|(
name|poi_stack
argument_list|,
name|poi_stack_nr
operator|+
literal|1
argument_list|,
name|poi_stack_alloc
argument_list|)
expr_stmt|;
block|}
name|poi_stack
index|[
name|poi_stack_nr
operator|++
index|]
operator|=
name|obj_offset
expr_stmt|;
comment|/* If parsing the base offset fails, just unwind */
name|base_offset
operator|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
name|type
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_offset
condition|)
goto|goto
name|unwind
goto|;
name|curpos
operator|=
name|obj_offset
operator|=
name|base_offset
expr_stmt|;
name|type
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|OBJ_NONE
condition|)
block|{
comment|/* If getting the base itself fails, we first 			 * retry the base, otherwise unwind */
name|type
operator|=
name|retry_bad_packed_offset
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>
name|OBJ_NONE
condition|)
goto|goto
name|out
goto|;
goto|goto
name|unwind
goto|;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OBJ_BAD
case|:
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"unknown object type %i at offset %"
name|PRIuMAX
literal|" in %s"
argument_list|,
name|type
argument_list|,
operator|(
name|uintmax_t
operator|)
name|obj_offset
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|type
operator|=
name|OBJ_BAD
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|poi_stack
operator|!=
name|small_poi_stack
condition|)
name|free
argument_list|(
name|poi_stack
argument_list|)
expr_stmt|;
return|return
name|type
return|;
name|unwind
label|:
while|while
condition|(
name|poi_stack_nr
condition|)
block|{
name|obj_offset
operator|=
name|poi_stack
index|[
operator|--
name|poi_stack_nr
index|]
expr_stmt|;
name|type
operator|=
name|retry_bad_packed_offset
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>
name|OBJ_NONE
condition|)
goto|goto
name|out
goto|;
block|}
name|type
operator|=
name|OBJ_BAD
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_function
begin_function
DECL|function|packed_object_info
specifier|static
name|int
name|packed_object_info
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|struct
name|object_info
modifier|*
name|oi
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w_curs
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|off_t
name|curpos
init|=
name|obj_offset
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
comment|/* 	 * We always get the representation type, but only convert it to 	 * a "real" type later if the caller is interested. 	 */
name|type
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|oi
operator|->
name|sizep
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OBJ_OFS_DELTA
operator|||
name|type
operator|==
name|OBJ_REF_DELTA
condition|)
block|{
name|off_t
name|tmp_pos
init|=
name|curpos
decl_stmt|;
name|off_t
name|base_offset
init|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|tmp_pos
argument_list|,
name|type
argument_list|,
name|obj_offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|base_offset
condition|)
block|{
name|type
operator|=
name|OBJ_BAD
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|oi
operator|->
name|sizep
operator|=
name|get_size_from_delta
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|tmp_pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|oi
operator|->
name|sizep
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|OBJ_BAD
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
operator|*
name|oi
operator|->
name|sizep
operator|=
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oi
operator|->
name|disk_sizep
condition|)
block|{
name|struct
name|revindex_entry
modifier|*
name|revidx
init|=
name|find_pack_revindex
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
decl_stmt|;
operator|*
name|oi
operator|->
name|disk_sizep
operator|=
name|revidx
index|[
literal|1
index|]
operator|.
name|offset
operator|-
name|obj_offset
expr_stmt|;
block|}
if|if
condition|(
name|oi
operator|->
name|typep
condition|)
block|{
operator|*
name|oi
operator|->
name|typep
operator|=
name|packed_to_object_type
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|,
name|type
argument_list|,
operator|&
name|w_curs
argument_list|,
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|oi
operator|->
name|typep
operator|<
literal|0
condition|)
block|{
name|type
operator|=
name|OBJ_BAD
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|unuse_pack
argument_list|(
operator|&
name|w_curs
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|unpack_compressed_entry
specifier|static
name|void
modifier|*
name|unpack_compressed_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
name|curpos
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|st
decl_stmt|;
name|git_zstream
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|buffer
operator|=
name|xmallocz
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|buffer
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
operator|+
literal|1
expr_stmt|;
name|git_inflate_init
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
do|do
block|{
name|in
operator|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
name|curpos
argument_list|,
operator|&
name|stream
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|st
operator|=
name|git_inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
operator|.
name|avail_out
condition|)
break|break;
comment|/* the payload is larger than it should be */
name|curpos
operator|+=
name|stream
operator|.
name|next_in
operator|-
name|in
expr_stmt|;
block|}
do|while
condition|(
name|st
operator|==
name|Z_OK
operator|||
name|st
operator|==
name|Z_BUF_ERROR
condition|)
do|;
name|git_inflate_end
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|Z_STREAM_END
operator|)
operator|||
name|stream
operator|.
name|total_out
operator|!=
name|size
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buffer
return|;
block|}
end_function
begin_define
DECL|macro|MAX_DELTA_CACHE
define|#
directive|define
name|MAX_DELTA_CACHE
value|(256)
end_define
begin_decl_stmt
DECL|variable|delta_base_cached
specifier|static
name|size_t
name|delta_base_cached
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|delta_base_cache_lru_list
specifier|static
struct|struct
name|delta_base_cache_lru_list
block|{
DECL|member|prev
name|struct
name|delta_base_cache_lru_list
modifier|*
name|prev
decl_stmt|;
DECL|member|next
name|struct
name|delta_base_cache_lru_list
modifier|*
name|next
decl_stmt|;
block|}
DECL|variable|delta_base_cache_lru
name|delta_base_cache_lru
init|=
block|{
operator|&
name|delta_base_cache_lru
block|,
operator|&
name|delta_base_cache_lru
block|}
struct|;
end_struct
begin_struct
DECL|struct|delta_base_cache_entry
specifier|static
struct|struct
name|delta_base_cache_entry
block|{
DECL|member|lru
name|struct
name|delta_base_cache_lru_list
name|lru
decl_stmt|;
DECL|member|data
name|void
modifier|*
name|data
decl_stmt|;
DECL|member|p
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
DECL|member|base_offset
name|off_t
name|base_offset
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|size
decl_stmt|;
DECL|member|type
name|enum
name|object_type
name|type
decl_stmt|;
block|}
DECL|variable|delta_base_cache
name|delta_base_cache
index|[
name|MAX_DELTA_CACHE
index|]
struct|;
end_struct
begin_function
DECL|function|pack_entry_hash
specifier|static
name|unsigned
name|long
name|pack_entry_hash
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|)
block|{
name|unsigned
name|long
name|hash
decl_stmt|;
name|hash
operator|=
operator|(
name|unsigned
name|long
operator|)
name|p
operator|+
operator|(
name|unsigned
name|long
operator|)
name|base_offset
expr_stmt|;
name|hash
operator|+=
operator|(
name|hash
operator|>>
literal|8
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
name|hash
operator|%
name|MAX_DELTA_CACHE
return|;
block|}
end_function
begin_function
specifier|static
name|struct
name|delta_base_cache_entry
modifier|*
DECL|function|get_delta_base_cache_entry
name|get_delta_base_cache_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|)
block|{
name|unsigned
name|long
name|hash
init|=
name|pack_entry_hash
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
decl_stmt|;
return|return
name|delta_base_cache
operator|+
name|hash
return|;
block|}
end_function
begin_function
DECL|function|eq_delta_base_cache_entry
specifier|static
name|int
name|eq_delta_base_cache_entry
parameter_list|(
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|)
block|{
return|return
operator|(
name|ent
operator|->
name|data
operator|&&
name|ent
operator|->
name|p
operator|==
name|p
operator|&&
name|ent
operator|->
name|base_offset
operator|==
name|base_offset
operator|)
return|;
block|}
end_function
begin_function
DECL|function|in_delta_base_cache
specifier|static
name|int
name|in_delta_base_cache
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|)
block|{
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|get_delta_base_cache_entry
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
return|return
name|eq_delta_base_cache_entry
argument_list|(
name|ent
argument_list|,
name|p
argument_list|,
name|base_offset
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|clear_delta_base_cache_entry
specifier|static
name|void
name|clear_delta_base_cache_entry
parameter_list|(
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
parameter_list|)
block|{
name|ent
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|next
operator|->
name|prev
operator|=
name|ent
operator|->
name|lru
operator|.
name|prev
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|prev
operator|->
name|next
operator|=
name|ent
operator|->
name|lru
operator|.
name|next
expr_stmt|;
name|delta_base_cached
operator|-=
name|ent
operator|->
name|size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cache_or_unpack_entry
specifier|static
name|void
modifier|*
name|cache_or_unpack_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|base_size
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|int
name|keep_cache
parameter_list|)
block|{
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|ent
operator|=
name|get_delta_base_cache_entry
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eq_delta_base_cache_entry
argument_list|(
name|ent
argument_list|,
name|p
argument_list|,
name|base_offset
argument_list|)
condition|)
return|return
name|unpack_entry
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|,
name|type
argument_list|,
name|base_size
argument_list|)
return|;
name|ret
operator|=
name|ent
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|keep_cache
condition|)
name|clear_delta_base_cache_entry
argument_list|(
name|ent
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|xmemdupz
argument_list|(
name|ent
operator|->
name|data
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|ent
operator|->
name|type
expr_stmt|;
operator|*
name|base_size
operator|=
name|ent
operator|->
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|release_delta_base_cache
specifier|static
specifier|inline
name|void
name|release_delta_base_cache
parameter_list|(
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|data
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|data
argument_list|)
expr_stmt|;
name|ent
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|next
operator|->
name|prev
operator|=
name|ent
operator|->
name|lru
operator|.
name|prev
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|prev
operator|->
name|next
operator|=
name|ent
operator|->
name|lru
operator|.
name|next
expr_stmt|;
name|delta_base_cached
operator|-=
name|ent
operator|->
name|size
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clear_delta_base_cache
name|void
name|clear_delta_base_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|MAX_DELTA_CACHE
condition|;
name|p
operator|++
control|)
name|release_delta_base_cache
argument_list|(
operator|&
name|delta_base_cache
index|[
name|p
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_delta_base_cache
specifier|static
name|void
name|add_delta_base_cache
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|unsigned
name|long
name|base_size
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|hash
init|=
name|pack_entry_hash
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
decl_stmt|;
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
init|=
name|delta_base_cache
operator|+
name|hash
decl_stmt|;
name|struct
name|delta_base_cache_lru_list
modifier|*
name|lru
decl_stmt|;
name|release_delta_base_cache
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|delta_base_cached
operator|+=
name|base_size
expr_stmt|;
for|for
control|(
name|lru
operator|=
name|delta_base_cache_lru
operator|.
name|next
init|;
name|delta_base_cached
operator|>
name|delta_base_cache_limit
operator|&&
name|lru
operator|!=
operator|&
name|delta_base_cache_lru
condition|;
name|lru
operator|=
name|lru
operator|->
name|next
control|)
block|{
name|struct
name|delta_base_cache_entry
modifier|*
name|f
init|=
operator|(
name|void
operator|*
operator|)
name|lru
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|type
operator|==
name|OBJ_BLOB
condition|)
name|release_delta_base_cache
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lru
operator|=
name|delta_base_cache_lru
operator|.
name|next
init|;
name|delta_base_cached
operator|>
name|delta_base_cache_limit
operator|&&
name|lru
operator|!=
operator|&
name|delta_base_cache_lru
condition|;
name|lru
operator|=
name|lru
operator|->
name|next
control|)
block|{
name|struct
name|delta_base_cache_entry
modifier|*
name|f
init|=
operator|(
name|void
operator|*
operator|)
name|lru
decl_stmt|;
name|release_delta_base_cache
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|ent
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|ent
operator|->
name|base_offset
operator|=
name|base_offset
expr_stmt|;
name|ent
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ent
operator|->
name|data
operator|=
name|base
expr_stmt|;
name|ent
operator|->
name|size
operator|=
name|base_size
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|next
operator|=
operator|&
name|delta_base_cache_lru
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|prev
operator|=
name|delta_base_cache_lru
operator|.
name|prev
expr_stmt|;
name|delta_base_cache_lru
operator|.
name|prev
operator|->
name|next
operator|=
operator|&
name|ent
operator|->
name|lru
expr_stmt|;
name|delta_base_cache_lru
operator|.
name|prev
operator|=
operator|&
name|ent
operator|->
name|lru
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
modifier|*
name|read_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|write_pack_access_log
specifier|static
name|void
name|write_pack_access_log
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|)
block|{
specifier|static
name|FILE
modifier|*
name|log_file
decl_stmt|;
if|if
condition|(
operator|!
name|log_pack_access
condition|)
name|log_pack_access
operator|=
name|getenv
argument_list|(
literal|"GIT_TRACE_PACK_ACCESS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_pack_access
condition|)
name|log_pack_access
operator|=
name|no_log_pack_access
expr_stmt|;
if|if
condition|(
name|log_pack_access
operator|==
name|no_log_pack_access
condition|)
return|return;
if|if
condition|(
operator|!
name|log_file
condition|)
block|{
name|log_file
operator|=
name|fopen
argument_list|(
name|log_pack_access
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_file
condition|)
block|{
name|error
argument_list|(
literal|"cannot open pack access log '%s' for writing: %s"
argument_list|,
name|log_pack_access
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|log_pack_access
operator|=
name|no_log_pack_access
expr_stmt|;
return|return;
block|}
block|}
name|fprintf
argument_list|(
name|log_file
argument_list|,
literal|"%s %"
name|PRIuMAX
literal|"\n"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|obj_offset
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|do_check_packed_object_crc
name|int
name|do_check_packed_object_crc
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|UNPACK_ENTRY_STACK_PREALLOC
define|#
directive|define
name|UNPACK_ENTRY_STACK_PREALLOC
value|64
end_define
begin_struct
DECL|struct|unpack_entry_stack_ent
struct|struct
name|unpack_entry_stack_ent
block|{
DECL|member|obj_offset
name|off_t
name|obj_offset
decl_stmt|;
DECL|member|curpos
name|off_t
name|curpos
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|size
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|unpack_entry
name|void
modifier|*
name|unpack_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|enum
name|object_type
modifier|*
name|final_type
parameter_list|,
name|unsigned
name|long
modifier|*
name|final_size
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w_curs
init|=
name|NULL
decl_stmt|;
name|off_t
name|curpos
init|=
name|obj_offset
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|struct
name|unpack_entry_stack_ent
name|small_delta_stack
index|[
name|UNPACK_ENTRY_STACK_PREALLOC
index|]
decl_stmt|;
name|struct
name|unpack_entry_stack_ent
modifier|*
name|delta_stack
init|=
name|small_delta_stack
decl_stmt|;
name|int
name|delta_stack_nr
init|=
literal|0
decl_stmt|,
name|delta_stack_alloc
init|=
name|UNPACK_ENTRY_STACK_PREALLOC
decl_stmt|;
name|int
name|base_from_cache
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|log_pack_access
operator|!=
name|no_log_pack_access
condition|)
name|write_pack_access_log
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
comment|/* PHASE 1: drill down to the innermost base object */
for|for
control|(
init|;
condition|;
control|)
block|{
name|off_t
name|base_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|get_delta_base_cache_entry
argument_list|(
name|p
argument_list|,
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq_delta_base_cache_entry
argument_list|(
name|ent
argument_list|,
name|p
argument_list|,
name|curpos
argument_list|)
condition|)
block|{
name|type
operator|=
name|ent
operator|->
name|type
expr_stmt|;
name|data
operator|=
name|ent
operator|->
name|data
expr_stmt|;
name|size
operator|=
name|ent
operator|->
name|size
expr_stmt|;
name|clear_delta_base_cache_entry
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|base_from_cache
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|do_check_packed_object_crc
operator|&&
name|p
operator|->
name|index_version
operator|>
literal|1
condition|)
block|{
name|struct
name|revindex_entry
modifier|*
name|revidx
init|=
name|find_pack_revindex
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|len
init|=
name|revidx
index|[
literal|1
index|]
operator|.
name|offset
operator|-
name|obj_offset
decl_stmt|;
if|if
condition|(
name|check_pack_crc
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|obj_offset
argument_list|,
name|len
argument_list|,
name|revidx
operator|->
name|nr
argument_list|)
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
init|=
name|nth_packed_object_sha1
argument_list|(
name|p
argument_list|,
name|revidx
operator|->
name|nr
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"bad packed object CRC for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|mark_bad_packed_object
argument_list|(
name|p
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|unuse_pack
argument_list|(
operator|&
name|w_curs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|type
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_OFS_DELTA
operator|&&
name|type
operator|!=
name|OBJ_REF_DELTA
condition|)
break|break;
name|base_offset
operator|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
name|type
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_offset
condition|)
block|{
name|error
argument_list|(
literal|"failed to validate delta base reference "
literal|"at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curpos
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
comment|/* bail to phase 2, in hopes of recovery */
name|data
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* push object, proceed to base */
if|if
condition|(
name|delta_stack_nr
operator|>=
name|delta_stack_alloc
operator|&&
name|delta_stack
operator|==
name|small_delta_stack
condition|)
block|{
name|delta_stack_alloc
operator|=
name|alloc_nr
argument_list|(
name|delta_stack_nr
argument_list|)
expr_stmt|;
name|delta_stack
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|delta_stack
argument_list|)
operator|*
name|delta_stack_alloc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|delta_stack
argument_list|,
name|small_delta_stack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|delta_stack
argument_list|)
operator|*
name|delta_stack_nr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ALLOC_GROW
argument_list|(
name|delta_stack
argument_list|,
name|delta_stack_nr
operator|+
literal|1
argument_list|,
name|delta_stack_alloc
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|delta_stack_nr
operator|++
expr_stmt|;
name|delta_stack
index|[
name|i
index|]
operator|.
name|obj_offset
operator|=
name|obj_offset
expr_stmt|;
name|delta_stack
index|[
name|i
index|]
operator|.
name|curpos
operator|=
name|curpos
expr_stmt|;
name|delta_stack
index|[
name|i
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|curpos
operator|=
name|obj_offset
operator|=
name|base_offset
expr_stmt|;
block|}
comment|/* PHASE 2: handle the base */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OBJ_OFS_DELTA
case|:
case|case
name|OBJ_REF_DELTA
case|:
if|if
condition|(
name|data
condition|)
name|die
argument_list|(
literal|"BUG in unpack_entry: left loop at a valid delta"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
if|if
condition|(
operator|!
name|base_from_cache
condition|)
name|data
operator|=
name|unpack_compressed_entry
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|curpos
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|data
operator|=
name|NULL
expr_stmt|;
name|error
argument_list|(
literal|"unknown object type %i at offset %"
name|PRIuMAX
literal|" in %s"
argument_list|,
name|type
argument_list|,
operator|(
name|uintmax_t
operator|)
name|obj_offset
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
block|}
comment|/* PHASE 3: apply deltas in order */
comment|/* invariants: 	 *   'data' holds the base data, or NULL if there was corruption 	 */
while|while
condition|(
name|delta_stack_nr
condition|)
block|{
name|void
modifier|*
name|delta_data
decl_stmt|;
name|void
modifier|*
name|base
init|=
name|data
decl_stmt|;
name|unsigned
name|long
name|delta_size
decl_stmt|,
name|base_size
init|=
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|add_delta_base_cache
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|,
name|base
argument_list|,
name|base_size
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
comment|/* 			 * We're probably in deep shit, but let's try to fetch 			 * the required base anyway from another pack or loose. 			 * This is costly but should happen only in the presence 			 * of a corrupted pack, and is better than failing outright. 			 */
name|struct
name|revindex_entry
modifier|*
name|revidx
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base_sha1
decl_stmt|;
name|revidx
operator|=
name|find_pack_revindex
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|revidx
condition|)
block|{
name|base_sha1
operator|=
name|nth_packed_object_sha1
argument_list|(
name|p
argument_list|,
name|revidx
operator|->
name|nr
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"failed to read delta base object %s"
literal|" at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|obj_offset
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|mark_bad_packed_object
argument_list|(
name|p
argument_list|,
name|base_sha1
argument_list|)
expr_stmt|;
name|base
operator|=
name|read_object
argument_list|(
name|base_sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|base_size
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
operator|--
name|delta_stack_nr
expr_stmt|;
name|obj_offset
operator|=
name|delta_stack
index|[
name|i
index|]
operator|.
name|obj_offset
expr_stmt|;
name|curpos
operator|=
name|delta_stack
index|[
name|i
index|]
operator|.
name|curpos
expr_stmt|;
name|delta_size
operator|=
name|delta_stack
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
continue|continue;
name|delta_data
operator|=
name|unpack_compressed_entry
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|curpos
argument_list|,
name|delta_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta_data
condition|)
block|{
name|error
argument_list|(
literal|"failed to unpack compressed delta "
literal|"at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curpos
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|data
operator|=
name|patch_delta
argument_list|(
name|base
argument_list|,
name|base_size
argument_list|,
name|delta_data
argument_list|,
name|delta_size
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * We could not apply the delta; warn the user, but keep going. 		 * Our failure will be noticed either in the next iteration of 		 * the loop, or if this is the final delta, in the caller when 		 * we return NULL. Those code paths will take care of making 		 * a more explicit warning and retrying with another copy of 		 * the object. 		 */
if|if
condition|(
operator|!
name|data
condition|)
name|error
argument_list|(
literal|"failed to apply delta"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|delta_data
argument_list|)
expr_stmt|;
block|}
operator|*
name|final_type
operator|=
name|type
expr_stmt|;
operator|*
name|final_size
operator|=
name|size
expr_stmt|;
name|unuse_pack
argument_list|(
operator|&
name|w_curs
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|nth_packed_object_sha1
specifier|const
name|unsigned
name|char
modifier|*
name|nth_packed_object_sha1
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|index
init|=
name|p
operator|->
name|index_data
decl_stmt|;
if|if
condition|(
operator|!
name|index
condition|)
block|{
if|if
condition|(
name|open_pack_index
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
name|index
operator|=
name|p
operator|->
name|index_data
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|p
operator|->
name|num_objects
condition|)
return|return
name|NULL
return|;
name|index
operator|+=
literal|4
operator|*
literal|256
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|index_version
operator|==
literal|1
condition|)
block|{
return|return
name|index
operator|+
literal|24
operator|*
name|n
operator|+
literal|4
return|;
block|}
else|else
block|{
name|index
operator|+=
literal|8
expr_stmt|;
return|return
name|index
operator|+
literal|20
operator|*
name|n
return|;
block|}
block|}
end_function
begin_function
DECL|function|nth_packed_object_offset
name|off_t
name|nth_packed_object_offset
parameter_list|(
specifier|const
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|index
init|=
name|p
operator|->
name|index_data
decl_stmt|;
name|index
operator|+=
literal|4
operator|*
literal|256
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|index_version
operator|==
literal|1
condition|)
block|{
return|return
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|24
operator|*
name|n
operator|)
operator|)
argument_list|)
return|;
block|}
else|else
block|{
name|uint32_t
name|off
decl_stmt|;
name|index
operator|+=
literal|8
operator|+
name|p
operator|->
name|num_objects
operator|*
operator|(
literal|20
operator|+
literal|4
operator|)
expr_stmt|;
name|off
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|4
operator|*
name|n
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|off
operator|&
literal|0x80000000
operator|)
condition|)
return|return
name|off
return|;
name|index
operator|+=
name|p
operator|->
name|num_objects
operator|*
literal|4
operator|+
operator|(
name|off
operator|&
literal|0x7fffffff
operator|)
operator|*
literal|8
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|0
operator|)
operator|)
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|4
operator|)
operator|)
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|find_pack_entry_one
name|off_t
name|find_pack_entry_one
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|level1_ofs
init|=
name|p
operator|->
name|index_data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|index
init|=
name|p
operator|->
name|index_data
decl_stmt|;
name|unsigned
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|stride
decl_stmt|;
specifier|static
name|int
name|use_lookup
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|debug_lookup
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|debug_lookup
operator|<
literal|0
condition|)
name|debug_lookup
operator|=
operator|!
operator|!
name|getenv
argument_list|(
literal|"GIT_DEBUG_LOOKUP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
condition|)
block|{
if|if
condition|(
name|open_pack_index
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|level1_ofs
operator|=
name|p
operator|->
name|index_data
expr_stmt|;
name|index
operator|=
name|p
operator|->
name|index_data
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|index_version
operator|>
literal|1
condition|)
block|{
name|level1_ofs
operator|+=
literal|2
expr_stmt|;
name|index
operator|+=
literal|8
expr_stmt|;
block|}
name|index
operator|+=
literal|4
operator|*
literal|256
expr_stmt|;
name|hi
operator|=
name|ntohl
argument_list|(
name|level1_ofs
index|[
operator|*
name|sha1
index|]
argument_list|)
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
operator|*
name|sha1
operator|==
literal|0x0
operator|)
condition|?
literal|0
else|:
name|ntohl
argument_list|(
name|level1_ofs
index|[
operator|*
name|sha1
operator|-
literal|1
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|index_version
operator|>
literal|1
condition|)
block|{
name|stride
operator|=
literal|20
expr_stmt|;
block|}
else|else
block|{
name|stride
operator|=
literal|24
expr_stmt|;
name|index
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|debug_lookup
condition|)
name|printf
argument_list|(
literal|"%02x%02x%02x... lo %u hi %u nr %"
name|PRIu32
literal|"\n"
argument_list|,
name|sha1
index|[
literal|0
index|]
argument_list|,
name|sha1
index|[
literal|1
index|]
argument_list|,
name|sha1
index|[
literal|2
index|]
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|p
operator|->
name|num_objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_lookup
operator|<
literal|0
condition|)
name|use_lookup
operator|=
operator|!
operator|!
name|getenv
argument_list|(
literal|"GIT_USE_LOOKUP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_lookup
condition|)
block|{
name|int
name|pos
init|=
name|sha1_entry_pos
argument_list|(
name|index
argument_list|,
name|stride
argument_list|,
literal|0
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|p
operator|->
name|num_objects
argument_list|,
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|nth_packed_object_offset
argument_list|(
name|p
argument_list|,
name|pos
argument_list|)
return|;
block|}
do|do
block|{
name|unsigned
name|mi
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|cmp
init|=
name|hashcmp
argument_list|(
name|index
operator|+
name|mi
operator|*
name|stride
argument_list|,
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug_lookup
condition|)
name|printf
argument_list|(
literal|"lo %u hi %u rg %u mi %u\n"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|hi
operator|-
name|lo
argument_list|,
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|nth_packed_object_offset
argument_list|(
name|p
argument_list|,
name|mi
argument_list|)
return|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|hi
operator|=
name|mi
expr_stmt|;
else|else
name|lo
operator|=
name|mi
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|lo
operator|<
name|hi
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_pack_valid
name|int
name|is_pack_valid
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
comment|/* An already open pack is known to be valid. */
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|!=
operator|-
literal|1
condition|)
return|return
literal|1
return|;
comment|/* If the pack has one window completely covering the 	 * file size, the pack is known to be valid even if 	 * the descriptor is not currently open. 	 */
if|if
condition|(
name|p
operator|->
name|windows
condition|)
block|{
name|struct
name|pack_window
modifier|*
name|w
init|=
name|p
operator|->
name|windows
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|->
name|offset
operator|&&
name|w
operator|->
name|len
operator|==
name|p
operator|->
name|pack_size
condition|)
return|return
literal|1
return|;
block|}
comment|/* Force the pack to open to prove its valid. */
return|return
operator|!
name|open_packed_git
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fill_pack_entry
specifier|static
name|int
name|fill_pack_entry
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|pack_entry
modifier|*
name|e
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|off_t
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|num_bad_objects
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|num_bad_objects
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|p
operator|->
name|bad_object_sha1
operator|+
literal|20
operator|*
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|offset
operator|=
name|find_pack_entry_one
argument_list|(
name|sha1
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
return|return
literal|0
return|;
comment|/* 	 * We are about to tell the caller where they can locate the 	 * requested object.  We better make sure the packfile is 	 * still here and can be accessed before supplying that 	 * answer, as it may have been deleted since the index was 	 * loaded! 	 */
if|if
condition|(
operator|!
name|is_pack_valid
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"packfile %s cannot be accessed"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|e
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|e
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|find_pack_entry
specifier|static
name|int
name|find_pack_entry
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|pack_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|packed_git
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|last_found_pack
operator|&&
name|fill_pack_entry
argument_list|(
name|sha1
argument_list|,
name|e
argument_list|,
name|last_found_pack
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|last_found_pack
operator|||
operator|!
name|fill_pack_entry
argument_list|(
name|sha1
argument_list|,
name|e
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
name|last_found_pack
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_sha1_pack
name|struct
name|packed_git
modifier|*
name|find_sha1_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|packed_git
modifier|*
name|packs
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|packs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|find_pack_entry_one
argument_list|(
name|sha1
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|p
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sha1_loose_object_info
specifier|static
name|int
name|sha1_loose_object_info
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|object_info
modifier|*
name|oi
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|unsigned
name|long
name|mapsize
decl_stmt|,
name|size
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|;
name|git_zstream
name|stream
decl_stmt|;
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 * If we don't care about type or size, then we don't 	 * need to look inside the object at all. Note that we 	 * do not optimize out the stat call, even if the 	 * caller doesn't care about the disk-size, since our 	 * return value implicitly indicates whether the 	 * object even exists. 	 */
if|if
condition|(
operator|!
name|oi
operator|->
name|typep
operator|&&
operator|!
name|oi
operator|->
name|sizep
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|oi
operator|->
name|disk_sizep
condition|)
operator|*
name|oi
operator|->
name|disk_sizep
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
name|map
operator|=
name|map_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|oi
operator|->
name|disk_sizep
condition|)
operator|*
name|oi
operator|->
name|disk_sizep
operator|=
name|mapsize
expr_stmt|;
if|if
condition|(
name|unpack_sha1_header
argument_list|(
operator|&
name|stream
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
name|error
argument_list|(
literal|"unable to unpack %s header"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|status
operator|=
name|parse_sha1_header
argument_list|(
name|hdr
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|status
operator|=
name|error
argument_list|(
literal|"unable to parse %s header"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oi
operator|->
name|sizep
condition|)
operator|*
name|oi
operator|->
name|sizep
operator|=
name|size
expr_stmt|;
name|git_inflate_end
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|oi
operator|->
name|typep
condition|)
operator|*
name|oi
operator|->
name|typep
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sha1_object_info_extended
name|int
name|sha1_object_info_extended
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|object_info
modifier|*
name|oi
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|struct
name|cached_object
modifier|*
name|co
decl_stmt|;
name|struct
name|pack_entry
name|e
decl_stmt|;
name|int
name|rtype
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|real
init|=
name|lookup_replace_object_extended
argument_list|(
name|sha1
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|co
operator|=
name|find_cached_object
argument_list|(
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
condition|)
block|{
if|if
condition|(
name|oi
operator|->
name|typep
condition|)
operator|*
operator|(
name|oi
operator|->
name|typep
operator|)
operator|=
name|co
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|oi
operator|->
name|sizep
condition|)
operator|*
operator|(
name|oi
operator|->
name|sizep
operator|)
operator|=
name|co
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|oi
operator|->
name|disk_sizep
condition|)
operator|*
operator|(
name|oi
operator|->
name|disk_sizep
operator|)
operator|=
literal|0
expr_stmt|;
name|oi
operator|->
name|whence
operator|=
name|OI_CACHED
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|real
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
comment|/* Most likely it's a loose object. */
if|if
condition|(
operator|!
name|sha1_loose_object_info
argument_list|(
name|real
argument_list|,
name|oi
argument_list|)
condition|)
block|{
name|oi
operator|->
name|whence
operator|=
name|OI_LOOSE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Not a loose object; someone else may have just packed it. */
name|reprepare_packed_git
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|real
argument_list|,
operator|&
name|e
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|rtype
operator|=
name|packed_object_info
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|e
operator|.
name|offset
argument_list|,
name|oi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|<
literal|0
condition|)
block|{
name|mark_bad_packed_object
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|real
argument_list|)
expr_stmt|;
return|return
name|sha1_object_info_extended
argument_list|(
name|real
argument_list|,
name|oi
argument_list|,
literal|0
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|in_delta_base_cache
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|e
operator|.
name|offset
argument_list|)
condition|)
block|{
name|oi
operator|->
name|whence
operator|=
name|OI_DBCACHED
expr_stmt|;
block|}
else|else
block|{
name|oi
operator|->
name|whence
operator|=
name|OI_PACKED
expr_stmt|;
name|oi
operator|->
name|u
operator|.
name|packed
operator|.
name|offset
operator|=
name|e
operator|.
name|offset
expr_stmt|;
name|oi
operator|->
name|u
operator|.
name|packed
operator|.
name|pack
operator|=
name|e
operator|.
name|p
expr_stmt|;
name|oi
operator|->
name|u
operator|.
name|packed
operator|.
name|is_delta
operator|=
operator|(
name|rtype
operator|==
name|OBJ_REF_DELTA
operator|||
name|rtype
operator|==
name|OBJ_OFS_DELTA
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* returns enum object_type or negative */
end_comment
begin_function
DECL|function|sha1_object_info
name|int
name|sha1_object_info
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|struct
name|object_info
name|oi
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|oi
operator|.
name|typep
operator|=
operator|&
name|type
expr_stmt|;
name|oi
operator|.
name|sizep
operator|=
name|sizep
expr_stmt|;
if|if
condition|(
name|sha1_object_info_extended
argument_list|(
name|sha1
argument_list|,
operator|&
name|oi
argument_list|,
name|LOOKUP_REPLACE_OBJECT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|read_packed_sha1
specifier|static
name|void
modifier|*
name|read_packed_sha1
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|)
condition|)
return|return
name|NULL
return|;
name|data
operator|=
name|cache_or_unpack_entry
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|e
operator|.
name|offset
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|/* 		 * We're probably in deep shit, but let's try to fetch 		 * the required object anyway from another pack or loose. 		 * This should happen only in the presence of a corrupted 		 * pack, and is better than failing outright. 		 */
name|error
argument_list|(
literal|"failed to read object %s at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|e
operator|.
name|offset
argument_list|,
name|e
operator|.
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|mark_bad_packed_object
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|data
operator|=
name|read_object
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|pretend_sha1_file
name|int
name|pretend_sha1_file
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|cached_object
modifier|*
name|co
decl_stmt|;
name|hash_sha1_file
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
operator|||
name|find_cached_object
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cached_object_alloc
operator|<=
name|cached_object_nr
condition|)
block|{
name|cached_object_alloc
operator|=
name|alloc_nr
argument_list|(
name|cached_object_alloc
argument_list|)
expr_stmt|;
name|cached_objects
operator|=
name|xrealloc
argument_list|(
name|cached_objects
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cached_objects
argument_list|)
operator|*
name|cached_object_alloc
argument_list|)
expr_stmt|;
block|}
name|co
operator|=
operator|&
name|cached_objects
index|[
name|cached_object_nr
operator|++
index|]
expr_stmt|;
name|co
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|co
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|co
operator|->
name|buf
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|co
operator|->
name|buf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|co
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_object
specifier|static
name|void
modifier|*
name|read_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|long
name|mapsize
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|struct
name|cached_object
modifier|*
name|co
decl_stmt|;
name|co
operator|=
name|find_cached_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
condition|)
block|{
operator|*
name|type
operator|=
name|co
operator|->
name|type
expr_stmt|;
operator|*
name|size
operator|=
name|co
operator|->
name|size
expr_stmt|;
return|return
name|xmemdupz
argument_list|(
name|co
operator|->
name|buf
argument_list|,
name|co
operator|->
name|size
argument_list|)
return|;
block|}
name|buf
operator|=
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
return|return
name|buf
return|;
name|map
operator|=
name|map_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|buf
operator|=
name|unpack_sha1_file
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|,
name|type
argument_list|,
name|size
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|reprepare_packed_git
argument_list|()
expr_stmt|;
return|return
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * This function dies on corrupt objects; the callers who want to  * deal with them should arrange to call read_object() and give error  * messages themselves.  */
end_comment
begin_function
DECL|function|read_sha1_file_extended
name|void
modifier|*
name|read_sha1_file_extended
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
name|unsigned
name|flag
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|repl
init|=
name|lookup_replace_object_extended
argument_list|(
name|sha1
argument_list|,
name|flag
argument_list|)
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|read_object
argument_list|(
name|repl
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
return|return
name|data
return|;
if|if
condition|(
name|errno
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|die_errno
argument_list|(
literal|"failed to read object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* die if we replaced an object with one that does not exist */
if|if
condition|(
name|repl
operator|!=
name|sha1
condition|)
name|die
argument_list|(
literal|"replacement %s not found for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|repl
argument_list|)
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_loose_object
argument_list|(
name|repl
argument_list|)
condition|)
block|{
name|path
operator|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"loose object %s (stored in %s) is corrupt"
argument_list|,
name|sha1_to_hex
argument_list|(
name|repl
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|has_packed_and_bad
argument_list|(
name|repl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|die
argument_list|(
literal|"packed object %s (stored in %s) is corrupt"
argument_list|,
name|sha1_to_hex
argument_list|(
name|repl
argument_list|)
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|read_object_with_reference
name|void
modifier|*
name|read_object_with_reference
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|required_type_name
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
name|unsigned
name|char
modifier|*
name|actual_sha1_return
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|,
name|required_type
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|isize
decl_stmt|;
name|unsigned
name|char
name|actual_sha1
index|[
literal|20
index|]
decl_stmt|;
name|required_type
operator|=
name|type_from_string
argument_list|(
name|required_type_name
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|actual_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ref_length
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|ref_type
init|=
name|NULL
decl_stmt|;
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|actual_sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|isize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|type
operator|==
name|required_type
condition|)
block|{
operator|*
name|size
operator|=
name|isize
expr_stmt|;
if|if
condition|(
name|actual_sha1_return
condition|)
name|hashcpy
argument_list|(
name|actual_sha1_return
argument_list|,
name|actual_sha1
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
comment|/* Handle references */
elseif|else
if|if
condition|(
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|ref_type
operator|=
literal|"tree "
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|OBJ_TAG
condition|)
name|ref_type
operator|=
literal|"object "
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ref_length
operator|=
name|strlen
argument_list|(
name|ref_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_length
operator|+
literal|40
operator|>
name|isize
operator|||
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|ref_type
argument_list|,
name|ref_length
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
name|ref_length
argument_list|,
name|actual_sha1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Now we have the ID of the referred-to object in 		 * actual_sha1.  Check again. */
block|}
block|}
end_function
begin_function
DECL|function|write_sha1_file_prepare
specifier|static
name|void
name|write_sha1_file_prepare
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|,
name|int
modifier|*
name|hdrlen
parameter_list|)
block|{
name|git_SHA_CTX
name|c
decl_stmt|;
comment|/* Generate the header */
operator|*
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|type
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Sha1.. */
name|git_SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|hdr
argument_list|,
operator|*
name|hdrlen
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|git_SHA1_Final
argument_list|(
name|sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Move the just written object into its final resting place.  * NEEDSWORK: this should be renamed to finalize_temp_file() as  * "moving" is only a part of what it does, when no patch between  * master to pu changes the call sites of this function.  */
end_comment
begin_function
DECL|function|move_temp_to_file
name|int
name|move_temp_to_file
parameter_list|(
specifier|const
name|char
modifier|*
name|tmpfile
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|object_creation_mode
operator|==
name|OBJECT_CREATION_USES_RENAMES
condition|)
goto|goto
name|try_rename
goto|;
elseif|else
if|if
condition|(
name|link
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
comment|/* 	 * Coda hack - coda doesn't like cross-directory links, 	 * so we fall back to a rename, which will mean that it 	 * won't be able to check collisions, but that's not a 	 * big deal. 	 * 	 * The same holds for FAT formatted media. 	 * 	 * When this succeeds, we just return.  We have nothing 	 * left to unlink. 	 */
if|if
condition|(
name|ret
operator|&&
name|ret
operator|!=
name|EEXIST
condition|)
block|{
name|try_rename
label|:
if|if
condition|(
operator|!
name|rename
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|errno
expr_stmt|;
block|}
name|unlink_or_warn
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|EEXIST
condition|)
block|{
return|return
name|error
argument_list|(
literal|"unable to write sha1 filename %s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|ret
argument_list|)
argument_list|)
return|;
block|}
comment|/* FIXME!!! Collision check here ? */
block|}
name|out
label|:
if|if
condition|(
name|adjust_shared_perm
argument_list|(
name|filename
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"unable to set permission to '%s'"
argument_list|,
name|filename
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_buffer
specifier|static
name|int
name|write_buffer
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"file write error (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|hash_sha1_file
name|int
name|hash_sha1_file
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|write_sha1_file_prepare
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|,
name|hdr
argument_list|,
operator|&
name|hdrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Finalize a file on disk, and close it. */
end_comment
begin_function
DECL|function|close_sha1_file
specifier|static
name|void
name|close_sha1_file
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|fsync_object_files
condition|)
name|fsync_or_die
argument_list|(
name|fd
argument_list|,
literal|"sha1 file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|die_errno
argument_list|(
literal|"error when closing sha1 file"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Size of directory component, including the ending '/' */
end_comment
begin_function
DECL|function|directory_size
specifier|static
specifier|inline
name|int
name|directory_size
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
return|return
name|s
operator|-
name|filename
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * This creates a temporary file in the same directory as the final  * 'filename'  *  * We want to avoid cross-directory filename renames, because those  * can have problems on various filesystems (FAT, NFS, Coda).  */
end_comment
begin_function
DECL|function|create_tmpfile
specifier|static
name|int
name|create_tmpfile
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsiz
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|dirlen
init|=
name|directory_size
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirlen
operator|+
literal|20
operator|>
name|bufsiz
condition|)
block|{
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|filename
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|dirlen
argument_list|,
literal|"tmp_obj_XXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|git_mkstemp_mode
argument_list|(
name|buffer
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|dirlen
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* Make sure the directory exists */
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|filename
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|buffer
index|[
name|dirlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|buffer
argument_list|,
literal|0777
argument_list|)
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|adjust_shared_perm
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Try again */
name|strcpy
argument_list|(
name|buffer
operator|+
name|dirlen
operator|-
literal|1
argument_list|,
literal|"/tmp_obj_XXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|git_mkstemp_mode
argument_list|(
name|buffer
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function
begin_function
DECL|function|write_loose_object
specifier|static
name|int
name|write_loose_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|,
name|int
name|hdrlen
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|time_t
name|mtime
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|char
name|compressed
index|[
literal|4096
index|]
decl_stmt|;
name|git_zstream
name|stream
decl_stmt|;
name|git_SHA_CTX
name|c
decl_stmt|;
name|unsigned
name|char
name|parano_sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
specifier|static
name|char
name|tmp_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|filename
operator|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|create_tmpfile
argument_list|(
name|tmp_file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_file
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
return|return
name|error
argument_list|(
literal|"insufficient permission for adding an object to repository database %s"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
literal|"unable to create temporary file: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
comment|/* Set it up */
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|git_deflate_init
argument_list|(
operator|&
name|stream
argument_list|,
name|zlib_compression_level
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|compressed
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
name|git_SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
comment|/* First header.. */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|hdrlen
expr_stmt|;
while|while
condition|(
name|git_deflate
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|)
operator|==
name|Z_OK
condition|)
empty_stmt|;
comment|/* nothing */
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* Then the data itself.. */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
do|do
block|{
name|unsigned
name|char
modifier|*
name|in0
init|=
name|stream
operator|.
name|next_in
decl_stmt|;
name|ret
operator|=
name|git_deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
name|git_SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|in0
argument_list|,
name|stream
operator|.
name|next_in
operator|-
name|in0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_buffer
argument_list|(
name|fd
argument_list|,
name|compressed
argument_list|,
name|stream
operator|.
name|next_out
operator|-
name|compressed
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to write sha1 file"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|compressed
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|Z_OK
condition|)
do|;
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
name|die
argument_list|(
literal|"unable to deflate new object %s (%d)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|git_deflate_end_gently
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|die
argument_list|(
literal|"deflateEnd on object %s failed (%d)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|git_SHA1_Final
argument_list|(
name|parano_sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|parano_sha1
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"confused by unstable object source data for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|close_sha1_file
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
condition|)
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|mtime
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|tmp_file
argument_list|,
operator|&
name|utb
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"failed utime() on %s: %s"
argument_list|,
name|tmp_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|move_temp_to_file
argument_list|(
name|tmp_file
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|write_sha1_file
name|int
name|write_sha1_file
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|returnsha1
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
comment|/* Normally if we have it in the pack then we do not bother writing 	 * it out into .git/objects/??/?{38} file. 	 */
name|write_sha1_file_prepare
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|,
name|hdr
argument_list|,
operator|&
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnsha1
condition|)
name|hashcpy
argument_list|(
name|returnsha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|write_loose_object
argument_list|(
name|sha1
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|force_object_loose
name|int
name|force_object_loose
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|time_t
name|mtime
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|has_loose_object
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
name|buf
operator|=
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|error
argument_list|(
literal|"cannot read sha1_file for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ret
operator|=
name|write_loose_object
argument_list|(
name|sha1
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|has_pack_index
name|int
name|has_pack_index
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|sha1_pack_index_name
argument_list|(
name|sha1
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|has_sha1_pack
name|int
name|has_sha1_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
return|return
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|has_sha1_file
name|int
name|has_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
if|if
condition|(
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|has_loose_object
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|1
return|;
name|reprepare_packed_git
argument_list|()
expr_stmt|;
return|return
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|check_tree
specifier|static
name|void
name|check_tree
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|tree_desc
name|desc
decl_stmt|;
name|struct
name|name_entry
name|entry
decl_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|desc
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tree_entry
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
comment|/* do nothing 		 * tree_entry() will die() on malformed entries */
empty_stmt|;
block|}
end_function
begin_function
DECL|function|check_commit
specifier|static
name|void
name|check_commit
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|commit
name|c
decl_stmt|;
name|memset
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit_buffer
argument_list|(
operator|&
name|c
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
condition|)
name|die
argument_list|(
literal|"corrupt commit"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_tag
specifier|static
name|void
name|check_tag
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|tag
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_tag_buffer
argument_list|(
operator|&
name|t
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
condition|)
name|die
argument_list|(
literal|"corrupt tag"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|index_mem
specifier|static
name|int
name|index_mem
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|re_allocated
init|=
literal|0
decl_stmt|;
name|int
name|write_object
init|=
name|flags
operator|&
name|HASH_WRITE_OBJECT
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|OBJ_BLOB
expr_stmt|;
comment|/* 	 * Convert blobs to git internal format 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|OBJ_BLOB
operator|)
operator|&&
name|path
condition|)
block|{
name|struct
name|strbuf
name|nbuf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|convert_to_git
argument_list|(
name|path
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|nbuf
argument_list|,
name|write_object
condition|?
name|safe_crlf
else|:
name|SAFE_CRLF_FALSE
argument_list|)
condition|)
block|{
name|buf
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|nbuf
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|re_allocated
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|HASH_FORMAT_CHECK
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OBJ_TREE
condition|)
name|check_tree
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|check_commit
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OBJ_TAG
condition|)
name|check_tag
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_object
condition|)
name|ret
operator|=
name|write_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|hash_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_allocated
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|index_pipe
specifier|static
name|int
name|index_pipe
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|struct
name|strbuf
name|sbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|sbuf
argument_list|,
name|fd
argument_list|,
literal|4096
argument_list|)
operator|>=
literal|0
condition|)
name|ret
operator|=
name|index_mem
argument_list|(
name|sha1
argument_list|,
name|sbuf
operator|.
name|buf
argument_list|,
name|sbuf
operator|.
name|len
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_define
DECL|macro|SMALL_FILE_SIZE
define|#
directive|define
name|SMALL_FILE_SIZE
value|(32*1024)
end_define
begin_function
DECL|function|index_core
specifier|static
name|int
name|index_core
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|ret
operator|=
name|index_mem
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|SMALL_FILE_SIZE
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
condition|)
name|ret
operator|=
name|index_mem
argument_list|(
name|sha1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|error
argument_list|(
literal|"short read %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|buf
init|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ret
operator|=
name|index_mem
argument_list|(
name|sha1
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * This creates one packfile per large blob unless bulk-checkin  * machinery is "plugged".  *  * This also bypasses the usual "convert-to-git" dance, and that is on  * purpose. We could write a streaming version of the converting  * functions and insert that before feeding the data to fast-import  * (or equivalent in-core API described above). However, that is  * somewhat complicated, as we do not know the size of the filter  * result, which we need to know beforehand when writing a git object.  * Since the primary motivation for trying to stream from the working  * tree file and to avoid mmaping it in core is to deal with large  * binary blobs, they generally do not want to get any conversion, and  * callers should avoid this code path when filters are requested.  */
end_comment
begin_function
DECL|function|index_stream
specifier|static
name|int
name|index_stream
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
return|return
name|index_bulk_checkin
argument_list|(
name|sha1
argument_list|,
name|fd
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|index_fd
name|int
name|index_fd
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|size
init|=
name|xsize_t
argument_list|(
name|st
operator|->
name|st_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
name|ret
operator|=
name|index_pipe
argument_list|(
name|sha1
argument_list|,
name|fd
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
name|big_file_threshold
operator|||
name|type
operator|!=
name|OBJ_BLOB
operator|||
operator|(
name|path
operator|&&
name|would_convert_to_git
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|ret
operator|=
name|index_core
argument_list|(
name|sha1
argument_list|,
name|fd
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|index_stream
argument_list|(
name|sha1
argument_list|,
name|fd
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|index_path
name|int
name|index_path
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
switch|switch
condition|(
name|st
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"open(\"%s\"): %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|index_fd
argument_list|(
name|sha1
argument_list|,
name|fd
argument_list|,
name|st
argument_list|,
name|OBJ_BLOB
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"%s: failed to insert into database"
argument_list|,
name|path
argument_list|)
return|;
break|break;
case|case
name|S_IFLNK
case|:
if|if
condition|(
name|strbuf_readlink
argument_list|(
operator|&
name|sb
argument_list|,
name|path
argument_list|,
name|st
operator|->
name|st_size
argument_list|)
condition|)
block|{
name|char
modifier|*
name|errstr
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
return|return
name|error
argument_list|(
literal|"readlink(\"%s\"): %s"
argument_list|,
name|path
argument_list|,
name|errstr
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HASH_WRITE_OBJECT
operator|)
condition|)
name|hash_sha1_file
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write_sha1_file
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"%s: failed to insert into database"
argument_list|,
name|path
argument_list|)
return|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
return|return
name|resolve_gitlink_ref
argument_list|(
name|path
argument_list|,
literal|"HEAD"
argument_list|,
name|sha1
argument_list|)
return|;
default|default:
return|return
name|error
argument_list|(
literal|"%s: unsupported file type"
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_pack_header
name|int
name|read_pack_header
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|pack_header
modifier|*
name|header
parameter_list|)
block|{
if|if
condition|(
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
condition|)
comment|/* "eof before pack header was fully read" */
return|return
name|PH_ERROR_EOF
return|;
if|if
condition|(
name|header
operator|->
name|hdr_signature
operator|!=
name|htonl
argument_list|(
name|PACK_SIGNATURE
argument_list|)
condition|)
comment|/* "protocol error (pack signature mismatch detected)" */
return|return
name|PH_ERROR_PACK_SIGNATURE
return|;
if|if
condition|(
operator|!
name|pack_version_ok
argument_list|(
name|header
operator|->
name|hdr_version
argument_list|)
condition|)
comment|/* "protocol error (pack version unsupported)" */
return|return
name|PH_ERROR_PROTOCOL
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|assert_sha1_type
name|void
name|assert_sha1_type
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|enum
name|object_type
name|expect
parameter_list|)
block|{
name|enum
name|object_type
name|type
init|=
name|sha1_object_info
argument_list|(
name|sha1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"%s is not a valid object"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|expect
condition|)
name|die
argument_list|(
literal|"%s is not a valid '%s' object"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|expect
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
