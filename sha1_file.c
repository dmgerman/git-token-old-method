begin_unit
begin_comment
comment|/*  * GIT - The information manager from hell  *  * Copyright (C) Linus Torvalds, 2005  *  * This handles basic git sha1 object files - packing, unpacking,  * creation etc.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"delta.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"pack-revindex.h"
end_include
begin_include
include|#
directive|include
file|"sha1-lookup.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|O_NOATIME
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__PPC__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|O_NOATIME
define|#
directive|define
name|O_NOATIME
value|01000000
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|O_NOATIME
define|#
directive|define
name|O_NOATIME
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|NO_C99_FORMAT
end_ifdef
begin_define
DECL|macro|SZ_FMT
define|#
directive|define
name|SZ_FMT
value|"lu"
end_define
begin_function
DECL|function|sz_fmt
specifier|static
name|unsigned
name|long
name|sz_fmt
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
return|return
operator|(
name|unsigned
name|long
operator|)
name|s
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|SZ_FMT
define|#
directive|define
name|SZ_FMT
value|"zu"
end_define
begin_function
DECL|function|sz_fmt
specifier|static
name|size_t
name|sz_fmt
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
return|return
name|s
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|null_sha1
specifier|const
name|unsigned
name|char
name|null_sha1
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|hexval_table
specifier|const
name|signed
name|char
name|hexval_table
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 00-07 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 08-0f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 10-17 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 18-1f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 20-27 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 28-2f */
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
comment|/* 30-37 */
literal|8
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 38-3f */
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
operator|-
literal|1
block|,
comment|/* 40-47 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 48-4f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 50-57 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 58-5f */
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
operator|-
literal|1
block|,
comment|/* 60-67 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 68-67 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 70-77 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 78-7f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 80-87 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 88-8f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 90-97 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 98-9f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* a0-a7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* a8-af */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* b0-b7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* b8-bf */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* c0-c7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* c8-cf */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* d0-d7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* d8-df */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* e0-e7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* e8-ef */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* f0-f7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* f8-ff */
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_sha1_hex
name|int
name|get_sha1_hex
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|(
name|hexval
argument_list|(
name|hex
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hexval
argument_list|(
name|hex
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|sha1
operator|++
operator|=
name|val
expr_stmt|;
name|hex
operator|+=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|safe_create_leading_directories
name|int
name|safe_create_leading_directories
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|pos
init|=
name|path
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|is_absolute_path
argument_list|(
name|path
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|pos
condition|)
block|{
name|pos
operator|=
name|strchr
argument_list|(
name|pos
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
operator|*
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* path exists */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|adjust_shared_perm
argument_list|(
name|path
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
operator|*
name|pos
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sha1_to_hex
name|char
modifier|*
name|sha1_to_hex
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|int
name|bufno
decl_stmt|;
specifier|static
name|char
name|hexbuffer
index|[
literal|4
index|]
index|[
literal|50
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|hexbuffer
index|[
literal|3
operator|&
operator|++
name|bufno
index|]
decl_stmt|,
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|*
name|sha1
operator|++
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function
begin_function
DECL|function|fill_sha1_path
specifier|static
name|void
name|fill_sha1_path
parameter_list|(
name|char
modifier|*
name|pathbuf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|unsigned
name|int
name|val
init|=
name|sha1
index|[
name|i
index|]
decl_stmt|;
name|char
modifier|*
name|pos
init|=
name|pathbuf
operator|+
name|i
operator|*
literal|2
operator|+
operator|(
name|i
operator|>
literal|0
operator|)
decl_stmt|;
operator|*
name|pos
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|pos
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * NOTE! This returns a statically allocated buffer, so you have to be  * careful about using it. Do an "xstrdup()" if you need to save the  * filename.  *  * Also note that this returns the location for creating.  Reading  * SHA1 file can happen from any alternate directory listed in the  * DB_ENVIRONMENT environment variable if it is not found in  * the primary object database.  */
end_comment
begin_function
DECL|function|sha1_file_name
name|char
modifier|*
name|sha1_file_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
specifier|const
name|char
modifier|*
name|sha1_file_directory
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|sha1_file_directory
argument_list|)
decl_stmt|;
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|60
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|base
argument_list|,
name|sha1_file_directory
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|base
operator|+
name|len
argument_list|,
literal|0
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|base
index|[
name|len
index|]
operator|=
literal|'/'
expr_stmt|;
name|base
index|[
name|len
operator|+
literal|3
index|]
operator|=
literal|'/'
expr_stmt|;
name|name
operator|=
name|base
operator|+
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|fill_sha1_path
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
end_function
begin_function
DECL|function|sha1_get_pack_name
specifier|static
name|char
modifier|*
name|sha1_get_pack_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|which
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|base
condition|)
block|{
specifier|const
name|char
modifier|*
name|sha1_file_directory
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|sha1_file_directory
argument_list|)
decl_stmt|;
operator|*
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|60
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|base
argument_list|,
literal|"%s/pack/pack-1234567890123456789012345678901234567890.%s"
argument_list|,
name|sha1_file_directory
argument_list|,
name|which
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
operator|*
name|base
operator|+
name|len
operator|+
literal|11
expr_stmt|;
block|}
name|buf
operator|=
operator|*
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|*
name|sha1
operator|++
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
return|return
operator|*
name|base
return|;
block|}
end_function
begin_function
DECL|function|sha1_pack_name
name|char
modifier|*
name|sha1_pack_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|;
return|return
name|sha1_get_pack_name
argument_list|(
name|sha1
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|base
argument_list|,
literal|"pack"
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sha1_pack_index_name
name|char
modifier|*
name|sha1_pack_index_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|;
return|return
name|sha1_get_pack_name
argument_list|(
name|sha1
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|base
argument_list|,
literal|"idx"
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|alt_odb_list
name|struct
name|alternate_object_database
modifier|*
name|alt_odb_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|alt_odb_tail
specifier|static
name|struct
name|alternate_object_database
modifier|*
modifier|*
name|alt_odb_tail
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|read_info_alternates
parameter_list|(
specifier|const
name|char
modifier|*
name|alternates
parameter_list|,
name|int
name|depth
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * Prepare alternate object database registry.  *  * The variable alt_odb_list points at the list of struct  * alternate_object_database.  The elements on this list come from  * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT  * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,  * whose contents is similar to that environment variable but can be  * LF separated.  Its base points at a statically allocated buffer that  * contains "/the/directory/corresponding/to/.git/objects/...", while  * its name points just after the slash at the end of ".git/objects/"  * in the example above, and has enough space to hold 40-byte hex  * SHA1, an extra slash for the first level indirection, and the  * terminating NUL.  */
end_comment
begin_function
DECL|function|link_alt_odb_entry
specifier|static
name|int
name|link_alt_odb_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|entry
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|objdir
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|ent
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
comment|/* 43 = 40-byte + 2 '/' + terminating NUL */
name|int
name|pfxlen
init|=
name|len
decl_stmt|;
name|int
name|entlen
init|=
name|pfxlen
operator|+
literal|43
decl_stmt|;
name|int
name|base_len
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|entry
argument_list|)
operator|&&
name|relative_base
condition|)
block|{
comment|/* Relative alt-odb */
if|if
condition|(
name|base_len
operator|<
literal|0
condition|)
name|base_len
operator|=
name|strlen
argument_list|(
name|relative_base
argument_list|)
operator|+
literal|1
expr_stmt|;
name|entlen
operator|+=
name|base_len
expr_stmt|;
name|pfxlen
operator|+=
name|base_len
expr_stmt|;
block|}
name|ent
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
operator|+
name|entlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|entry
argument_list|)
operator|&&
name|relative_base
condition|)
block|{
name|memcpy
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|relative_base
argument_list|,
name|base_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|base_len
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|ent
operator|->
name|base
operator|+
name|base_len
argument_list|,
name|entry
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|entry
argument_list|,
name|pfxlen
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
operator|=
name|ent
operator|->
name|base
operator|+
name|pfxlen
operator|+
literal|1
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
operator|+
literal|3
index|]
operator|=
literal|'/'
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
index|]
operator|=
name|ent
operator|->
name|base
index|[
name|entlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Detect cases where alternate disappeared */
if|if
condition|(
name|stat
argument_list|(
name|ent
operator|->
name|base
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"object directory %s does not exist; "
literal|"check .git/objects/info/alternates."
argument_list|,
name|ent
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Prevent the common mistake of listing the same 	 * thing twice, or object directory itself. 	 */
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|alt
operator|->
name|base
argument_list|,
name|pfxlen
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|objdir
argument_list|,
name|pfxlen
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* add the alternate entry */
operator|*
name|alt_odb_tail
operator|=
name|ent
expr_stmt|;
name|alt_odb_tail
operator|=
operator|&
operator|(
name|ent
operator|->
name|next
operator|)
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* recursively add alternates */
name|read_info_alternates
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
index|]
operator|=
literal|'/'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|link_alt_odb_entries
specifier|static
name|void
name|link_alt_odb_entries
parameter_list|(
specifier|const
name|char
modifier|*
name|alt
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|,
name|int
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|depth
operator|>
literal|5
condition|)
block|{
name|error
argument_list|(
literal|"%s: ignoring alternate object stores, nesting too deep."
argument_list|,
name|relative_base
argument_list|)
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|alt
expr_stmt|;
while|while
condition|(
name|last
operator|<
name|ep
condition|)
block|{
name|cp
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|!=
name|sep
condition|)
name|cp
operator|++
expr_stmt|;
name|last
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|!=
name|sep
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|cp
condition|)
block|{
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|last
argument_list|)
operator|&&
name|depth
condition|)
block|{
name|error
argument_list|(
literal|"%s: ignoring relative alternate object store %s"
argument_list|,
name|relative_base
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_alt_odb_entry
argument_list|(
name|last
argument_list|,
name|cp
operator|-
name|last
argument_list|,
name|relative_base
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|==
name|sep
condition|)
name|cp
operator|++
expr_stmt|;
name|last
operator|=
name|cp
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|read_info_alternates
specifier|static
name|void
name|read_info_alternates
parameter_list|(
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|char
modifier|*
name|map
decl_stmt|;
name|size_t
name|mapsz
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
name|alt_file_name
index|[]
init|=
literal|"info/alternates"
decl_stmt|;
comment|/* Given that relative_base is no longer than PATH_MAX, 	   ensure that "path" has enough space to append "/", the 	   file name, "info/alternates", and a trailing NUL.  */
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|1
operator|+
sizeof|sizeof
name|alt_file_name
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|relative_base
argument_list|,
name|alt_file_name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|(
name|st
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|mapsz
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|map
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|mapsz
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|link_alt_odb_entries
argument_list|(
name|map
argument_list|,
name|map
operator|+
name|mapsz
argument_list|,
literal|'\n'
argument_list|,
name|relative_base
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsz
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_to_alternates_file
name|void
name|add_to_alternates_file
parameter_list|(
specifier|const
name|char
modifier|*
name|reference
parameter_list|)
block|{
name|struct
name|lock_file
modifier|*
name|lock
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_file
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|hold_lock_file_for_append
argument_list|(
name|lock
argument_list|,
name|git_path
argument_list|(
literal|"objects/info/alternates"
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|alt
init|=
name|mkpath
argument_list|(
literal|"%s/objects\n"
argument_list|,
name|reference
argument_list|)
decl_stmt|;
name|write_or_die
argument_list|(
name|fd
argument_list|,
name|alt
argument_list|,
name|strlen
argument_list|(
name|alt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_lock_file
argument_list|(
name|lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not close alternates file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_odb_tail
condition|)
name|link_alt_odb_entries
argument_list|(
name|alt
argument_list|,
name|alt
operator|+
name|strlen
argument_list|(
name|alt
argument_list|)
argument_list|,
literal|'\n'
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_alt_odb
name|void
name|prepare_alt_odb
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|alt_odb_tail
condition|)
return|return;
name|alt
operator|=
name|getenv
argument_list|(
name|ALTERNATE_DB_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt
condition|)
name|alt
operator|=
literal|""
expr_stmt|;
name|alt_odb_tail
operator|=
operator|&
name|alt_odb_list
expr_stmt|;
name|link_alt_odb_entries
argument_list|(
name|alt
argument_list|,
name|alt
operator|+
name|strlen
argument_list|(
name|alt
argument_list|)
argument_list|,
literal|':'
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_info_alternates
argument_list|(
name|get_object_directory
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|has_loose_object
specifier|static
name|int
name|has_loose_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|name
argument_list|,
name|F_OK
argument_list|)
condition|)
return|return
literal|1
return|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|name
operator|=
name|alt
operator|->
name|name
expr_stmt|;
name|fill_sha1_path
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|alt
operator|->
name|base
argument_list|,
name|F_OK
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|pack_used_ctr
specifier|static
name|unsigned
name|int
name|pack_used_ctr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_mmap_calls
specifier|static
name|unsigned
name|int
name|pack_mmap_calls
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|peak_pack_open_windows
specifier|static
name|unsigned
name|int
name|peak_pack_open_windows
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_open_windows
specifier|static
name|unsigned
name|int
name|pack_open_windows
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|peak_pack_mapped
specifier|static
name|size_t
name|peak_pack_mapped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_mapped
specifier|static
name|size_t
name|pack_mapped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|packed_git
name|struct
name|packed_git
modifier|*
name|packed_git
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|pack_report
name|void
name|pack_report
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pack_report: getpagesize()            = %10"
name|SZ_FMT
literal|"\n"
literal|"pack_report: core.packedGitWindowSize = %10"
name|SZ_FMT
literal|"\n"
literal|"pack_report: core.packedGitLimit      = %10"
name|SZ_FMT
literal|"\n"
argument_list|,
name|sz_fmt
argument_list|(
name|getpagesize
argument_list|()
argument_list|)
argument_list|,
name|sz_fmt
argument_list|(
name|packed_git_window_size
argument_list|)
argument_list|,
name|sz_fmt
argument_list|(
name|packed_git_limit
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pack_report: pack_used_ctr            = %10u\n"
literal|"pack_report: pack_mmap_calls          = %10u\n"
literal|"pack_report: pack_open_windows        = %10u / %10u\n"
literal|"pack_report: pack_mapped              = "
literal|"%10"
name|SZ_FMT
literal|" / %10"
name|SZ_FMT
literal|"\n"
argument_list|,
name|pack_used_ctr
argument_list|,
name|pack_mmap_calls
argument_list|,
name|pack_open_windows
argument_list|,
name|peak_pack_open_windows
argument_list|,
name|sz_fmt
argument_list|(
name|pack_mapped
argument_list|)
argument_list|,
name|sz_fmt
argument_list|(
name|peak_pack_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_packed_git_idx
specifier|static
name|int
name|check_packed_git_idx
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|void
modifier|*
name|idx_map
decl_stmt|;
name|struct
name|pack_idx_header
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|idx_size
decl_stmt|;
name|uint32_t
name|version
decl_stmt|,
name|nr
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|index
decl_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|idx_size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx_size
operator|<
literal|4
operator|*
literal|256
operator|+
literal|20
operator|+
literal|20
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"index file %s is too small"
argument_list|,
name|path
argument_list|)
return|;
block|}
name|idx_map
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|idx_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|idx_map
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|idx_signature
operator|==
name|htonl
argument_list|(
name|PACK_IDX_SIGNATURE
argument_list|)
condition|)
block|{
name|version
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|idx_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|<
literal|2
operator|||
name|version
operator|>
literal|2
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"index file %s is version %d"
literal|" and is not supported by this binary"
literal|" (try upgrading GIT to a newer version)"
argument_list|,
name|path
argument_list|,
name|version
argument_list|)
return|;
block|}
block|}
else|else
name|version
operator|=
literal|1
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|idx_map
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
condition|)
name|index
operator|+=
literal|2
expr_stmt|;
comment|/* skip index header */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|n
init|=
name|ntohl
argument_list|(
name|index
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|nr
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"non-monotonic index %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
name|nr
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Total size: 		 *  - 256 index entries 4 bytes each 		 *  - 24-byte entries * nr (20-byte sha1 + 4-byte offset) 		 *  - 20-byte SHA1 of the packfile 		 *  - 20-byte SHA1 file checksum 		 */
if|if
condition|(
name|idx_size
operator|!=
literal|4
operator|*
literal|256
operator|+
name|nr
operator|*
literal|24
operator|+
literal|20
operator|+
literal|20
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"wrong index v1 file size in %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|version
operator|==
literal|2
condition|)
block|{
comment|/* 		 * Minimum size: 		 *  - 8 bytes of header 		 *  - 256 index entries 4 bytes each 		 *  - 20-byte sha1 entry * nr 		 *  - 4-byte crc entry * nr 		 *  - 4-byte offset entry * nr 		 *  - 20-byte SHA1 of the packfile 		 *  - 20-byte SHA1 file checksum 		 * And after the 4-byte offset table might be a 		 * variable sized table containing 8-byte entries 		 * for offsets larger than 2^31. 		 */
name|unsigned
name|long
name|min_size
init|=
literal|8
operator|+
literal|4
operator|*
literal|256
operator|+
name|nr
operator|*
operator|(
literal|20
operator|+
literal|4
operator|+
literal|4
operator|)
operator|+
literal|20
operator|+
literal|20
decl_stmt|;
name|unsigned
name|long
name|max_size
init|=
name|min_size
decl_stmt|;
if|if
condition|(
name|nr
condition|)
name|max_size
operator|+=
operator|(
name|nr
operator|-
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|idx_size
operator|<
name|min_size
operator|||
name|idx_size
operator|>
name|max_size
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"wrong index v2 file size in %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
if|if
condition|(
name|idx_size
operator|!=
name|min_size
operator|&&
comment|/* 		     * make sure we can deal with large pack offsets. 		     * 31-bit signed offset won't be enough, neither 		     * 32-bit unsigned one will be. 		     */
operator|(
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|<=
literal|4
operator|)
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"pack too large for current definition of off_t in %s"
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
name|p
operator|->
name|index_version
operator|=
name|version
expr_stmt|;
name|p
operator|->
name|index_data
operator|=
name|idx_map
expr_stmt|;
name|p
operator|->
name|index_size
operator|=
name|idx_size
expr_stmt|;
name|p
operator|->
name|num_objects
operator|=
name|nr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|open_pack_index
name|int
name|open_pack_index
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|idx_name
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|index_data
condition|)
return|return
literal|0
return|;
name|idx_name
operator|=
name|xstrdup
argument_list|(
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|idx_name
operator|+
name|strlen
argument_list|(
name|idx_name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|".pack"
argument_list|)
argument_list|,
literal|".idx"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_packed_git_idx
argument_list|(
name|idx_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idx_name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|scan_windows
specifier|static
name|void
name|scan_windows
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|packed_git
modifier|*
modifier|*
name|lru_p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|lru_w
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|lru_l
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w
decl_stmt|,
modifier|*
name|w_l
decl_stmt|;
for|for
control|(
name|w_l
operator|=
name|NULL
operator|,
name|w
operator|=
name|p
operator|->
name|windows
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|inuse_cnt
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|lru_w
operator|||
name|w
operator|->
name|last_used
operator|<
operator|(
operator|*
name|lru_w
operator|)
operator|->
name|last_used
condition|)
block|{
operator|*
name|lru_p
operator|=
name|p
expr_stmt|;
operator|*
name|lru_w
operator|=
name|w
expr_stmt|;
operator|*
name|lru_l
operator|=
name|w_l
expr_stmt|;
block|}
block|}
name|w_l
operator|=
name|w
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|unuse_one_window
specifier|static
name|int
name|unuse_one_window
parameter_list|(
name|struct
name|packed_git
modifier|*
name|current
parameter_list|,
name|int
name|keep_fd
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|,
modifier|*
name|lru_p
init|=
name|NULL
decl_stmt|;
name|struct
name|pack_window
modifier|*
name|lru_w
init|=
name|NULL
decl_stmt|,
modifier|*
name|lru_l
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|current
condition|)
name|scan_windows
argument_list|(
name|current
argument_list|,
operator|&
name|lru_p
argument_list|,
operator|&
name|lru_w
argument_list|,
operator|&
name|lru_l
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|scan_windows
argument_list|(
name|p
argument_list|,
operator|&
name|lru_p
argument_list|,
operator|&
name|lru_w
argument_list|,
operator|&
name|lru_l
argument_list|)
expr_stmt|;
if|if
condition|(
name|lru_p
condition|)
block|{
name|munmap
argument_list|(
name|lru_w
operator|->
name|base
argument_list|,
name|lru_w
operator|->
name|len
argument_list|)
expr_stmt|;
name|pack_mapped
operator|-=
name|lru_w
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|lru_l
condition|)
name|lru_l
operator|->
name|next
operator|=
name|lru_w
operator|->
name|next
expr_stmt|;
else|else
block|{
name|lru_p
operator|->
name|windows
operator|=
name|lru_w
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|lru_p
operator|->
name|windows
operator|&&
name|lru_p
operator|->
name|pack_fd
operator|!=
name|keep_fd
condition|)
block|{
name|close
argument_list|(
name|lru_p
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|lru_p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|lru_w
argument_list|)
expr_stmt|;
name|pack_open_windows
operator|--
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|release_pack_memory
name|void
name|release_pack_memory
parameter_list|(
name|size_t
name|need
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|size_t
name|cur
init|=
name|pack_mapped
decl_stmt|;
while|while
condition|(
name|need
operator|>=
operator|(
name|cur
operator|-
name|pack_mapped
operator|)
operator|&&
name|unuse_one_window
argument_list|(
name|NULL
argument_list|,
name|fd
argument_list|)
condition|)
empty_stmt|;
comment|/* nothing */
block|}
end_function
begin_function
DECL|function|close_pack_windows
name|void
name|close_pack_windows
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|->
name|windows
condition|)
block|{
name|struct
name|pack_window
modifier|*
name|w
init|=
name|p
operator|->
name|windows
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|inuse_cnt
condition|)
name|die
argument_list|(
literal|"pack '%s' still has open windows to it"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|w
operator|->
name|base
argument_list|,
name|w
operator|->
name|len
argument_list|)
expr_stmt|;
name|pack_mapped
operator|-=
name|w
operator|->
name|len
expr_stmt|;
name|pack_open_windows
operator|--
expr_stmt|;
name|p
operator|->
name|windows
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|unuse_pack
name|void
name|unuse_pack
parameter_list|(
name|struct
name|pack_window
modifier|*
modifier|*
name|w_cursor
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w
init|=
operator|*
name|w_cursor
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|w
operator|->
name|inuse_cnt
operator|--
expr_stmt|;
operator|*
name|w_cursor
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Do not call this directly as this leaks p->pack_fd on error return;  * call open_packed_git() instead.  */
end_comment
begin_function
DECL|function|open_packed_git_1
specifier|static
name|int
name|open_packed_git_1
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|pack_header
name|hdr
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|idx_sha1
decl_stmt|;
name|long
name|fd_flag
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|index_data
operator|&&
name|open_pack_index
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s index unavailable"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
name|p
operator|->
name|pack_fd
operator|=
name|open
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we created the struct before we had the pack we lack size. */
if|if
condition|(
operator|!
name|p
operator|->
name|pack_size
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s not a regular file"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
name|p
operator|->
name|pack_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|pack_size
operator|!=
name|st
operator|.
name|st_size
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s size changed"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
comment|/* We leave these file descriptors open with sliding mmap; 	 * there is no point keeping them open across exec(), though. 	 */
name|fd_flag
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_flag
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"cannot determine file descriptor flags"
argument_list|)
return|;
name|fd_flag
operator||=
name|FD_CLOEXEC
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd_flag
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"cannot set FD_CLOEXEC"
argument_list|)
return|;
comment|/* Verify we recognize this pack file format. */
if|if
condition|(
name|read_in_full
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"file %s is far too short to be a packfile"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
if|if
condition|(
name|hdr
operator|.
name|hdr_signature
operator|!=
name|htonl
argument_list|(
name|PACK_SIGNATURE
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"file %s is not a GIT packfile"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
if|if
condition|(
operator|!
name|pack_version_ok
argument_list|(
name|hdr
operator|.
name|hdr_version
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s is version %u and not supported"
literal|" (try upgrading GIT to a newer version)"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|.
name|hdr_version
argument_list|)
argument_list|)
return|;
comment|/* Verify the pack matches its index. */
if|if
condition|(
name|p
operator|->
name|num_objects
operator|!=
name|ntohl
argument_list|(
name|hdr
operator|.
name|hdr_entries
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s claims to have %u objects"
literal|" while index indicates %u objects"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|.
name|hdr_entries
argument_list|)
argument_list|,
name|p
operator|->
name|num_objects
argument_list|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|p
operator|->
name|pack_size
operator|-
sizeof|sizeof
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"end of packfile %s is unavailable"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
if|if
condition|(
name|read_in_full
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|,
name|sha1
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s signature is unavailable"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
name|idx_sha1
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|index_data
operator|)
operator|+
name|p
operator|->
name|index_size
operator|-
literal|40
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|idx_sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"packfile %s does not match index"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|open_packed_git
specifier|static
name|int
name|open_packed_git
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|open_packed_git_1
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|pack_fd
argument_list|)
expr_stmt|;
name|p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|in_window
specifier|static
name|int
name|in_window
parameter_list|(
name|struct
name|pack_window
modifier|*
name|win
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
comment|/* We must promise at least 20 bytes (one hash) after the 	 * offset is available from this window, otherwise the offset 	 * is not actually in this window and a different window (which 	 * has that one hash excess) must be used.  This is to support 	 * the object header and delta base parsing routines below. 	 */
name|off_t
name|win_off
init|=
name|win
operator|->
name|offset
decl_stmt|;
return|return
name|win_off
operator|<=
name|offset
operator|&&
operator|(
name|offset
operator|+
literal|20
operator|)
operator|<=
operator|(
name|win_off
operator|+
name|win
operator|->
name|len
operator|)
return|;
block|}
end_function
begin_function
DECL|function|use_pack
name|unsigned
name|char
modifier|*
name|use_pack
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_cursor
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|unsigned
name|int
modifier|*
name|left
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|win
init|=
operator|*
name|w_cursor
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|==
operator|-
literal|1
operator|&&
name|open_packed_git
argument_list|(
name|p
argument_list|)
condition|)
name|die
argument_list|(
literal|"packfile %s cannot be accessed"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
comment|/* Since packfiles end in a hash of their content and its 	 * pointless to ask for an offset into the middle of that 	 * hash, and the in_window function above wouldn't match 	 * don't allow an offset too close to the end of the file. 	 */
if|if
condition|(
name|offset
operator|>
operator|(
name|p
operator|->
name|pack_size
operator|-
literal|20
operator|)
condition|)
name|die
argument_list|(
literal|"offset beyond end of packfile (truncated pack?)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
operator|||
operator|!
name|in_window
argument_list|(
name|win
argument_list|,
name|offset
argument_list|)
condition|)
block|{
if|if
condition|(
name|win
condition|)
name|win
operator|->
name|inuse_cnt
operator|--
expr_stmt|;
for|for
control|(
name|win
operator|=
name|p
operator|->
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
name|in_window
argument_list|(
name|win
argument_list|,
name|offset
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|size_t
name|window_align
init|=
name|packed_git_window_size
operator|/
literal|2
decl_stmt|;
name|off_t
name|len
decl_stmt|;
name|win
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|win
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|->
name|offset
operator|=
operator|(
name|offset
operator|/
name|window_align
operator|)
operator|*
name|window_align
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|pack_size
operator|-
name|win
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|packed_git_window_size
condition|)
name|len
operator|=
name|packed_git_window_size
expr_stmt|;
name|win
operator|->
name|len
operator|=
operator|(
name|size_t
operator|)
name|len
expr_stmt|;
name|pack_mapped
operator|+=
name|win
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|packed_git_limit
operator|<
name|pack_mapped
operator|&&
name|unuse_one_window
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|pack_fd
argument_list|)
condition|)
empty_stmt|;
comment|/* nothing */
name|win
operator|->
name|base
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|win
operator|->
name|len
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|p
operator|->
name|pack_fd
argument_list|,
name|win
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|->
name|base
operator|==
name|MAP_FAILED
condition|)
name|die
argument_list|(
literal|"packfile %s cannot be mapped: %s"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|pack_mmap_calls
operator|++
expr_stmt|;
name|pack_open_windows
operator|++
expr_stmt|;
if|if
condition|(
name|pack_mapped
operator|>
name|peak_pack_mapped
condition|)
name|peak_pack_mapped
operator|=
name|pack_mapped
expr_stmt|;
if|if
condition|(
name|pack_open_windows
operator|>
name|peak_pack_open_windows
condition|)
name|peak_pack_open_windows
operator|=
name|pack_open_windows
expr_stmt|;
name|win
operator|->
name|next
operator|=
name|p
operator|->
name|windows
expr_stmt|;
name|p
operator|->
name|windows
operator|=
name|win
expr_stmt|;
block|}
block|}
if|if
condition|(
name|win
operator|!=
operator|*
name|w_cursor
condition|)
block|{
name|win
operator|->
name|last_used
operator|=
name|pack_used_ctr
operator|++
expr_stmt|;
name|win
operator|->
name|inuse_cnt
operator|++
expr_stmt|;
operator|*
name|w_cursor
operator|=
name|win
expr_stmt|;
block|}
name|offset
operator|-=
name|win
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
name|left
operator|=
name|win
operator|->
name|len
operator|-
name|xsize_t
argument_list|(
name|offset
argument_list|)
expr_stmt|;
return|return
name|win
operator|->
name|base
operator|+
name|offset
return|;
block|}
end_function
begin_function
DECL|function|add_packed_git
name|struct
name|packed_git
modifier|*
name|add_packed_git
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|path_len
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|path_len
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|/* 	 * Make sure a corresponding .pack file exists and that 	 * the index looks sane. 	 */
name|path_len
operator|-=
name|strlen
argument_list|(
literal|".idx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_len
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
operator|+
name|path_len
argument_list|,
literal|".pack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* ok, it looks sane as far as we can check without 	 * actually mapping the pack file. 	 */
name|p
operator|->
name|index_version
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|index_data
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|index_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|num_objects
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|num_bad_objects
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|bad_object_sha1
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|pack_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|windows
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|pack_local
operator|=
name|local
expr_stmt|;
name|p
operator|->
name|mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|path_len
operator|<
literal|40
operator|||
name|get_sha1_hex
argument_list|(
name|path
operator|+
name|path_len
operator|-
literal|40
argument_list|,
name|p
operator|->
name|sha1
argument_list|)
condition|)
name|hashclr
argument_list|(
name|p
operator|->
name|sha1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|parse_pack_index
name|struct
name|packed_git
modifier|*
name|parse_pack_index
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|idx_path
init|=
name|sha1_pack_index_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|sha1_pack_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|check_packed_git_idx
argument_list|(
name|idx_path
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|p
operator|->
name|pack_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|windows
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|pack_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|install_packed_git
name|void
name|install_packed_git
parameter_list|(
name|struct
name|packed_git
modifier|*
name|pack
parameter_list|)
block|{
name|pack
operator|->
name|next
operator|=
name|packed_git
expr_stmt|;
name|packed_git
operator|=
name|pack
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_packed_git_one
specifier|static
name|void
name|prepare_packed_git_one
parameter_list|(
name|char
modifier|*
name|objdir
parameter_list|,
name|int
name|local
parameter_list|)
block|{
comment|/* Ensure that this buffer is large enough so that we can 	   append "/pack/" without clobbering the stack even if 	   strlen(objdir) were PATH_MAX.  */
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/pack"
argument_list|,
name|objdir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|error
argument_list|(
literal|"unable to open object pack directory: %s: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|path
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|has_extension
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".idx"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|len
operator|+
name|namelen
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|path
argument_list|)
condition|)
continue|continue;
comment|/* Don't reopen a pack we already have. */
name|strcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|len
operator|+
name|namelen
operator|-
literal|4
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|p
condition|)
continue|continue;
comment|/* See if it really is a valid .idx file with corresponding 		 * .pack file that we can map. 		 */
name|p
operator|=
name|add_packed_git
argument_list|(
name|path
argument_list|,
name|len
operator|+
name|namelen
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
name|install_packed_git
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sort_pack
specifier|static
name|int
name|sort_pack
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
expr|struct
name|packed_git
operator|*
operator|*
operator|)
name|a_
operator|)
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
expr|struct
name|packed_git
operator|*
operator|*
operator|)
name|b_
operator|)
decl_stmt|;
name|int
name|st
decl_stmt|;
comment|/* 	 * Local packs tend to contain objects specific to our 	 * variant of the project than remote ones.  In addition, 	 * remote ones could be on a network mounted filesystem. 	 * Favor local ones for these reasons. 	 */
name|st
operator|=
name|a
operator|->
name|pack_local
operator|-
name|b
operator|->
name|pack_local
expr_stmt|;
if|if
condition|(
name|st
condition|)
return|return
operator|-
name|st
return|;
comment|/* 	 * Younger packs tend to contain more recent objects, 	 * and more recent objects tend to get accessed more 	 * often. 	 */
if|if
condition|(
name|a
operator|->
name|mtime
operator|<
name|b
operator|->
name|mtime
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|mtime
operator|==
name|b
operator|->
name|mtime
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|rearrange_packed_git
specifier|static
name|void
name|rearrange_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
modifier|*
name|ary
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|2
condition|)
return|return;
comment|/* prepare an array of packed_git for easier sorting */
name|ary
operator|=
name|xcalloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|packed_git
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|ary
index|[
name|n
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|qsort
argument_list|(
name|ary
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|packed_git
operator|*
argument_list|)
argument_list|,
name|sort_pack
argument_list|)
expr_stmt|;
comment|/* link them back again */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|ary
index|[
name|i
index|]
operator|->
name|next
operator|=
name|ary
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|ary
index|[
name|n
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|packed_git
operator|=
name|ary
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|ary
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|prepare_packed_git_run_once
specifier|static
name|int
name|prepare_packed_git_run_once
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|prepare_packed_git
name|void
name|prepare_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|prepare_packed_git_run_once
condition|)
return|return;
name|prepare_packed_git_one
argument_list|(
name|get_object_directory
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|alt
operator|->
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prepare_packed_git_one
argument_list|(
name|alt
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|->
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|rearrange_packed_git
argument_list|()
expr_stmt|;
name|prepare_packed_git_run_once
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reprepare_packed_git
name|void
name|reprepare_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|prepare_packed_git_run_once
operator|=
literal|0
expr_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|mark_bad_packed_object
specifier|static
name|void
name|mark_bad_packed_object
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|num_bad_objects
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|p
operator|->
name|bad_object_sha1
operator|+
literal|20
operator|*
name|i
argument_list|)
condition|)
return|return;
name|p
operator|->
name|bad_object_sha1
operator|=
name|xrealloc
argument_list|(
name|p
operator|->
name|bad_object_sha1
argument_list|,
literal|20
operator|*
operator|(
name|p
operator|->
name|num_bad_objects
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|bad_object_sha1
operator|+
literal|20
operator|*
name|p
operator|->
name|num_bad_objects
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|num_bad_objects
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sha1_signature
name|int
name|check_sha1_signature
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|void
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|char
name|real_sha1
index|[
literal|20
index|]
decl_stmt|;
name|hash_sha1_file
argument_list|(
name|map
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|real_sha1
argument_list|)
expr_stmt|;
return|return
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|real_sha1
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|git_open_noatime
specifier|static
name|int
name|git_open_noatime
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|int
name|sha1_file_open_flag
init|=
name|O_NOATIME
decl_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
name|sha1_file_open_flag
argument_list|)
decl_stmt|;
comment|/* Might the failure be due to O_NOATIME? */
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
operator|&&
name|sha1_file_open_flag
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|sha1_file_open_flag
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function
begin_function
DECL|function|open_sha1_file
specifier|static
name|int
name|open_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
name|fd
operator|=
name|git_open_noatime
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
name|fd
return|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|name
operator|=
name|alt
operator|->
name|name
expr_stmt|;
name|fill_sha1_path
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|git_open_noatime
argument_list|(
name|alt
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
name|fd
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|map_sha1_file
specifier|static
name|void
modifier|*
name|map_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|void
modifier|*
name|map
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open_sha1_file
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
operator|*
name|size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|map
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
operator|*
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function
begin_function
DECL|function|legacy_loose_object
specifier|static
name|int
name|legacy_loose_object
parameter_list|(
name|unsigned
name|char
modifier|*
name|map
parameter_list|)
block|{
name|unsigned
name|int
name|word
decl_stmt|;
comment|/* 	 * Is it a zlib-compressed buffer? If so, the first byte 	 * must be 0x78 (15-bit window size, deflated), and the 	 * first 16-bit word is evenly divisible by 31 	 */
name|word
operator|=
operator|(
name|map
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|map
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|map
index|[
literal|0
index|]
operator|==
literal|0x78
operator|&&
operator|!
operator|(
name|word
operator|%
literal|31
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unpack_object_header_gently
name|unsigned
name|long
name|unpack_object_header_gently
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|shift
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|long
name|used
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|buf
index|[
name|used
operator|++
index|]
expr_stmt|;
operator|*
name|type
operator|=
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|7
expr_stmt|;
name|size
operator|=
name|c
operator|&
literal|15
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|len
operator|<=
name|used
condition|)
return|return
literal|0
return|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|<=
name|shift
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|buf
index|[
name|used
operator|++
index|]
expr_stmt|;
name|size
operator|+=
operator|(
name|c
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
return|return
name|used
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_header
specifier|static
name|int
name|unpack_sha1_header
parameter_list|(
name|z_stream
modifier|*
name|stream
parameter_list|,
name|unsigned
name|char
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|mapsize
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|bufsiz
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|used
decl_stmt|;
specifier|static
specifier|const
name|char
name|valid_loose_object_type
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
comment|/* OBJ_EXT */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* "commit", "tree", "blob", "tag" */
literal|0
block|,
comment|/* "delta" and others are invalid in a loose object */
block|}
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
comment|/* Get the data stream */
name|memset
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|next_in
operator|=
name|map
expr_stmt|;
name|stream
operator|->
name|avail_in
operator|=
name|mapsize
expr_stmt|;
name|stream
operator|->
name|next_out
operator|=
name|buffer
expr_stmt|;
name|stream
operator|->
name|avail_out
operator|=
name|bufsiz
expr_stmt|;
if|if
condition|(
name|legacy_loose_object
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|inflateInit
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|inflate
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* 	 * There used to be a second loose object header format which 	 * was meant to mimic the in-pack format, allowing for direct 	 * copy of the object data.  This format turned up not to be 	 * really worth it and we don't write it any longer.  But we 	 * can still read it. 	 */
name|used
operator|=
name|unpack_object_header_gently
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used
operator|||
operator|!
name|valid_loose_object_type
index|[
name|type
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|map
operator|+=
name|used
expr_stmt|;
name|mapsize
operator|-=
name|used
expr_stmt|;
comment|/* Set up the stream for the rest.. */
name|stream
operator|->
name|next_in
operator|=
name|map
expr_stmt|;
name|stream
operator|->
name|avail_in
operator|=
name|mapsize
expr_stmt|;
name|inflateInit
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* And generate the fake traditional header */
name|stream
operator|->
name|total_out
operator|=
literal|1
operator|+
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|bufsiz
argument_list|,
literal|"%s %lu"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_rest
specifier|static
name|void
modifier|*
name|unpack_sha1_rest
parameter_list|(
name|z_stream
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|bytes
init|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
name|int
name|status
init|=
name|Z_OK
decl_stmt|;
name|n
operator|=
name|stream
operator|->
name|total_out
operator|-
name|bytes
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|size
condition|)
name|n
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
name|bytes
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
name|size
condition|)
block|{
comment|/* 		 * The above condition must be (bytes<= size), not 		 * (bytes< size).  In other words, even though we 		 * expect no more output and set avail_out to zer0, 		 * the input zlib stream may have bytes that express 		 * "this concludes the stream", and we *do* want to 		 * eat that input. 		 * 		 * Otherwise we would not be able to test that we 		 * consumed all the input to reach the expected size; 		 * we also want to check that zlib tells us that all 		 * went well with status == Z_STREAM_END at the end. 		 */
name|stream
operator|->
name|next_out
operator|=
name|buf
operator|+
name|bytes
expr_stmt|;
name|stream
operator|->
name|avail_out
operator|=
name|size
operator|-
name|bytes
expr_stmt|;
while|while
condition|(
name|status
operator|==
name|Z_OK
condition|)
name|status
operator|=
name|inflate
argument_list|(
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|Z_STREAM_END
operator|&&
operator|!
name|stream
operator|->
name|avail_in
condition|)
block|{
name|inflateEnd
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"corrupt loose object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stream
operator|->
name|avail_in
condition|)
name|error
argument_list|(
literal|"garbage at end of loose object '%s'"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * We used to just use "sscanf()", but that's actually way  * too permissive for what we want to check. So do an anal  * object header parse by hand.  */
end_comment
begin_function
DECL|function|parse_sha1_header
specifier|static
name|int
name|parse_sha1_header
parameter_list|(
specifier|const
name|char
modifier|*
name|hdr
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|char
name|type
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* 	 * The type can be at most ten bytes (including the 	 * terminating '\0' that we add), and is followed by 	 * a space. 	 */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|hdr
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
break|break;
name|type
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|type
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The length must follow immediately, and be in canonical 	 * decimal format (ie "010" is not valid). 	 */
name|size
operator|=
operator|*
name|hdr
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|9
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|size
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|long
name|c
init|=
operator|*
name|hdr
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|9
condition|)
break|break;
name|hdr
operator|++
expr_stmt|;
name|size
operator|=
name|size
operator|*
literal|10
operator|+
name|c
expr_stmt|;
block|}
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
comment|/* 	 * The length must be followed by a zero byte 	 */
return|return
operator|*
name|hdr
condition|?
operator|-
literal|1
else|:
name|type_from_string
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_file
specifier|static
name|void
modifier|*
name|unpack_sha1_file
parameter_list|(
name|void
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|mapsize
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|char
name|hdr
index|[
literal|8192
index|]
decl_stmt|;
name|ret
operator|=
name|unpack_sha1_header
argument_list|(
operator|&
name|stream
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|Z_OK
operator|||
operator|(
operator|*
name|type
operator|=
name|parse_sha1_header
argument_list|(
name|hdr
argument_list|,
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|unpack_sha1_rest
argument_list|(
operator|&
name|stream
argument_list|,
name|hdr
argument_list|,
operator|*
name|size
argument_list|,
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_size_from_delta
name|unsigned
name|long
name|get_size_from_delta
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
name|curpos
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
name|delta_head
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|int
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|delta_head
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
do|do
block|{
name|in
operator|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
name|curpos
argument_list|,
operator|&
name|stream
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|st
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
name|curpos
operator|+=
name|stream
operator|.
name|next_in
operator|-
name|in
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|st
operator|==
name|Z_OK
operator|||
name|st
operator|==
name|Z_BUF_ERROR
operator|)
operator|&&
name|stream
operator|.
name|total_out
operator|<
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
condition|)
do|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|Z_STREAM_END
operator|)
operator|&&
name|stream
operator|.
name|total_out
operator|!=
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
condition|)
name|die
argument_list|(
literal|"delta data unpack-initial failed"
argument_list|)
expr_stmt|;
comment|/* Examine the initial part of the delta to figure out 	 * the result size. 	 */
name|data
operator|=
name|delta_head
expr_stmt|;
comment|/* ignore base size */
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|,
name|delta_head
operator|+
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the result size */
return|return
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|,
name|delta_head
operator|+
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_delta_base
specifier|static
name|off_t
name|get_delta_base
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
modifier|*
name|curpos
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
name|off_t
name|delta_obj_offset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base_info
init|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|*
name|curpos
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|off_t
name|base_offset
decl_stmt|;
comment|/* use_pack() assured us we have [base_info, base_info + 20) 	 * as a range that we can look at without walking off the 	 * end of the mapped window.  Its actually the hash size 	 * that is assured.  An OFS_DELTA longer than the hash size 	 * is stupid, as then a REF_DELTA would be smaller to store. 	 */
if|if
condition|(
name|type
operator|==
name|OBJ_OFS_DELTA
condition|)
block|{
name|unsigned
name|used
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
init|=
name|base_info
index|[
name|used
operator|++
index|]
decl_stmt|;
name|base_offset
operator|=
name|c
operator|&
literal|127
expr_stmt|;
while|while
condition|(
name|c
operator|&
literal|128
condition|)
block|{
name|base_offset
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|base_offset
operator|||
name|MSB
argument_list|(
name|base_offset
argument_list|,
literal|7
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* overflow */
name|c
operator|=
name|base_info
index|[
name|used
operator|++
index|]
expr_stmt|;
name|base_offset
operator|=
operator|(
name|base_offset
operator|<<
literal|7
operator|)
operator|+
operator|(
name|c
operator|&
literal|127
operator|)
expr_stmt|;
block|}
name|base_offset
operator|=
name|delta_obj_offset
operator|-
name|base_offset
expr_stmt|;
if|if
condition|(
name|base_offset
operator|>=
name|delta_obj_offset
condition|)
return|return
literal|0
return|;
comment|/* out of bound */
operator|*
name|curpos
operator|+=
name|used
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OBJ_REF_DELTA
condition|)
block|{
comment|/* The base entry _must_ be in the same pack */
name|base_offset
operator|=
name|find_pack_entry_one
argument_list|(
name|base_info
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|curpos
operator|+=
literal|20
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"I am totally screwed"
argument_list|)
expr_stmt|;
return|return
name|base_offset
return|;
block|}
end_function
begin_comment
comment|/* forward declaration for a mutually recursive function */
end_comment
begin_function_decl
specifier|static
name|int
name|packed_object_info
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|packed_delta_info
specifier|static
name|int
name|packed_delta_info
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
name|curpos
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|off_t
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
name|type
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
name|type
operator|=
name|packed_object_info
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We choose to only get the type of the base object and 	 * ignore potentially corrupt pack file that expects the delta 	 * based on a base with a wrong size.  This saves tons of 	 * inflate() calls. 	 */
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|get_size_from_delta
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
name|curpos
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|unpack_object_header
specifier|static
name|int
name|unpack_object_header
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
modifier|*
name|curpos
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
name|unsigned
name|int
name|left
decl_stmt|;
name|unsigned
name|long
name|used
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
comment|/* use_pack() assures us we have [base, base + 20) available 	 * as a range that we can look at at.  (Its actually the hash 	 * size that is assured.)  With our object header encoding 	 * the maximum deflated object size is 2^137, which is just 	 * insane, so we know won't exceed what we have been given. 	 */
name|base
operator|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|*
name|curpos
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|used
operator|=
name|unpack_object_header_gently
argument_list|(
name|base
argument_list|,
name|left
argument_list|,
operator|&
name|type
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used
condition|)
name|die
argument_list|(
literal|"object offset outside of pack file"
argument_list|)
expr_stmt|;
operator|*
name|curpos
operator|+=
name|used
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|packed_object_info_detail
specifier|const
name|char
modifier|*
name|packed_object_info_detail
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
name|unsigned
name|long
modifier|*
name|store_size
parameter_list|,
name|unsigned
name|int
modifier|*
name|delta_chain_length
parameter_list|,
name|unsigned
name|char
modifier|*
name|base_sha1
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w_curs
init|=
name|NULL
decl_stmt|;
name|off_t
name|curpos
decl_stmt|;
name|unsigned
name|long
name|dummy
decl_stmt|;
name|unsigned
name|char
modifier|*
name|next_sha1
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|struct
name|revindex_entry
modifier|*
name|revidx
decl_stmt|;
operator|*
name|delta_chain_length
operator|=
literal|0
expr_stmt|;
name|curpos
operator|=
name|obj_offset
expr_stmt|;
name|type
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|revidx
operator|=
name|find_pack_revindex
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
operator|*
name|store_size
operator|=
name|revidx
index|[
literal|1
index|]
operator|.
name|offset
operator|-
name|obj_offset
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|die
argument_list|(
literal|"pack %s contains unknown object type %d"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|type
argument_list|)
expr_stmt|;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
name|unuse_pack
argument_list|(
operator|&
name|w_curs
argument_list|)
expr_stmt|;
return|return
name|typename
argument_list|(
name|type
argument_list|)
return|;
case|case
name|OBJ_OFS_DELTA
case|:
name|obj_offset
operator|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
name|type
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_offset
condition|)
name|die
argument_list|(
literal|"pack %s contains bad delta base reference of type %s"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|delta_chain_length
operator|==
literal|0
condition|)
block|{
name|revidx
operator|=
name|find_pack_revindex
argument_list|(
name|p
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|base_sha1
argument_list|,
name|nth_packed_object_sha1
argument_list|(
name|p
argument_list|,
name|revidx
operator|->
name|nr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OBJ_REF_DELTA
case|:
name|next_sha1
operator|=
name|use_pack
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|curpos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|delta_chain_length
operator|==
literal|0
condition|)
name|hashcpy
argument_list|(
name|base_sha1
argument_list|,
name|next_sha1
argument_list|)
expr_stmt|;
name|obj_offset
operator|=
name|find_pack_entry_one
argument_list|(
name|next_sha1
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|delta_chain_length
operator|)
operator|++
expr_stmt|;
name|curpos
operator|=
name|obj_offset
expr_stmt|;
name|type
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|packed_object_info
specifier|static
name|int
name|packed_object_info
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w_curs
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|off_t
name|curpos
init|=
name|obj_offset
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|type
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OBJ_OFS_DELTA
case|:
case|case
name|OBJ_REF_DELTA
case|:
name|type
operator|=
name|packed_delta_info
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|curpos
argument_list|,
name|type
argument_list|,
name|obj_offset
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"pack %s contains unknown object type %d"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|unuse_pack
argument_list|(
operator|&
name|w_curs
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function
begin_function
DECL|function|unpack_compressed_entry
specifier|static
name|void
modifier|*
name|unpack_compressed_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
name|curpos
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|st
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|buffer
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
do|do
block|{
name|in
operator|=
name|use_pack
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
name|curpos
argument_list|,
operator|&
name|stream
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
name|in
expr_stmt|;
name|st
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
name|curpos
operator|+=
name|stream
operator|.
name|next_in
operator|-
name|in
expr_stmt|;
block|}
do|while
condition|(
name|st
operator|==
name|Z_OK
operator|||
name|st
operator|==
name|Z_BUF_ERROR
condition|)
do|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|Z_STREAM_END
operator|)
operator|||
name|stream
operator|.
name|total_out
operator|!=
name|size
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buffer
return|;
block|}
end_function
begin_define
DECL|macro|MAX_DELTA_CACHE
define|#
directive|define
name|MAX_DELTA_CACHE
value|(256)
end_define
begin_decl_stmt
DECL|variable|delta_base_cached
specifier|static
name|size_t
name|delta_base_cached
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|delta_base_cache_lru_list
specifier|static
struct|struct
name|delta_base_cache_lru_list
block|{
DECL|member|prev
name|struct
name|delta_base_cache_lru_list
modifier|*
name|prev
decl_stmt|;
DECL|member|next
name|struct
name|delta_base_cache_lru_list
modifier|*
name|next
decl_stmt|;
block|}
DECL|variable|delta_base_cache_lru
name|delta_base_cache_lru
init|=
block|{
operator|&
name|delta_base_cache_lru
block|,
operator|&
name|delta_base_cache_lru
block|}
struct|;
end_struct
begin_struct
DECL|struct|delta_base_cache_entry
specifier|static
struct|struct
name|delta_base_cache_entry
block|{
DECL|member|lru
name|struct
name|delta_base_cache_lru_list
name|lru
decl_stmt|;
DECL|member|data
name|void
modifier|*
name|data
decl_stmt|;
DECL|member|p
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
DECL|member|base_offset
name|off_t
name|base_offset
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|size
decl_stmt|;
DECL|member|type
name|enum
name|object_type
name|type
decl_stmt|;
block|}
DECL|variable|delta_base_cache
name|delta_base_cache
index|[
name|MAX_DELTA_CACHE
index|]
struct|;
end_struct
begin_function
DECL|function|pack_entry_hash
specifier|static
name|unsigned
name|long
name|pack_entry_hash
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|)
block|{
name|unsigned
name|long
name|hash
decl_stmt|;
name|hash
operator|=
operator|(
name|unsigned
name|long
operator|)
name|p
operator|+
operator|(
name|unsigned
name|long
operator|)
name|base_offset
expr_stmt|;
name|hash
operator|+=
operator|(
name|hash
operator|>>
literal|8
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
name|hash
operator|%
name|MAX_DELTA_CACHE
return|;
block|}
end_function
begin_function
DECL|function|cache_or_unpack_entry
specifier|static
name|void
modifier|*
name|cache_or_unpack_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|base_size
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|int
name|keep_cache
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|long
name|hash
init|=
name|pack_entry_hash
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
decl_stmt|;
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
init|=
name|delta_base_cache
operator|+
name|hash
decl_stmt|;
name|ret
operator|=
name|ent
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|ent
operator|->
name|p
operator|==
name|p
operator|&&
name|ent
operator|->
name|base_offset
operator|==
name|base_offset
condition|)
goto|goto
name|found_cache_entry
goto|;
return|return
name|unpack_entry
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|,
name|type
argument_list|,
name|base_size
argument_list|)
return|;
name|found_cache_entry
label|:
if|if
condition|(
operator|!
name|keep_cache
condition|)
block|{
name|ent
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|next
operator|->
name|prev
operator|=
name|ent
operator|->
name|lru
operator|.
name|prev
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|prev
operator|->
name|next
operator|=
name|ent
operator|->
name|lru
operator|.
name|next
expr_stmt|;
name|delta_base_cached
operator|-=
name|ent
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|xmemdupz
argument_list|(
name|ent
operator|->
name|data
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
operator|*
name|type
operator|=
name|ent
operator|->
name|type
expr_stmt|;
operator|*
name|base_size
operator|=
name|ent
operator|->
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|release_delta_base_cache
specifier|static
specifier|inline
name|void
name|release_delta_base_cache
parameter_list|(
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|->
name|data
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|data
argument_list|)
expr_stmt|;
name|ent
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|next
operator|->
name|prev
operator|=
name|ent
operator|->
name|lru
operator|.
name|prev
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|prev
operator|->
name|next
operator|=
name|ent
operator|->
name|lru
operator|.
name|next
expr_stmt|;
name|delta_base_cached
operator|-=
name|ent
operator|->
name|size
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_delta_base_cache
specifier|static
name|void
name|add_delta_base_cache
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|base_offset
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|unsigned
name|long
name|base_size
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|hash
init|=
name|pack_entry_hash
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
decl_stmt|;
name|struct
name|delta_base_cache_entry
modifier|*
name|ent
init|=
name|delta_base_cache
operator|+
name|hash
decl_stmt|;
name|struct
name|delta_base_cache_lru_list
modifier|*
name|lru
decl_stmt|;
name|release_delta_base_cache
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|delta_base_cached
operator|+=
name|base_size
expr_stmt|;
for|for
control|(
name|lru
operator|=
name|delta_base_cache_lru
operator|.
name|next
init|;
name|delta_base_cached
operator|>
name|delta_base_cache_limit
operator|&&
name|lru
operator|!=
operator|&
name|delta_base_cache_lru
condition|;
name|lru
operator|=
name|lru
operator|->
name|next
control|)
block|{
name|struct
name|delta_base_cache_entry
modifier|*
name|f
init|=
operator|(
name|void
operator|*
operator|)
name|lru
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|type
operator|==
name|OBJ_BLOB
condition|)
name|release_delta_base_cache
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|lru
operator|=
name|delta_base_cache_lru
operator|.
name|next
init|;
name|delta_base_cached
operator|>
name|delta_base_cache_limit
operator|&&
name|lru
operator|!=
operator|&
name|delta_base_cache_lru
condition|;
name|lru
operator|=
name|lru
operator|->
name|next
control|)
block|{
name|struct
name|delta_base_cache_entry
modifier|*
name|f
init|=
operator|(
name|void
operator|*
operator|)
name|lru
decl_stmt|;
name|release_delta_base_cache
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|ent
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|ent
operator|->
name|base_offset
operator|=
name|base_offset
expr_stmt|;
name|ent
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ent
operator|->
name|data
operator|=
name|base
expr_stmt|;
name|ent
operator|->
name|size
operator|=
name|base_size
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|next
operator|=
operator|&
name|delta_base_cache_lru
expr_stmt|;
name|ent
operator|->
name|lru
operator|.
name|prev
operator|=
name|delta_base_cache_lru
operator|.
name|prev
expr_stmt|;
name|delta_base_cache_lru
operator|.
name|prev
operator|->
name|next
operator|=
operator|&
name|ent
operator|->
name|lru
expr_stmt|;
name|delta_base_cache_lru
operator|.
name|prev
operator|=
operator|&
name|ent
operator|->
name|lru
expr_stmt|;
block|}
end_function
begin_function
DECL|function|unpack_delta_entry
specifier|static
name|void
modifier|*
name|unpack_delta_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|struct
name|pack_window
modifier|*
modifier|*
name|w_curs
parameter_list|,
name|off_t
name|curpos
parameter_list|,
name|unsigned
name|long
name|delta_size
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|void
modifier|*
name|delta_data
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|unsigned
name|long
name|base_size
decl_stmt|;
name|off_t
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
operator|*
name|type
argument_list|,
name|obj_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_offset
condition|)
block|{
name|error
argument_list|(
literal|"failed to validate delta base reference "
literal|"at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curpos
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|base
operator|=
name|cache_or_unpack_entry
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|,
operator|&
name|base_size
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
comment|/* 		 * We're probably in deep shit, but let's try to fetch 		 * the required base anyway from another pack or loose. 		 * This is costly but should happen only in the presence 		 * of a corrupted pack, and is better than failing outright. 		 */
name|struct
name|revindex_entry
modifier|*
name|revidx
init|=
name|find_pack_revindex
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|base_sha1
init|=
name|nth_packed_object_sha1
argument_list|(
name|p
argument_list|,
name|revidx
operator|->
name|nr
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"failed to read delta base object %s"
literal|" at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_sha1
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|base_offset
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|mark_bad_packed_object
argument_list|(
name|p
argument_list|,
name|base_sha1
argument_list|)
expr_stmt|;
name|base
operator|=
name|read_sha1_file
argument_list|(
name|base_sha1
argument_list|,
name|type
argument_list|,
operator|&
name|base_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
name|NULL
return|;
block|}
name|delta_data
operator|=
name|unpack_compressed_entry
argument_list|(
name|p
argument_list|,
name|w_curs
argument_list|,
name|curpos
argument_list|,
name|delta_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta_data
condition|)
block|{
name|error
argument_list|(
literal|"failed to unpack compressed delta "
literal|"at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curpos
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|result
operator|=
name|patch_delta
argument_list|(
name|base
argument_list|,
name|base_size
argument_list|,
name|delta_data
argument_list|,
name|delta_size
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|die
argument_list|(
literal|"failed to apply delta"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|delta_data
argument_list|)
expr_stmt|;
name|add_delta_base_cache
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|,
name|base
argument_list|,
name|base_size
argument_list|,
operator|*
name|type
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|unpack_entry
name|void
modifier|*
name|unpack_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|off_t
name|obj_offset
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|pack_window
modifier|*
name|w_curs
init|=
name|NULL
decl_stmt|;
name|off_t
name|curpos
init|=
name|obj_offset
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
operator|*
name|type
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
operator|&
name|curpos
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|type
condition|)
block|{
case|case
name|OBJ_OFS_DELTA
case|:
case|case
name|OBJ_REF_DELTA
case|:
name|data
operator|=
name|unpack_delta_entry
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|curpos
argument_list|,
operator|*
name|sizep
argument_list|,
name|obj_offset
argument_list|,
name|type
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
name|data
operator|=
name|unpack_compressed_entry
argument_list|(
name|p
argument_list|,
operator|&
name|w_curs
argument_list|,
name|curpos
argument_list|,
operator|*
name|sizep
argument_list|)
expr_stmt|;
break|break;
default|default:
name|data
operator|=
name|NULL
expr_stmt|;
name|error
argument_list|(
literal|"unknown object type %i at offset %"
name|PRIuMAX
literal|" in %s"
argument_list|,
operator|*
name|type
argument_list|,
operator|(
name|uintmax_t
operator|)
name|obj_offset
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
block|}
name|unuse_pack
argument_list|(
operator|&
name|w_curs
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_function
DECL|function|nth_packed_object_sha1
specifier|const
name|unsigned
name|char
modifier|*
name|nth_packed_object_sha1
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|index
init|=
name|p
operator|->
name|index_data
decl_stmt|;
if|if
condition|(
operator|!
name|index
condition|)
block|{
if|if
condition|(
name|open_pack_index
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
name|index
operator|=
name|p
operator|->
name|index_data
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|p
operator|->
name|num_objects
condition|)
return|return
name|NULL
return|;
name|index
operator|+=
literal|4
operator|*
literal|256
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|index_version
operator|==
literal|1
condition|)
block|{
return|return
name|index
operator|+
literal|24
operator|*
name|n
operator|+
literal|4
return|;
block|}
else|else
block|{
name|index
operator|+=
literal|8
expr_stmt|;
return|return
name|index
operator|+
literal|20
operator|*
name|n
return|;
block|}
block|}
end_function
begin_function
DECL|function|nth_packed_object_offset
specifier|static
name|off_t
name|nth_packed_object_offset
parameter_list|(
specifier|const
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|uint32_t
name|n
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|index
init|=
name|p
operator|->
name|index_data
decl_stmt|;
name|index
operator|+=
literal|4
operator|*
literal|256
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|index_version
operator|==
literal|1
condition|)
block|{
return|return
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|24
operator|*
name|n
operator|)
operator|)
argument_list|)
return|;
block|}
else|else
block|{
name|uint32_t
name|off
decl_stmt|;
name|index
operator|+=
literal|8
operator|+
name|p
operator|->
name|num_objects
operator|*
operator|(
literal|20
operator|+
literal|4
operator|)
expr_stmt|;
name|off
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|4
operator|*
name|n
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|off
operator|&
literal|0x80000000
operator|)
condition|)
return|return
name|off
return|;
name|index
operator|+=
name|p
operator|->
name|num_objects
operator|*
literal|4
operator|+
operator|(
name|off
operator|&
literal|0x7fffffff
operator|)
operator|*
literal|8
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|0
operator|)
operator|)
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|index
operator|+
literal|4
operator|)
operator|)
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|find_pack_entry_one
name|off_t
name|find_pack_entry_one
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|level1_ofs
init|=
name|p
operator|->
name|index_data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|index
init|=
name|p
operator|->
name|index_data
decl_stmt|;
name|unsigned
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|stride
decl_stmt|;
specifier|static
name|int
name|use_lookup
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|debug_lookup
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|debug_lookup
operator|<
literal|0
condition|)
name|debug_lookup
operator|=
operator|!
operator|!
name|getenv
argument_list|(
literal|"GIT_DEBUG_LOOKUP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
condition|)
block|{
if|if
condition|(
name|open_pack_index
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|level1_ofs
operator|=
name|p
operator|->
name|index_data
expr_stmt|;
name|index
operator|=
name|p
operator|->
name|index_data
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|index_version
operator|>
literal|1
condition|)
block|{
name|level1_ofs
operator|+=
literal|2
expr_stmt|;
name|index
operator|+=
literal|8
expr_stmt|;
block|}
name|index
operator|+=
literal|4
operator|*
literal|256
expr_stmt|;
name|hi
operator|=
name|ntohl
argument_list|(
name|level1_ofs
index|[
operator|*
name|sha1
index|]
argument_list|)
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
operator|*
name|sha1
operator|==
literal|0x0
operator|)
condition|?
literal|0
else|:
name|ntohl
argument_list|(
name|level1_ofs
index|[
operator|*
name|sha1
operator|-
literal|1
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|index_version
operator|>
literal|1
condition|)
block|{
name|stride
operator|=
literal|20
expr_stmt|;
block|}
else|else
block|{
name|stride
operator|=
literal|24
expr_stmt|;
name|index
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|debug_lookup
condition|)
name|printf
argument_list|(
literal|"%02x%02x%02x... lo %u hi %u nr %u\n"
argument_list|,
name|sha1
index|[
literal|0
index|]
argument_list|,
name|sha1
index|[
literal|1
index|]
argument_list|,
name|sha1
index|[
literal|2
index|]
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|p
operator|->
name|num_objects
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_lookup
operator|<
literal|0
condition|)
name|use_lookup
operator|=
operator|!
operator|!
name|getenv
argument_list|(
literal|"GIT_USE_LOOKUP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_lookup
condition|)
block|{
name|int
name|pos
init|=
name|sha1_entry_pos
argument_list|(
name|index
argument_list|,
name|stride
argument_list|,
literal|0
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|p
operator|->
name|num_objects
argument_list|,
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|nth_packed_object_offset
argument_list|(
name|p
argument_list|,
name|pos
argument_list|)
return|;
block|}
do|do
block|{
name|unsigned
name|mi
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|cmp
init|=
name|hashcmp
argument_list|(
name|index
operator|+
name|mi
operator|*
name|stride
argument_list|,
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug_lookup
condition|)
name|printf
argument_list|(
literal|"lo %u hi %u rg %u mi %u\n"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|hi
operator|-
name|lo
argument_list|,
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|nth_packed_object_offset
argument_list|(
name|p
argument_list|,
name|mi
argument_list|)
return|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|hi
operator|=
name|mi
expr_stmt|;
else|else
name|lo
operator|=
name|mi
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|lo
operator|<
name|hi
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|matches_pack_name
name|int
name|matches_pack_name
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last_c
decl_stmt|,
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
name|p
operator|->
name|pack_name
operator|,
name|last_c
operator|=
name|c
init|;
operator|*
name|c
condition|;
control|)
if|if
condition|(
operator|*
name|c
operator|==
literal|'/'
condition|)
name|last_c
operator|=
operator|++
name|c
expr_stmt|;
else|else
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|last_c
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_pack_entry
specifier|static
name|int
name|find_pack_entry
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|pack_entry
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|ignore_packed
parameter_list|)
block|{
specifier|static
name|struct
name|packed_git
modifier|*
name|last_found
init|=
operator|(
name|void
operator|*
operator|)
literal|1
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|packed_git
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|(
name|last_found
operator|==
operator|(
name|void
operator|*
operator|)
literal|1
operator|)
condition|?
name|packed_git
else|:
name|last_found
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ignore_packed
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|ig
decl_stmt|;
for|for
control|(
name|ig
operator|=
name|ignore_packed
init|;
operator|*
name|ig
condition|;
name|ig
operator|++
control|)
if|if
condition|(
name|matches_pack_name
argument_list|(
name|p
argument_list|,
operator|*
name|ig
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|ig
condition|)
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|num_bad_objects
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|num_bad_objects
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|p
operator|->
name|bad_object_sha1
operator|+
literal|20
operator|*
name|i
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
name|offset
operator|=
name|find_pack_entry_one
argument_list|(
name|sha1
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
comment|/* 			 * We are about to tell the caller where they can 			 * locate the requested object.  We better make 			 * sure the packfile is still here and can be 			 * accessed before supplying that answer, as 			 * it may have been deleted since the index 			 * was loaded! 			 */
if|if
condition|(
name|p
operator|->
name|pack_fd
operator|==
operator|-
literal|1
operator|&&
name|open_packed_git
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"packfile %s cannot be accessed"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|e
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|e
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|last_found
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
name|next
label|:
if|if
condition|(
name|p
operator|==
name|last_found
condition|)
name|p
operator|=
name|packed_git
expr_stmt|;
else|else
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|last_found
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_sha1_pack
name|struct
name|packed_git
modifier|*
name|find_sha1_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|packed_git
modifier|*
name|packs
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|packs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|find_pack_entry_one
argument_list|(
name|sha1
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|p
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sha1_loose_object_info
specifier|static
name|int
name|sha1_loose_object_info
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|unsigned
name|long
name|mapsize
decl_stmt|,
name|size
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|map
operator|=
name|map_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return
name|error
argument_list|(
literal|"unable to find %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|unpack_sha1_header
argument_list|(
operator|&
name|stream
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
name|error
argument_list|(
literal|"unable to unpack %s header"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|status
operator|=
name|parse_sha1_header
argument_list|(
name|hdr
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|status
operator|=
name|error
argument_list|(
literal|"unable to parse %s header"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|sha1_object_info
name|int
name|sha1_object_info
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|reprepare_packed_git
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|sha1_loose_object_info
argument_list|(
name|sha1
argument_list|,
name|sizep
argument_list|)
return|;
block|}
return|return
name|packed_object_info
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|e
operator|.
name|offset
argument_list|,
name|sizep
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read_packed_sha1
specifier|static
name|void
modifier|*
name|read_packed_sha1
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
name|data
operator|=
name|cache_or_unpack_entry
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|e
operator|.
name|offset
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
comment|/* 		 * We're probably in deep shit, but let's try to fetch 		 * the required object anyway from another pack or loose. 		 * This should happen only in the presence of a corrupted 		 * pack, and is better than failing outright. 		 */
name|error
argument_list|(
literal|"failed to read object %s at offset %"
name|PRIuMAX
literal|" from %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|e
operator|.
name|offset
argument_list|,
name|e
operator|.
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|mark_bad_packed_object
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|data
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*  * This is meant to hold a *small* number of objects that you would  * want read_sha1_file() to be able to return, but yet you do not want  * to write them into the object store (e.g. a browse-only  * application).  */
end_comment
begin_struct
DECL|struct|cached_object
specifier|static
struct|struct
name|cached_object
block|{
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|type
name|enum
name|object_type
name|type
decl_stmt|;
DECL|member|buf
name|void
modifier|*
name|buf
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|size
decl_stmt|;
block|}
DECL|variable|cached_objects
modifier|*
name|cached_objects
struct|;
end_struct
begin_decl_stmt
DECL|variable|cached_object_nr
DECL|variable|cached_object_alloc
specifier|static
name|int
name|cached_object_nr
decl_stmt|,
name|cached_object_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|empty_tree
specifier|static
name|struct
name|cached_object
name|empty_tree
init|=
block|{
comment|/* empty tree sha1: 4b825dc642cb6eb9a060e54bf8d69288fbee4904 */
literal|"\x4b\x82\x5d\xc6\x42\xcb\x6e\xb9\xa0\x60"
literal|"\xe5\x4b\xf8\xd6\x92\x88\xfb\xee\x49\x04"
block|,
name|OBJ_TREE
block|,
literal|""
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|find_cached_object
specifier|static
name|struct
name|cached_object
modifier|*
name|find_cached_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|cached_object
modifier|*
name|co
init|=
name|cached_objects
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cached_object_nr
condition|;
name|i
operator|++
operator|,
name|co
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|co
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|co
return|;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|empty_tree
operator|.
name|sha1
argument_list|)
condition|)
return|return
operator|&
name|empty_tree
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|pretend_sha1_file
name|int
name|pretend_sha1_file
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|cached_object
modifier|*
name|co
decl_stmt|;
name|hash_sha1_file
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
operator|||
name|find_cached_object
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cached_object_alloc
operator|<=
name|cached_object_nr
condition|)
block|{
name|cached_object_alloc
operator|=
name|alloc_nr
argument_list|(
name|cached_object_alloc
argument_list|)
expr_stmt|;
name|cached_objects
operator|=
name|xrealloc
argument_list|(
name|cached_objects
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cached_objects
argument_list|)
operator|*
name|cached_object_alloc
argument_list|)
expr_stmt|;
block|}
name|co
operator|=
operator|&
name|cached_objects
index|[
name|cached_object_nr
operator|++
index|]
expr_stmt|;
name|co
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|co
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|co
operator|->
name|buf
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|co
operator|->
name|buf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|co
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_sha1_file
name|void
modifier|*
name|read_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|long
name|mapsize
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|struct
name|cached_object
modifier|*
name|co
decl_stmt|;
name|co
operator|=
name|find_cached_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
condition|)
block|{
operator|*
name|type
operator|=
name|co
operator|->
name|type
expr_stmt|;
operator|*
name|size
operator|=
name|co
operator|->
name|size
expr_stmt|;
return|return
name|xmemdupz
argument_list|(
name|co
operator|->
name|buf
argument_list|,
name|co
operator|->
name|size
argument_list|)
return|;
block|}
name|buf
operator|=
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
return|return
name|buf
return|;
name|map
operator|=
name|map_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|buf
operator|=
name|unpack_sha1_file
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|,
name|type
argument_list|,
name|size
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|reprepare_packed_git
argument_list|()
expr_stmt|;
return|return
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read_object_with_reference
name|void
modifier|*
name|read_object_with_reference
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|required_type_name
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
name|unsigned
name|char
modifier|*
name|actual_sha1_return
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|,
name|required_type
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|isize
decl_stmt|;
name|unsigned
name|char
name|actual_sha1
index|[
literal|20
index|]
decl_stmt|;
name|required_type
operator|=
name|type_from_string
argument_list|(
name|required_type_name
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|actual_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ref_length
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|ref_type
init|=
name|NULL
decl_stmt|;
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|actual_sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|isize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|type
operator|==
name|required_type
condition|)
block|{
operator|*
name|size
operator|=
name|isize
expr_stmt|;
if|if
condition|(
name|actual_sha1_return
condition|)
name|hashcpy
argument_list|(
name|actual_sha1_return
argument_list|,
name|actual_sha1
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
comment|/* Handle references */
elseif|else
if|if
condition|(
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|ref_type
operator|=
literal|"tree "
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|OBJ_TAG
condition|)
name|ref_type
operator|=
literal|"object "
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ref_length
operator|=
name|strlen
argument_list|(
name|ref_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_length
operator|+
literal|40
operator|>
name|isize
operator|||
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|ref_type
argument_list|,
name|ref_length
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
name|ref_length
argument_list|,
name|actual_sha1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Now we have the ID of the referred-to object in 		 * actual_sha1.  Check again. */
block|}
block|}
end_function
begin_function
DECL|function|write_sha1_file_prepare
specifier|static
name|void
name|write_sha1_file_prepare
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|,
name|int
modifier|*
name|hdrlen
parameter_list|)
block|{
name|SHA_CTX
name|c
decl_stmt|;
comment|/* Generate the header */
operator|*
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|type
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Sha1.. */
name|SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|hdr
argument_list|,
operator|*
name|hdrlen
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SHA1_Final
argument_list|(
name|sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Move the just written object into its final resting place  */
end_comment
begin_function
DECL|function|move_temp_to_file
name|int
name|move_temp_to_file
parameter_list|(
specifier|const
name|char
modifier|*
name|tmpfile
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|ret
init|=
name|link
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
decl_stmt|;
comment|/* 	 * Coda hack - coda doesn't like cross-directory links, 	 * so we fall back to a rename, which will mean that it 	 * won't be able to check collisions, but that's not a 	 * big deal. 	 * 	 * The same holds for FAT formatted media. 	 * 	 * When this succeeds, we just return 0. We have nothing 	 * left to unlink. 	 */
if|if
condition|(
name|ret
operator|&&
name|ret
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
operator|!
name|rename
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|errno
expr_stmt|;
block|}
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|EEXIST
condition|)
block|{
return|return
name|error
argument_list|(
literal|"unable to write sha1 filename %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|ret
argument_list|)
argument_list|)
return|;
block|}
comment|/* FIXME!!! Collision check here ? */
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_buffer
specifier|static
name|int
name|write_buffer
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"file write error (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|hash_sha1_file
name|int
name|hash_sha1_file
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|write_sha1_file_prepare
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|,
name|hdr
argument_list|,
operator|&
name|hdrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Finalize a file on disk, and close it. */
end_comment
begin_function
DECL|function|close_sha1_file
specifier|static
name|void
name|close_sha1_file
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
comment|/* For safe-mode, we could fsync_or_die(fd, "sha1 file") here */
name|fchmod
argument_list|(
name|fd
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"unable to write sha1 file"
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Size of directory component, including the ending '/' */
end_comment
begin_function
DECL|function|directory_size
specifier|static
specifier|inline
name|int
name|directory_size
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
return|return
name|s
operator|-
name|filename
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * This creates a temporary file in the same directory as the final  * 'filename'  *  * We want to avoid cross-directory filename renames, because those  * can have problems on various filesystems (FAT, NFS, Coda).  */
end_comment
begin_function
DECL|function|create_tmpfile
specifier|static
name|int
name|create_tmpfile
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsiz
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|dirlen
init|=
name|directory_size
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirlen
operator|+
literal|20
operator|>
name|bufsiz
condition|)
block|{
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|filename
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
name|dirlen
argument_list|,
literal|"tmp_obj_XXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|dirlen
condition|)
block|{
comment|/* Make sure the directory exists */
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|filename
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|buffer
index|[
name|dirlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|buffer
argument_list|,
literal|0777
argument_list|)
operator|||
name|adjust_shared_perm
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Try again */
name|strcpy
argument_list|(
name|buffer
operator|+
name|dirlen
operator|-
literal|1
argument_list|,
literal|"/tmp_obj_XXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function
begin_function
DECL|function|write_loose_object
specifier|static
name|int
name|write_loose_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|,
name|int
name|hdrlen
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|time_t
name|mtime
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|size
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|char
modifier|*
name|compressed
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
specifier|static
name|char
name|tmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|filename
operator|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|create_tmpfile
argument_list|(
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
return|return
name|error
argument_list|(
literal|"insufficient permission for adding an object to repository database %s\n"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
literal|"unable to create temporary sha1 filename %s: %s\n"
argument_list|,
name|tmpfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
comment|/* Set it up */
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|deflateInit
argument_list|(
operator|&
name|stream
argument_list|,
name|zlib_compression_level
argument_list|)
expr_stmt|;
name|size
operator|=
literal|8
operator|+
name|deflateBound
argument_list|(
operator|&
name|stream
argument_list|,
name|len
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
name|compressed
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Compress it */
name|stream
operator|.
name|next_out
operator|=
name|compressed
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
comment|/* First header.. */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|hdrlen
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
comment|/* Then the data itself.. */
name|stream
operator|.
name|next_in
operator|=
name|buf
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
name|die
argument_list|(
literal|"unable to deflate new object %s (%d)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|deflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|die
argument_list|(
literal|"deflateEnd on object %s failed (%d)"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|size
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
if|if
condition|(
name|write_buffer
argument_list|(
name|fd
argument_list|,
name|compressed
argument_list|,
name|size
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to write sha1 file"
argument_list|)
expr_stmt|;
name|close_sha1_file
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
condition|)
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|mtime
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|tmpfile
argument_list|,
operator|&
name|utb
argument_list|)
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"failed utime() on %s: %s"
argument_list|,
name|tmpfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|move_temp_to_file
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|write_sha1_file
name|int
name|write_sha1_file
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|returnsha1
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
comment|/* Normally if we have it in the pack then we do not bother writing 	 * it out into .git/objects/??/?{38} file. 	 */
name|write_sha1_file_prepare
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|,
name|hdr
argument_list|,
operator|&
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnsha1
condition|)
name|hashcpy
argument_list|(
name|returnsha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|write_loose_object
argument_list|(
name|sha1
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|force_object_loose
name|int
name|force_object_loose
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|time_t
name|mtime
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
name|hdr
index|[
literal|32
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
if|if
condition|(
name|has_loose_object
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
name|buf
operator|=
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|error
argument_list|(
literal|"cannot read sha1_file for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|write_loose_object
argument_list|(
name|sha1
argument_list|,
name|hdr
argument_list|,
name|hdrlen
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|mtime
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|has_pack_index
name|int
name|has_pack_index
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|sha1_pack_index_name
argument_list|(
name|sha1
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|has_pack_file
name|int
name|has_pack_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|sha1_pack_name
argument_list|(
name|sha1
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|has_sha1_pack
name|int
name|has_sha1_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|ignore_packed
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
return|return
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|ignore_packed
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|has_sha1_file
name|int
name|has_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
if|if
condition|(
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|has_loose_object
argument_list|(
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|index_pipe
name|int
name|index_pipe
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|write_object
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|buf
argument_list|,
name|fd
argument_list|,
literal|4096
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|blob_type
expr_stmt|;
if|if
condition|(
name|write_object
condition|)
name|ret
operator|=
name|write_sha1_file
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|hash_sha1_file
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|index_fd
name|int
name|index_fd
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|int
name|write_object
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|size
init|=
name|xsize_t
argument_list|(
name|st
operator|->
name|st_size
argument_list|)
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|re_allocated
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
condition|)
name|buf
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|OBJ_BLOB
expr_stmt|;
comment|/* 	 * Convert blobs to git internal format 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|OBJ_BLOB
operator|)
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|nbuf
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|nbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_to_git
argument_list|(
name|path
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|nbuf
argument_list|,
name|write_object
condition|?
name|safe_crlf
else|:
literal|0
argument_list|)
condition|)
block|{
name|munmap
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|buf
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|nbuf
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|re_allocated
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|write_object
condition|)
name|ret
operator|=
name|write_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|hash_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|re_allocated
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|size
condition|)
name|munmap
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|index_path
name|int
name|index_path
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|int
name|write_object
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|st
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"open(\"%s\"): %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|index_fd
argument_list|(
name|sha1
argument_list|,
name|fd
argument_list|,
name|st
argument_list|,
name|write_object
argument_list|,
name|OBJ_BLOB
argument_list|,
name|path
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"%s: failed to insert into database"
argument_list|,
name|path
argument_list|)
return|;
break|break;
case|case
name|S_IFLNK
case|:
name|len
operator|=
name|xsize_t
argument_list|(
name|st
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|target
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlink
argument_list|(
name|path
argument_list|,
name|target
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|!=
name|st
operator|->
name|st_size
condition|)
block|{
name|char
modifier|*
name|errstr
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"readlink(\"%s\"): %s"
argument_list|,
name|path
argument_list|,
name|errstr
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|write_object
condition|)
name|hash_sha1_file
argument_list|(
name|target
argument_list|,
name|len
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write_sha1_file
argument_list|(
name|target
argument_list|,
name|len
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"%s: failed to insert into database"
argument_list|,
name|path
argument_list|)
return|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
return|return
name|resolve_gitlink_ref
argument_list|(
name|path
argument_list|,
literal|"HEAD"
argument_list|,
name|sha1
argument_list|)
return|;
default|default:
return|return
name|error
argument_list|(
literal|"%s: unsupported file type"
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_pack_header
name|int
name|read_pack_header
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|pack_header
modifier|*
name|header
parameter_list|)
block|{
if|if
condition|(
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
condition|)
comment|/* "eof before pack header was fully read" */
return|return
name|PH_ERROR_EOF
return|;
if|if
condition|(
name|header
operator|->
name|hdr_signature
operator|!=
name|htonl
argument_list|(
name|PACK_SIGNATURE
argument_list|)
condition|)
comment|/* "protocol error (pack signature mismatch detected)" */
return|return
name|PH_ERROR_PACK_SIGNATURE
return|;
if|if
condition|(
operator|!
name|pack_version_ok
argument_list|(
name|header
operator|->
name|hdr_version
argument_list|)
condition|)
comment|/* "protocol error (pack version unsupported)" */
return|return
name|PH_ERROR_PROTOCOL
return|;
return|return
literal|0
return|;
block|}
end_function
end_unit
