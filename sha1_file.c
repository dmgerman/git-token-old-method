begin_unit
begin_comment
comment|/*  * GIT - The information manager from hell  *  * Copyright (C) Linus Torvalds, 2005  *  * This handles basic git sha1 object files - packing, unpacking,  * creation etc.  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"delta.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"tree.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|O_NOATIME
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__PPC__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|O_NOATIME
define|#
directive|define
name|O_NOATIME
value|01000000
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|O_NOATIME
define|#
directive|define
name|O_NOATIME
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|null_sha1
specifier|const
name|unsigned
name|char
name|null_sha1
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|sha1_file_open_flag
specifier|static
name|unsigned
name|int
name|sha1_file_open_flag
init|=
name|O_NOATIME
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|hexval_table
name|signed
name|char
name|hexval_table
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 00-07 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 08-0f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 10-17 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 18-1f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 20-27 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 28-2f */
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
comment|/* 30-37 */
literal|8
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 38-3f */
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
operator|-
literal|1
block|,
comment|/* 40-47 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 48-4f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 50-57 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 58-5f */
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
operator|-
literal|1
block|,
comment|/* 60-67 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 68-67 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 70-77 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 78-7f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 80-87 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 88-8f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 90-97 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* 98-9f */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* a0-a7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* a8-af */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* b0-b7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* b8-bf */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* c0-c7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* c8-cf */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* d0-d7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* d8-df */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* e0-e7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* e8-ef */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* f0-f7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* f8-ff */
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_sha1_hex
name|int
name|get_sha1_hex
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|(
name|hexval
argument_list|(
name|hex
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hexval
argument_list|(
name|hex
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|&
operator|~
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|sha1
operator|++
operator|=
name|val
expr_stmt|;
name|hex
operator|+=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|safe_create_leading_directories
name|int
name|safe_create_leading_directories
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|pos
init|=
name|path
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
literal|'/'
condition|)
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|pos
condition|)
block|{
name|pos
operator|=
name|strchr
argument_list|(
name|pos
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
break|break;
operator|*
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* path exists */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|adjust_shared_perm
argument_list|(
name|path
argument_list|)
condition|)
block|{
operator|*
name|pos
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
operator|*
name|pos
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sha1_to_hex
name|char
modifier|*
name|sha1_to_hex
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|int
name|bufno
decl_stmt|;
specifier|static
name|char
name|hexbuffer
index|[
literal|4
index|]
index|[
literal|50
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|hexbuffer
index|[
literal|3
operator|&
operator|++
name|bufno
index|]
decl_stmt|,
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|*
name|sha1
operator|++
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function
begin_function
DECL|function|fill_sha1_path
specifier|static
name|void
name|fill_sha1_path
parameter_list|(
name|char
modifier|*
name|pathbuf
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|unsigned
name|int
name|val
init|=
name|sha1
index|[
name|i
index|]
decl_stmt|;
name|char
modifier|*
name|pos
init|=
name|pathbuf
operator|+
name|i
operator|*
literal|2
operator|+
operator|(
name|i
operator|>
literal|0
operator|)
decl_stmt|;
operator|*
name|pos
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|pos
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * NOTE! This returns a statically allocated buffer, so you have to be  * careful about using it. Do a "xstrdup()" if you need to save the  * filename.  *  * Also note that this returns the location for creating.  Reading  * SHA1 file can happen from any alternate directory listed in the  * DB_ENVIRONMENT environment variable if it is not found in  * the primary object database.  */
end_comment
begin_function
DECL|function|sha1_file_name
name|char
modifier|*
name|sha1_file_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
specifier|const
name|char
modifier|*
name|sha1_file_directory
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|sha1_file_directory
argument_list|)
decl_stmt|;
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|60
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|base
argument_list|,
name|sha1_file_directory
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|base
operator|+
name|len
argument_list|,
literal|0
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|base
index|[
name|len
index|]
operator|=
literal|'/'
expr_stmt|;
name|base
index|[
name|len
operator|+
literal|3
index|]
operator|=
literal|'/'
expr_stmt|;
name|name
operator|=
name|base
operator|+
name|len
operator|+
literal|1
expr_stmt|;
block|}
name|fill_sha1_path
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
end_function
begin_function
DECL|function|sha1_pack_name
name|char
modifier|*
name|sha1_pack_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
specifier|const
name|char
modifier|*
name|sha1_file_directory
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|sha1_file_directory
argument_list|)
decl_stmt|;
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|60
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|base
argument_list|,
literal|"%s/pack/pack-1234567890123456789012345678901234567890.pack"
argument_list|,
name|sha1_file_directory
argument_list|)
expr_stmt|;
name|name
operator|=
name|base
operator|+
name|len
operator|+
literal|11
expr_stmt|;
block|}
name|buf
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|*
name|sha1
operator|++
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
return|return
name|base
return|;
block|}
end_function
begin_function
DECL|function|sha1_pack_index_name
name|char
modifier|*
name|sha1_pack_index_name
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
specifier|const
name|char
modifier|*
name|sha1_file_directory
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|sha1_file_directory
argument_list|)
decl_stmt|;
name|base
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|60
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|base
argument_list|,
literal|"%s/pack/pack-1234567890123456789012345678901234567890.idx"
argument_list|,
name|sha1_file_directory
argument_list|)
expr_stmt|;
name|name
operator|=
name|base
operator|+
name|len
operator|+
literal|11
expr_stmt|;
block|}
name|buf
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|val
init|=
operator|*
name|sha1
operator|++
decl_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hex
index|[
name|val
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
return|return
name|base
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|alt_odb_list
name|struct
name|alternate_object_database
modifier|*
name|alt_odb_list
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|alt_odb_tail
specifier|static
name|struct
name|alternate_object_database
modifier|*
modifier|*
name|alt_odb_tail
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|read_info_alternates
parameter_list|(
specifier|const
name|char
modifier|*
name|alternates
parameter_list|,
name|int
name|depth
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*  * Prepare alternate object database registry.  *  * The variable alt_odb_list points at the list of struct  * alternate_object_database.  The elements on this list come from  * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT  * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,  * whose contents is similar to that environment variable but can be  * LF separated.  Its base points at a statically allocated buffer that  * contains "/the/directory/corresponding/to/.git/objects/...", while  * its name points just after the slash at the end of ".git/objects/"  * in the example above, and has enough space to hold 40-byte hex  * SHA1, an extra slash for the first level indirection, and the  * terminating NUL.  */
end_comment
begin_function
DECL|function|link_alt_odb_entry
specifier|static
name|int
name|link_alt_odb_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|entry
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|objdir
init|=
name|get_object_directory
argument_list|()
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|ent
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
comment|/* 43 = 40-byte + 2 '/' + terminating NUL */
name|int
name|pfxlen
init|=
name|len
decl_stmt|;
name|int
name|entlen
init|=
name|pfxlen
operator|+
literal|43
decl_stmt|;
name|int
name|base_len
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|entry
operator|!=
literal|'/'
operator|&&
name|relative_base
condition|)
block|{
comment|/* Relative alt-odb */
if|if
condition|(
name|base_len
operator|<
literal|0
condition|)
name|base_len
operator|=
name|strlen
argument_list|(
name|relative_base
argument_list|)
operator|+
literal|1
expr_stmt|;
name|entlen
operator|+=
name|base_len
expr_stmt|;
name|pfxlen
operator|+=
name|base_len
expr_stmt|;
block|}
name|ent
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
operator|+
name|entlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry
operator|!=
literal|'/'
operator|&&
name|relative_base
condition|)
block|{
name|memcpy
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|relative_base
argument_list|,
name|base_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|base_len
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|ent
operator|->
name|base
operator|+
name|base_len
argument_list|,
name|entry
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|entry
argument_list|,
name|pfxlen
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
operator|=
name|ent
operator|->
name|base
operator|+
name|pfxlen
operator|+
literal|1
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
operator|+
literal|3
index|]
operator|=
literal|'/'
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
index|]
operator|=
name|ent
operator|->
name|base
index|[
name|entlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Detect cases where alternate disappeared */
if|if
condition|(
name|stat
argument_list|(
name|ent
operator|->
name|base
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"object directory %s does not exist; "
literal|"check .git/objects/info/alternates."
argument_list|,
name|ent
operator|->
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Prevent the common mistake of listing the same 	 * thing twice, or object directory itself. 	 */
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|alt
operator|->
name|base
argument_list|,
name|pfxlen
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|objdir
argument_list|,
name|pfxlen
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* add the alternate entry */
operator|*
name|alt_odb_tail
operator|=
name|ent
expr_stmt|;
name|alt_odb_tail
operator|=
operator|&
operator|(
name|ent
operator|->
name|next
operator|)
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* recursively add alternates */
name|read_info_alternates
argument_list|(
name|ent
operator|->
name|base
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|base
index|[
name|pfxlen
index|]
operator|=
literal|'/'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|link_alt_odb_entries
specifier|static
name|void
name|link_alt_odb_entries
parameter_list|(
specifier|const
name|char
modifier|*
name|alt
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|,
name|int
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|depth
operator|>
literal|5
condition|)
block|{
name|error
argument_list|(
literal|"%s: ignoring alternate object stores, nesting too deep."
argument_list|,
name|relative_base
argument_list|)
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|alt
expr_stmt|;
while|while
condition|(
name|last
operator|<
name|ep
condition|)
block|{
name|cp
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|!=
name|sep
condition|)
name|cp
operator|++
expr_stmt|;
name|last
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|!=
name|sep
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|cp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|last
operator|!=
literal|'/'
operator|)
operator|&&
name|depth
condition|)
block|{
name|error
argument_list|(
literal|"%s: ignoring relative alternate object store %s"
argument_list|,
name|relative_base
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_alt_odb_entry
argument_list|(
name|last
argument_list|,
name|cp
operator|-
name|last
argument_list|,
name|relative_base
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
operator|*
name|cp
operator|==
name|sep
condition|)
name|cp
operator|++
expr_stmt|;
name|last
operator|=
name|cp
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|read_info_alternates
specifier|static
name|void
name|read_info_alternates
parameter_list|(
specifier|const
name|char
modifier|*
name|relative_base
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|char
modifier|*
name|map
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/info/alternates"
argument_list|,
name|relative_base
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|(
name|st
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|map
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|MAP_FAILED
condition|)
return|return;
name|link_alt_odb_entries
argument_list|(
name|map
argument_list|,
name|map
operator|+
name|st
operator|.
name|st_size
argument_list|,
literal|'\n'
argument_list|,
name|relative_base
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_alt_odb
name|void
name|prepare_alt_odb
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|alt
decl_stmt|;
name|alt
operator|=
name|getenv
argument_list|(
name|ALTERNATE_DB_ENVIRONMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt
condition|)
name|alt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|alt_odb_tail
condition|)
return|return;
name|alt_odb_tail
operator|=
operator|&
name|alt_odb_list
expr_stmt|;
name|link_alt_odb_entries
argument_list|(
name|alt
argument_list|,
name|alt
operator|+
name|strlen
argument_list|(
name|alt
argument_list|)
argument_list|,
literal|':'
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_info_alternates
argument_list|(
name|get_object_directory
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_sha1_file
specifier|static
name|char
modifier|*
name|find_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|name
argument_list|,
name|st
argument_list|)
condition|)
return|return
name|name
return|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|name
operator|=
name|alt
operator|->
name|name
expr_stmt|;
name|fill_sha1_path
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|alt
operator|->
name|base
argument_list|,
name|st
argument_list|)
condition|)
return|return
name|alt
operator|->
name|base
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|pack_used_ctr
specifier|static
name|int
name|pack_used_ctr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pack_mapped
specifier|static
name|unsigned
name|long
name|pack_mapped
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|packed_git
name|struct
name|packed_git
modifier|*
name|packed_git
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|check_packed_git_idx
specifier|static
name|int
name|check_packed_git_idx
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|unsigned
name|long
modifier|*
name|idx_size_
parameter_list|,
name|void
modifier|*
modifier|*
name|idx_map_
parameter_list|)
block|{
name|void
modifier|*
name|idx_map
decl_stmt|;
name|unsigned
name|int
modifier|*
name|index
decl_stmt|;
name|unsigned
name|long
name|idx_size
decl_stmt|;
name|int
name|nr
decl_stmt|,
name|i
decl_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|idx_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|idx_map
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|idx_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx_map
operator|==
name|MAP_FAILED
condition|)
return|return
operator|-
literal|1
return|;
name|index
operator|=
name|idx_map
expr_stmt|;
operator|*
name|idx_map_
operator|=
name|idx_map
expr_stmt|;
operator|*
name|idx_size_
operator|=
name|idx_size
expr_stmt|;
comment|/* check index map */
if|if
condition|(
name|idx_size
operator|<
literal|4
operator|*
literal|256
operator|+
literal|20
operator|+
literal|20
condition|)
return|return
name|error
argument_list|(
literal|"index file too small"
argument_list|)
return|;
name|nr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|n
init|=
name|ntohl
argument_list|(
name|index
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|nr
condition|)
return|return
name|error
argument_list|(
literal|"non-monotonic index"
argument_list|)
return|;
name|nr
operator|=
name|n
expr_stmt|;
block|}
comment|/* 	 * Total size: 	 *  - 256 index entries 4 bytes each 	 *  - 24-byte entries * nr (20-byte sha1 + 4-byte offset) 	 *  - 20-byte SHA1 of the packfile 	 *  - 20-byte SHA1 file checksum 	 */
if|if
condition|(
name|idx_size
operator|!=
literal|4
operator|*
literal|256
operator|+
name|nr
operator|*
literal|24
operator|+
literal|20
operator|+
literal|20
condition|)
return|return
name|error
argument_list|(
literal|"wrong index file size"
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unuse_one_packed_git
specifier|static
name|int
name|unuse_one_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|,
modifier|*
name|lru
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pack_use_cnt
operator|||
operator|!
name|p
operator|->
name|pack_base
condition|)
continue|continue;
if|if
condition|(
operator|!
name|lru
operator|||
name|p
operator|->
name|pack_last_used
operator|<
name|lru
operator|->
name|pack_last_used
condition|)
name|lru
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lru
condition|)
return|return
literal|0
return|;
name|munmap
argument_list|(
name|lru
operator|->
name|pack_base
argument_list|,
name|lru
operator|->
name|pack_size
argument_list|)
expr_stmt|;
name|lru
operator|->
name|pack_base
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|unuse_packed_git
name|void
name|unuse_packed_git
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|pack_use_cnt
operator|--
expr_stmt|;
block|}
end_function
begin_function
DECL|function|use_packed_git
name|int
name|use_packed_git
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|pack_size
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
comment|/* We created the struct before we had the pack */
name|stat
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|die
argument_list|(
literal|"packfile %s not a regular file"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|p
operator|->
name|pack_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|pack_base
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|;
name|struct
name|pack_header
modifier|*
name|hdr
decl_stmt|;
name|pack_mapped
operator|+=
name|p
operator|->
name|pack_size
expr_stmt|;
while|while
condition|(
name|packed_git_limit
operator|<
name|pack_mapped
operator|&&
name|unuse_one_packed_git
argument_list|()
condition|)
empty_stmt|;
comment|/* nothing */
name|fd
operator|=
name|open
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"packfile %s cannot be opened"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"packfile %s cannot be opened"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|!=
name|p
operator|->
name|pack_size
condition|)
name|die
argument_list|(
literal|"packfile %s size mismatch."
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|map
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|p
operator|->
name|pack_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|MAP_FAILED
condition|)
name|die
argument_list|(
literal|"packfile %s cannot be mapped."
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|p
operator|->
name|pack_base
operator|=
name|map
expr_stmt|;
comment|/* Check if we understand this pack file.  If we don't we're 		 * likely too old to handle it. 		 */
name|hdr
operator|=
name|map
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_signature
operator|!=
name|htonl
argument_list|(
name|PACK_SIGNATURE
argument_list|)
condition|)
name|die
argument_list|(
literal|"packfile %s isn't actually a pack."
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pack_version_ok
argument_list|(
name|hdr
operator|->
name|hdr_version
argument_list|)
condition|)
name|die
argument_list|(
literal|"packfile %s is version %i and not supported"
literal|" (try upgrading GIT to a newer version)"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|ntohl
argument_list|(
name|hdr
operator|->
name|hdr_version
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if the pack file matches with the index file. 		 * this is cheap. 		 */
if|if
condition|(
name|hashcmp
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|index_base
operator|)
operator|+
name|p
operator|->
name|index_size
operator|-
literal|40
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|pack_base
operator|+
name|p
operator|->
name|pack_size
operator|-
literal|20
argument_list|)
condition|)
block|{
name|die
argument_list|(
literal|"packfile %s does not match index."
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|pack_last_used
operator|=
name|pack_used_ctr
operator|++
expr_stmt|;
name|p
operator|->
name|pack_use_cnt
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|add_packed_git
name|struct
name|packed_git
modifier|*
name|add_packed_git
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|int
name|path_len
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|idx_size
decl_stmt|;
name|void
modifier|*
name|idx_map
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|check_packed_git_idx
argument_list|(
name|path
argument_list|,
operator|&
name|idx_size
argument_list|,
operator|&
name|idx_map
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* do we have a corresponding .pack file? */
name|strcpy
argument_list|(
name|path
operator|+
name|path_len
operator|-
literal|4
argument_list|,
literal|".pack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|munmap
argument_list|(
name|idx_map
argument_list|,
name|idx_size
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* ok, it looks sane as far as we can check without 	 * actually mapping the pack file. 	 */
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|path_len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|p
operator|->
name|index_size
operator|=
name|idx_size
expr_stmt|;
name|p
operator|->
name|pack_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|index_base
operator|=
name|idx_map
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|pack_base
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|pack_last_used
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pack_use_cnt
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pack_local
operator|=
name|local
expr_stmt|;
if|if
condition|(
operator|(
name|path_len
operator|>
literal|44
operator|)
operator|&&
operator|!
name|get_sha1_hex
argument_list|(
name|path
operator|+
name|path_len
operator|-
literal|44
argument_list|,
name|sha1
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|p
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|parse_pack_index
name|struct
name|packed_git
modifier|*
name|parse_pack_index
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|char
modifier|*
name|path
init|=
name|sha1_pack_index_name
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
return|return
name|parse_pack_index_file
argument_list|(
name|sha1
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_pack_index_file
name|struct
name|packed_git
modifier|*
name|parse_pack_index_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|idx_path
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|idx_size
decl_stmt|;
name|void
modifier|*
name|idx_map
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|check_packed_git_idx
argument_list|(
name|idx_path
argument_list|,
operator|&
name|idx_size
argument_list|,
operator|&
name|idx_map
argument_list|)
condition|)
return|return
name|NULL
return|;
name|path
operator|=
name|sha1_pack_name
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|p
operator|->
name|index_size
operator|=
name|idx_size
expr_stmt|;
name|p
operator|->
name|pack_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|index_base
operator|=
name|idx_map
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|pack_base
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|pack_last_used
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pack_use_cnt
operator|=
literal|0
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|install_packed_git
name|void
name|install_packed_git
parameter_list|(
name|struct
name|packed_git
modifier|*
name|pack
parameter_list|)
block|{
name|pack
operator|->
name|next
operator|=
name|packed_git
expr_stmt|;
name|packed_git
operator|=
name|pack
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_packed_git_one
specifier|static
name|void
name|prepare_packed_git_one
parameter_list|(
name|char
modifier|*
name|objdir
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/pack"
argument_list|,
name|objdir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|error
argument_list|(
literal|"unable to open object pack directory: %s: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|path
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
decl_stmt|;
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|has_extension
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".idx"
argument_list|)
condition|)
continue|continue;
comment|/* we have .idx.  Is it a file we can map? */
name|strcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|len
operator|+
name|namelen
operator|-
literal|4
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|p
condition|)
continue|continue;
name|p
operator|=
name|add_packed_git
argument_list|(
name|path
argument_list|,
name|len
operator|+
name|namelen
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
name|p
operator|->
name|next
operator|=
name|packed_git
expr_stmt|;
name|packed_git
operator|=
name|p
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function
begin_decl_stmt
DECL|variable|prepare_packed_git_run_once
specifier|static
name|int
name|prepare_packed_git_run_once
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|prepare_packed_git
name|void
name|prepare_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alternate_object_database
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|prepare_packed_git_run_once
condition|)
return|return;
name|prepare_packed_git_one
argument_list|(
name|get_object_directory
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prepare_alt_odb
argument_list|()
expr_stmt|;
for|for
control|(
name|alt
operator|=
name|alt_odb_list
init|;
name|alt
condition|;
name|alt
operator|=
name|alt
operator|->
name|next
control|)
block|{
name|alt
operator|->
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prepare_packed_git_one
argument_list|(
name|alt
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|->
name|name
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|prepare_packed_git_run_once
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|reprepare_packed_git
name|void
name|reprepare_packed_git
parameter_list|(
name|void
parameter_list|)
block|{
name|prepare_packed_git_run_once
operator|=
literal|0
expr_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_sha1_signature
name|int
name|check_sha1_signature
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|void
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|char
name|real_sha1
index|[
literal|20
index|]
decl_stmt|;
name|hash_sha1_file
argument_list|(
name|map
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|real_sha1
argument_list|)
expr_stmt|;
return|return
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|real_sha1
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|map_sha1_file
name|void
modifier|*
name|map_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|find_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|st
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
operator||
name|sha1_file_open_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* See if it works without O_NOATIME */
switch|switch
condition|(
name|sha1_file_open_flag
condition|)
block|{
default|default:
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
break|break;
comment|/* Fallthrough */
case|case
literal|0
case|:
return|return
name|NULL
return|;
block|}
comment|/* If it failed once, it will probably fail again. 		 * Stop using O_NOATIME 		 */
name|sha1_file_open_flag
operator|=
literal|0
expr_stmt|;
block|}
name|map
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|MAP_FAILED
condition|)
return|return
name|NULL
return|;
operator|*
name|size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
return|return
name|map
return|;
block|}
end_function
begin_function
DECL|function|legacy_loose_object
name|int
name|legacy_loose_object
parameter_list|(
name|unsigned
name|char
modifier|*
name|map
parameter_list|)
block|{
name|unsigned
name|int
name|word
decl_stmt|;
comment|/* 	 * Is it a zlib-compressed buffer? If so, the first byte 	 * must be 0x78 (15-bit window size, deflated), and the 	 * first 16-bit word is evenly divisible by 31 	 */
name|word
operator|=
operator|(
name|map
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|map
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|map
index|[
literal|0
index|]
operator|==
literal|0x78
operator|&&
operator|!
operator|(
name|word
operator|%
literal|31
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unpack_object_header_gently
name|unsigned
name|long
name|unpack_object_header_gently
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|shift
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|long
name|used
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|buf
index|[
name|used
operator|++
index|]
expr_stmt|;
operator|*
name|type
operator|=
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|7
expr_stmt|;
name|size
operator|=
name|c
operator|&
literal|15
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|len
operator|<=
name|used
condition|)
return|return
literal|0
return|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|<=
name|shift
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|buf
index|[
name|used
operator|++
index|]
expr_stmt|;
name|size
operator|+=
operator|(
name|c
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
return|return
name|used
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_header
specifier|static
name|int
name|unpack_sha1_header
parameter_list|(
name|z_stream
modifier|*
name|stream
parameter_list|,
name|unsigned
name|char
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|mapsize
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|bufsiz
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|used
decl_stmt|;
specifier|static
specifier|const
name|char
name|valid_loose_object_type
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
comment|/* OBJ_EXT */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* "commit", "tree", "blob", "tag" */
literal|0
block|,
comment|/* "delta" and others are invalid in a loose object */
block|}
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
comment|/* Get the data stream */
name|memset
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|next_in
operator|=
name|map
expr_stmt|;
name|stream
operator|->
name|avail_in
operator|=
name|mapsize
expr_stmt|;
name|stream
operator|->
name|next_out
operator|=
name|buffer
expr_stmt|;
name|stream
operator|->
name|avail_out
operator|=
name|bufsiz
expr_stmt|;
if|if
condition|(
name|legacy_loose_object
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|inflateInit
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|inflate
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|used
operator|=
name|unpack_object_header_gently
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used
operator|||
operator|!
name|valid_loose_object_type
index|[
name|type
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|map
operator|+=
name|used
expr_stmt|;
name|mapsize
operator|-=
name|used
expr_stmt|;
comment|/* Set up the stream for the rest.. */
name|stream
operator|->
name|next_in
operator|=
name|map
expr_stmt|;
name|stream
operator|->
name|avail_in
operator|=
name|mapsize
expr_stmt|;
name|inflateInit
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* And generate the fake traditional header */
name|stream
operator|->
name|total_out
operator|=
literal|1
operator|+
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|bufsiz
argument_list|,
literal|"%s %lu"
argument_list|,
name|type_names
index|[
name|type
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_rest
specifier|static
name|void
modifier|*
name|unpack_sha1_rest
parameter_list|(
name|z_stream
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|bytes
init|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
name|n
operator|=
name|stream
operator|->
name|total_out
operator|-
name|bytes
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|size
condition|)
name|n
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
name|bytes
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
name|size
condition|)
block|{
name|stream
operator|->
name|next_out
operator|=
name|buf
operator|+
name|bytes
expr_stmt|;
name|stream
operator|->
name|avail_out
operator|=
name|size
operator|-
name|bytes
expr_stmt|;
while|while
condition|(
name|inflate
argument_list|(
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
block|}
name|buf
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|inflateEnd
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_comment
comment|/*  * We used to just use "sscanf()", but that's actually way  * too permissive for what we want to check. So do an anal  * object header parse by hand.  */
end_comment
begin_function
DECL|function|parse_sha1_header
specifier|static
name|int
name|parse_sha1_header
parameter_list|(
name|char
modifier|*
name|hdr
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* 	 * The type can be at most ten bytes (including the  	 * terminating '\0' that we add), and is followed by 	 * a space.  	 */
name|i
operator|=
literal|10
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|hdr
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
operator|!
operator|--
name|i
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|type
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|type
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The length must follow immediately, and be in canonical 	 * decimal format (ie "010" is not valid). 	 */
name|size
operator|=
operator|*
name|hdr
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|9
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|size
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|long
name|c
init|=
operator|*
name|hdr
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|9
condition|)
break|break;
name|hdr
operator|++
expr_stmt|;
name|size
operator|=
name|size
operator|*
literal|10
operator|+
name|c
expr_stmt|;
block|}
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
comment|/* 	 * The length must be followed by a zero byte 	 */
return|return
operator|*
name|hdr
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unpack_sha1_file
name|void
modifier|*
name|unpack_sha1_file
parameter_list|(
name|void
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|mapsize
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|char
name|hdr
index|[
literal|8192
index|]
decl_stmt|;
name|ret
operator|=
name|unpack_sha1_header
argument_list|(
operator|&
name|stream
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|Z_OK
operator|||
name|parse_sha1_header
argument_list|(
name|hdr
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|unpack_sha1_rest
argument_list|(
operator|&
name|stream
argument_list|,
name|hdr
argument_list|,
operator|*
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_delta_base
specifier|static
name|unsigned
name|long
name|get_delta_base
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|enum
name|object_type
name|kind
parameter_list|,
name|unsigned
name|long
name|delta_obj_offset
parameter_list|,
name|unsigned
name|long
modifier|*
name|base_obj_offset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|base_info
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|pack_base
operator|+
name|offset
decl_stmt|;
name|unsigned
name|long
name|base_offset
decl_stmt|;
comment|/* there must be at least 20 bytes left regardless of delta type */
if|if
condition|(
name|p
operator|->
name|pack_size
operator|<=
name|offset
operator|+
literal|20
condition|)
name|die
argument_list|(
literal|"truncated pack file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|OBJ_OFS_DELTA
condition|)
block|{
name|unsigned
name|used
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
init|=
name|base_info
index|[
name|used
operator|++
index|]
decl_stmt|;
name|base_offset
operator|=
name|c
operator|&
literal|127
expr_stmt|;
while|while
condition|(
name|c
operator|&
literal|128
condition|)
block|{
name|base_offset
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|base_offset
operator|||
name|base_offset
operator|&
operator|~
operator|(
operator|~
literal|0UL
operator|>>
literal|7
operator|)
condition|)
name|die
argument_list|(
literal|"offset value overflow for delta base object"
argument_list|)
expr_stmt|;
name|c
operator|=
name|base_info
index|[
name|used
operator|++
index|]
expr_stmt|;
name|base_offset
operator|=
operator|(
name|base_offset
operator|<<
literal|7
operator|)
operator|+
operator|(
name|c
operator|&
literal|127
operator|)
expr_stmt|;
block|}
name|base_offset
operator|=
name|delta_obj_offset
operator|-
name|base_offset
expr_stmt|;
if|if
condition|(
name|base_offset
operator|>=
name|delta_obj_offset
condition|)
name|die
argument_list|(
literal|"delta base offset out of bound"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|used
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|OBJ_REF_DELTA
condition|)
block|{
comment|/* The base entry _must_ be in the same pack */
name|base_offset
operator|=
name|find_pack_entry_one
argument_list|(
name|base_info
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_offset
condition|)
name|die
argument_list|(
literal|"failed to find delta-pack base object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|base_info
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|20
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"I am totally screwed"
argument_list|)
expr_stmt|;
operator|*
name|base_obj_offset
operator|=
name|base_offset
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_comment
comment|/* forward declaration for a mutually recursive function */
end_comment
begin_function_decl
specifier|static
name|int
name|packed_object_info
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|packed_delta_info
specifier|static
name|int
name|packed_delta_info
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|enum
name|object_type
name|kind
parameter_list|,
name|unsigned
name|long
name|obj_offset
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|long
name|base_offset
decl_stmt|;
name|offset
operator|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|kind
argument_list|,
name|obj_offset
argument_list|,
operator|&
name|base_offset
argument_list|)
expr_stmt|;
comment|/* We choose to only get the type of the base object and 	 * ignore potentially corrupt pack file that expects the delta 	 * based on a base with a wrong size.  This saves tons of 	 * inflate() calls. 	 */
if|if
condition|(
name|packed_object_info
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot get info for delta-pack base"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizep
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
name|delta_head
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|long
name|result_size
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|int
name|st
decl_stmt|;
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|pack_base
operator|+
name|offset
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|p
operator|->
name|pack_size
operator|-
name|offset
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|delta_head
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|st
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|Z_STREAM_END
operator|)
operator|&&
name|stream
operator|.
name|total_out
operator|!=
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
condition|)
name|die
argument_list|(
literal|"delta data unpack-initial failed"
argument_list|)
expr_stmt|;
comment|/* Examine the initial part of the delta to figure out 		 * the result size. 		 */
name|data
operator|=
name|delta_head
expr_stmt|;
comment|/* ignore base size */
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|,
name|delta_head
operator|+
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the result size */
name|result_size
operator|=
name|get_delta_hdr_size
argument_list|(
operator|&
name|data
argument_list|,
name|delta_head
operator|+
sizeof|sizeof
argument_list|(
name|delta_head
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|result_size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unpack_object_header
specifier|static
name|unsigned
name|long
name|unpack_object_header
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|enum
name|object_type
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|long
name|used
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|pack_size
operator|<=
name|offset
condition|)
name|die
argument_list|(
literal|"object offset outside of pack file"
argument_list|)
expr_stmt|;
name|used
operator|=
name|unpack_object_header_gently
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|pack_base
operator|+
name|offset
argument_list|,
name|p
operator|->
name|pack_size
operator|-
name|offset
argument_list|,
name|type
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|used
condition|)
name|die
argument_list|(
literal|"object offset outside of pack file"
argument_list|)
expr_stmt|;
return|return
name|offset
operator|+
name|used
return|;
block|}
end_function
begin_function
DECL|function|packed_object_info_detail
name|void
name|packed_object_info_detail
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
name|unsigned
name|long
modifier|*
name|store_size
parameter_list|,
name|unsigned
name|int
modifier|*
name|delta_chain_length
parameter_list|,
name|unsigned
name|char
modifier|*
name|base_sha1
parameter_list|)
block|{
name|unsigned
name|long
name|obj_offset
decl_stmt|,
name|val
decl_stmt|;
name|unsigned
name|char
modifier|*
name|next_sha1
decl_stmt|;
name|enum
name|object_type
name|kind
decl_stmt|;
operator|*
name|delta_chain_length
operator|=
literal|0
expr_stmt|;
name|obj_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
operator|&
name|kind
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|die
argument_list|(
literal|"pack %s contains unknown object type %d"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|kind
argument_list|)
expr_stmt|;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
name|strcpy
argument_list|(
name|type
argument_list|,
name|type_names
index|[
name|kind
index|]
argument_list|)
expr_stmt|;
operator|*
name|store_size
operator|=
literal|0
expr_stmt|;
comment|/* notyet */
return|return;
case|case
name|OBJ_OFS_DELTA
case|:
name|get_delta_base
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|kind
argument_list|,
name|obj_offset
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|delta_chain_length
operator|==
literal|0
condition|)
block|{
comment|/* TODO: find base_sha1 as pointed by offset */
block|}
break|break;
case|case
name|OBJ_REF_DELTA
case|:
if|if
condition|(
name|p
operator|->
name|pack_size
operator|<=
name|offset
operator|+
literal|20
condition|)
name|die
argument_list|(
literal|"pack file %s records an incomplete delta base"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|next_sha1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|pack_base
operator|+
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|delta_chain_length
operator|==
literal|0
condition|)
name|hashcpy
argument_list|(
name|base_sha1
argument_list|,
name|next_sha1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|find_pack_entry_one
argument_list|(
name|next_sha1
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|obj_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
operator|(
operator|*
name|delta_chain_length
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|packed_object_info
specifier|static
name|int
name|packed_object_info
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|obj_offset
init|=
name|offset
decl_stmt|;
name|enum
name|object_type
name|kind
decl_stmt|;
name|offset
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|OBJ_OFS_DELTA
case|:
case|case
name|OBJ_REF_DELTA
case|:
return|return
name|packed_delta_info
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|kind
argument_list|,
name|obj_offset
argument_list|,
name|type
argument_list|,
name|sizep
argument_list|)
return|;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
name|strcpy
argument_list|(
name|type
argument_list|,
name|type_names
index|[
name|kind
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"pack %s contains unknown object type %d"
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|unpack_compressed_entry
specifier|static
name|void
modifier|*
name|unpack_compressed_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|st
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|pack_base
operator|+
name|offset
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|p
operator|->
name|pack_size
operator|-
name|offset
expr_stmt|;
name|stream
operator|.
name|next_out
operator|=
name|buffer
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|st
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|!=
name|Z_STREAM_END
operator|)
operator|||
name|stream
operator|.
name|total_out
operator|!=
name|size
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buffer
return|;
block|}
end_function
begin_function
DECL|function|unpack_delta_entry
specifier|static
name|void
modifier|*
name|unpack_delta_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|delta_size
parameter_list|,
name|enum
name|object_type
name|kind
parameter_list|,
name|unsigned
name|long
name|obj_offset
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|void
modifier|*
name|delta_data
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|unsigned
name|long
name|result_size
decl_stmt|,
name|base_size
decl_stmt|,
name|base_offset
decl_stmt|;
name|offset
operator|=
name|get_delta_base
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|kind
argument_list|,
name|obj_offset
argument_list|,
operator|&
name|base_offset
argument_list|)
expr_stmt|;
name|base
operator|=
name|unpack_entry
argument_list|(
name|p
argument_list|,
name|base_offset
argument_list|,
name|type
argument_list|,
operator|&
name|base_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|die
argument_list|(
literal|"failed to read delta base object at %lu from %s"
argument_list|,
name|base_offset
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|delta_data
operator|=
name|unpack_compressed_entry
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|delta_size
argument_list|)
expr_stmt|;
name|result
operator|=
name|patch_delta
argument_list|(
name|base
argument_list|,
name|base_size
argument_list|,
name|delta_data
argument_list|,
name|delta_size
argument_list|,
operator|&
name|result_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|die
argument_list|(
literal|"failed to apply delta"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|delta_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|result_size
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|unpack_entry
name|void
modifier|*
name|unpack_entry
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|obj_offset
init|=
name|offset
decl_stmt|;
name|enum
name|object_type
name|kind
decl_stmt|;
name|void
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
name|use_packed_git
argument_list|(
name|p
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot map packed file"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|unpack_object_header
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|OBJ_OFS_DELTA
case|:
case|case
name|OBJ_REF_DELTA
case|:
name|retval
operator|=
name|unpack_delta_entry
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|kind
argument_list|,
name|obj_offset
argument_list|,
name|type
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_COMMIT
case|:
case|case
name|OBJ_TREE
case|:
case|case
name|OBJ_BLOB
case|:
case|case
name|OBJ_TAG
case|:
name|strcpy
argument_list|(
name|type
argument_list|,
name|type_names
index|[
name|kind
index|]
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
name|retval
operator|=
name|unpack_compressed_entry
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"unknown object type %i in %s"
argument_list|,
name|kind
argument_list|,
name|p
operator|->
name|pack_name
argument_list|)
expr_stmt|;
block|}
name|unuse_packed_git
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|num_packed_objects
name|int
name|num_packed_objects
parameter_list|(
specifier|const
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
comment|/* See check_packed_git_idx() */
return|return
operator|(
name|p
operator|->
name|index_size
operator|-
literal|20
operator|-
literal|20
operator|-
literal|4
operator|*
literal|256
operator|)
operator|/
literal|24
return|;
block|}
end_function
begin_function
DECL|function|nth_packed_object_sha1
name|int
name|nth_packed_object_sha1
parameter_list|(
specifier|const
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|void
modifier|*
name|index
init|=
name|p
operator|->
name|index_base
operator|+
literal|256
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|num_packed_objects
argument_list|(
name|p
argument_list|)
operator|<=
name|n
condition|)
return|return
operator|-
literal|1
return|;
name|hashcpy
argument_list|(
name|sha1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
operator|+
operator|(
literal|24
operator|*
name|n
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_pack_entry_one
name|unsigned
name|long
name|find_pack_entry_one
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|level1_ofs
init|=
name|p
operator|->
name|index_base
decl_stmt|;
name|int
name|hi
init|=
name|ntohl
argument_list|(
name|level1_ofs
index|[
operator|*
name|sha1
index|]
argument_list|)
decl_stmt|;
name|int
name|lo
init|=
operator|(
operator|(
operator|*
name|sha1
operator|==
literal|0x0
operator|)
condition|?
literal|0
else|:
name|ntohl
argument_list|(
name|level1_ofs
index|[
operator|*
name|sha1
operator|-
literal|1
index|]
argument_list|)
operator|)
decl_stmt|;
name|void
modifier|*
name|index
init|=
name|p
operator|->
name|index_base
operator|+
literal|256
decl_stmt|;
do|do
block|{
name|int
name|mi
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|cmp
init|=
name|hashcmp
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
operator|+
operator|(
literal|24
operator|*
name|mi
operator|)
operator|+
literal|4
argument_list|,
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|index
operator|+
operator|(
literal|24
operator|*
name|mi
operator|)
operator|)
operator|)
argument_list|)
return|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
name|hi
operator|=
name|mi
expr_stmt|;
else|else
name|lo
operator|=
name|mi
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|lo
operator|<
name|hi
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|matches_pack_name
specifier|static
name|int
name|matches_pack_name
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|ig
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last_c
decl_stmt|,
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|pack_name
argument_list|,
name|ig
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|c
operator|=
name|p
operator|->
name|pack_name
operator|,
name|last_c
operator|=
name|c
init|;
operator|*
name|c
condition|;
control|)
if|if
condition|(
operator|*
name|c
operator|==
literal|'/'
condition|)
name|last_c
operator|=
operator|++
name|c
expr_stmt|;
else|else
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|last_c
argument_list|,
name|ig
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|find_pack_entry
specifier|static
name|int
name|find_pack_entry
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|pack_entry
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|ignore_packed
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ignore_packed
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|ig
decl_stmt|;
for|for
control|(
name|ig
operator|=
name|ignore_packed
init|;
operator|*
name|ig
condition|;
name|ig
operator|++
control|)
if|if
condition|(
operator|!
name|matches_pack_name
argument_list|(
name|p
argument_list|,
operator|*
name|ig
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|ig
condition|)
continue|continue;
block|}
name|offset
operator|=
name|find_pack_entry_one
argument_list|(
name|sha1
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|e
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|e
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|hashcpy
argument_list|(
name|e
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|find_sha1_pack
name|struct
name|packed_git
modifier|*
name|find_sha1_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|packed_git
modifier|*
name|packs
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|packs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|find_pack_entry_one
argument_list|(
name|sha1
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|p
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|sha1_loose_object_info
specifier|static
name|int
name|sha1_loose_object_info
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|unsigned
name|long
name|mapsize
decl_stmt|,
name|size
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|char
name|hdr
index|[
literal|128
index|]
decl_stmt|;
name|map
operator|=
name|map_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return
name|error
argument_list|(
literal|"unable to find %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|unpack_sha1_header
argument_list|(
operator|&
name|stream
argument_list|,
name|map
argument_list|,
name|mapsize
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
name|error
argument_list|(
literal|"unable to unpack %s header"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_sha1_header
argument_list|(
name|hdr
argument_list|,
name|type
argument_list|,
operator|&
name|size
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
name|error
argument_list|(
literal|"unable to parse %s header"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|sha1_object_info
name|int
name|sha1_object_info
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|pack_entry
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|reprepare_packed_git
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|sha1_loose_object_info
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|sizep
argument_list|)
return|;
block|}
if|if
condition|(
name|use_packed_git
argument_list|(
name|e
operator|.
name|p
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot map packed file"
argument_list|)
expr_stmt|;
name|status
operator|=
name|packed_object_info
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|e
operator|.
name|offset
argument_list|,
name|type
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
name|unuse_packed_git
argument_list|(
name|e
operator|.
name|p
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function
begin_function
DECL|function|read_packed_sha1
specifier|static
name|void
modifier|*
name|read_packed_sha1
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"cannot read sha1_file for %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|unpack_entry
argument_list|(
name|e
operator|.
name|p
argument_list|,
name|e
operator|.
name|offset
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|read_sha1_file
name|void
modifier|*
name|read_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|unsigned
name|long
name|mapsize
decl_stmt|;
name|void
modifier|*
name|map
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|struct
name|pack_entry
name|e
decl_stmt|;
if|if
condition|(
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
return|;
name|map
operator|=
name|map_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|buf
operator|=
name|unpack_sha1_file
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|map
argument_list|,
name|mapsize
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|reprepare_packed_git
argument_list|()
expr_stmt|;
if|if
condition|(
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
name|size
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|read_object_with_reference
name|void
modifier|*
name|read_object_with_reference
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|required_type
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
name|unsigned
name|char
modifier|*
name|actual_sha1_return
parameter_list|)
block|{
name|char
name|type
index|[
literal|20
index|]
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|isize
decl_stmt|;
name|unsigned
name|char
name|actual_sha1
index|[
literal|20
index|]
decl_stmt|;
name|hashcpy
argument_list|(
name|actual_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ref_length
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|ref_type
init|=
name|NULL
decl_stmt|;
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|actual_sha1
argument_list|,
name|type
argument_list|,
operator|&
name|isize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|required_type
argument_list|)
condition|)
block|{
operator|*
name|size
operator|=
name|isize
expr_stmt|;
if|if
condition|(
name|actual_sha1_return
condition|)
name|hashcpy
argument_list|(
name|actual_sha1_return
argument_list|,
name|actual_sha1
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
comment|/* Handle references */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|commit_type
argument_list|)
condition|)
name|ref_type
operator|=
literal|"tree "
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|tag_type
argument_list|)
condition|)
name|ref_type
operator|=
literal|"object "
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ref_length
operator|=
name|strlen
argument_list|(
name|ref_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|ref_type
argument_list|,
name|ref_length
argument_list|)
operator|||
name|get_sha1_hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
name|ref_length
argument_list|,
name|actual_sha1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Now we have the ID of the referred-to object in 		 * actual_sha1.  Check again. */
block|}
block|}
end_function
begin_function
DECL|function|write_sha1_file_prepare
specifier|static
name|void
name|write_sha1_file_prepare
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|char
modifier|*
name|hdr
parameter_list|,
name|int
modifier|*
name|hdrlen
parameter_list|)
block|{
name|SHA_CTX
name|c
decl_stmt|;
comment|/* Generate the header */
operator|*
name|hdrlen
operator|=
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|type
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Sha1.. */
name|SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|hdr
argument_list|,
operator|*
name|hdrlen
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SHA1_Final
argument_list|(
name|sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Link the tempfile to the final place, possibly creating the  * last directory level as you do so.  *  * Returns the errno on failure, 0 on success.  */
end_comment
begin_function
DECL|function|link_temp_to_file
specifier|static
name|int
name|link_temp_to_file
parameter_list|(
specifier|const
name|char
modifier|*
name|tmpfile
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|link
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Try to mkdir the last path component if that failed. 	 * 	 * Re-try the "link()" regardless of whether the mkdir 	 * succeeds, since a race might mean that somebody 	 * else succeeded. 	 */
name|ret
operator|=
name|errno
expr_stmt|;
name|dir
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
operator|*
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mkdir
argument_list|(
name|filename
argument_list|,
literal|0777
argument_list|)
operator|&&
name|adjust_shared_perm
argument_list|(
name|filename
argument_list|)
condition|)
block|{
operator|*
name|dir
operator|=
literal|'/'
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
operator|*
name|dir
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|!
name|link
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|errno
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Move the just written object into its final resting place  */
end_comment
begin_function
DECL|function|move_temp_to_file
name|int
name|move_temp_to_file
parameter_list|(
specifier|const
name|char
modifier|*
name|tmpfile
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|ret
init|=
name|link_temp_to_file
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
decl_stmt|;
comment|/* 	 * Coda hack - coda doesn't like cross-directory links, 	 * so we fall back to a rename, which will mean that it 	 * won't be able to check collisions, but that's not a 	 * big deal. 	 * 	 * The same holds for FAT formatted media. 	 * 	 * When this succeeds, we just return 0. We have nothing 	 * left to unlink. 	 */
if|if
condition|(
name|ret
operator|&&
name|ret
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
operator|!
name|rename
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|errno
expr_stmt|;
block|}
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|EEXIST
condition|)
block|{
return|return
name|error
argument_list|(
literal|"unable to write sha1 filename %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|ret
argument_list|)
argument_list|)
return|;
block|}
comment|/* FIXME!!! Collision check here ? */
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_buffer
specifier|static
name|int
name|write_buffer
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
condition|)
block|{
name|ssize_t
name|size
decl_stmt|;
name|size
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|error
argument_list|(
literal|"file write: disk full"
argument_list|)
return|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
return|return
name|error
argument_list|(
literal|"file write error (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
name|len
operator|-=
name|size
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_binary_header
specifier|static
name|int
name|write_binary_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|hdr
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|int
name|hdr_len
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|type
operator|<<
literal|4
operator|)
operator||
operator|(
name|len
operator|&
literal|15
operator|)
expr_stmt|;
name|len
operator|>>=
literal|4
expr_stmt|;
name|hdr_len
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
operator|*
name|hdr
operator|++
operator|=
name|c
operator||
literal|0x80
expr_stmt|;
name|hdr_len
operator|++
expr_stmt|;
name|c
operator|=
operator|(
name|len
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|len
operator|>>=
literal|7
expr_stmt|;
block|}
operator|*
name|hdr
operator|=
name|c
expr_stmt|;
return|return
name|hdr_len
return|;
block|}
end_function
begin_function
DECL|function|setup_object_header
specifier|static
name|void
name|setup_object_header
parameter_list|(
name|z_stream
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|int
name|obj_type
decl_stmt|,
name|hdr
decl_stmt|;
if|if
condition|(
name|use_legacy_headers
condition|)
block|{
while|while
condition|(
name|deflate
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|blob_type
argument_list|)
condition|)
name|obj_type
operator|=
name|OBJ_BLOB
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|tree_type
argument_list|)
condition|)
name|obj_type
operator|=
name|OBJ_TREE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|commit_type
argument_list|)
condition|)
name|obj_type
operator|=
name|OBJ_COMMIT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|tag_type
argument_list|)
condition|)
name|obj_type
operator|=
name|OBJ_TAG
expr_stmt|;
else|else
name|die
argument_list|(
literal|"trying to generate bogus object of type '%s'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|write_binary_header
argument_list|(
name|stream
operator|->
name|next_out
argument_list|,
name|obj_type
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stream
operator|->
name|total_out
operator|=
name|hdr
expr_stmt|;
name|stream
operator|->
name|next_out
operator|+=
name|hdr
expr_stmt|;
name|stream
operator|->
name|avail_out
operator|-=
name|hdr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hash_sha1_file
name|int
name|hash_sha1_file
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|unsigned
name|char
name|hdr
index|[
literal|50
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|write_sha1_file_prepare
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|,
name|hdr
argument_list|,
operator|&
name|hdrlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|write_sha1_file
name|int
name|write_sha1_file
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|returnsha1
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|compressed
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
specifier|static
name|char
name|tmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|unsigned
name|char
name|hdr
index|[
literal|50
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|hdrlen
decl_stmt|;
comment|/* Normally if we have it in the pack then we do not bother writing 	 * it out into .git/objects/??/?{38} file. 	 */
name|write_sha1_file_prepare
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|,
name|hdr
argument_list|,
operator|&
name|hdrlen
argument_list|)
expr_stmt|;
name|filename
operator|=
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|returnsha1
condition|)
name|hashcpy
argument_list|(
name|returnsha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_sha1_file
argument_list|(
name|sha1
argument_list|)
condition|)
return|return
literal|0
return|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * FIXME!!! We might do collision checking here, but we'd 		 * need to uncompress the old file and check it. Later. 		 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
return|return
name|error
argument_list|(
literal|"sha1 file %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
name|snprintf
argument_list|(
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"%s/obj_XXXXXX"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
return|return
name|error
argument_list|(
literal|"insufficient permission for adding an object to repository database %s\n"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
literal|"unable to create temporary sha1 filename %s: %s\n"
argument_list|,
name|tmpfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
comment|/* Set it up */
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|deflateInit
argument_list|(
operator|&
name|stream
argument_list|,
name|zlib_compression_level
argument_list|)
expr_stmt|;
name|size
operator|=
literal|8
operator|+
name|deflateBound
argument_list|(
operator|&
name|stream
argument_list|,
name|len
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
name|compressed
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Compress it */
name|stream
operator|.
name|next_out
operator|=
name|compressed
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
comment|/* First header.. */
name|stream
operator|.
name|next_in
operator|=
name|hdr
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|hdrlen
expr_stmt|;
name|setup_object_header
argument_list|(
operator|&
name|stream
argument_list|,
name|type
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Then the data itself.. */
name|stream
operator|.
name|next_in
operator|=
name|buf
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
name|deflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|size
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
if|if
condition|(
name|write_buffer
argument_list|(
name|fd
argument_list|,
name|compressed
argument_list|,
name|size
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to write sha1 file"
argument_list|)
expr_stmt|;
name|fchmod
argument_list|(
name|fd
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
return|return
name|move_temp_to_file
argument_list|(
name|tmpfile
argument_list|,
name|filename
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * We need to unpack and recompress the object for writing  * it out to a different file.  */
end_comment
begin_function
DECL|function|repack_object
specifier|static
name|void
modifier|*
name|repack_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|objsize
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|unpacked
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|char
name|type
index|[
literal|20
index|]
decl_stmt|;
name|char
name|hdr
index|[
literal|50
index|]
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
comment|/* need to unpack and recompress it by itself */
name|unpacked
operator|=
name|read_packed_sha1
argument_list|(
name|sha1
argument_list|,
name|type
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|sprintf
argument_list|(
name|hdr
argument_list|,
literal|"%s %lu"
argument_list|,
name|type
argument_list|,
name|len
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Set it up */
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|deflateInit
argument_list|(
operator|&
name|stream
argument_list|,
name|zlib_compression_level
argument_list|)
expr_stmt|;
name|size
operator|=
name|deflateBound
argument_list|(
operator|&
name|stream
argument_list|,
name|len
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Compress it */
name|stream
operator|.
name|next_out
operator|=
name|buf
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
comment|/* First header.. */
name|stream
operator|.
name|next_in
operator|=
operator|(
name|void
operator|*
operator|)
name|hdr
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|hdrlen
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
comment|/* Then the data itself.. */
name|stream
operator|.
name|next_in
operator|=
name|unpacked
expr_stmt|;
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|deflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_FINISH
argument_list|)
operator|==
name|Z_OK
condition|)
comment|/* nothing */
empty_stmt|;
name|deflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unpacked
argument_list|)
expr_stmt|;
operator|*
name|objsize
operator|=
name|stream
operator|.
name|total_out
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_function
DECL|function|write_sha1_to_fd
name|int
name|write_sha1_to_fd
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|unsigned
name|long
name|objsize
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|map_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|objsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|retval
operator|=
name|write_buffer
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|objsize
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|buf
argument_list|,
name|objsize
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|buf
operator|=
name|repack_object
argument_list|(
name|sha1
argument_list|,
operator|&
name|objsize
argument_list|)
expr_stmt|;
name|retval
operator|=
name|write_buffer
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|objsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|write_sha1_from_fd
name|int
name|write_sha1_from_fd
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|size_t
modifier|*
name|bufposn
parameter_list|)
block|{
name|char
name|tmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|local
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|unsigned
name|char
name|real_sha1
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
name|discard
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|SHA_CTX
name|c
decl_stmt|;
name|snprintf
argument_list|(
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"%s/obj_XXXXXX"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|)
expr_stmt|;
name|local
operator|=
name|mkstemp
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
return|return
name|error
argument_list|(
literal|"insufficient permission for adding an object to repository database %s\n"
argument_list|,
name|get_object_directory
argument_list|()
argument_list|)
return|;
else|else
return|return
name|error
argument_list|(
literal|"unable to create temporary sha1 filename %s: %s\n"
argument_list|,
name|tmpfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|stream
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|inflateInit
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|SHA1_Init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
do|do
block|{
name|ssize_t
name|size
decl_stmt|;
if|if
condition|(
operator|*
name|bufposn
condition|)
block|{
name|stream
operator|.
name|avail_in
operator|=
operator|*
name|bufposn
expr_stmt|;
name|stream
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
do|do
block|{
name|stream
operator|.
name|next_out
operator|=
name|discard
expr_stmt|;
name|stream
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|discard
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|stream
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
operator|&
name|c
argument_list|,
name|discard
argument_list|,
sizeof|sizeof
argument_list|(
name|discard
argument_list|)
operator|-
name|stream
operator|.
name|avail_out
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|stream
operator|.
name|avail_in
operator|&&
name|ret
operator|==
name|Z_OK
condition|)
do|;
if|if
condition|(
name|write_buffer
argument_list|(
name|local
argument_list|,
name|buffer
argument_list|,
operator|*
name|bufposn
operator|-
name|stream
operator|.
name|avail_in
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"unable to write sha1 file"
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|+
operator|*
name|bufposn
operator|-
name|stream
operator|.
name|avail_in
argument_list|,
name|stream
operator|.
name|avail_in
argument_list|)
expr_stmt|;
operator|*
name|bufposn
operator|=
name|stream
operator|.
name|avail_in
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
break|break;
block|}
name|size
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
operator|+
operator|*
name|bufposn
argument_list|,
name|bufsize
operator|-
operator|*
name|bufposn
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|close
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|error
argument_list|(
literal|"Connection closed?"
argument_list|)
return|;
name|perror
argument_list|(
literal|"Reading from connection"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|bufposn
operator|+=
name|size
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|inflateEnd
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|SHA1_Final
argument_list|(
name|real_sha1
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"File %s corrupted"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|real_sha1
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"File %s has bad hash"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
block|}
return|return
name|move_temp_to_file
argument_list|(
name|tmpfile
argument_list|,
name|sha1_file_name
argument_list|(
name|sha1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|has_pack_index
name|int
name|has_pack_index
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|sha1_pack_index_name
argument_list|(
name|sha1
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|has_pack_file
name|int
name|has_pack_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|sha1_pack_name
argument_list|(
name|sha1
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|has_sha1_pack
name|int
name|has_sha1_pack
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|ignore_packed
parameter_list|)
block|{
name|struct
name|pack_entry
name|e
decl_stmt|;
return|return
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|ignore_packed
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|has_sha1_file
name|int
name|has_sha1_file
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|pack_entry
name|e
decl_stmt|;
if|if
condition|(
name|find_pack_entry
argument_list|(
name|sha1
argument_list|,
operator|&
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|find_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|st
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * reads from fd as long as possible into a supplied buffer of size bytes.  * If necessary the buffer's size is increased using realloc()  *  * returns 0 if anything went fine and -1 otherwise  *  * NOTE: both buf and size may change, but even when -1 is returned  * you still have to free() it yourself.  */
end_comment
begin_function
DECL|function|read_pipe
name|int
name|read_pipe
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
modifier|*
name|return_buf
parameter_list|,
name|unsigned
name|long
modifier|*
name|return_size
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
operator|*
name|return_buf
decl_stmt|;
name|unsigned
name|long
name|size
init|=
operator|*
name|return_size
decl_stmt|;
name|int
name|iret
decl_stmt|;
name|unsigned
name|long
name|off
init|=
literal|0
decl_stmt|;
do|do
block|{
name|iret
operator|=
name|xread
argument_list|(
name|fd
argument_list|,
name|buf
operator|+
name|off
argument_list|,
name|size
operator|-
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|iret
operator|>
literal|0
condition|)
block|{
name|off
operator|+=
name|iret
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|size
condition|)
block|{
name|size
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|iret
operator|>
literal|0
condition|)
do|;
operator|*
name|return_buf
operator|=
name|buf
expr_stmt|;
operator|*
name|return_size
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|iret
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|index_pipe
name|int
name|index_pipe
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|write_object
parameter_list|)
block|{
name|unsigned
name|long
name|size
init|=
literal|4096
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|read_pipe
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|blob_type
expr_stmt|;
if|if
condition|(
name|write_object
condition|)
name|ret
operator|=
name|write_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|hash_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|index_fd
name|int
name|index_fd
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|int
name|write_object
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|size
init|=
name|st
operator|->
name|st_size
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|buf
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|buf
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|MAP_FAILED
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|type
condition|)
name|type
operator|=
name|blob_type
expr_stmt|;
if|if
condition|(
name|write_object
condition|)
name|ret
operator|=
name|write_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|hash_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|munmap
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|index_path
name|int
name|index_path
parameter_list|(
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|int
name|write_object
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
switch|switch
condition|(
name|st
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"open(\"%s\"): %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|index_fd
argument_list|(
name|sha1
argument_list|,
name|fd
argument_list|,
name|st
argument_list|,
name|write_object
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"%s: failed to insert into database"
argument_list|,
name|path
argument_list|)
return|;
break|break;
case|case
name|S_IFLNK
case|:
name|target
operator|=
name|xmalloc
argument_list|(
name|st
operator|->
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlink
argument_list|(
name|path
argument_list|,
name|target
argument_list|,
name|st
operator|->
name|st_size
operator|+
literal|1
argument_list|)
operator|!=
name|st
operator|->
name|st_size
condition|)
block|{
name|char
modifier|*
name|errstr
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"readlink(\"%s\"): %s"
argument_list|,
name|path
argument_list|,
name|errstr
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|write_object
condition|)
name|hash_sha1_file
argument_list|(
name|target
argument_list|,
name|st
operator|->
name|st_size
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write_sha1_file
argument_list|(
name|target
argument_list|,
name|st
operator|->
name|st_size
argument_list|,
name|blob_type
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"%s: failed to insert into database"
argument_list|,
name|path
argument_list|)
return|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|error
argument_list|(
literal|"%s: unsupported file type"
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
end_unit
