begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"xdiff/xmacros.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"userdiff.h"
end_include
begin_include
include|#
directive|include
file|"sha1-array.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_function
DECL|function|compare_paths
specifier|static
name|int
name|compare_paths
parameter_list|(
specifier|const
name|struct
name|combine_diff_path
modifier|*
name|one
parameter_list|,
specifier|const
name|struct
name|diff_filespec
modifier|*
name|two
parameter_list|)
block|{
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|one
operator|->
name|mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|two
operator|->
name|mode
argument_list|)
condition|)
return|return
name|strcmp
argument_list|(
name|one
operator|->
name|path
argument_list|,
name|two
operator|->
name|path
argument_list|)
return|;
return|return
name|base_name_compare
argument_list|(
name|one
operator|->
name|path
argument_list|,
name|strlen
argument_list|(
name|one
operator|->
name|path
argument_list|)
argument_list|,
name|one
operator|->
name|mode
argument_list|,
name|two
operator|->
name|path
argument_list|,
name|strlen
argument_list|(
name|two
operator|->
name|path
argument_list|)
argument_list|,
name|two
operator|->
name|mode
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|intersect_paths
specifier|static
name|struct
name|combine_diff_path
modifier|*
name|intersect_paths
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|curr
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|num_parent
parameter_list|)
block|{
name|struct
name|diff_queue_struct
modifier|*
name|q
init|=
operator|&
name|diff_queued_diff
decl_stmt|;
name|struct
name|combine_diff_path
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|curr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cmp
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|diff_unmodified_pair
argument_list|(
name|q
operator|->
name|queue
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|path
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|path
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|combine_diff_path_size
argument_list|(
name|num_parent
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|path
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|parent
index|[
name|num_parent
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|path
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|p
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|parent
index|[
literal|0
index|]
argument_list|)
operator|*
name|num_parent
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|oid
operator|.
name|hash
argument_list|,
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|mode
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|status
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|status
expr_stmt|;
operator|*
name|tail
operator|=
name|p
expr_stmt|;
name|tail
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|curr
return|;
block|}
comment|/* 	 * paths in curr (linked list) and q->queue[] (array) are 	 * both sorted in the tree order. 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|tail
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cmp
operator|=
operator|(
operator|(
name|i
operator|>=
name|q
operator|->
name|nr
operator|)
condition|?
operator|-
literal|1
else|:
name|compare_paths
argument_list|(
name|p
argument_list|,
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|/* p->path not in q->queue[]; drop it */
operator|*
name|tail
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|/* q->queue[i] not in p->path; skip it */
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|hashcpy
argument_list|(
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|mode
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|status
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|status
expr_stmt|;
name|tail
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|curr
return|;
block|}
end_function
begin_comment
comment|/* Lines lost from parent */
end_comment
begin_struct
DECL|struct|lline
struct|struct
name|lline
block|{
DECL|member|next
DECL|member|prev
name|struct
name|lline
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|parent_map
name|unsigned
name|long
name|parent_map
decl_stmt|;
DECL|member|line
name|char
name|line
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Lines lost from current parent (before coalescing) */
end_comment
begin_struct
DECL|struct|plost
struct|struct
name|plost
block|{
DECL|member|lost_head
DECL|member|lost_tail
name|struct
name|lline
modifier|*
name|lost_head
decl_stmt|,
modifier|*
name|lost_tail
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Lines surviving in the merge result */
end_comment
begin_struct
DECL|struct|sline
struct|struct
name|sline
block|{
comment|/* Accumulated and coalesced lost lines */
DECL|member|lost
name|struct
name|lline
modifier|*
name|lost
decl_stmt|;
DECL|member|lenlost
name|int
name|lenlost
decl_stmt|;
DECL|member|plost
name|struct
name|plost
name|plost
decl_stmt|;
DECL|member|bol
name|char
modifier|*
name|bol
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
comment|/* bit 0 up to (N-1) are on if the parent has this line (i.e. 	 * we did not change it). 	 * bit N is used for "interesting" lines, including context. 	 * bit (N+1) is used for "do not show deletion before this". 	 */
DECL|member|flag
name|unsigned
name|long
name|flag
decl_stmt|;
DECL|member|p_lno
name|unsigned
name|long
modifier|*
name|p_lno
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|match_string_spaces
specifier|static
name|int
name|match_string_spaces
parameter_list|(
specifier|const
name|char
modifier|*
name|line1
parameter_list|,
name|int
name|len1
parameter_list|,
specifier|const
name|char
modifier|*
name|line2
parameter_list|,
name|int
name|len2
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|XDF_WHITESPACE_FLAGS
condition|)
block|{
for|for
control|(
init|;
name|len1
operator|>
literal|0
operator|&&
name|XDL_ISSPACE
argument_list|(
name|line1
index|[
name|len1
operator|-
literal|1
index|]
argument_list|)
condition|;
name|len1
operator|--
control|)
empty_stmt|;
for|for
control|(
init|;
name|len2
operator|>
literal|0
operator|&&
name|XDL_ISSPACE
argument_list|(
name|line2
index|[
name|len2
operator|-
literal|1
index|]
argument_list|)
condition|;
name|len2
operator|--
control|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|XDF_IGNORE_WHITESPACE
operator||
name|XDF_IGNORE_WHITESPACE_CHANGE
operator|)
operator|)
condition|)
return|return
operator|(
name|len1
operator|==
name|len2
operator|&&
operator|!
name|memcmp
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|,
name|len1
argument_list|)
operator|)
return|;
while|while
condition|(
name|len1
operator|>
literal|0
operator|&&
name|len2
operator|>
literal|0
condition|)
block|{
name|len1
operator|--
expr_stmt|;
name|len2
operator|--
expr_stmt|;
if|if
condition|(
name|XDL_ISSPACE
argument_list|(
name|line1
index|[
name|len1
index|]
argument_list|)
operator|||
name|XDL_ISSPACE
argument_list|(
name|line2
index|[
name|len2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|XDF_IGNORE_WHITESPACE_CHANGE
operator|)
operator|&&
operator|(
operator|!
name|XDL_ISSPACE
argument_list|(
name|line1
index|[
name|len1
index|]
argument_list|)
operator|||
operator|!
name|XDL_ISSPACE
argument_list|(
name|line2
index|[
name|len2
index|]
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|len1
operator|>
literal|0
operator|&&
name|XDL_ISSPACE
argument_list|(
name|line1
index|[
name|len1
index|]
argument_list|)
condition|;
name|len1
operator|--
control|)
empty_stmt|;
for|for
control|(
init|;
name|len2
operator|>
literal|0
operator|&&
name|XDL_ISSPACE
argument_list|(
name|line2
index|[
name|len2
index|]
argument_list|)
condition|;
name|len2
operator|--
control|)
empty_stmt|;
block|}
if|if
condition|(
name|line1
index|[
name|len1
index|]
operator|!=
name|line2
index|[
name|len2
index|]
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|XDF_IGNORE_WHITESPACE
condition|)
block|{
comment|/* Consume remaining spaces */
for|for
control|(
init|;
name|len1
operator|>
literal|0
operator|&&
name|XDL_ISSPACE
argument_list|(
name|line1
index|[
name|len1
operator|-
literal|1
index|]
argument_list|)
condition|;
name|len1
operator|--
control|)
empty_stmt|;
for|for
control|(
init|;
name|len2
operator|>
literal|0
operator|&&
name|XDL_ISSPACE
argument_list|(
name|line2
index|[
name|len2
operator|-
literal|1
index|]
argument_list|)
condition|;
name|len2
operator|--
control|)
empty_stmt|;
block|}
comment|/* We matched full line1 and line2 */
if|if
condition|(
operator|!
name|len1
operator|&&
operator|!
name|len2
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_enum
DECL|enum|coalesce_direction
DECL|enumerator|MATCH
DECL|enumerator|BASE
DECL|enumerator|NEW
enum|enum
name|coalesce_direction
block|{
name|MATCH
block|,
name|BASE
block|,
name|NEW
block|}
enum|;
end_enum
begin_comment
comment|/* Coalesce new lines into base by finding LCS */
end_comment
begin_function
DECL|function|coalesce_lines
specifier|static
name|struct
name|lline
modifier|*
name|coalesce_lines
parameter_list|(
name|struct
name|lline
modifier|*
name|base
parameter_list|,
name|int
modifier|*
name|lenbase
parameter_list|,
name|struct
name|lline
modifier|*
name|new
parameter_list|,
name|int
name|lennew
parameter_list|,
name|unsigned
name|long
name|parent
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
name|int
modifier|*
modifier|*
name|lcs
decl_stmt|;
name|enum
name|coalesce_direction
modifier|*
modifier|*
name|directions
decl_stmt|;
name|struct
name|lline
modifier|*
name|baseend
decl_stmt|,
modifier|*
name|newend
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|origbaselen
init|=
operator|*
name|lenbase
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
name|base
return|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
operator|*
name|lenbase
operator|=
name|lennew
expr_stmt|;
return|return
name|new
return|;
block|}
comment|/* 	 * Coalesce new lines into base by finding the LCS 	 * - Create the table to run dynamic programming 	 * - Compute the LCS 	 * - Then reverse read the direction structure: 	 *   - If we have MATCH, assign parent to base flag, and consume 	 *   both baseend and newend 	 *   - Else if we have BASE, consume baseend 	 *   - Else if we have NEW, insert newend lline into base and 	 *   consume newend 	 */
name|lcs
operator|=
name|xcalloc
argument_list|(
name|origbaselen
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|directions
operator|=
name|xcalloc
argument_list|(
name|origbaselen
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|enum
name|coalesce_direction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origbaselen
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|lcs
index|[
name|i
index|]
operator|=
name|xcalloc
argument_list|(
name|lennew
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|directions
index|[
name|i
index|]
operator|=
name|xcalloc
argument_list|(
name|lennew
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|enum
name|coalesce_direction
argument_list|)
argument_list|)
expr_stmt|;
name|directions
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|BASE
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|lennew
operator|+
literal|1
condition|;
name|j
operator|++
control|)
name|directions
index|[
literal|0
index|]
index|[
name|j
index|]
operator|=
name|NEW
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|baseend
operator|=
name|base
init|;
name|i
operator|<
name|origbaselen
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|newend
operator|=
name|new
init|;
name|j
operator|<
name|lennew
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|match_string_spaces
argument_list|(
name|baseend
operator|->
name|line
argument_list|,
name|baseend
operator|->
name|len
argument_list|,
name|newend
operator|->
name|line
argument_list|,
name|newend
operator|->
name|len
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|lcs
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|lcs
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|directions
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|MATCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lcs
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|>=
name|lcs
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
condition|)
block|{
name|lcs
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|lcs
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|directions
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|NEW
expr_stmt|;
block|}
else|else
block|{
name|lcs
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|lcs
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
expr_stmt|;
name|directions
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|BASE
expr_stmt|;
block|}
if|if
condition|(
name|newend
operator|->
name|next
condition|)
name|newend
operator|=
name|newend
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|baseend
operator|->
name|next
condition|)
name|baseend
operator|=
name|baseend
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origbaselen
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|lcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lcs
argument_list|)
expr_stmt|;
comment|/* At this point, baseend and newend point to the end of each lists */
name|i
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
operator|||
name|j
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|directions
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|MATCH
condition|)
block|{
name|baseend
operator|->
name|parent_map
operator||=
literal|1
operator|<<
name|parent
expr_stmt|;
name|baseend
operator|=
name|baseend
operator|->
name|prev
expr_stmt|;
name|newend
operator|=
name|newend
operator|->
name|prev
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|directions
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|NEW
condition|)
block|{
name|struct
name|lline
modifier|*
name|lline
decl_stmt|;
name|lline
operator|=
name|newend
expr_stmt|;
comment|/* Remove lline from new list and update newend */
if|if
condition|(
name|lline
operator|->
name|prev
condition|)
name|lline
operator|->
name|prev
operator|->
name|next
operator|=
name|lline
operator|->
name|next
expr_stmt|;
else|else
name|new
operator|=
name|lline
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lline
operator|->
name|next
condition|)
name|lline
operator|->
name|next
operator|->
name|prev
operator|=
name|lline
operator|->
name|prev
expr_stmt|;
name|newend
operator|=
name|lline
operator|->
name|prev
expr_stmt|;
name|j
operator|--
expr_stmt|;
comment|/* Add lline to base list */
if|if
condition|(
name|baseend
condition|)
block|{
name|lline
operator|->
name|next
operator|=
name|baseend
operator|->
name|next
expr_stmt|;
name|lline
operator|->
name|prev
operator|=
name|baseend
expr_stmt|;
if|if
condition|(
name|lline
operator|->
name|prev
condition|)
name|lline
operator|->
name|prev
operator|->
name|next
operator|=
name|lline
expr_stmt|;
block|}
else|else
block|{
name|lline
operator|->
name|next
operator|=
name|base
expr_stmt|;
name|base
operator|=
name|lline
expr_stmt|;
block|}
operator|(
operator|*
name|lenbase
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|lline
operator|->
name|next
condition|)
name|lline
operator|->
name|next
operator|->
name|prev
operator|=
name|lline
expr_stmt|;
block|}
else|else
block|{
name|baseend
operator|=
name|baseend
operator|->
name|prev
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
name|newend
operator|=
name|new
expr_stmt|;
while|while
condition|(
name|newend
condition|)
block|{
name|struct
name|lline
modifier|*
name|lline
init|=
name|newend
decl_stmt|;
name|newend
operator|=
name|newend
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|lline
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origbaselen
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|directions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|directions
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
end_function
begin_function
DECL|function|grab_blob
specifier|static
name|char
modifier|*
name|grab_blob
parameter_list|(
specifier|const
name|struct
name|object_id
modifier|*
name|oid
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|,
name|struct
name|userdiff_driver
modifier|*
name|textconv
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|blob
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|blob
operator|=
name|xmalloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|snprintf
argument_list|(
name|blob
argument_list|,
literal|100
argument_list|,
literal|"Subproject commit %s\n"
argument_list|,
name|oid_to_hex
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_null_oid
argument_list|(
name|oid
argument_list|)
condition|)
block|{
comment|/* deleted blob */
operator|*
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|xcalloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|textconv
condition|)
block|{
name|struct
name|diff_filespec
modifier|*
name|df
init|=
name|alloc_filespec
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|fill_filespec
argument_list|(
name|df
argument_list|,
name|oid
operator|->
name|hash
argument_list|,
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|fill_textconv
argument_list|(
name|textconv
argument_list|,
name|df
argument_list|,
operator|&
name|blob
argument_list|)
expr_stmt|;
name|free_filespec
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blob
operator|=
name|read_sha1_file
argument_list|(
name|oid
operator|->
name|hash
argument_list|,
operator|&
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"object '%s' is not a blob!"
argument_list|,
name|oid_to_hex
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|blob
return|;
block|}
end_function
begin_function
DECL|function|append_lost
specifier|static
name|void
name|append_lost
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|lline
modifier|*
name|lline
decl_stmt|;
name|unsigned
name|long
name|this_mask
init|=
operator|(
literal|1UL
operator|<<
name|n
operator|)
decl_stmt|;
if|if
condition|(
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|len
operator|--
expr_stmt|;
name|lline
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lline
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lline
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|lline
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|lline
operator|->
name|prev
operator|=
name|sline
operator|->
name|plost
operator|.
name|lost_tail
expr_stmt|;
if|if
condition|(
name|lline
operator|->
name|prev
condition|)
name|lline
operator|->
name|prev
operator|->
name|next
operator|=
name|lline
expr_stmt|;
else|else
name|sline
operator|->
name|plost
operator|.
name|lost_head
operator|=
name|lline
expr_stmt|;
name|sline
operator|->
name|plost
operator|.
name|lost_tail
operator|=
name|lline
expr_stmt|;
name|sline
operator|->
name|plost
operator|.
name|len
operator|++
expr_stmt|;
name|lline
operator|->
name|parent_map
operator|=
name|this_mask
expr_stmt|;
name|memcpy
argument_list|(
name|lline
operator|->
name|line
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lline
operator|->
name|line
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|combine_diff_state
struct|struct
name|combine_diff_state
block|{
DECL|member|lno
name|unsigned
name|int
name|lno
decl_stmt|;
DECL|member|ob
DECL|member|on
DECL|member|nb
DECL|member|nn
name|int
name|ob
decl_stmt|,
name|on
decl_stmt|,
name|nb
decl_stmt|,
name|nn
decl_stmt|;
DECL|member|nmask
name|unsigned
name|long
name|nmask
decl_stmt|;
DECL|member|num_parent
name|int
name|num_parent
decl_stmt|;
DECL|member|n
name|int
name|n
decl_stmt|;
DECL|member|sline
name|struct
name|sline
modifier|*
name|sline
decl_stmt|;
DECL|member|lost_bucket
name|struct
name|sline
modifier|*
name|lost_bucket
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|consume_line
specifier|static
name|void
name|consume_line
parameter_list|(
name|void
modifier|*
name|state_
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|struct
name|combine_diff_state
modifier|*
name|state
init|=
name|state_
decl_stmt|;
if|if
condition|(
literal|5
operator|<
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
literal|"@@ -"
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|parse_hunk_header
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
operator|&
name|state
operator|->
name|ob
argument_list|,
operator|&
name|state
operator|->
name|on
argument_list|,
operator|&
name|state
operator|->
name|nb
argument_list|,
operator|&
name|state
operator|->
name|nn
argument_list|)
condition|)
return|return;
name|state
operator|->
name|lno
operator|=
name|state
operator|->
name|nb
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|nn
operator|==
literal|0
condition|)
block|{
comment|/* @@ -X,Y +N,0 @@ removed Y lines 			 * that would have come *after* line N 			 * in the result.  Our lost buckets hang 			 * to the line after the removed lines, 			 * 			 * Note that this is correct even when N == 0, 			 * in which case the hunk removes the first 			 * line in the file. 			 */
name|state
operator|->
name|lost_bucket
operator|=
operator|&
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|nb
condition|)
name|state
operator|->
name|nb
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|lost_bucket
operator|=
operator|&
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
operator|.
name|p_lno
condition|)
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
operator|.
name|p_lno
operator|=
name|xcalloc
argument_list|(
name|state
operator|->
name|num_parent
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
operator|.
name|p_lno
index|[
name|state
operator|->
name|n
index|]
operator|=
name|state
operator|->
name|ob
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|state
operator|->
name|lost_bucket
condition|)
return|return;
comment|/* not in any hunk yet */
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|append_lost
argument_list|(
name|state
operator|->
name|lost_bucket
argument_list|,
name|state
operator|->
name|n
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|lno
operator|-
literal|1
index|]
operator|.
name|flag
operator||=
name|state
operator|->
name|nmask
expr_stmt|;
name|state
operator|->
name|lno
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|combine_diff
specifier|static
name|void
name|combine_diff
parameter_list|(
specifier|const
name|struct
name|object_id
modifier|*
name|parent
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|mmfile_t
modifier|*
name|result_file
parameter_list|,
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|int
name|cnt
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|result_deleted
parameter_list|,
name|struct
name|userdiff_driver
modifier|*
name|textconv
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|long
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|p_lno
decl_stmt|,
name|lno
decl_stmt|;
name|unsigned
name|long
name|nmask
init|=
operator|(
literal|1UL
operator|<<
name|n
operator|)
decl_stmt|;
name|xpparam_t
name|xpp
decl_stmt|;
name|xdemitconf_t
name|xecfg
decl_stmt|;
name|mmfile_t
name|parent_file
decl_stmt|;
name|struct
name|combine_diff_state
name|state
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
if|if
condition|(
name|result_deleted
condition|)
return|return;
comment|/* result deleted */
name|parent_file
operator|.
name|ptr
operator|=
name|grab_blob
argument_list|(
name|parent
argument_list|,
name|mode
argument_list|,
operator|&
name|sz
argument_list|,
name|textconv
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|parent_file
operator|.
name|size
operator|=
name|sz
expr_stmt|;
name|memset
argument_list|(
operator|&
name|xpp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xpp
argument_list|)
argument_list|)
expr_stmt|;
name|xpp
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|memset
argument_list|(
operator|&
name|xecfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xecfg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|nmask
operator|=
name|nmask
expr_stmt|;
name|state
operator|.
name|sline
operator|=
name|sline
expr_stmt|;
name|state
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|num_parent
operator|=
name|num_parent
expr_stmt|;
name|state
operator|.
name|n
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|xdi_diff_outf
argument_list|(
operator|&
name|parent_file
argument_list|,
name|result_file
argument_list|,
name|consume_line
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|xpp
argument_list|,
operator|&
name|xecfg
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to generate combined diff for %s"
argument_list|,
name|oid_to_hex
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parent_file
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* Assign line numbers for this parent. 	 * 	 * sline[lno].p_lno[n] records the first line number 	 * (counting from 1) for parent N if the final hunk display 	 * started by showing sline[lno] (possibly showing the lost 	 * lines attached to it first). 	 */
for|for
control|(
name|lno
operator|=
literal|0
operator|,
name|p_lno
operator|=
literal|1
init|;
name|lno
operator|<=
name|cnt
condition|;
name|lno
operator|++
control|)
block|{
name|struct
name|lline
modifier|*
name|ll
decl_stmt|;
name|sline
index|[
name|lno
index|]
operator|.
name|p_lno
index|[
name|n
index|]
operator|=
name|p_lno
expr_stmt|;
comment|/* Coalesce new lines */
if|if
condition|(
name|sline
index|[
name|lno
index|]
operator|.
name|plost
operator|.
name|lost_head
condition|)
block|{
name|struct
name|sline
modifier|*
name|sl
init|=
operator|&
name|sline
index|[
name|lno
index|]
decl_stmt|;
name|sl
operator|->
name|lost
operator|=
name|coalesce_lines
argument_list|(
name|sl
operator|->
name|lost
argument_list|,
operator|&
name|sl
operator|->
name|lenlost
argument_list|,
name|sl
operator|->
name|plost
operator|.
name|lost_head
argument_list|,
name|sl
operator|->
name|plost
operator|.
name|len
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sl
operator|->
name|plost
operator|.
name|lost_head
operator|=
name|sl
operator|->
name|plost
operator|.
name|lost_tail
operator|=
name|NULL
expr_stmt|;
name|sl
operator|->
name|plost
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* How many lines would this sline advance the p_lno? */
name|ll
operator|=
name|sline
index|[
name|lno
index|]
operator|.
name|lost
expr_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
if|if
condition|(
name|ll
operator|->
name|parent_map
operator|&
name|nmask
condition|)
name|p_lno
operator|++
expr_stmt|;
comment|/* '-' means parent had it */
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|lno
operator|<
name|cnt
operator|&&
operator|!
operator|(
name|sline
index|[
name|lno
index|]
operator|.
name|flag
operator|&
name|nmask
operator|)
condition|)
name|p_lno
operator|++
expr_stmt|;
comment|/* no '+' means parent had it */
block|}
name|sline
index|[
name|lno
index|]
operator|.
name|p_lno
index|[
name|n
index|]
operator|=
name|p_lno
expr_stmt|;
comment|/* trailer */
block|}
end_function
begin_decl_stmt
DECL|variable|context
specifier|static
name|unsigned
name|long
name|context
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|combine_marker
specifier|static
name|char
name|combine_marker
init|=
literal|'@'
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|interesting
specifier|static
name|int
name|interesting
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|all_mask
parameter_list|)
block|{
comment|/* If some parents lost lines here, or if we have added to 	 * some parent, it is interesting. 	 */
return|return
operator|(
operator|(
name|sline
operator|->
name|flag
operator|&
name|all_mask
operator|)
operator|||
name|sline
operator|->
name|lost
operator|)
return|;
block|}
end_function
begin_function
DECL|function|adjust_hunk_tail
specifier|static
name|unsigned
name|long
name|adjust_hunk_tail
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|all_mask
parameter_list|,
name|unsigned
name|long
name|hunk_begin
parameter_list|,
name|unsigned
name|long
name|i
parameter_list|)
block|{
comment|/* i points at the first uninteresting line.  If the last line 	 * of the hunk was interesting only because it has some 	 * deletion, then it is not all that interesting for the 	 * purpose of giving trailing context lines.  This is because 	 * we output '-' line and then unmodified sline[i-1] itself in 	 * that case which gives us one extra context line. 	 */
if|if
condition|(
operator|(
name|hunk_begin
operator|+
literal|1
operator|<=
name|i
operator|)
operator|&&
operator|!
operator|(
name|sline
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|flag
operator|&
name|all_mask
operator|)
condition|)
name|i
operator|--
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|find_next
specifier|static
name|unsigned
name|long
name|find_next
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|mark
parameter_list|,
name|unsigned
name|long
name|i
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|look_for_uninteresting
parameter_list|)
block|{
comment|/* We have examined up to i-1 and are about to look at i. 	 * Find next interesting or uninteresting line.  Here, 	 * "interesting" does not mean interesting(), but marked by 	 * the give_context() function below (i.e. it includes context 	 * lines that are not interesting to interesting() function 	 * that are surrounded by interesting() ones. 	 */
while|while
condition|(
name|i
operator|<=
name|cnt
condition|)
if|if
condition|(
name|look_for_uninteresting
condition|?
operator|!
operator|(
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
else|:
operator|(
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
return|return
name|i
return|;
else|else
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|give_context
specifier|static
name|int
name|give_context
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|num_parent
parameter_list|)
block|{
name|unsigned
name|long
name|all_mask
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|mark
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|no_pre_delete
init|=
operator|(
literal|2UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
comment|/* Two groups of interesting lines may have a short gap of 	 * uninteresting lines.  Connect such groups to give them a 	 * bit of context. 	 * 	 * We first start from what the interesting() function says, 	 * and mark them with "mark", and paint context lines with the 	 * mark.  So interesting() would still say false for such context 	 * lines but they are treated as "interesting" in the end. 	 */
name|i
operator|=
name|find_next
argument_list|(
name|sline
argument_list|,
name|mark
argument_list|,
literal|0
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|i
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|i
operator|<=
name|cnt
condition|)
block|{
name|unsigned
name|long
name|j
init|=
operator|(
name|context
operator|<
name|i
operator|)
condition|?
operator|(
name|i
operator|-
name|context
operator|)
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|k
decl_stmt|;
comment|/* Paint a few lines before the first interesting line. */
while|while
condition|(
name|j
operator|<
name|i
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator||=
name|no_pre_delete
expr_stmt|;
name|sline
index|[
name|j
operator|++
index|]
operator|.
name|flag
operator||=
name|mark
expr_stmt|;
block|}
name|again
label|:
comment|/* we know up to i is to be included.  where does the 		 * next uninteresting one start? 		 */
name|j
operator|=
name|find_next
argument_list|(
name|sline
argument_list|,
name|mark
argument_list|,
name|i
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|j
condition|)
break|break;
comment|/* the rest are all interesting */
comment|/* lookahead context lines */
name|k
operator|=
name|find_next
argument_list|(
name|sline
argument_list|,
name|mark
argument_list|,
name|j
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
name|adjust_hunk_tail
argument_list|(
name|sline
argument_list|,
name|all_mask
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|j
operator|+
name|context
condition|)
block|{
comment|/* k is interesting and [j,k) are not, but 			 * paint them interesting because the gap is small. 			 */
while|while
condition|(
name|j
operator|<
name|k
condition|)
name|sline
index|[
name|j
operator|++
index|]
operator|.
name|flag
operator||=
name|mark
expr_stmt|;
name|i
operator|=
name|k
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* j is the first uninteresting line and there is 		 * no overlap beyond it within context lines.  Paint 		 * the trailing edge a bit. 		 */
name|i
operator|=
name|k
expr_stmt|;
name|k
operator|=
operator|(
name|j
operator|+
name|context
operator|<
name|cnt
operator|+
literal|1
operator|)
condition|?
name|j
operator|+
name|context
else|:
name|cnt
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|k
condition|)
name|sline
index|[
name|j
operator|++
index|]
operator|.
name|flag
operator||=
name|mark
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|make_hunks
specifier|static
name|int
name|make_hunks
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|)
block|{
name|unsigned
name|long
name|all_mask
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|mark
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|has_interesting
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|interesting
argument_list|(
operator|&
name|sline
index|[
name|i
index|]
argument_list|,
name|all_mask
argument_list|)
condition|)
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator||=
name|mark
expr_stmt|;
else|else
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&=
operator|~
name|mark
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dense
condition|)
return|return
name|give_context
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|)
return|;
comment|/* Look at each hunk, and if we have changes from only one 	 * parent, or the changes are the same from all but one 	 * parent, mark that uninteresting. 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|cnt
condition|)
block|{
name|unsigned
name|long
name|j
decl_stmt|,
name|hunk_begin
decl_stmt|,
name|hunk_end
decl_stmt|;
name|unsigned
name|long
name|same_diff
decl_stmt|;
while|while
condition|(
name|i
operator|<=
name|cnt
operator|&&
operator|!
operator|(
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|i
condition|)
break|break;
comment|/* No more interesting hunks */
name|hunk_begin
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
block|{
comment|/* Look beyond the end to see if there 				 * is an interesting line after this 				 * hunk within context span. 				 */
name|unsigned
name|long
name|la
decl_stmt|;
comment|/* lookahead */
name|int
name|contin
init|=
literal|0
decl_stmt|;
name|la
operator|=
name|adjust_hunk_tail
argument_list|(
name|sline
argument_list|,
name|all_mask
argument_list|,
name|hunk_begin
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|la
operator|=
operator|(
name|la
operator|+
name|context
operator|<
name|cnt
operator|+
literal|1
operator|)
condition|?
operator|(
name|la
operator|+
name|context
operator|)
else|:
name|cnt
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|la
operator|&&
name|j
operator|<=
operator|--
name|la
condition|)
block|{
if|if
condition|(
name|sline
index|[
name|la
index|]
operator|.
name|flag
operator|&
name|mark
condition|)
block|{
name|contin
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|contin
condition|)
break|break;
name|j
operator|=
name|la
expr_stmt|;
block|}
block|}
name|hunk_end
operator|=
name|j
expr_stmt|;
comment|/* [i..hunk_end) are interesting.  Now is it really 		 * interesting?  We check if there are only two versions 		 * and the result matches one of them.  That is, we look 		 * at: 		 *   (+) line, which records lines added to which parents; 		 *       this line appears in the result. 		 *   (-) line, which records from what parents the line 		 *       was removed; this line does not appear in the result. 		 * then check the set of parents the result has difference 		 * from, from all lines.  If there are lines that has 		 * different set of parents that the result has differences 		 * from, that means we have more than two versions. 		 * 		 * Even when we have only two versions, if the result does 		 * not match any of the parents, the it should be considered 		 * interesting.  In such a case, we would have all '+' line. 		 * After passing the above "two versions" test, that would 		 * appear as "the same set of parents" to be "all parents". 		 */
name|same_diff
operator|=
literal|0
expr_stmt|;
name|has_interesting
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|hunk_end
operator|&&
operator|!
name|has_interesting
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|long
name|this_diff
init|=
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&
name|all_mask
decl_stmt|;
name|struct
name|lline
modifier|*
name|ll
init|=
name|sline
index|[
name|j
index|]
operator|.
name|lost
decl_stmt|;
if|if
condition|(
name|this_diff
condition|)
block|{
comment|/* This has some changes.  Is it the 				 * same as others? 				 */
if|if
condition|(
operator|!
name|same_diff
condition|)
name|same_diff
operator|=
name|this_diff
expr_stmt|;
elseif|else
if|if
condition|(
name|same_diff
operator|!=
name|this_diff
condition|)
block|{
name|has_interesting
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|ll
operator|&&
operator|!
name|has_interesting
condition|)
block|{
comment|/* Lost this line from these parents; 				 * who are they?  Are they the same? 				 */
name|this_diff
operator|=
name|ll
operator|->
name|parent_map
expr_stmt|;
if|if
condition|(
operator|!
name|same_diff
condition|)
name|same_diff
operator|=
name|this_diff
expr_stmt|;
elseif|else
if|if
condition|(
name|same_diff
operator|!=
name|this_diff
condition|)
block|{
name|has_interesting
operator|=
literal|1
expr_stmt|;
block|}
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|has_interesting
operator|&&
name|same_diff
operator|!=
name|all_mask
condition|)
block|{
comment|/* This hunk is not that interesting after all */
for|for
control|(
name|j
operator|=
name|hunk_begin
init|;
name|j
operator|<
name|hunk_end
condition|;
name|j
operator|++
control|)
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&=
operator|~
name|mark
expr_stmt|;
block|}
name|i
operator|=
name|hunk_end
expr_stmt|;
block|}
name|has_interesting
operator|=
name|give_context
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|)
expr_stmt|;
return|return
name|has_interesting
return|;
block|}
end_function
begin_function
DECL|function|show_parent_lno
specifier|static
name|void
name|show_parent_lno
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|l0
parameter_list|,
name|unsigned
name|long
name|l1
parameter_list|,
name|int
name|n
parameter_list|,
name|unsigned
name|long
name|null_context
parameter_list|)
block|{
name|l0
operator|=
name|sline
index|[
name|l0
index|]
operator|.
name|p_lno
index|[
name|n
index|]
expr_stmt|;
name|l1
operator|=
name|sline
index|[
name|l1
index|]
operator|.
name|p_lno
index|[
name|n
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" -%lu,%lu"
argument_list|,
name|l0
argument_list|,
name|l1
operator|-
name|l0
operator|-
name|null_context
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hunk_comment_line
specifier|static
name|int
name|hunk_comment_line
parameter_list|(
specifier|const
name|char
modifier|*
name|bol
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|bol
condition|)
return|return
literal|0
return|;
name|ch
operator|=
operator|*
name|bol
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
name|isalpha
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'_'
operator|||
name|ch
operator|==
literal|'$'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|show_line_to_eol
specifier|static
name|void
name|show_line_to_eol
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|reset
parameter_list|)
block|{
name|int
name|saw_cr_at_eol
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|saw_cr_at_eol
operator|=
operator|(
name|len
operator|&&
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%.*s%s%s\n"
argument_list|,
name|len
operator|-
name|saw_cr_at_eol
argument_list|,
name|line
argument_list|,
name|reset
argument_list|,
name|saw_cr_at_eol
condition|?
literal|"\r"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump_sline
specifier|static
name|void
name|dump_sline
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
specifier|const
name|char
modifier|*
name|line_prefix
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|use_color
parameter_list|,
name|int
name|result_deleted
parameter_list|)
block|{
name|unsigned
name|long
name|mark
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|no_pre_delete
init|=
operator|(
literal|2UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|lno
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_frag
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_FRAGINFO
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_func
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_FUNCINFO
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_new
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_FILE_NEW
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_old
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_FILE_OLD
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_context
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_CONTEXT
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_reset
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_RESET
argument_list|)
decl_stmt|;
if|if
condition|(
name|result_deleted
condition|)
return|return;
comment|/* result deleted */
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|long
name|hunk_end
decl_stmt|;
name|unsigned
name|long
name|rlines
decl_stmt|;
specifier|const
name|char
modifier|*
name|hunk_comment
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|null_context
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|lno
operator|<=
name|cnt
operator|&&
operator|!
operator|(
name|sline
index|[
name|lno
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
block|{
if|if
condition|(
name|hunk_comment_line
argument_list|(
name|sline
index|[
name|lno
index|]
operator|.
name|bol
argument_list|)
condition|)
name|hunk_comment
operator|=
name|sline
index|[
name|lno
index|]
operator|.
name|bol
expr_stmt|;
name|lno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
name|lno
condition|)
break|break;
else|else
block|{
for|for
control|(
name|hunk_end
operator|=
name|lno
operator|+
literal|1
init|;
name|hunk_end
operator|<=
name|cnt
condition|;
name|hunk_end
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|sline
index|[
name|hunk_end
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
break|break;
block|}
name|rlines
operator|=
name|hunk_end
operator|-
name|lno
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|hunk_end
condition|)
name|rlines
operator|--
expr_stmt|;
comment|/* pointing at the last delete hunk */
if|if
condition|(
operator|!
name|context
condition|)
block|{
comment|/* 			 * Even when running with --unified=0, all 			 * lines in the hunk needs to be processed in 			 * the loop below in order to show the 			 * deletion recorded in lost_head.  However, 			 * we do not want to show the resulting line 			 * with all blank context markers in such a 			 * case.  Compensate. 			 */
name|unsigned
name|long
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|lno
init|;
name|j
operator|<
name|hunk_end
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&
operator|(
name|mark
operator|-
literal|1
operator|)
operator|)
condition|)
name|null_context
operator|++
expr_stmt|;
name|rlines
operator|-=
name|null_context
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|line_prefix
argument_list|,
name|c_frag
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|num_parent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|combine_marker
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|show_parent_lno
argument_list|(
name|sline
argument_list|,
name|lno
argument_list|,
name|hunk_end
argument_list|,
name|i
argument_list|,
name|null_context
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" +%lu,%lu "
argument_list|,
name|lno
operator|+
literal|1
argument_list|,
name|rlines
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|num_parent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|combine_marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunk_comment
condition|)
block|{
name|int
name|comment_end
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|hunk_comment
index|[
name|i
index|]
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
operator|!
name|ch
operator|||
name|ch
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
name|comment_end
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|comment_end
condition|)
name|printf
argument_list|(
literal|"%s%s %s%s"
argument_list|,
name|c_reset
argument_list|,
name|c_context
argument_list|,
name|c_reset
argument_list|,
name|c_func
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comment_end
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|hunk_comment
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
while|while
condition|(
name|lno
operator|<
name|hunk_end
condition|)
block|{
name|struct
name|lline
modifier|*
name|ll
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|long
name|p_mask
decl_stmt|;
name|struct
name|sline
modifier|*
name|sl
init|=
operator|&
name|sline
index|[
name|lno
operator|++
index|]
decl_stmt|;
name|ll
operator|=
operator|(
name|sl
operator|->
name|flag
operator|&
name|no_pre_delete
operator|)
condition|?
name|NULL
else|:
name|sl
operator|->
name|lost
expr_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|line_prefix
argument_list|,
name|c_old
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_parent
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ll
operator|->
name|parent_map
operator|&
operator|(
literal|1UL
operator|<<
name|j
operator|)
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|show_line_to_eol
argument_list|(
name|ll
operator|->
name|line
argument_list|,
operator|-
literal|1
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
name|lno
condition|)
break|break;
name|p_mask
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|line_prefix
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sl
operator|->
name|flag
operator|&
operator|(
name|mark
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* 				 * This sline was here to hang the 				 * lost lines in front of it. 				 */
if|if
condition|(
operator|!
name|context
condition|)
continue|continue;
name|fputs
argument_list|(
name|c_context
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|c_new
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_parent
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p_mask
operator|&
name|sl
operator|->
name|flag
condition|)
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|p_mask
operator|<<=
literal|1
expr_stmt|;
block|}
name|show_line_to_eol
argument_list|(
name|sl
operator|->
name|bol
argument_list|,
name|sl
operator|->
name|len
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|reuse_combine_diff
specifier|static
name|void
name|reuse_combine_diff
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
comment|/* We have already examined parent j and we know parent i 	 * and parent j are the same, so reuse the combined result 	 * of parent j for parent i. 	 */
name|unsigned
name|long
name|lno
decl_stmt|,
name|imask
decl_stmt|,
name|jmask
decl_stmt|;
name|imask
operator|=
operator|(
literal|1UL
operator|<<
name|i
operator|)
expr_stmt|;
name|jmask
operator|=
operator|(
literal|1UL
operator|<<
name|j
operator|)
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
init|;
name|lno
operator|<=
name|cnt
condition|;
name|lno
operator|++
control|)
block|{
name|struct
name|lline
modifier|*
name|ll
init|=
name|sline
operator|->
name|lost
decl_stmt|;
name|sline
operator|->
name|p_lno
index|[
name|i
index|]
operator|=
name|sline
operator|->
name|p_lno
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
if|if
condition|(
name|ll
operator|->
name|parent_map
operator|&
name|jmask
condition|)
name|ll
operator|->
name|parent_map
operator||=
name|imask
expr_stmt|;
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sline
operator|->
name|flag
operator|&
name|jmask
condition|)
name|sline
operator|->
name|flag
operator||=
name|imask
expr_stmt|;
name|sline
operator|++
expr_stmt|;
block|}
comment|/* the overall size of the file (sline[cnt]) */
name|sline
operator|->
name|p_lno
index|[
name|i
index|]
operator|=
name|sline
operator|->
name|p_lno
index|[
name|j
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump_quoted_path
specifier|static
name|void
name|dump_quoted_path
parameter_list|(
specifier|const
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|line_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|c_meta
parameter_list|,
specifier|const
name|char
modifier|*
name|c_reset
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|line_prefix
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|c_meta
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|quote_two_c_style
argument_list|(
operator|&
name|buf
argument_list|,
name|prefix
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_combined_header
specifier|static
name|void
name|show_combined_header
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|elem
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|line_prefix
parameter_list|,
name|int
name|mode_differs
parameter_list|,
name|int
name|show_file_header
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|int
name|abbrev
init|=
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|FULL_INDEX
argument_list|)
condition|?
name|GIT_SHA1_HEXSZ
else|:
name|DEFAULT_ABBREV
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_prefix
init|=
name|opt
operator|->
name|a_prefix
condition|?
name|opt
operator|->
name|a_prefix
else|:
literal|"a/"
decl_stmt|;
specifier|const
name|char
modifier|*
name|b_prefix
init|=
name|opt
operator|->
name|b_prefix
condition|?
name|opt
operator|->
name|b_prefix
else|:
literal|"b/"
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_meta
init|=
name|diff_get_color_opt
argument_list|(
name|opt
argument_list|,
name|DIFF_METAINFO
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_reset
init|=
name|diff_get_color_opt
argument_list|(
name|opt
argument_list|,
name|DIFF_RESET
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|abb
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rev
operator|->
name|loginfo
operator|&&
operator|!
name|rev
operator|->
name|no_commit_id
condition|)
name|show_log
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|dump_quoted_path
argument_list|(
name|dense
condition|?
literal|"diff --cc "
else|:
literal|"diff --combined "
argument_list|,
literal|""
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%sindex "
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|abb
operator|=
name|find_unique_abbrev
argument_list|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|i
condition|?
literal|","
else|:
literal|""
argument_list|,
name|abb
argument_list|)
expr_stmt|;
block|}
name|abb
operator|=
name|find_unique_abbrev
argument_list|(
name|elem
operator|->
name|oid
operator|.
name|hash
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"..%s%s\n"
argument_list|,
name|abb
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_differs
condition|)
block|{
name|deleted
operator|=
operator|!
name|elem
operator|->
name|mode
expr_stmt|;
comment|/* We say it was added if nobody had it */
name|added
operator|=
operator|!
name|deleted
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|added
operator|&&
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|status
operator|!=
name|DIFF_STATUS_ADDED
condition|)
name|added
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|added
condition|)
name|printf
argument_list|(
literal|"%s%snew file mode %06o"
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|,
name|elem
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|deleted
condition|)
name|printf
argument_list|(
literal|"%s%sdeleted file "
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mode "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s%06o"
argument_list|,
name|i
condition|?
literal|","
else|:
literal|""
argument_list|,
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elem
operator|->
name|mode
condition|)
name|printf
argument_list|(
literal|"..%06o"
argument_list|,
name|elem
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|show_file_header
condition|)
return|return;
if|if
condition|(
name|added
condition|)
name|dump_quoted_path
argument_list|(
literal|"--- "
argument_list|,
literal|""
argument_list|,
literal|"/dev/null"
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
else|else
name|dump_quoted_path
argument_list|(
literal|"--- "
argument_list|,
name|a_prefix
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleted
condition|)
name|dump_quoted_path
argument_list|(
literal|"+++ "
argument_list|,
literal|""
argument_list|,
literal|"/dev/null"
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
else|else
name|dump_quoted_path
argument_list|(
literal|"+++ "
argument_list|,
name|b_prefix
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|line_prefix
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_patch_diff
specifier|static
name|void
name|show_patch_diff
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|elem
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|,
name|int
name|working_tree_file
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|unsigned
name|long
name|result_size
decl_stmt|,
name|cnt
decl_stmt|,
name|lno
decl_stmt|;
name|int
name|result_deleted
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|sline
modifier|*
name|sline
decl_stmt|;
comment|/* survived lines */
name|int
name|mode_differs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|show_hunks
decl_stmt|;
name|mmfile_t
name|result_file
decl_stmt|;
name|struct
name|userdiff_driver
modifier|*
name|userdiff
decl_stmt|;
name|struct
name|userdiff_driver
modifier|*
name|textconv
init|=
name|NULL
decl_stmt|;
name|int
name|is_binary
decl_stmt|;
specifier|const
name|char
modifier|*
name|line_prefix
init|=
name|diff_line_prefix
argument_list|(
name|opt
argument_list|)
decl_stmt|;
name|context
operator|=
name|opt
operator|->
name|context
expr_stmt|;
name|userdiff
operator|=
name|userdiff_find_by_path
argument_list|(
name|elem
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|userdiff
condition|)
name|userdiff
operator|=
name|userdiff_find_by_name
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|ALLOW_TEXTCONV
argument_list|)
condition|)
name|textconv
operator|=
name|userdiff_get_textconv
argument_list|(
name|userdiff
argument_list|)
expr_stmt|;
comment|/* Read the result of merge first */
if|if
condition|(
operator|!
name|working_tree_file
condition|)
name|result
operator|=
name|grab_blob
argument_list|(
operator|&
name|elem
operator|->
name|oid
argument_list|,
name|elem
operator|->
name|mode
argument_list|,
operator|&
name|result_size
argument_list|,
name|textconv
argument_list|,
name|elem
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Used by diff-tree to read from the working tree */
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|elem
operator|->
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|deleted_file
goto|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|strbuf_readlink
argument_list|(
operator|&
name|buf
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"readlink(%s): %s"
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|result_size
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|result
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|elem
operator|->
name|mode
operator|=
name|canon_mode
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|struct
name|object_id
name|oid
decl_stmt|;
if|if
condition|(
name|resolve_gitlink_ref
argument_list|(
name|elem
operator|->
name|path
argument_list|,
literal|"HEAD"
argument_list|,
name|oid
operator|.
name|hash
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
name|grab_blob
argument_list|(
operator|&
name|elem
operator|->
name|oid
argument_list|,
name|elem
operator|->
name|mode
argument_list|,
operator|&
name|result_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|grab_blob
argument_list|(
operator|&
name|oid
argument_list|,
name|elem
operator|->
name|mode
argument_list|,
operator|&
name|result_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|textconv
condition|)
block|{
name|struct
name|diff_filespec
modifier|*
name|df
init|=
name|alloc_filespec
argument_list|(
name|elem
operator|->
name|path
argument_list|)
decl_stmt|;
name|fill_filespec
argument_list|(
name|df
argument_list|,
name|null_sha1
argument_list|,
literal|0
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|result_size
operator|=
name|fill_textconv
argument_list|(
name|textconv
argument_list|,
name|df
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|free_filespec
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|<=
operator|(
name|fd
operator|=
name|open
argument_list|(
name|elem
operator|->
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
condition|)
block|{
name|size_t
name|len
init|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
decl_stmt|;
name|ssize_t
name|done
decl_stmt|;
name|int
name|is_file
decl_stmt|,
name|i
decl_stmt|;
name|elem
operator|->
name|mode
operator|=
name|canon_mode
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
comment|/* if symlinks don't work, assume symlink if all parents 			 * are symlinks 			 */
name|is_file
operator|=
name|has_symlinks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|is_file
operator|&&
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|is_file
operator|=
operator|!
name|S_ISLNK
argument_list|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_file
condition|)
name|elem
operator|->
name|mode
operator|=
name|canon_mode
argument_list|(
name|S_IFLNK
argument_list|)
expr_stmt|;
name|result_size
operator|=
name|len
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|done
operator|=
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|result
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"read error '%s'"
argument_list|,
name|elem
operator|->
name|path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|done
operator|<
name|len
condition|)
name|die
argument_list|(
literal|"early EOF '%s'"
argument_list|,
name|elem
operator|->
name|path
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If not a fake symlink, apply filters, e.g. autocrlf */
if|if
condition|(
name|is_file
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
name|convert_to_git
argument_list|(
name|elem
operator|->
name|path
argument_list|,
name|result
argument_list|,
name|len
argument_list|,
operator|&
name|buf
argument_list|,
name|safe_crlf
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|result_size
operator|=
name|len
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|deleted_file
label|:
name|result_deleted
operator|=
literal|1
expr_stmt|;
name|result_size
operator|=
literal|0
expr_stmt|;
name|elem
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|elem
operator|->
name|mode
condition|)
block|{
name|mode_differs
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|textconv
condition|)
name|is_binary
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|userdiff
operator|->
name|binary
operator|!=
operator|-
literal|1
condition|)
name|is_binary
operator|=
name|userdiff
operator|->
name|binary
expr_stmt|;
else|else
block|{
name|is_binary
operator|=
name|buffer_is_binary
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|is_binary
operator|&&
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|buf
operator|=
name|grab_blob
argument_list|(
operator|&
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|oid
argument_list|,
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_is_binary
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
condition|)
name|is_binary
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_binary
condition|)
block|{
name|show_combined_header
argument_list|(
name|elem
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|,
name|rev
argument_list|,
name|line_prefix
argument_list|,
name|mode_differs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Binary files differ\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|cp
operator|=
name|result
init|;
name|cp
operator|<
name|result
operator|+
name|result_size
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|result_size
operator|&&
name|result
index|[
name|result_size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|cnt
operator|++
expr_stmt|;
comment|/* incomplete line */
name|sline
operator|=
name|xcalloc
argument_list|(
name|cnt
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sline
argument_list|)
argument_list|)
expr_stmt|;
name|sline
index|[
literal|0
index|]
operator|.
name|bol
operator|=
name|result
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
operator|,
name|cp
operator|=
name|result
init|;
name|cp
operator|<
name|result
operator|+
name|result_size
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|sline
index|[
name|lno
index|]
operator|.
name|len
operator|=
name|cp
operator|-
name|sline
index|[
name|lno
index|]
operator|.
name|bol
expr_stmt|;
name|lno
operator|++
expr_stmt|;
if|if
condition|(
name|lno
operator|<
name|cnt
condition|)
name|sline
index|[
name|lno
index|]
operator|.
name|bol
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result_size
operator|&&
name|result
index|[
name|result_size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|sline
index|[
name|cnt
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|result_size
operator|-
operator|(
name|sline
index|[
name|cnt
operator|-
literal|1
index|]
operator|.
name|bol
operator|-
name|result
operator|)
expr_stmt|;
name|result_file
operator|.
name|ptr
operator|=
name|result
expr_stmt|;
name|result_file
operator|.
name|size
operator|=
name|result_size
expr_stmt|;
comment|/* Even p_lno[cnt+1] is valid -- that is for the end line number 	 * for deletion hunk at the end. 	 */
name|sline
index|[
literal|0
index|]
operator|.
name|p_lno
operator|=
name|xcalloc
argument_list|(
operator|(
name|cnt
operator|+
literal|2
operator|)
operator|*
name|num_parent
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
init|;
name|lno
operator|<=
name|cnt
condition|;
name|lno
operator|++
control|)
name|sline
index|[
name|lno
operator|+
literal|1
index|]
operator|.
name|p_lno
operator|=
name|sline
index|[
name|lno
index|]
operator|.
name|p_lno
operator|+
name|num_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|oidcmp
argument_list|(
operator|&
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|oid
argument_list|,
operator|&
name|elem
operator|->
name|parent
index|[
name|j
index|]
operator|.
name|oid
argument_list|)
condition|)
block|{
name|reuse_combine_diff
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<=
name|j
condition|)
name|combine_diff
argument_list|(
operator|&
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|oid
argument_list|,
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|,
operator|&
name|result_file
argument_list|,
name|sline
argument_list|,
name|cnt
argument_list|,
name|i
argument_list|,
name|num_parent
argument_list|,
name|result_deleted
argument_list|,
name|textconv
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|opt
operator|->
name|xdl_opts
argument_list|)
expr_stmt|;
block|}
name|show_hunks
operator|=
name|make_hunks
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_hunks
operator|||
name|mode_differs
operator|||
name|working_tree_file
condition|)
block|{
name|show_combined_header
argument_list|(
name|elem
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|,
name|rev
argument_list|,
name|line_prefix
argument_list|,
name|mode_differs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dump_sline
argument_list|(
name|sline
argument_list|,
name|line_prefix
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|,
name|opt
operator|->
name|use_color
argument_list|,
name|result_deleted
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
init|;
name|lno
operator|<
name|cnt
condition|;
name|lno
operator|++
control|)
block|{
if|if
condition|(
name|sline
index|[
name|lno
index|]
operator|.
name|lost
condition|)
block|{
name|struct
name|lline
modifier|*
name|ll
init|=
name|sline
index|[
name|lno
index|]
operator|.
name|lost
decl_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
name|struct
name|lline
modifier|*
name|tmp
init|=
name|ll
decl_stmt|;
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|sline
index|[
literal|0
index|]
operator|.
name|p_lno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sline
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_raw_diff
specifier|static
name|void
name|show_raw_diff
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|p
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|int
name|line_termination
decl_stmt|,
name|inter_name_termination
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|line_prefix
init|=
name|diff_line_prefix
argument_list|(
name|opt
argument_list|)
decl_stmt|;
name|line_termination
operator|=
name|opt
operator|->
name|line_termination
expr_stmt|;
name|inter_name_termination
operator|=
literal|'\t'
expr_stmt|;
if|if
condition|(
operator|!
name|line_termination
condition|)
name|inter_name_termination
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|loginfo
operator|&&
operator|!
name|rev
operator|->
name|no_commit_id
condition|)
name|show_log
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
name|DIFF_FORMAT_RAW
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|line_prefix
argument_list|)
expr_stmt|;
comment|/* As many colons as there are parents */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
comment|/* Show the modes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%06o "
argument_list|,
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%06o"
argument_list|,
name|p
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* Show sha1's */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|diff_unique_abbrev
argument_list|(
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|oid
operator|.
name|hash
argument_list|,
name|opt
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|diff_unique_abbrev
argument_list|(
name|p
operator|->
name|oid
operator|.
name|hash
argument_list|,
name|opt
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_RAW
operator||
name|DIFF_FORMAT_NAME_STATUS
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|inter_name_termination
argument_list|)
expr_stmt|;
block|}
name|write_name_quoted
argument_list|(
name|p
operator|->
name|path
argument_list|,
name|stdout
argument_list|,
name|line_termination
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * The result (p->elem) is from the working tree and their  * parents are typically from multiple stages during a merge  * (i.e. diff-files) or the state in HEAD and in the index  * (i.e. diff-index).  */
end_comment
begin_function
DECL|function|show_combined_diff
name|void
name|show_combined_diff
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|p
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_RAW
operator||
name|DIFF_FORMAT_NAME
operator||
name|DIFF_FORMAT_NAME_STATUS
operator|)
condition|)
name|show_raw_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|rev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
name|DIFF_FORMAT_PATCH
condition|)
name|show_patch_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|,
literal|1
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_combined_pair
specifier|static
name|void
name|free_combined_pair
parameter_list|(
name|struct
name|diff_filepair
modifier|*
name|pair
parameter_list|)
block|{
name|free
argument_list|(
name|pair
operator|->
name|two
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * A combine_diff_path expresses N parents on the LHS against 1 merge  * result. Synthesize a diff_filepair that has N entries on the "one"  * side and 1 entry on the "two" side.  *  * In the future, we might want to add more data to combine_diff_path  * so that we can fill fields we are ignoring (most notably, size) here,  * but currently nobody uses it, so this should suffice for now.  */
end_comment
begin_function
DECL|function|combined_pair
specifier|static
name|struct
name|diff_filepair
modifier|*
name|combined_pair
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|p
parameter_list|,
name|int
name|num_parent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|diff_filepair
modifier|*
name|pair
decl_stmt|;
name|struct
name|diff_filespec
modifier|*
name|pool
decl_stmt|;
name|pair
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|=
name|xcalloc
argument_list|(
name|num_parent
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diff_filespec
argument_list|)
argument_list|)
expr_stmt|;
name|pair
operator|->
name|one
operator|=
name|pool
operator|+
literal|1
expr_stmt|;
name|pair
operator|->
name|two
operator|=
name|pool
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|pair
operator|->
name|one
index|[
name|i
index|]
operator|.
name|path
operator|=
name|p
operator|->
name|path
expr_stmt|;
name|pair
operator|->
name|one
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|pair
operator|->
name|one
index|[
name|i
index|]
operator|.
name|sha1
argument_list|,
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|oid
operator|.
name|hash
argument_list|)
expr_stmt|;
name|pair
operator|->
name|one
index|[
name|i
index|]
operator|.
name|sha1_valid
operator|=
operator|!
name|is_null_oid
argument_list|(
operator|&
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|oid
argument_list|)
expr_stmt|;
name|pair
operator|->
name|one
index|[
name|i
index|]
operator|.
name|has_more_entries
operator|=
literal|1
expr_stmt|;
block|}
name|pair
operator|->
name|one
index|[
name|num_parent
operator|-
literal|1
index|]
operator|.
name|has_more_entries
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|two
operator|->
name|path
operator|=
name|p
operator|->
name|path
expr_stmt|;
name|pair
operator|->
name|two
operator|->
name|mode
operator|=
name|p
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|pair
operator|->
name|two
operator|->
name|sha1
argument_list|,
name|p
operator|->
name|oid
operator|.
name|hash
argument_list|)
expr_stmt|;
name|pair
operator|->
name|two
operator|->
name|sha1_valid
operator|=
operator|!
name|is_null_oid
argument_list|(
operator|&
name|p
operator|->
name|oid
argument_list|)
expr_stmt|;
return|return
name|pair
return|;
block|}
end_function
begin_function
DECL|function|handle_combined_callback
specifier|static
name|void
name|handle_combined_callback
parameter_list|(
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|,
name|struct
name|combine_diff_path
modifier|*
name|paths
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|num_paths
parameter_list|)
block|{
name|struct
name|combine_diff_path
modifier|*
name|p
decl_stmt|;
name|struct
name|diff_queue_struct
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|q
operator|.
name|queue
operator|=
name|xcalloc
argument_list|(
name|num_paths
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diff_filepair
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|.
name|alloc
operator|=
name|num_paths
expr_stmt|;
name|q
operator|.
name|nr
operator|=
name|num_paths
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|q
operator|.
name|queue
index|[
name|i
operator|++
index|]
operator|=
name|combined_pair
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|)
expr_stmt|;
name|opt
operator|->
name|format_callback
argument_list|(
operator|&
name|q
argument_list|,
name|opt
argument_list|,
name|opt
operator|->
name|format_callback_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_paths
condition|;
name|i
operator|++
control|)
name|free_combined_pair
argument_list|(
name|q
operator|.
name|queue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|.
name|queue
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|path_path
specifier|static
specifier|const
name|char
modifier|*
name|path_path
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|struct
name|combine_diff_path
modifier|*
name|path
init|=
operator|(
expr|struct
name|combine_diff_path
operator|*
operator|)
name|obj
decl_stmt|;
return|return
name|path
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/* find set of paths that every parent touches */
end_comment
begin_function
DECL|function|find_paths_generic
specifier|static
name|struct
name|combine_diff_path
modifier|*
name|find_paths_generic
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|struct
name|sha1_array
modifier|*
name|parents
parameter_list|,
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|combine_diff_path
modifier|*
name|paths
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_parent
init|=
name|parents
operator|->
name|nr
decl_stmt|;
name|int
name|output_format
init|=
name|opt
operator|->
name|output_format
decl_stmt|;
specifier|const
name|char
modifier|*
name|orderfile
init|=
name|opt
operator|->
name|orderfile
decl_stmt|;
name|opt
operator|->
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
comment|/* tell diff_tree to emit paths in sorted (=tree) order */
name|opt
operator|->
name|orderfile
operator|=
name|NULL
expr_stmt|;
comment|/* D(A,P1...Pn) = D(A,P1) ^ ... ^ D(A,Pn)  (wrt paths) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * show stat against the first parent even when doing 		 * combined diff. 		 */
name|int
name|stat_opt
init|=
operator|(
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_NUMSTAT
operator||
name|DIFF_FORMAT_DIFFSTAT
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|stat_opt
condition|)
name|opt
operator|->
name|output_format
operator|=
name|stat_opt
expr_stmt|;
else|else
name|opt
operator|->
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|parents
operator|->
name|sha1
index|[
name|i
index|]
argument_list|,
name|sha1
argument_list|,
literal|""
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|paths
operator|=
name|intersect_paths
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
name|num_parent
argument_list|)
expr_stmt|;
comment|/* if showing diff, show it in requested order */
if|if
condition|(
name|opt
operator|->
name|output_format
operator|!=
name|DIFF_FORMAT_NO_OUTPUT
operator|&&
name|orderfile
condition|)
block|{
name|diffcore_order
argument_list|(
name|orderfile
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
name|opt
operator|->
name|output_format
operator|=
name|output_format
expr_stmt|;
name|opt
operator|->
name|orderfile
operator|=
name|orderfile
expr_stmt|;
return|return
name|paths
return|;
block|}
end_function
begin_comment
comment|/*  * find set of paths that everybody touches, assuming diff is run without  * rename/copy detection, etc, comparing all trees simultaneously (= faster).  */
end_comment
begin_function
DECL|function|find_paths_multitree
specifier|static
name|struct
name|combine_diff_path
modifier|*
name|find_paths_multitree
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|struct
name|sha1_array
modifier|*
name|parents
parameter_list|,
name|struct
name|diff_options
modifier|*
name|opt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nparent
init|=
name|parents
operator|->
name|nr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|parents_sha1
decl_stmt|;
name|struct
name|combine_diff_path
name|paths_head
decl_stmt|;
name|struct
name|strbuf
name|base
decl_stmt|;
name|parents_sha1
operator|=
name|xmalloc
argument_list|(
name|nparent
operator|*
sizeof|sizeof
argument_list|(
name|parents_sha1
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparent
condition|;
name|i
operator|++
control|)
name|parents_sha1
index|[
name|i
index|]
operator|=
name|parents
operator|->
name|sha1
index|[
name|i
index|]
expr_stmt|;
comment|/* fake list head, so worker can assume it is non-NULL */
name|paths_head
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|base
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|diff_tree_paths
argument_list|(
operator|&
name|paths_head
argument_list|,
name|sha1
argument_list|,
name|parents_sha1
argument_list|,
name|nparent
argument_list|,
operator|&
name|base
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parents_sha1
argument_list|)
expr_stmt|;
return|return
name|paths_head
operator|.
name|next
return|;
block|}
end_function
begin_function
DECL|function|diff_tree_combined
name|void
name|diff_tree_combined
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|struct
name|sha1_array
modifier|*
name|parents
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|struct
name|diff_options
name|diffopts
decl_stmt|;
name|struct
name|combine_diff_path
modifier|*
name|p
decl_stmt|,
modifier|*
name|paths
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_paths
decl_stmt|,
name|needsep
decl_stmt|,
name|show_log_first
decl_stmt|,
name|num_parent
init|=
name|parents
operator|->
name|nr
decl_stmt|;
name|int
name|need_generic_pathscan
decl_stmt|;
comment|/* nothing to do, if no parents */
if|if
condition|(
operator|!
name|num_parent
condition|)
return|return;
name|show_log_first
operator|=
operator|!
operator|!
name|rev
operator|->
name|loginfo
operator|&&
operator|!
name|rev
operator|->
name|no_commit_id
expr_stmt|;
name|needsep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|show_log_first
condition|)
block|{
name|show_log
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|verbose_header
operator|&&
name|opt
operator|->
name|output_format
operator|&&
name|opt
operator|->
name|output_format
operator|!=
name|DIFF_FORMAT_NO_OUTPUT
operator|&&
operator|!
name|commit_format_is_empty
argument_list|(
name|rev
operator|->
name|commit_format
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|diff_line_prefix
argument_list|(
name|opt
argument_list|)
argument_list|,
name|opt
operator|->
name|line_termination
argument_list|)
expr_stmt|;
block|}
name|diffopts
operator|=
operator|*
name|opt
expr_stmt|;
name|copy_pathspec
argument_list|(
operator|&
name|diffopts
operator|.
name|pathspec
argument_list|,
operator|&
name|opt
operator|->
name|pathspec
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diffopts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|DIFF_OPT_CLR
argument_list|(
operator|&
name|diffopts
argument_list|,
name|ALLOW_EXTERNAL
argument_list|)
expr_stmt|;
comment|/* find set of paths that everybody touches 	 * 	 * NOTE 	 * 	 * Diffcore transformations are bound to diff_filespec and logic 	 * comparing two entries - i.e. they do not apply directly to combine 	 * diff. 	 * 	 * If some of such transformations is requested - we launch generic 	 * path scanning, which works significantly slower compared to 	 * simultaneous all-trees-in-one-go scan in find_paths_multitree(). 	 * 	 * TODO some of the filters could be ported to work on 	 * combine_diff_paths - i.e. all functionality that skips paths, so in 	 * theory, we could end up having only multitree path scanning. 	 * 	 * NOTE please keep this semantically in sync with diffcore_std() 	 */
name|need_generic_pathscan
operator|=
name|opt
operator|->
name|skip_stat_unmatch
operator|||
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|FOLLOW_RENAMES
argument_list|)
operator|||
name|opt
operator|->
name|break_opt
operator|!=
operator|-
literal|1
operator|||
name|opt
operator|->
name|detect_rename
operator|||
name|opt
operator|->
name|pickaxe
operator|||
name|opt
operator|->
name|filter
expr_stmt|;
if|if
condition|(
name|need_generic_pathscan
condition|)
block|{
comment|/* 		 * NOTE generic case also handles --stat, as it computes 		 * diff(sha1,parent_i) for all i to do the job, specifically 		 * for parent0. 		 */
name|paths
operator|=
name|find_paths_generic
argument_list|(
name|sha1
argument_list|,
name|parents
argument_list|,
operator|&
name|diffopts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|stat_opt
decl_stmt|;
name|paths
operator|=
name|find_paths_multitree
argument_list|(
name|sha1
argument_list|,
name|parents
argument_list|,
operator|&
name|diffopts
argument_list|)
expr_stmt|;
comment|/* 		 * show stat against the first parent even 		 * when doing combined diff. 		 */
name|stat_opt
operator|=
operator|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_NUMSTAT
operator||
name|DIFF_FORMAT_DIFFSTAT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|stat_opt
condition|)
block|{
name|diffopts
operator|.
name|output_format
operator|=
name|stat_opt
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|parents
operator|->
name|sha1
index|[
literal|0
index|]
argument_list|,
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diffopts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|diffopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|orderfile
condition|)
name|diffcore_order
argument_list|(
name|opt
operator|->
name|orderfile
argument_list|)
expr_stmt|;
name|diff_flush
argument_list|(
operator|&
name|diffopts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* find out number of surviving paths */
for|for
control|(
name|num_paths
operator|=
literal|0
operator|,
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|num_paths
operator|++
expr_stmt|;
comment|/* order paths according to diffcore_order */
if|if
condition|(
name|opt
operator|->
name|orderfile
operator|&&
name|num_paths
condition|)
block|{
name|struct
name|obj_order
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
operator|*
name|num_paths
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|.
name|obj
operator|=
name|p
expr_stmt|;
name|order_objects
argument_list|(
name|opt
operator|->
name|orderfile
argument_list|,
name|path_path
argument_list|,
name|o
argument_list|,
name|num_paths
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_paths
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|o
index|[
name|i
index|]
operator|.
name|obj
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|o
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|obj
expr_stmt|;
block|}
name|p
operator|=
name|o
index|[
name|num_paths
operator|-
literal|1
index|]
operator|.
name|obj
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|paths
operator|=
name|o
index|[
literal|0
index|]
operator|.
name|obj
expr_stmt|;
name|free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_paths
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_RAW
operator||
name|DIFF_FORMAT_NAME
operator||
name|DIFF_FORMAT_NAME_STATUS
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|show_raw_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|needsep
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_NUMSTAT
operator||
name|DIFF_FORMAT_DIFFSTAT
operator|)
condition|)
name|needsep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
name|DIFF_FORMAT_CALLBACK
condition|)
name|handle_combined_callback
argument_list|(
name|opt
argument_list|,
name|paths
argument_list|,
name|num_parent
argument_list|,
name|num_paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
name|DIFF_FORMAT_PATCH
condition|)
block|{
if|if
condition|(
name|needsep
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|diff_line_prefix
argument_list|(
name|opt
argument_list|)
argument_list|,
name|opt
operator|->
name|line_termination
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|show_patch_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|,
literal|0
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean things up */
while|while
condition|(
name|paths
condition|)
block|{
name|struct
name|combine_diff_path
modifier|*
name|tmp
init|=
name|paths
decl_stmt|;
name|paths
operator|=
name|paths
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|free_pathspec
argument_list|(
operator|&
name|diffopts
operator|.
name|pathspec
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|diff_tree_combined_merge
name|void
name|diff_tree_combined_merge
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
init|=
name|get_saved_parents
argument_list|(
name|rev
argument_list|,
name|commit
argument_list|)
decl_stmt|;
name|struct
name|sha1_array
name|parents
init|=
name|SHA1_ARRAY_INIT
decl_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
name|sha1_array_append
argument_list|(
operator|&
name|parents
argument_list|,
name|get_object_hash
argument_list|(
name|parent
operator|->
name|item
operator|->
name|object
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|next
expr_stmt|;
block|}
name|diff_tree_combined
argument_list|(
name|get_object_hash
argument_list|(
name|commit
operator|->
name|object
argument_list|)
argument_list|,
operator|&
name|parents
argument_list|,
name|dense
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|sha1_array_clear
argument_list|(
operator|&
name|parents
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
