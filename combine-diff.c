begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"blob.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_function
DECL|function|intersect_paths
specifier|static
name|struct
name|combine_diff_path
modifier|*
name|intersect_paths
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|curr
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|num_parent
parameter_list|)
block|{
name|struct
name|diff_queue_struct
modifier|*
name|q
init|=
operator|&
name|diff_queued_diff
decl_stmt|;
name|struct
name|combine_diff_path
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|struct
name|combine_diff_path
modifier|*
name|list
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|list
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|diff_unmodified_pair
argument_list|(
name|q
operator|->
name|queue
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|path
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|path
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|combine_diff_path_size
argument_list|(
name|num_parent
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|path
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|parent
index|[
name|num_parent
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|path
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|p
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|parent
index|[
literal|0
index|]
argument_list|)
operator|*
name|num_parent
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|sha1
argument_list|,
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|mode
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|sha1
argument_list|,
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|mode
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|status
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|status
expr_stmt|;
operator|*
name|tail
operator|=
name|p
expr_stmt|;
name|tail
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
for|for
control|(
name|p
operator|=
name|curr
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|len
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|diff_unmodified_pair
argument_list|(
name|q
operator|->
name|queue
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|path
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|two
operator|->
name|path
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|p
operator|->
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|p
operator|->
name|path
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|hashcpy
argument_list|(
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|sha1
argument_list|,
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|mode
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|one
operator|->
name|mode
expr_stmt|;
name|p
operator|->
name|parent
index|[
name|n
index|]
operator|.
name|status
operator|=
name|q
operator|->
name|queue
index|[
name|i
index|]
operator|->
name|status
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|p
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|curr
return|;
block|}
end_function
begin_comment
comment|/* Lines lost from parent */
end_comment
begin_struct
DECL|struct|lline
struct|struct
name|lline
block|{
DECL|member|next
name|struct
name|lline
modifier|*
name|next
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|parent_map
name|unsigned
name|long
name|parent_map
decl_stmt|;
DECL|member|line
name|char
name|line
index|[
name|FLEX_ARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Lines surviving in the merge result */
end_comment
begin_struct
DECL|struct|sline
struct|struct
name|sline
block|{
DECL|member|lost_head
DECL|member|lost_tail
name|struct
name|lline
modifier|*
name|lost_head
decl_stmt|,
modifier|*
modifier|*
name|lost_tail
decl_stmt|;
DECL|member|bol
name|char
modifier|*
name|bol
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
comment|/* bit 0 up to (N-1) are on if the parent has this line (i.e. 	 * we did not change it). 	 * bit N is used for "interesting" lines, including context. 	 * bit (N+1) is used for "do not show deletion before this". 	 */
DECL|member|flag
name|unsigned
name|long
name|flag
decl_stmt|;
DECL|member|p_lno
name|unsigned
name|long
modifier|*
name|p_lno
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|grab_blob
specifier|static
name|char
modifier|*
name|grab_blob
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|long
modifier|*
name|size
parameter_list|)
block|{
name|char
modifier|*
name|blob
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
condition|)
block|{
comment|/* deleted blob */
operator|*
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|xcalloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
name|blob
operator|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_BLOB
condition|)
name|die
argument_list|(
literal|"object '%s' is not a blob!"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|blob
return|;
block|}
end_function
begin_function
DECL|function|append_lost
specifier|static
name|void
name|append_lost
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|lline
modifier|*
name|lline
decl_stmt|;
name|unsigned
name|long
name|this_mask
init|=
operator|(
literal|1UL
operator|<<
name|n
operator|)
decl_stmt|;
if|if
condition|(
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|len
operator|--
expr_stmt|;
comment|/* Check to see if we can squash things */
if|if
condition|(
name|sline
operator|->
name|lost_head
condition|)
block|{
name|struct
name|lline
modifier|*
name|last_one
init|=
name|NULL
decl_stmt|;
comment|/* We cannot squash it with earlier one */
for|for
control|(
name|lline
operator|=
name|sline
operator|->
name|lost_head
init|;
name|lline
condition|;
name|lline
operator|=
name|lline
operator|->
name|next
control|)
if|if
condition|(
name|lline
operator|->
name|parent_map
operator|&
name|this_mask
condition|)
name|last_one
operator|=
name|lline
expr_stmt|;
name|lline
operator|=
name|last_one
condition|?
name|last_one
operator|->
name|next
else|:
name|sline
operator|->
name|lost_head
expr_stmt|;
while|while
condition|(
name|lline
condition|)
block|{
if|if
condition|(
name|lline
operator|->
name|len
operator|==
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|lline
operator|->
name|line
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|lline
operator|->
name|parent_map
operator||=
name|this_mask
expr_stmt|;
return|return;
block|}
name|lline
operator|=
name|lline
operator|->
name|next
expr_stmt|;
block|}
block|}
name|lline
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lline
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lline
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|lline
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|lline
operator|->
name|parent_map
operator|=
name|this_mask
expr_stmt|;
name|memcpy
argument_list|(
name|lline
operator|->
name|line
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lline
operator|->
name|line
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|sline
operator|->
name|lost_tail
operator|=
name|lline
expr_stmt|;
name|sline
operator|->
name|lost_tail
operator|=
operator|&
name|lline
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|combine_diff_state
struct|struct
name|combine_diff_state
block|{
DECL|member|lno
name|unsigned
name|int
name|lno
decl_stmt|;
DECL|member|ob
DECL|member|on
DECL|member|nb
DECL|member|nn
name|int
name|ob
decl_stmt|,
name|on
decl_stmt|,
name|nb
decl_stmt|,
name|nn
decl_stmt|;
DECL|member|nmask
name|unsigned
name|long
name|nmask
decl_stmt|;
DECL|member|num_parent
name|int
name|num_parent
decl_stmt|;
DECL|member|n
name|int
name|n
decl_stmt|;
DECL|member|sline
name|struct
name|sline
modifier|*
name|sline
decl_stmt|;
DECL|member|lost_bucket
name|struct
name|sline
modifier|*
name|lost_bucket
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|consume_line
specifier|static
name|void
name|consume_line
parameter_list|(
name|void
modifier|*
name|state_
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|struct
name|combine_diff_state
modifier|*
name|state
init|=
name|state_
decl_stmt|;
if|if
condition|(
literal|5
operator|<
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
literal|"@@ -"
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|parse_hunk_header
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
operator|&
name|state
operator|->
name|ob
argument_list|,
operator|&
name|state
operator|->
name|on
argument_list|,
operator|&
name|state
operator|->
name|nb
argument_list|,
operator|&
name|state
operator|->
name|nn
argument_list|)
condition|)
return|return;
name|state
operator|->
name|lno
operator|=
name|state
operator|->
name|nb
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|nb
condition|)
comment|/* @@ -1,2 +0,0 @@ to remove the 			 * first two lines... 			 */
name|state
operator|->
name|nb
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|nn
operator|==
literal|0
condition|)
comment|/* @@ -X,Y +N,0 @@ removed Y lines 			 * that would have come *after* line N 			 * in the result.  Our lost buckets hang 			 * to the line after the removed lines, 			 */
name|state
operator|->
name|lost_bucket
operator|=
operator|&
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
index|]
expr_stmt|;
else|else
name|state
operator|->
name|lost_bucket
operator|=
operator|&
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
operator|.
name|p_lno
condition|)
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
operator|.
name|p_lno
operator|=
name|xcalloc
argument_list|(
name|state
operator|->
name|num_parent
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|nb
operator|-
literal|1
index|]
operator|.
name|p_lno
index|[
name|state
operator|->
name|n
index|]
operator|=
name|state
operator|->
name|ob
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|state
operator|->
name|lost_bucket
condition|)
return|return;
comment|/* not in any hunk yet */
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|append_lost
argument_list|(
name|state
operator|->
name|lost_bucket
argument_list|,
name|state
operator|->
name|n
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|state
operator|->
name|sline
index|[
name|state
operator|->
name|lno
operator|-
literal|1
index|]
operator|.
name|flag
operator||=
name|state
operator|->
name|nmask
expr_stmt|;
name|state
operator|->
name|lno
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|combine_diff
specifier|static
name|void
name|combine_diff
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|parent
parameter_list|,
name|mmfile_t
modifier|*
name|result_file
parameter_list|,
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|int
name|cnt
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|num_parent
parameter_list|)
block|{
name|unsigned
name|int
name|p_lno
decl_stmt|,
name|lno
decl_stmt|;
name|unsigned
name|long
name|nmask
init|=
operator|(
literal|1UL
operator|<<
name|n
operator|)
decl_stmt|;
name|xpparam_t
name|xpp
decl_stmt|;
name|xdemitconf_t
name|xecfg
decl_stmt|;
name|mmfile_t
name|parent_file
decl_stmt|;
name|xdemitcb_t
name|ecb
decl_stmt|;
name|struct
name|combine_diff_state
name|state
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
if|if
condition|(
operator|!
name|cnt
condition|)
return|return;
comment|/* result deleted */
name|parent_file
operator|.
name|ptr
operator|=
name|grab_blob
argument_list|(
name|parent
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
name|parent_file
operator|.
name|size
operator|=
name|sz
expr_stmt|;
name|xpp
operator|.
name|flags
operator|=
name|XDF_NEED_MINIMAL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|xecfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xecfg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|nmask
operator|=
name|nmask
expr_stmt|;
name|state
operator|.
name|sline
operator|=
name|sline
expr_stmt|;
name|state
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|num_parent
operator|=
name|num_parent
expr_stmt|;
name|state
operator|.
name|n
operator|=
name|n
expr_stmt|;
name|xdi_diff_outf
argument_list|(
operator|&
name|parent_file
argument_list|,
name|result_file
argument_list|,
name|consume_line
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|xpp
argument_list|,
operator|&
name|xecfg
argument_list|,
operator|&
name|ecb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parent_file
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* Assign line numbers for this parent. 	 * 	 * sline[lno].p_lno[n] records the first line number 	 * (counting from 1) for parent N if the final hunk display 	 * started by showing sline[lno] (possibly showing the lost 	 * lines attached to it first). 	 */
for|for
control|(
name|lno
operator|=
literal|0
operator|,
name|p_lno
operator|=
literal|1
init|;
name|lno
operator|<=
name|cnt
condition|;
name|lno
operator|++
control|)
block|{
name|struct
name|lline
modifier|*
name|ll
decl_stmt|;
name|sline
index|[
name|lno
index|]
operator|.
name|p_lno
index|[
name|n
index|]
operator|=
name|p_lno
expr_stmt|;
comment|/* How many lines would this sline advance the p_lno? */
name|ll
operator|=
name|sline
index|[
name|lno
index|]
operator|.
name|lost_head
expr_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
if|if
condition|(
name|ll
operator|->
name|parent_map
operator|&
name|nmask
condition|)
name|p_lno
operator|++
expr_stmt|;
comment|/* '-' means parent had it */
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|lno
operator|<
name|cnt
operator|&&
operator|!
operator|(
name|sline
index|[
name|lno
index|]
operator|.
name|flag
operator|&
name|nmask
operator|)
condition|)
name|p_lno
operator|++
expr_stmt|;
comment|/* no '+' means parent had it */
block|}
name|sline
index|[
name|lno
index|]
operator|.
name|p_lno
index|[
name|n
index|]
operator|=
name|p_lno
expr_stmt|;
comment|/* trailer */
block|}
end_function
begin_decl_stmt
DECL|variable|context
specifier|static
name|unsigned
name|long
name|context
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|combine_marker
specifier|static
name|char
name|combine_marker
init|=
literal|'@'
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|interesting
specifier|static
name|int
name|interesting
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|all_mask
parameter_list|)
block|{
comment|/* If some parents lost lines here, or if we have added to 	 * some parent, it is interesting. 	 */
return|return
operator|(
operator|(
name|sline
operator|->
name|flag
operator|&
name|all_mask
operator|)
operator|||
name|sline
operator|->
name|lost_head
operator|)
return|;
block|}
end_function
begin_function
DECL|function|adjust_hunk_tail
specifier|static
name|unsigned
name|long
name|adjust_hunk_tail
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|all_mask
parameter_list|,
name|unsigned
name|long
name|hunk_begin
parameter_list|,
name|unsigned
name|long
name|i
parameter_list|)
block|{
comment|/* i points at the first uninteresting line.  If the last line 	 * of the hunk was interesting only because it has some 	 * deletion, then it is not all that interesting for the 	 * purpose of giving trailing context lines.  This is because 	 * we output '-' line and then unmodified sline[i-1] itself in 	 * that case which gives us one extra context line. 	 */
if|if
condition|(
operator|(
name|hunk_begin
operator|+
literal|1
operator|<=
name|i
operator|)
operator|&&
operator|!
operator|(
name|sline
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|flag
operator|&
name|all_mask
operator|)
condition|)
name|i
operator|--
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|find_next
specifier|static
name|unsigned
name|long
name|find_next
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|mark
parameter_list|,
name|unsigned
name|long
name|i
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|look_for_uninteresting
parameter_list|)
block|{
comment|/* We have examined up to i-1 and are about to look at i. 	 * Find next interesting or uninteresting line.  Here, 	 * "interesting" does not mean interesting(), but marked by 	 * the give_context() function below (i.e. it includes context 	 * lines that are not interesting to interesting() function 	 * that are surrounded by interesting() ones. 	 */
while|while
condition|(
name|i
operator|<=
name|cnt
condition|)
if|if
condition|(
name|look_for_uninteresting
condition|?
operator|!
operator|(
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
else|:
operator|(
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
return|return
name|i
return|;
else|else
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function
begin_function
DECL|function|give_context
specifier|static
name|int
name|give_context
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|num_parent
parameter_list|)
block|{
name|unsigned
name|long
name|all_mask
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|mark
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|no_pre_delete
init|=
operator|(
literal|2UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
comment|/* Two groups of interesting lines may have a short gap of 	 * uninteresting lines.  Connect such groups to give them a 	 * bit of context. 	 * 	 * We first start from what the interesting() function says, 	 * and mark them with "mark", and paint context lines with the 	 * mark.  So interesting() would still say false for such context 	 * lines but they are treated as "interesting" in the end. 	 */
name|i
operator|=
name|find_next
argument_list|(
name|sline
argument_list|,
name|mark
argument_list|,
literal|0
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|i
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|i
operator|<=
name|cnt
condition|)
block|{
name|unsigned
name|long
name|j
init|=
operator|(
name|context
operator|<
name|i
operator|)
condition|?
operator|(
name|i
operator|-
name|context
operator|)
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|k
decl_stmt|;
comment|/* Paint a few lines before the first interesting line. */
while|while
condition|(
name|j
operator|<
name|i
condition|)
name|sline
index|[
name|j
operator|++
index|]
operator|.
name|flag
operator||=
name|mark
operator||
name|no_pre_delete
expr_stmt|;
name|again
label|:
comment|/* we know up to i is to be included.  where does the 		 * next uninteresting one start? 		 */
name|j
operator|=
name|find_next
argument_list|(
name|sline
argument_list|,
name|mark
argument_list|,
name|i
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|j
condition|)
break|break;
comment|/* the rest are all interesting */
comment|/* lookahead context lines */
name|k
operator|=
name|find_next
argument_list|(
name|sline
argument_list|,
name|mark
argument_list|,
name|j
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
name|adjust_hunk_tail
argument_list|(
name|sline
argument_list|,
name|all_mask
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|j
operator|+
name|context
condition|)
block|{
comment|/* k is interesting and [j,k) are not, but 			 * paint them interesting because the gap is small. 			 */
while|while
condition|(
name|j
operator|<
name|k
condition|)
name|sline
index|[
name|j
operator|++
index|]
operator|.
name|flag
operator||=
name|mark
expr_stmt|;
name|i
operator|=
name|k
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* j is the first uninteresting line and there is 		 * no overlap beyond it within context lines.  Paint 		 * the trailing edge a bit. 		 */
name|i
operator|=
name|k
expr_stmt|;
name|k
operator|=
operator|(
name|j
operator|+
name|context
operator|<
name|cnt
operator|+
literal|1
operator|)
condition|?
name|j
operator|+
name|context
else|:
name|cnt
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|k
condition|)
name|sline
index|[
name|j
operator|++
index|]
operator|.
name|flag
operator||=
name|mark
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|make_hunks
specifier|static
name|int
name|make_hunks
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|)
block|{
name|unsigned
name|long
name|all_mask
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|mark
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|has_interesting
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|interesting
argument_list|(
operator|&
name|sline
index|[
name|i
index|]
argument_list|,
name|all_mask
argument_list|)
condition|)
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator||=
name|mark
expr_stmt|;
else|else
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&=
operator|~
name|mark
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dense
condition|)
return|return
name|give_context
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|)
return|;
comment|/* Look at each hunk, and if we have changes from only one 	 * parent, or the changes are the same from all but one 	 * parent, mark that uninteresting. 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|cnt
condition|)
block|{
name|unsigned
name|long
name|j
decl_stmt|,
name|hunk_begin
decl_stmt|,
name|hunk_end
decl_stmt|;
name|unsigned
name|long
name|same_diff
decl_stmt|;
while|while
condition|(
name|i
operator|<=
name|cnt
operator|&&
operator|!
operator|(
name|sline
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|i
condition|)
break|break;
comment|/* No more interesting hunks */
name|hunk_begin
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
block|{
comment|/* Look beyond the end to see if there 				 * is an interesting line after this 				 * hunk within context span. 				 */
name|unsigned
name|long
name|la
decl_stmt|;
comment|/* lookahead */
name|int
name|contin
init|=
literal|0
decl_stmt|;
name|la
operator|=
name|adjust_hunk_tail
argument_list|(
name|sline
argument_list|,
name|all_mask
argument_list|,
name|hunk_begin
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|la
operator|=
operator|(
name|la
operator|+
name|context
operator|<
name|cnt
operator|+
literal|1
operator|)
condition|?
operator|(
name|la
operator|+
name|context
operator|)
else|:
name|cnt
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|<=
operator|--
name|la
condition|)
block|{
if|if
condition|(
name|sline
index|[
name|la
index|]
operator|.
name|flag
operator|&
name|mark
condition|)
block|{
name|contin
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|contin
condition|)
break|break;
name|j
operator|=
name|la
expr_stmt|;
block|}
block|}
name|hunk_end
operator|=
name|j
expr_stmt|;
comment|/* [i..hunk_end) are interesting.  Now is it really 		 * interesting?  We check if there are only two versions 		 * and the result matches one of them.  That is, we look 		 * at: 		 *   (+) line, which records lines added to which parents; 		 *       this line appears in the result. 		 *   (-) line, which records from what parents the line 		 *       was removed; this line does not appear in the result. 		 * then check the set of parents the result has difference 		 * from, from all lines.  If there are lines that has 		 * different set of parents that the result has differences 		 * from, that means we have more than two versions. 		 * 		 * Even when we have only two versions, if the result does 		 * not match any of the parents, the it should be considered 		 * interesting.  In such a case, we would have all '+' line. 		 * After passing the above "two versions" test, that would 		 * appear as "the same set of parents" to be "all parents". 		 */
name|same_diff
operator|=
literal|0
expr_stmt|;
name|has_interesting
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|hunk_end
operator|&&
operator|!
name|has_interesting
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|long
name|this_diff
init|=
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&
name|all_mask
decl_stmt|;
name|struct
name|lline
modifier|*
name|ll
init|=
name|sline
index|[
name|j
index|]
operator|.
name|lost_head
decl_stmt|;
if|if
condition|(
name|this_diff
condition|)
block|{
comment|/* This has some changes.  Is it the 				 * same as others? 				 */
if|if
condition|(
operator|!
name|same_diff
condition|)
name|same_diff
operator|=
name|this_diff
expr_stmt|;
elseif|else
if|if
condition|(
name|same_diff
operator|!=
name|this_diff
condition|)
block|{
name|has_interesting
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|ll
operator|&&
operator|!
name|has_interesting
condition|)
block|{
comment|/* Lost this line from these parents; 				 * who are they?  Are they the same? 				 */
name|this_diff
operator|=
name|ll
operator|->
name|parent_map
expr_stmt|;
if|if
condition|(
operator|!
name|same_diff
condition|)
name|same_diff
operator|=
name|this_diff
expr_stmt|;
elseif|else
if|if
condition|(
name|same_diff
operator|!=
name|this_diff
condition|)
block|{
name|has_interesting
operator|=
literal|1
expr_stmt|;
block|}
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|has_interesting
operator|&&
name|same_diff
operator|!=
name|all_mask
condition|)
block|{
comment|/* This hunk is not that interesting after all */
for|for
control|(
name|j
operator|=
name|hunk_begin
init|;
name|j
operator|<
name|hunk_end
condition|;
name|j
operator|++
control|)
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&=
operator|~
name|mark
expr_stmt|;
block|}
name|i
operator|=
name|hunk_end
expr_stmt|;
block|}
name|has_interesting
operator|=
name|give_context
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|)
expr_stmt|;
return|return
name|has_interesting
return|;
block|}
end_function
begin_function
DECL|function|show_parent_lno
specifier|static
name|void
name|show_parent_lno
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|l0
parameter_list|,
name|unsigned
name|long
name|l1
parameter_list|,
name|int
name|n
parameter_list|,
name|unsigned
name|long
name|null_context
parameter_list|)
block|{
name|l0
operator|=
name|sline
index|[
name|l0
index|]
operator|.
name|p_lno
index|[
name|n
index|]
expr_stmt|;
name|l1
operator|=
name|sline
index|[
name|l1
index|]
operator|.
name|p_lno
index|[
name|n
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" -%lu,%lu"
argument_list|,
name|l0
argument_list|,
name|l1
operator|-
name|l0
operator|-
name|null_context
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hunk_comment_line
specifier|static
name|int
name|hunk_comment_line
parameter_list|(
specifier|const
name|char
modifier|*
name|bol
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|bol
condition|)
return|return
literal|0
return|;
name|ch
operator|=
operator|*
name|bol
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
name|isalpha
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'_'
operator|||
name|ch
operator|==
literal|'$'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|show_line_to_eol
specifier|static
name|void
name|show_line_to_eol
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|reset
parameter_list|)
block|{
name|int
name|saw_cr_at_eol
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|saw_cr_at_eol
operator|=
operator|(
name|len
operator|&&
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%.*s%s%s\n"
argument_list|,
name|len
operator|-
name|saw_cr_at_eol
argument_list|,
name|line
argument_list|,
name|reset
argument_list|,
name|saw_cr_at_eol
condition|?
literal|"\r"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump_sline
specifier|static
name|void
name|dump_sline
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|use_color
parameter_list|)
block|{
name|unsigned
name|long
name|mark
init|=
operator|(
literal|1UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|unsigned
name|long
name|no_pre_delete
init|=
operator|(
literal|2UL
operator|<<
name|num_parent
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|lno
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_frag
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_FRAGINFO
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_new
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_FILE_NEW
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_old
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_FILE_OLD
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_plain
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_PLAIN
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_reset
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_RESET
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cnt
condition|)
return|return;
comment|/* result deleted */
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|sline
modifier|*
name|sl
init|=
operator|&
name|sline
index|[
name|lno
index|]
decl_stmt|;
name|unsigned
name|long
name|hunk_end
decl_stmt|;
name|unsigned
name|long
name|rlines
decl_stmt|;
specifier|const
name|char
modifier|*
name|hunk_comment
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|null_context
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|lno
operator|<=
name|cnt
operator|&&
operator|!
operator|(
name|sline
index|[
name|lno
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
block|{
if|if
condition|(
name|hunk_comment_line
argument_list|(
name|sline
index|[
name|lno
index|]
operator|.
name|bol
argument_list|)
condition|)
name|hunk_comment
operator|=
name|sline
index|[
name|lno
index|]
operator|.
name|bol
expr_stmt|;
name|lno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
name|lno
condition|)
break|break;
else|else
block|{
for|for
control|(
name|hunk_end
operator|=
name|lno
operator|+
literal|1
init|;
name|hunk_end
operator|<=
name|cnt
condition|;
name|hunk_end
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|sline
index|[
name|hunk_end
index|]
operator|.
name|flag
operator|&
name|mark
operator|)
condition|)
break|break;
block|}
name|rlines
operator|=
name|hunk_end
operator|-
name|lno
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|hunk_end
condition|)
name|rlines
operator|--
expr_stmt|;
comment|/* pointing at the last delete hunk */
if|if
condition|(
operator|!
name|context
condition|)
block|{
comment|/* 			 * Even when running with --unified=0, all 			 * lines in the hunk needs to be processed in 			 * the loop below in order to show the 			 * deletion recorded in lost_head.  However, 			 * we do not want to show the resulting line 			 * with all blank context markers in such a 			 * case.  Compensate. 			 */
name|unsigned
name|long
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|lno
init|;
name|j
operator|<
name|hunk_end
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|sline
index|[
name|j
index|]
operator|.
name|flag
operator|&
operator|(
name|mark
operator|-
literal|1
operator|)
operator|)
condition|)
name|null_context
operator|++
expr_stmt|;
name|rlines
operator|-=
name|null_context
expr_stmt|;
block|}
name|fputs
argument_list|(
name|c_frag
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|num_parent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|combine_marker
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|show_parent_lno
argument_list|(
name|sline
argument_list|,
name|lno
argument_list|,
name|hunk_end
argument_list|,
name|i
argument_list|,
name|null_context
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" +%lu,%lu "
argument_list|,
name|lno
operator|+
literal|1
argument_list|,
name|rlines
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|num_parent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|combine_marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunk_comment
condition|)
block|{
name|int
name|comment_end
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|hunk_comment
index|[
name|i
index|]
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
operator|!
name|ch
operator|||
name|ch
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
name|comment_end
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|comment_end
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comment_end
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|hunk_comment
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
while|while
condition|(
name|lno
operator|<
name|hunk_end
condition|)
block|{
name|struct
name|lline
modifier|*
name|ll
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|long
name|p_mask
decl_stmt|;
name|sl
operator|=
operator|&
name|sline
index|[
name|lno
operator|++
index|]
expr_stmt|;
name|ll
operator|=
operator|(
name|sl
operator|->
name|flag
operator|&
name|no_pre_delete
operator|)
condition|?
name|NULL
else|:
name|sl
operator|->
name|lost_head
expr_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
name|fputs
argument_list|(
name|c_old
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_parent
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ll
operator|->
name|parent_map
operator|&
operator|(
literal|1UL
operator|<<
name|j
operator|)
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|show_line_to_eol
argument_list|(
name|ll
operator|->
name|line
argument_list|,
operator|-
literal|1
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
name|lno
condition|)
break|break;
name|p_mask
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sl
operator|->
name|flag
operator|&
operator|(
name|mark
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* 				 * This sline was here to hang the 				 * lost lines in front of it. 				 */
if|if
condition|(
operator|!
name|context
condition|)
continue|continue;
name|fputs
argument_list|(
name|c_plain
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|c_new
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_parent
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p_mask
operator|&
name|sl
operator|->
name|flag
condition|)
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|p_mask
operator|<<=
literal|1
expr_stmt|;
block|}
name|show_line_to_eol
argument_list|(
name|sl
operator|->
name|bol
argument_list|,
name|sl
operator|->
name|len
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|reuse_combine_diff
specifier|static
name|void
name|reuse_combine_diff
parameter_list|(
name|struct
name|sline
modifier|*
name|sline
parameter_list|,
name|unsigned
name|long
name|cnt
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
comment|/* We have already examined parent j and we know parent i 	 * and parent j are the same, so reuse the combined result 	 * of parent j for parent i. 	 */
name|unsigned
name|long
name|lno
decl_stmt|,
name|imask
decl_stmt|,
name|jmask
decl_stmt|;
name|imask
operator|=
operator|(
literal|1UL
operator|<<
name|i
operator|)
expr_stmt|;
name|jmask
operator|=
operator|(
literal|1UL
operator|<<
name|j
operator|)
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
init|;
name|lno
operator|<=
name|cnt
condition|;
name|lno
operator|++
control|)
block|{
name|struct
name|lline
modifier|*
name|ll
init|=
name|sline
operator|->
name|lost_head
decl_stmt|;
name|sline
operator|->
name|p_lno
index|[
name|i
index|]
operator|=
name|sline
operator|->
name|p_lno
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
if|if
condition|(
name|ll
operator|->
name|parent_map
operator|&
name|jmask
condition|)
name|ll
operator|->
name|parent_map
operator||=
name|imask
expr_stmt|;
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sline
operator|->
name|flag
operator|&
name|jmask
condition|)
name|sline
operator|->
name|flag
operator||=
name|imask
expr_stmt|;
name|sline
operator|++
expr_stmt|;
block|}
comment|/* the overall size of the file (sline[cnt]) */
name|sline
operator|->
name|p_lno
index|[
name|i
index|]
operator|=
name|sline
operator|->
name|p_lno
index|[
name|j
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump_quoted_path
specifier|static
name|void
name|dump_quoted_path
parameter_list|(
specifier|const
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|c_meta
parameter_list|,
specifier|const
name|char
modifier|*
name|c_reset
parameter_list|)
block|{
specifier|static
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|c_meta
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|quote_two_c_style
argument_list|(
operator|&
name|buf
argument_list|,
name|prefix
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_patch_diff
specifier|static
name|void
name|show_patch_diff
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|elem
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|unsigned
name|long
name|result_size
decl_stmt|,
name|cnt
decl_stmt|,
name|lno
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|sline
modifier|*
name|sline
decl_stmt|;
comment|/* survived lines */
name|int
name|mode_differs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|show_hunks
decl_stmt|;
name|int
name|working_tree_file
init|=
name|is_null_sha1
argument_list|(
name|elem
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|int
name|abbrev
init|=
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|FULL_INDEX
argument_list|)
condition|?
literal|40
else|:
name|DEFAULT_ABBREV
decl_stmt|;
name|mmfile_t
name|result_file
decl_stmt|;
name|context
operator|=
name|opt
operator|->
name|context
expr_stmt|;
comment|/* Read the result of merge first */
if|if
condition|(
operator|!
name|working_tree_file
condition|)
name|result
operator|=
name|grab_blob
argument_list|(
name|elem
operator|->
name|sha1
argument_list|,
operator|&
name|result_size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Used by diff-tree to read from the working tree */
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|elem
operator|->
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|deleted_file
goto|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|size_t
name|len
init|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
decl_stmt|;
name|result_size
operator|=
name|len
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_size
operator|!=
name|readlink
argument_list|(
name|elem
operator|->
name|path
argument_list|,
name|result
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"readlink(%s): %s"
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|elem
operator|->
name|mode
operator|=
name|canon_mode
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|<=
operator|(
name|fd
operator|=
name|open
argument_list|(
name|elem
operator|->
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|&&
operator|!
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|size_t
name|len
init|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
decl_stmt|;
name|ssize_t
name|done
decl_stmt|;
name|int
name|is_file
decl_stmt|,
name|i
decl_stmt|;
name|elem
operator|->
name|mode
operator|=
name|canon_mode
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
comment|/* if symlinks don't work, assume symlink if all parents 			 * are symlinks 			 */
name|is_file
operator|=
name|has_symlinks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|is_file
operator|&&
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|is_file
operator|=
operator|!
name|S_ISLNK
argument_list|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_file
condition|)
name|elem
operator|->
name|mode
operator|=
name|canon_mode
argument_list|(
name|S_IFLNK
argument_list|)
expr_stmt|;
name|result_size
operator|=
name|len
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|done
operator|=
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|result
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"read error '%s'"
argument_list|,
name|elem
operator|->
name|path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|done
operator|<
name|len
condition|)
name|die
argument_list|(
literal|"early EOF '%s'"
argument_list|,
name|elem
operator|->
name|path
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If not a fake symlink, apply filters, e.g. autocrlf */
if|if
condition|(
name|is_file
condition|)
block|{
name|struct
name|strbuf
name|buf
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_to_git
argument_list|(
name|elem
operator|->
name|path
argument_list|,
name|result
argument_list|,
name|len
argument_list|,
operator|&
name|buf
argument_list|,
name|safe_crlf
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|result_size
operator|=
name|len
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|deleted_file
label|:
name|result_size
operator|=
literal|0
expr_stmt|;
name|elem
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|cp
operator|=
name|result
init|;
name|cp
operator|<
name|result
operator|+
name|result_size
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|result_size
operator|&&
name|result
index|[
name|result_size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|cnt
operator|++
expr_stmt|;
comment|/* incomplete line */
name|sline
operator|=
name|xcalloc
argument_list|(
name|cnt
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sline
argument_list|)
argument_list|)
expr_stmt|;
name|sline
index|[
literal|0
index|]
operator|.
name|bol
operator|=
name|result
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
init|;
name|lno
operator|<=
name|cnt
operator|+
literal|1
condition|;
name|lno
operator|++
control|)
block|{
name|sline
index|[
name|lno
index|]
operator|.
name|lost_tail
operator|=
operator|&
name|sline
index|[
name|lno
index|]
operator|.
name|lost_head
expr_stmt|;
name|sline
index|[
name|lno
index|]
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|lno
operator|=
literal|0
operator|,
name|cp
operator|=
name|result
init|;
name|cp
operator|<
name|result
operator|+
name|result_size
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|sline
index|[
name|lno
index|]
operator|.
name|len
operator|=
name|cp
operator|-
name|sline
index|[
name|lno
index|]
operator|.
name|bol
expr_stmt|;
name|lno
operator|++
expr_stmt|;
if|if
condition|(
name|lno
operator|<
name|cnt
condition|)
name|sline
index|[
name|lno
index|]
operator|.
name|bol
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result_size
operator|&&
name|result
index|[
name|result_size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|sline
index|[
name|cnt
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|result_size
operator|-
operator|(
name|sline
index|[
name|cnt
operator|-
literal|1
index|]
operator|.
name|bol
operator|-
name|result
operator|)
expr_stmt|;
name|result_file
operator|.
name|ptr
operator|=
name|result
expr_stmt|;
name|result_file
operator|.
name|size
operator|=
name|result_size
expr_stmt|;
comment|/* Even p_lno[cnt+1] is valid -- that is for the end line number 	 * for deletion hunk at the end. 	 */
name|sline
index|[
literal|0
index|]
operator|.
name|p_lno
operator|=
name|xcalloc
argument_list|(
operator|(
name|cnt
operator|+
literal|2
operator|)
operator|*
name|num_parent
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
init|;
name|lno
operator|<=
name|cnt
condition|;
name|lno
operator|++
control|)
name|sline
index|[
name|lno
operator|+
literal|1
index|]
operator|.
name|p_lno
operator|=
name|sline
index|[
name|lno
index|]
operator|.
name|p_lno
operator|+
name|num_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|sha1
argument_list|,
name|elem
operator|->
name|parent
index|[
name|j
index|]
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|reuse_combine_diff
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<=
name|j
condition|)
name|combine_diff
argument_list|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|sha1
argument_list|,
operator|&
name|result_file
argument_list|,
name|sline
argument_list|,
name|cnt
argument_list|,
name|i
argument_list|,
name|num_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|elem
operator|->
name|mode
condition|)
name|mode_differs
operator|=
literal|1
expr_stmt|;
block|}
name|show_hunks
operator|=
name|make_hunks
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_hunks
operator|||
name|mode_differs
operator|||
name|working_tree_file
condition|)
block|{
specifier|const
name|char
modifier|*
name|abb
decl_stmt|;
name|int
name|use_color
init|=
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|COLOR_DIFF
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_meta
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_METAINFO
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_reset
init|=
name|diff_get_color
argument_list|(
name|use_color
argument_list|,
name|DIFF_RESET
argument_list|)
decl_stmt|;
name|int
name|added
init|=
literal|0
decl_stmt|;
name|int
name|deleted
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rev
operator|->
name|loginfo
operator|&&
operator|!
name|rev
operator|->
name|no_commit_id
condition|)
name|show_log
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|dump_quoted_path
argument_list|(
name|dense
condition|?
literal|"diff --cc "
else|:
literal|"diff --combined "
argument_list|,
literal|""
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sindex "
argument_list|,
name|c_meta
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|abb
operator|=
name|find_unique_abbrev
argument_list|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|sha1
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|i
condition|?
literal|","
else|:
literal|""
argument_list|,
name|abb
argument_list|)
expr_stmt|;
block|}
name|abb
operator|=
name|find_unique_abbrev
argument_list|(
name|elem
operator|->
name|sha1
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"..%s%s\n"
argument_list|,
name|abb
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_differs
condition|)
block|{
name|deleted
operator|=
operator|!
name|elem
operator|->
name|mode
expr_stmt|;
comment|/* We say it was added if nobody had it */
name|added
operator|=
operator|!
name|deleted
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|added
operator|&&
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|status
operator|!=
name|DIFF_STATUS_ADDED
condition|)
name|added
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|added
condition|)
name|printf
argument_list|(
literal|"%snew file mode %06o"
argument_list|,
name|c_meta
argument_list|,
name|elem
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|deleted
condition|)
name|printf
argument_list|(
literal|"%sdeleted file "
argument_list|,
name|c_meta
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mode "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s%06o"
argument_list|,
name|i
condition|?
literal|","
else|:
literal|""
argument_list|,
name|elem
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elem
operator|->
name|mode
condition|)
name|printf
argument_list|(
literal|"..%06o"
argument_list|,
name|elem
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|added
condition|)
name|dump_quoted_path
argument_list|(
literal|"--- "
argument_list|,
literal|""
argument_list|,
literal|"/dev/null"
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
else|else
name|dump_quoted_path
argument_list|(
literal|"--- "
argument_list|,
name|opt
operator|->
name|a_prefix
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleted
condition|)
name|dump_quoted_path
argument_list|(
literal|"+++ "
argument_list|,
literal|""
argument_list|,
literal|"/dev/null"
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
else|else
name|dump_quoted_path
argument_list|(
literal|"+++ "
argument_list|,
name|opt
operator|->
name|b_prefix
argument_list|,
name|elem
operator|->
name|path
argument_list|,
name|c_meta
argument_list|,
name|c_reset
argument_list|)
expr_stmt|;
name|dump_sline
argument_list|(
name|sline
argument_list|,
name|cnt
argument_list|,
name|num_parent
argument_list|,
name|DIFF_OPT_TST
argument_list|(
name|opt
argument_list|,
name|COLOR_DIFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|lno
operator|=
literal|0
init|;
name|lno
operator|<
name|cnt
condition|;
name|lno
operator|++
control|)
block|{
if|if
condition|(
name|sline
index|[
name|lno
index|]
operator|.
name|lost_head
condition|)
block|{
name|struct
name|lline
modifier|*
name|ll
init|=
name|sline
index|[
name|lno
index|]
operator|.
name|lost_head
decl_stmt|;
while|while
condition|(
name|ll
condition|)
block|{
name|struct
name|lline
modifier|*
name|tmp
init|=
name|ll
decl_stmt|;
name|ll
operator|=
name|ll
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|sline
index|[
literal|0
index|]
operator|.
name|p_lno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sline
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|COLONS
define|#
directive|define
name|COLONS
value|"::::::::::::::::::::::::::::::::"
end_define
begin_function
DECL|function|show_raw_diff
specifier|static
name|void
name|show_raw_diff
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|p
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|line_termination
decl_stmt|,
name|inter_name_termination
decl_stmt|;
name|line_termination
operator|=
name|opt
operator|->
name|line_termination
expr_stmt|;
name|inter_name_termination
operator|=
literal|'\t'
expr_stmt|;
if|if
condition|(
operator|!
name|line_termination
condition|)
name|inter_name_termination
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|loginfo
operator|&&
operator|!
name|rev
operator|->
name|no_commit_id
condition|)
name|show_log
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
name|DIFF_FORMAT_RAW
condition|)
block|{
name|offset
operator|=
name|strlen
argument_list|(
name|COLONS
argument_list|)
operator|-
name|num_parent
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
name|prefix
operator|=
name|COLONS
operator|+
name|offset
expr_stmt|;
comment|/* Show the modes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s%06o"
argument_list|,
name|prefix
argument_list|,
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|" "
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s%06o"
argument_list|,
name|prefix
argument_list|,
name|p
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* Show sha1's */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|diff_unique_abbrev
argument_list|(
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|sha1
argument_list|,
name|opt
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|diff_unique_abbrev
argument_list|(
name|p
operator|->
name|sha1
argument_list|,
name|opt
operator|->
name|abbrev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_RAW
operator||
name|DIFF_FORMAT_NAME_STATUS
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|p
operator|->
name|parent
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|inter_name_termination
argument_list|)
expr_stmt|;
block|}
name|write_name_quoted
argument_list|(
name|p
operator|->
name|path
argument_list|,
name|stdout
argument_list|,
name|line_termination
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_combined_diff
name|void
name|show_combined_diff
parameter_list|(
name|struct
name|combine_diff_path
modifier|*
name|p
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|len
condition|)
return|return;
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_RAW
operator||
name|DIFF_FORMAT_NAME
operator||
name|DIFF_FORMAT_NAME_STATUS
operator|)
condition|)
name|show_raw_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|rev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
name|DIFF_FORMAT_PATCH
condition|)
name|show_patch_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|diff_tree_combined
name|void
name|diff_tree_combined
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|unsigned
name|char
name|parent
index|[]
index|[
literal|20
index|]
parameter_list|,
name|int
name|num_parent
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|struct
name|diff_options
modifier|*
name|opt
init|=
operator|&
name|rev
operator|->
name|diffopt
decl_stmt|;
name|struct
name|diff_options
name|diffopts
decl_stmt|;
name|struct
name|combine_diff_path
modifier|*
name|p
decl_stmt|,
modifier|*
name|paths
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_paths
decl_stmt|,
name|needsep
decl_stmt|,
name|show_log_first
decl_stmt|;
name|diffopts
operator|=
operator|*
name|opt
expr_stmt|;
name|diffopts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|diffopts
argument_list|,
name|RECURSIVE
argument_list|)
expr_stmt|;
name|DIFF_OPT_CLR
argument_list|(
operator|&
name|diffopts
argument_list|,
name|ALLOW_EXTERNAL
argument_list|)
expr_stmt|;
name|show_log_first
operator|=
operator|!
operator|!
name|rev
operator|->
name|loginfo
operator|&&
operator|!
name|rev
operator|->
name|no_commit_id
expr_stmt|;
name|needsep
operator|=
literal|0
expr_stmt|;
comment|/* find set of paths that everybody touches */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_parent
condition|;
name|i
operator|++
control|)
block|{
comment|/* show stat against the first parent even 		 * when doing combined diff. 		 */
name|int
name|stat_opt
init|=
operator|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_NUMSTAT
operator||
name|DIFF_FORMAT_DIFFSTAT
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|stat_opt
condition|)
name|diffopts
operator|.
name|output_format
operator|=
name|stat_opt
expr_stmt|;
else|else
name|diffopts
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_NO_OUTPUT
expr_stmt|;
name|diff_tree_sha1
argument_list|(
name|parent
index|[
name|i
index|]
argument_list|,
name|sha1
argument_list|,
literal|""
argument_list|,
operator|&
name|diffopts
argument_list|)
expr_stmt|;
name|diffcore_std
argument_list|(
operator|&
name|diffopts
argument_list|)
expr_stmt|;
name|paths
operator|=
name|intersect_paths
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
name|num_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_log_first
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|show_log
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|->
name|verbose_header
operator|&&
name|opt
operator|->
name|output_format
condition|)
name|putchar
argument_list|(
name|opt
operator|->
name|line_termination
argument_list|)
expr_stmt|;
block|}
name|diff_flush
argument_list|(
operator|&
name|diffopts
argument_list|)
expr_stmt|;
block|}
comment|/* find out surviving paths */
for|for
control|(
name|num_paths
operator|=
literal|0
operator|,
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|len
condition|)
name|num_paths
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num_paths
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_RAW
operator||
name|DIFF_FORMAT_NAME
operator||
name|DIFF_FORMAT_NAME_STATUS
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|len
condition|)
name|show_raw_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
name|needsep
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
operator|(
name|DIFF_FORMAT_NUMSTAT
operator||
name|DIFF_FORMAT_DIFFSTAT
operator|)
condition|)
name|needsep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|output_format
operator|&
name|DIFF_FORMAT_PATCH
condition|)
block|{
if|if
condition|(
name|needsep
condition|)
name|putchar
argument_list|(
name|opt
operator|->
name|line_termination
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|paths
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|len
condition|)
name|show_patch_diff
argument_list|(
name|p
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Clean things up */
while|while
condition|(
name|paths
condition|)
block|{
name|struct
name|combine_diff_path
modifier|*
name|tmp
init|=
name|paths
decl_stmt|;
name|paths
operator|=
name|paths
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|diff_tree_combined_merge
name|void
name|diff_tree_combined_merge
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|dense
parameter_list|,
name|struct
name|rev_info
modifier|*
name|rev
parameter_list|)
block|{
name|int
name|num_parent
decl_stmt|;
specifier|const
name|unsigned
name|char
argument_list|(
operator|*
name|parent
argument_list|)
decl|[20]
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
comment|/* count parents */
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
operator|,
name|num_parent
operator|=
literal|0
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
operator|,
name|num_parent
operator|++
control|)
empty_stmt|;
comment|/* nothing */
name|parent
operator|=
name|xmalloc
argument_list|(
name|num_parent
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|parent
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
operator|,
name|num_parent
operator|=
literal|0
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
operator|,
name|num_parent
operator|++
control|)
name|hashcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|parent
operator|+
name|num_parent
operator|)
argument_list|,
name|parents
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|diff_tree_combined
argument_list|(
name|sha1
argument_list|,
name|parent
argument_list|,
name|num_parent
argument_list|,
name|dense
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
