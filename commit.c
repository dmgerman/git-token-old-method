begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"gpg-interface.h"
end_include
begin_include
include|#
directive|include
file|"mergesort.h"
end_include
begin_include
include|#
directive|include
file|"commit-slab.h"
end_include
begin_include
include|#
directive|include
file|"prio-queue.h"
end_include
begin_include
include|#
directive|include
file|"sha1-lookup.h"
end_include
begin_function_decl
specifier|static
name|struct
name|commit_extra_header
modifier|*
name|read_commit_extra_header_lines
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|save_commit_buffer
name|int
name|save_commit_buffer
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_type
specifier|const
name|char
modifier|*
name|commit_type
init|=
literal|"commit"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|lookup_commit_reference_gently
name|struct
name|commit
modifier|*
name|lookup_commit_reference_gently
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
return|return
name|object_as_type
argument_list|(
name|obj
argument_list|,
name|OBJ_COMMIT
argument_list|,
name|quiet
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference
name|struct
name|commit
modifier|*
name|lookup_commit_reference
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_or_die
name|struct
name|commit
modifier|*
name|lookup_commit_or_die
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|ref_name
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|c
init|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse %s"
argument_list|)
argument_list|,
name|ref_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|c
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"%s %s is not a commit!"
argument_list|)
argument_list|,
name|ref_name
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit
name|struct
name|commit
modifier|*
name|lookup_commit
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|lookup_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|create_object
argument_list|(
name|sha1
argument_list|,
name|alloc_commit_node
argument_list|()
argument_list|)
return|;
return|return
name|object_as_type
argument_list|(
name|obj
argument_list|,
name|OBJ_COMMIT
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference_by_name
name|struct
name|commit
modifier|*
name|lookup_commit_reference_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
if|if
condition|(
name|get_sha1_committish
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|commit
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|commit
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_date
specifier|static
name|unsigned
name|long
name|parse_commit_date
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|tail
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dateptr
decl_stmt|;
if|if
condition|(
name|buf
operator|+
literal|6
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"author"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|+
literal|9
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"committer"
argument_list|,
literal|9
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'>'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
name|dateptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
comment|/* dateptr< buf&& buf[-1] == '\n', so strtoul will stop at buf-1 */
return|return
name|strtoul
argument_list|(
name|dateptr
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|commit_graft
specifier|static
name|struct
name|commit_graft
modifier|*
modifier|*
name|commit_graft
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_graft_alloc
DECL|variable|commit_graft_nr
specifier|static
name|int
name|commit_graft_alloc
decl_stmt|,
name|commit_graft_nr
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|commit_graft_sha1_access
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|commit_graft_sha1_access
parameter_list|(
name|size_t
name|index
parameter_list|,
name|void
modifier|*
name|table
parameter_list|)
block|{
name|struct
name|commit_graft
modifier|*
modifier|*
name|commit_graft_table
init|=
name|table
decl_stmt|;
return|return
name|commit_graft_table
index|[
name|index
index|]
operator|->
name|sha1
return|;
block|}
end_function
begin_function
DECL|function|commit_graft_pos
specifier|static
name|int
name|commit_graft_pos
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|sha1_pos
argument_list|(
name|sha1
argument_list|,
name|commit_graft
argument_list|,
name|commit_graft_nr
argument_list|,
name|commit_graft_sha1_access
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|register_commit_graft
name|int
name|register_commit_graft
parameter_list|(
name|struct
name|commit_graft
modifier|*
name|graft
parameter_list|,
name|int
name|ignore_dups
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pos
condition|)
block|{
if|if
condition|(
name|ignore_dups
condition|)
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|commit_graft
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|commit_graft
argument_list|,
name|commit_graft_nr
operator|+
literal|1
argument_list|,
name|commit_graft_alloc
argument_list|)
expr_stmt|;
name|commit_graft_nr
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|commit_graft_nr
condition|)
name|memmove
argument_list|(
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
name|commit_graft
operator|+
name|pos
argument_list|,
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|commit_graft
argument_list|)
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_graft_line
name|struct
name|commit_graft
modifier|*
name|read_graft_line
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|i
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|%
literal|41
condition|)
goto|goto
name|bad_graft_data
goto|;
name|i
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|41
operator|-
literal|1
expr_stmt|;
name|graft
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|graft
argument_list|)
operator|+
literal|20
operator|*
name|i
argument_list|)
expr_stmt|;
name|graft
operator|->
name|nr_parent
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
argument_list|,
name|graft
operator|->
name|sha1
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
for|for
control|(
name|i
operator|=
literal|40
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|41
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
goto|goto
name|bad_graft_data
goto|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
operator|+
name|i
operator|+
literal|1
argument_list|,
name|graft
operator|->
name|parent
index|[
name|i
operator|/
literal|41
index|]
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
block|}
return|return
name|graft
return|;
name|bad_graft_data
label|:
name|error
argument_list|(
literal|"bad graft data: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|read_graft_file
specifier|static
name|int
name|read_graft_file
parameter_list|(
specifier|const
name|char
modifier|*
name|graft_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|graft_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|!
name|strbuf_getwholeline
argument_list|(
operator|&
name|buf
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|read_graft_line
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|buf
operator|.
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|graft
condition|)
continue|continue;
if|if
condition|(
name|register_commit_graft
argument_list|(
name|graft
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate graft data: %s"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|prepare_commit_graft
specifier|static
name|void
name|prepare_commit_graft
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|commit_graft_prepared
decl_stmt|;
name|char
modifier|*
name|graft_file
decl_stmt|;
if|if
condition|(
name|commit_graft_prepared
condition|)
return|return;
name|graft_file
operator|=
name|get_graft_file
argument_list|()
expr_stmt|;
name|read_graft_file
argument_list|(
name|graft_file
argument_list|)
expr_stmt|;
comment|/* make sure shallows are read */
name|is_repository_shallow
argument_list|()
expr_stmt|;
name|commit_graft_prepared
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lookup_commit_graft
name|struct
name|commit_graft
modifier|*
name|lookup_commit_graft
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|prepare_commit_graft
argument_list|()
expr_stmt|;
name|pos
operator|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|commit_graft
index|[
name|pos
index|]
return|;
block|}
end_function
begin_function
DECL|function|for_each_commit_graft
name|int
name|for_each_commit_graft
parameter_list|(
name|each_commit_graft_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ret
operator|=
literal|0
init|;
name|i
operator|<
name|commit_graft_nr
operator|&&
operator|!
name|ret
condition|;
name|i
operator|++
control|)
name|ret
operator|=
name|fn
argument_list|(
name|commit_graft
index|[
name|i
index|]
argument_list|,
name|cb_data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|unregister_shallow
name|int
name|unregister_shallow
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|commit_graft_nr
condition|)
name|memmove
argument_list|(
name|commit_graft
operator|+
name|pos
argument_list|,
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commit_graft
operator|*
argument_list|)
operator|*
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|commit_graft_nr
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_struct
DECL|struct|commit_buffer
struct|struct
name|commit_buffer
block|{
DECL|member|buffer
name|void
modifier|*
name|buffer
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|size
decl_stmt|;
block|}
struct|;
end_struct
begin_expr_stmt
name|define_commit_slab
argument_list|(
name|buffer_slab
argument_list|,
expr|struct
name|commit_buffer
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
DECL|variable|buffer_slab
specifier|static
name|struct
name|buffer_slab
name|buffer_slab
init|=
name|COMMIT_SLAB_INIT
argument_list|(
literal|1
argument_list|,
name|buffer_slab
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|set_commit_buffer
name|void
name|set_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|struct
name|commit_buffer
modifier|*
name|v
init|=
name|buffer_slab_at
argument_list|(
operator|&
name|buffer_slab
argument_list|,
name|commit
argument_list|)
decl_stmt|;
name|v
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|v
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|get_cached_commit_buffer
specifier|const
name|void
modifier|*
name|get_cached_commit_buffer
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|commit_buffer
modifier|*
name|v
init|=
name|buffer_slab_at
argument_list|(
operator|&
name|buffer_slab
argument_list|,
name|commit
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|v
operator|->
name|size
expr_stmt|;
return|return
name|v
operator|->
name|buffer
return|;
block|}
end_function
begin_function
DECL|function|get_commit_buffer
specifier|const
name|void
modifier|*
name|get_commit_buffer
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ret
init|=
name|get_cached_commit_buffer
argument_list|(
name|commit
argument_list|,
name|sizep
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|ret
operator|=
name|read_sha1_file
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|die
argument_list|(
literal|"cannot read commit object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"expected commit for %s, got %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|unuse_commit_buffer
name|void
name|unuse_commit_buffer
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|struct
name|commit_buffer
modifier|*
name|v
init|=
name|buffer_slab_at
argument_list|(
operator|&
name|buffer_slab
argument_list|,
name|commit
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|buffer
operator|!=
name|buffer
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_commit_buffer
name|void
name|free_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|struct
name|commit_buffer
modifier|*
name|v
init|=
name|buffer_slab_at
argument_list|(
operator|&
name|buffer_slab
argument_list|,
name|commit
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|v
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|v
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|detach_commit_buffer
specifier|const
name|void
modifier|*
name|detach_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|long
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|commit_buffer
modifier|*
name|v
init|=
name|buffer_slab_at
argument_list|(
operator|&
name|buffer_slab
argument_list|,
name|commit
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|v
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|v
operator|->
name|size
expr_stmt|;
name|v
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_buffer
name|int
name|parse_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tail
init|=
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
name|unsigned
name|char
name|parent
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|item
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|tail
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|46
operator|||
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"tree "
argument_list|,
literal|5
argument_list|)
operator|||
name|bufptr
index|[
literal|45
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|error
argument_list|(
literal|"bogus commit object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|5
argument_list|,
name|parent
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"bad tree pointer in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|item
operator|->
name|tree
operator|=
name|lookup_tree
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
literal|46
expr_stmt|;
comment|/* "tree " + "hex sha1" + "\n" */
name|pptr
operator|=
operator|&
name|item
operator|->
name|parents
expr_stmt|;
name|graft
operator|=
name|lookup_commit_graft
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
while|while
condition|(
name|bufptr
operator|+
literal|48
operator|<
name|tail
operator|&&
operator|!
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|48
operator|||
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|7
argument_list|,
name|parent
argument_list|)
operator|||
name|bufptr
index|[
literal|47
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|error
argument_list|(
literal|"bad parents in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|bufptr
operator|+=
literal|48
expr_stmt|;
comment|/* 		 * The clone is shallow if nr_parent< 0, and we must 		 * not traverse its real parents even when we unhide them. 		 */
if|if
condition|(
name|graft
operator|&&
operator|(
name|graft
operator|->
name|nr_parent
operator|<
literal|0
operator|||
name|grafts_replace_parents
operator|)
condition|)
continue|continue;
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
condition|)
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|graft
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graft
operator|->
name|nr_parent
condition|;
name|i
operator|++
control|)
block|{
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|graft
operator|->
name|parent
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_parent
condition|)
continue|continue;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
block|}
name|item
operator|->
name|date
operator|=
name|parse_commit_date
argument_list|(
name|bufptr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit
name|int
name|parse_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|error
argument_list|(
literal|"Could not read %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Object %s not a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
block|}
name|ret
operator|=
name|parse_commit_buffer
argument_list|(
name|item
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_commit_buffer
operator|&&
operator|!
name|ret
condition|)
block|{
name|set_commit_buffer
argument_list|(
name|item
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_or_die
name|void
name|parse_commit_or_die
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
name|parse_commit
argument_list|(
name|item
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to parse commit %s"
argument_list|,
name|item
condition|?
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|find_commit_subject
name|int
name|find_commit_subject
parameter_list|(
specifier|const
name|char
modifier|*
name|commit_buffer
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|subject
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|commit_buffer
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\n'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\n'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|eol
operator|=
name|p
init|;
operator|*
name|eol
operator|&&
operator|*
name|eol
operator|!=
literal|'\n'
condition|;
name|eol
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
block|}
else|else
name|eol
operator|=
name|p
expr_stmt|;
operator|*
name|subject
operator|=
name|p
expr_stmt|;
return|return
name|eol
operator|-
name|p
return|;
block|}
end_function
begin_function
DECL|function|commit_list_insert
name|struct
name|commit_list
modifier|*
name|commit_list_insert
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|new_list
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_list
argument_list|)
argument_list|)
decl_stmt|;
name|new_list
operator|->
name|item
operator|=
name|item
expr_stmt|;
name|new_list
operator|->
name|next
operator|=
operator|*
name|list_p
expr_stmt|;
operator|*
name|list_p
operator|=
name|new_list
expr_stmt|;
return|return
name|new_list
return|;
block|}
end_function
begin_function
DECL|function|commit_list_count
name|unsigned
name|commit_list_count
parameter_list|(
specifier|const
name|struct
name|commit_list
modifier|*
name|l
parameter_list|)
block|{
name|unsigned
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|c
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|copy_commit_list
name|struct
name|commit_list
modifier|*
name|copy_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pp
init|=
operator|&
name|head
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|pp
operator|=
name|commit_list_append
argument_list|(
name|list
operator|->
name|item
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function
begin_function
DECL|function|free_commit_list
name|void
name|free_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|temp
init|=
name|list
decl_stmt|;
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|commit_list_insert_by_date
name|struct
name|commit_list
modifier|*
name|commit_list_insert_by_date
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
modifier|*
name|pp
init|=
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|item
operator|->
name|date
operator|<
name|item
operator|->
name|date
condition|)
block|{
break|break;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|commit_list_insert
argument_list|(
name|item
argument_list|,
name|pp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|commit_list_compare_by_date
specifier|static
name|int
name|commit_list_compare_by_date
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|unsigned
name|long
name|a_date
init|=
operator|(
operator|(
specifier|const
expr|struct
name|commit_list
operator|*
operator|)
name|a
operator|)
operator|->
name|item
operator|->
name|date
decl_stmt|;
name|unsigned
name|long
name|b_date
init|=
operator|(
operator|(
specifier|const
expr|struct
name|commit_list
operator|*
operator|)
name|b
operator|)
operator|->
name|item
operator|->
name|date
decl_stmt|;
if|if
condition|(
name|a_date
operator|<
name|b_date
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a_date
operator|>
name|b_date
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|commit_list_get_next
specifier|static
name|void
modifier|*
name|commit_list_get_next
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|commit_list
operator|*
operator|)
name|a
operator|)
operator|->
name|next
return|;
block|}
end_function
begin_function
DECL|function|commit_list_set_next
specifier|static
name|void
name|commit_list_set_next
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|next
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|commit_list
operator|*
operator|)
name|a
operator|)
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
end_function
begin_function
DECL|function|commit_list_sort_by_date
name|void
name|commit_list_sort_by_date
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
operator|*
name|list
operator|=
name|llist_mergesort
argument_list|(
operator|*
name|list
argument_list|,
name|commit_list_get_next
argument_list|,
name|commit_list_set_next
argument_list|,
name|commit_list_compare_by_date
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pop_most_recent_commit
name|struct
name|commit
modifier|*
name|pop_most_recent_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|ret
init|=
operator|(
operator|*
name|list
operator|)
operator|->
name|item
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|ret
operator|->
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|old
init|=
operator|*
name|list
decl_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|parse_commit
argument_list|(
name|commit
argument_list|)
operator|&&
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|mark
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|mark
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|commit
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|clear_commit_marks_1
specifier|static
name|void
name|clear_commit_marks_1
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|plist
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
while|while
condition|(
name|commit
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mark
operator|&
name|commit
operator|->
name|object
operator|.
name|flags
operator|)
condition|)
return|return;
name|commit
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|mark
expr_stmt|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
if|if
condition|(
operator|!
name|parents
condition|)
return|return;
while|while
condition|(
operator|(
name|parents
operator|=
name|parents
operator|->
name|next
operator|)
condition|)
name|commit_list_insert
argument_list|(
name|parents
operator|->
name|item
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|commit
operator|=
name|commit
operator|->
name|parents
operator|->
name|item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clear_commit_marks_many
name|void
name|clear_commit_marks_many
parameter_list|(
name|int
name|nr
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|commit
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|nr
operator|--
condition|)
block|{
name|commit_list_insert
argument_list|(
operator|*
name|commit
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|commit
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|list
condition|)
name|clear_commit_marks_1
argument_list|(
operator|&
name|list
argument_list|,
name|pop_commit
argument_list|(
operator|&
name|list
argument_list|)
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear_commit_marks
name|void
name|clear_commit_marks
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|clear_commit_marks_many
argument_list|(
literal|1
argument_list|,
operator|&
name|commit
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear_commit_marks_for_object_array
name|void
name|clear_commit_marks_for_object_array
parameter_list|(
name|struct
name|object_array
modifier|*
name|a
parameter_list|,
name|unsigned
name|mark
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|object
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|object
operator|=
name|a
operator|->
name|objects
index|[
name|i
index|]
operator|.
name|item
expr_stmt|;
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|object
operator|->
name|sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
name|clear_commit_marks
argument_list|(
name|commit
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pop_commit
name|struct
name|commit
modifier|*
name|pop_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|top
init|=
operator|*
name|stack
decl_stmt|;
name|struct
name|commit
modifier|*
name|item
init|=
name|top
condition|?
name|top
operator|->
name|item
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|top
condition|)
block|{
operator|*
name|stack
operator|=
name|top
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*  * Topological sort support  */
end_comment
begin_comment
comment|/* count number of children that have not been emitted */
end_comment
begin_expr_stmt
name|define_commit_slab
argument_list|(
name|indegree_slab
argument_list|,
name|int
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* record author-date for each commit object */
end_comment
begin_macro
name|define_commit_slab
argument_list|(
argument|author_date_slab
argument_list|,
argument|unsigned long
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_function
DECL|function|record_author_date
specifier|static
name|void
name|record_author_date
parameter_list|(
name|struct
name|author_date_slab
modifier|*
name|author_date
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|line_end
decl_stmt|,
modifier|*
name|ident_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
init|=
name|get_commit_buffer
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|ident_split
name|ident
decl_stmt|;
name|char
modifier|*
name|date_end
decl_stmt|;
name|unsigned
name|long
name|date
decl_stmt|;
for|for
control|(
name|buf
operator|=
name|buffer
init|;
name|buf
condition|;
name|buf
operator|=
name|line_end
operator|+
literal|1
control|)
block|{
name|line_end
operator|=
name|strchrnul
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buf
argument_list|,
literal|"author "
argument_list|,
operator|&
name|ident_line
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|line_end
index|[
literal|0
index|]
operator|||
name|line_end
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
return|return;
comment|/* end of header */
continue|continue;
block|}
if|if
condition|(
name|split_ident_line
argument_list|(
operator|&
name|ident
argument_list|,
name|ident_line
argument_list|,
name|line_end
operator|-
name|ident_line
argument_list|)
operator|||
operator|!
name|ident
operator|.
name|date_begin
operator|||
operator|!
name|ident
operator|.
name|date_end
condition|)
goto|goto
name|fail_exit
goto|;
comment|/* malformed "author" line */
break|break;
block|}
name|date
operator|=
name|strtoul
argument_list|(
name|ident
operator|.
name|date_begin
argument_list|,
operator|&
name|date_end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|date_end
operator|!=
name|ident
operator|.
name|date_end
condition|)
goto|goto
name|fail_exit
goto|;
comment|/* malformed date */
operator|*
operator|(
name|author_date_slab_at
argument_list|(
name|author_date
argument_list|,
name|commit
argument_list|)
operator|)
operator|=
name|date
expr_stmt|;
name|fail_exit
label|:
name|unuse_commit_buffer
argument_list|(
name|commit
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compare_commits_by_author_date
specifier|static
name|int
name|compare_commits_by_author_date
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
specifier|const
name|struct
name|commit
modifier|*
name|a
init|=
name|a_
decl_stmt|,
modifier|*
name|b
init|=
name|b_
decl_stmt|;
name|struct
name|author_date_slab
modifier|*
name|author_date
init|=
name|cb_data
decl_stmt|;
name|unsigned
name|long
name|a_date
init|=
operator|*
operator|(
name|author_date_slab_at
argument_list|(
name|author_date
argument_list|,
name|a
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|long
name|b_date
init|=
operator|*
operator|(
name|author_date_slab_at
argument_list|(
name|author_date
argument_list|,
name|b
argument_list|)
operator|)
decl_stmt|;
comment|/* newer commits with larger date first */
if|if
condition|(
name|a_date
operator|<
name|b_date
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a_date
operator|>
name|b_date
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|compare_commits_by_commit_date
name|int
name|compare_commits_by_commit_date
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|const
name|struct
name|commit
modifier|*
name|a
init|=
name|a_
decl_stmt|,
modifier|*
name|b
init|=
name|b_
decl_stmt|;
comment|/* newer commits with larger date first */
if|if
condition|(
name|a
operator|->
name|date
operator|<
name|b
operator|->
name|date
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|date
operator|>
name|b
operator|->
name|date
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Performs an in-place topological sort on the list supplied.  */
end_comment
begin_function
DECL|function|sort_in_topological_order
name|void
name|sort_in_topological_order
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|enum
name|rev_sort_order
name|sort_order
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|,
modifier|*
name|orig
init|=
operator|*
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
decl_stmt|;
name|struct
name|indegree_slab
name|indegree
decl_stmt|;
name|struct
name|prio_queue
name|queue
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|author_date_slab
name|author_date
decl_stmt|;
if|if
condition|(
operator|!
name|orig
condition|)
return|return;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
name|init_indegree_slab
argument_list|(
operator|&
name|indegree
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|queue
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sort_order
condition|)
block|{
default|default:
comment|/* REV_SORT_IN_GRAPH_ORDER */
name|queue
operator|.
name|compare
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|REV_SORT_BY_COMMIT_DATE
case|:
name|queue
operator|.
name|compare
operator|=
name|compare_commits_by_commit_date
expr_stmt|;
break|break;
case|case
name|REV_SORT_BY_AUTHOR_DATE
case|:
name|init_author_date_slab
argument_list|(
operator|&
name|author_date
argument_list|)
expr_stmt|;
name|queue
operator|.
name|compare
operator|=
name|compare_commits_by_author_date
expr_stmt|;
name|queue
operator|.
name|cb_data
operator|=
operator|&
name|author_date
expr_stmt|;
break|break;
block|}
comment|/* Mark them and clear the indegree */
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|next
operator|->
name|item
decl_stmt|;
operator|*
operator|(
name|indegree_slab_at
argument_list|(
operator|&
name|indegree
argument_list|,
name|commit
argument_list|)
operator|)
operator|=
literal|1
expr_stmt|;
comment|/* also record the author dates, if needed */
if|if
condition|(
name|sort_order
operator|==
name|REV_SORT_BY_AUTHOR_DATE
condition|)
name|record_author_date
argument_list|(
operator|&
name|author_date
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
comment|/* update the indegree */
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|next
operator|->
name|item
operator|->
name|parents
decl_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|int
modifier|*
name|pi
init|=
name|indegree_slab_at
argument_list|(
operator|&
name|indegree
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|pi
condition|)
operator|(
operator|*
name|pi
operator|)
operator|++
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* 	 * find the tips 	 * 	 * tips are nodes not reachable from any other node in the list 	 * 	 * the tips serve as a starting set for the work queue. 	 */
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|next
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|indegree_slab_at
argument_list|(
operator|&
name|indegree
argument_list|,
name|commit
argument_list|)
operator|)
operator|==
literal|1
condition|)
name|prio_queue_put
argument_list|(
operator|&
name|queue
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This is unfortunate; the initial tips need to be shown 	 * in the order given from the revision traversal machinery. 	 */
if|if
condition|(
name|sort_order
operator|==
name|REV_SORT_IN_GRAPH_ORDER
condition|)
name|prio_queue_reverse
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
comment|/* We no longer need the commit list */
name|free_commit_list
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|pptr
operator|=
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|commit
operator|=
name|prio_queue_get
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|int
modifier|*
name|pi
init|=
name|indegree_slab_at
argument_list|(
operator|&
name|indegree
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|pi
condition|)
continue|continue;
comment|/* 			 * parents are only enqueued for emission 			 * when all their children have been emitted thereby 			 * guaranteeing topological order. 			 */
if|if
condition|(
operator|--
operator|(
operator|*
name|pi
operator|)
operator|==
literal|1
condition|)
name|prio_queue_put
argument_list|(
operator|&
name|queue
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * all children of commit have already been 		 * emitted. we can emit it now. 		 */
operator|*
operator|(
name|indegree_slab_at
argument_list|(
operator|&
name|indegree
argument_list|,
name|commit
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
name|clear_indegree_slab
argument_list|(
operator|&
name|indegree
argument_list|)
expr_stmt|;
name|clear_prio_queue
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort_order
operator|==
name|REV_SORT_BY_AUTHOR_DATE
condition|)
name|clear_author_date_slab
argument_list|(
operator|&
name|author_date
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* merge-base stuff */
end_comment
begin_comment
comment|/* Remember to update object flag allocation in object.h */
end_comment
begin_define
DECL|macro|PARENT1
define|#
directive|define
name|PARENT1
value|(1u<<16)
end_define
begin_define
DECL|macro|PARENT2
define|#
directive|define
name|PARENT2
value|(1u<<17)
end_define
begin_define
DECL|macro|STALE
define|#
directive|define
name|STALE
value|(1u<<18)
end_define
begin_define
DECL|macro|RESULT
define|#
directive|define
name|RESULT
value|(1u<<19)
end_define
begin_decl_stmt
DECL|variable|all_flags
specifier|static
specifier|const
name|unsigned
name|all_flags
init|=
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator||
name|RESULT
operator|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|queue_has_nonstale
specifier|static
name|int
name|queue_has_nonstale
parameter_list|(
name|struct
name|prio_queue
modifier|*
name|queue
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|queue
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|queue
operator|->
name|array
index|[
name|i
index|]
operator|.
name|data
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* all input commits in one and twos[] must have been parsed! */
end_comment
begin_function
DECL|function|paint_down_to_common
specifier|static
name|struct
name|commit_list
modifier|*
name|paint_down_to_common
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|twos
parameter_list|)
block|{
name|struct
name|prio_queue
name|queue
init|=
block|{
name|compare_commits_by_commit_date
block|}
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|one
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT1
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|commit_list_append
argument_list|(
name|one
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|prio_queue_put
argument_list|(
operator|&
name|queue
argument_list|,
name|one
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|twos
index|[
name|i
index|]
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT2
expr_stmt|;
name|prio_queue_put
argument_list|(
operator|&
name|queue
argument_list|,
name|twos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|queue_has_nonstale
argument_list|(
operator|&
name|queue
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|prio_queue_get
argument_list|(
operator|&
name|queue
argument_list|)
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|(
name|PARENT1
operator||
name|PARENT2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|RESULT
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|RESULT
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Mark parents of a found merge stale */
name|flags
operator||=
name|STALE
expr_stmt|;
block|}
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|object
operator|.
name|flags
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
continue|continue;
if|if
condition|(
name|parse_commit
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|object
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
name|prio_queue_put
argument_list|(
operator|&
name|queue
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|clear_prio_queue
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|merge_bases_many
specifier|static
name|struct
name|commit_list
modifier|*
name|merge_bases_many
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|twos
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|one
operator|==
name|twos
index|[
name|i
index|]
condition|)
comment|/* 			 * We do not mark this even with RESULT so we do not 			 * have to clean it up. 			 */
return|return
name|commit_list_insert
argument_list|(
name|one
argument_list|,
operator|&
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|parse_commit
argument_list|(
name|one
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parse_commit
argument_list|(
name|twos
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|list
operator|=
name|paint_down_to_common
argument_list|(
name|one
argument_list|,
name|n
argument_list|,
name|twos
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
name|list
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
operator|)
condition|)
name|commit_list_insert_by_date
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_octopus_merge_bases
name|struct
name|commit_list
modifier|*
name|get_octopus_merge_bases
parameter_list|(
name|struct
name|commit_list
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
return|return
name|ret
return|;
name|commit_list_insert
argument_list|(
name|in
operator|->
name|item
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|in
operator|->
name|next
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|new
init|=
name|NULL
decl_stmt|,
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|j
operator|=
name|ret
init|;
name|j
condition|;
name|j
operator|=
name|j
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|bases
decl_stmt|;
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|i
operator|->
name|item
argument_list|,
name|j
operator|->
name|item
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|new
operator|=
name|bases
expr_stmt|;
else|else
name|end
operator|->
name|next
operator|=
name|bases
expr_stmt|;
for|for
control|(
name|k
operator|=
name|bases
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|next
control|)
name|end
operator|=
name|k
expr_stmt|;
block|}
name|ret
operator|=
name|new
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|remove_redundant
specifier|static
name|int
name|remove_redundant
parameter_list|(
name|struct
name|commit
modifier|*
modifier|*
name|array
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
comment|/* 	 * Some commit in the array may be an ancestor of 	 * another commit.  Move such commit to the end of 	 * the array, and return the number of commits that 	 * are independent from each other. 	 */
name|struct
name|commit
modifier|*
modifier|*
name|work
decl_stmt|;
name|unsigned
name|char
modifier|*
name|redundant
decl_stmt|;
name|int
modifier|*
name|filled_index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|filled
decl_stmt|;
name|work
operator|=
name|xcalloc
argument_list|(
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|redundant
operator|=
name|xcalloc
argument_list|(
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filled_index
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|filled_index
argument_list|)
operator|*
operator|(
name|cnt
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|parse_commit
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|commit_list
modifier|*
name|common
decl_stmt|;
if|if
condition|(
name|redundant
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|filled
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
operator|||
name|redundant
index|[
name|j
index|]
condition|)
continue|continue;
name|filled_index
index|[
name|filled
index|]
operator|=
name|j
expr_stmt|;
name|work
index|[
name|filled
operator|++
index|]
operator|=
name|array
index|[
name|j
index|]
expr_stmt|;
block|}
name|common
operator|=
name|paint_down_to_common
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|filled
argument_list|,
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
index|[
name|i
index|]
operator|->
name|object
operator|.
name|flags
operator|&
name|PARENT2
condition|)
name|redundant
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|filled
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|work
index|[
name|j
index|]
operator|->
name|object
operator|.
name|flags
operator|&
name|PARENT1
condition|)
name|redundant
index|[
name|filled_index
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|filled
condition|;
name|j
operator|++
control|)
name|clear_commit_marks
argument_list|(
name|work
index|[
name|j
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|common
argument_list|)
expr_stmt|;
block|}
comment|/* Now collect the result */
name|memcpy
argument_list|(
name|work
argument_list|,
name|array
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|filled
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|redundant
index|[
name|i
index|]
condition|)
name|array
index|[
name|filled
operator|++
index|]
operator|=
name|work
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|filled
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|redundant
index|[
name|i
index|]
condition|)
name|array
index|[
name|j
operator|++
index|]
operator|=
name|work
index|[
name|i
index|]
expr_stmt|;
name|free
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|redundant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filled_index
argument_list|)
expr_stmt|;
return|return
name|filled
return|;
block|}
end_function
begin_function
DECL|function|get_merge_bases_many
name|struct
name|commit_list
modifier|*
name|get_merge_bases_many
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|twos
parameter_list|,
name|int
name|cleanup
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|rslt
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|result
operator|=
name|merge_bases_many
argument_list|(
name|one
argument_list|,
name|n
argument_list|,
name|twos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|one
operator|==
name|twos
index|[
name|i
index|]
condition|)
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|result
operator|||
operator|!
name|result
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|cleanup
condition|)
block|{
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks_many
argument_list|(
name|n
argument_list|,
name|twos
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* There are more than one */
name|cnt
operator|=
name|commit_list_count
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|xcalloc
argument_list|(
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|result
operator|,
name|i
operator|=
literal|0
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|rslt
index|[
name|i
operator|++
index|]
operator|=
name|list
operator|->
name|item
expr_stmt|;
name|free_commit_list
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks_many
argument_list|(
name|n
argument_list|,
name|twos
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|remove_redundant
argument_list|(
name|rslt
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|commit_list_insert_by_date
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rslt
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_merge_bases
name|struct
name|commit_list
modifier|*
name|get_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|struct
name|commit
modifier|*
name|two
parameter_list|,
name|int
name|cleanup
parameter_list|)
block|{
return|return
name|get_merge_bases_many
argument_list|(
name|one
argument_list|,
literal|1
argument_list|,
operator|&
name|two
argument_list|,
name|cleanup
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Is "commit" a descendant of one of the elements on the "with_commit" list?  */
end_comment
begin_function
DECL|function|is_descendant_of
name|int
name|is_descendant_of
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_list
modifier|*
name|with_commit
parameter_list|)
block|{
if|if
condition|(
operator|!
name|with_commit
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|with_commit
condition|)
block|{
name|struct
name|commit
modifier|*
name|other
decl_stmt|;
name|other
operator|=
name|with_commit
operator|->
name|item
expr_stmt|;
name|with_commit
operator|=
name|with_commit
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|in_merge_bases
argument_list|(
name|other
argument_list|,
name|commit
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Is "commit" an ancestor of one of the "references"?  */
end_comment
begin_function
DECL|function|in_merge_bases_many
name|int
name|in_merge_bases_many
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|nr_reference
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|reference
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|bases
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return
name|ret
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_reference
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|parse_commit
argument_list|(
name|reference
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|ret
return|;
name|bases
operator|=
name|paint_down_to_common
argument_list|(
name|commit
argument_list|,
name|nr_reference
argument_list|,
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|PARENT2
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|commit
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks_many
argument_list|(
name|nr_reference
argument_list|,
name|reference
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|bases
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*  * Is "commit" an ancestor of (i.e. reachable from) the "reference"?  */
end_comment
begin_function
DECL|function|in_merge_bases
name|int
name|in_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit
modifier|*
name|reference
parameter_list|)
block|{
return|return
name|in_merge_bases_many
argument_list|(
name|commit
argument_list|,
literal|1
argument_list|,
operator|&
name|reference
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|reduce_heads
name|struct
name|commit_list
modifier|*
name|reduce_heads
parameter_list|(
name|struct
name|commit_list
modifier|*
name|heads
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|result
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|num_head
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|heads
condition|)
return|return
name|NULL
return|;
comment|/* Uniquify */
for|for
control|(
name|p
operator|=
name|heads
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|STALE
expr_stmt|;
for|for
control|(
name|p
operator|=
name|heads
operator|,
name|num_head
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
condition|)
continue|continue;
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|STALE
expr_stmt|;
name|num_head
operator|++
expr_stmt|;
block|}
name|array
operator|=
name|xcalloc
argument_list|(
name|num_head
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|heads
operator|,
name|i
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
condition|)
block|{
name|array
index|[
name|i
operator|++
index|]
operator|=
name|p
operator|->
name|item
expr_stmt|;
name|p
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|STALE
expr_stmt|;
block|}
block|}
name|num_head
operator|=
name|remove_redundant
argument_list|(
name|array
argument_list|,
name|num_head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_head
condition|;
name|i
operator|++
control|)
name|tail
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|array
index|[
name|i
index|]
argument_list|,
name|tail
argument_list|)
operator|->
name|next
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|gpg_sig_header
specifier|static
specifier|const
name|char
name|gpg_sig_header
index|[]
init|=
literal|"gpgsig"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|gpg_sig_header_len
specifier|static
specifier|const
name|int
name|gpg_sig_header_len
init|=
sizeof|sizeof
argument_list|(
name|gpg_sig_header
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|do_sign_commit
specifier|static
name|int
name|do_sign_commit
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|keyid
parameter_list|)
block|{
name|struct
name|strbuf
name|sig
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|inspos
decl_stmt|,
name|copypos
decl_stmt|;
comment|/* find the end of the header */
name|inspos
operator|=
name|strstr
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
literal|"\n\n"
argument_list|)
operator|-
name|buf
operator|->
name|buf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|keyid
operator|||
operator|!
operator|*
name|keyid
condition|)
name|keyid
operator|=
name|get_signing_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|sign_buffer
argument_list|(
name|buf
argument_list|,
operator|&
name|sig
argument_list|,
name|keyid
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|copypos
operator|=
literal|0
init|;
name|sig
operator|.
name|buf
index|[
name|copypos
index|]
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|bol
init|=
name|sig
operator|.
name|buf
operator|+
name|copypos
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
init|=
name|strchrnul
argument_list|(
name|bol
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|int
name|len
init|=
operator|(
name|eol
operator|-
name|bol
operator|)
operator|+
operator|!
operator|!
operator|*
name|eol
decl_stmt|;
if|if
condition|(
operator|!
name|copypos
condition|)
block|{
name|strbuf_insert
argument_list|(
name|buf
argument_list|,
name|inspos
argument_list|,
name|gpg_sig_header
argument_list|,
name|gpg_sig_header_len
argument_list|)
expr_stmt|;
name|inspos
operator|+=
name|gpg_sig_header_len
expr_stmt|;
block|}
name|strbuf_insert
argument_list|(
name|buf
argument_list|,
name|inspos
operator|++
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
name|buf
argument_list|,
name|inspos
argument_list|,
name|bol
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|inspos
operator|+=
name|len
expr_stmt|;
name|copypos
operator|+=
name|len
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_signed_commit
name|int
name|parse_signed_commit
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|strbuf
modifier|*
name|payload
parameter_list|,
name|struct
name|strbuf
modifier|*
name|signature
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
init|=
name|get_commit_buffer
argument_list|(
name|commit
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|int
name|in_signature
decl_stmt|,
name|saw_signature
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|line
operator|=
name|buffer
expr_stmt|;
name|tail
operator|=
name|buffer
operator|+
name|size
expr_stmt|;
name|in_signature
operator|=
literal|0
expr_stmt|;
name|saw_signature
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|line
operator|<
name|tail
condition|)
block|{
specifier|const
name|char
modifier|*
name|sig
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|next
init|=
name|memchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|,
name|tail
operator|-
name|line
argument_list|)
decl_stmt|;
name|next
operator|=
name|next
condition|?
name|next
operator|+
literal|1
else|:
name|tail
expr_stmt|;
if|if
condition|(
name|in_signature
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|sig
operator|=
name|line
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|line
argument_list|,
name|gpg_sig_header
argument_list|)
operator|&&
name|line
index|[
name|gpg_sig_header_len
index|]
operator|==
literal|' '
condition|)
name|sig
operator|=
name|line
operator|+
name|gpg_sig_header_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sig
condition|)
block|{
name|strbuf_add
argument_list|(
name|signature
argument_list|,
name|sig
argument_list|,
name|next
operator|-
name|sig
argument_list|)
expr_stmt|;
name|saw_signature
operator|=
literal|1
expr_stmt|;
name|in_signature
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'\n'
condition|)
comment|/* dump the whole remainder of the buffer */
name|next
operator|=
name|tail
expr_stmt|;
name|strbuf_add
argument_list|(
name|payload
argument_list|,
name|line
argument_list|,
name|next
operator|-
name|line
argument_list|)
expr_stmt|;
name|in_signature
operator|=
literal|0
expr_stmt|;
block|}
name|line
operator|=
name|next
expr_stmt|;
block|}
name|unuse_commit_buffer
argument_list|(
name|commit
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|saw_signature
return|;
block|}
end_function
begin_function
DECL|function|remove_signature
name|int
name|remove_signature
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
name|buf
operator|->
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
init|=
name|buf
operator|->
name|buf
operator|+
name|buf
operator|->
name|len
decl_stmt|;
name|int
name|in_signature
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|sig_start
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sig_end
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|line
operator|<
name|tail
condition|)
block|{
specifier|const
name|char
modifier|*
name|next
init|=
name|memchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|,
name|tail
operator|-
name|line
argument_list|)
decl_stmt|;
name|next
operator|=
name|next
condition|?
name|next
operator|+
literal|1
else|:
name|tail
expr_stmt|;
if|if
condition|(
name|in_signature
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|sig_end
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|line
argument_list|,
name|gpg_sig_header
argument_list|)
operator|&&
name|line
index|[
name|gpg_sig_header_len
index|]
operator|==
literal|' '
condition|)
block|{
name|sig_start
operator|=
name|line
expr_stmt|;
name|sig_end
operator|=
name|next
expr_stmt|;
name|in_signature
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'\n'
condition|)
comment|/* dump the whole remainder of the buffer */
name|next
operator|=
name|tail
expr_stmt|;
name|in_signature
operator|=
literal|0
expr_stmt|;
block|}
name|line
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sig_start
condition|)
name|strbuf_remove
argument_list|(
name|buf
argument_list|,
name|sig_start
operator|-
name|buf
operator|->
name|buf
argument_list|,
name|sig_end
operator|-
name|sig_start
argument_list|)
expr_stmt|;
return|return
name|sig_start
operator|!=
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|handle_signed_tag
specifier|static
name|void
name|handle_signed_tag
parameter_list|(
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|merge_remote_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|commit_extra_header
modifier|*
name|mergetag
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|len
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|desc
operator|=
name|merge_remote_util
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|desc
operator|||
operator|!
name|desc
operator|->
name|obj
condition|)
return|return;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|desc
operator|->
name|obj
operator|->
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
name|type
operator|!=
name|OBJ_TAG
condition|)
goto|goto
name|free_return
goto|;
name|len
operator|=
name|parse_signature
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|len
condition|)
goto|goto
name|free_return
goto|;
comment|/* 	 * We could verify this signature and either omit the tag when 	 * it does not validate, but the integrator may not have the 	 * public key of the signer of the tag he is merging, while a 	 * later auditor may have it while auditing, so let's not run 	 * verify-signed-buffer here for now... 	 * 	 * if (verify_signed_buffer(buf, len, buf + len, size - len, ...)) 	 *	warn("warning: signed tag unverified."); 	 */
name|mergetag
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mergetag
argument_list|)
argument_list|)
expr_stmt|;
name|mergetag
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"mergetag"
argument_list|)
expr_stmt|;
name|mergetag
operator|->
name|value
operator|=
name|buf
expr_stmt|;
name|mergetag
operator|->
name|len
operator|=
name|size
expr_stmt|;
operator|*
operator|*
name|tail
operator|=
name|mergetag
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|mergetag
operator|->
name|next
expr_stmt|;
return|return;
name|free_return
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
specifier|static
struct|struct
block|{
DECL|member|result
name|char
name|result
decl_stmt|;
DECL|member|check
specifier|const
name|char
modifier|*
name|check
decl_stmt|;
block|}
DECL|variable|sigcheck_gpg_status
name|sigcheck_gpg_status
index|[]
init|=
block|{
block|{
literal|'G'
block|,
literal|"\n[GNUPG:] GOODSIG "
block|}
block|,
block|{
literal|'B'
block|,
literal|"\n[GNUPG:] BADSIG "
block|}
block|,
block|{
literal|'U'
block|,
literal|"\n[GNUPG:] TRUST_NEVER"
block|}
block|,
block|{
literal|'U'
block|,
literal|"\n[GNUPG:] TRUST_UNDEFINED"
block|}
block|, }
struct|;
end_struct
begin_function
DECL|function|parse_gpg_output
specifier|static
name|void
name|parse_gpg_output
parameter_list|(
name|struct
name|signature_check
modifier|*
name|sigc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buf
init|=
name|sigc
operator|->
name|gpg_status
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Iterate over all search strings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|sigcheck_gpg_status
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|found
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|skip_prefix
argument_list|(
name|buf
argument_list|,
name|sigcheck_gpg_status
index|[
name|i
index|]
operator|.
name|check
operator|+
literal|1
argument_list|,
operator|&
name|found
argument_list|)
condition|)
block|{
name|found
operator|=
name|strstr
argument_list|(
name|buf
argument_list|,
name|sigcheck_gpg_status
index|[
name|i
index|]
operator|.
name|check
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
continue|continue;
name|found
operator|+=
name|strlen
argument_list|(
name|sigcheck_gpg_status
index|[
name|i
index|]
operator|.
name|check
argument_list|)
expr_stmt|;
block|}
name|sigc
operator|->
name|result
operator|=
name|sigcheck_gpg_status
index|[
name|i
index|]
operator|.
name|result
expr_stmt|;
comment|/* The trust messages are not followed by key/signer information */
if|if
condition|(
name|sigc
operator|->
name|result
operator|!=
literal|'U'
condition|)
block|{
name|sigc
operator|->
name|key
operator|=
name|xmemdupz
argument_list|(
name|found
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|found
operator|+=
literal|17
expr_stmt|;
name|next
operator|=
name|strchrnul
argument_list|(
name|found
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|sigc
operator|->
name|signer
operator|=
name|xmemdupz
argument_list|(
name|found
argument_list|,
name|next
operator|-
name|found
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|check_commit_signature
name|void
name|check_commit_signature
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|signature_check
modifier|*
name|sigc
parameter_list|)
block|{
name|struct
name|strbuf
name|payload
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|signature
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|gpg_output
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|gpg_status
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|status
decl_stmt|;
name|sigc
operator|->
name|result
operator|=
literal|'N'
expr_stmt|;
if|if
condition|(
name|parse_signed_commit
argument_list|(
name|commit
argument_list|,
operator|&
name|payload
argument_list|,
operator|&
name|signature
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
name|status
operator|=
name|verify_signed_buffer
argument_list|(
name|payload
operator|.
name|buf
argument_list|,
name|payload
operator|.
name|len
argument_list|,
name|signature
operator|.
name|buf
argument_list|,
name|signature
operator|.
name|len
argument_list|,
operator|&
name|gpg_output
argument_list|,
operator|&
name|gpg_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
operator|!
name|gpg_output
operator|.
name|len
condition|)
goto|goto
name|out
goto|;
name|sigc
operator|->
name|payload
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|payload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigc
operator|->
name|gpg_output
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|gpg_output
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigc
operator|->
name|gpg_status
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|gpg_status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parse_gpg_output
argument_list|(
name|sigc
argument_list|)
expr_stmt|;
name|out
label|:
name|strbuf_release
argument_list|(
operator|&
name|gpg_status
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|gpg_output
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|payload
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|signature
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append_merge_tag_headers
name|void
name|append_merge_tag_headers
parameter_list|(
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|handle_signed_tag
argument_list|(
name|parent
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_extra_header
specifier|static
name|void
name|add_extra_header
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buffer
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
name|extra
parameter_list|)
block|{
name|strbuf_addstr
argument_list|(
name|buffer
argument_list|,
name|extra
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|->
name|len
condition|)
name|strbuf_add_lines
argument_list|(
name|buffer
argument_list|,
literal|" "
argument_list|,
name|extra
operator|->
name|value
argument_list|,
name|extra
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|strbuf_addch
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_commit_extra_headers
name|struct
name|commit_extra_header
modifier|*
name|read_commit_extra_headers
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|exclude
parameter_list|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|extra
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
init|=
name|get_commit_buffer
argument_list|(
name|commit
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|extra
operator|=
name|read_commit_extra_header_lines
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
name|exclude
argument_list|)
expr_stmt|;
name|unuse_commit_buffer
argument_list|(
name|commit
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|extra
return|;
block|}
end_function
begin_function
DECL|function|for_each_mergetag
name|void
name|for_each_mergetag
parameter_list|(
name|each_mergetag_fn
name|fn
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|extra
decl_stmt|,
modifier|*
name|to_free
decl_stmt|;
name|to_free
operator|=
name|read_commit_extra_headers
argument_list|(
name|commit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|extra
operator|=
name|to_free
init|;
name|extra
condition|;
name|extra
operator|=
name|extra
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|extra
operator|->
name|key
argument_list|,
literal|"mergetag"
argument_list|)
condition|)
continue|continue;
comment|/* not a merge tag */
name|fn
argument_list|(
name|commit
argument_list|,
name|extra
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|free_commit_extra_headers
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|standard_header_field
specifier|static
specifier|inline
name|int
name|standard_header_field
parameter_list|(
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
operator|(
name|len
operator|==
literal|4
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"tree "
argument_list|,
literal|5
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|6
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|6
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"author "
argument_list|,
literal|7
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|9
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"committer "
argument_list|,
literal|10
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|8
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"encoding "
argument_list|,
literal|9
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|excluded_header_field
specifier|static
name|int
name|excluded_header_field
parameter_list|(
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|exclude
parameter_list|)
block|{
if|if
condition|(
operator|!
name|exclude
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|exclude
condition|)
block|{
name|size_t
name|xlen
init|=
name|strlen
argument_list|(
operator|*
name|exclude
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|xlen
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
operator|*
name|exclude
argument_list|,
name|xlen
argument_list|)
operator|&&
name|field
index|[
name|xlen
index|]
operator|==
literal|' '
condition|)
return|return
literal|1
return|;
name|exclude
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_commit_extra_header_lines
specifier|static
name|struct
name|commit_extra_header
modifier|*
name|read_commit_extra_header_lines
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|exclude
parameter_list|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|extra
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|extra
decl_stmt|,
modifier|*
name|it
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|eof
decl_stmt|,
modifier|*
name|eob
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
for|for
control|(
name|line
operator|=
name|buffer
operator|,
name|eob
operator|=
name|line
operator|+
name|size
init|;
name|line
operator|<
name|eob
operator|&&
operator|*
name|line
operator|!=
literal|'\n'
condition|;
name|line
operator|=
name|next
control|)
block|{
name|next
operator|=
name|memchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|,
name|eob
operator|-
name|line
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
condition|?
name|next
operator|+
literal|1
else|:
name|eob
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|' '
condition|)
block|{
comment|/* continuation */
if|if
condition|(
name|it
condition|)
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|next
operator|-
operator|(
name|line
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|it
condition|)
name|it
operator|->
name|value
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|it
operator|->
name|len
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|it
operator|=
name|NULL
expr_stmt|;
name|eof
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|<=
name|eof
condition|)
name|eof
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|standard_header_field
argument_list|(
name|line
argument_list|,
name|eof
operator|-
name|line
argument_list|)
operator|||
name|excluded_header_field
argument_list|(
name|line
argument_list|,
name|eof
operator|-
name|line
argument_list|,
name|exclude
argument_list|)
condition|)
continue|continue;
name|it
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|key
operator|=
name|xmemdupz
argument_list|(
name|line
argument_list|,
name|eof
operator|-
name|line
argument_list|)
expr_stmt|;
operator|*
name|tail
operator|=
name|it
expr_stmt|;
name|tail
operator|=
operator|&
name|it
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|eof
operator|+
literal|1
operator|<
name|next
condition|)
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|eof
operator|+
literal|1
argument_list|,
name|next
operator|-
operator|(
name|eof
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
condition|)
name|it
operator|->
name|value
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|it
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
name|extra
return|;
block|}
end_function
begin_function
DECL|function|free_commit_extra_headers
name|void
name|free_commit_extra_headers
parameter_list|(
name|struct
name|commit_extra_header
modifier|*
name|extra
parameter_list|)
block|{
while|while
condition|(
name|extra
condition|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|next
init|=
name|extra
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|extra
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|extra
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|commit_tree
name|int
name|commit_tree
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msg_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|tree
parameter_list|,
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
name|unsigned
name|char
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|sign_commit
parameter_list|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|extra
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|extra
decl_stmt|;
name|int
name|result
decl_stmt|;
name|append_merge_tag_headers
argument_list|(
name|parents
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|result
operator|=
name|commit_tree_extended
argument_list|(
name|msg
argument_list|,
name|msg_len
argument_list|,
name|tree
argument_list|,
name|parents
argument_list|,
name|ret
argument_list|,
name|author
argument_list|,
name|sign_commit
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|free_commit_extra_headers
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|find_invalid_utf8
specifier|static
name|int
name|find_invalid_utf8
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|max_codepoint
index|[]
init|=
block|{
literal|0x7f
block|,
literal|0x7ff
block|,
literal|0xffff
block|,
literal|0x10ffff
block|}
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|bad_offset
decl_stmt|;
name|unsigned
name|int
name|codepoint
decl_stmt|;
name|unsigned
name|int
name|min_val
decl_stmt|,
name|max_val
decl_stmt|;
name|len
operator|--
expr_stmt|;
name|offset
operator|++
expr_stmt|;
comment|/* Simple US-ASCII? No worries. */
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
continue|continue;
name|bad_offset
operator|=
name|offset
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Count how many more high bits set: that's how 		 * many more bytes this sequence should have. 		 */
name|bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|&
literal|0x40
condition|)
block|{
name|c
operator|<<=
literal|1
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
comment|/* 		 * Must be between 1 and 3 more bytes.  Longer sequences result in 		 * codepoints beyond U+10FFFF, which are guaranteed never to exist. 		 */
if|if
condition|(
name|bytes
operator|<
literal|1
operator|||
literal|3
operator|<
name|bytes
condition|)
return|return
name|bad_offset
return|;
comment|/* Do we *have* that many bytes? */
if|if
condition|(
name|len
operator|<
name|bytes
condition|)
return|return
name|bad_offset
return|;
comment|/* 		 * Place the encoded bits at the bottom of the value and compute the 		 * valid range. 		 */
name|codepoint
operator|=
operator|(
name|c
operator|&
literal|0x7f
operator|)
operator|>>
name|bytes
expr_stmt|;
name|min_val
operator|=
name|max_codepoint
index|[
name|bytes
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|max_val
operator|=
name|max_codepoint
index|[
name|bytes
index|]
expr_stmt|;
name|offset
operator|+=
name|bytes
expr_stmt|;
name|len
operator|-=
name|bytes
expr_stmt|;
comment|/* And verify that they are good continuation bytes */
do|do
block|{
name|codepoint
operator|<<=
literal|6
expr_stmt|;
name|codepoint
operator||=
operator|*
name|buf
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|buf
operator|++
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
name|bad_offset
return|;
block|}
do|while
condition|(
operator|--
name|bytes
condition|)
do|;
comment|/* Reject codepoints that are out of range for the sequence length. */
if|if
condition|(
name|codepoint
operator|<
name|min_val
operator|||
name|codepoint
operator|>
name|max_val
condition|)
return|return
name|bad_offset
return|;
comment|/* Surrogates are only for UTF-16 and cannot be encoded in UTF-8. */
if|if
condition|(
operator|(
name|codepoint
operator|&
literal|0x1ff800
operator|)
operator|==
literal|0xd800
condition|)
return|return
name|bad_offset
return|;
comment|/* U+xxFFFE and U+xxFFFF are guaranteed non-characters. */
if|if
condition|(
operator|(
name|codepoint
operator|&
literal|0xfffe
operator|)
operator|==
literal|0xfffe
condition|)
return|return
name|bad_offset
return|;
comment|/* So are anything in the range U+FDD0..U+FDEF. */
if|if
condition|(
name|codepoint
operator|>=
literal|0xfdd0
operator|&&
name|codepoint
operator|<=
literal|0xfdef
condition|)
return|return
name|bad_offset
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * This verifies that the buffer is in proper utf8 format.  *  * If it isn't, it assumes any non-utf8 characters are Latin1,  * and does the conversion.  */
end_comment
begin_function
DECL|function|verify_utf8
specifier|static
name|int
name|verify_utf8
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|long
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|bad
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|replace
index|[
literal|2
index|]
decl_stmt|;
name|bad
operator|=
name|find_invalid_utf8
argument_list|(
name|buf
operator|->
name|buf
operator|+
name|pos
argument_list|,
name|buf
operator|->
name|len
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad
operator|<
literal|0
condition|)
return|return
name|ok
return|;
name|pos
operator|+=
name|bad
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|buf
operator|->
name|buf
index|[
name|pos
index|]
expr_stmt|;
name|strbuf_remove
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We know 'c' must be in the range 128-255 */
name|replace
index|[
literal|0
index|]
operator|=
literal|0xc0
operator|+
operator|(
name|c
operator|>>
literal|6
operator|)
expr_stmt|;
name|replace
index|[
literal|1
index|]
operator|=
literal|0x80
operator|+
operator|(
name|c
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|strbuf_insert
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|replace
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|commit_utf8_warn
specifier|static
specifier|const
name|char
name|commit_utf8_warn
index|[]
init|=
literal|"Warning: commit message did not conform to UTF-8.\n"
literal|"You may want to amend it after fixing the message, or set the config\n"
literal|"variable i18n.commitencoding to the encoding your project uses.\n"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|commit_tree_extended
name|int
name|commit_tree_extended
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msg_len
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|tree
parameter_list|,
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
name|unsigned
name|char
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|sign_commit
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
name|extra
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|int
name|encoding_is_utf8
decl_stmt|;
name|struct
name|strbuf
name|buffer
decl_stmt|;
name|assert_sha1_type
argument_list|(
name|tree
argument_list|,
name|OBJ_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memchr
argument_list|(
name|msg
argument_list|,
literal|'\0'
argument_list|,
name|msg_len
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"a NUL byte in commit log message not allowed."
argument_list|)
return|;
comment|/* Not having i18n.commitencoding is the same as having utf-8 */
name|encoding_is_utf8
operator|=
name|is_encoding_utf8
argument_list|(
name|git_commit_encoding
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|buffer
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
comment|/* should avoid reallocs for the headers */
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"tree %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE! This ordering means that the same exact tree merged with a 	 * different order of parents will be a _different_ changeset even 	 * if everything else stays the same. 	 */
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
name|parents
operator|->
name|next
decl_stmt|;
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"parent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|parents
operator|=
name|next
expr_stmt|;
block|}
comment|/* Person/date information */
if|if
condition|(
operator|!
name|author
condition|)
name|author
operator|=
name|git_author_info
argument_list|(
name|IDENT_STRICT
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"author %s\n"
argument_list|,
name|author
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"committer %s\n"
argument_list|,
name|git_committer_info
argument_list|(
name|IDENT_STRICT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding_is_utf8
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"encoding %s\n"
argument_list|,
name|git_commit_encoding
argument_list|)
expr_stmt|;
while|while
condition|(
name|extra
condition|)
block|{
name|add_extra_header
argument_list|(
operator|&
name|buffer
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|extra
operator|=
name|extra
operator|->
name|next
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* And add the comment */
name|strbuf_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|msg
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
comment|/* And check the encoding */
if|if
condition|(
name|encoding_is_utf8
operator|&&
operator|!
name|verify_utf8
argument_list|(
operator|&
name|buffer
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|commit_utf8_warn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign_commit
operator|&&
name|do_sign_commit
argument_list|(
operator|&
name|buffer
argument_list|,
name|sign_commit
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|result
operator|=
name|write_sha1_file
argument_list|(
name|buffer
operator|.
name|buf
argument_list|,
name|buffer
operator|.
name|len
argument_list|,
name|commit_type
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_merge_parent
name|struct
name|commit
modifier|*
name|get_merge_parent
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|obj
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|commit
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|peel_to_type
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|obj
argument_list|,
name|OBJ_COMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|&&
operator|!
name|commit
operator|->
name|util
condition|)
block|{
name|struct
name|merge_remote_desc
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|desc
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|commit
operator|->
name|util
operator|=
name|desc
expr_stmt|;
block|}
return|return
name|commit
return|;
block|}
end_function
begin_comment
comment|/*  * Append a commit to the end of the commit_list.  *  * next starts by pointing to the variable that holds the head of an  * empty commit_list, and is updated to point to the "next" field of  * the last item on the list as new commits are appended.  *  * Usage example:  *  *     struct commit_list *list;  *     struct commit_list **next =&list;  *  *     next = commit_list_append(c1, next);  *     next = commit_list_append(c2, next);  *     assert(commit_list_count(list) == 2);  *     return list;  */
end_comment
begin_function
DECL|function|commit_list_append
name|struct
name|commit_list
modifier|*
modifier|*
name|commit_list_append
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_list
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|item
operator|=
name|commit
expr_stmt|;
operator|*
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|next
return|;
block|}
end_function
begin_function
DECL|function|print_commit_list
name|void
name|print_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|format_cur
parameter_list|,
specifier|const
name|char
modifier|*
name|format_last
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|format
init|=
name|list
operator|->
name|next
condition|?
name|format_cur
else|:
name|format_last
decl_stmt|;
name|printf
argument_list|(
name|format
argument_list|,
name|sha1_to_hex
argument_list|(
name|list
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
end_unit
