begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_decl_stmt
DECL|variable|save_commit_buffer
name|int
name|save_commit_buffer
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|sort_node
struct|struct
name|sort_node
block|{
comment|/* 	 * the number of children of the associated commit 	 * that also occur in the list being sorted. 	 */
DECL|member|indegree
name|unsigned
name|int
name|indegree
decl_stmt|;
comment|/* 	 * reference to original list item that we will re-use 	 * on output. 	 */
DECL|member|list_item
name|struct
name|commit_list
modifier|*
name|list_item
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|commit_type
specifier|const
name|char
modifier|*
name|commit_type
init|=
literal|"commit"
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|cmt_fmt_map
struct|struct
name|cmt_fmt_map
block|{
DECL|member|n
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
DECL|member|cmp_len
name|size_t
name|cmp_len
decl_stmt|;
DECL|member|v
name|enum
name|cmit_fmt
name|v
decl_stmt|;
block|}
DECL|variable|cmt_fmts
name|cmt_fmts
index|[]
init|=
block|{
block|{
literal|"raw"
block|,
literal|1
block|,
name|CMIT_FMT_RAW
block|}
block|,
block|{
literal|"medium"
block|,
literal|1
block|,
name|CMIT_FMT_MEDIUM
block|}
block|,
block|{
literal|"short"
block|,
literal|1
block|,
name|CMIT_FMT_SHORT
block|}
block|,
block|{
literal|"email"
block|,
literal|1
block|,
name|CMIT_FMT_EMAIL
block|}
block|,
block|{
literal|"full"
block|,
literal|5
block|,
name|CMIT_FMT_FULL
block|}
block|,
block|{
literal|"fuller"
block|,
literal|5
block|,
name|CMIT_FMT_FULLER
block|}
block|,
block|{
literal|"oneline"
block|,
literal|1
block|,
name|CMIT_FMT_ONELINE
block|}
block|, }
struct|;
end_struct
begin_function
DECL|function|get_commit_format
name|enum
name|cmit_fmt
name|get_commit_format
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
return|return
name|CMIT_FMT_DEFAULT
return|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'='
condition|)
name|arg
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cmt_fmts
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
name|cmt_fmts
index|[
name|i
index|]
operator|.
name|n
argument_list|,
name|cmt_fmts
index|[
name|i
index|]
operator|.
name|cmp_len
argument_list|)
condition|)
return|return
name|cmt_fmts
index|[
name|i
index|]
operator|.
name|v
return|;
block|}
name|die
argument_list|(
literal|"invalid --pretty format: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|check_commit
specifier|static
name|struct
name|commit
modifier|*
name|check_commit
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|"Object %s is a %s, not a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|obj
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference_gently
name|struct
name|commit
modifier|*
name|lookup_commit_reference_gently
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
return|return
name|check_commit
argument_list|(
name|obj
argument_list|,
name|sha1
argument_list|,
name|quiet
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference
name|struct
name|commit
modifier|*
name|lookup_commit_reference
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit
name|struct
name|commit
modifier|*
name|lookup_commit
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|lookup_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|struct
name|commit
modifier|*
name|ret
init|=
name|alloc_commit_node
argument_list|()
decl_stmt|;
name|created_object
argument_list|(
name|sha1
argument_list|,
operator|&
name|ret
operator|->
name|object
argument_list|)
expr_stmt|;
name|ret
operator|->
name|object
operator|.
name|type
operator|=
name|OBJ_COMMIT
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|obj
operator|->
name|type
condition|)
name|obj
operator|->
name|type
operator|=
name|OBJ_COMMIT
expr_stmt|;
return|return
name|check_commit
argument_list|(
name|obj
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_date
specifier|static
name|unsigned
name|long
name|parse_commit_date
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|long
name|date
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"author"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"committer"
argument_list|,
literal|9
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|buf
operator|++
operator|!=
literal|'>'
condition|)
comment|/* nada */
empty_stmt|;
name|date
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|==
name|ULONG_MAX
condition|)
name|date
operator|=
literal|0
expr_stmt|;
return|return
name|date
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|commit_graft
specifier|static
name|struct
name|commit_graft
modifier|*
modifier|*
name|commit_graft
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_graft_alloc
DECL|variable|commit_graft_nr
specifier|static
name|int
name|commit_graft_alloc
decl_stmt|,
name|commit_graft_nr
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|commit_graft_pos
specifier|static
name|int
name|commit_graft_pos
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|commit_graft_nr
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|int
name|mi
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|commit_graft
index|[
name|mi
index|]
decl_stmt|;
name|int
name|cmp
init|=
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|mi
return|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|hi
operator|=
name|mi
expr_stmt|;
else|else
name|lo
operator|=
name|mi
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|-
name|lo
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|register_commit_graft
name|int
name|register_commit_graft
parameter_list|(
name|struct
name|commit_graft
modifier|*
name|graft
parameter_list|,
name|int
name|ignore_dups
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pos
condition|)
block|{
if|if
condition|(
name|ignore_dups
condition|)
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|commit_graft
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|commit_graft_alloc
operator|<=
operator|++
name|commit_graft_nr
condition|)
block|{
name|commit_graft_alloc
operator|=
name|alloc_nr
argument_list|(
name|commit_graft_alloc
argument_list|)
expr_stmt|;
name|commit_graft
operator|=
name|xrealloc
argument_list|(
name|commit_graft
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit_graft
argument_list|)
operator|*
name|commit_graft_alloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
name|commit_graft_nr
condition|)
name|memmove
argument_list|(
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
name|commit_graft
operator|+
name|pos
argument_list|,
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|commit_graft
argument_list|)
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_graft_line
name|struct
name|commit_graft
modifier|*
name|read_graft_line
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|i
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|%
literal|41
condition|)
block|{
name|bad_graft_data
label|:
name|error
argument_list|(
literal|"bad graft data: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|41
operator|-
literal|1
expr_stmt|;
name|graft
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|graft
argument_list|)
operator|+
literal|20
operator|*
name|i
argument_list|)
expr_stmt|;
name|graft
operator|->
name|nr_parent
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
argument_list|,
name|graft
operator|->
name|sha1
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
for|for
control|(
name|i
operator|=
literal|40
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|41
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
goto|goto
name|bad_graft_data
goto|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
operator|+
name|i
operator|+
literal|1
argument_list|,
name|graft
operator|->
name|parent
index|[
name|i
operator|/
literal|41
index|]
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
block|}
return|return
name|graft
return|;
block|}
end_function
begin_function
DECL|function|read_graft_file
name|int
name|read_graft_file
parameter_list|(
specifier|const
name|char
modifier|*
name|graft_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|graft_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|read_graft_line
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|graft
condition|)
continue|continue;
if|if
condition|(
name|register_commit_graft
argument_list|(
name|graft
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate graft data: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|prepare_commit_graft
specifier|static
name|void
name|prepare_commit_graft
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|commit_graft_prepared
decl_stmt|;
name|char
modifier|*
name|graft_file
decl_stmt|;
if|if
condition|(
name|commit_graft_prepared
condition|)
return|return;
name|graft_file
operator|=
name|get_graft_file
argument_list|()
expr_stmt|;
name|read_graft_file
argument_list|(
name|graft_file
argument_list|)
expr_stmt|;
comment|/* make sure shallows are read */
name|is_repository_shallow
argument_list|()
expr_stmt|;
name|commit_graft_prepared
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lookup_commit_graft
specifier|static
name|struct
name|commit_graft
modifier|*
name|lookup_commit_graft
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|prepare_commit_graft
argument_list|()
expr_stmt|;
name|pos
operator|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|commit_graft
index|[
name|pos
index|]
return|;
block|}
end_function
begin_function
DECL|function|write_shallow_commits
name|int
name|write_shallow_commits
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|use_pack_protocol
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_graft_nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|commit_graft
index|[
name|i
index|]
operator|->
name|nr_parent
operator|<
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|commit_graft
index|[
name|i
index|]
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|use_pack_protocol
condition|)
name|packet_write
argument_list|(
name|fd
argument_list|,
literal|"shallow %s"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|hex
argument_list|,
literal|40
argument_list|)
operator|!=
literal|40
condition|)
break|break;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|unregister_shallow
name|int
name|unregister_shallow
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|commit_graft_nr
condition|)
name|memcpy
argument_list|(
name|commit_graft
operator|+
name|pos
argument_list|,
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commit_graft
operator|*
argument_list|)
operator|*
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|commit_graft_nr
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_buffer
name|int
name|parse_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|char
modifier|*
name|tail
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
name|unsigned
name|char
name|parent
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
decl_stmt|;
name|unsigned
name|n_refs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|item
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|tail
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|5
operator|||
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"tree "
argument_list|,
literal|5
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"bogus commit object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|45
operator|||
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|5
argument_list|,
name|parent
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"bad tree pointer in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|item
operator|->
name|tree
operator|=
name|lookup_tree
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|tree
condition|)
name|n_refs
operator|++
expr_stmt|;
name|bufptr
operator|+=
literal|46
expr_stmt|;
comment|/* "tree " + "hex sha1" + "\n" */
name|pptr
operator|=
operator|&
name|item
operator|->
name|parents
expr_stmt|;
name|graft
operator|=
name|lookup_commit_graft
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
while|while
condition|(
name|bufptr
operator|+
literal|48
operator|<
name|tail
operator|&&
operator|!
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|48
operator|||
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|7
argument_list|,
name|parent
argument_list|)
operator|||
name|bufptr
index|[
literal|47
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|error
argument_list|(
literal|"bad parents in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|bufptr
operator|+=
literal|48
expr_stmt|;
if|if
condition|(
name|graft
condition|)
continue|continue;
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
condition|)
block|{
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
name|n_refs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|graft
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graft
operator|->
name|nr_parent
condition|;
name|i
operator|++
control|)
block|{
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|graft
operator|->
name|parent
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_parent
condition|)
continue|continue;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
name|n_refs
operator|++
expr_stmt|;
block|}
block|}
name|item
operator|->
name|date
operator|=
name|parse_commit_date
argument_list|(
name|bufptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|track_object_refs
condition|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
name|struct
name|object_refs
modifier|*
name|refs
init|=
name|alloc_object_refs
argument_list|(
name|n_refs
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|tree
condition|)
name|refs
operator|->
name|ref
index|[
name|i
operator|++
index|]
operator|=
operator|&
name|item
operator|->
name|tree
operator|->
name|object
expr_stmt|;
for|for
control|(
name|p
operator|=
name|item
operator|->
name|parents
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|refs
operator|->
name|ref
index|[
name|i
operator|++
index|]
operator|=
operator|&
name|p
operator|->
name|item
operator|->
name|object
expr_stmt|;
name|set_object_refs
argument_list|(
operator|&
name|item
operator|->
name|object
argument_list|,
name|refs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit
name|int
name|parse_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|)
block|{
name|char
name|type
index|[
literal|20
index|]
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|error
argument_list|(
literal|"Could not read %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|commit_type
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Object %s not a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
block|}
name|ret
operator|=
name|parse_commit_buffer
argument_list|(
name|item
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_commit_buffer
operator|&&
operator|!
name|ret
condition|)
block|{
name|item
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|commit_list_insert
name|struct
name|commit_list
modifier|*
name|commit_list_insert
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|new_list
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_list
argument_list|)
argument_list|)
decl_stmt|;
name|new_list
operator|->
name|item
operator|=
name|item
expr_stmt|;
name|new_list
operator|->
name|next
operator|=
operator|*
name|list_p
expr_stmt|;
operator|*
name|list_p
operator|=
name|new_list
expr_stmt|;
return|return
name|new_list
return|;
block|}
end_function
begin_function
DECL|function|free_commit_list
name|void
name|free_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|temp
init|=
name|list
decl_stmt|;
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|insert_by_date
name|struct
name|commit_list
modifier|*
name|insert_by_date
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
modifier|*
name|pp
init|=
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|item
operator|->
name|date
operator|<
name|item
operator|->
name|date
condition|)
block|{
break|break;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|commit_list_insert
argument_list|(
name|item
argument_list|,
name|pp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sort_by_date
name|void
name|sort_by_date
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|list
condition|)
block|{
name|insert_by_date
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|item
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|ret
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pop_most_recent_commit
name|struct
name|commit
modifier|*
name|pop_most_recent_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|ret
init|=
operator|(
operator|*
name|list
operator|)
operator|->
name|item
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|ret
operator|->
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|old
init|=
operator|*
name|list
decl_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|parse_commit
argument_list|(
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|mark
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|mark
expr_stmt|;
name|insert_by_date
argument_list|(
name|commit
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|clear_commit_marks
name|void
name|clear_commit_marks
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|mark
expr_stmt|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
comment|/* Have we already cleared this? */
if|if
condition|(
name|mark
operator|&
name|parent
operator|->
name|object
operator|.
name|flags
condition|)
name|clear_commit_marks
argument_list|(
name|parent
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Generic support for pretty-printing the header  */
end_comment
begin_function
DECL|function|get_one_line
specifier|static
name|int
name|get_one_line
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|char
name|c
init|=
operator|*
name|msg
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/* High bit set, or ISO-2022-INT */
end_comment
begin_function
DECL|function|non_ascii
specifier|static
name|int
name|non_ascii
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|ch
operator|=
operator|(
name|ch
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|||
operator|(
name|ch
operator|==
literal|0x1b
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|is_rfc2047_special
specifier|static
name|int
name|is_rfc2047_special
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'='
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'?'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'_'
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|add_rfc2047
specifier|static
name|int
name|add_rfc2047
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|needquote
decl_stmt|;
name|char
name|q_encoding
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|q_encoding_fmt
init|=
literal|"=?%s?q?"
decl_stmt|;
for|for
control|(
name|i
operator|=
name|needquote
operator|=
literal|0
init|;
operator|!
name|needquote
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|line
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
name|needquote
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|<
name|len
operator|)
operator|&&
operator|(
name|ch
operator|==
literal|'='
operator|&&
name|line
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'?'
operator|)
condition|)
name|needquote
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|needquote
condition|)
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*s"
argument_list|,
name|len
argument_list|,
name|line
argument_list|)
return|;
name|i
operator|=
name|snprintf
argument_list|(
name|q_encoding
argument_list|,
sizeof|sizeof
argument_list|(
name|q_encoding
argument_list|)
argument_list|,
name|q_encoding_fmt
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|q_encoding
argument_list|)
operator|<
name|i
condition|)
name|die
argument_list|(
literal|"Insanely long encoding name %s"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|q_encoding
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|ch
init|=
name|line
index|[
name|i
index|]
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|is_rfc2047_special
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"=%02X"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
else|else
operator|*
name|bp
operator|++
operator|=
name|ch
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|bp
argument_list|,
literal|"?="
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
return|return
name|bp
operator|-
name|buf
return|;
block|}
end_function
begin_function
DECL|function|add_user_info
specifier|static
name|int
name|add_user_info
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
name|relative_date
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|unsigned
name|long
name|time
decl_stmt|;
name|int
name|tz
decl_stmt|,
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|filler
init|=
literal|"    "
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
condition|)
return|return
literal|0
return|;
name|date
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|date
condition|)
return|return
literal|0
return|;
name|namelen
operator|=
operator|++
name|date
operator|-
name|line
expr_stmt|;
name|time
operator|=
name|strtoul
argument_list|(
name|date
argument_list|,
operator|&
name|date
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tz
operator|=
name|strtol
argument_list|(
name|date
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
block|{
name|char
modifier|*
name|name_tail
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'<'
argument_list|)
decl_stmt|;
name|int
name|display_name_length
decl_stmt|;
if|if
condition|(
operator|!
name|name_tail
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|line
operator|<
name|name_tail
operator|&&
name|isspace
argument_list|(
name|name_tail
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|name_tail
operator|--
expr_stmt|;
name|display_name_length
operator|=
name|name_tail
operator|-
name|line
expr_stmt|;
name|filler
operator|=
literal|""
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"From: "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|add_rfc2047
argument_list|(
name|buf
operator|+
name|ret
argument_list|,
name|line
argument_list|,
name|display_name_length
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|ret
argument_list|,
name|name_tail
argument_list|,
name|namelen
operator|-
name|display_name_length
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|namelen
operator|-
name|display_name_length
expr_stmt|;
name|buf
index|[
name|ret
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %.*s%.*s\n"
argument_list|,
name|what
argument_list|,
operator|(
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|?
literal|4
else|:
literal|0
argument_list|,
name|filler
argument_list|,
name|namelen
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|CMIT_FMT_MEDIUM
case|:
name|ret
operator|+=
name|sprintf
argument_list|(
name|buf
operator|+
name|ret
argument_list|,
literal|"Date:   %s\n"
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|relative_date
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_EMAIL
case|:
name|ret
operator|+=
name|sprintf
argument_list|(
name|buf
operator|+
name|ret
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|show_rfc2822_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMIT_FMT_FULLER
case|:
name|ret
operator|+=
name|sprintf
argument_list|(
name|buf
operator|+
name|ret
argument_list|,
literal|"%sDate: %s\n"
argument_list|,
name|what
argument_list|,
name|show_date
argument_list|(
name|time
argument_list|,
name|tz
argument_list|,
name|relative_date
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* notin' */
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|is_empty_line
specifier|static
name|int
name|is_empty_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|len_p
parameter_list|)
block|{
name|int
name|len
init|=
operator|*
name|len_p
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
operator|*
name|len_p
operator|=
name|len
expr_stmt|;
return|return
operator|!
name|len
return|;
block|}
end_function
begin_function
DECL|function|add_merge_info
specifier|static
name|int
name|add_merge_info
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|int
name|abbrev
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
init|=
name|commit
operator|->
name|parents
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|)
operator|||
operator|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|)
operator|||
operator|!
name|parent
operator|||
operator|!
name|parent
operator|->
name|next
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Merge:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parent
operator|->
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|dots
decl_stmt|;
if|if
condition|(
name|abbrev
condition|)
name|hex
operator|=
name|find_unique_abbrev
argument_list|(
name|p
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hex
condition|)
name|hex
operator|=
name|sha1_to_hex
argument_list|(
name|p
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|dots
operator|=
operator|(
name|abbrev
operator|&&
name|strlen
argument_list|(
name|hex
argument_list|)
operator|!=
literal|40
operator|)
condition|?
literal|"..."
else|:
literal|""
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|next
expr_stmt|;
name|offset
operator|+=
name|sprintf
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|" %s%s"
argument_list|,
name|hex
argument_list|,
name|dots
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|offset
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_function
DECL|function|get_header
specifier|static
name|char
modifier|*
name|get_header
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|int
name|key_len
init|=
name|strlen
argument_list|(
name|key
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
init|=
name|commit
operator|->
name|buffer
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|eol
init|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|line
operator|==
name|eol
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|eol
condition|)
block|{
name|eol
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|next
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
operator|&&
name|line
index|[
name|key_len
index|]
operator|==
literal|' '
condition|)
block|{
name|int
name|len
init|=
name|eol
operator|-
name|line
operator|-
name|key_len
decl_stmt|;
name|char
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|line
operator|+
name|key_len
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ret
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
name|line
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|replace_encoding_header
specifier|static
name|char
modifier|*
name|replace_encoding_header
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|char
modifier|*
name|encoding_header
init|=
name|strstr
argument_list|(
name|buf
argument_list|,
literal|"\nencoding "
argument_list|)
decl_stmt|;
name|char
modifier|*
name|end_of_encoding_header
decl_stmt|;
name|int
name|encoding_header_pos
decl_stmt|;
name|int
name|encoding_header_len
decl_stmt|;
name|int
name|new_len
decl_stmt|;
name|int
name|need_len
decl_stmt|;
name|int
name|buflen
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|encoding_header
condition|)
return|return
name|buf
return|;
comment|/* should not happen but be defensive */
name|encoding_header
operator|++
expr_stmt|;
name|end_of_encoding_header
operator|=
name|strchr
argument_list|(
name|encoding_header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end_of_encoding_header
condition|)
return|return
name|buf
return|;
comment|/* should not happen but be defensive */
name|end_of_encoding_header
operator|++
expr_stmt|;
name|encoding_header_len
operator|=
name|end_of_encoding_header
operator|-
name|encoding_header
expr_stmt|;
name|encoding_header_pos
operator|=
name|encoding_header
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|is_encoding_utf8
argument_list|(
name|encoding
argument_list|)
condition|)
block|{
comment|/* we have re-coded to UTF-8; drop the header */
name|memmove
argument_list|(
name|encoding_header
argument_list|,
name|end_of_encoding_header
argument_list|,
name|buflen
operator|-
operator|(
name|encoding_header_pos
operator|+
name|encoding_header_len
operator|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|new_len
operator|=
name|strlen
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
name|need_len
operator|=
name|new_len
operator|+
name|strlen
argument_list|(
literal|"encoding \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding_header_len
operator|<
name|need_len
condition|)
block|{
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|buflen
operator|+
operator|(
name|need_len
operator|-
name|encoding_header_len
operator|)
argument_list|)
expr_stmt|;
name|encoding_header
operator|=
name|buf
operator|+
name|encoding_header_pos
expr_stmt|;
name|end_of_encoding_header
operator|=
name|encoding_header
operator|+
name|encoding_header_len
expr_stmt|;
block|}
name|memmove
argument_list|(
name|end_of_encoding_header
operator|+
operator|(
name|need_len
operator|-
name|encoding_header_len
operator|)
argument_list|,
name|end_of_encoding_header
argument_list|,
name|buflen
operator|-
operator|(
name|encoding_header_pos
operator|+
name|encoding_header_len
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|encoding_header
operator|+
literal|9
argument_list|,
name|encoding
argument_list|,
name|strlen
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
name|encoding_header
index|[
literal|9
operator|+
name|new_len
index|]
operator|=
literal|'\n'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function
begin_function
DECL|function|logmsg_reencode
specifier|static
name|char
modifier|*
name|logmsg_reencode
parameter_list|(
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|char
modifier|*
name|output_encoding
parameter_list|)
block|{
name|char
modifier|*
name|encoding
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|utf8
init|=
literal|"utf-8"
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|output_encoding
condition|)
return|return
name|NULL
return|;
name|encoding
operator|=
name|get_header
argument_list|(
name|commit
argument_list|,
literal|"encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
condition|)
name|encoding
operator|=
name|utf8
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|encoding
argument_list|,
name|output_encoding
argument_list|)
condition|)
name|out
operator|=
name|strdup
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
else|else
name|out
operator|=
name|reencode_string
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
name|output_encoding
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|out
operator|=
name|replace_encoding_header
argument_list|(
name|out
argument_list|,
name|output_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|!=
name|utf8
condition|)
name|free
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
return|return
name|NULL
return|;
return|return
name|out
return|;
block|}
end_function
begin_function
DECL|function|pretty_print_commit
name|unsigned
name|long
name|pretty_print_commit
parameter_list|(
name|enum
name|cmit_fmt
name|fmt
parameter_list|,
specifier|const
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|space
parameter_list|,
name|int
name|abbrev
parameter_list|,
specifier|const
name|char
modifier|*
name|subject
parameter_list|,
specifier|const
name|char
modifier|*
name|after_subject
parameter_list|,
name|int
name|relative_date
parameter_list|)
block|{
name|int
name|hdr
init|=
literal|1
decl_stmt|,
name|body
init|=
literal|0
decl_stmt|,
name|seen_title
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|indent
init|=
literal|4
decl_stmt|;
name|int
name|parents_shown
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|commit
operator|->
name|buffer
decl_stmt|;
name|int
name|plain_non_ascii
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|reencoded
decl_stmt|;
name|char
modifier|*
name|encoding
decl_stmt|;
name|encoding
operator|=
operator|(
name|git_log_output_encoding
condition|?
name|git_log_output_encoding
else|:
name|git_commit_encoding
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding
condition|)
name|encoding
operator|=
literal|"utf-8"
expr_stmt|;
name|reencoded
operator|=
name|logmsg_reencode
argument_list|(
name|commit
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|reencoded
condition|)
name|msg
operator|=
name|reencoded
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
operator|||
name|fmt
operator|==
name|CMIT_FMT_EMAIL
condition|)
name|indent
operator|=
literal|0
expr_stmt|;
comment|/* After-subject is used to pass in Content-Type: multipart 	 * MIME header; in that case we do not have to do the 	 * plaintext content type even if the commit message has 	 * non 7-bit ASCII character.  Otherwise, check if we need 	 * to say this is not a 7-bit ASCII. 	 */
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
operator|!
name|after_subject
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|,
name|in_body
decl_stmt|;
for|for
control|(
name|in_body
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|msg
index|[
name|i
index|]
operator|)
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|in_body
condition|)
block|{
comment|/* author could be non 7-bit ASCII but 				 * the log may be so; skip over the 				 * header part first. 				 */
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|&&
name|i
operator|+
literal|1
operator|<
name|len
operator|&&
name|msg
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|in_body
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|non_ascii
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|plain_non_ascii
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
name|msg
decl_stmt|;
name|int
name|linelen
init|=
name|get_one_line
argument_list|(
name|msg
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|linelen
condition|)
break|break;
comment|/* 		 * We want some slop for indentation and a possible 		 * final "...". Thus the "+ 20". 		 */
if|if
condition|(
name|offset
operator|+
name|linelen
operator|+
literal|20
operator|>
name|space
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|"    ...\n"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
name|msg
operator|+=
name|linelen
expr_stmt|;
name|len
operator|-=
name|linelen
expr_stmt|;
if|if
condition|(
name|hdr
condition|)
block|{
if|if
condition|(
name|linelen
operator|==
literal|1
condition|)
block|{
name|hdr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
operator|)
operator|&&
operator|!
name|subject
condition|)
name|buf
index|[
name|offset
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_RAW
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|linelen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
name|linelen
operator|!=
literal|48
condition|)
name|die
argument_list|(
literal|"bad parent line in commit"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|parents_shown
condition|)
block|{
name|offset
operator|+=
name|add_merge_info
argument_list|(
name|fmt
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|commit
argument_list|,
name|abbrev
argument_list|)
expr_stmt|;
name|parents_shown
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * MEDIUM == DEFAULT shows only author with dates. 			 * FULL shows both authors but not dates. 			 * FULLER shows both authors and dates. 			 */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"author "
argument_list|,
literal|7
argument_list|)
condition|)
name|offset
operator|+=
name|add_user_info
argument_list|(
literal|"Author"
argument_list|,
name|fmt
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|line
operator|+
literal|7
argument_list|,
name|relative_date
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|line
argument_list|,
literal|"committer "
argument_list|,
literal|10
argument_list|)
operator|&&
operator|(
name|fmt
operator|==
name|CMIT_FMT_FULL
operator|||
name|fmt
operator|==
name|CMIT_FMT_FULLER
operator|)
condition|)
name|offset
operator|+=
name|add_user_info
argument_list|(
literal|"Commit"
argument_list|,
name|fmt
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|line
operator|+
literal|10
argument_list|,
name|relative_date
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|subject
condition|)
name|body
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_empty_line
argument_list|(
name|line
argument_list|,
operator|&
name|linelen
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|seen_title
condition|)
continue|continue;
if|if
condition|(
operator|!
name|body
condition|)
continue|continue;
if|if
condition|(
name|subject
condition|)
continue|continue;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_SHORT
condition|)
break|break;
block|}
name|seen_title
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|subject
condition|)
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|subject
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|subject
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|slen
expr_stmt|;
name|offset
operator|+=
name|add_rfc2047
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
operator|+
name|indent
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|linelen
operator|+
name|indent
expr_stmt|;
block|}
name|buf
index|[
name|offset
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_ONELINE
condition|)
break|break;
if|if
condition|(
name|subject
operator|&&
name|plain_non_ascii
condition|)
block|{
name|int
name|sz
decl_stmt|;
name|char
name|header
index|[
literal|512
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|header_fmt
init|=
literal|"Content-Type: text/plain; charset=%s\n"
literal|"Content-Transfer-Encoding: 8bit\n"
decl_stmt|;
name|sz
operator|=
name|snprintf
argument_list|(
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|,
name|header_fmt
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|header
argument_list|)
operator|<
name|sz
condition|)
name|die
argument_list|(
literal|"Encoding name %s too long"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|header
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|sz
expr_stmt|;
block|}
if|if
condition|(
name|after_subject
condition|)
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|after_subject
argument_list|)
decl_stmt|;
if|if
condition|(
name|slen
operator|>
name|space
operator|-
name|offset
operator|-
literal|1
condition|)
name|slen
operator|=
name|space
operator|-
name|offset
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|after_subject
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|slen
expr_stmt|;
name|after_subject
operator|=
name|NULL
expr_stmt|;
block|}
name|subject
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|offset
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|offset
operator|--
expr_stmt|;
comment|/* Make sure there is an EOLN for the non-oneline case */
if|if
condition|(
name|fmt
operator|!=
name|CMIT_FMT_ONELINE
condition|)
name|buf
index|[
name|offset
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* 	 * make sure there is another EOLN to separate the headers from whatever 	 * body the caller appends if we haven't already written a body 	 */
if|if
condition|(
name|fmt
operator|==
name|CMIT_FMT_EMAIL
operator|&&
operator|!
name|body
condition|)
name|buf
index|[
name|offset
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|offset
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|reencoded
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function
begin_function
DECL|function|pop_commit
name|struct
name|commit
modifier|*
name|pop_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|top
init|=
operator|*
name|stack
decl_stmt|;
name|struct
name|commit
modifier|*
name|item
init|=
name|top
condition|?
name|top
operator|->
name|item
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|top
condition|)
block|{
operator|*
name|stack
operator|=
name|top
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
return|return
name|item
return|;
block|}
end_function
begin_function
DECL|function|count_parents
name|int
name|count_parents
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|commit
operator|->
name|parents
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
operator|,
name|count
operator|++
control|)
empty_stmt|;
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|topo_sort_default_setter
name|void
name|topo_sort_default_setter
parameter_list|(
name|struct
name|commit
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|c
operator|->
name|util
operator|=
name|data
expr_stmt|;
block|}
end_function
begin_function
DECL|function|topo_sort_default_getter
name|void
modifier|*
name|topo_sort_default_getter
parameter_list|(
name|struct
name|commit
modifier|*
name|c
parameter_list|)
block|{
return|return
name|c
operator|->
name|util
return|;
block|}
end_function
begin_comment
comment|/*  * Performs an in-place topological sort on the list supplied.  */
end_comment
begin_function
DECL|function|sort_in_topological_order
name|void
name|sort_in_topological_order
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|lifo
parameter_list|)
block|{
name|sort_in_topological_order_fn
argument_list|(
name|list
argument_list|,
name|lifo
argument_list|,
name|topo_sort_default_setter
argument_list|,
name|topo_sort_default_getter
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sort_in_topological_order_fn
name|void
name|sort_in_topological_order_fn
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|lifo
parameter_list|,
name|topo_sort_set_fn_t
name|setter
parameter_list|,
name|topo_sort_get_fn_t
name|getter
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
operator|*
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|work
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|insert
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
init|=
name|list
decl_stmt|;
name|struct
name|sort_node
modifier|*
name|nodes
decl_stmt|;
name|struct
name|sort_node
modifier|*
name|next_nodes
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* determine the size of the list */
while|while
condition|(
name|next
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return;
comment|/* allocate an array to help sort the list */
name|nodes
operator|=
name|xcalloc
argument_list|(
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nodes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* link the list to the array */
name|next_nodes
operator|=
name|nodes
expr_stmt|;
name|next
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|next_nodes
operator|->
name|list_item
operator|=
name|next
expr_stmt|;
name|setter
argument_list|(
name|next
operator|->
name|item
argument_list|,
name|next_nodes
argument_list|)
expr_stmt|;
name|next_nodes
operator|++
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
comment|/* update the indegree */
name|next
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|next
operator|->
name|item
operator|->
name|parents
decl_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|struct
name|sort_node
modifier|*
name|pn
init|=
operator|(
expr|struct
name|sort_node
operator|*
operator|)
name|getter
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn
condition|)
name|pn
operator|->
name|indegree
operator|++
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
comment|/*           * find the tips          *          * tips are nodes not reachable from any other node in the list           *           * the tips serve as a starting set for the work queue.          */
name|next
operator|=
operator|*
name|list
expr_stmt|;
name|insert
operator|=
operator|&
name|work
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|sort_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|sort_node
operator|*
operator|)
name|getter
argument_list|(
name|next
operator|->
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|indegree
operator|==
literal|0
condition|)
block|{
name|insert
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|next
operator|->
name|item
argument_list|,
name|insert
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
comment|/* process the list in topological order */
if|if
condition|(
operator|!
name|lifo
condition|)
name|sort_by_date
argument_list|(
operator|&
name|work
argument_list|)
expr_stmt|;
while|while
condition|(
name|work
condition|)
block|{
name|struct
name|commit
modifier|*
name|work_item
init|=
name|pop_commit
argument_list|(
operator|&
name|work
argument_list|)
decl_stmt|;
name|struct
name|sort_node
modifier|*
name|work_node
init|=
operator|(
expr|struct
name|sort_node
operator|*
operator|)
name|getter
argument_list|(
name|work_item
argument_list|)
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|work_item
operator|->
name|parents
decl_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|struct
name|sort_node
modifier|*
name|pn
init|=
operator|(
expr|struct
name|sort_node
operator|*
operator|)
name|getter
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn
condition|)
block|{
comment|/* 				 * parents are only enqueued for emission                                   * when all their children have been emitted thereby                                  * guaranteeing topological order.                                  */
name|pn
operator|->
name|indegree
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|pn
operator|->
name|indegree
condition|)
block|{
if|if
condition|(
operator|!
name|lifo
condition|)
name|insert_by_date
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
else|else
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
comment|/*                  * work_item is a commit all of whose children                  * have already been emitted. we can emit it now.                  */
operator|*
name|pptr
operator|=
name|work_node
operator|->
name|list_item
expr_stmt|;
name|pptr
operator|=
operator|&
operator|(
operator|*
name|pptr
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pptr
operator|=
name|NULL
expr_stmt|;
name|setter
argument_list|(
name|work_item
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* merge-base stuff */
end_comment
begin_comment
comment|/* bits #0..15 in revision.h */
end_comment
begin_define
DECL|macro|PARENT1
define|#
directive|define
name|PARENT1
value|(1u<<16)
end_define
begin_define
DECL|macro|PARENT2
define|#
directive|define
name|PARENT2
value|(1u<<17)
end_define
begin_define
DECL|macro|STALE
define|#
directive|define
name|STALE
value|(1u<<18)
end_define
begin_define
DECL|macro|RESULT
define|#
directive|define
name|RESULT
value|(1u<<19)
end_define
begin_decl_stmt
DECL|variable|all_flags
specifier|static
specifier|const
name|unsigned
name|all_flags
init|=
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator||
name|RESULT
operator|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|interesting
specifier|static
name|struct
name|commit
modifier|*
name|interesting
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|list
operator|->
name|item
decl_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
condition|)
continue|continue;
return|return
name|commit
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|merge_bases
specifier|static
name|struct
name|commit_list
modifier|*
name|merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|struct
name|commit
modifier|*
name|two
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|one
operator|==
name|two
condition|)
comment|/* We do not mark this even with RESULT so we do not 		 * have to clean it up. 		 */
return|return
name|commit_list_insert
argument_list|(
name|one
argument_list|,
operator|&
name|result
argument_list|)
return|;
name|parse_commit
argument_list|(
name|one
argument_list|)
expr_stmt|;
name|parse_commit
argument_list|(
name|two
argument_list|)
expr_stmt|;
name|one
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT1
expr_stmt|;
name|two
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT2
expr_stmt|;
name|insert_by_date
argument_list|(
name|one
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|insert_by_date
argument_list|(
name|two
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|interesting
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|n
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|commit
operator|=
name|list
operator|->
name|item
expr_stmt|;
name|n
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|n
expr_stmt|;
name|flags
operator|=
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|(
name|PARENT1
operator||
name|PARENT2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|RESULT
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|RESULT
expr_stmt|;
name|insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Mark parents of a found merge stale */
name|flags
operator||=
name|STALE
expr_stmt|;
block|}
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|object
operator|.
name|flags
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
continue|continue;
name|parse_commit
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|object
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
name|insert_by_date
argument_list|(
name|p
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up the result to remove stale ones */
name|free_commit_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|n
init|=
name|list
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
operator|)
condition|)
name|insert_by_date
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|n
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_merge_bases
name|struct
name|commit_list
modifier|*
name|get_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|struct
name|commit
modifier|*
name|two
parameter_list|,
name|int
name|cleanup
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|rslt
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|result
operator|=
name|merge_bases
argument_list|(
name|one
argument_list|,
name|two
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|==
name|two
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
name|result
operator|||
operator|!
name|result
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|cleanup
condition|)
block|{
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|two
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* There are more than one */
name|cnt
operator|=
literal|0
expr_stmt|;
name|list
operator|=
name|result
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|rslt
operator|=
name|xcalloc
argument_list|(
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|result
operator|,
name|i
operator|=
literal|0
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|rslt
index|[
name|i
operator|++
index|]
operator|=
name|list
operator|->
name|item
expr_stmt|;
name|free_commit_list
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|two
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rslt
index|[
name|i
index|]
operator|||
operator|!
name|rslt
index|[
name|j
index|]
condition|)
continue|continue;
name|result
operator|=
name|merge_bases
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
name|rslt
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|rslt
index|[
name|j
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|result
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rslt
index|[
name|i
index|]
operator|==
name|list
operator|->
name|item
condition|)
name|rslt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rslt
index|[
name|j
index|]
operator|==
name|list
operator|->
name|item
condition|)
name|rslt
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* Surviving ones in rslt[] are the independent results */
name|result
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rslt
index|[
name|i
index|]
condition|)
name|insert_by_date
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rslt
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|in_merge_bases
name|int
name|in_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|rev1
parameter_list|,
name|struct
name|commit
modifier|*
name|rev2
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|bases
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bases
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|rev1
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|b
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|free_commit_list
argument_list|(
name|bases
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
end_unit
