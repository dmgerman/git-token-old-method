begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_decl_stmt
DECL|variable|save_commit_buffer
name|int
name|save_commit_buffer
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_type
specifier|const
name|char
modifier|*
name|commit_type
init|=
literal|"commit"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|check_commit
specifier|static
name|struct
name|commit
modifier|*
name|check_commit
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|"Object %s is a %s, not a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|obj
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference_gently
name|struct
name|commit
modifier|*
name|lookup_commit_reference_gently
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
return|return
name|check_commit
argument_list|(
name|obj
argument_list|,
name|sha1
argument_list|,
name|quiet
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference
name|struct
name|commit
modifier|*
name|lookup_commit_reference
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit
name|struct
name|commit
modifier|*
name|lookup_commit
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|lookup_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|create_object
argument_list|(
name|sha1
argument_list|,
name|OBJ_COMMIT
argument_list|,
name|alloc_commit_node
argument_list|()
argument_list|)
return|;
if|if
condition|(
operator|!
name|obj
operator|->
name|type
condition|)
name|obj
operator|->
name|type
operator|=
name|OBJ_COMMIT
expr_stmt|;
return|return
name|check_commit
argument_list|(
name|obj
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_date
specifier|static
name|unsigned
name|long
name|parse_commit_date
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|tail
parameter_list|)
block|{
name|unsigned
name|long
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|dateptr
decl_stmt|;
if|if
condition|(
name|buf
operator|+
literal|6
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"author"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|+
literal|9
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"committer"
argument_list|,
literal|9
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'>'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
name|dateptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
comment|/* dateptr< buf&& buf[-1] == '\n', so strtoul will stop at buf-1 */
name|date
operator|=
name|strtoul
argument_list|(
name|dateptr
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|==
name|ULONG_MAX
condition|)
name|date
operator|=
literal|0
expr_stmt|;
return|return
name|date
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|commit_graft
specifier|static
name|struct
name|commit_graft
modifier|*
modifier|*
name|commit_graft
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_graft_alloc
DECL|variable|commit_graft_nr
specifier|static
name|int
name|commit_graft_alloc
decl_stmt|,
name|commit_graft_nr
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|commit_graft_pos
specifier|static
name|int
name|commit_graft_pos
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|commit_graft_nr
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|int
name|mi
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|commit_graft
index|[
name|mi
index|]
decl_stmt|;
name|int
name|cmp
init|=
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|mi
return|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|hi
operator|=
name|mi
expr_stmt|;
else|else
name|lo
operator|=
name|mi
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|-
name|lo
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|register_commit_graft
name|int
name|register_commit_graft
parameter_list|(
name|struct
name|commit_graft
modifier|*
name|graft
parameter_list|,
name|int
name|ignore_dups
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pos
condition|)
block|{
if|if
condition|(
name|ignore_dups
condition|)
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|commit_graft
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|commit_graft_alloc
operator|<=
operator|++
name|commit_graft_nr
condition|)
block|{
name|commit_graft_alloc
operator|=
name|alloc_nr
argument_list|(
name|commit_graft_alloc
argument_list|)
expr_stmt|;
name|commit_graft
operator|=
name|xrealloc
argument_list|(
name|commit_graft
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit_graft
argument_list|)
operator|*
name|commit_graft_alloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
name|commit_graft_nr
condition|)
name|memmove
argument_list|(
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
name|commit_graft
operator|+
name|pos
argument_list|,
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|commit_graft
argument_list|)
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_graft_line
name|struct
name|commit_graft
modifier|*
name|read_graft_line
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|i
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|%
literal|41
condition|)
block|{
name|bad_graft_data
label|:
name|error
argument_list|(
literal|"bad graft data: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|41
operator|-
literal|1
expr_stmt|;
name|graft
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|graft
argument_list|)
operator|+
literal|20
operator|*
name|i
argument_list|)
expr_stmt|;
name|graft
operator|->
name|nr_parent
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
argument_list|,
name|graft
operator|->
name|sha1
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
for|for
control|(
name|i
operator|=
literal|40
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|41
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
goto|goto
name|bad_graft_data
goto|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
operator|+
name|i
operator|+
literal|1
argument_list|,
name|graft
operator|->
name|parent
index|[
name|i
operator|/
literal|41
index|]
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
block|}
return|return
name|graft
return|;
block|}
end_function
begin_function
DECL|function|read_graft_file
name|int
name|read_graft_file
parameter_list|(
specifier|const
name|char
modifier|*
name|graft_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|graft_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|read_graft_line
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|graft
condition|)
continue|continue;
if|if
condition|(
name|register_commit_graft
argument_list|(
name|graft
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate graft data: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|prepare_commit_graft
specifier|static
name|void
name|prepare_commit_graft
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|commit_graft_prepared
decl_stmt|;
name|char
modifier|*
name|graft_file
decl_stmt|;
if|if
condition|(
name|commit_graft_prepared
condition|)
return|return;
name|graft_file
operator|=
name|get_graft_file
argument_list|()
expr_stmt|;
name|read_graft_file
argument_list|(
name|graft_file
argument_list|)
expr_stmt|;
comment|/* make sure shallows are read */
name|is_repository_shallow
argument_list|()
expr_stmt|;
name|commit_graft_prepared
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lookup_commit_graft
name|struct
name|commit_graft
modifier|*
name|lookup_commit_graft
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|prepare_commit_graft
argument_list|()
expr_stmt|;
name|pos
operator|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|commit_graft
index|[
name|pos
index|]
return|;
block|}
end_function
begin_function
DECL|function|write_shallow_commits
name|int
name|write_shallow_commits
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|use_pack_protocol
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_graft_nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|commit_graft
index|[
name|i
index|]
operator|->
name|nr_parent
operator|<
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|hex
init|=
name|sha1_to_hex
argument_list|(
name|commit_graft
index|[
name|i
index|]
operator|->
name|sha1
argument_list|)
decl_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|use_pack_protocol
condition|)
name|packet_write
argument_list|(
name|fd
argument_list|,
literal|"shallow %s"
argument_list|,
name|hex
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|hex
argument_list|,
literal|40
argument_list|)
operator|!=
literal|40
condition|)
break|break;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|unregister_shallow
name|int
name|unregister_shallow
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|commit_graft_nr
condition|)
name|memcpy
argument_list|(
name|commit_graft
operator|+
name|pos
argument_list|,
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commit_graft
operator|*
argument_list|)
operator|*
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|commit_graft_nr
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_buffer
name|int
name|parse_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|char
modifier|*
name|tail
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
name|unsigned
name|char
name|parent
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
decl_stmt|;
name|unsigned
name|n_refs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|item
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|tail
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|46
operator|||
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"tree "
argument_list|,
literal|5
argument_list|)
operator|||
name|bufptr
index|[
literal|45
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|error
argument_list|(
literal|"bogus commit object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|5
argument_list|,
name|parent
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"bad tree pointer in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|item
operator|->
name|tree
operator|=
name|lookup_tree
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|tree
condition|)
name|n_refs
operator|++
expr_stmt|;
name|bufptr
operator|+=
literal|46
expr_stmt|;
comment|/* "tree " + "hex sha1" + "\n" */
name|pptr
operator|=
operator|&
name|item
operator|->
name|parents
expr_stmt|;
name|graft
operator|=
name|lookup_commit_graft
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
while|while
condition|(
name|bufptr
operator|+
literal|48
operator|<
name|tail
operator|&&
operator|!
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|48
operator|||
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|7
argument_list|,
name|parent
argument_list|)
operator|||
name|bufptr
index|[
literal|47
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|error
argument_list|(
literal|"bad parents in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|bufptr
operator|+=
literal|48
expr_stmt|;
if|if
condition|(
name|graft
condition|)
continue|continue;
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
condition|)
block|{
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
name|n_refs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|graft
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graft
operator|->
name|nr_parent
condition|;
name|i
operator|++
control|)
block|{
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|graft
operator|->
name|parent
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_parent
condition|)
continue|continue;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
name|n_refs
operator|++
expr_stmt|;
block|}
block|}
name|item
operator|->
name|date
operator|=
name|parse_commit_date
argument_list|(
name|bufptr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit
name|int
name|parse_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|error
argument_list|(
literal|"Could not read %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Object %s not a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
block|}
name|ret
operator|=
name|parse_commit_buffer
argument_list|(
name|item
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_commit_buffer
operator|&&
operator|!
name|ret
condition|)
block|{
name|item
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|commit_list_insert
name|struct
name|commit_list
modifier|*
name|commit_list_insert
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|new_list
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_list
argument_list|)
argument_list|)
decl_stmt|;
name|new_list
operator|->
name|item
operator|=
name|item
expr_stmt|;
name|new_list
operator|->
name|next
operator|=
operator|*
name|list_p
expr_stmt|;
operator|*
name|list_p
operator|=
name|new_list
expr_stmt|;
return|return
name|new_list
return|;
block|}
end_function
begin_function
DECL|function|free_commit_list
name|void
name|free_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|temp
init|=
name|list
decl_stmt|;
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|insert_by_date
name|struct
name|commit_list
modifier|*
name|insert_by_date
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
modifier|*
name|pp
init|=
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|item
operator|->
name|date
operator|<
name|item
operator|->
name|date
condition|)
block|{
break|break;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|commit_list_insert
argument_list|(
name|item
argument_list|,
name|pp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sort_by_date
name|void
name|sort_by_date
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|list
condition|)
block|{
name|insert_by_date
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|item
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|ret
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pop_most_recent_commit
name|struct
name|commit
modifier|*
name|pop_most_recent_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|ret
init|=
operator|(
operator|*
name|list
operator|)
operator|->
name|item
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|ret
operator|->
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|old
init|=
operator|*
name|list
decl_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|parse_commit
argument_list|(
name|commit
argument_list|)
operator|&&
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|mark
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|mark
expr_stmt|;
name|insert_by_date
argument_list|(
name|commit
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|clear_commit_marks
name|void
name|clear_commit_marks
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
while|while
condition|(
name|commit
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mark
operator|&
name|commit
operator|->
name|object
operator|.
name|flags
operator|)
condition|)
return|return;
name|commit
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|mark
expr_stmt|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
if|if
condition|(
operator|!
name|parents
condition|)
return|return;
while|while
condition|(
operator|(
name|parents
operator|=
name|parents
operator|->
name|next
operator|)
condition|)
name|clear_commit_marks
argument_list|(
name|parents
operator|->
name|item
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|commit
operator|=
name|commit
operator|->
name|parents
operator|->
name|item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pop_commit
name|struct
name|commit
modifier|*
name|pop_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|top
init|=
operator|*
name|stack
decl_stmt|;
name|struct
name|commit
modifier|*
name|item
init|=
name|top
condition|?
name|top
operator|->
name|item
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|top
condition|)
block|{
operator|*
name|stack
operator|=
name|top
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*  * Performs an in-place topological sort on the list supplied.  */
end_comment
begin_function
DECL|function|sort_in_topological_order
name|void
name|sort_in_topological_order
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|lifo
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|,
modifier|*
name|orig
init|=
operator|*
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|work
decl_stmt|,
modifier|*
modifier|*
name|insert
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
decl_stmt|;
if|if
condition|(
operator|!
name|orig
condition|)
return|return;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
comment|/* Mark them and clear the indegree */
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|next
operator|->
name|item
decl_stmt|;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|TOPOSORT
expr_stmt|;
name|commit
operator|->
name|indegree
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update the indegree */
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|next
operator|->
name|item
operator|->
name|parents
decl_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|TOPOSORT
condition|)
name|parent
operator|->
name|indegree
operator|++
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* 	 * find the tips 	 * 	 * tips are nodes not reachable from any other node in the list 	 * 	 * the tips serve as a starting set for the work queue. 	 */
name|work
operator|=
name|NULL
expr_stmt|;
name|insert
operator|=
operator|&
name|work
expr_stmt|;
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|next
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|commit
operator|->
name|indegree
condition|)
name|insert
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
name|insert
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
comment|/* process the list in topological order */
if|if
condition|(
operator|!
name|lifo
condition|)
name|sort_by_date
argument_list|(
operator|&
name|work
argument_list|)
expr_stmt|;
name|pptr
operator|=
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|work
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|,
modifier|*
name|work_item
decl_stmt|;
name|work_item
operator|=
name|work
expr_stmt|;
name|work
operator|=
name|work_item
operator|->
name|next
expr_stmt|;
name|work_item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|commit
operator|=
name|work_item
operator|->
name|item
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|parent
operator|->
name|object
operator|.
name|flags
operator|&
name|TOPOSORT
operator|)
condition|)
continue|continue;
comment|/* 			 * parents are only enqueued for emission 			 * when all their children have been emitted thereby 			 * guaranteeing topological order. 			 */
if|if
condition|(
operator|!
operator|--
name|parent
operator|->
name|indegree
condition|)
block|{
if|if
condition|(
operator|!
name|lifo
condition|)
name|insert_by_date
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
else|else
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * work_item is a commit all of whose children 		 * have already been emitted. we can emit it now. 		 */
name|commit
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|TOPOSORT
expr_stmt|;
operator|*
name|pptr
operator|=
name|work_item
expr_stmt|;
name|pptr
operator|=
operator|&
name|work_item
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* merge-base stuff */
end_comment
begin_comment
comment|/* bits #0..15 in revision.h */
end_comment
begin_define
DECL|macro|PARENT1
define|#
directive|define
name|PARENT1
value|(1u<<16)
end_define
begin_define
DECL|macro|PARENT2
define|#
directive|define
name|PARENT2
value|(1u<<17)
end_define
begin_define
DECL|macro|STALE
define|#
directive|define
name|STALE
value|(1u<<18)
end_define
begin_define
DECL|macro|RESULT
define|#
directive|define
name|RESULT
value|(1u<<19)
end_define
begin_decl_stmt
DECL|variable|all_flags
specifier|static
specifier|const
name|unsigned
name|all_flags
init|=
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator||
name|RESULT
operator|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|interesting
specifier|static
name|struct
name|commit
modifier|*
name|interesting
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|list
operator|->
name|item
decl_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
condition|)
continue|continue;
return|return
name|commit
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|merge_bases
specifier|static
name|struct
name|commit_list
modifier|*
name|merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|struct
name|commit
modifier|*
name|two
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|one
operator|==
name|two
condition|)
comment|/* We do not mark this even with RESULT so we do not 		 * have to clean it up. 		 */
return|return
name|commit_list_insert
argument_list|(
name|one
argument_list|,
operator|&
name|result
argument_list|)
return|;
if|if
condition|(
name|parse_commit
argument_list|(
name|one
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|parse_commit
argument_list|(
name|two
argument_list|)
condition|)
return|return
name|NULL
return|;
name|one
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT1
expr_stmt|;
name|two
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT2
expr_stmt|;
name|insert_by_date
argument_list|(
name|one
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|insert_by_date
argument_list|(
name|two
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|interesting
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|n
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|commit
operator|=
name|list
operator|->
name|item
expr_stmt|;
name|n
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|n
expr_stmt|;
name|flags
operator|=
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|(
name|PARENT1
operator||
name|PARENT2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|RESULT
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|RESULT
expr_stmt|;
name|insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Mark parents of a found merge stale */
name|flags
operator||=
name|STALE
expr_stmt|;
block|}
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|object
operator|.
name|flags
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
continue|continue;
if|if
condition|(
name|parse_commit
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|object
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
name|insert_by_date
argument_list|(
name|p
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up the result to remove stale ones */
name|free_commit_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|n
init|=
name|list
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
operator|)
condition|)
name|insert_by_date
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|n
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_merge_bases
name|struct
name|commit_list
modifier|*
name|get_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|struct
name|commit
modifier|*
name|two
parameter_list|,
name|int
name|cleanup
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|rslt
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|result
operator|=
name|merge_bases
argument_list|(
name|one
argument_list|,
name|two
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|==
name|two
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|!
name|result
operator|||
operator|!
name|result
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|cleanup
condition|)
block|{
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|two
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* There are more than one */
name|cnt
operator|=
literal|0
expr_stmt|;
name|list
operator|=
name|result
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|rslt
operator|=
name|xcalloc
argument_list|(
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|result
operator|,
name|i
operator|=
literal|0
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|rslt
index|[
name|i
operator|++
index|]
operator|=
name|list
operator|->
name|item
expr_stmt|;
name|free_commit_list
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|two
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rslt
index|[
name|i
index|]
operator|||
operator|!
name|rslt
index|[
name|j
index|]
condition|)
continue|continue;
name|result
operator|=
name|merge_bases
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
name|rslt
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|rslt
index|[
name|j
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|result
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rslt
index|[
name|i
index|]
operator|==
name|list
operator|->
name|item
condition|)
name|rslt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rslt
index|[
name|j
index|]
operator|==
name|list
operator|->
name|item
condition|)
name|rslt
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* Surviving ones in rslt[] are the independent results */
name|result
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rslt
index|[
name|i
index|]
condition|)
name|insert_by_date
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rslt
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|in_merge_bases
name|int
name|in_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|reference
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|bases
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|commit
argument_list|,
operator|*
name|reference
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"not yet"
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bases
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|b
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|free_commit_list
argument_list|(
name|bases
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
end_unit
