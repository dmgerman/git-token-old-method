begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"pkt-line.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"notes.h"
end_include
begin_include
include|#
directive|include
file|"gpg-interface.h"
end_include
begin_include
include|#
directive|include
file|"mergesort.h"
end_include
begin_decl_stmt
DECL|variable|save_commit_buffer
name|int
name|save_commit_buffer
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_type
specifier|const
name|char
modifier|*
name|commit_type
init|=
literal|"commit"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|check_commit
specifier|static
name|struct
name|commit
modifier|*
name|check_commit
parameter_list|(
name|struct
name|object
modifier|*
name|obj
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|"Object %s is a %s, not a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|typename
argument_list|(
name|obj
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
expr|struct
name|commit
operator|*
operator|)
name|obj
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference_gently
name|struct
name|commit
modifier|*
name|lookup_commit_reference_gently
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|NULL
return|;
return|return
name|check_commit
argument_list|(
name|obj
argument_list|,
name|sha1
argument_list|,
name|quiet
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference
name|struct
name|commit
modifier|*
name|lookup_commit_reference
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
return|return
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_or_die
name|struct
name|commit
modifier|*
name|lookup_commit_or_die
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
specifier|const
name|char
modifier|*
name|ref_name
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|c
init|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|die
argument_list|(
name|_
argument_list|(
literal|"could not parse %s"
argument_list|)
argument_list|,
name|ref_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|c
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"%s %s is not a commit!"
argument_list|)
argument_list|,
name|ref_name
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit
name|struct
name|commit
modifier|*
name|lookup_commit
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|lookup_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
return|return
name|create_object
argument_list|(
name|sha1
argument_list|,
name|OBJ_COMMIT
argument_list|,
name|alloc_commit_node
argument_list|()
argument_list|)
return|;
if|if
condition|(
operator|!
name|obj
operator|->
name|type
condition|)
name|obj
operator|->
name|type
operator|=
name|OBJ_COMMIT
expr_stmt|;
return|return
name|check_commit
argument_list|(
name|obj
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|lookup_commit_reference_by_name
name|struct
name|commit
modifier|*
name|lookup_commit_reference_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
if|if
condition|(
name|get_sha1_committish
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|commit
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|commit
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_date
specifier|static
name|unsigned
name|long
name|parse_commit_date
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|tail
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dateptr
decl_stmt|;
if|if
condition|(
name|buf
operator|+
literal|6
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"author"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|+
literal|9
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"committer"
argument_list|,
literal|9
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'>'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
name|dateptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|tail
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* nada */
empty_stmt|;
if|if
condition|(
name|buf
operator|>=
name|tail
condition|)
return|return
literal|0
return|;
comment|/* dateptr< buf&& buf[-1] == '\n', so strtoul will stop at buf-1 */
return|return
name|strtoul
argument_list|(
name|dateptr
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|commit_graft
specifier|static
name|struct
name|commit_graft
modifier|*
modifier|*
name|commit_graft
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_graft_alloc
DECL|variable|commit_graft_nr
specifier|static
name|int
name|commit_graft_alloc
decl_stmt|,
name|commit_graft_nr
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|commit_graft_pos
specifier|static
name|int
name|commit_graft_pos
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|commit_graft_nr
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|int
name|mi
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|commit_graft
index|[
name|mi
index|]
decl_stmt|;
name|int
name|cmp
init|=
name|hashcmp
argument_list|(
name|sha1
argument_list|,
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|mi
return|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|hi
operator|=
name|mi
expr_stmt|;
else|else
name|lo
operator|=
name|mi
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|-
name|lo
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|register_commit_graft
name|int
name|register_commit_graft
parameter_list|(
name|struct
name|commit_graft
modifier|*
name|graft
parameter_list|,
name|int
name|ignore_dups
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|graft
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|pos
condition|)
block|{
if|if
condition|(
name|ignore_dups
condition|)
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|commit_graft
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|commit_graft_alloc
operator|<=
operator|++
name|commit_graft_nr
condition|)
block|{
name|commit_graft_alloc
operator|=
name|alloc_nr
argument_list|(
name|commit_graft_alloc
argument_list|)
expr_stmt|;
name|commit_graft
operator|=
name|xrealloc
argument_list|(
name|commit_graft
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|commit_graft
argument_list|)
operator|*
name|commit_graft_alloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
name|commit_graft_nr
condition|)
name|memmove
argument_list|(
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
name|commit_graft
operator|+
name|pos
argument_list|,
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|commit_graft
argument_list|)
argument_list|)
expr_stmt|;
name|commit_graft
index|[
name|pos
index|]
operator|=
name|graft
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_graft_line
name|struct
name|commit_graft
modifier|*
name|read_graft_line
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|i
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|buf
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|%
literal|41
condition|)
goto|goto
name|bad_graft_data
goto|;
name|i
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|41
operator|-
literal|1
expr_stmt|;
name|graft
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|graft
argument_list|)
operator|+
literal|20
operator|*
name|i
argument_list|)
expr_stmt|;
name|graft
operator|->
name|nr_parent
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
argument_list|,
name|graft
operator|->
name|sha1
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
for|for
control|(
name|i
operator|=
literal|40
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|41
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
goto|goto
name|bad_graft_data
goto|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|buf
operator|+
name|i
operator|+
literal|1
argument_list|,
name|graft
operator|->
name|parent
index|[
name|i
operator|/
literal|41
index|]
argument_list|)
condition|)
goto|goto
name|bad_graft_data
goto|;
block|}
return|return
name|graft
return|;
name|bad_graft_data
label|:
name|error
argument_list|(
literal|"bad graft data: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graft
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|read_graft_file
specifier|static
name|int
name|read_graft_file
parameter_list|(
specifier|const
name|char
modifier|*
name|graft_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|graft_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/* The format is just "Commit Parent1 Parent2 ...\n" */
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
init|=
name|read_graft_line
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|graft
condition|)
continue|continue;
if|if
condition|(
name|register_commit_graft
argument_list|(
name|graft
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate graft data: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|prepare_commit_graft
specifier|static
name|void
name|prepare_commit_graft
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|commit_graft_prepared
decl_stmt|;
name|char
modifier|*
name|graft_file
decl_stmt|;
if|if
condition|(
name|commit_graft_prepared
condition|)
return|return;
name|graft_file
operator|=
name|get_graft_file
argument_list|()
expr_stmt|;
name|read_graft_file
argument_list|(
name|graft_file
argument_list|)
expr_stmt|;
comment|/* make sure shallows are read */
name|is_repository_shallow
argument_list|()
expr_stmt|;
name|commit_graft_prepared
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lookup_commit_graft
name|struct
name|commit_graft
modifier|*
name|lookup_commit_graft
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|prepare_commit_graft
argument_list|()
expr_stmt|;
name|pos
operator|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|commit_graft
index|[
name|pos
index|]
return|;
block|}
end_function
begin_function
DECL|function|for_each_commit_graft
name|int
name|for_each_commit_graft
parameter_list|(
name|each_commit_graft_fn
name|fn
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ret
operator|=
literal|0
init|;
name|i
operator|<
name|commit_graft_nr
operator|&&
operator|!
name|ret
condition|;
name|i
operator|++
control|)
name|ret
operator|=
name|fn
argument_list|(
name|commit_graft
index|[
name|i
index|]
argument_list|,
name|cb_data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|unregister_shallow
name|int
name|unregister_shallow
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
init|=
name|commit_graft_pos
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pos
operator|+
literal|1
operator|<
name|commit_graft_nr
condition|)
name|memmove
argument_list|(
name|commit_graft
operator|+
name|pos
argument_list|,
name|commit_graft
operator|+
name|pos
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commit_graft
operator|*
argument_list|)
operator|*
operator|(
name|commit_graft_nr
operator|-
name|pos
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|commit_graft_nr
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit_buffer
name|int
name|parse_commit_buffer
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tail
init|=
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
name|unsigned
name|char
name|parent
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
decl_stmt|;
name|struct
name|commit_graft
modifier|*
name|graft
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|item
operator|->
name|object
operator|.
name|parsed
operator|=
literal|1
expr_stmt|;
name|tail
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|46
operator|||
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"tree "
argument_list|,
literal|5
argument_list|)
operator|||
name|bufptr
index|[
literal|45
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|error
argument_list|(
literal|"bogus commit object %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|5
argument_list|,
name|parent
argument_list|)
operator|<
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"bad tree pointer in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|item
operator|->
name|tree
operator|=
name|lookup_tree
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
literal|46
expr_stmt|;
comment|/* "tree " + "hex sha1" + "\n" */
name|pptr
operator|=
operator|&
name|item
operator|->
name|parents
expr_stmt|;
name|graft
operator|=
name|lookup_commit_graft
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
while|while
condition|(
name|bufptr
operator|+
literal|48
operator|<
name|tail
operator|&&
operator|!
name|memcmp
argument_list|(
name|bufptr
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
if|if
condition|(
name|tail
operator|<=
name|bufptr
operator|+
literal|48
operator|||
name|get_sha1_hex
argument_list|(
name|bufptr
operator|+
literal|7
argument_list|,
name|parent
argument_list|)
operator|||
name|bufptr
index|[
literal|47
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|error
argument_list|(
literal|"bad parents in commit %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
name|bufptr
operator|+=
literal|48
expr_stmt|;
comment|/* 		 * The clone is shallow if nr_parent< 0, and we must 		 * not traverse its real parents even when we unhide them. 		 */
if|if
condition|(
name|graft
operator|&&
operator|(
name|graft
operator|->
name|nr_parent
operator|<
literal|0
operator|||
name|grafts_replace_parents
operator|)
condition|)
continue|continue;
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
condition|)
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|graft
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|commit
modifier|*
name|new_parent
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|graft
operator|->
name|nr_parent
condition|;
name|i
operator|++
control|)
block|{
name|new_parent
operator|=
name|lookup_commit
argument_list|(
name|graft
operator|->
name|parent
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_parent
condition|)
continue|continue;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|new_parent
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
block|}
name|item
operator|->
name|date
operator|=
name|parse_commit_date
argument_list|(
name|bufptr
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_commit
name|int
name|parse_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|item
operator|->
name|object
operator|.
name|parsed
condition|)
return|return
literal|0
return|;
name|buffer
operator|=
name|read_sha1_file
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
return|return
name|error
argument_list|(
literal|"Could not read %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|type
operator|!=
name|OBJ_COMMIT
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|error
argument_list|(
literal|"Object %s not a commit"
argument_list|,
name|sha1_to_hex
argument_list|(
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
return|;
block|}
name|ret
operator|=
name|parse_commit_buffer
argument_list|(
name|item
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_commit_buffer
operator|&&
operator|!
name|ret
condition|)
block|{
name|item
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|find_commit_subject
name|int
name|find_commit_subject
parameter_list|(
specifier|const
name|char
modifier|*
name|commit_buffer
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|subject
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|commit_buffer
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\n'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\n'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|eol
operator|=
name|p
init|;
operator|*
name|eol
operator|&&
operator|*
name|eol
operator|!=
literal|'\n'
condition|;
name|eol
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
block|}
else|else
name|eol
operator|=
name|p
expr_stmt|;
operator|*
name|subject
operator|=
name|p
expr_stmt|;
return|return
name|eol
operator|-
name|p
return|;
block|}
end_function
begin_function
DECL|function|commit_list_insert
name|struct
name|commit_list
modifier|*
name|commit_list_insert
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|new_list
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_list
argument_list|)
argument_list|)
decl_stmt|;
name|new_list
operator|->
name|item
operator|=
name|item
expr_stmt|;
name|new_list
operator|->
name|next
operator|=
operator|*
name|list_p
expr_stmt|;
operator|*
name|list_p
operator|=
name|new_list
expr_stmt|;
return|return
name|new_list
return|;
block|}
end_function
begin_function
DECL|function|commit_list_count
name|unsigned
name|commit_list_count
parameter_list|(
specifier|const
name|struct
name|commit_list
modifier|*
name|l
parameter_list|)
block|{
name|unsigned
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|c
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
end_function
begin_function
DECL|function|free_commit_list
name|void
name|free_commit_list
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|temp
init|=
name|list
decl_stmt|;
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|commit_list_insert_by_date
name|struct
name|commit_list
modifier|*
name|commit_list_insert_by_date
parameter_list|(
name|struct
name|commit
modifier|*
name|item
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
modifier|*
name|pp
init|=
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|item
operator|->
name|date
operator|<
name|item
operator|->
name|date
condition|)
block|{
break|break;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
name|commit_list_insert
argument_list|(
name|item
argument_list|,
name|pp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|commit_list_compare_by_date
specifier|static
name|int
name|commit_list_compare_by_date
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|unsigned
name|long
name|a_date
init|=
operator|(
operator|(
specifier|const
expr|struct
name|commit_list
operator|*
operator|)
name|a
operator|)
operator|->
name|item
operator|->
name|date
decl_stmt|;
name|unsigned
name|long
name|b_date
init|=
operator|(
operator|(
specifier|const
expr|struct
name|commit_list
operator|*
operator|)
name|b
operator|)
operator|->
name|item
operator|->
name|date
decl_stmt|;
if|if
condition|(
name|a_date
operator|<
name|b_date
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a_date
operator|>
name|b_date
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|commit_list_get_next
specifier|static
name|void
modifier|*
name|commit_list_get_next
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|commit_list
operator|*
operator|)
name|a
operator|)
operator|->
name|next
return|;
block|}
end_function
begin_function
DECL|function|commit_list_set_next
specifier|static
name|void
name|commit_list_set_next
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|next
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|commit_list
operator|*
operator|)
name|a
operator|)
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
end_function
begin_function
DECL|function|commit_list_sort_by_date
name|void
name|commit_list_sort_by_date
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|)
block|{
operator|*
name|list
operator|=
name|llist_mergesort
argument_list|(
operator|*
name|list
argument_list|,
name|commit_list_get_next
argument_list|,
name|commit_list_set_next
argument_list|,
name|commit_list_compare_by_date
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pop_most_recent_commit
name|struct
name|commit
modifier|*
name|pop_most_recent_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|ret
init|=
operator|(
operator|*
name|list
operator|)
operator|->
name|item
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|ret
operator|->
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|old
init|=
operator|*
name|list
decl_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|parse_commit
argument_list|(
name|commit
argument_list|)
operator|&&
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|mark
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|mark
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|commit
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|clear_commit_marks_1
specifier|static
name|void
name|clear_commit_marks_1
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|plist
parameter_list|,
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
while|while
condition|(
name|commit
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mark
operator|&
name|commit
operator|->
name|object
operator|.
name|flags
operator|)
condition|)
return|return;
name|commit
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|mark
expr_stmt|;
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
if|if
condition|(
operator|!
name|parents
condition|)
return|return;
while|while
condition|(
operator|(
name|parents
operator|=
name|parents
operator|->
name|next
operator|)
condition|)
name|commit_list_insert
argument_list|(
name|parents
operator|->
name|item
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|commit
operator|=
name|commit
operator|->
name|parents
operator|->
name|item
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|clear_commit_marks
name|void
name|clear_commit_marks
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
name|clear_commit_marks_1
argument_list|(
operator|&
name|list
argument_list|,
name|pop_commit
argument_list|(
operator|&
name|list
argument_list|)
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clear_commit_marks_for_object_array
name|void
name|clear_commit_marks_for_object_array
parameter_list|(
name|struct
name|object_array
modifier|*
name|a
parameter_list|,
name|unsigned
name|mark
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|object
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|object
operator|=
name|a
operator|->
name|objects
index|[
name|i
index|]
operator|.
name|item
expr_stmt|;
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|object
operator|->
name|sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
name|clear_commit_marks
argument_list|(
name|commit
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pop_commit
name|struct
name|commit
modifier|*
name|pop_commit
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|top
init|=
operator|*
name|stack
decl_stmt|;
name|struct
name|commit
modifier|*
name|item
init|=
name|top
condition|?
name|top
operator|->
name|item
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|top
condition|)
block|{
operator|*
name|stack
operator|=
name|top
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
return|return
name|item
return|;
block|}
end_function
begin_comment
comment|/*  * Performs an in-place topological sort on the list supplied.  */
end_comment
begin_function
DECL|function|sort_in_topological_order
name|void
name|sort_in_topological_order
parameter_list|(
name|struct
name|commit_list
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|lifo
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|,
modifier|*
name|orig
init|=
operator|*
name|list
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|work
decl_stmt|,
modifier|*
modifier|*
name|insert
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
decl_stmt|;
if|if
condition|(
operator|!
name|orig
condition|)
return|return;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
comment|/* Mark them and clear the indegree */
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|next
operator|->
name|item
decl_stmt|;
name|commit
operator|->
name|indegree
operator|=
literal|1
expr_stmt|;
block|}
comment|/* update the indegree */
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|next
operator|->
name|item
operator|->
name|parents
decl_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|parent
operator|->
name|indegree
condition|)
name|parent
operator|->
name|indegree
operator|++
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* 	 * find the tips 	 * 	 * tips are nodes not reachable from any other node in the list 	 * 	 * the tips serve as a starting set for the work queue. 	 */
name|work
operator|=
name|NULL
expr_stmt|;
name|insert
operator|=
operator|&
name|work
expr_stmt|;
for|for
control|(
name|next
operator|=
name|orig
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|next
operator|->
name|item
decl_stmt|;
if|if
condition|(
name|commit
operator|->
name|indegree
operator|==
literal|1
condition|)
name|insert
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|commit
argument_list|,
name|insert
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
comment|/* process the list in topological order */
if|if
condition|(
operator|!
name|lifo
condition|)
name|commit_list_sort_by_date
argument_list|(
operator|&
name|work
argument_list|)
expr_stmt|;
name|pptr
operator|=
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|work
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|,
modifier|*
name|work_item
decl_stmt|;
name|work_item
operator|=
name|work
expr_stmt|;
name|work
operator|=
name|work_item
operator|->
name|next
expr_stmt|;
name|work_item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|commit
operator|=
name|work_item
operator|->
name|item
expr_stmt|;
for|for
control|(
name|parents
operator|=
name|commit
operator|->
name|parents
init|;
name|parents
condition|;
name|parents
operator|=
name|parents
operator|->
name|next
control|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|->
name|indegree
condition|)
continue|continue;
comment|/* 			 * parents are only enqueued for emission 			 * when all their children have been emitted thereby 			 * guaranteeing topological order. 			 */
if|if
condition|(
operator|--
name|parent
operator|->
name|indegree
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|lifo
condition|)
name|commit_list_insert_by_date
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
else|else
name|commit_list_insert
argument_list|(
name|parent
argument_list|,
operator|&
name|work
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * work_item is a commit all of whose children 		 * have already been emitted. we can emit it now. 		 */
name|commit
operator|->
name|indegree
operator|=
literal|0
expr_stmt|;
operator|*
name|pptr
operator|=
name|work_item
expr_stmt|;
name|pptr
operator|=
operator|&
name|work_item
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* merge-base stuff */
end_comment
begin_comment
comment|/* bits #0..15 in revision.h */
end_comment
begin_define
DECL|macro|PARENT1
define|#
directive|define
name|PARENT1
value|(1u<<16)
end_define
begin_define
DECL|macro|PARENT2
define|#
directive|define
name|PARENT2
value|(1u<<17)
end_define
begin_define
DECL|macro|STALE
define|#
directive|define
name|STALE
value|(1u<<18)
end_define
begin_define
DECL|macro|RESULT
define|#
directive|define
name|RESULT
value|(1u<<19)
end_define
begin_decl_stmt
DECL|variable|all_flags
specifier|static
specifier|const
name|unsigned
name|all_flags
init|=
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator||
name|RESULT
operator|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|interesting
specifier|static
name|struct
name|commit
modifier|*
name|interesting
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|list
operator|->
name|item
decl_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
condition|)
continue|continue;
return|return
name|commit
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|merge_bases_many
specifier|static
name|struct
name|commit_list
modifier|*
name|merge_bases_many
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|twos
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|one
operator|==
name|twos
index|[
name|i
index|]
condition|)
comment|/* 			 * We do not mark this even with RESULT so we do not 			 * have to clean it up. 			 */
return|return
name|commit_list_insert
argument_list|(
name|one
argument_list|,
operator|&
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|parse_commit
argument_list|(
name|one
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parse_commit
argument_list|(
name|twos
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|one
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT1
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|one
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|twos
index|[
name|i
index|]
operator|->
name|object
operator|.
name|flags
operator||=
name|PARENT2
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|twos
index|[
name|i
index|]
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|interesting
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|next
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|commit
operator|=
name|list
operator|->
name|item
expr_stmt|;
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
name|flags
operator|=
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
operator|(
name|PARENT1
operator||
name|PARENT2
operator||
name|STALE
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|(
name|PARENT1
operator||
name|PARENT2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|RESULT
operator|)
condition|)
block|{
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|RESULT
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|commit
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Mark parents of a found merge stale */
name|flags
operator||=
name|STALE
expr_stmt|;
block|}
name|parents
operator|=
name|commit
operator|->
name|parents
expr_stmt|;
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|p
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|object
operator|.
name|flags
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
continue|continue;
if|if
condition|(
name|parse_commit
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|object
operator|.
name|flags
operator||=
name|flags
expr_stmt|;
name|commit_list_insert_by_date
argument_list|(
name|p
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up the result to remove stale ones */
name|free_commit_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
name|list
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&
name|STALE
operator|)
condition|)
name|commit_list_insert_by_date
argument_list|(
name|list
operator|->
name|item
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_octopus_merge_bases
name|struct
name|commit_list
modifier|*
name|get_octopus_merge_bases
parameter_list|(
name|struct
name|commit_list
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|commit_list
modifier|*
modifier|*
name|pptr
init|=
operator|&
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
name|in
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ret
condition|)
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|i
operator|->
name|item
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
else|else
block|{
name|struct
name|commit_list
modifier|*
name|new
init|=
name|NULL
decl_stmt|,
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|j
operator|=
name|ret
init|;
name|j
condition|;
name|j
operator|=
name|j
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|bases
decl_stmt|;
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|i
operator|->
name|item
argument_list|,
name|j
operator|->
name|item
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|new
operator|=
name|bases
expr_stmt|;
else|else
name|end
operator|->
name|next
operator|=
name|bases
expr_stmt|;
for|for
control|(
name|k
operator|=
name|bases
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|next
control|)
name|end
operator|=
name|k
expr_stmt|;
block|}
name|ret
operator|=
name|new
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|get_merge_bases_many
name|struct
name|commit_list
modifier|*
name|get_merge_bases_many
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|twos
parameter_list|,
name|int
name|cleanup
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|list
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|rslt
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|result
operator|=
name|merge_bases_many
argument_list|(
name|one
argument_list|,
name|n
argument_list|,
name|twos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|one
operator|==
name|twos
index|[
name|i
index|]
condition|)
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|result
operator|||
operator|!
name|result
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|cleanup
condition|)
block|{
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|clear_commit_marks
argument_list|(
name|twos
index|[
name|i
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* There are more than one */
name|cnt
operator|=
literal|0
expr_stmt|;
name|list
operator|=
name|result
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|rslt
operator|=
name|xcalloc
argument_list|(
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rslt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|result
operator|,
name|i
operator|=
literal|0
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|rslt
index|[
name|i
operator|++
index|]
operator|=
name|list
operator|->
name|item
expr_stmt|;
name|free_commit_list
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|one
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|clear_commit_marks
argument_list|(
name|twos
index|[
name|i
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rslt
index|[
name|i
index|]
operator|||
operator|!
name|rslt
index|[
name|j
index|]
condition|)
continue|continue;
name|result
operator|=
name|merge_bases_many
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
operator|&
name|rslt
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|rslt
index|[
name|j
index|]
argument_list|,
name|all_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|result
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rslt
index|[
name|i
index|]
operator|==
name|list
operator|->
name|item
condition|)
name|rslt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rslt
index|[
name|j
index|]
operator|==
name|list
operator|->
name|item
condition|)
name|rslt
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* Surviving ones in rslt[] are the independent results */
name|result
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rslt
index|[
name|i
index|]
condition|)
name|commit_list_insert_by_date
argument_list|(
name|rslt
index|[
name|i
index|]
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rslt
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_merge_bases
name|struct
name|commit_list
modifier|*
name|get_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|one
parameter_list|,
name|struct
name|commit
modifier|*
name|two
parameter_list|,
name|int
name|cleanup
parameter_list|)
block|{
return|return
name|get_merge_bases_many
argument_list|(
name|one
argument_list|,
literal|1
argument_list|,
operator|&
name|two
argument_list|,
name|cleanup
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|is_descendant_of
name|int
name|is_descendant_of
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_list
modifier|*
name|with_commit
parameter_list|)
block|{
if|if
condition|(
operator|!
name|with_commit
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|with_commit
condition|)
block|{
name|struct
name|commit
modifier|*
name|other
decl_stmt|;
name|other
operator|=
name|with_commit
operator|->
name|item
expr_stmt|;
name|with_commit
operator|=
name|with_commit
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|in_merge_bases
argument_list|(
name|other
argument_list|,
operator|&
name|commit
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|in_merge_bases
name|int
name|in_merge_bases
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit
modifier|*
modifier|*
name|reference
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|bases
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|bases
operator|=
name|get_merge_bases
argument_list|(
name|commit
argument_list|,
operator|*
name|reference
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|die
argument_list|(
literal|"not yet"
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bases
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|b
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|free_commit_list
argument_list|(
name|bases
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|reduce_heads
name|struct
name|commit_list
modifier|*
name|reduce_heads
parameter_list|(
name|struct
name|commit_list
modifier|*
name|heads
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|p
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|result
decl_stmt|;
name|struct
name|commit
modifier|*
modifier|*
name|other
decl_stmt|;
name|size_t
name|num_head
decl_stmt|,
name|num_other
decl_stmt|;
if|if
condition|(
operator|!
name|heads
condition|)
return|return
name|NULL
return|;
comment|/* Avoid unnecessary reallocations */
for|for
control|(
name|p
operator|=
name|heads
operator|,
name|num_head
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|num_head
operator|++
expr_stmt|;
name|other
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|other
argument_list|)
argument_list|,
name|num_head
argument_list|)
expr_stmt|;
comment|/* For each commit, see if it can be reached by others */
for|for
control|(
name|p
operator|=
name|heads
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|commit_list
modifier|*
name|q
decl_stmt|,
modifier|*
name|base
decl_stmt|;
comment|/* Do we already have this in the result? */
for|for
control|(
name|q
operator|=
name|result
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|item
operator|==
name|q
operator|->
name|item
condition|)
break|break;
if|if
condition|(
name|q
condition|)
continue|continue;
name|num_other
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|heads
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|item
operator|==
name|q
operator|->
name|item
condition|)
continue|continue;
name|other
index|[
name|num_other
operator|++
index|]
operator|=
name|q
operator|->
name|item
expr_stmt|;
block|}
if|if
condition|(
name|num_other
condition|)
name|base
operator|=
name|get_merge_bases_many
argument_list|(
name|p
operator|->
name|item
argument_list|,
name|num_other
argument_list|,
name|other
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If p->item does not have anything common with other 		 * commits, there won't be any merge base.  If it is 		 * reachable from some of the others, p->item will be 		 * the merge base.  If its history is connected with 		 * others, but p->item is not reachable by others, we 		 * will get something other than p->item back. 		 */
if|if
condition|(
operator|!
name|base
operator|||
operator|(
name|base
operator|->
name|item
operator|!=
name|p
operator|->
name|item
operator|)
condition|)
name|tail
operator|=
operator|&
operator|(
name|commit_list_insert
argument_list|(
name|p
operator|->
name|item
argument_list|,
name|tail
argument_list|)
operator|->
name|next
operator|)
expr_stmt|;
name|free_commit_list
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|other
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|gpg_sig_header
specifier|static
specifier|const
name|char
name|gpg_sig_header
index|[]
init|=
literal|"gpgsig"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|gpg_sig_header_len
specifier|static
specifier|const
name|int
name|gpg_sig_header_len
init|=
sizeof|sizeof
argument_list|(
name|gpg_sig_header
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|do_sign_commit
specifier|static
name|int
name|do_sign_commit
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|keyid
parameter_list|)
block|{
name|struct
name|strbuf
name|sig
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|inspos
decl_stmt|,
name|copypos
decl_stmt|;
comment|/* find the end of the header */
name|inspos
operator|=
name|strstr
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
literal|"\n\n"
argument_list|)
operator|-
name|buf
operator|->
name|buf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|keyid
operator|||
operator|!
operator|*
name|keyid
condition|)
name|keyid
operator|=
name|get_signing_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|sign_buffer
argument_list|(
name|buf
argument_list|,
operator|&
name|sig
argument_list|,
name|keyid
argument_list|)
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|copypos
operator|=
literal|0
init|;
name|sig
operator|.
name|buf
index|[
name|copypos
index|]
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|bol
init|=
name|sig
operator|.
name|buf
operator|+
name|copypos
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
init|=
name|strchrnul
argument_list|(
name|bol
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|int
name|len
init|=
operator|(
name|eol
operator|-
name|bol
operator|)
operator|+
operator|!
operator|!
operator|*
name|eol
decl_stmt|;
if|if
condition|(
operator|!
name|copypos
condition|)
block|{
name|strbuf_insert
argument_list|(
name|buf
argument_list|,
name|inspos
argument_list|,
name|gpg_sig_header
argument_list|,
name|gpg_sig_header_len
argument_list|)
expr_stmt|;
name|inspos
operator|+=
name|gpg_sig_header_len
expr_stmt|;
block|}
name|strbuf_insert
argument_list|(
name|buf
argument_list|,
name|inspos
operator|++
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
name|buf
argument_list|,
name|inspos
argument_list|,
name|bol
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|inspos
operator|+=
name|len
expr_stmt|;
name|copypos
operator|+=
name|len
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|parse_signed_commit
name|int
name|parse_signed_commit
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|strbuf
modifier|*
name|payload
parameter_list|,
name|struct
name|strbuf
modifier|*
name|signature
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|read_sha1_file
argument_list|(
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
name|int
name|in_signature
decl_stmt|,
name|saw_signature
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
name|type
operator|!=
name|OBJ_COMMIT
condition|)
goto|goto
name|cleanup
goto|;
name|line
operator|=
name|buffer
expr_stmt|;
name|tail
operator|=
name|buffer
operator|+
name|size
expr_stmt|;
name|in_signature
operator|=
literal|0
expr_stmt|;
name|saw_signature
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|line
operator|<
name|tail
condition|)
block|{
specifier|const
name|char
modifier|*
name|sig
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|next
init|=
name|memchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|,
name|tail
operator|-
name|line
argument_list|)
decl_stmt|;
name|next
operator|=
name|next
condition|?
name|next
operator|+
literal|1
else|:
name|tail
expr_stmt|;
if|if
condition|(
name|in_signature
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|sig
operator|=
name|line
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|line
argument_list|,
name|gpg_sig_header
argument_list|)
operator|&&
name|line
index|[
name|gpg_sig_header_len
index|]
operator|==
literal|' '
condition|)
name|sig
operator|=
name|line
operator|+
name|gpg_sig_header_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sig
condition|)
block|{
name|strbuf_add
argument_list|(
name|signature
argument_list|,
name|sig
argument_list|,
name|next
operator|-
name|sig
argument_list|)
expr_stmt|;
name|saw_signature
operator|=
literal|1
expr_stmt|;
name|in_signature
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'\n'
condition|)
comment|/* dump the whole remainder of the buffer */
name|next
operator|=
name|tail
expr_stmt|;
name|strbuf_add
argument_list|(
name|payload
argument_list|,
name|line
argument_list|,
name|next
operator|-
name|line
argument_list|)
expr_stmt|;
name|in_signature
operator|=
literal|0
expr_stmt|;
block|}
name|line
operator|=
name|next
expr_stmt|;
block|}
name|cleanup
label|:
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|saw_signature
return|;
block|}
end_function
begin_function
DECL|function|handle_signed_tag
specifier|static
name|void
name|handle_signed_tag
parameter_list|(
name|struct
name|commit
modifier|*
name|parent
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|merge_remote_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|commit_extra_header
modifier|*
name|mergetag
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|len
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|desc
operator|=
name|merge_remote_util
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|desc
operator|||
operator|!
name|desc
operator|->
name|obj
condition|)
return|return;
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|desc
operator|->
name|obj
operator|->
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
name|type
operator|!=
name|OBJ_TAG
condition|)
goto|goto
name|free_return
goto|;
name|len
operator|=
name|parse_signature
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|len
condition|)
goto|goto
name|free_return
goto|;
comment|/* 	 * We could verify this signature and either omit the tag when 	 * it does not validate, but the integrator may not have the 	 * public key of the signer of the tag he is merging, while a 	 * later auditor may have it while auditing, so let's not run 	 * verify-signed-buffer here for now... 	 * 	 * if (verify_signed_buffer(buf, len, buf + len, size - len, ...)) 	 *	warn("warning: signed tag unverified."); 	 */
name|mergetag
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mergetag
argument_list|)
argument_list|)
expr_stmt|;
name|mergetag
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"mergetag"
argument_list|)
expr_stmt|;
name|mergetag
operator|->
name|value
operator|=
name|buf
expr_stmt|;
name|mergetag
operator|->
name|len
operator|=
name|size
expr_stmt|;
operator|*
operator|*
name|tail
operator|=
name|mergetag
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|mergetag
operator|->
name|next
expr_stmt|;
return|return;
name|free_return
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append_merge_tag_headers
name|void
name|append_merge_tag_headers
parameter_list|(
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|handle_signed_tag
argument_list|(
name|parent
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|parents
operator|=
name|parents
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|add_extra_header
specifier|static
name|void
name|add_extra_header
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buffer
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
name|extra
parameter_list|)
block|{
name|strbuf_addstr
argument_list|(
name|buffer
argument_list|,
name|extra
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|->
name|len
condition|)
name|strbuf_add_lines
argument_list|(
name|buffer
argument_list|,
literal|" "
argument_list|,
name|extra
operator|->
name|value
argument_list|,
name|extra
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
name|strbuf_addch
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_commit_extra_headers
name|struct
name|commit_extra_header
modifier|*
name|read_commit_extra_headers
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|exclude
parameter_list|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|extra
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|read_sha1_file
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|&&
name|type
operator|==
name|OBJ_COMMIT
condition|)
name|extra
operator|=
name|read_commit_extra_header_lines
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
name|exclude
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|extra
return|;
block|}
end_function
begin_function
DECL|function|standard_header_field
specifier|static
specifier|inline
name|int
name|standard_header_field
parameter_list|(
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
operator|(
name|len
operator|==
literal|4
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"tree "
argument_list|,
literal|5
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|6
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"parent "
argument_list|,
literal|7
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|6
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"author "
argument_list|,
literal|7
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|9
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"committer "
argument_list|,
literal|10
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
literal|8
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
literal|"encoding "
argument_list|,
literal|9
argument_list|)
operator|)
operator|)
return|;
block|}
end_function
begin_function
DECL|function|excluded_header_field
specifier|static
name|int
name|excluded_header_field
parameter_list|(
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|exclude
parameter_list|)
block|{
if|if
condition|(
operator|!
name|exclude
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|exclude
condition|)
block|{
name|size_t
name|xlen
init|=
name|strlen
argument_list|(
operator|*
name|exclude
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|xlen
operator|&&
operator|!
name|memcmp
argument_list|(
name|field
argument_list|,
operator|*
name|exclude
argument_list|,
name|xlen
argument_list|)
operator|&&
name|field
index|[
name|xlen
index|]
operator|==
literal|' '
condition|)
return|return
literal|1
return|;
name|exclude
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_commit_extra_header_lines
name|struct
name|commit_extra_header
modifier|*
name|read_commit_extra_header_lines
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|exclude
parameter_list|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|extra
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|extra
decl_stmt|,
modifier|*
name|it
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|eof
decl_stmt|,
modifier|*
name|eob
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
for|for
control|(
name|line
operator|=
name|buffer
operator|,
name|eob
operator|=
name|line
operator|+
name|size
init|;
name|line
operator|<
name|eob
operator|&&
operator|*
name|line
operator|!=
literal|'\n'
condition|;
name|line
operator|=
name|next
control|)
block|{
name|next
operator|=
name|memchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|,
name|eob
operator|-
name|line
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
condition|?
name|next
operator|+
literal|1
else|:
name|eob
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|' '
condition|)
block|{
comment|/* continuation */
if|if
condition|(
name|it
condition|)
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|next
operator|-
operator|(
name|line
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|it
condition|)
name|it
operator|->
name|value
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|it
operator|->
name|len
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|it
operator|=
name|NULL
expr_stmt|;
name|eof
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|<=
name|eof
condition|)
name|eof
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|standard_header_field
argument_list|(
name|line
argument_list|,
name|eof
operator|-
name|line
argument_list|)
operator|||
name|excluded_header_field
argument_list|(
name|line
argument_list|,
name|eof
operator|-
name|line
argument_list|,
name|exclude
argument_list|)
condition|)
continue|continue;
name|it
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|key
operator|=
name|xmemdupz
argument_list|(
name|line
argument_list|,
name|eof
operator|-
name|line
argument_list|)
expr_stmt|;
operator|*
name|tail
operator|=
name|it
expr_stmt|;
name|tail
operator|=
operator|&
name|it
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|eof
operator|+
literal|1
operator|<
name|next
condition|)
name|strbuf_add
argument_list|(
operator|&
name|buf
argument_list|,
name|eof
operator|+
literal|1
argument_list|,
name|next
operator|-
operator|(
name|eof
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
condition|)
name|it
operator|->
name|value
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|it
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
name|extra
return|;
block|}
end_function
begin_function
DECL|function|free_commit_extra_headers
name|void
name|free_commit_extra_headers
parameter_list|(
name|struct
name|commit_extra_header
modifier|*
name|extra
parameter_list|)
block|{
while|while
condition|(
name|extra
condition|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|next
init|=
name|extra
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|extra
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|extra
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|commit_tree
name|int
name|commit_tree
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|msg
parameter_list|,
name|unsigned
name|char
modifier|*
name|tree
parameter_list|,
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
name|unsigned
name|char
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|sign_commit
parameter_list|)
block|{
name|struct
name|commit_extra_header
modifier|*
name|extra
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|tail
init|=
operator|&
name|extra
decl_stmt|;
name|int
name|result
decl_stmt|;
name|append_merge_tag_headers
argument_list|(
name|parents
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|result
operator|=
name|commit_tree_extended
argument_list|(
name|msg
argument_list|,
name|tree
argument_list|,
name|parents
argument_list|,
name|ret
argument_list|,
name|author
argument_list|,
name|sign_commit
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|free_commit_extra_headers
argument_list|(
name|extra
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|commit_utf8_warn
specifier|static
specifier|const
name|char
name|commit_utf8_warn
index|[]
init|=
literal|"Warning: commit message does not conform to UTF-8.\n"
literal|"You may want to amend it after fixing the message, or set the config\n"
literal|"variable i18n.commitencoding to the encoding your project uses.\n"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|commit_tree_extended
name|int
name|commit_tree_extended
parameter_list|(
specifier|const
name|struct
name|strbuf
modifier|*
name|msg
parameter_list|,
name|unsigned
name|char
modifier|*
name|tree
parameter_list|,
name|struct
name|commit_list
modifier|*
name|parents
parameter_list|,
name|unsigned
name|char
modifier|*
name|ret
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|sign_commit
parameter_list|,
name|struct
name|commit_extra_header
modifier|*
name|extra
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|int
name|encoding_is_utf8
decl_stmt|;
name|struct
name|strbuf
name|buffer
decl_stmt|;
name|assert_sha1_type
argument_list|(
name|tree
argument_list|,
name|OBJ_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memchr
argument_list|(
name|msg
operator|->
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|msg
operator|->
name|len
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"a NUL byte in commit log message not allowed."
argument_list|)
return|;
comment|/* Not having i18n.commitencoding is the same as having utf-8 */
name|encoding_is_utf8
operator|=
name|is_encoding_utf8
argument_list|(
name|git_commit_encoding
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|buffer
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
comment|/* should avoid reallocs for the headers */
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"tree %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE! This ordering means that the same exact tree merged with a 	 * different order of parents will be a _different_ changeset even 	 * if everything else stays the same. 	 */
while|while
condition|(
name|parents
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|next
init|=
name|parents
operator|->
name|next
decl_stmt|;
name|struct
name|commit
modifier|*
name|parent
init|=
name|parents
operator|->
name|item
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"parent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|parent
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|parents
operator|=
name|next
expr_stmt|;
block|}
comment|/* Person/date information */
if|if
condition|(
operator|!
name|author
condition|)
name|author
operator|=
name|git_author_info
argument_list|(
name|IDENT_STRICT
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"author %s\n"
argument_list|,
name|author
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"committer %s\n"
argument_list|,
name|git_committer_info
argument_list|(
name|IDENT_STRICT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|encoding_is_utf8
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|buffer
argument_list|,
literal|"encoding %s\n"
argument_list|,
name|git_commit_encoding
argument_list|)
expr_stmt|;
while|while
condition|(
name|extra
condition|)
block|{
name|add_extra_header
argument_list|(
operator|&
name|buffer
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|extra
operator|=
name|extra
operator|->
name|next
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|buffer
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* And add the comment */
name|strbuf_addbuf
argument_list|(
operator|&
name|buffer
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* And check the encoding */
if|if
condition|(
name|encoding_is_utf8
operator|&&
operator|!
name|is_utf8
argument_list|(
name|buffer
operator|.
name|buf
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|commit_utf8_warn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign_commit
operator|&&
name|do_sign_commit
argument_list|(
operator|&
name|buffer
argument_list|,
name|sign_commit
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|result
operator|=
name|write_sha1_file
argument_list|(
name|buffer
operator|.
name|buf
argument_list|,
name|buffer
operator|.
name|len
argument_list|,
name|commit_type
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|get_merge_parent
name|struct
name|commit
modifier|*
name|get_merge_parent
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|obj
operator|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
name|commit
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|peel_to_type
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|obj
argument_list|,
name|OBJ_COMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
operator|&&
operator|!
name|commit
operator|->
name|util
condition|)
block|{
name|struct
name|merge_remote_desc
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|desc
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|commit
operator|->
name|util
operator|=
name|desc
expr_stmt|;
block|}
return|return
name|commit
return|;
block|}
end_function
begin_comment
comment|/*  * Append a commit to the end of the commit_list.  *  * next starts by pointing to the variable that holds the head of an  * empty commit_list, and is updated to point to the "next" field of  * the last item on the list as new commits are appended.  *  * Usage example:  *  *     struct commit_list *list;  *     struct commit_list **next =&list;  *  *     next = commit_list_append(c1, next);  *     next = commit_list_append(c2, next);  *     assert(commit_list_count(list) == 2);  *     return list;  */
end_comment
begin_function
DECL|function|commit_list_append
name|struct
name|commit_list
modifier|*
modifier|*
name|commit_list_append
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|struct
name|commit_list
modifier|*
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|commit_list
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_list
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|item
operator|=
name|commit
expr_stmt|;
operator|*
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|next
return|;
block|}
end_function
end_unit
