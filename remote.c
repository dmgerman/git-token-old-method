begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_decl_stmt
DECL|variable|remotes
specifier|static
name|struct
name|remote
modifier|*
modifier|*
name|remotes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allocated_remotes
specifier|static
name|int
name|allocated_remotes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branches
specifier|static
name|struct
name|branch
modifier|*
modifier|*
name|branches
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|allocated_branches
specifier|static
name|int
name|allocated_branches
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_branch
specifier|static
name|struct
name|branch
modifier|*
name|current_branch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_remote_name
specifier|static
specifier|const
name|char
modifier|*
name|default_remote_name
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|BUF_SIZE
define|#
directive|define
name|BUF_SIZE
value|(2048)
end_define
begin_decl_stmt
DECL|variable|buffer
specifier|static
name|char
name|buffer
index|[
name|BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|add_push_refspec
specifier|static
name|void
name|add_push_refspec
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|int
name|nr
init|=
name|remote
operator|->
name|push_refspec_nr
operator|+
literal|1
decl_stmt|;
name|remote
operator|->
name|push_refspec
operator|=
name|xrealloc
argument_list|(
name|remote
operator|->
name|push_refspec
argument_list|,
name|nr
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|->
name|push_refspec
index|[
name|nr
operator|-
literal|1
index|]
operator|=
name|ref
expr_stmt|;
name|remote
operator|->
name|push_refspec_nr
operator|=
name|nr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_fetch_refspec
specifier|static
name|void
name|add_fetch_refspec
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|int
name|nr
init|=
name|remote
operator|->
name|fetch_refspec_nr
operator|+
literal|1
decl_stmt|;
name|remote
operator|->
name|fetch_refspec
operator|=
name|xrealloc
argument_list|(
name|remote
operator|->
name|fetch_refspec
argument_list|,
name|nr
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|->
name|fetch_refspec
index|[
name|nr
operator|-
literal|1
index|]
operator|=
name|ref
expr_stmt|;
name|remote
operator|->
name|fetch_refspec_nr
operator|=
name|nr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_url
specifier|static
name|void
name|add_url
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|int
name|nr
init|=
name|remote
operator|->
name|url_nr
operator|+
literal|1
decl_stmt|;
name|remote
operator|->
name|url
operator|=
name|xrealloc
argument_list|(
name|remote
operator|->
name|url
argument_list|,
name|nr
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|->
name|url
index|[
name|nr
operator|-
literal|1
index|]
operator|=
name|url
expr_stmt|;
name|remote
operator|->
name|url_nr
operator|=
name|nr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_remote
specifier|static
name|struct
name|remote
modifier|*
name|make_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|empty
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|allocated_remotes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|remotes
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|empty
operator|<
literal|0
condition|)
name|empty
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
condition|?
operator|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|remotes
index|[
name|i
index|]
operator|->
name|name
index|[
name|len
index|]
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|remotes
index|[
name|i
index|]
return|;
block|}
block|}
if|if
condition|(
name|empty
operator|<
literal|0
condition|)
block|{
name|empty
operator|=
name|allocated_remotes
expr_stmt|;
name|allocated_remotes
operator|+=
name|allocated_remotes
condition|?
name|allocated_remotes
else|:
literal|1
expr_stmt|;
name|remotes
operator|=
name|xrealloc
argument_list|(
name|remotes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|remotes
argument_list|)
operator|*
name|allocated_remotes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|remotes
operator|+
name|empty
argument_list|,
literal|0
argument_list|,
operator|(
name|allocated_remotes
operator|-
name|empty
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|remotes
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remotes
index|[
name|empty
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|remote
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|remotes
index|[
name|empty
index|]
operator|->
name|name
operator|=
name|xstrndup
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|remotes
index|[
name|empty
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|remotes
index|[
name|empty
index|]
return|;
block|}
end_function
begin_function
DECL|function|add_merge
specifier|static
name|void
name|add_merge
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|nr
init|=
name|branch
operator|->
name|merge_nr
operator|+
literal|1
decl_stmt|;
name|branch
operator|->
name|merge_name
operator|=
name|xrealloc
argument_list|(
name|branch
operator|->
name|merge_name
argument_list|,
name|nr
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|branch
operator|->
name|merge_name
index|[
name|nr
operator|-
literal|1
index|]
operator|=
name|name
expr_stmt|;
name|branch
operator|->
name|merge_nr
operator|=
name|nr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_branch
specifier|static
name|struct
name|branch
modifier|*
name|make_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|empty
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|refname
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|allocated_branches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|branches
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|empty
operator|<
literal|0
condition|)
name|empty
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
condition|?
operator|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|branches
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|branches
index|[
name|i
index|]
operator|->
name|name
index|[
name|len
index|]
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|branches
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|branches
index|[
name|i
index|]
return|;
block|}
block|}
if|if
condition|(
name|empty
operator|<
literal|0
condition|)
block|{
name|empty
operator|=
name|allocated_branches
expr_stmt|;
name|allocated_branches
operator|+=
name|allocated_branches
condition|?
name|allocated_branches
else|:
literal|1
expr_stmt|;
name|branches
operator|=
name|xrealloc
argument_list|(
name|branches
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|branches
argument_list|)
operator|*
name|allocated_branches
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|branches
operator|+
name|empty
argument_list|,
literal|0
argument_list|,
operator|(
name|allocated_branches
operator|-
name|empty
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|branches
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|branches
index|[
name|empty
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|branch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|branches
index|[
name|empty
index|]
operator|->
name|name
operator|=
name|xstrndup
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|branches
index|[
name|empty
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|refname
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|refname
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
argument_list|,
name|branches
index|[
name|empty
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|branches
index|[
name|empty
index|]
operator|->
name|refname
operator|=
name|refname
expr_stmt|;
return|return
name|branches
index|[
name|empty
index|]
return|;
block|}
end_function
begin_function
DECL|function|read_remotes_file
specifier|static
name|void
name|read_remotes_file
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"remotes/%s"
argument_list|,
name|remote
operator|->
name|name
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|int
name|value_list
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"URL:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"Push:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"Pull:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|5
expr_stmt|;
block|}
else|else
continue|continue;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
continue|continue;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|value_list
condition|)
block|{
case|case
literal|0
case|:
name|add_url
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_branches_file
specifier|static
name|void
name|read_branches_file
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|slash
init|=
name|strchr
argument_list|(
name|remote
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|frag
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
name|int
name|n
init|=
name|slash
condition|?
name|slash
operator|-
name|remote
operator|->
name|name
else|:
literal|1000
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"branches/%.*s"
argument_list|,
name|n
argument_list|,
name|remote
operator|->
name|name
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|s
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|slash
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|strcat
argument_list|(
name|p
argument_list|,
name|slash
argument_list|)
expr_stmt|;
name|frag
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
condition|)
block|{
operator|*
operator|(
name|frag
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|branch
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|frag
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|branch
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|branch
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|branch
operator|=
literal|"refs/heads/master"
expr_stmt|;
block|}
name|add_url
argument_list|(
name|remote
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|remote
operator|->
name|fetch_tags
operator|=
literal|1
expr_stmt|;
comment|/* always auto-follow */
block|}
end_function
begin_function
DECL|function|handle_config
specifier|static
name|int
name|handle_config
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|subkey
decl_stmt|;
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"branch."
argument_list|)
condition|)
block|{
name|name
operator|=
name|key
operator|+
literal|7
expr_stmt|;
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|branch
operator|=
name|make_branch
argument_list|(
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".remote"
argument_list|)
condition|)
block|{
name|branch
operator|->
name|remote_name
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|==
name|current_branch
condition|)
name|default_remote_name
operator|=
name|branch
operator|->
name|remote_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".merge"
argument_list|)
condition|)
name|add_merge
argument_list|(
name|branch
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"remote."
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|key
operator|+
literal|7
expr_stmt|;
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
name|error
argument_list|(
literal|"Config with no key for remote %s"
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
operator|*
name|subkey
operator|==
literal|'/'
condition|)
block|{
name|warning
argument_list|(
literal|"Config remote shorthand cannot begin with '/': %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|remote
operator|=
name|make_remote
argument_list|(
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
block|{
comment|/* if we ever have a boolean variable, e.g. "remote.*.disabled" 		 * [remote "frotz"] 		 *      disabled 		 * is a valid way to set it to true; we get NULL in value so 		 * we need to handle it here. 		 * 		 * if (!strcmp(subkey, ".disabled")) { 		 *      val = git_config_bool(key, value); 		 *      return 0; 		 * } else 		 * 		 */
return|return
literal|0
return|;
comment|/* ignore unknown booleans */
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".url"
argument_list|)
condition|)
block|{
name|add_url
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".push"
argument_list|)
condition|)
block|{
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".fetch"
argument_list|)
condition|)
block|{
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".receivepack"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|remote
operator|->
name|receivepack
condition|)
name|remote
operator|->
name|receivepack
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"more than one receivepack given, using the first"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".uploadpack"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|remote
operator|->
name|uploadpack
condition|)
name|remote
operator|->
name|uploadpack
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"more than one uploadpack given, using the first"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".tagopt"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"--no-tags"
argument_list|)
condition|)
name|remote
operator|->
name|fetch_tags
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|read_config
specifier|static
name|void
name|read_config
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|head_ref
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|if
condition|(
name|default_remote_name
condition|)
comment|// did this already
return|return;
name|default_remote_name
operator|=
name|xstrdup
argument_list|(
literal|"origin"
argument_list|)
expr_stmt|;
name|current_branch
operator|=
name|NULL
expr_stmt|;
name|head_ref
operator|=
name|resolve_ref
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_ref
operator|&&
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|head_ref
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
block|{
name|current_branch
operator|=
name|make_branch
argument_list|(
name|head_ref
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|git_config
argument_list|(
name|handle_config
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_ref_spec
name|struct
name|refspec
modifier|*
name|parse_ref_spec
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|refspec
modifier|*
name|rs
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|,
name|nr_refspec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|gp
decl_stmt|;
name|sp
operator|=
name|refspec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'+'
condition|)
block|{
name|rs
index|[
name|i
index|]
operator|.
name|force
operator|=
literal|1
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
name|gp
operator|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|ep
operator|=
name|strchr
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|&&
name|ep
operator|&&
name|gp
operator|>
name|ep
condition|)
name|gp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ep
condition|)
block|{
if|if
condition|(
name|ep
index|[
literal|1
index|]
condition|)
block|{
specifier|const
name|char
modifier|*
name|glob
init|=
name|strchr
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
literal|'*'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|gp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gp
condition|)
name|rs
index|[
name|i
index|]
operator|.
name|dst
operator|=
name|xstrndup
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
name|glob
operator|-
name|ep
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|rs
index|[
name|i
index|]
operator|.
name|dst
operator|=
name|xstrdup
argument_list|(
name|ep
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ep
operator|=
name|sp
operator|+
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gp
condition|)
block|{
name|rs
index|[
name|i
index|]
operator|.
name|pattern
operator|=
literal|1
expr_stmt|;
name|ep
operator|=
name|gp
expr_stmt|;
block|}
name|rs
index|[
name|i
index|]
operator|.
name|src
operator|=
name|xstrndup
argument_list|(
name|sp
argument_list|,
name|ep
operator|-
name|sp
argument_list|)
expr_stmt|;
block|}
return|return
name|rs
return|;
block|}
end_function
begin_function
DECL|function|remote_get
name|struct
name|remote
modifier|*
name|remote_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|remote
modifier|*
name|ret
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
name|default_remote_name
expr_stmt|;
name|ret
operator|=
name|make_remote
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
name|read_remotes_file
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
name|read_branches_file
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
name|add_url
argument_list|(
name|ret
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|fetch
operator|=
name|parse_ref_spec
argument_list|(
name|ret
operator|->
name|fetch_refspec_nr
argument_list|,
name|ret
operator|->
name|fetch_refspec
argument_list|)
expr_stmt|;
name|ret
operator|->
name|push
operator|=
name|parse_ref_spec
argument_list|(
name|ret
operator|->
name|push_refspec_nr
argument_list|,
name|ret
operator|->
name|push_refspec
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|for_each_remote
name|int
name|for_each_remote
parameter_list|(
name|each_remote_fn
name|fn
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|allocated_remotes
operator|&&
operator|!
name|result
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|remote
modifier|*
name|r
init|=
name|remotes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
continue|continue;
if|if
condition|(
operator|!
name|r
operator|->
name|fetch
condition|)
name|r
operator|->
name|fetch
operator|=
name|parse_ref_spec
argument_list|(
name|r
operator|->
name|fetch_refspec_nr
argument_list|,
name|r
operator|->
name|fetch_refspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|push
condition|)
name|r
operator|->
name|push
operator|=
name|parse_ref_spec
argument_list|(
name|r
operator|->
name|push_refspec_nr
argument_list|,
name|r
operator|->
name|push_refspec
argument_list|)
expr_stmt|;
name|result
operator|=
name|fn
argument_list|(
name|r
argument_list|,
name|priv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|ref_remove_duplicates
name|void
name|ref_remove_duplicates
parameter_list|(
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|posn
decl_stmt|;
name|struct
name|ref
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|ref_map
condition|;
name|ref_map
operator|=
name|ref_map
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ref_map
operator|->
name|peer_ref
condition|)
continue|continue;
name|posn
operator|=
operator|&
name|ref_map
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|*
name|posn
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|peer_ref
operator|&&
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|name
argument_list|)
condition|)
name|die
argument_list|(
literal|"%s tracks both %s and %s"
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
operator|(
operator|*
name|posn
operator|)
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|name
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
operator|*
name|posn
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|posn
argument_list|)
expr_stmt|;
operator|*
name|posn
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|posn
operator|=
operator|&
operator|(
operator|*
name|posn
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|remote_has_url
name|int
name|remote_has_url
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remote
operator|->
name|url_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|remote
operator|->
name|url
index|[
name|i
index|]
argument_list|,
name|url
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Returns true if, under the matching rules for fetching, name is the  * same as the given full name.  */
end_comment
begin_function
DECL|function|ref_matches_abbrev
specifier|static
name|int
name|ref_matches_abbrev
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|full
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
return|return
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|full
argument_list|)
return|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|full
argument_list|,
literal|"refs/"
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"remotes/"
argument_list|)
condition|)
return|return
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|full
operator|+
literal|5
argument_list|)
return|;
if|if
condition|(
name|prefixcmp
argument_list|(
name|full
operator|+
literal|5
argument_list|,
literal|"heads/"
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|strcmp
argument_list|(
name|full
operator|+
literal|11
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|remote_find_tracking
name|int
name|remote_find_tracking
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
name|int
name|find_src
init|=
name|refspec
operator|->
name|src
operator|==
name|NULL
decl_stmt|;
name|char
modifier|*
name|needle
decl_stmt|,
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|find_src
condition|)
block|{
if|if
condition|(
operator|!
name|refspec
operator|->
name|dst
condition|)
return|return
name|error
argument_list|(
literal|"find_tracking: need either src or dst"
argument_list|)
return|;
name|needle
operator|=
name|refspec
operator|->
name|dst
expr_stmt|;
name|result
operator|=
operator|&
name|refspec
operator|->
name|src
expr_stmt|;
block|}
else|else
block|{
name|needle
operator|=
name|refspec
operator|->
name|src
expr_stmt|;
name|result
operator|=
operator|&
name|refspec
operator|->
name|dst
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remote
operator|->
name|fetch_refspec_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|refspec
modifier|*
name|fetch
init|=
operator|&
name|remote
operator|->
name|fetch
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|find_src
condition|?
name|fetch
operator|->
name|dst
else|:
name|fetch
operator|->
name|src
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
init|=
name|find_src
condition|?
name|fetch
operator|->
name|src
else|:
name|fetch
operator|->
name|dst
decl_stmt|;
if|if
condition|(
operator|!
name|fetch
operator|->
name|dst
condition|)
continue|continue;
if|if
condition|(
name|fetch
operator|->
name|pattern
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|needle
argument_list|,
name|key
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|strlen
argument_list|(
name|needle
argument_list|)
operator|-
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|result
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|result
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|needle
operator|+
name|strlen
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|refspec
operator|->
name|force
operator|=
name|fetch
operator|->
name|force
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|needle
argument_list|,
name|key
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|refspec
operator|->
name|force
operator|=
name|fetch
operator|->
name|force
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|alloc_ref
name|struct
name|ref
modifier|*
name|alloc_ref
parameter_list|(
name|unsigned
name|namelen
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|namelen
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|namelen
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|copy_ref
specifier|static
name|struct
name|ref
modifier|*
name|copy_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|strlen
argument_list|(
name|ref
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ref
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|strlen
argument_list|(
name|ref
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|free_refs
name|void
name|free_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|next
operator|=
name|ref
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|peer_ref
condition|)
name|free
argument_list|(
name|ref
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|count_refspec_match
specifier|static
name|int
name|count_refspec_match
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|matched_ref
parameter_list|)
block|{
name|int
name|patlen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched_weak
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched
init|=
name|NULL
decl_stmt|;
name|int
name|weak_match
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
for|for
control|(
name|weak_match
operator|=
name|match
operator|=
literal|0
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|refs
operator|->
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|<
name|patlen
operator|||
name|memcmp
argument_list|(
name|name
operator|+
name|namelen
operator|-
name|patlen
argument_list|,
name|pattern
argument_list|,
name|patlen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|name
index|[
name|namelen
operator|-
name|patlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
comment|/* A match is "weak" if it is with refs outside 		 * heads or tags, and did not specify the pattern 		 * in full (e.g. "refs/remotes/origin/master") or at 		 * least from the toplevel (e.g. "remotes/origin/master"); 		 * otherwise "git push $URL master" would result in 		 * ambiguity between remotes/origin/master and heads/master 		 * at the remote site. 		 */
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|patlen
operator|!=
name|namelen
operator|-
literal|5
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
comment|/* We want to catch the case where only weak 			 * matches are found and there are multiple 			 * matches, and where more than one strong 			 * matches are found, as ambiguous.  One 			 * strong match with zero or more weak matches 			 * are acceptable as a unique match. 			 */
name|matched_weak
operator|=
name|refs
expr_stmt|;
name|weak_match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|matched
operator|=
name|refs
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
operator|*
name|matched_ref
operator|=
name|matched_weak
expr_stmt|;
return|return
name|weak_match
return|;
block|}
else|else
block|{
operator|*
name|matched_ref
operator|=
name|matched
expr_stmt|;
return|return
name|match
return|;
block|}
block|}
end_function
begin_function
DECL|function|tail_link_ref
specifier|static
name|void
name|tail_link_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
operator|*
operator|*
name|tail
operator|=
name|ref
expr_stmt|;
while|while
condition|(
name|ref
operator|->
name|next
condition|)
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_function
DECL|function|try_explicit_object_name
specifier|static
name|struct
name|ref
modifier|*
name|try_explicit_object_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
block|{
name|ref
operator|=
name|alloc_ref
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"(delete)"
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|make_linked_ref
specifier|static
name|struct
name|ref
modifier|*
name|make_linked_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ret
operator|=
name|alloc_ref
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tail_link_ref
argument_list|(
name|ret
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|match_explicit
specifier|static
name|int
name|match_explicit
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|struct
name|refspec
modifier|*
name|rs
parameter_list|,
name|int
name|errs
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|matched_src
decl_stmt|,
modifier|*
name|matched_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_value
init|=
name|rs
operator|->
name|dst
decl_stmt|;
if|if
condition|(
name|rs
operator|->
name|pattern
condition|)
return|return
name|errs
return|;
name|matched_src
operator|=
name|matched_dst
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|rs
operator|->
name|src
argument_list|,
name|src
argument_list|,
operator|&
name|matched_src
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
comment|/* The source could be in the get_sha1() format 		 * not a reference name.  :refs/other is a 		 * way to delete 'other' ref at the remote end. 		 */
name|matched_src
operator|=
name|try_explicit_object_name
argument_list|(
name|rs
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matched_src
condition|)
name|error
argument_list|(
literal|"src refspec %s does not match any."
argument_list|,
name|rs
operator|->
name|src
argument_list|)
expr_stmt|;
break|break;
default|default:
name|matched_src
operator|=
name|NULL
expr_stmt|;
name|error
argument_list|(
literal|"src refspec %s matches more than one."
argument_list|,
name|rs
operator|->
name|src
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|matched_src
condition|)
name|errs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|dst_value
condition|)
block|{
if|if
condition|(
operator|!
name|matched_src
condition|)
return|return
name|errs
return|;
name|dst_value
operator|=
name|matched_src
operator|->
name|name
expr_stmt|;
block|}
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|dst_value
argument_list|,
name|dst
argument_list|,
operator|&
name|matched_dst
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|dst_value
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
condition|)
name|matched_dst
operator|=
name|make_linked_ref
argument_list|(
name|dst_value
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"dst refspec %s does not match any "
literal|"existing ref on the remote and does "
literal|"not start with refs/."
argument_list|,
name|dst_value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|matched_dst
operator|=
name|NULL
expr_stmt|;
name|error
argument_list|(
literal|"dst refspec %s matches more than one."
argument_list|,
name|dst_value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errs
operator|||
operator|!
name|matched_dst
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|matched_dst
operator|->
name|peer_ref
condition|)
block|{
name|errs
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"dst ref %s receives from more than one src."
argument_list|,
name|matched_dst
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matched_dst
operator|->
name|peer_ref
operator|=
name|matched_src
expr_stmt|;
name|matched_dst
operator|->
name|force
operator|=
name|rs
operator|->
name|force
expr_stmt|;
block|}
return|return
name|errs
return|;
block|}
end_function
begin_function
DECL|function|match_explicit_refs
specifier|static
name|int
name|match_explicit_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|struct
name|refspec
modifier|*
name|rs
parameter_list|,
name|int
name|rs_nr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|errs
decl_stmt|;
for|for
control|(
name|i
operator|=
name|errs
operator|=
literal|0
init|;
name|i
operator|<
name|rs_nr
condition|;
name|i
operator|++
control|)
name|errs
operator||=
name|match_explicit
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|dst_tail
argument_list|,
operator|&
name|rs
index|[
name|i
index|]
argument_list|,
name|errs
argument_list|)
expr_stmt|;
return|return
operator|-
name|errs
return|;
block|}
end_function
begin_function
DECL|function|find_ref_by_name
specifier|static
name|struct
name|ref
modifier|*
name|find_ref_by_name
parameter_list|(
name|struct
name|ref
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|list
return|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|check_pattern_match
specifier|static
specifier|const
name|struct
name|refspec
modifier|*
name|check_pattern_match
parameter_list|(
specifier|const
name|struct
name|refspec
modifier|*
name|rs
parameter_list|,
name|int
name|rs_nr
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rs
index|[
name|i
index|]
operator|.
name|pattern
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|src
operator|->
name|name
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|)
condition|)
return|return
name|rs
operator|+
name|i
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Note. This is used only by "push"; refspec matching rules for  * push and fetch are subtly different, so do not try to reuse it  * without thinking.  */
end_comment
begin_function
DECL|function|match_refs
name|int
name|match_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|int
name|nr_refspec
parameter_list|,
name|char
modifier|*
modifier|*
name|refspec
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|struct
name|refspec
modifier|*
name|rs
init|=
name|parse_ref_spec
argument_list|(
name|nr_refspec
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|refspec
argument_list|)
decl_stmt|;
if|if
condition|(
name|match_explicit_refs
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|dst_tail
argument_list|,
name|rs
argument_list|,
name|nr_refspec
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* pick the remainder */
for|for
control|(
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|dst_peer
decl_stmt|;
specifier|const
name|struct
name|refspec
modifier|*
name|pat
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|dst_name
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|peer_ref
condition|)
continue|continue;
if|if
condition|(
name|nr_refspec
condition|)
block|{
name|pat
operator|=
name|check_pattern_match
argument_list|(
name|rs
argument_list|,
name|nr_refspec
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|prefixcmp
argument_list|(
name|src
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
comment|/* 			 * "matching refs"; traditionally we pushed everything 			 * including refs outside refs/heads/ hierarchy, but 			 * that does not make much sense these days. 			 */
continue|continue;
if|if
condition|(
name|pat
condition|)
block|{
specifier|const
name|char
modifier|*
name|dst_side
init|=
name|pat
operator|->
name|dst
condition|?
name|pat
operator|->
name|dst
else|:
name|pat
operator|->
name|src
decl_stmt|;
name|dst_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dst_side
argument_list|)
operator|+
name|strlen
argument_list|(
name|src
operator|->
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|pat
operator|->
name|src
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dst_name
argument_list|,
name|dst_side
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dst_name
argument_list|,
name|src
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|pat
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_name
operator|=
name|xstrdup
argument_list|(
name|src
operator|->
name|name
argument_list|)
expr_stmt|;
name|dst_peer
operator|=
name|find_ref_by_name
argument_list|(
name|dst
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_peer
operator|&&
name|dst_peer
operator|->
name|peer_ref
condition|)
comment|/* We're already sending something to this ref. */
goto|goto
name|free_name
goto|;
if|if
condition|(
operator|!
name|dst_peer
operator|&&
operator|!
name|nr_refspec
operator|&&
operator|!
name|all
condition|)
comment|/* Remote doesn't have it, and we have no 			 * explicit pattern, and we don't have 			 * --all. */
goto|goto
name|free_name
goto|;
if|if
condition|(
operator|!
name|dst_peer
condition|)
block|{
comment|/* Create a new one and link it */
name|dst_peer
operator|=
name|make_linked_ref
argument_list|(
name|dst_name
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_peer
operator|->
name|new_sha1
argument_list|,
name|src
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
block|}
name|dst_peer
operator|->
name|peer_ref
operator|=
name|src
expr_stmt|;
name|free_name
label|:
name|free
argument_list|(
name|dst_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|branch_get
name|struct
name|branch
modifier|*
name|branch_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|ret
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|ret
operator|=
name|current_branch
expr_stmt|;
else|else
name|ret
operator|=
name|make_branch
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|ret
operator|->
name|remote_name
condition|)
block|{
name|ret
operator|->
name|remote
operator|=
name|remote_get
argument_list|(
name|ret
operator|->
name|remote_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|merge_nr
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ret
operator|->
name|merge
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
operator|->
name|merge
argument_list|)
argument_list|,
name|ret
operator|->
name|merge_nr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ret
operator|->
name|merge_nr
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|->
name|merge
index|[
name|i
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|ret
operator|->
name|merge
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
operator|=
name|xstrdup
argument_list|(
name|ret
operator|->
name|merge_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|remote_find_tracking
argument_list|(
name|ret
operator|->
name|remote
argument_list|,
name|ret
operator|->
name|merge
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|branch_has_merge_config
name|int
name|branch_has_merge_config
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|)
block|{
return|return
name|branch
operator|&&
operator|!
operator|!
name|branch
operator|->
name|merge
return|;
block|}
end_function
begin_function
DECL|function|branch_merge_matches
name|int
name|branch_merge_matches
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|branch
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|branch
operator|->
name|merge_nr
condition|)
return|return
literal|0
return|;
return|return
name|ref_matches_abbrev
argument_list|(
name|branch
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
argument_list|,
name|refname
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_expanded_map
specifier|static
name|struct
name|ref
modifier|*
name|get_expanded_map
parameter_list|(
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|ref
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ret
decl_stmt|;
name|int
name|remote_prefix_len
init|=
name|strlen
argument_list|(
name|refspec
operator|->
name|src
argument_list|)
decl_stmt|;
name|int
name|local_prefix_len
init|=
name|strlen
argument_list|(
name|refspec
operator|->
name|dst
argument_list|)
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
continue|continue;
comment|/* a dereference item */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|refspec
operator|->
name|src
argument_list|)
condition|)
block|{
name|char
modifier|*
name|match
decl_stmt|;
name|struct
name|ref
modifier|*
name|cpy
init|=
name|copy_ref
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|match
operator|=
name|ref
operator|->
name|name
operator|+
name|remote_prefix_len
expr_stmt|;
name|cpy
operator|->
name|peer_ref
operator|=
name|alloc_ref
argument_list|(
name|local_prefix_len
operator|+
name|strlen
argument_list|(
name|match
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cpy
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|refspec
operator|->
name|dst
argument_list|,
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|refspec
operator|->
name|force
condition|)
name|cpy
operator|->
name|peer_ref
operator|->
name|force
operator|=
literal|1
expr_stmt|;
operator|*
name|tail
operator|=
name|cpy
expr_stmt|;
name|tail
operator|=
operator|&
name|cpy
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|find_ref_by_name_abbrev
specifier|static
name|struct
name|ref
modifier|*
name|find_ref_by_name_abbrev
parameter_list|(
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ref_matches_abbrev
argument_list|(
name|name
argument_list|,
name|ref
operator|->
name|name
argument_list|)
condition|)
return|return
name|ref
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|get_remote_ref
name|struct
name|ref
modifier|*
name|get_remote_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|find_ref_by_name_abbrev
argument_list|(
name|remote_refs
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
name|die
argument_list|(
literal|"Couldn't find remote ref %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|copy_ref
argument_list|(
name|ref
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_local_ref
specifier|static
name|struct
name|ref
modifier|*
name|get_local_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|)
condition|)
block|{
name|ret
operator|=
name|alloc_ref
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"remotes/"
argument_list|)
condition|)
block|{
name|ret
operator|=
name|alloc_ref
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ret
operator|->
name|name
argument_list|,
literal|"refs/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|alloc_ref
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ret
operator|->
name|name
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|get_fetch_map
name|int
name|get_fetch_map
parameter_list|(
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref_map
decl_stmt|,
modifier|*
name|rm
decl_stmt|;
if|if
condition|(
name|refspec
operator|->
name|pattern
condition|)
block|{
name|ref_map
operator|=
name|get_expanded_map
argument_list|(
name|remote_refs
argument_list|,
name|refspec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref_map
operator|=
name|get_remote_ref
argument_list|(
name|remote_refs
argument_list|,
name|refspec
operator|->
name|src
index|[
literal|0
index|]
condition|?
name|refspec
operator|->
name|src
else|:
literal|"HEAD"
argument_list|)
expr_stmt|;
name|ref_map
operator|->
name|peer_ref
operator|=
name|get_local_ref
argument_list|(
name|refspec
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_map
operator|->
name|peer_ref
operator|&&
name|refspec
operator|->
name|force
condition|)
name|ref_map
operator|->
name|peer_ref
operator|->
name|force
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|rm
operator|=
name|ref_map
init|;
name|rm
condition|;
name|rm
operator|=
name|rm
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rm
operator|->
name|peer_ref
operator|&&
name|check_ref_format
argument_list|(
name|rm
operator|->
name|peer_ref
operator|->
name|name
operator|+
literal|5
argument_list|)
condition|)
name|die
argument_list|(
literal|"* refusing to create funny ref '%s' locally"
argument_list|,
name|rm
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|tail_link_ref
argument_list|(
name|ref_map
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
