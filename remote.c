begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_decl_stmt
DECL|variable|s_tag_refspec
specifier|static
name|struct
name|refspec
name|s_tag_refspec
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"refs/tags/"
block|,
literal|"refs/tags/"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tag_refspec
specifier|const
name|struct
name|refspec
modifier|*
name|tag_refspec
init|=
operator|&
name|s_tag_refspec
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|counted_string
struct|struct
name|counted_string
block|{
DECL|member|len
name|size_t
name|len
decl_stmt|;
DECL|member|s
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|rewrite
struct|struct
name|rewrite
block|{
DECL|member|base
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
DECL|member|baselen
name|size_t
name|baselen
decl_stmt|;
DECL|member|instead_of
name|struct
name|counted_string
modifier|*
name|instead_of
decl_stmt|;
DECL|member|instead_of_nr
name|int
name|instead_of_nr
decl_stmt|;
DECL|member|instead_of_alloc
name|int
name|instead_of_alloc
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|remotes
specifier|static
name|struct
name|remote
modifier|*
modifier|*
name|remotes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remotes_alloc
specifier|static
name|int
name|remotes_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remotes_nr
specifier|static
name|int
name|remotes_nr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branches
specifier|static
name|struct
name|branch
modifier|*
modifier|*
name|branches
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branches_alloc
specifier|static
name|int
name|branches_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branches_nr
specifier|static
name|int
name|branches_nr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_branch
specifier|static
name|struct
name|branch
modifier|*
name|current_branch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_remote_name
specifier|static
specifier|const
name|char
modifier|*
name|default_remote_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rewrite
specifier|static
name|struct
name|rewrite
modifier|*
modifier|*
name|rewrite
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rewrite_alloc
specifier|static
name|int
name|rewrite_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rewrite_nr
specifier|static
name|int
name|rewrite_nr
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|BUF_SIZE
define|#
directive|define
name|BUF_SIZE
value|(2048)
end_define
begin_decl_stmt
DECL|variable|buffer
specifier|static
name|char
name|buffer
index|[
name|BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|alias_url
specifier|static
specifier|const
name|char
modifier|*
name|alias_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|struct
name|counted_string
modifier|*
name|longest
decl_stmt|;
name|int
name|longest_i
decl_stmt|;
name|longest
operator|=
name|NULL
expr_stmt|;
name|longest_i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rewrite_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|rewrite
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of_nr
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|url
argument_list|,
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of
index|[
name|j
index|]
operator|.
name|s
argument_list|)
operator|&&
operator|(
operator|!
name|longest
operator|||
name|longest
operator|->
name|len
operator|<
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of
index|[
name|j
index|]
operator|.
name|len
operator|)
condition|)
block|{
name|longest
operator|=
operator|&
operator|(
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of
index|[
name|j
index|]
operator|)
expr_stmt|;
name|longest_i
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|longest
condition|)
return|return
name|url
return|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|rewrite
index|[
name|longest_i
index|]
operator|->
name|baselen
operator|+
operator|(
name|strlen
argument_list|(
name|url
argument_list|)
operator|-
name|longest
operator|->
name|len
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|rewrite
index|[
name|longest_i
index|]
operator|->
name|base
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|+
name|rewrite
index|[
name|longest_i
index|]
operator|->
name|baselen
argument_list|,
name|url
operator|+
name|longest
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|add_push_refspec
specifier|static
name|void
name|add_push_refspec
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|remote
operator|->
name|push_refspec
argument_list|,
name|remote
operator|->
name|push_refspec_nr
operator|+
literal|1
argument_list|,
name|remote
operator|->
name|push_refspec_alloc
argument_list|)
expr_stmt|;
name|remote
operator|->
name|push_refspec
index|[
name|remote
operator|->
name|push_refspec_nr
operator|++
index|]
operator|=
name|ref
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_fetch_refspec
specifier|static
name|void
name|add_fetch_refspec
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|remote
operator|->
name|fetch_refspec
argument_list|,
name|remote
operator|->
name|fetch_refspec_nr
operator|+
literal|1
argument_list|,
name|remote
operator|->
name|fetch_refspec_alloc
argument_list|)
expr_stmt|;
name|remote
operator|->
name|fetch_refspec
index|[
name|remote
operator|->
name|fetch_refspec_nr
operator|++
index|]
operator|=
name|ref
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_url
specifier|static
name|void
name|add_url
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|remote
operator|->
name|url
argument_list|,
name|remote
operator|->
name|url_nr
operator|+
literal|1
argument_list|,
name|remote
operator|->
name|url_alloc
argument_list|)
expr_stmt|;
name|remote
operator|->
name|url
index|[
name|remote
operator|->
name|url_nr
operator|++
index|]
operator|=
name|url
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_url_alias
specifier|static
name|void
name|add_url_alias
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|add_url
argument_list|(
name|remote
argument_list|,
name|alias_url
argument_list|(
name|url
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_remote
specifier|static
name|struct
name|remote
modifier|*
name|make_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|remote
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remotes_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|len
condition|?
operator|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|remotes
index|[
name|i
index|]
operator|->
name|name
index|[
name|len
index|]
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|remotes
index|[
name|i
index|]
return|;
block|}
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|remotes
argument_list|,
name|remotes_nr
operator|+
literal|1
argument_list|,
name|remotes_alloc
argument_list|)
expr_stmt|;
name|remotes
index|[
name|remotes_nr
operator|++
index|]
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|ret
operator|->
name|name
operator|=
name|xstrndup
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|ret
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|add_merge
specifier|static
name|void
name|add_merge
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|branch
operator|->
name|merge_name
argument_list|,
name|branch
operator|->
name|merge_nr
operator|+
literal|1
argument_list|,
name|branch
operator|->
name|merge_alloc
argument_list|)
expr_stmt|;
name|branch
operator|->
name|merge_name
index|[
name|branch
operator|->
name|merge_nr
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_branch
specifier|static
name|struct
name|branch
modifier|*
name|make_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|refname
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|branches_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|len
condition|?
operator|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|branches
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|branches
index|[
name|i
index|]
operator|->
name|name
index|[
name|len
index|]
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|branches
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|branches
index|[
name|i
index|]
return|;
block|}
name|ALLOC_GROW
argument_list|(
name|branches
argument_list|,
name|branches_nr
operator|+
literal|1
argument_list|,
name|branches_alloc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|branch
argument_list|)
argument_list|)
expr_stmt|;
name|branches
index|[
name|branches_nr
operator|++
index|]
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|ret
operator|->
name|name
operator|=
name|xstrndup
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|ret
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|refname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|refname
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
argument_list|,
name|ret
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|refname
operator|=
name|refname
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|make_rewrite
specifier|static
name|struct
name|rewrite
modifier|*
name|make_rewrite
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|rewrite
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rewrite_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|len
condition|?
operator|(
name|len
operator|==
name|rewrite
index|[
name|i
index|]
operator|->
name|baselen
operator|&&
operator|!
name|strncmp
argument_list|(
name|base
argument_list|,
name|rewrite
index|[
name|i
index|]
operator|->
name|base
argument_list|,
name|len
argument_list|)
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|base
argument_list|,
name|rewrite
index|[
name|i
index|]
operator|->
name|base
argument_list|)
condition|)
return|return
name|rewrite
index|[
name|i
index|]
return|;
block|}
name|ALLOC_GROW
argument_list|(
name|rewrite
argument_list|,
name|rewrite_nr
operator|+
literal|1
argument_list|,
name|rewrite_alloc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rewrite
argument_list|)
argument_list|)
expr_stmt|;
name|rewrite
index|[
name|rewrite_nr
operator|++
index|]
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|ret
operator|->
name|base
operator|=
name|xstrndup
argument_list|(
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|->
name|baselen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|->
name|base
operator|=
name|xstrdup
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|ret
operator|->
name|baselen
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|add_instead_of
specifier|static
name|void
name|add_instead_of
parameter_list|(
name|struct
name|rewrite
modifier|*
name|rewrite
parameter_list|,
specifier|const
name|char
modifier|*
name|instead_of
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|rewrite
operator|->
name|instead_of
argument_list|,
name|rewrite
operator|->
name|instead_of_nr
operator|+
literal|1
argument_list|,
name|rewrite
operator|->
name|instead_of_alloc
argument_list|)
expr_stmt|;
name|rewrite
operator|->
name|instead_of
index|[
name|rewrite
operator|->
name|instead_of_nr
index|]
operator|.
name|s
operator|=
name|instead_of
expr_stmt|;
name|rewrite
operator|->
name|instead_of
index|[
name|rewrite
operator|->
name|instead_of_nr
index|]
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|instead_of
argument_list|)
expr_stmt|;
name|rewrite
operator|->
name|instead_of_nr
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_remotes_file
specifier|static
name|void
name|read_remotes_file
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"remotes/%s"
argument_list|,
name|remote
operator|->
name|name
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|remote
operator|->
name|origin
operator|=
name|REMOTE_REMOTES
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|int
name|value_list
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"URL:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"Push:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"Pull:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|5
expr_stmt|;
block|}
else|else
continue|continue;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
continue|continue;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|value_list
condition|)
block|{
case|case
literal|0
case|:
name|add_url_alias
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_branches_file
specifier|static
name|void
name|read_branches_file
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|slash
init|=
name|strchr
argument_list|(
name|remote
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|frag
decl_stmt|;
name|struct
name|strbuf
name|branch
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|n
init|=
name|slash
condition|?
name|slash
operator|-
name|remote
operator|->
name|name
else|:
literal|1000
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"branches/%.*s"
argument_list|,
name|n
argument_list|,
name|remote
operator|->
name|name
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|s
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return;
name|remote
operator|->
name|origin
operator|=
name|REMOTE_BRANCHES
expr_stmt|;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|slash
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|strcat
argument_list|(
name|p
argument_list|,
name|slash
argument_list|)
expr_stmt|;
comment|/* 	 * With "slash", e.g. "git fetch jgarzik/netdev-2.6" when 	 * reading from $GIT_DIR/branches/jgarzik fetches "HEAD" from 	 * the partial URL obtained from the branches file plus 	 * "/netdev-2.6" and does not store it in any tracking ref. 	 * #branch specifier in the file is ignored. 	 * 	 * Otherwise, the branches file would have URL and optionally 	 * #branch specified.  The "master" (or specified) branch is 	 * fetched and stored in the local branch of the same name. 	 */
name|frag
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
condition|)
block|{
operator|*
operator|(
name|frag
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|branch
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|branch
argument_list|,
literal|"refs/heads/master"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slash
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|branch
argument_list|,
literal|":refs/heads/%s"
argument_list|,
name|remote
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_reset
argument_list|(
operator|&
name|branch
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|branch
argument_list|,
literal|"HEAD:"
argument_list|)
expr_stmt|;
block|}
name|add_url_alias
argument_list|(
name|remote
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|branch
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Cogito compatible push: push current HEAD to remote #branch 	 * (master if missing) 	 */
name|strbuf_init
argument_list|(
operator|&
name|branch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|branch
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|branch
argument_list|,
literal|":refs/heads/%s"
argument_list|,
name|frag
argument_list|)
expr_stmt|;
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|branch
argument_list|,
literal|":refs/heads/master"
argument_list|)
expr_stmt|;
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|branch
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|->
name|fetch_tags
operator|=
literal|1
expr_stmt|;
comment|/* always auto-follow */
block|}
end_function
begin_function
DECL|function|handle_config
specifier|static
name|int
name|handle_config
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|subkey
decl_stmt|;
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"branch."
argument_list|)
condition|)
block|{
name|name
operator|=
name|key
operator|+
literal|7
expr_stmt|;
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
literal|0
return|;
name|branch
operator|=
name|make_branch
argument_list|(
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".remote"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|key
argument_list|)
return|;
name|branch
operator|->
name|remote_name
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|==
name|current_branch
condition|)
name|default_remote_name
operator|=
name|branch
operator|->
name|remote_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".merge"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|key
argument_list|)
return|;
name|add_merge
argument_list|(
name|branch
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"url."
argument_list|)
condition|)
block|{
name|struct
name|rewrite
modifier|*
name|rewrite
decl_stmt|;
name|name
operator|=
name|key
operator|+
literal|4
expr_stmt|;
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
literal|0
return|;
name|rewrite
operator|=
name|make_rewrite
argument_list|(
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".insteadof"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|key
argument_list|)
return|;
name|add_instead_of
argument_list|(
name|rewrite
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"remote."
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|key
operator|+
literal|7
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
condition|)
block|{
name|warning
argument_list|(
literal|"Config remote shorthand cannot begin with '/': %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
name|error
argument_list|(
literal|"Config with no key for remote %s"
argument_list|,
name|name
argument_list|)
return|;
name|remote
operator|=
name|make_remote
argument_list|(
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
name|remote
operator|->
name|origin
operator|=
name|REMOTE_CONFIG
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".mirror"
argument_list|)
condition|)
name|remote
operator|->
name|mirror
operator|=
name|git_config_bool
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".skipdefaultupdate"
argument_list|)
condition|)
name|remote
operator|->
name|skip_default_update
operator|=
name|git_config_bool
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".url"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|add_url
argument_list|(
name|remote
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".push"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".fetch"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".receivepack"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|remote
operator|->
name|receivepack
condition|)
name|remote
operator|->
name|receivepack
operator|=
name|v
expr_stmt|;
else|else
name|error
argument_list|(
literal|"more than one receivepack given, using the first"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".uploadpack"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|remote
operator|->
name|uploadpack
condition|)
name|remote
operator|->
name|uploadpack
operator|=
name|v
expr_stmt|;
else|else
name|error
argument_list|(
literal|"more than one uploadpack given, using the first"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".tagopt"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"--no-tags"
argument_list|)
condition|)
name|remote
operator|->
name|fetch_tags
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".proxy"
argument_list|)
condition|)
block|{
return|return
name|git_config_string
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|remote
operator|->
name|http_proxy
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|alias_all_urls
specifier|static
name|void
name|alias_all_urls
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remotes_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|remotes
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|remotes
index|[
name|i
index|]
operator|->
name|url_nr
condition|;
name|j
operator|++
control|)
block|{
name|remotes
index|[
name|i
index|]
operator|->
name|url
index|[
name|j
index|]
operator|=
name|alias_url
argument_list|(
name|remotes
index|[
name|i
index|]
operator|->
name|url
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|read_config
specifier|static
name|void
name|read_config
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|head_ref
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|if
condition|(
name|default_remote_name
condition|)
comment|// did this already
return|return;
name|default_remote_name
operator|=
name|xstrdup
argument_list|(
literal|"origin"
argument_list|)
expr_stmt|;
name|current_branch
operator|=
name|NULL
expr_stmt|;
name|head_ref
operator|=
name|resolve_ref
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_ref
operator|&&
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|head_ref
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
block|{
name|current_branch
operator|=
name|make_branch
argument_list|(
name|head_ref
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|git_config
argument_list|(
name|handle_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alias_all_urls
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * We need to make sure the tracking branches are well formed, but a  * wildcard refspec in "struct refspec" must have a trailing slash. We  * temporarily drop the trailing '/' while calling check_ref_format(),  * and put it back.  The caller knows that a CHECK_REF_FORMAT_ONELEVEL  * error return is Ok for a wildcard refspec.  */
end_comment
begin_function
DECL|function|verify_refname
specifier|static
name|int
name|verify_refname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|is_glob
parameter_list|)
block|{
name|int
name|result
decl_stmt|,
name|len
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|is_glob
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|result
operator|=
name|check_ref_format
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_glob
condition|)
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*  * This function frees a refspec array.  * Warning: code paths should be checked to ensure that the src  *          and dst pointers are always freeable pointers as well  *          as the refspec pointer itself.  */
end_comment
begin_function
DECL|function|free_refspecs
specifier|static
name|void
name|free_refspecs
parameter_list|(
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|,
name|int
name|nr_refspec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|refspec
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|refspec
index|[
name|i
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refspec
index|[
name|i
index|]
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|refspec
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_refspec_internal
specifier|static
name|struct
name|refspec
modifier|*
name|parse_refspec_internal
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|,
name|int
name|fetch
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|st
decl_stmt|;
name|struct
name|refspec
modifier|*
name|rs
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|,
name|nr_refspec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|llen
decl_stmt|;
name|int
name|is_glob
decl_stmt|;
specifier|const
name|char
modifier|*
name|lhs
decl_stmt|,
modifier|*
name|rhs
decl_stmt|;
name|llen
operator|=
name|is_glob
operator|=
literal|0
expr_stmt|;
name|lhs
operator|=
name|refspec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|lhs
operator|==
literal|'+'
condition|)
block|{
name|rs
index|[
name|i
index|]
operator|.
name|force
operator|=
literal|1
expr_stmt|;
name|lhs
operator|++
expr_stmt|;
block|}
name|rhs
operator|=
name|strrchr
argument_list|(
name|lhs
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* 		 * Before going on, special case ":" (or "+:") as a refspec 		 * for matching refs. 		 */
if|if
condition|(
operator|!
name|fetch
operator|&&
name|rhs
operator|==
name|lhs
operator|&&
name|rhs
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|rs
index|[
name|i
index|]
operator|.
name|matching
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rhs
condition|)
block|{
name|size_t
name|rlen
init|=
name|strlen
argument_list|(
operator|++
name|rhs
argument_list|)
decl_stmt|;
name|is_glob
operator|=
operator|(
literal|2
operator|<=
name|rlen
operator|&&
operator|!
name|strcmp
argument_list|(
name|rhs
operator|+
name|rlen
operator|-
literal|2
argument_list|,
literal|"/*"
argument_list|)
operator|)
expr_stmt|;
name|rs
index|[
name|i
index|]
operator|.
name|dst
operator|=
name|xstrndup
argument_list|(
name|rhs
argument_list|,
name|rlen
operator|-
name|is_glob
argument_list|)
expr_stmt|;
block|}
name|llen
operator|=
operator|(
name|rhs
condition|?
operator|(
name|rhs
operator|-
name|lhs
operator|-
literal|1
operator|)
else|:
name|strlen
argument_list|(
name|lhs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
literal|2
operator|<=
name|llen
operator|&&
operator|!
name|memcmp
argument_list|(
name|lhs
operator|+
name|llen
operator|-
literal|2
argument_list|,
literal|"/*"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|rhs
operator|&&
operator|!
name|is_glob
operator|)
operator|||
operator|(
operator|!
name|rhs
operator|&&
name|fetch
operator|)
condition|)
goto|goto
name|invalid
goto|;
name|is_glob
operator|=
literal|1
expr_stmt|;
name|llen
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|&&
name|is_glob
condition|)
block|{
goto|goto
name|invalid
goto|;
block|}
name|rs
index|[
name|i
index|]
operator|.
name|pattern
operator|=
name|is_glob
expr_stmt|;
name|rs
index|[
name|i
index|]
operator|.
name|src
operator|=
name|xstrndup
argument_list|(
name|lhs
argument_list|,
name|llen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch
condition|)
block|{
comment|/* 			 * LHS 			 * - empty is allowed; it means HEAD. 			 * - otherwise it must be a valid looking ref. 			 */
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|src
condition|)
empty_stmt|;
comment|/* empty is ok */
else|else
block|{
name|st
operator|=
name|verify_refname
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|is_glob
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|&&
name|st
operator|!=
name|CHECK_REF_FORMAT_ONELEVEL
condition|)
goto|goto
name|invalid
goto|;
block|}
comment|/* 			 * RHS 			 * - missing is ok, and is same as empty. 			 * - empty is ok; it means not to store. 			 * - otherwise it must be a valid looking ref. 			 */
if|if
condition|(
operator|!
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
block|{
empty_stmt|;
comment|/* ok */
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
block|{
empty_stmt|;
comment|/* ok */
block|}
else|else
block|{
name|st
operator|=
name|verify_refname
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|,
name|is_glob
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|&&
name|st
operator|!=
name|CHECK_REF_FORMAT_ONELEVEL
condition|)
goto|goto
name|invalid
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * LHS 			 * - empty is allowed; it means delete. 			 * - when wildcarded, it must be a valid looking ref. 			 * - otherwise, it must be an extended SHA-1, but 			 *   there is no existing way to validate this. 			 */
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|src
condition|)
empty_stmt|;
comment|/* empty is ok */
elseif|else
if|if
condition|(
name|is_glob
condition|)
block|{
name|st
operator|=
name|verify_refname
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|is_glob
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|&&
name|st
operator|!=
name|CHECK_REF_FORMAT_ONELEVEL
condition|)
goto|goto
name|invalid
goto|;
block|}
else|else
empty_stmt|;
comment|/* anything goes, for now */
comment|/* 			 * RHS 			 * - missing is allowed, but LHS then must be a 			 *   valid looking ref. 			 * - empty is not allowed. 			 * - otherwise it must be a valid looking ref. 			 */
if|if
condition|(
operator|!
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
block|{
name|st
operator|=
name|verify_refname
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|is_glob
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|&&
name|st
operator|!=
name|CHECK_REF_FORMAT_ONELEVEL
condition|)
goto|goto
name|invalid
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
block|{
goto|goto
name|invalid
goto|;
block|}
else|else
block|{
name|st
operator|=
name|verify_refname
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|,
name|is_glob
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|&&
name|st
operator|!=
name|CHECK_REF_FORMAT_ONELEVEL
condition|)
goto|goto
name|invalid
goto|;
block|}
block|}
block|}
return|return
name|rs
return|;
name|invalid
label|:
if|if
condition|(
name|verify
condition|)
block|{
comment|/* 		 * nr_refspec must be greater than zero and i must be valid 		 * since it is only possible to reach this point from within 		 * the for loop above. 		 */
name|free_refspecs
argument_list|(
name|rs
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|die
argument_list|(
literal|"Invalid refspec '%s'"
argument_list|,
name|refspec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|valid_fetch_refspec
name|int
name|valid_fetch_refspec
parameter_list|(
specifier|const
name|char
modifier|*
name|fetch_refspec_str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fetch_refspec
index|[]
init|=
block|{
name|fetch_refspec_str
block|}
decl_stmt|;
name|struct
name|refspec
modifier|*
name|refspec
decl_stmt|;
name|refspec
operator|=
name|parse_refspec_internal
argument_list|(
literal|1
argument_list|,
name|fetch_refspec
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_refspecs
argument_list|(
name|refspec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|refspec
return|;
block|}
end_function
begin_function
DECL|function|parse_fetch_refspec
name|struct
name|refspec
modifier|*
name|parse_fetch_refspec
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|)
block|{
return|return
name|parse_refspec_internal
argument_list|(
name|nr_refspec
argument_list|,
name|refspec
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_push_refspec
specifier|static
name|struct
name|refspec
modifier|*
name|parse_push_refspec
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|)
block|{
return|return
name|parse_refspec_internal
argument_list|(
name|nr_refspec
argument_list|,
name|refspec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|valid_remote_nick
specifier|static
name|int
name|valid_remote_nick
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
index|[
literal|0
index|]
operator|||
name|is_dot_or_dotdot
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
return|;
comment|/* no slash */
block|}
end_function
begin_function
DECL|function|remote_get
name|struct
name|remote
modifier|*
name|remote_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|remote
modifier|*
name|ret
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
name|default_remote_name
expr_stmt|;
name|ret
operator|=
name|make_remote
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_remote_nick
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
name|read_remotes_file
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
name|read_branches_file
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
name|add_url_alias
argument_list|(
name|ret
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|->
name|url
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|fetch
operator|=
name|parse_fetch_refspec
argument_list|(
name|ret
operator|->
name|fetch_refspec_nr
argument_list|,
name|ret
operator|->
name|fetch_refspec
argument_list|)
expr_stmt|;
name|ret
operator|->
name|push
operator|=
name|parse_push_refspec
argument_list|(
name|ret
operator|->
name|push_refspec_nr
argument_list|,
name|ret
operator|->
name|push_refspec
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|for_each_remote
name|int
name|for_each_remote
parameter_list|(
name|each_remote_fn
name|fn
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remotes_nr
operator|&&
operator|!
name|result
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|remote
modifier|*
name|r
init|=
name|remotes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
continue|continue;
if|if
condition|(
operator|!
name|r
operator|->
name|fetch
condition|)
name|r
operator|->
name|fetch
operator|=
name|parse_fetch_refspec
argument_list|(
name|r
operator|->
name|fetch_refspec_nr
argument_list|,
name|r
operator|->
name|fetch_refspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|push
condition|)
name|r
operator|->
name|push
operator|=
name|parse_push_refspec
argument_list|(
name|r
operator|->
name|push_refspec_nr
argument_list|,
name|r
operator|->
name|push_refspec
argument_list|)
expr_stmt|;
name|result
operator|=
name|fn
argument_list|(
name|r
argument_list|,
name|priv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|ref_remove_duplicates
name|void
name|ref_remove_duplicates
parameter_list|(
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|posn
decl_stmt|;
name|struct
name|ref
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|ref_map
condition|;
name|ref_map
operator|=
name|ref_map
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ref_map
operator|->
name|peer_ref
condition|)
continue|continue;
name|posn
operator|=
operator|&
name|ref_map
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|*
name|posn
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|peer_ref
operator|&&
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|name
argument_list|)
condition|)
name|die
argument_list|(
literal|"%s tracks both %s and %s"
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
operator|(
operator|*
name|posn
operator|)
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|name
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
operator|*
name|posn
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
operator|*
name|posn
operator|)
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|posn
argument_list|)
expr_stmt|;
operator|*
name|posn
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|posn
operator|=
operator|&
operator|(
operator|*
name|posn
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|remote_has_url
name|int
name|remote_has_url
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remote
operator|->
name|url_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|remote
operator|->
name|url
index|[
name|i
index|]
argument_list|,
name|url
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|remote_find_tracking
name|int
name|remote_find_tracking
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
name|int
name|find_src
init|=
name|refspec
operator|->
name|src
operator|==
name|NULL
decl_stmt|;
name|char
modifier|*
name|needle
decl_stmt|,
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|find_src
condition|)
block|{
if|if
condition|(
operator|!
name|refspec
operator|->
name|dst
condition|)
return|return
name|error
argument_list|(
literal|"find_tracking: need either src or dst"
argument_list|)
return|;
name|needle
operator|=
name|refspec
operator|->
name|dst
expr_stmt|;
name|result
operator|=
operator|&
name|refspec
operator|->
name|src
expr_stmt|;
block|}
else|else
block|{
name|needle
operator|=
name|refspec
operator|->
name|src
expr_stmt|;
name|result
operator|=
operator|&
name|refspec
operator|->
name|dst
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remote
operator|->
name|fetch_refspec_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|refspec
modifier|*
name|fetch
init|=
operator|&
name|remote
operator|->
name|fetch
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|find_src
condition|?
name|fetch
operator|->
name|dst
else|:
name|fetch
operator|->
name|src
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
init|=
name|find_src
condition|?
name|fetch
operator|->
name|src
else|:
name|fetch
operator|->
name|dst
decl_stmt|;
if|if
condition|(
operator|!
name|fetch
operator|->
name|dst
condition|)
continue|continue;
if|if
condition|(
name|fetch
operator|->
name|pattern
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|needle
argument_list|,
name|key
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|strlen
argument_list|(
name|needle
argument_list|)
operator|-
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|result
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|result
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|needle
operator|+
name|strlen
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|refspec
operator|->
name|force
operator|=
name|fetch
operator|->
name|force
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|needle
argument_list|,
name|key
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|refspec
operator|->
name|force
operator|=
name|fetch
operator|->
name|force
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|alloc_ref_with_prefix
specifier|static
name|struct
name|ref
modifier|*
name|alloc_ref_with_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|size_t
name|prefixlen
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|prefixlen
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|prefix
argument_list|,
name|prefixlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
operator|+
name|prefixlen
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|alloc_ref
name|struct
name|ref
modifier|*
name|alloc_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|alloc_ref_with_prefix
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|copy_ref
specifier|static
name|struct
name|ref
modifier|*
name|copy_ref
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|strlen
argument_list|(
name|ref
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ref
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|strlen
argument_list|(
name|ref
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|copy_ref_list
name|struct
name|ref
modifier|*
name|copy_ref_list
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ret
decl_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
operator|*
name|tail
operator|=
name|copy_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|tail
operator|=
operator|&
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|free_ref
specifier|static
name|void
name|free_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ref
condition|)
return|return;
name|free
argument_list|(
name|ref
operator|->
name|remote_status
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
operator|->
name|symref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_refs
name|void
name|free_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|next
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ref
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|count_refspec_match
specifier|static
name|int
name|count_refspec_match
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|matched_ref
parameter_list|)
block|{
name|int
name|patlen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched_weak
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched
init|=
name|NULL
decl_stmt|;
name|int
name|weak_match
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
for|for
control|(
name|weak_match
operator|=
name|match
operator|=
literal|0
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|refs
operator|->
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|refname_match
argument_list|(
name|pattern
argument_list|,
name|name
argument_list|,
name|ref_rev_parse_rules
argument_list|)
condition|)
continue|continue;
comment|/* A match is "weak" if it is with refs outside 		 * heads or tags, and did not specify the pattern 		 * in full (e.g. "refs/remotes/origin/master") or at 		 * least from the toplevel (e.g. "remotes/origin/master"); 		 * otherwise "git push $URL master" would result in 		 * ambiguity between remotes/origin/master and heads/master 		 * at the remote site. 		 */
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|patlen
operator|!=
name|namelen
operator|-
literal|5
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
comment|/* We want to catch the case where only weak 			 * matches are found and there are multiple 			 * matches, and where more than one strong 			 * matches are found, as ambiguous.  One 			 * strong match with zero or more weak matches 			 * are acceptable as a unique match. 			 */
name|matched_weak
operator|=
name|refs
expr_stmt|;
name|weak_match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|matched
operator|=
name|refs
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
operator|*
name|matched_ref
operator|=
name|matched_weak
expr_stmt|;
return|return
name|weak_match
return|;
block|}
else|else
block|{
operator|*
name|matched_ref
operator|=
name|matched
expr_stmt|;
return|return
name|match
return|;
block|}
block|}
end_function
begin_function
DECL|function|tail_link_ref
specifier|static
name|void
name|tail_link_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
operator|*
operator|*
name|tail
operator|=
name|ref
expr_stmt|;
while|while
condition|(
name|ref
operator|->
name|next
condition|)
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_function
DECL|function|try_explicit_object_name
specifier|static
name|struct
name|ref
modifier|*
name|try_explicit_object_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
block|{
name|ref
operator|=
name|alloc_ref
argument_list|(
literal|"(delete)"
argument_list|)
expr_stmt|;
name|hashclr
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|make_linked_ref
specifier|static
name|struct
name|ref
modifier|*
name|make_linked_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
init|=
name|alloc_ref
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tail_link_ref
argument_list|(
name|ret
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|guess_ref
specifier|static
name|char
modifier|*
name|guess_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ref
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
init|=
name|resolve_ref
argument_list|(
name|peer
operator|->
name|name
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|r
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|r
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"refs/tags/"
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|match_explicit
specifier|static
name|int
name|match_explicit
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|struct
name|refspec
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|matched_src
decl_stmt|,
modifier|*
name|matched_dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_value
init|=
name|rs
operator|->
name|dst
decl_stmt|;
name|char
modifier|*
name|dst_guess
decl_stmt|;
if|if
condition|(
name|rs
operator|->
name|pattern
operator|||
name|rs
operator|->
name|matching
condition|)
return|return
literal|0
return|;
name|matched_src
operator|=
name|matched_dst
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|rs
operator|->
name|src
argument_list|,
name|src
argument_list|,
operator|&
name|matched_src
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
comment|/* The source could be in the get_sha1() format 		 * not a reference name.  :refs/other is a 		 * way to delete 'other' ref at the remote end. 		 */
name|matched_src
operator|=
name|try_explicit_object_name
argument_list|(
name|rs
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matched_src
condition|)
return|return
name|error
argument_list|(
literal|"src refspec %s does not match any."
argument_list|,
name|rs
operator|->
name|src
argument_list|)
return|;
break|break;
default|default:
return|return
name|error
argument_list|(
literal|"src refspec %s matches more than one."
argument_list|,
name|rs
operator|->
name|src
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|dst_value
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|dst_value
operator|=
name|resolve_ref
argument_list|(
name|matched_src
operator|->
name|name
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst_value
operator|||
operator|(
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
name|prefixcmp
argument_list|(
name|dst_value
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"%s cannot be resolved to branch."
argument_list|,
name|matched_src
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|dst_value
argument_list|,
name|dst
argument_list|,
operator|&
name|matched_dst
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|dst_value
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
condition|)
name|matched_dst
operator|=
name|make_linked_ref
argument_list|(
name|dst_value
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dst_guess
operator|=
name|guess_ref
argument_list|(
name|dst_value
argument_list|,
name|matched_src
argument_list|)
operator|)
condition|)
name|matched_dst
operator|=
name|make_linked_ref
argument_list|(
name|dst_guess
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unable to push to unqualified destination: %s\n"
literal|"The destination refspec neither matches an "
literal|"existing ref on the remote nor\n"
literal|"begins with refs/, and we are unable to "
literal|"guess a prefix based on the source ref."
argument_list|,
name|dst_value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|matched_dst
operator|=
name|NULL
expr_stmt|;
name|error
argument_list|(
literal|"dst refspec %s matches more than one."
argument_list|,
name|dst_value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|matched_dst
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|matched_dst
operator|->
name|peer_ref
condition|)
return|return
name|error
argument_list|(
literal|"dst ref %s receives from more than one src."
argument_list|,
name|matched_dst
operator|->
name|name
argument_list|)
return|;
else|else
block|{
name|matched_dst
operator|->
name|peer_ref
operator|=
name|matched_src
expr_stmt|;
name|matched_dst
operator|->
name|force
operator|=
name|rs
operator|->
name|force
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|match_explicit_refs
specifier|static
name|int
name|match_explicit_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|struct
name|refspec
modifier|*
name|rs
parameter_list|,
name|int
name|rs_nr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|errs
decl_stmt|;
for|for
control|(
name|i
operator|=
name|errs
operator|=
literal|0
init|;
name|i
operator|<
name|rs_nr
condition|;
name|i
operator|++
control|)
name|errs
operator|+=
name|match_explicit
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|dst_tail
argument_list|,
operator|&
name|rs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|errs
return|;
block|}
end_function
begin_function
DECL|function|check_pattern_match
specifier|static
specifier|const
name|struct
name|refspec
modifier|*
name|check_pattern_match
parameter_list|(
specifier|const
name|struct
name|refspec
modifier|*
name|rs
parameter_list|,
name|int
name|rs_nr
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|matching_refs
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rs
index|[
name|i
index|]
operator|.
name|matching
operator|&&
operator|(
name|matching_refs
operator|==
operator|-
literal|1
operator|||
name|rs
index|[
name|i
index|]
operator|.
name|force
operator|)
condition|)
block|{
name|matching_refs
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rs
index|[
name|i
index|]
operator|.
name|pattern
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|src
operator|->
name|name
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|)
condition|)
return|return
name|rs
operator|+
name|i
return|;
block|}
if|if
condition|(
name|matching_refs
operator|!=
operator|-
literal|1
condition|)
return|return
name|rs
operator|+
name|matching_refs
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Note. This is used only by "push"; refspec matching rules for  * push and fetch are subtly different, so do not try to reuse it  * without thinking.  */
end_comment
begin_function
DECL|function|match_refs
name|int
name|match_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|refspec
modifier|*
name|rs
decl_stmt|;
name|int
name|send_all
init|=
name|flags
operator|&
name|MATCH_REFS_ALL
decl_stmt|;
name|int
name|send_mirror
init|=
name|flags
operator|&
name|MATCH_REFS_MIRROR
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|default_refspec
index|[]
init|=
block|{
literal|":"
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|nr_refspec
condition|)
block|{
name|nr_refspec
operator|=
literal|1
expr_stmt|;
name|refspec
operator|=
name|default_refspec
expr_stmt|;
block|}
name|rs
operator|=
name|parse_push_refspec
argument_list|(
name|nr_refspec
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|refspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_explicit_refs
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|dst_tail
argument_list|,
name|rs
argument_list|,
name|nr_refspec
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* pick the remainder */
for|for
control|(
init|;
name|src
condition|;
name|src
operator|=
name|src
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|dst_peer
decl_stmt|;
specifier|const
name|struct
name|refspec
modifier|*
name|pat
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|dst_name
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|peer_ref
condition|)
continue|continue;
name|pat
operator|=
name|check_pattern_match
argument_list|(
name|rs
argument_list|,
name|nr_refspec
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
continue|continue;
if|if
condition|(
name|pat
operator|->
name|matching
condition|)
block|{
comment|/* 			 * "matching refs"; traditionally we pushed everything 			 * including refs outside refs/heads/ hierarchy, but 			 * that does not make much sense these days. 			 */
if|if
condition|(
operator|!
name|send_mirror
operator|&&
name|prefixcmp
argument_list|(
name|src
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
continue|continue;
name|dst_name
operator|=
name|xstrdup
argument_list|(
name|src
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|dst_side
init|=
name|pat
operator|->
name|dst
condition|?
name|pat
operator|->
name|dst
else|:
name|pat
operator|->
name|src
decl_stmt|;
name|dst_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dst_side
argument_list|)
operator|+
name|strlen
argument_list|(
name|src
operator|->
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|pat
operator|->
name|src
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dst_name
argument_list|,
name|dst_side
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dst_name
argument_list|,
name|src
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|pat
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dst_peer
operator|=
name|find_ref_by_name
argument_list|(
name|dst
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_peer
condition|)
block|{
if|if
condition|(
name|dst_peer
operator|->
name|peer_ref
condition|)
comment|/* We're already sending something to this ref. */
goto|goto
name|free_name
goto|;
block|}
else|else
block|{
if|if
condition|(
name|pat
operator|->
name|matching
operator|&&
operator|!
operator|(
name|send_all
operator|||
name|send_mirror
operator|)
condition|)
comment|/* 				 * Remote doesn't have it, and we have no 				 * explicit pattern, and we don't have 				 * --all nor --mirror. 				 */
goto|goto
name|free_name
goto|;
comment|/* Create a new one and link it */
name|dst_peer
operator|=
name|make_linked_ref
argument_list|(
name|dst_name
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_peer
operator|->
name|new_sha1
argument_list|,
name|src
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
block|}
name|dst_peer
operator|->
name|peer_ref
operator|=
name|src
expr_stmt|;
name|dst_peer
operator|->
name|force
operator|=
name|pat
operator|->
name|force
expr_stmt|;
name|free_name
label|:
name|free
argument_list|(
name|dst_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|branch_get
name|struct
name|branch
modifier|*
name|branch_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|ret
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|ret
operator|=
name|current_branch
expr_stmt|;
else|else
name|ret
operator|=
name|make_branch
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|ret
operator|->
name|remote_name
condition|)
block|{
name|ret
operator|->
name|remote
operator|=
name|remote_get
argument_list|(
name|ret
operator|->
name|remote_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|merge_nr
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ret
operator|->
name|merge
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ret
operator|->
name|merge
argument_list|)
argument_list|,
name|ret
operator|->
name|merge_nr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ret
operator|->
name|merge_nr
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|->
name|merge
index|[
name|i
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|ret
operator|->
name|merge
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
operator|=
name|xstrdup
argument_list|(
name|ret
operator|->
name|merge_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|remote_find_tracking
argument_list|(
name|ret
operator|->
name|remote
argument_list|,
name|ret
operator|->
name|merge
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|branch_has_merge_config
name|int
name|branch_has_merge_config
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|)
block|{
return|return
name|branch
operator|&&
operator|!
operator|!
name|branch
operator|->
name|merge
return|;
block|}
end_function
begin_function
DECL|function|branch_merge_matches
name|int
name|branch_merge_matches
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|branch
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|branch
operator|->
name|merge_nr
condition|)
return|return
literal|0
return|;
return|return
name|refname_match
argument_list|(
name|branch
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
argument_list|,
name|refname
argument_list|,
name|ref_fetch_rules
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_expanded_map
specifier|static
name|struct
name|ref
modifier|*
name|get_expanded_map
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|ref
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ret
decl_stmt|;
name|int
name|remote_prefix_len
init|=
name|strlen
argument_list|(
name|refspec
operator|->
name|src
argument_list|)
decl_stmt|;
name|int
name|local_prefix_len
init|=
name|strlen
argument_list|(
name|refspec
operator|->
name|dst
argument_list|)
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
continue|continue;
comment|/* a dereference item */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|refspec
operator|->
name|src
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
name|struct
name|ref
modifier|*
name|cpy
init|=
name|copy_ref
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|match
operator|=
name|ref
operator|->
name|name
operator|+
name|remote_prefix_len
expr_stmt|;
name|cpy
operator|->
name|peer_ref
operator|=
name|alloc_ref_with_prefix
argument_list|(
name|refspec
operator|->
name|dst
argument_list|,
name|local_prefix_len
argument_list|,
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|refspec
operator|->
name|force
condition|)
name|cpy
operator|->
name|peer_ref
operator|->
name|force
operator|=
literal|1
expr_stmt|;
operator|*
name|tail
operator|=
name|cpy
expr_stmt|;
name|tail
operator|=
operator|&
name|cpy
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|find_ref_by_name_abbrev
specifier|static
specifier|const
name|struct
name|ref
modifier|*
name|find_ref_by_name_abbrev
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|refname_match
argument_list|(
name|name
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|ref_fetch_rules
argument_list|)
condition|)
return|return
name|ref
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|get_remote_ref
name|struct
name|ref
modifier|*
name|get_remote_ref
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ref
init|=
name|find_ref_by_name_abbrev
argument_list|(
name|remote_refs
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
return|return
name|NULL
return|;
return|return
name|copy_ref
argument_list|(
name|ref
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_local_ref
specifier|static
name|struct
name|ref
modifier|*
name|get_local_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|)
condition|)
return|return
name|alloc_ref
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"remotes/"
argument_list|)
condition|)
return|return
name|alloc_ref_with_prefix
argument_list|(
literal|"refs/"
argument_list|,
literal|5
argument_list|,
name|name
argument_list|)
return|;
return|return
name|alloc_ref_with_prefix
argument_list|(
literal|"refs/heads/"
argument_list|,
literal|11
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_fetch_map
name|int
name|get_fetch_map
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|,
name|int
name|missing_ok
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref_map
decl_stmt|,
modifier|*
modifier|*
name|rmp
decl_stmt|;
if|if
condition|(
name|refspec
operator|->
name|pattern
condition|)
block|{
name|ref_map
operator|=
name|get_expanded_map
argument_list|(
name|remote_refs
argument_list|,
name|refspec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|refspec
operator|->
name|src
index|[
literal|0
index|]
condition|?
name|refspec
operator|->
name|src
else|:
literal|"HEAD"
decl_stmt|;
name|ref_map
operator|=
name|get_remote_ref
argument_list|(
name|remote_refs
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|missing_ok
operator|&&
operator|!
name|ref_map
condition|)
name|die
argument_list|(
literal|"Couldn't find remote ref %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_map
condition|)
block|{
name|ref_map
operator|->
name|peer_ref
operator|=
name|get_local_ref
argument_list|(
name|refspec
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_map
operator|->
name|peer_ref
operator|&&
name|refspec
operator|->
name|force
condition|)
name|ref_map
operator|->
name|peer_ref
operator|->
name|force
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|rmp
operator|=
operator|&
name|ref_map
init|;
operator|*
name|rmp
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|rmp
operator|)
operator|->
name|peer_ref
condition|)
block|{
name|int
name|st
init|=
name|check_ref_format
argument_list|(
operator|(
operator|*
name|rmp
operator|)
operator|->
name|peer_ref
operator|->
name|name
operator|+
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|st
operator|&&
name|st
operator|!=
name|CHECK_REF_FORMAT_ONELEVEL
condition|)
block|{
name|struct
name|ref
modifier|*
name|ignore
init|=
operator|*
name|rmp
decl_stmt|;
name|error
argument_list|(
literal|"* Ignoring funny ref '%s' locally"
argument_list|,
operator|(
operator|*
name|rmp
operator|)
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|rmp
operator|=
operator|(
operator|*
name|rmp
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ignore
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|rmp
operator|=
operator|&
operator|(
operator|(
operator|*
name|rmp
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ref_map
condition|)
name|tail_link_ref
argument_list|(
name|ref_map
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|resolve_remote_symref
name|int
name|resolve_remote_symref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|struct
name|ref
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ref
operator|->
name|symref
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ref
operator|->
name|symref
argument_list|,
name|list
operator|->
name|name
argument_list|)
condition|)
block|{
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|list
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Return true if there is anything to report, otherwise false.  */
end_comment
begin_function
DECL|function|stat_tracking_info
name|int
name|stat_tracking_info
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|int
modifier|*
name|num_ours
parameter_list|,
name|int
modifier|*
name|num_theirs
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|ours
decl_stmt|,
modifier|*
name|theirs
decl_stmt|;
name|char
name|symmetric
index|[
literal|84
index|]
decl_stmt|;
name|struct
name|rev_info
name|revs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_argv
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|int
name|rev_argc
decl_stmt|;
comment|/* 	 * Nothing to report unless we are marked to build on top of 	 * somebody else. 	 */
if|if
condition|(
operator|!
name|branch
operator|||
operator|!
name|branch
operator|->
name|merge
operator|||
operator|!
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|||
operator|!
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
condition|)
return|return
literal|0
return|;
comment|/* 	 * If what we used to build on no longer exists, there is 	 * nothing to report. 	 */
name|base
operator|=
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
expr_stmt|;
if|if
condition|(
operator|!
name|resolve_ref
argument_list|(
name|base
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
name|theirs
operator|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|theirs
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|resolve_ref
argument_list|(
name|branch
operator|->
name|refname
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
name|ours
operator|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ours
condition|)
return|return
literal|0
return|;
comment|/* are we the same? */
if|if
condition|(
name|theirs
operator|==
name|ours
condition|)
return|return
literal|0
return|;
comment|/* Run "rev-list --no-merges --left-right ours...theirs" internally... */
name|rev_argc
operator|=
literal|0
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
literal|"--no-merges"
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
literal|"--left-right"
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
name|symmetric
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
literal|"--"
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
index|]
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|symmetric
argument_list|,
name|sha1_to_hex
argument_list|(
name|ours
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symmetric
operator|+
literal|40
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symmetric
operator|+
literal|43
argument_list|,
name|sha1_to_hex
argument_list|(
name|theirs
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
name|rev_argc
argument_list|,
name|rev_argv
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
comment|/* ... and count the commits on each side. */
operator|*
name|num_ours
operator|=
literal|0
expr_stmt|;
operator|*
name|num_theirs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|commit
modifier|*
name|c
init|=
name|get_revision
argument_list|(
operator|&
name|revs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|->
name|object
operator|.
name|flags
operator|&
name|SYMMETRIC_LEFT
condition|)
operator|(
operator|*
name|num_ours
operator|)
operator|++
expr_stmt|;
else|else
operator|(
operator|*
name|num_theirs
operator|)
operator|++
expr_stmt|;
block|}
comment|/* clear object flags smudged by the above traversal */
name|clear_commit_marks
argument_list|(
name|ours
argument_list|,
name|ALL_REV_FLAGS
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|theirs
argument_list|,
name|ALL_REV_FLAGS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Return true when there is anything to report, otherwise false.  */
end_comment
begin_function
DECL|function|format_tracking_info
name|int
name|format_tracking_info
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|num_ours
decl_stmt|,
name|num_theirs
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|num_ours
argument_list|,
operator|&
name|num_theirs
argument_list|)
condition|)
return|return
literal|0
return|;
name|base
operator|=
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|base
argument_list|,
literal|"refs/remotes/"
argument_list|)
condition|)
block|{
name|base
operator|+=
name|strlen
argument_list|(
literal|"refs/remotes/"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|num_theirs
condition|)
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Your branch is ahead of '%s' "
literal|"by %d commit%s.\n"
argument_list|,
name|base
argument_list|,
name|num_ours
argument_list|,
operator|(
name|num_ours
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|num_ours
condition|)
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Your branch is behind '%s' "
literal|"by %d commit%s, "
literal|"and can be fast-forwarded.\n"
argument_list|,
name|base
argument_list|,
name|num_theirs
argument_list|,
operator|(
name|num_theirs
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
else|else
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"Your branch and '%s' have diverged,\n"
literal|"and have %d and %d different commit(s) each, "
literal|"respectively.\n"
argument_list|,
name|base
argument_list|,
name|num_ours
argument_list|,
name|num_theirs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
end_unit
