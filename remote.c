begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"mergesort.h"
end_include
begin_enum
DECL|enum|map_direction
DECL|enumerator|FROM_SRC
DECL|enumerator|FROM_DST
enum|enum
name|map_direction
block|{
name|FROM_SRC
block|,
name|FROM_DST
block|}
enum|;
end_enum
begin_decl_stmt
DECL|variable|s_tag_refspec
specifier|static
name|struct
name|refspec
name|s_tag_refspec
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"refs/tags/*"
block|,
literal|"refs/tags/*"
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|tag_refspec
specifier|const
name|struct
name|refspec
modifier|*
name|tag_refspec
init|=
operator|&
name|s_tag_refspec
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|counted_string
struct|struct
name|counted_string
block|{
DECL|member|len
name|size_t
name|len
decl_stmt|;
DECL|member|s
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|rewrite
struct|struct
name|rewrite
block|{
DECL|member|base
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
DECL|member|baselen
name|size_t
name|baselen
decl_stmt|;
DECL|member|instead_of
name|struct
name|counted_string
modifier|*
name|instead_of
decl_stmt|;
DECL|member|instead_of_nr
name|int
name|instead_of_nr
decl_stmt|;
DECL|member|instead_of_alloc
name|int
name|instead_of_alloc
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|rewrites
struct|struct
name|rewrites
block|{
DECL|member|rewrite
name|struct
name|rewrite
modifier|*
modifier|*
name|rewrite
decl_stmt|;
DECL|member|rewrite_alloc
name|int
name|rewrite_alloc
decl_stmt|;
DECL|member|rewrite_nr
name|int
name|rewrite_nr
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|remotes
specifier|static
name|struct
name|remote
modifier|*
modifier|*
name|remotes
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remotes_alloc
specifier|static
name|int
name|remotes_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|remotes_nr
specifier|static
name|int
name|remotes_nr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branches
specifier|static
name|struct
name|branch
modifier|*
modifier|*
name|branches
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branches_alloc
specifier|static
name|int
name|branches_alloc
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|branches_nr
specifier|static
name|int
name|branches_nr
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|current_branch
specifier|static
name|struct
name|branch
modifier|*
name|current_branch
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|default_remote_name
specifier|static
specifier|const
name|char
modifier|*
name|default_remote_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|pushremote_name
specifier|static
specifier|const
name|char
modifier|*
name|pushremote_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|explicit_default_remote_name
specifier|static
name|int
name|explicit_default_remote_name
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rewrites
specifier|static
name|struct
name|rewrites
name|rewrites
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|rewrites_push
specifier|static
name|struct
name|rewrites
name|rewrites_push
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|BUF_SIZE
define|#
directive|define
name|BUF_SIZE
value|(2048)
end_define
begin_decl_stmt
DECL|variable|buffer
specifier|static
name|char
name|buffer
index|[
name|BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|valid_remote
specifier|static
name|int
name|valid_remote
parameter_list|(
specifier|const
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|!
name|remote
operator|->
name|url
operator|)
operator|||
operator|(
operator|!
operator|!
name|remote
operator|->
name|foreign_vcs
operator|)
return|;
block|}
end_function
begin_function
DECL|function|alias_url
specifier|static
specifier|const
name|char
modifier|*
name|alias_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|struct
name|rewrites
modifier|*
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|struct
name|counted_string
modifier|*
name|longest
decl_stmt|;
name|int
name|longest_i
decl_stmt|;
name|longest
operator|=
name|NULL
expr_stmt|;
name|longest_i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|rewrite_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|rewrite
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|r
operator|->
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of_nr
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|url
argument_list|,
name|r
operator|->
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of
index|[
name|j
index|]
operator|.
name|s
argument_list|)
operator|&&
operator|(
operator|!
name|longest
operator|||
name|longest
operator|->
name|len
operator|<
name|r
operator|->
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of
index|[
name|j
index|]
operator|.
name|len
operator|)
condition|)
block|{
name|longest
operator|=
operator|&
operator|(
name|r
operator|->
name|rewrite
index|[
name|i
index|]
operator|->
name|instead_of
index|[
name|j
index|]
operator|)
expr_stmt|;
name|longest_i
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|longest
condition|)
return|return
name|url
return|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|r
operator|->
name|rewrite
index|[
name|longest_i
index|]
operator|->
name|baselen
operator|+
operator|(
name|strlen
argument_list|(
name|url
argument_list|)
operator|-
name|longest
operator|->
name|len
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|r
operator|->
name|rewrite
index|[
name|longest_i
index|]
operator|->
name|base
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|+
name|r
operator|->
name|rewrite
index|[
name|longest_i
index|]
operator|->
name|baselen
argument_list|,
name|url
operator|+
name|longest
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|add_push_refspec
specifier|static
name|void
name|add_push_refspec
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|remote
operator|->
name|push_refspec
argument_list|,
name|remote
operator|->
name|push_refspec_nr
operator|+
literal|1
argument_list|,
name|remote
operator|->
name|push_refspec_alloc
argument_list|)
expr_stmt|;
name|remote
operator|->
name|push_refspec
index|[
name|remote
operator|->
name|push_refspec_nr
operator|++
index|]
operator|=
name|ref
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_fetch_refspec
specifier|static
name|void
name|add_fetch_refspec
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|remote
operator|->
name|fetch_refspec
argument_list|,
name|remote
operator|->
name|fetch_refspec_nr
operator|+
literal|1
argument_list|,
name|remote
operator|->
name|fetch_refspec_alloc
argument_list|)
expr_stmt|;
name|remote
operator|->
name|fetch_refspec
index|[
name|remote
operator|->
name|fetch_refspec_nr
operator|++
index|]
operator|=
name|ref
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_url
specifier|static
name|void
name|add_url
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|remote
operator|->
name|url
argument_list|,
name|remote
operator|->
name|url_nr
operator|+
literal|1
argument_list|,
name|remote
operator|->
name|url_alloc
argument_list|)
expr_stmt|;
name|remote
operator|->
name|url
index|[
name|remote
operator|->
name|url_nr
operator|++
index|]
operator|=
name|url
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_pushurl
specifier|static
name|void
name|add_pushurl
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|pushurl
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|remote
operator|->
name|pushurl
argument_list|,
name|remote
operator|->
name|pushurl_nr
operator|+
literal|1
argument_list|,
name|remote
operator|->
name|pushurl_alloc
argument_list|)
expr_stmt|;
name|remote
operator|->
name|pushurl
index|[
name|remote
operator|->
name|pushurl_nr
operator|++
index|]
operator|=
name|pushurl
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_pushurl_alias
specifier|static
name|void
name|add_pushurl_alias
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pushurl
init|=
name|alias_url
argument_list|(
name|url
argument_list|,
operator|&
name|rewrites_push
argument_list|)
decl_stmt|;
if|if
condition|(
name|pushurl
operator|!=
name|url
condition|)
name|add_pushurl
argument_list|(
name|remote
argument_list|,
name|pushurl
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_url_alias
specifier|static
name|void
name|add_url_alias
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|add_url
argument_list|(
name|remote
argument_list|,
name|alias_url
argument_list|(
name|url
argument_list|,
operator|&
name|rewrites
argument_list|)
argument_list|)
expr_stmt|;
name|add_pushurl_alias
argument_list|(
name|remote
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_remote
specifier|static
name|struct
name|remote
modifier|*
name|make_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|remote
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remotes_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|len
condition|?
operator|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|remotes
index|[
name|i
index|]
operator|->
name|name
index|[
name|len
index|]
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|remotes
index|[
name|i
index|]
return|;
block|}
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|remotes
argument_list|,
name|remotes_nr
operator|+
literal|1
argument_list|,
name|remotes_alloc
argument_list|)
expr_stmt|;
name|remotes
index|[
name|remotes_nr
operator|++
index|]
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|ret
operator|->
name|name
operator|=
name|xstrndup
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|ret
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|add_merge
specifier|static
name|void
name|add_merge
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|branch
operator|->
name|merge_name
argument_list|,
name|branch
operator|->
name|merge_nr
operator|+
literal|1
argument_list|,
name|branch
operator|->
name|merge_alloc
argument_list|)
expr_stmt|;
name|branch
operator|->
name|merge_name
index|[
name|branch
operator|->
name|merge_nr
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_function
DECL|function|make_branch
specifier|static
name|struct
name|branch
modifier|*
name|make_branch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|refname
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|branches_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|len
condition|?
operator|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|branches
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|!
name|branches
index|[
name|i
index|]
operator|->
name|name
index|[
name|len
index|]
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|branches
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|branches
index|[
name|i
index|]
return|;
block|}
name|ALLOC_GROW
argument_list|(
name|branches
argument_list|,
name|branches_nr
operator|+
literal|1
argument_list|,
name|branches_alloc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|branch
argument_list|)
argument_list|)
expr_stmt|;
name|branches
index|[
name|branches_nr
operator|++
index|]
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|ret
operator|->
name|name
operator|=
name|xstrndup
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|ret
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|refname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|refname
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|refname
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
argument_list|,
name|ret
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|refname
operator|=
name|refname
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|make_rewrite
specifier|static
name|struct
name|rewrite
modifier|*
name|make_rewrite
parameter_list|(
name|struct
name|rewrites
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|rewrite
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|rewrite_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|len
condition|?
operator|(
name|len
operator|==
name|r
operator|->
name|rewrite
index|[
name|i
index|]
operator|->
name|baselen
operator|&&
operator|!
name|strncmp
argument_list|(
name|base
argument_list|,
name|r
operator|->
name|rewrite
index|[
name|i
index|]
operator|->
name|base
argument_list|,
name|len
argument_list|)
operator|)
else|:
operator|!
name|strcmp
argument_list|(
name|base
argument_list|,
name|r
operator|->
name|rewrite
index|[
name|i
index|]
operator|->
name|base
argument_list|)
condition|)
return|return
name|r
operator|->
name|rewrite
index|[
name|i
index|]
return|;
block|}
name|ALLOC_GROW
argument_list|(
name|r
operator|->
name|rewrite
argument_list|,
name|r
operator|->
name|rewrite_nr
operator|+
literal|1
argument_list|,
name|r
operator|->
name|rewrite_alloc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rewrite
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|rewrite
index|[
name|r
operator|->
name|rewrite_nr
operator|++
index|]
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|ret
operator|->
name|base
operator|=
name|xstrndup
argument_list|(
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
operator|->
name|baselen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|->
name|base
operator|=
name|xstrdup
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|ret
operator|->
name|baselen
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|add_instead_of
specifier|static
name|void
name|add_instead_of
parameter_list|(
name|struct
name|rewrite
modifier|*
name|rewrite
parameter_list|,
specifier|const
name|char
modifier|*
name|instead_of
parameter_list|)
block|{
name|ALLOC_GROW
argument_list|(
name|rewrite
operator|->
name|instead_of
argument_list|,
name|rewrite
operator|->
name|instead_of_nr
operator|+
literal|1
argument_list|,
name|rewrite
operator|->
name|instead_of_alloc
argument_list|)
expr_stmt|;
name|rewrite
operator|->
name|instead_of
index|[
name|rewrite
operator|->
name|instead_of_nr
index|]
operator|.
name|s
operator|=
name|instead_of
expr_stmt|;
name|rewrite
operator|->
name|instead_of
index|[
name|rewrite
operator|->
name|instead_of_nr
index|]
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|instead_of
argument_list|)
expr_stmt|;
name|rewrite
operator|->
name|instead_of_nr
operator|++
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_remotes_file
specifier|static
name|void
name|read_remotes_file
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"remotes/%s"
argument_list|,
name|remote
operator|->
name|name
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|remote
operator|->
name|origin
operator|=
name|REMOTE_REMOTES
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|int
name|value_list
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"URL:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"Push:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|buffer
argument_list|,
literal|"Pull:"
argument_list|)
condition|)
block|{
name|value_list
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|buffer
operator|+
literal|5
expr_stmt|;
block|}
else|else
continue|continue;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
continue|continue;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|value_list
condition|)
block|{
case|case
literal|0
case|:
name|add_url_alias
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|xstrdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_branches_file
specifier|static
name|void
name|read_branches_file
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|)
block|{
name|char
modifier|*
name|frag
decl_stmt|;
name|struct
name|strbuf
name|branch
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|n
init|=
literal|1000
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"branches/%.*s"
argument_list|,
name|n
argument_list|,
name|remote
operator|->
name|name
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|s
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
name|BUF_SIZE
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return;
name|remote
operator|->
name|origin
operator|=
name|REMOTE_BRANCHES
expr_stmt|;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|s
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * The branches file would have URL and optionally 	 * #branch specified.  The "master" (or specified) branch is 	 * fetched and stored in the local branch of the same name. 	 */
name|frag
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
condition|)
block|{
operator|*
operator|(
name|frag
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|branch
argument_list|,
literal|"refs/heads/%s"
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|branch
argument_list|,
literal|"refs/heads/master"
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|branch
argument_list|,
literal|":refs/heads/%s"
argument_list|,
name|remote
operator|->
name|name
argument_list|)
expr_stmt|;
name|add_url_alias
argument_list|(
name|remote
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|branch
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Cogito compatible push: push current HEAD to remote #branch 	 * (master if missing) 	 */
name|strbuf_init
argument_list|(
operator|&
name|branch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|branch
argument_list|,
literal|"HEAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|branch
argument_list|,
literal|":refs/heads/%s"
argument_list|,
name|frag
argument_list|)
expr_stmt|;
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|branch
argument_list|,
literal|":refs/heads/master"
argument_list|)
expr_stmt|;
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|branch
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|remote
operator|->
name|fetch_tags
operator|=
literal|1
expr_stmt|;
comment|/* always auto-follow */
block|}
end_function
begin_function
DECL|function|handle_config
specifier|static
name|int
name|handle_config
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|subkey
decl_stmt|;
name|struct
name|remote
modifier|*
name|remote
decl_stmt|;
name|struct
name|branch
modifier|*
name|branch
decl_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"branch."
argument_list|)
condition|)
block|{
name|name
operator|=
name|key
operator|+
literal|7
expr_stmt|;
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
literal|0
return|;
name|branch
operator|=
name|make_branch
argument_list|(
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".remote"
argument_list|)
condition|)
block|{
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|branch
operator|->
name|remote_name
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|branch
operator|==
name|current_branch
condition|)
block|{
name|default_remote_name
operator|=
name|branch
operator|->
name|remote_name
expr_stmt|;
name|explicit_default_remote_name
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".pushremote"
argument_list|)
condition|)
block|{
if|if
condition|(
name|branch
operator|==
name|current_branch
condition|)
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|pushremote_name
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".merge"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|key
argument_list|)
return|;
name|add_merge
argument_list|(
name|branch
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"url."
argument_list|)
condition|)
block|{
name|struct
name|rewrite
modifier|*
name|rewrite
decl_stmt|;
name|name
operator|=
name|key
operator|+
literal|4
expr_stmt|;
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".insteadof"
argument_list|)
condition|)
block|{
name|rewrite
operator|=
name|make_rewrite
argument_list|(
operator|&
name|rewrites
argument_list|,
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|key
argument_list|)
return|;
name|add_instead_of
argument_list|(
name|rewrite
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".pushinsteadof"
argument_list|)
condition|)
block|{
name|rewrite
operator|=
name|make_rewrite
argument_list|(
operator|&
name|rewrites_push
argument_list|,
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|key
argument_list|)
return|;
name|add_instead_of
argument_list|(
name|rewrite
argument_list|,
name|xstrdup
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prefixcmp
argument_list|(
name|key
argument_list|,
literal|"remote."
argument_list|)
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|key
operator|+
literal|7
expr_stmt|;
comment|/* Handle remote.* variables */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pushdefault"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|pushremote_name
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
comment|/* Handle remote.<name>.* variables */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
condition|)
block|{
name|warning
argument_list|(
literal|"Config remote shorthand cannot begin with '/': %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|subkey
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subkey
condition|)
return|return
literal|0
return|;
name|remote
operator|=
name|make_remote
argument_list|(
name|name
argument_list|,
name|subkey
operator|-
name|name
argument_list|)
expr_stmt|;
name|remote
operator|->
name|origin
operator|=
name|REMOTE_CONFIG
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".mirror"
argument_list|)
condition|)
name|remote
operator|->
name|mirror
operator|=
name|git_config_bool
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".skipdefaultupdate"
argument_list|)
condition|)
name|remote
operator|->
name|skip_default_update
operator|=
name|git_config_bool
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".skipfetchall"
argument_list|)
condition|)
name|remote
operator|->
name|skip_default_update
operator|=
name|git_config_bool
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".url"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|add_url
argument_list|(
name|remote
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".pushurl"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|add_pushurl
argument_list|(
name|remote
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".push"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|add_push_refspec
argument_list|(
name|remote
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".fetch"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|add_fetch_refspec
argument_list|(
name|remote
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".receivepack"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|remote
operator|->
name|receivepack
condition|)
name|remote
operator|->
name|receivepack
operator|=
name|v
expr_stmt|;
else|else
name|error
argument_list|(
literal|"more than one receivepack given, using the first"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".uploadpack"
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|git_config_string
argument_list|(
operator|&
name|v
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|remote
operator|->
name|uploadpack
condition|)
name|remote
operator|->
name|uploadpack
operator|=
name|v
expr_stmt|;
else|else
name|error
argument_list|(
literal|"more than one uploadpack given, using the first"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".tagopt"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"--no-tags"
argument_list|)
condition|)
name|remote
operator|->
name|fetch_tags
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"--tags"
argument_list|)
condition|)
name|remote
operator|->
name|fetch_tags
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".proxy"
argument_list|)
condition|)
block|{
return|return
name|git_config_string
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|remote
operator|->
name|http_proxy
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subkey
argument_list|,
literal|".vcs"
argument_list|)
condition|)
block|{
return|return
name|git_config_string
argument_list|(
operator|&
name|remote
operator|->
name|foreign_vcs
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|alias_all_urls
specifier|static
name|void
name|alias_all_urls
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remotes_nr
condition|;
name|i
operator|++
control|)
block|{
name|int
name|add_pushurl_aliases
decl_stmt|;
if|if
condition|(
operator|!
name|remotes
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|remotes
index|[
name|i
index|]
operator|->
name|pushurl_nr
condition|;
name|j
operator|++
control|)
block|{
name|remotes
index|[
name|i
index|]
operator|->
name|pushurl
index|[
name|j
index|]
operator|=
name|alias_url
argument_list|(
name|remotes
index|[
name|i
index|]
operator|->
name|pushurl
index|[
name|j
index|]
argument_list|,
operator|&
name|rewrites
argument_list|)
expr_stmt|;
block|}
name|add_pushurl_aliases
operator|=
name|remotes
index|[
name|i
index|]
operator|->
name|pushurl_nr
operator|==
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|remotes
index|[
name|i
index|]
operator|->
name|url_nr
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|add_pushurl_aliases
condition|)
name|add_pushurl_alias
argument_list|(
name|remotes
index|[
name|i
index|]
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|url
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|remotes
index|[
name|i
index|]
operator|->
name|url
index|[
name|j
index|]
operator|=
name|alias_url
argument_list|(
name|remotes
index|[
name|i
index|]
operator|->
name|url
index|[
name|j
index|]
argument_list|,
operator|&
name|rewrites
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|read_config
specifier|static
name|void
name|read_config
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|head_ref
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|if
condition|(
name|default_remote_name
condition|)
comment|/* did this already */
return|return;
name|default_remote_name
operator|=
name|xstrdup
argument_list|(
literal|"origin"
argument_list|)
expr_stmt|;
name|current_branch
operator|=
name|NULL
expr_stmt|;
name|head_ref
operator|=
name|resolve_ref_unsafe
argument_list|(
literal|"HEAD"
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_ref
operator|&&
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|head_ref
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
block|{
name|current_branch
operator|=
name|make_branch
argument_list|(
name|head_ref
operator|+
name|strlen
argument_list|(
literal|"refs/heads/"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|git_config
argument_list|(
name|handle_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alias_all_urls
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * This function frees a refspec array.  * Warning: code paths should be checked to ensure that the src  *          and dst pointers are always freeable pointers as well  *          as the refspec pointer itself.  */
end_comment
begin_function
DECL|function|free_refspecs
specifier|static
name|void
name|free_refspecs
parameter_list|(
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|,
name|int
name|nr_refspec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|refspec
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|refspec
index|[
name|i
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refspec
index|[
name|i
index|]
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|refspec
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_refspec_internal
specifier|static
name|struct
name|refspec
modifier|*
name|parse_refspec_internal
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|,
name|int
name|fetch
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|refspec
modifier|*
name|rs
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|,
name|nr_refspec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|llen
decl_stmt|;
name|int
name|is_glob
decl_stmt|;
specifier|const
name|char
modifier|*
name|lhs
decl_stmt|,
modifier|*
name|rhs
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|is_glob
operator|=
literal|0
expr_stmt|;
name|lhs
operator|=
name|refspec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|lhs
operator|==
literal|'+'
condition|)
block|{
name|rs
index|[
name|i
index|]
operator|.
name|force
operator|=
literal|1
expr_stmt|;
name|lhs
operator|++
expr_stmt|;
block|}
name|rhs
operator|=
name|strrchr
argument_list|(
name|lhs
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* 		 * Before going on, special case ":" (or "+:") as a refspec 		 * for pushing matching refs. 		 */
if|if
condition|(
operator|!
name|fetch
operator|&&
name|rhs
operator|==
name|lhs
operator|&&
name|rhs
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|rs
index|[
name|i
index|]
operator|.
name|matching
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rhs
condition|)
block|{
name|size_t
name|rlen
init|=
name|strlen
argument_list|(
operator|++
name|rhs
argument_list|)
decl_stmt|;
name|is_glob
operator|=
operator|(
literal|1
operator|<=
name|rlen
operator|&&
name|strchr
argument_list|(
name|rhs
argument_list|,
literal|'*'
argument_list|)
operator|)
expr_stmt|;
name|rs
index|[
name|i
index|]
operator|.
name|dst
operator|=
name|xstrndup
argument_list|(
name|rhs
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
name|llen
operator|=
operator|(
name|rhs
condition|?
operator|(
name|rhs
operator|-
name|lhs
operator|-
literal|1
operator|)
else|:
name|strlen
argument_list|(
name|lhs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<=
name|llen
operator|&&
name|memchr
argument_list|(
name|lhs
argument_list|,
literal|'*'
argument_list|,
name|llen
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|rhs
operator|&&
operator|!
name|is_glob
operator|)
operator|||
operator|(
operator|!
name|rhs
operator|&&
name|fetch
operator|)
condition|)
goto|goto
name|invalid
goto|;
name|is_glob
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|&&
name|is_glob
condition|)
block|{
goto|goto
name|invalid
goto|;
block|}
name|rs
index|[
name|i
index|]
operator|.
name|pattern
operator|=
name|is_glob
expr_stmt|;
name|rs
index|[
name|i
index|]
operator|.
name|src
operator|=
name|xstrndup
argument_list|(
name|lhs
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|flags
operator|=
name|REFNAME_ALLOW_ONELEVEL
operator||
operator|(
name|is_glob
condition|?
name|REFNAME_REFSPEC_PATTERN
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|fetch
condition|)
block|{
name|unsigned
name|char
name|unused
index|[
literal|40
index|]
decl_stmt|;
comment|/* LHS */
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|src
condition|)
empty_stmt|;
comment|/* empty is ok; it means "HEAD" */
elseif|else
if|if
condition|(
name|llen
operator|==
literal|40
operator|&&
operator|!
name|get_sha1_hex
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|unused
argument_list|)
condition|)
name|rs
index|[
name|i
index|]
operator|.
name|exact_sha1
operator|=
literal|1
expr_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
operator|!
name|check_refname_format
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|flags
argument_list|)
condition|)
empty_stmt|;
comment|/* valid looking ref is ok */
else|else
goto|goto
name|invalid
goto|;
comment|/* RHS */
if|if
condition|(
operator|!
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
empty_stmt|;
comment|/* missing is ok; it is the same as empty */
elseif|else
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
empty_stmt|;
comment|/* empty is ok; it means "do not store" */
elseif|else
if|if
condition|(
operator|!
name|check_refname_format
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|,
name|flags
argument_list|)
condition|)
empty_stmt|;
comment|/* valid looking ref is ok */
else|else
goto|goto
name|invalid
goto|;
block|}
else|else
block|{
comment|/* 			 * LHS 			 * - empty is allowed; it means delete. 			 * - when wildcarded, it must be a valid looking ref. 			 * - otherwise, it must be an extended SHA-1, but 			 *   there is no existing way to validate this. 			 */
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|src
condition|)
empty_stmt|;
comment|/* empty is ok */
elseif|else
if|if
condition|(
name|is_glob
condition|)
block|{
if|if
condition|(
name|check_refname_format
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|invalid
goto|;
block|}
else|else
empty_stmt|;
comment|/* anything goes, for now */
comment|/* 			 * RHS 			 * - missing is allowed, but LHS then must be a 			 *   valid looking ref. 			 * - empty is not allowed. 			 * - otherwise it must be a valid looking ref. 			 */
if|if
condition|(
operator|!
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
block|{
if|if
condition|(
name|check_refname_format
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|invalid
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|)
block|{
goto|goto
name|invalid
goto|;
block|}
else|else
block|{
if|if
condition|(
name|check_refname_format
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|dst
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|invalid
goto|;
block|}
block|}
block|}
return|return
name|rs
return|;
name|invalid
label|:
if|if
condition|(
name|verify
condition|)
block|{
comment|/* 		 * nr_refspec must be greater than zero and i must be valid 		 * since it is only possible to reach this point from within 		 * the for loop above. 		 */
name|free_refspecs
argument_list|(
name|rs
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|die
argument_list|(
literal|"Invalid refspec '%s'"
argument_list|,
name|refspec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|valid_fetch_refspec
name|int
name|valid_fetch_refspec
parameter_list|(
specifier|const
name|char
modifier|*
name|fetch_refspec_str
parameter_list|)
block|{
name|struct
name|refspec
modifier|*
name|refspec
decl_stmt|;
name|refspec
operator|=
name|parse_refspec_internal
argument_list|(
literal|1
argument_list|,
operator|&
name|fetch_refspec_str
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_refspecs
argument_list|(
name|refspec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|refspec
return|;
block|}
end_function
begin_function
DECL|function|parse_fetch_refspec
name|struct
name|refspec
modifier|*
name|parse_fetch_refspec
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|)
block|{
return|return
name|parse_refspec_internal
argument_list|(
name|nr_refspec
argument_list|,
name|refspec
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_push_refspec
specifier|static
name|struct
name|refspec
modifier|*
name|parse_push_refspec
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|)
block|{
return|return
name|parse_refspec_internal
argument_list|(
name|nr_refspec
argument_list|,
name|refspec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|free_refspec
name|void
name|free_refspec
parameter_list|(
name|int
name|nr_refspec
parameter_list|,
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_refspec
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|refspec
index|[
name|i
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refspec
index|[
name|i
index|]
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|refspec
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|valid_remote_nick
specifier|static
name|int
name|valid_remote_nick
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
index|[
literal|0
index|]
operator|||
name|is_dot_or_dotdot
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
return|;
comment|/* no slash */
block|}
end_function
begin_function
DECL|function|remote_get_1
specifier|static
name|struct
name|remote
modifier|*
name|remote_get_1
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|pushremote_name
parameter_list|)
block|{
name|struct
name|remote
modifier|*
name|ret
decl_stmt|;
name|int
name|name_given
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
condition|)
name|name_given
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pushremote_name
condition|)
block|{
name|name
operator|=
name|pushremote_name
expr_stmt|;
name|name_given
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|default_remote_name
expr_stmt|;
name|name_given
operator|=
name|explicit_default_remote_name
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|make_remote
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_remote_nick
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|valid_remote
argument_list|(
name|ret
argument_list|)
condition|)
name|read_remotes_file
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_remote
argument_list|(
name|ret
argument_list|)
condition|)
name|read_branches_file
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name_given
operator|&&
operator|!
name|valid_remote
argument_list|(
name|ret
argument_list|)
condition|)
name|add_url_alias
argument_list|(
name|ret
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_remote
argument_list|(
name|ret
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|fetch
operator|=
name|parse_fetch_refspec
argument_list|(
name|ret
operator|->
name|fetch_refspec_nr
argument_list|,
name|ret
operator|->
name|fetch_refspec
argument_list|)
expr_stmt|;
name|ret
operator|->
name|push
operator|=
name|parse_push_refspec
argument_list|(
name|ret
operator|->
name|push_refspec_nr
argument_list|,
name|ret
operator|->
name|push_refspec
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|remote_get
name|struct
name|remote
modifier|*
name|remote_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|read_config
argument_list|()
expr_stmt|;
return|return
name|remote_get_1
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|pushremote_get
name|struct
name|remote
modifier|*
name|pushremote_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|read_config
argument_list|()
expr_stmt|;
return|return
name|remote_get_1
argument_list|(
name|name
argument_list|,
name|pushremote_name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|remote_is_configured
name|int
name|remote_is_configured
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remotes_nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|remotes
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|for_each_remote
name|int
name|for_each_remote
parameter_list|(
name|each_remote_fn
name|fn
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remotes_nr
operator|&&
operator|!
name|result
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|remote
modifier|*
name|r
init|=
name|remotes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
continue|continue;
if|if
condition|(
operator|!
name|r
operator|->
name|fetch
condition|)
name|r
operator|->
name|fetch
operator|=
name|parse_fetch_refspec
argument_list|(
name|r
operator|->
name|fetch_refspec_nr
argument_list|,
name|r
operator|->
name|fetch_refspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|push
condition|)
name|r
operator|->
name|push
operator|=
name|parse_push_refspec
argument_list|(
name|r
operator|->
name|push_refspec_nr
argument_list|,
name|r
operator|->
name|push_refspec
argument_list|)
expr_stmt|;
name|result
operator|=
name|fn
argument_list|(
name|r
argument_list|,
name|priv
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|ref_remove_duplicates
name|void
name|ref_remove_duplicates
parameter_list|(
name|struct
name|ref
modifier|*
name|ref_map
parameter_list|)
block|{
name|struct
name|string_list
name|refs
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
name|ref_map
condition|;
name|prev
operator|=
name|ref_map
operator|,
name|ref_map
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ref_map
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|ref_map
operator|->
name|peer_ref
condition|)
continue|continue;
name|item
operator|=
name|string_list_lookup
argument_list|(
operator|&
name|refs
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|(
expr|struct
name|ref
operator|*
operator|)
name|item
operator|->
name|util
operator|)
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|name
argument_list|)
condition|)
name|die
argument_list|(
literal|"%s tracks both %s and %s"
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
operator|(
operator|(
expr|struct
name|ref
operator|*
operator|)
name|item
operator|->
name|util
operator|)
operator|->
name|name
argument_list|,
name|ref_map
operator|->
name|name
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|ref_map
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ref_map
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_map
argument_list|)
expr_stmt|;
name|ref_map
operator|=
name|prev
expr_stmt|;
comment|/* skip this; we freed it */
continue|continue;
block|}
name|item
operator|=
name|string_list_insert
argument_list|(
operator|&
name|refs
argument_list|,
name|ref_map
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|ref_map
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
operator|&
name|refs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remote_has_url
name|int
name|remote_has_url
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remote
operator|->
name|url_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|remote
operator|->
name|url
index|[
name|i
index|]
argument_list|,
name|url
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|match_name_with_pattern
specifier|static
name|int
name|match_name_with_pattern
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|kstar
init|=
name|strchr
argument_list|(
name|key
argument_list|,
literal|'*'
argument_list|)
decl_stmt|;
name|size_t
name|klen
decl_stmt|;
name|size_t
name|ksuffixlen
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|kstar
condition|)
name|die
argument_list|(
literal|"Key '%s' of pattern had no '*'"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|klen
operator|=
name|kstar
operator|-
name|key
expr_stmt|;
name|ksuffixlen
operator|=
name|strlen
argument_list|(
name|kstar
operator|+
literal|1
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
operator|&&
name|namelen
operator|>=
name|klen
operator|+
name|ksuffixlen
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
operator|+
name|namelen
operator|-
name|ksuffixlen
argument_list|,
name|kstar
operator|+
literal|1
argument_list|,
name|ksuffixlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|value
condition|)
block|{
specifier|const
name|char
modifier|*
name|vstar
init|=
name|strchr
argument_list|(
name|value
argument_list|,
literal|'*'
argument_list|)
decl_stmt|;
name|size_t
name|vlen
decl_stmt|;
name|size_t
name|vsuffixlen
decl_stmt|;
if|if
condition|(
operator|!
name|vstar
condition|)
name|die
argument_list|(
literal|"Value '%s' of pattern has no '*'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|vstar
operator|-
name|value
expr_stmt|;
name|vsuffixlen
operator|=
name|strlen
argument_list|(
name|vstar
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|xmalloc
argument_list|(
name|vlen
operator|+
name|vsuffixlen
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|klen
operator|-
name|ksuffixlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|result
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|result
operator|+
name|vlen
argument_list|,
name|name
operator|+
name|klen
argument_list|,
name|namelen
operator|-
name|klen
operator|-
name|ksuffixlen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|result
operator|+
name|vlen
operator|+
name|namelen
operator|-
name|klen
operator|-
name|ksuffixlen
argument_list|,
name|vstar
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|query_refspecs
specifier|static
name|int
name|query_refspecs
parameter_list|(
name|struct
name|refspec
modifier|*
name|refs
parameter_list|,
name|int
name|ref_count
parameter_list|,
name|struct
name|refspec
modifier|*
name|query
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|find_src
init|=
operator|!
name|query
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|find_src
operator|&&
operator|!
name|query
operator|->
name|dst
condition|)
return|return
name|error
argument_list|(
literal|"query_refspecs: need either src or dst"
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ref_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|refspec
modifier|*
name|refspec
init|=
operator|&
name|refs
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|find_src
condition|?
name|refspec
operator|->
name|dst
else|:
name|refspec
operator|->
name|src
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
init|=
name|find_src
condition|?
name|refspec
operator|->
name|src
else|:
name|refspec
operator|->
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|needle
init|=
name|find_src
condition|?
name|query
operator|->
name|dst
else|:
name|query
operator|->
name|src
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
init|=
name|find_src
condition|?
operator|&
name|query
operator|->
name|src
else|:
operator|&
name|query
operator|->
name|dst
decl_stmt|;
if|if
condition|(
operator|!
name|refspec
operator|->
name|dst
condition|)
continue|continue;
if|if
condition|(
name|refspec
operator|->
name|pattern
condition|)
block|{
if|if
condition|(
name|match_name_with_pattern
argument_list|(
name|key
argument_list|,
name|needle
argument_list|,
name|value
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|query
operator|->
name|force
operator|=
name|refspec
operator|->
name|force
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|needle
argument_list|,
name|key
argument_list|)
condition|)
block|{
operator|*
name|result
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|query
operator|->
name|force
operator|=
name|refspec
operator|->
name|force
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|apply_refspecs
name|char
modifier|*
name|apply_refspecs
parameter_list|(
name|struct
name|refspec
modifier|*
name|refspecs
parameter_list|,
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|refspec
name|query
decl_stmt|;
name|memset
argument_list|(
operator|&
name|query
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refspec
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|.
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
if|if
condition|(
name|query_refspecs
argument_list|(
name|refspecs
argument_list|,
name|nr_refspec
argument_list|,
operator|&
name|query
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|query
operator|.
name|dst
return|;
block|}
end_function
begin_function
DECL|function|remote_find_tracking
name|int
name|remote_find_tracking
parameter_list|(
name|struct
name|remote
modifier|*
name|remote
parameter_list|,
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
return|return
name|query_refspecs
argument_list|(
name|remote
operator|->
name|fetch
argument_list|,
name|remote
operator|->
name|fetch_refspec_nr
argument_list|,
name|refspec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|alloc_ref_with_prefix
specifier|static
name|struct
name|ref
modifier|*
name|alloc_ref_with_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|size_t
name|prefixlen
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|prefixlen
operator|+
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|prefix
argument_list|,
name|prefixlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
operator|+
name|prefixlen
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|alloc_ref
name|struct
name|ref
modifier|*
name|alloc_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|alloc_ref_with_prefix
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|copy_ref
name|struct
name|ref
modifier|*
name|copy_ref
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|cpy
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|cpy
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cpy
argument_list|,
name|ref
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ref
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cpy
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cpy
operator|->
name|symref
operator|=
name|ref
operator|->
name|symref
condition|?
name|xstrdup
argument_list|(
name|ref
operator|->
name|symref
argument_list|)
else|:
name|NULL
expr_stmt|;
name|cpy
operator|->
name|remote_status
operator|=
name|ref
operator|->
name|remote_status
condition|?
name|xstrdup
argument_list|(
name|ref
operator|->
name|remote_status
argument_list|)
else|:
name|NULL
expr_stmt|;
name|cpy
operator|->
name|peer_ref
operator|=
name|copy_ref
argument_list|(
name|ref
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
return|return
name|cpy
return|;
block|}
end_function
begin_function
DECL|function|copy_ref_list
name|struct
name|ref
modifier|*
name|copy_ref_list
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ret
decl_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
operator|*
name|tail
operator|=
name|copy_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|tail
operator|=
operator|&
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|free_ref
specifier|static
name|void
name|free_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ref
condition|)
return|return;
name|free_ref
argument_list|(
name|ref
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
operator|->
name|remote_status
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
operator|->
name|symref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_refs
name|void
name|free_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|next
operator|=
name|ref
operator|->
name|next
expr_stmt|;
name|free_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ref_compare_name
name|int
name|ref_compare_name
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ref_list_get_next
specifier|static
name|void
modifier|*
name|ref_list_get_next
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|ref
operator|*
operator|)
name|a
operator|)
operator|->
name|next
return|;
block|}
end_function
begin_function
DECL|function|ref_list_set_next
specifier|static
name|void
name|ref_list_set_next
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|next
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|ref
operator|*
operator|)
name|a
operator|)
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sort_ref_list
name|void
name|sort_ref_list
parameter_list|(
name|struct
name|ref
modifier|*
modifier|*
name|l
parameter_list|,
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
operator|*
name|l
operator|=
name|llist_mergesort
argument_list|(
operator|*
name|l
argument_list|,
name|ref_list_get_next
argument_list|,
name|ref_list_set_next
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|count_refspec_match
specifier|static
name|int
name|count_refspec_match
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|matched_ref
parameter_list|)
block|{
name|int
name|patlen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched_weak
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
name|matched
init|=
name|NULL
decl_stmt|;
name|int
name|weak_match
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
for|for
control|(
name|weak_match
operator|=
name|match
operator|=
literal|0
init|;
name|refs
condition|;
name|refs
operator|=
name|refs
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|refs
operator|->
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|refname_match
argument_list|(
name|pattern
argument_list|,
name|name
argument_list|,
name|ref_rev_parse_rules
argument_list|)
condition|)
continue|continue;
comment|/* A match is "weak" if it is with refs outside 		 * heads or tags, and did not specify the pattern 		 * in full (e.g. "refs/remotes/origin/master") or at 		 * least from the toplevel (e.g. "remotes/origin/master"); 		 * otherwise "git push $URL master" would result in 		 * ambiguity between remotes/origin/master and heads/master 		 * at the remote site. 		 */
if|if
condition|(
name|namelen
operator|!=
name|patlen
operator|&&
name|patlen
operator|!=
name|namelen
operator|-
literal|5
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|&&
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
block|{
comment|/* We want to catch the case where only weak 			 * matches are found and there are multiple 			 * matches, and where more than one strong 			 * matches are found, as ambiguous.  One 			 * strong match with zero or more weak matches 			 * are acceptable as a unique match. 			 */
name|matched_weak
operator|=
name|refs
expr_stmt|;
name|weak_match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|matched
operator|=
name|refs
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
operator|*
name|matched_ref
operator|=
name|matched_weak
expr_stmt|;
return|return
name|weak_match
return|;
block|}
else|else
block|{
operator|*
name|matched_ref
operator|=
name|matched
expr_stmt|;
return|return
name|match
return|;
block|}
block|}
end_function
begin_function
DECL|function|tail_link_ref
specifier|static
name|void
name|tail_link_ref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
operator|*
operator|*
name|tail
operator|=
name|ref
expr_stmt|;
while|while
condition|(
name|ref
operator|->
name|next
condition|)
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
block|}
end_function
begin_function
DECL|function|alloc_delete_ref
specifier|static
name|struct
name|ref
modifier|*
name|alloc_delete_ref
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|alloc_ref
argument_list|(
literal|"(delete)"
argument_list|)
decl_stmt|;
name|hashclr
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|try_explicit_object_name
specifier|static
name|struct
name|ref
modifier|*
name|try_explicit_object_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
return|return
name|alloc_delete_ref
argument_list|()
return|;
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ref
operator|=
name|alloc_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function
begin_function
DECL|function|make_linked_ref
specifier|static
name|struct
name|ref
modifier|*
name|make_linked_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ret
init|=
name|alloc_ref
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tail_link_ref
argument_list|(
name|ret
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|guess_ref
specifier|static
name|char
modifier|*
name|guess_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ref
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
init|=
name|resolve_ref_unsafe
argument_list|(
name|peer
operator|->
name|name
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|r
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"refs/heads/"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|r
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"refs/tags/"
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|match_explicit
specifier|static
name|int
name|match_explicit
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|struct
name|refspec
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|matched_src
decl_stmt|,
modifier|*
name|matched_dst
decl_stmt|;
name|int
name|copy_src
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_value
init|=
name|rs
operator|->
name|dst
decl_stmt|;
name|char
modifier|*
name|dst_guess
decl_stmt|;
if|if
condition|(
name|rs
operator|->
name|pattern
operator|||
name|rs
operator|->
name|matching
condition|)
return|return
literal|0
return|;
name|matched_src
operator|=
name|matched_dst
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|rs
operator|->
name|src
argument_list|,
name|src
argument_list|,
operator|&
name|matched_src
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|copy_src
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* The source could be in the get_sha1() format 		 * not a reference name.  :refs/other is a 		 * way to delete 'other' ref at the remote end. 		 */
name|matched_src
operator|=
name|try_explicit_object_name
argument_list|(
name|rs
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matched_src
condition|)
return|return
name|error
argument_list|(
literal|"src refspec %s does not match any."
argument_list|,
name|rs
operator|->
name|src
argument_list|)
return|;
name|copy_src
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|error
argument_list|(
literal|"src refspec %s matches more than one."
argument_list|,
name|rs
operator|->
name|src
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|dst_value
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|dst_value
operator|=
name|resolve_ref_unsafe
argument_list|(
name|matched_src
operator|->
name|name
argument_list|,
name|sha1
argument_list|,
literal|1
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst_value
operator|||
operator|(
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
operator|&&
name|prefixcmp
argument_list|(
name|dst_value
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"%s cannot be resolved to branch."
argument_list|,
name|matched_src
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|count_refspec_match
argument_list|(
name|dst_value
argument_list|,
name|dst
argument_list|,
operator|&
name|matched_dst
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|dst_value
argument_list|,
literal|"refs/"
argument_list|,
literal|5
argument_list|)
condition|)
name|matched_dst
operator|=
name|make_linked_ref
argument_list|(
name|dst_value
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_null_sha1
argument_list|(
name|matched_src
operator|->
name|new_sha1
argument_list|)
condition|)
name|error
argument_list|(
literal|"unable to delete '%s': remote ref does not exist"
argument_list|,
name|dst_value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dst_guess
operator|=
name|guess_ref
argument_list|(
name|dst_value
argument_list|,
name|matched_src
argument_list|)
operator|)
condition|)
name|matched_dst
operator|=
name|make_linked_ref
argument_list|(
name|dst_guess
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unable to push to unqualified destination: %s\n"
literal|"The destination refspec neither matches an "
literal|"existing ref on the remote nor\n"
literal|"begins with refs/, and we are unable to "
literal|"guess a prefix based on the source ref."
argument_list|,
name|dst_value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|matched_dst
operator|=
name|NULL
expr_stmt|;
name|error
argument_list|(
literal|"dst refspec %s matches more than one."
argument_list|,
name|dst_value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|matched_dst
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|matched_dst
operator|->
name|peer_ref
condition|)
return|return
name|error
argument_list|(
literal|"dst ref %s receives from more than one src."
argument_list|,
name|matched_dst
operator|->
name|name
argument_list|)
return|;
else|else
block|{
name|matched_dst
operator|->
name|peer_ref
operator|=
name|copy_src
condition|?
name|copy_ref
argument_list|(
name|matched_src
argument_list|)
else|:
name|matched_src
expr_stmt|;
name|matched_dst
operator|->
name|force
operator|=
name|rs
operator|->
name|force
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|match_explicit_refs
specifier|static
name|int
name|match_explicit_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|,
name|struct
name|refspec
modifier|*
name|rs
parameter_list|,
name|int
name|rs_nr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|errs
decl_stmt|;
for|for
control|(
name|i
operator|=
name|errs
operator|=
literal|0
init|;
name|i
operator|<
name|rs_nr
condition|;
name|i
operator|++
control|)
name|errs
operator|+=
name|match_explicit
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|dst_tail
argument_list|,
operator|&
name|rs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|errs
return|;
block|}
end_function
begin_function
DECL|function|get_ref_match
specifier|static
name|char
modifier|*
name|get_ref_match
parameter_list|(
specifier|const
name|struct
name|refspec
modifier|*
name|rs
parameter_list|,
name|int
name|rs_nr
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|int
name|send_mirror
parameter_list|,
name|int
name|direction
parameter_list|,
specifier|const
name|struct
name|refspec
modifier|*
modifier|*
name|ret_pat
parameter_list|)
block|{
specifier|const
name|struct
name|refspec
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|matching_refs
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs_nr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rs
index|[
name|i
index|]
operator|.
name|matching
operator|&&
operator|(
name|matching_refs
operator|==
operator|-
literal|1
operator|||
name|rs
index|[
name|i
index|]
operator|.
name|force
operator|)
condition|)
block|{
name|matching_refs
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rs
index|[
name|i
index|]
operator|.
name|pattern
condition|)
block|{
specifier|const
name|char
modifier|*
name|dst_side
init|=
name|rs
index|[
name|i
index|]
operator|.
name|dst
condition|?
name|rs
index|[
name|i
index|]
operator|.
name|dst
else|:
name|rs
index|[
name|i
index|]
operator|.
name|src
decl_stmt|;
name|int
name|match
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|FROM_SRC
condition|)
name|match
operator|=
name|match_name_with_pattern
argument_list|(
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|dst_side
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
else|else
name|match
operator|=
name|match_name_with_pattern
argument_list|(
name|dst_side
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|rs
index|[
name|i
index|]
operator|.
name|src
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
block|{
name|matching_refs
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|matching_refs
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|pat
operator|=
name|rs
operator|+
name|matching_refs
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|matching
condition|)
block|{
comment|/* 		 * "matching refs"; traditionally we pushed everything 		 * including refs outside refs/heads/ hierarchy, but 		 * that does not make much sense these days. 		 */
if|if
condition|(
operator|!
name|send_mirror
operator|&&
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|)
return|return
name|NULL
return|;
name|name
operator|=
name|xstrdup
argument_list|(
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_pat
condition|)
operator|*
name|ret_pat
operator|=
name|pat
expr_stmt|;
return|return
name|name
return|;
block|}
end_function
begin_function
DECL|function|tail_ref
specifier|static
name|struct
name|ref
modifier|*
modifier|*
name|tail_ref
parameter_list|(
name|struct
name|ref
modifier|*
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
name|head
decl_stmt|;
while|while
condition|(
operator|*
name|tail
condition|)
name|tail
operator|=
operator|&
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|)
expr_stmt|;
return|return
name|tail
return|;
block|}
end_function
begin_struct
DECL|struct|tips
struct|struct
name|tips
block|{
DECL|member|tip
name|struct
name|commit
modifier|*
modifier|*
name|tip
decl_stmt|;
DECL|member|nr
DECL|member|alloc
name|int
name|nr
decl_stmt|,
name|alloc
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|add_to_tips
specifier|static
name|void
name|add_to_tips
parameter_list|(
name|struct
name|tips
modifier|*
name|tips
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|sha1
argument_list|)
condition|)
return|return;
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
operator|(
name|commit
operator|->
name|object
operator|.
name|flags
operator|&
name|TMP_MARK
operator|)
condition|)
return|return;
name|commit
operator|->
name|object
operator|.
name|flags
operator||=
name|TMP_MARK
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|tips
operator|->
name|tip
argument_list|,
name|tips
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|tips
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|tips
operator|->
name|tip
index|[
name|tips
operator|->
name|nr
operator|++
index|]
operator|=
name|commit
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_missing_tags
specifier|static
name|void
name|add_missing_tags
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|dst
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|dst_tail
parameter_list|)
block|{
name|struct
name|string_list
name|dst_tag
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|struct
name|string_list
name|src_tag
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|item
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|tips
name|sent_tips
decl_stmt|;
comment|/* 	 * Collect everything we know they would have at the end of 	 * this push, and collect all tags they have. 	 */
name|memset
argument_list|(
operator|&
name|sent_tips
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sent_tips
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ref
operator|=
operator|*
name|dst
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ref
operator|->
name|peer_ref
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
condition|)
name|add_to_tips
argument_list|(
operator|&
name|sent_tips
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
else|else
name|add_to_tips
argument_list|(
operator|&
name|sent_tips
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
name|string_list_append
argument_list|(
operator|&
name|dst_tag
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|clear_commit_marks_many
argument_list|(
name|sent_tips
operator|.
name|nr
argument_list|,
name|sent_tips
operator|.
name|tip
argument_list|,
name|TMP_MARK
argument_list|)
expr_stmt|;
name|sort_string_list
argument_list|(
operator|&
name|dst_tag
argument_list|)
expr_stmt|;
comment|/* Collect tags they do not have. */
for|for
control|(
name|ref
operator|=
name|src
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
continue|continue;
comment|/* not a tag */
if|if
condition|(
name|string_list_has_string
argument_list|(
operator|&
name|dst_tag
argument_list|,
name|ref
operator|->
name|name
argument_list|)
condition|)
continue|continue;
comment|/* they already have it */
if|if
condition|(
name|sha1_object_info
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|NULL
argument_list|)
operator|!=
name|OBJ_TAG
condition|)
continue|continue;
comment|/* be conservative */
name|item
operator|=
name|string_list_append
argument_list|(
operator|&
name|src_tag
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|item
operator|->
name|util
operator|=
name|ref
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
operator|&
name|dst_tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, src_tag lists tags that are missing from 	 * dst, and sent_tips lists the tips we are pushing or those 	 * that we know they already have. An element in the src_tag 	 * that is an ancestor of any of the sent_tips needs to be 	 * sent to the other side. 	 */
if|if
condition|(
name|sent_tips
operator|.
name|nr
condition|)
block|{
name|for_each_string_list_item
argument_list|(
argument|item
argument_list|,
argument|&src_tag
argument_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|item
operator|->
name|util
decl_stmt|;
name|struct
name|ref
modifier|*
name|dst_ref
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
if|if
condition|(
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
condition|)
continue|continue;
name|commit
operator|=
name|lookup_commit_reference_gently
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
comment|/* not pushing a commit, which is not an error */
continue|continue;
comment|/* 			 * Is this tag, which they do not have, reachable from 			 * any of the commits we are sending? 			 */
if|if
condition|(
operator|!
name|in_merge_bases_many
argument_list|(
name|commit
argument_list|,
name|sent_tips
operator|.
name|nr
argument_list|,
name|sent_tips
operator|.
name|tip
argument_list|)
condition|)
continue|continue;
comment|/* Add it in */
name|dst_ref
operator|=
name|make_linked_ref
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|dst_tail
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_ref
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|dst_ref
operator|->
name|peer_ref
operator|=
name|copy_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
name|string_list_clear
argument_list|(
operator|&
name|src_tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sent_tips
operator|.
name|tip
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_ref_index
specifier|static
name|void
name|prepare_ref_index
parameter_list|(
name|struct
name|string_list
modifier|*
name|ref_index
parameter_list|,
name|struct
name|ref
modifier|*
name|ref
parameter_list|)
block|{
for|for
control|(
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
name|string_list_append_nodup
argument_list|(
name|ref_index
argument_list|,
name|ref
operator|->
name|name
argument_list|)
operator|->
name|util
operator|=
name|ref
expr_stmt|;
name|sort_string_list
argument_list|(
name|ref_index
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Given the set of refs the local repository has, the set of refs the  * remote repository has, and the refspec used for push, determine  * what remote refs we will update and with what value by setting  * peer_ref (which object is being pushed) and force (if the push is  * forced) in elements of "dst". The function may add new elements to  * dst (e.g. pushing to a new branch, done in match_explicit_refs).  */
end_comment
begin_function
DECL|function|match_push_refs
name|int
name|match_push_refs
parameter_list|(
name|struct
name|ref
modifier|*
name|src
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|dst
parameter_list|,
name|int
name|nr_refspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|refspec
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|refspec
modifier|*
name|rs
decl_stmt|;
name|int
name|send_all
init|=
name|flags
operator|&
name|MATCH_REFS_ALL
decl_stmt|;
name|int
name|send_mirror
init|=
name|flags
operator|&
name|MATCH_REFS_MIRROR
decl_stmt|;
name|int
name|send_prune
init|=
name|flags
operator|&
name|MATCH_REFS_PRUNE
decl_stmt|;
name|int
name|errs
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|default_refspec
index|[]
init|=
block|{
literal|":"
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|,
modifier|*
modifier|*
name|dst_tail
init|=
name|tail_ref
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|struct
name|string_list
name|dst_ref_index
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
if|if
condition|(
operator|!
name|nr_refspec
condition|)
block|{
name|nr_refspec
operator|=
literal|1
expr_stmt|;
name|refspec
operator|=
name|default_refspec
expr_stmt|;
block|}
name|rs
operator|=
name|parse_push_refspec
argument_list|(
name|nr_refspec
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|refspec
argument_list|)
expr_stmt|;
name|errs
operator|=
name|match_explicit_refs
argument_list|(
name|src
argument_list|,
operator|*
name|dst
argument_list|,
operator|&
name|dst_tail
argument_list|,
name|rs
argument_list|,
name|nr_refspec
argument_list|)
expr_stmt|;
comment|/* pick the remainder */
for|for
control|(
name|ref
operator|=
name|src
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|struct
name|string_list_item
modifier|*
name|dst_item
decl_stmt|;
name|struct
name|ref
modifier|*
name|dst_peer
decl_stmt|;
specifier|const
name|struct
name|refspec
modifier|*
name|pat
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|dst_name
decl_stmt|;
name|dst_name
operator|=
name|get_ref_match
argument_list|(
name|rs
argument_list|,
name|nr_refspec
argument_list|,
name|ref
argument_list|,
name|send_mirror
argument_list|,
name|FROM_SRC
argument_list|,
operator|&
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst_name
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dst_ref_index
operator|.
name|nr
condition|)
name|prepare_ref_index
argument_list|(
operator|&
name|dst_ref_index
argument_list|,
operator|*
name|dst
argument_list|)
expr_stmt|;
name|dst_item
operator|=
name|string_list_lookup
argument_list|(
operator|&
name|dst_ref_index
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
name|dst_peer
operator|=
name|dst_item
condition|?
name|dst_item
operator|->
name|util
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|dst_peer
condition|)
block|{
if|if
condition|(
name|dst_peer
operator|->
name|peer_ref
condition|)
comment|/* We're already sending something to this ref. */
goto|goto
name|free_name
goto|;
block|}
else|else
block|{
if|if
condition|(
name|pat
operator|->
name|matching
operator|&&
operator|!
operator|(
name|send_all
operator|||
name|send_mirror
operator|)
condition|)
comment|/* 				 * Remote doesn't have it, and we have no 				 * explicit pattern, and we don't have 				 * --all nor --mirror. 				 */
goto|goto
name|free_name
goto|;
comment|/* Create a new one and link it */
name|dst_peer
operator|=
name|make_linked_ref
argument_list|(
name|dst_name
argument_list|,
operator|&
name|dst_tail
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|dst_peer
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
name|string_list_insert
argument_list|(
operator|&
name|dst_ref_index
argument_list|,
name|dst_peer
operator|->
name|name
argument_list|)
operator|->
name|util
operator|=
name|dst_peer
expr_stmt|;
block|}
name|dst_peer
operator|->
name|peer_ref
operator|=
name|copy_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|dst_peer
operator|->
name|force
operator|=
name|pat
operator|->
name|force
expr_stmt|;
name|free_name
label|:
name|free
argument_list|(
name|dst_name
argument_list|)
expr_stmt|;
block|}
name|string_list_clear
argument_list|(
operator|&
name|dst_ref_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MATCH_REFS_FOLLOW_TAGS
condition|)
name|add_missing_tags
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|&
name|dst_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_prune
condition|)
block|{
name|struct
name|string_list
name|src_ref_index
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
comment|/* check for missing refs on the remote */
for|for
control|(
name|ref
operator|=
operator|*
name|dst
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|src_name
decl_stmt|;
if|if
condition|(
name|ref
operator|->
name|peer_ref
condition|)
comment|/* We're already sending something to this ref. */
continue|continue;
name|src_name
operator|=
name|get_ref_match
argument_list|(
name|rs
argument_list|,
name|nr_refspec
argument_list|,
name|ref
argument_list|,
name|send_mirror
argument_list|,
name|FROM_DST
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_name
condition|)
block|{
if|if
condition|(
operator|!
name|src_ref_index
operator|.
name|nr
condition|)
name|prepare_ref_index
argument_list|(
operator|&
name|src_ref_index
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|string_list_has_string
argument_list|(
operator|&
name|src_ref_index
argument_list|,
name|src_name
argument_list|)
condition|)
name|ref
operator|->
name|peer_ref
operator|=
name|alloc_delete_ref
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|src_name
argument_list|)
expr_stmt|;
block|}
block|}
name|string_list_clear
argument_list|(
operator|&
name|src_ref_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|set_ref_status_for_push
name|void
name|set_ref_status_for_push
parameter_list|(
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
name|int
name|send_mirror
parameter_list|,
name|int
name|force_update
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|int
name|force_ref_update
init|=
name|ref
operator|->
name|force
operator|||
name|force_update
decl_stmt|;
if|if
condition|(
name|ref
operator|->
name|peer_ref
condition|)
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|send_mirror
condition|)
continue|continue;
name|ref
operator|->
name|deletion
operator|=
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|->
name|deletion
operator|&&
operator|!
name|hashcmp
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|ref
operator|->
name|new_sha1
argument_list|)
condition|)
block|{
name|ref
operator|->
name|status
operator|=
name|REF_STATUS_UPTODATE
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Decide whether an individual refspec A:B can be 		 * pushed.  The push will succeed if any of the 		 * following are true: 		 * 		 * (1) the remote reference B does not exist 		 * 		 * (2) the remote reference B is being removed (i.e., 		 *     pushing :B where no source is specified) 		 * 		 * (3) the destination is not under refs/tags/, and 		 *     if the old and new value is a commit, the new 		 *     is a descendant of the old. 		 * 		 * (4) it is forced using the +A:B notation, or by 		 *     passing the --force argument 		 */
if|if
condition|(
operator|!
name|ref
operator|->
name|deletion
operator|&&
operator|!
name|is_null_sha1
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
name|int
name|why
init|=
literal|0
decl_stmt|;
comment|/* why would this push require --force? */
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|"refs/tags/"
argument_list|)
condition|)
name|why
operator|=
name|REF_STATUS_REJECT_ALREADY_EXISTS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|has_sha1_file
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
name|why
operator|=
name|REF_STATUS_REJECT_FETCH_FIRST
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|lookup_commit_reference_gently
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|lookup_commit_reference_gently
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
literal|1
argument_list|)
condition|)
name|why
operator|=
name|REF_STATUS_REJECT_NEEDS_FORCE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ref_newer
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|ref
operator|->
name|old_sha1
argument_list|)
condition|)
name|why
operator|=
name|REF_STATUS_REJECT_NONFASTFORWARD
expr_stmt|;
if|if
condition|(
operator|!
name|force_ref_update
condition|)
name|ref
operator|->
name|status
operator|=
name|why
expr_stmt|;
elseif|else
if|if
condition|(
name|why
condition|)
name|ref
operator|->
name|forced_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|branch_get
name|struct
name|branch
modifier|*
name|branch_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|ret
decl_stmt|;
name|read_config
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
name|ret
operator|=
name|current_branch
expr_stmt|;
else|else
name|ret
operator|=
name|make_branch
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|ret
operator|->
name|remote_name
condition|)
block|{
name|ret
operator|->
name|remote
operator|=
name|remote_get
argument_list|(
name|ret
operator|->
name|remote_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|merge_nr
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ret
operator|->
name|merge
operator|=
name|xcalloc
argument_list|(
name|ret
operator|->
name|merge_nr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
operator|->
name|merge
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ret
operator|->
name|merge_nr
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|->
name|merge
index|[
name|i
index|]
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|ret
operator|->
name|merge
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
operator|=
name|xstrdup
argument_list|(
name|ret
operator|->
name|merge_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_find_tracking
argument_list|(
name|ret
operator|->
name|remote
argument_list|,
name|ret
operator|->
name|merge
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|ret
operator|->
name|remote_name
argument_list|,
literal|"."
argument_list|)
condition|)
name|ret
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|dst
operator|=
name|xstrdup
argument_list|(
name|ret
operator|->
name|merge_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|branch_has_merge_config
name|int
name|branch_has_merge_config
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|)
block|{
return|return
name|branch
operator|&&
operator|!
operator|!
name|branch
operator|->
name|merge
return|;
block|}
end_function
begin_function
DECL|function|branch_merge_matches
name|int
name|branch_merge_matches
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|branch
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|branch
operator|->
name|merge_nr
condition|)
return|return
literal|0
return|;
return|return
name|refname_match
argument_list|(
name|branch
operator|->
name|merge
index|[
name|i
index|]
operator|->
name|src
argument_list|,
name|refname
argument_list|,
name|ref_fetch_rules
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ignore_symref_update
specifier|static
name|int
name|ignore_symref_update
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|if
condition|(
operator|!
name|resolve_ref_unsafe
argument_list|(
name|refname
argument_list|,
name|sha1
argument_list|,
literal|0
argument_list|,
operator|&
name|flag
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* non-existing refs are OK */
return|return
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
return|;
block|}
end_function
begin_function
DECL|function|get_expanded_map
specifier|static
name|struct
name|ref
modifier|*
name|get_expanded_map
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|ref
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ret
decl_stmt|;
name|char
modifier|*
name|expn_name
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|ref
operator|->
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
continue|continue;
comment|/* a dereference item */
if|if
condition|(
name|match_name_with_pattern
argument_list|(
name|refspec
operator|->
name|src
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|refspec
operator|->
name|dst
argument_list|,
operator|&
name|expn_name
argument_list|)
operator|&&
operator|!
name|ignore_symref_update
argument_list|(
name|expn_name
argument_list|)
condition|)
block|{
name|struct
name|ref
modifier|*
name|cpy
init|=
name|copy_ref
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|cpy
operator|->
name|peer_ref
operator|=
name|alloc_ref
argument_list|(
name|expn_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|refspec
operator|->
name|force
condition|)
name|cpy
operator|->
name|peer_ref
operator|->
name|force
operator|=
literal|1
expr_stmt|;
operator|*
name|tail
operator|=
name|cpy
expr_stmt|;
name|tail
operator|=
operator|&
name|cpy
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|find_ref_by_name_abbrev
specifier|static
specifier|const
name|struct
name|ref
modifier|*
name|find_ref_by_name_abbrev
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
name|refname_match
argument_list|(
name|name
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|ref_fetch_rules
argument_list|)
condition|)
return|return
name|ref
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|get_remote_ref
name|struct
name|ref
modifier|*
name|get_remote_ref
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|ref
init|=
name|find_ref_by_name_abbrev
argument_list|(
name|remote_refs
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
return|return
name|NULL
return|;
return|return
name|copy_ref
argument_list|(
name|ref
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_local_ref
specifier|static
name|struct
name|ref
modifier|*
name|get_local_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"refs/"
argument_list|)
condition|)
return|return
name|alloc_ref
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"heads/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"tags/"
argument_list|)
operator|||
operator|!
name|prefixcmp
argument_list|(
name|name
argument_list|,
literal|"remotes/"
argument_list|)
condition|)
return|return
name|alloc_ref_with_prefix
argument_list|(
literal|"refs/"
argument_list|,
literal|5
argument_list|,
name|name
argument_list|)
return|;
return|return
name|alloc_ref_with_prefix
argument_list|(
literal|"refs/heads/"
argument_list|,
literal|11
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|get_fetch_map
name|int
name|get_fetch_map
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
specifier|const
name|struct
name|refspec
modifier|*
name|refspec
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|,
name|int
name|missing_ok
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref_map
decl_stmt|,
modifier|*
modifier|*
name|rmp
decl_stmt|;
if|if
condition|(
name|refspec
operator|->
name|pattern
condition|)
block|{
name|ref_map
operator|=
name|get_expanded_map
argument_list|(
name|remote_refs
argument_list|,
name|refspec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|refspec
operator|->
name|src
index|[
literal|0
index|]
condition|?
name|refspec
operator|->
name|src
else|:
literal|"HEAD"
decl_stmt|;
if|if
condition|(
name|refspec
operator|->
name|exact_sha1
condition|)
block|{
name|ref_map
operator|=
name|alloc_ref
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|get_sha1_hex
argument_list|(
name|name
argument_list|,
name|ref_map
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref_map
operator|=
name|get_remote_ref
argument_list|(
name|remote_refs
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|missing_ok
operator|&&
operator|!
name|ref_map
condition|)
name|die
argument_list|(
literal|"Couldn't find remote ref %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_map
condition|)
block|{
name|ref_map
operator|->
name|peer_ref
operator|=
name|get_local_ref
argument_list|(
name|refspec
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_map
operator|->
name|peer_ref
operator|&&
name|refspec
operator|->
name|force
condition|)
name|ref_map
operator|->
name|peer_ref
operator|->
name|force
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|rmp
operator|=
operator|&
name|ref_map
init|;
operator|*
name|rmp
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|rmp
operator|)
operator|->
name|peer_ref
condition|)
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
operator|(
operator|*
name|rmp
operator|)
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
literal|"refs/"
argument_list|)
operator|||
name|check_refname_format
argument_list|(
operator|(
operator|*
name|rmp
operator|)
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|struct
name|ref
modifier|*
name|ignore
init|=
operator|*
name|rmp
decl_stmt|;
name|error
argument_list|(
literal|"* Ignoring funny ref '%s' locally"
argument_list|,
operator|(
operator|*
name|rmp
operator|)
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|rmp
operator|=
operator|(
operator|*
name|rmp
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ignore
operator|->
name|peer_ref
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|rmp
operator|=
operator|&
operator|(
operator|(
operator|*
name|rmp
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ref_map
condition|)
name|tail_link_ref
argument_list|(
name|ref_map
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|resolve_remote_symref
name|int
name|resolve_remote_symref
parameter_list|(
name|struct
name|ref
modifier|*
name|ref
parameter_list|,
name|struct
name|ref
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ref
operator|->
name|symref
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ref
operator|->
name|symref
argument_list|,
name|list
operator|->
name|name
argument_list|)
condition|)
block|{
name|hashcpy
argument_list|(
name|ref
operator|->
name|old_sha1
argument_list|,
name|list
operator|->
name|old_sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|unmark_and_free
specifier|static
name|void
name|unmark_and_free
parameter_list|(
name|struct
name|commit_list
modifier|*
name|list
parameter_list|,
name|unsigned
name|int
name|mark
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|temp
init|=
name|list
decl_stmt|;
name|temp
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator|&=
operator|~
name|mark
expr_stmt|;
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ref_newer
name|int
name|ref_newer
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|new_sha1
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|old_sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|o
decl_stmt|;
name|struct
name|commit
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|list
decl_stmt|,
modifier|*
name|used
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* 	 * Both new and old must be commit-ish and new is descendant of 	 * old.  Otherwise we require --force. 	 */
name|o
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|old_sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
literal|0
return|;
name|old
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
expr_stmt|;
name|o
operator|=
name|deref_tag
argument_list|(
name|parse_object
argument_list|(
name|new_sha1
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|||
name|o
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
return|return
literal|0
return|;
name|new
operator|=
operator|(
expr|struct
name|commit
operator|*
operator|)
name|o
expr_stmt|;
if|if
condition|(
name|parse_commit
argument_list|(
name|new
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|used
operator|=
name|list
operator|=
name|NULL
expr_stmt|;
name|commit_list_insert
argument_list|(
name|new
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|new
operator|=
name|pop_most_recent_commit
argument_list|(
operator|&
name|list
argument_list|,
name|TMP_MARK
argument_list|)
expr_stmt|;
name|commit_list_insert
argument_list|(
name|new
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|old
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|unmark_and_free
argument_list|(
name|list
argument_list|,
name|TMP_MARK
argument_list|)
expr_stmt|;
name|unmark_and_free
argument_list|(
name|used
argument_list|,
name|TMP_MARK
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function
begin_comment
comment|/*  * Compare a branch with its upstream, and save their differences (number  * of commits) in *num_ours and *num_theirs.  *  * Return 0 if branch has no upstream (no base), -1 if upstream is missing  * (with "gone" base), otherwise 1 (with base).  */
end_comment
begin_function
DECL|function|stat_tracking_info
name|int
name|stat_tracking_info
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|int
modifier|*
name|num_ours
parameter_list|,
name|int
modifier|*
name|num_theirs
parameter_list|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|ours
decl_stmt|,
modifier|*
name|theirs
decl_stmt|;
name|char
name|symmetric
index|[
literal|84
index|]
decl_stmt|;
name|struct
name|rev_info
name|revs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_argv
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|int
name|rev_argc
decl_stmt|;
comment|/* Cannot stat unless we are marked to build on top of somebody else. */
if|if
condition|(
operator|!
name|branch
operator|||
operator|!
name|branch
operator|->
name|merge
operator|||
operator|!
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|||
operator|!
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
condition|)
return|return
literal|0
return|;
comment|/* Cannot stat if what we used to build on no longer exists */
name|base
operator|=
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
expr_stmt|;
if|if
condition|(
name|read_ref
argument_list|(
name|base
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|theirs
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|theirs
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|read_ref
argument_list|(
name|branch
operator|->
name|refname
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|ours
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ours
condition|)
return|return
operator|-
literal|1
return|;
comment|/* are we the same? */
if|if
condition|(
name|theirs
operator|==
name|ours
condition|)
block|{
operator|*
name|num_theirs
operator|=
operator|*
name|num_ours
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Run "rev-list --left-right ours...theirs" internally... */
name|rev_argc
operator|=
literal|0
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
literal|"--left-right"
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
name|symmetric
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
operator|++
index|]
operator|=
literal|"--"
expr_stmt|;
name|rev_argv
index|[
name|rev_argc
index|]
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|symmetric
argument_list|,
name|sha1_to_hex
argument_list|(
name|ours
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symmetric
operator|+
literal|40
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symmetric
operator|+
literal|43
argument_list|,
name|sha1_to_hex
argument_list|(
name|theirs
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
name|rev_argc
argument_list|,
name|rev_argv
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
comment|/* ... and count the commits on each side. */
operator|*
name|num_ours
operator|=
literal|0
expr_stmt|;
operator|*
name|num_theirs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|commit
modifier|*
name|c
init|=
name|get_revision
argument_list|(
operator|&
name|revs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|->
name|object
operator|.
name|flags
operator|&
name|SYMMETRIC_LEFT
condition|)
operator|(
operator|*
name|num_ours
operator|)
operator|++
expr_stmt|;
else|else
operator|(
operator|*
name|num_theirs
operator|)
operator|++
expr_stmt|;
block|}
comment|/* clear object flags smudged by the above traversal */
name|clear_commit_marks
argument_list|(
name|ours
argument_list|,
name|ALL_REV_FLAGS
argument_list|)
expr_stmt|;
name|clear_commit_marks
argument_list|(
name|theirs
argument_list|,
name|ALL_REV_FLAGS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Return true when there is anything to report, otherwise false.  */
end_comment
begin_function
DECL|function|format_tracking_info
name|int
name|format_tracking_info
parameter_list|(
name|struct
name|branch
modifier|*
name|branch
parameter_list|,
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|int
name|ours
decl_stmt|,
name|theirs
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|upstream_is_gone
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|stat_tracking_info
argument_list|(
name|branch
argument_list|,
operator|&
name|ours
argument_list|,
operator|&
name|theirs
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* no base */
return|return
literal|0
return|;
case|case
operator|-
literal|1
case|:
comment|/* with "gone" base */
name|upstream_is_gone
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Nothing to report if neither side has changes. */
if|if
condition|(
operator|!
name|ours
operator|&&
operator|!
name|theirs
condition|)
return|return
literal|0
return|;
comment|/* with base */
break|break;
block|}
name|base
operator|=
name|branch
operator|->
name|merge
index|[
literal|0
index|]
operator|->
name|dst
expr_stmt|;
name|base
operator|=
name|shorten_unambiguous_ref
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|upstream_is_gone
condition|)
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|_
argument_list|(
literal|"Your branch is based on '%s', but the upstream is gone.\n"
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_status_hints
condition|)
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|_
argument_list|(
literal|"  (use \"git branch --unset-upstream\" to fixup)\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|theirs
condition|)
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|Q_
argument_list|(
literal|"Your branch is ahead of '%s' by %d commit.\n"
argument_list|,
literal|"Your branch is ahead of '%s' by %d commits.\n"
argument_list|,
name|ours
argument_list|)
argument_list|,
name|base
argument_list|,
name|ours
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_status_hints
condition|)
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|_
argument_list|(
literal|"  (use \"git push\" to publish your local commits)\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ours
condition|)
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|Q_
argument_list|(
literal|"Your branch is behind '%s' by %d commit, "
literal|"and can be fast-forwarded.\n"
argument_list|,
literal|"Your branch is behind '%s' by %d commits, "
literal|"and can be fast-forwarded.\n"
argument_list|,
name|theirs
argument_list|)
argument_list|,
name|base
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_status_hints
condition|)
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|_
argument_list|(
literal|"  (use \"git pull\" to update your local branch)\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|Q_
argument_list|(
literal|"Your branch and '%s' have diverged,\n"
literal|"and have %d and %d different commit each, "
literal|"respectively.\n"
argument_list|,
literal|"Your branch and '%s' have diverged,\n"
literal|"and have %d and %d different commits each, "
literal|"respectively.\n"
argument_list|,
name|theirs
argument_list|)
argument_list|,
name|base
argument_list|,
name|ours
argument_list|,
name|theirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|advice_status_hints
condition|)
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
name|_
argument_list|(
literal|"  (use \"git pull\" to merge the remote branch into yours)\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|one_local_ref
specifier|static
name|int
name|one_local_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|ref
modifier|*
modifier|*
modifier|*
name|local_tail
init|=
name|cb_data
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* we already know it starts with refs/ to get here */
if|if
condition|(
name|check_refname_format
argument_list|(
name|refname
operator|+
literal|5
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|strlen
argument_list|(
name|refname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ref
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ref
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|refname
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|*
name|local_tail
operator|=
name|ref
expr_stmt|;
operator|*
name|local_tail
operator|=
operator|&
name|ref
operator|->
name|next
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_local_heads
name|struct
name|ref
modifier|*
name|get_local_heads
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|local_refs
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|local_tail
init|=
operator|&
name|local_refs
decl_stmt|;
name|for_each_ref
argument_list|(
name|one_local_ref
argument_list|,
operator|&
name|local_tail
argument_list|)
expr_stmt|;
return|return
name|local_refs
return|;
block|}
end_function
begin_function
DECL|function|guess_remote_head
name|struct
name|ref
modifier|*
name|guess_remote_head
parameter_list|(
specifier|const
name|struct
name|ref
modifier|*
name|head
parameter_list|,
specifier|const
name|struct
name|ref
modifier|*
name|refs
parameter_list|,
name|int
name|all
parameter_list|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|r
decl_stmt|;
name|struct
name|ref
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Some transports support directly peeking at 	 * where HEAD points; if that is the case, then 	 * we don't have to guess. 	 */
if|if
condition|(
name|head
operator|->
name|symref
condition|)
return|return
name|copy_ref
argument_list|(
name|find_ref_by_name
argument_list|(
name|refs
argument_list|,
name|head
operator|->
name|symref
argument_list|)
argument_list|)
return|;
comment|/* If refs/heads/master could be right, it is. */
if|if
condition|(
operator|!
name|all
condition|)
block|{
name|r
operator|=
name|find_ref_by_name
argument_list|(
name|refs
argument_list|,
literal|"refs/heads/master"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
operator|!
name|hashcmp
argument_list|(
name|r
operator|->
name|old_sha1
argument_list|,
name|head
operator|->
name|old_sha1
argument_list|)
condition|)
return|return
name|copy_ref
argument_list|(
name|r
argument_list|)
return|;
block|}
comment|/* Look for another ref that points there */
for|for
control|(
name|r
operator|=
name|refs
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|!=
name|head
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|r
operator|->
name|name
argument_list|,
literal|"refs/heads/"
argument_list|)
operator|&&
operator|!
name|hashcmp
argument_list|(
name|r
operator|->
name|old_sha1
argument_list|,
name|head
operator|->
name|old_sha1
argument_list|)
condition|)
block|{
operator|*
name|tail
operator|=
name|copy_ref
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|&
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|all
condition|)
break|break;
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_struct
DECL|struct|stale_heads_info
struct|struct
name|stale_heads_info
block|{
DECL|member|ref_names
name|struct
name|string_list
modifier|*
name|ref_names
decl_stmt|;
DECL|member|stale_refs_tail
name|struct
name|ref
modifier|*
modifier|*
name|stale_refs_tail
decl_stmt|;
DECL|member|refs
name|struct
name|refspec
modifier|*
name|refs
decl_stmt|;
DECL|member|ref_count
name|int
name|ref_count
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|get_stale_heads_cb
specifier|static
name|int
name|get_stale_heads_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|)
block|{
name|struct
name|stale_heads_info
modifier|*
name|info
init|=
name|cb_data
decl_stmt|;
name|struct
name|refspec
name|query
decl_stmt|;
name|memset
argument_list|(
operator|&
name|query
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refspec
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|.
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|refname
expr_stmt|;
if|if
condition|(
name|query_refspecs
argument_list|(
name|info
operator|->
name|refs
argument_list|,
name|info
operator|->
name|ref_count
argument_list|,
operator|&
name|query
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* No matches */
comment|/* 	 * If we did find a suitable refspec and it's not a symref and 	 * it's not in the list of refs that currently exist in that 	 * remote we consider it to be stale. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|flags
operator|&
name|REF_ISSYMREF
operator|)
operator|||
name|string_list_has_string
argument_list|(
name|info
operator|->
name|ref_names
argument_list|,
name|query
operator|.
name|src
argument_list|)
operator|)
condition|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|make_linked_ref
argument_list|(
name|refname
argument_list|,
operator|&
name|info
operator|->
name|stale_refs_tail
argument_list|)
decl_stmt|;
name|hashcpy
argument_list|(
name|ref
operator|->
name|new_sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|query
operator|.
name|src
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_stale_heads
name|struct
name|ref
modifier|*
name|get_stale_heads
parameter_list|(
name|struct
name|refspec
modifier|*
name|refs
parameter_list|,
name|int
name|ref_count
parameter_list|,
name|struct
name|ref
modifier|*
name|fetch_map
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|,
modifier|*
name|stale_refs
init|=
name|NULL
decl_stmt|;
name|struct
name|string_list
name|ref_names
init|=
name|STRING_LIST_INIT_NODUP
decl_stmt|;
name|struct
name|stale_heads_info
name|info
decl_stmt|;
name|info
operator|.
name|ref_names
operator|=
operator|&
name|ref_names
expr_stmt|;
name|info
operator|.
name|stale_refs_tail
operator|=
operator|&
name|stale_refs
expr_stmt|;
name|info
operator|.
name|refs
operator|=
name|refs
expr_stmt|;
name|info
operator|.
name|ref_count
operator|=
name|ref_count
expr_stmt|;
for|for
control|(
name|ref
operator|=
name|fetch_map
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
name|string_list_append
argument_list|(
operator|&
name|ref_names
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|sort_string_list
argument_list|(
operator|&
name|ref_names
argument_list|)
expr_stmt|;
name|for_each_ref
argument_list|(
name|get_stale_heads_cb
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|ref_names
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|stale_refs
return|;
block|}
end_function
end_unit
