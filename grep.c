begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"grep.h"
end_include
begin_include
include|#
directive|include
file|"userdiff.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_function
DECL|function|append_header_grep_pattern
name|void
name|append_header_grep_pattern
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|enum
name|grep_header_field
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|pattern
operator|=
name|pat
expr_stmt|;
name|p
operator|->
name|origin
operator|=
literal|"header"
expr_stmt|;
name|p
operator|->
name|no
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|token
operator|=
name|GREP_PATTERN_HEAD
expr_stmt|;
name|p
operator|->
name|field
operator|=
name|field
expr_stmt|;
operator|*
name|opt
operator|->
name|header_tail
operator|=
name|p
expr_stmt|;
name|opt
operator|->
name|header_tail
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append_grep_pattern
name|void
name|append_grep_pattern
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|no
parameter_list|,
name|enum
name|grep_pat_token
name|t
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|pattern
operator|=
name|pat
expr_stmt|;
name|p
operator|->
name|origin
operator|=
name|origin
expr_stmt|;
name|p
operator|->
name|no
operator|=
name|no
expr_stmt|;
name|p
operator|->
name|token
operator|=
name|t
expr_stmt|;
operator|*
name|opt
operator|->
name|pattern_tail
operator|=
name|p
expr_stmt|;
name|opt
operator|->
name|pattern_tail
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_opt_dup
name|struct
name|grep_opt
modifier|*
name|grep_opt_dup
parameter_list|(
specifier|const
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|pat
decl_stmt|;
name|struct
name|grep_opt
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|grep_opt
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|ret
operator|=
operator|*
name|opt
expr_stmt|;
name|ret
operator|->
name|pattern_list
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|pattern_tail
operator|=
operator|&
name|ret
operator|->
name|pattern_list
expr_stmt|;
for|for
control|(
name|pat
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|pat
operator|!=
name|NULL
condition|;
name|pat
operator|=
name|pat
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pat
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
condition|)
name|append_header_grep_pattern
argument_list|(
name|ret
argument_list|,
name|pat
operator|->
name|field
argument_list|,
name|pat
operator|->
name|pattern
argument_list|)
expr_stmt|;
else|else
name|append_grep_pattern
argument_list|(
name|ret
argument_list|,
name|pat
operator|->
name|pattern
argument_list|,
name|pat
operator|->
name|origin
argument_list|,
name|pat
operator|->
name|no
argument_list|,
name|pat
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|compile_regexp
specifier|static
name|void
name|compile_regexp
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|p
operator|->
name|word_regexp
operator|=
name|opt
operator|->
name|word_regexp
expr_stmt|;
name|p
operator|->
name|ignore_case
operator|=
name|opt
operator|->
name|ignore_case
expr_stmt|;
name|p
operator|->
name|fixed
operator|=
name|opt
operator|->
name|fixed
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fixed
condition|)
return|return;
name|err
operator|=
name|regcomp
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|p
operator|->
name|pattern
argument_list|,
name|opt
operator|->
name|regflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|where
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|no
condition|)
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"In '%s' at %d, "
argument_list|,
name|p
operator|->
name|origin
argument_list|,
name|p
operator|->
name|no
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|origin
condition|)
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"%s, "
argument_list|,
name|p
operator|->
name|origin
argument_list|)
expr_stmt|;
else|else
name|where
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|regerror
argument_list|(
name|err
argument_list|,
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|errbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"%s'%s': %s"
argument_list|,
name|where
argument_list|,
name|p
operator|->
name|pattern
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function_decl
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_or
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|compile_pattern_atom
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_atom
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|x
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|node
operator|=
name|GREP_NODE_ATOM
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|atom
operator|=
name|p
expr_stmt|;
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
name|x
return|;
case|case
name|GREP_OPEN_PAREN
case|:
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|x
operator|=
name|compile_pattern_or
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|list
operator|||
operator|(
operator|*
name|list
operator|)
operator|->
name|token
operator|!=
name|GREP_CLOSE_PAREN
condition|)
name|die
argument_list|(
literal|"unmatched parenthesis"
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
return|return
name|x
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_function
DECL|function|compile_pattern_not
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_not
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_NOT
case|:
if|if
condition|(
operator|!
name|p
operator|->
name|next
condition|)
name|die
argument_list|(
literal|"--not not followed by pattern expression"
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|x
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|node
operator|=
name|GREP_NODE_NOT
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|unary
operator|=
name|compile_pattern_not
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|->
name|u
operator|.
name|unary
condition|)
name|die
argument_list|(
literal|"--not followed by non pattern expression"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
default|default:
return|return
name|compile_pattern_atom
argument_list|(
name|list
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|compile_pattern_and
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_and
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|x
operator|=
name|compile_pattern_not
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|token
operator|==
name|GREP_AND
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|next
condition|)
name|die
argument_list|(
literal|"--and not followed by pattern expression"
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|y
operator|=
name|compile_pattern_and
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|y
condition|)
name|die
argument_list|(
literal|"--and not followed by pattern expression"
argument_list|)
expr_stmt|;
name|z
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|node
operator|=
name|GREP_NODE_AND
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|=
name|y
expr_stmt|;
return|return
name|z
return|;
block|}
return|return
name|x
return|;
block|}
end_function
begin_function
DECL|function|compile_pattern_or
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_or
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|x
operator|=
name|compile_pattern_and
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
name|x
operator|&&
name|p
operator|&&
name|p
operator|->
name|token
operator|!=
name|GREP_CLOSE_PAREN
condition|)
block|{
name|y
operator|=
name|compile_pattern_or
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|y
condition|)
name|die
argument_list|(
literal|"not a pattern expression %s"
argument_list|,
name|p
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|z
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|node
operator|=
name|GREP_NODE_OR
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|=
name|y
expr_stmt|;
return|return
name|z
return|;
block|}
return|return
name|x
return|;
block|}
end_function
begin_function
DECL|function|compile_pattern_expr
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_expr
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
return|return
name|compile_pattern_or
argument_list|(
name|list
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|compile_grep_patterns
name|void
name|compile_grep_patterns
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|header_expr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|header_list
condition|)
block|{
name|p
operator|=
name|opt
operator|->
name|header_list
expr_stmt|;
name|header_expr
operator|=
name|compile_pattern_expr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|die
argument_list|(
literal|"incomplete pattern expression: %s"
argument_list|,
name|p
operator|->
name|pattern
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|header_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|compile_regexp
argument_list|(
name|p
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|opt
operator|->
name|extended
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|compile_regexp
argument_list|(
name|p
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|opt
operator|->
name|extended
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|opt
operator|->
name|all_match
operator|||
name|header_expr
condition|)
name|opt
operator|->
name|extended
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|opt
operator|->
name|extended
condition|)
return|return;
comment|/* Then bundle them up in an expression. 	 * A classic recursive descent parser would do. 	 */
name|p
operator|=
name|opt
operator|->
name|pattern_list
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|opt
operator|->
name|pattern_expression
operator|=
name|compile_pattern_expr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|die
argument_list|(
literal|"incomplete pattern expression: %s"
argument_list|,
name|p
operator|->
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header_expr
condition|)
return|return;
if|if
condition|(
name|opt
operator|->
name|pattern_expression
condition|)
block|{
name|struct
name|grep_expr
modifier|*
name|z
decl_stmt|;
name|z
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|node
operator|=
name|GREP_NODE_OR
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|=
name|opt
operator|->
name|pattern_expression
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|=
name|header_expr
expr_stmt|;
name|opt
operator|->
name|pattern_expression
operator|=
name|z
expr_stmt|;
block|}
else|else
block|{
name|opt
operator|->
name|pattern_expression
operator|=
name|header_expr
expr_stmt|;
block|}
name|opt
operator|->
name|all_match
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_pattern_expr
specifier|static
name|void
name|free_pattern_expr
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|x
operator|->
name|node
condition|)
block|{
case|case
name|GREP_NODE_ATOM
case|:
break|break;
case|case
name|GREP_NODE_NOT
case|:
name|free_pattern_expr
argument_list|(
name|x
operator|->
name|u
operator|.
name|unary
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_AND
case|:
case|case
name|GREP_NODE_OR
case|:
name|free_pattern_expr
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|)
expr_stmt|;
name|free_pattern_expr
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_grep_patterns
name|void
name|free_grep_patterns
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|n
control|)
block|{
name|n
operator|=
name|p
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|regfree
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|opt
operator|->
name|extended
condition|)
return|return;
name|free_pattern_expr
argument_list|(
name|opt
operator|->
name|pattern_expression
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|end_of_line
specifier|static
name|char
modifier|*
name|end_of_line
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|unsigned
name|long
modifier|*
name|left
parameter_list|)
block|{
name|unsigned
name|long
name|l
init|=
operator|*
name|left
decl_stmt|;
while|while
condition|(
name|l
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|left
operator|=
name|l
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function
begin_function
DECL|function|word_char
specifier|static
name|int
name|word_char
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'_'
return|;
block|}
end_function
begin_function
DECL|function|output_color
specifier|static
name|void
name|output_color
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|color
parameter_list|)
block|{
if|if
condition|(
name|opt
operator|->
name|color
operator|&&
name|color
operator|&&
name|color
index|[
literal|0
index|]
condition|)
block|{
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|color
argument_list|,
name|strlen
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|GIT_COLOR_RESET
argument_list|,
name|strlen
argument_list|(
name|GIT_COLOR_RESET
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_sep
specifier|static
name|void
name|output_sep
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
name|sign
parameter_list|)
block|{
if|if
condition|(
name|opt
operator|->
name|null_following_name
condition|)
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|output_color
argument_list|(
name|opt
argument_list|,
operator|&
name|sign
argument_list|,
literal|1
argument_list|,
name|opt
operator|->
name|color_sep
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_name
specifier|static
name|void
name|show_name
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|opt
operator|->
name|null_following_name
condition|?
literal|"\0"
else|:
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fixmatch
specifier|static
name|int
name|fixmatch
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|int
name|ignore_case
parameter_list|,
name|regmatch_t
modifier|*
name|match
parameter_list|)
block|{
name|char
modifier|*
name|hit
decl_stmt|;
if|if
condition|(
name|ignore_case
condition|)
name|hit
operator|=
name|strcasestr
argument_list|(
name|line
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
else|else
name|hit
operator|=
name|strstr
argument_list|(
name|line
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hit
condition|)
block|{
name|match
operator|->
name|rm_so
operator|=
name|match
operator|->
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|REG_NOMATCH
return|;
block|}
else|else
block|{
name|match
operator|->
name|rm_so
operator|=
name|hit
operator|-
name|line
expr_stmt|;
name|match
operator|->
name|rm_eo
operator|=
name|match
operator|->
name|rm_so
operator|+
name|strlen
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|strip_timestamp
specifier|static
name|int
name|strip_timestamp
parameter_list|(
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
modifier|*
name|eol_p
parameter_list|)
block|{
name|char
modifier|*
name|eol
init|=
operator|*
name|eol_p
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
name|bol
operator|<
operator|--
name|eol
condition|)
block|{
if|if
condition|(
operator|*
name|eol
operator|!=
literal|'>'
condition|)
continue|continue;
operator|*
name|eol_p
operator|=
operator|++
name|eol
expr_stmt|;
name|ch
operator|=
operator|*
name|eol
expr_stmt|;
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ch
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_struct
specifier|static
struct|struct
block|{
DECL|member|field
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
block|}
DECL|variable|header_field
name|header_field
index|[]
init|=
block|{
block|{
literal|"author "
block|,
literal|7
block|}
block|,
block|{
literal|"committer "
block|,
literal|10
block|}
block|, }
struct|;
end_struct
begin_function
DECL|function|match_one_pattern
specifier|static
name|int
name|match_one_pattern
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|regmatch_t
modifier|*
name|pmatch
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|int
name|hit
init|=
literal|0
decl_stmt|;
name|int
name|saved_ch
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|bol
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|token
operator|!=
name|GREP_PATTERN
operator|)
operator|&&
operator|(
operator|(
name|p
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
operator|)
operator|!=
operator|(
name|ctx
operator|==
name|GREP_CONTEXT_HEAD
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
condition|)
block|{
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|field
operator|<
name|ARRAY_SIZE
argument_list|(
name|header_field
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|=
name|header_field
index|[
name|p
operator|->
name|field
index|]
operator|.
name|field
expr_stmt|;
name|len
operator|=
name|header_field
index|[
name|p
operator|->
name|field
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bol
argument_list|,
name|field
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|bol
operator|+=
name|len
expr_stmt|;
name|saved_ch
operator|=
name|strip_timestamp
argument_list|(
name|bol
argument_list|,
operator|&
name|eol
argument_list|)
expr_stmt|;
block|}
name|again
label|:
if|if
condition|(
name|p
operator|->
name|fixed
condition|)
name|hit
operator|=
operator|!
name|fixmatch
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
name|bol
argument_list|,
name|p
operator|->
name|ignore_case
argument_list|,
name|pmatch
argument_list|)
expr_stmt|;
else|else
name|hit
operator|=
operator|!
name|regexec
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|bol
argument_list|,
literal|1
argument_list|,
name|pmatch
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit
operator|&&
name|p
operator|->
name|word_regexp
condition|)
block|{
if|if
condition|(
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|<
literal|0
operator|)
operator|||
operator|(
name|eol
operator|-
name|bol
operator|)
operator|<
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|||
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|<
literal|0
operator|)
operator|||
operator|(
name|eol
operator|-
name|bol
operator|)
operator|<
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
condition|)
name|die
argument_list|(
literal|"regexp returned nonsense"
argument_list|)
expr_stmt|;
comment|/* Match beginning must be either beginning of the 		 * line, or at word boundary (i.e. the last char must 		 * not be a word char).  Similarly, match end must be 		 * either end of the line, or at word boundary 		 * (i.e. the next char must not be a word char). 		 */
if|if
condition|(
operator|(
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
operator|)
operator|||
operator|!
name|word_char
argument_list|(
name|bol
index|[
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
operator|(
name|eol
operator|-
name|bol
operator|)
operator|)
operator|||
operator|!
name|word_char
argument_list|(
name|bol
index|[
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
index|]
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|hit
operator|=
literal|0
expr_stmt|;
comment|/* Words consist of at least one character. */
if|if
condition|(
name|pmatch
operator|->
name|rm_so
operator|==
name|pmatch
operator|->
name|rm_eo
condition|)
name|hit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hit
operator|&&
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+
name|bol
operator|+
literal|1
operator|<
name|eol
condition|)
block|{
comment|/* There could be more than one match on the 			 * line, and the first match might not be 			 * strict word match.  But later ones could be! 			 * Forward to the next possible start, i.e. the 			 * next position following a non-word char. 			 */
name|bol
operator|=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+
name|bol
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|word_char
argument_list|(
name|bol
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|bol
operator|<
name|eol
condition|)
name|bol
operator|++
expr_stmt|;
name|eflags
operator||=
name|REG_NOTBOL
expr_stmt|;
if|if
condition|(
name|bol
operator|<
name|eol
condition|)
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
operator|&&
name|saved_ch
condition|)
operator|*
name|eol
operator|=
name|saved_ch
expr_stmt|;
if|if
condition|(
name|hit
condition|)
block|{
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+=
name|bol
operator|-
name|start
expr_stmt|;
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|+=
name|bol
operator|-
name|start
expr_stmt|;
block|}
return|return
name|hit
return|;
block|}
end_function
begin_function
DECL|function|match_expr_eval
specifier|static
name|int
name|match_expr_eval
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
name|regmatch_t
name|match
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|die
argument_list|(
literal|"Not a valid grep expression"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
operator|->
name|node
condition|)
block|{
case|case
name|GREP_NODE_ATOM
case|:
name|h
operator|=
name|match_one_pattern
argument_list|(
name|x
operator|->
name|u
operator|.
name|atom
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_NOT
case|:
name|h
operator|=
operator|!
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|unary
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_AND
case|:
if|if
condition|(
operator|!
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|h
operator|=
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_OR
case|:
if|if
condition|(
operator|!
name|collect_hits
condition|)
return|return
operator|(
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
operator|||
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|h
operator|=
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|->
name|hit
operator||=
name|h
expr_stmt|;
name|h
operator||=
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"Unexpected node type (internal error) %d"
argument_list|,
name|x
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collect_hits
condition|)
name|x
operator|->
name|hit
operator||=
name|h
expr_stmt|;
return|return
name|h
return|;
block|}
end_function
begin_function
DECL|function|match_expr
specifier|static
name|int
name|match_expr
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|struct
name|grep_expr
modifier|*
name|x
init|=
name|opt
operator|->
name|pattern_expression
decl_stmt|;
return|return
name|match_expr_eval
argument_list|(
name|x
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|collect_hits
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|match_line
specifier|static
name|int
name|match_line
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|regmatch_t
name|match
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|extended
condition|)
return|return
name|match_expr
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|collect_hits
argument_list|)
return|;
comment|/* we do not call with collect_hits without being extended */
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|match_one_pattern
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|match_next_pattern
specifier|static
name|int
name|match_next_pattern
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|regmatch_t
modifier|*
name|pmatch
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|regmatch_t
name|match
decl_stmt|;
if|if
condition|(
operator|!
name|match_one_pattern
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
name|eflags
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|match
operator|.
name|rm_so
operator|<
literal|0
operator|||
name|match
operator|.
name|rm_eo
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pmatch
operator|->
name|rm_so
operator|>=
literal|0
operator|&&
name|pmatch
operator|->
name|rm_eo
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|rm_so
operator|>
name|pmatch
operator|->
name|rm_so
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|match
operator|.
name|rm_so
operator|==
name|pmatch
operator|->
name|rm_so
operator|&&
name|match
operator|.
name|rm_eo
operator|<
name|pmatch
operator|->
name|rm_eo
condition|)
return|return
literal|1
return|;
block|}
name|pmatch
operator|->
name|rm_so
operator|=
name|match
operator|.
name|rm_so
expr_stmt|;
name|pmatch
operator|->
name|rm_eo
operator|=
name|match
operator|.
name|rm_eo
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|next_match
specifier|static
name|int
name|next_match
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|regmatch_t
modifier|*
name|pmatch
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|int
name|hit
init|=
literal|0
decl_stmt|;
name|pmatch
operator|->
name|rm_so
operator|=
name|pmatch
operator|->
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bol
operator|<
name|eol
condition|)
block|{
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|hit
operator||=
name|match_next_pattern
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|pmatch
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
return|return
name|hit
return|;
block|}
end_function
begin_function
DECL|function|show_line
specifier|static
name|void
name|show_line
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|lno
parameter_list|,
name|char
name|sign
parameter_list|)
block|{
name|int
name|rest
init|=
name|eol
operator|-
name|bol
decl_stmt|;
name|char
modifier|*
name|line_color
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|pre_context
operator|||
name|opt
operator|->
name|post_context
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|last_shown
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|show_hunk_mark
condition|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|,
name|opt
operator|->
name|color_sep
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lno
operator|>
name|opt
operator|->
name|last_shown
operator|+
literal|1
condition|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|,
name|opt
operator|->
name|color_sep
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|opt
operator|->
name|last_shown
operator|=
name|lno
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|pathname
condition|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|output_sep
argument_list|(
name|opt
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|->
name|linenum
condition|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|opt
operator|->
name|color_lineno
argument_list|)
expr_stmt|;
name|output_sep
argument_list|(
name|opt
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|->
name|color
condition|)
block|{
name|regmatch_t
name|match
decl_stmt|;
name|enum
name|grep_context
name|ctx
init|=
name|GREP_CONTEXT_BODY
decl_stmt|;
name|int
name|ch
init|=
operator|*
name|eol
decl_stmt|;
name|int
name|eflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sign
operator|==
literal|':'
condition|)
name|line_color
operator|=
name|opt
operator|->
name|color_selected
expr_stmt|;
elseif|else
if|if
condition|(
name|sign
operator|==
literal|'-'
condition|)
name|line_color
operator|=
name|opt
operator|->
name|color_context
expr_stmt|;
elseif|else
if|if
condition|(
name|sign
operator|==
literal|'='
condition|)
name|line_color
operator|=
name|opt
operator|->
name|color_function
expr_stmt|;
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|next_match
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
name|eflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|rm_so
operator|==
name|match
operator|.
name|rm_eo
condition|)
break|break;
name|output_color
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|match
operator|.
name|rm_so
argument_list|,
name|line_color
argument_list|)
expr_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|bol
operator|+
name|match
operator|.
name|rm_so
argument_list|,
name|match
operator|.
name|rm_eo
operator|-
name|match
operator|.
name|rm_so
argument_list|,
name|opt
operator|->
name|color_match
argument_list|)
expr_stmt|;
name|bol
operator|+=
name|match
operator|.
name|rm_eo
expr_stmt|;
name|rest
operator|-=
name|match
operator|.
name|rm_eo
expr_stmt|;
name|eflags
operator|=
name|REG_NOTBOL
expr_stmt|;
block|}
operator|*
name|eol
operator|=
name|ch
expr_stmt|;
block|}
name|output_color
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|rest
argument_list|,
name|line_color
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|match_funcname
specifier|static
name|int
name|match_funcname
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|)
block|{
name|xdemitconf_t
modifier|*
name|xecfg
init|=
name|opt
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|xecfg
operator|&&
name|xecfg
operator|->
name|find_func
condition|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
return|return
name|xecfg
operator|->
name|find_func
argument_list|(
name|bol
argument_list|,
name|eol
operator|-
name|bol
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
name|xecfg
operator|->
name|find_func_priv
argument_list|)
operator|>=
literal|0
return|;
block|}
if|if
condition|(
name|bol
operator|==
name|eol
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|bol
argument_list|)
operator|||
operator|*
name|bol
operator|==
literal|'_'
operator|||
operator|*
name|bol
operator|==
literal|'$'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|show_funcname_line
specifier|static
name|void
name|show_funcname_line
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|unsigned
name|lno
parameter_list|)
block|{
while|while
condition|(
name|bol
operator|>
name|buf
condition|)
block|{
name|char
modifier|*
name|eol
init|=
operator|--
name|bol
decl_stmt|;
while|while
condition|(
name|bol
operator|>
name|buf
operator|&&
name|bol
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|bol
operator|--
expr_stmt|;
name|lno
operator|--
expr_stmt|;
if|if
condition|(
name|lno
operator|<=
name|opt
operator|->
name|last_shown
condition|)
break|break;
if|if
condition|(
name|match_funcname
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|)
condition|)
block|{
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|name
argument_list|,
name|lno
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|show_pre_context
specifier|static
name|void
name|show_pre_context
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|unsigned
name|lno
parameter_list|)
block|{
name|unsigned
name|cur
init|=
name|lno
decl_stmt|,
name|from
init|=
literal|1
decl_stmt|,
name|funcname_lno
init|=
literal|0
decl_stmt|;
name|int
name|funcname_needed
init|=
name|opt
operator|->
name|funcname
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|pre_context
operator|<
name|lno
condition|)
name|from
operator|=
name|lno
operator|-
name|opt
operator|->
name|pre_context
expr_stmt|;
if|if
condition|(
name|from
operator|<=
name|opt
operator|->
name|last_shown
condition|)
name|from
operator|=
name|opt
operator|->
name|last_shown
operator|+
literal|1
expr_stmt|;
comment|/* Rewind. */
while|while
condition|(
name|bol
operator|>
name|buf
operator|&&
name|cur
operator|>
name|from
condition|)
block|{
name|char
modifier|*
name|eol
init|=
operator|--
name|bol
decl_stmt|;
while|while
condition|(
name|bol
operator|>
name|buf
operator|&&
name|bol
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|bol
operator|--
expr_stmt|;
name|cur
operator|--
expr_stmt|;
if|if
condition|(
name|funcname_needed
operator|&&
name|match_funcname
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|)
condition|)
block|{
name|funcname_lno
operator|=
name|cur
expr_stmt|;
name|funcname_needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* We need to look even further back to find a function signature. */
if|if
condition|(
name|opt
operator|->
name|funcname
operator|&&
name|funcname_needed
condition|)
name|show_funcname_line
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|bol
argument_list|,
name|cur
argument_list|)
expr_stmt|;
comment|/* Back forward. */
while|while
condition|(
name|cur
operator|<
name|lno
condition|)
block|{
name|char
modifier|*
name|eol
init|=
name|bol
decl_stmt|,
name|sign
init|=
operator|(
name|cur
operator|==
name|funcname_lno
operator|)
condition|?
literal|'='
else|:
literal|'-'
decl_stmt|;
while|while
condition|(
operator|*
name|eol
operator|!=
literal|'\n'
condition|)
name|eol
operator|++
expr_stmt|;
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|name
argument_list|,
name|cur
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|bol
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|should_lookahead
specifier|static
name|int
name|should_lookahead
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|extended
condition|)
return|return
literal|0
return|;
comment|/* punt for too complex stuff */
if|if
condition|(
name|opt
operator|->
name|invert
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|token
operator|!=
name|GREP_PATTERN
condition|)
return|return
literal|0
return|;
comment|/* punt for "header only" and stuff */
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|look_ahead
specifier|static
name|int
name|look_ahead
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|unsigned
name|long
modifier|*
name|left_p
parameter_list|,
name|unsigned
modifier|*
name|lno_p
parameter_list|,
name|char
modifier|*
modifier|*
name|bol_p
parameter_list|)
block|{
name|unsigned
name|lno
init|=
operator|*
name|lno_p
decl_stmt|;
name|char
modifier|*
name|bol
init|=
operator|*
name|bol_p
decl_stmt|;
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|last_bol
decl_stmt|;
name|regoff_t
name|earliest
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|hit
decl_stmt|;
name|regmatch_t
name|m
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|fixed
condition|)
name|hit
operator|=
operator|!
name|fixmatch
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
name|bol
argument_list|,
name|p
operator|->
name|ignore_case
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|REG_STARTEND
name|m
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|m
operator|.
name|rm_eo
operator|=
operator|*
name|left_p
expr_stmt|;
name|hit
operator|=
operator|!
name|regexec
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|bol
argument_list|,
literal|1
argument_list|,
operator|&
name|m
argument_list|,
name|REG_STARTEND
argument_list|)
expr_stmt|;
else|#
directive|else
name|hit
operator|=
operator|!
name|regexec
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|bol
argument_list|,
literal|1
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|hit
operator|||
name|m
operator|.
name|rm_so
operator|<
literal|0
operator|||
name|m
operator|.
name|rm_eo
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|earliest
operator|<
literal|0
operator|||
name|m
operator|.
name|rm_so
operator|<
name|earliest
condition|)
name|earliest
operator|=
name|m
operator|.
name|rm_so
expr_stmt|;
block|}
if|if
condition|(
name|earliest
operator|<
literal|0
condition|)
block|{
operator|*
name|bol_p
operator|=
name|bol
operator|+
operator|*
name|left_p
expr_stmt|;
operator|*
name|left_p
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|sp
operator|=
name|bol
operator|+
name|earliest
init|;
name|bol
operator|<
name|sp
operator|&&
name|sp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
name|sp
operator|--
control|)
empty_stmt|;
comment|/* find the beginning of the line */
name|last_bol
operator|=
name|sp
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|bol
init|;
name|sp
operator|<
name|last_bol
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\n'
condition|)
name|lno
operator|++
expr_stmt|;
block|}
operator|*
name|left_p
operator|-=
name|last_bol
operator|-
name|bol
expr_stmt|;
operator|*
name|bol_p
operator|=
name|last_bol
expr_stmt|;
operator|*
name|lno_p
operator|=
name|lno
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|grep_threads_ok
name|int
name|grep_threads_ok
parameter_list|(
specifier|const
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
comment|/* If this condition is true, then we may use the attribute 	 * machinery in grep_buffer_1. The attribute code is not 	 * thread safe, so we disable the use of threads. 	 */
if|if
condition|(
name|opt
operator|->
name|funcname
operator|&&
operator|!
name|opt
operator|->
name|unmatch_name_only
operator|&&
operator|!
name|opt
operator|->
name|status_only
operator|&&
operator|!
name|opt
operator|->
name|name_only
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|std_output
specifier|static
name|void
name|std_output
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_buffer_1
specifier|static
name|int
name|grep_buffer_1
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|char
modifier|*
name|bol
init|=
name|buf
decl_stmt|;
name|unsigned
name|long
name|left
init|=
name|size
decl_stmt|;
name|unsigned
name|lno
init|=
literal|1
decl_stmt|;
name|unsigned
name|last_hit
init|=
literal|0
decl_stmt|;
name|int
name|binary_match_only
init|=
literal|0
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|int
name|try_lookahead
init|=
literal|0
decl_stmt|;
name|enum
name|grep_context
name|ctx
init|=
name|GREP_CONTEXT_HEAD
decl_stmt|;
name|xdemitconf_t
name|xecfg
decl_stmt|;
if|if
condition|(
operator|!
name|opt
operator|->
name|output
condition|)
name|opt
operator|->
name|output
operator|=
name|std_output
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|last_shown
operator|&&
operator|(
name|opt
operator|->
name|pre_context
operator|||
name|opt
operator|->
name|post_context
operator|)
operator|&&
name|opt
operator|->
name|output
operator|==
name|std_output
condition|)
name|opt
operator|->
name|show_hunk_mark
operator|=
literal|1
expr_stmt|;
name|opt
operator|->
name|last_shown
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opt
operator|->
name|binary
condition|)
block|{
case|case
name|GREP_BINARY_DEFAULT
case|:
if|if
condition|(
name|buffer_is_binary
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
condition|)
name|binary_match_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GREP_BINARY_NOMATCH
case|:
if|if
condition|(
name|buffer_is_binary
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Assume unmatch */
break|break;
case|case
name|GREP_BINARY_TEXT
case|:
break|break;
default|default:
name|die
argument_list|(
literal|"bug: unknown binary handling mode"
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|xecfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xecfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|funcname
operator|&&
operator|!
name|opt
operator|->
name|unmatch_name_only
operator|&&
operator|!
name|opt
operator|->
name|status_only
operator|&&
operator|!
name|opt
operator|->
name|name_only
operator|&&
operator|!
name|binary_match_only
operator|&&
operator|!
name|collect_hits
condition|)
block|{
name|struct
name|userdiff_driver
modifier|*
name|drv
init|=
name|userdiff_find_by_path
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|drv
operator|&&
name|drv
operator|->
name|funcname
operator|.
name|pattern
condition|)
block|{
specifier|const
name|struct
name|userdiff_funcname
modifier|*
name|pe
init|=
operator|&
name|drv
operator|->
name|funcname
decl_stmt|;
name|xdiff_set_find_func
argument_list|(
operator|&
name|xecfg
argument_list|,
name|pe
operator|->
name|pattern
argument_list|,
name|pe
operator|->
name|cflags
argument_list|)
expr_stmt|;
name|opt
operator|->
name|priv
operator|=
operator|&
name|xecfg
expr_stmt|;
block|}
block|}
name|try_lookahead
operator|=
name|should_lookahead
argument_list|(
name|opt
argument_list|)
expr_stmt|;
while|while
condition|(
name|left
condition|)
block|{
name|char
modifier|*
name|eol
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|hit
decl_stmt|;
comment|/* 		 * look_ahead() skips quicly to the line that possibly 		 * has the next hit; don't call it if we need to do 		 * something more than just skipping the current line 		 * in response to an unmatch for the current line.  E.g. 		 * inside a post-context window, we will show the current 		 * line as a context around the previous hit when it 		 * doesn't hit. 		 */
if|if
condition|(
name|try_lookahead
operator|&&
operator|!
operator|(
name|last_hit
operator|&&
name|lno
operator|<=
name|last_hit
operator|+
name|opt
operator|->
name|post_context
operator|)
operator|&&
name|look_ahead
argument_list|(
name|opt
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|lno
argument_list|,
operator|&
name|bol
argument_list|)
condition|)
break|break;
name|eol
operator|=
name|end_of_line
argument_list|(
name|bol
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|eol
expr_stmt|;
operator|*
name|eol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|==
name|GREP_CONTEXT_HEAD
operator|)
operator|&&
operator|(
name|eol
operator|==
name|bol
operator|)
condition|)
name|ctx
operator|=
name|GREP_CONTEXT_BODY
expr_stmt|;
name|hit
operator|=
name|match_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|collect_hits
argument_list|)
expr_stmt|;
operator|*
name|eol
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|collect_hits
condition|)
goto|goto
name|next_line
goto|;
comment|/* "grep -v -e foo -e bla" should list lines 		 * that do not have either, so inversion should 		 * be done outside. 		 */
if|if
condition|(
name|opt
operator|->
name|invert
condition|)
name|hit
operator|=
operator|!
name|hit
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|unmatch_name_only
condition|)
block|{
if|if
condition|(
name|hit
condition|)
return|return
literal|0
return|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|hit
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|status_only
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|opt
operator|->
name|count
condition|)
goto|goto
name|next_line
goto|;
if|if
condition|(
name|binary_match_only
condition|)
block|{
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"Binary file "
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|" matches\n"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|opt
operator|->
name|name_only
condition|)
block|{
name|show_name
argument_list|(
name|opt
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Hit at this line.  If we haven't shown the 			 * pre-context lines, we would need to show them. 			 */
if|if
condition|(
name|opt
operator|->
name|pre_context
condition|)
name|show_pre_context
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|bol
argument_list|,
name|lno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|funcname
condition|)
name|show_funcname_line
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|bol
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|name
argument_list|,
name|lno
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|last_hit
operator|=
name|lno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_hit
operator|&&
name|lno
operator|<=
name|last_hit
operator|+
name|opt
operator|->
name|post_context
condition|)
block|{
comment|/* If the last hit is within the post context, 			 * we need to show this line. 			 */
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|name
argument_list|,
name|lno
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|next_line
label|:
name|bol
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|left
condition|)
break|break;
name|left
operator|--
expr_stmt|;
name|lno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|collect_hits
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opt
operator|->
name|status_only
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opt
operator|->
name|unmatch_name_only
condition|)
block|{
comment|/* We did not see any hit, so we want to show this */
name|show_name
argument_list|(
name|opt
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|xdiff_clear_find_func
argument_list|(
operator|&
name|xecfg
argument_list|)
expr_stmt|;
name|opt
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
comment|/* NEEDSWORK: 	 * The real "grep -c foo *.c" gives many "bar.c:0" lines, 	 * which feels mostly useless but sometimes useful.  Maybe 	 * make it another option?  For now suppress them. 	 */
if|if
condition|(
name|opt
operator|->
name|count
operator|&&
name|count
condition|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|output_sep
argument_list|(
name|opt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%u\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
operator|!
operator|!
name|last_hit
return|;
block|}
end_function
begin_function
DECL|function|clr_hit_marker
specifier|static
name|void
name|clr_hit_marker
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|)
block|{
comment|/* All-hit markers are meaningful only at the very top level 	 * OR node. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|x
operator|->
name|hit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|node
operator|!=
name|GREP_NODE_OR
condition|)
return|return;
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|->
name|hit
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|chk_hit_marker
specifier|static
name|int
name|chk_hit_marker
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|)
block|{
comment|/* Top level nodes have hit markers.  See if they all are hits */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|node
operator|!=
name|GREP_NODE_OR
condition|)
return|return
name|x
operator|->
name|hit
return|;
if|if
condition|(
operator|!
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|->
name|hit
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|grep_buffer
name|int
name|grep_buffer
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
comment|/* 	 * we do not have to do the two-pass grep when we do not check 	 * buffer-wide "all-match". 	 */
if|if
condition|(
operator|!
name|opt
operator|->
name|all_match
condition|)
return|return
name|grep_buffer_1
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Otherwise the toplevel "or" terms hit a bit differently. 	 * We first clear hit markers from them. 	 */
name|clr_hit_marker
argument_list|(
name|opt
operator|->
name|pattern_expression
argument_list|)
expr_stmt|;
name|grep_buffer_1
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chk_hit_marker
argument_list|(
name|opt
operator|->
name|pattern_expression
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|grep_buffer_1
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
end_unit
