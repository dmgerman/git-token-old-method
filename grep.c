begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"grep.h"
end_include
begin_include
include|#
directive|include
file|"userdiff.h"
end_include
begin_include
include|#
directive|include
file|"xdiff-interface.h"
end_include
begin_function_decl
specifier|static
name|int
name|grep_source_load
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|grep_source_is_binary
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|create_grep_pat
specifier|static
name|struct
name|grep_pat
modifier|*
name|create_grep_pat
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|size_t
name|patlen
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|no
parameter_list|,
name|enum
name|grep_pat_token
name|t
parameter_list|,
name|enum
name|grep_header_field
name|field
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|pattern
operator|=
name|xmemdupz
argument_list|(
name|pat
argument_list|,
name|patlen
argument_list|)
expr_stmt|;
name|p
operator|->
name|patternlen
operator|=
name|patlen
expr_stmt|;
name|p
operator|->
name|origin
operator|=
name|origin
expr_stmt|;
name|p
operator|->
name|no
operator|=
name|no
expr_stmt|;
name|p
operator|->
name|token
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|field
operator|=
name|field
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
DECL|function|do_append_grep_pat
specifier|static
name|void
name|do_append_grep_pat
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
modifier|*
name|tail
parameter_list|,
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|)
block|{
operator|*
operator|*
name|tail
operator|=
name|p
expr_stmt|;
operator|*
name|tail
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|grep_pat
modifier|*
name|new_pat
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|p
operator|->
name|pattern
operator|+
name|p
operator|->
name|patternlen
decl_stmt|,
modifier|*
name|nl
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|++
name|len
operator|<=
name|p
operator|->
name|patternlen
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|--
name|cp
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|nl
operator|=
name|cp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|nl
condition|)
break|break;
name|new_pat
operator|=
name|create_grep_pat
argument_list|(
name|nl
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|p
operator|->
name|origin
argument_list|,
name|p
operator|->
name|no
argument_list|,
name|p
operator|->
name|token
argument_list|,
name|p
operator|->
name|field
argument_list|)
expr_stmt|;
name|new_pat
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|next
condition|)
operator|*
name|tail
operator|=
operator|&
name|new_pat
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|new_pat
expr_stmt|;
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|patternlen
operator|-=
name|len
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|append_header_grep_pattern
name|void
name|append_header_grep_pattern
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|enum
name|grep_header_field
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
init|=
name|create_grep_pat
argument_list|(
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|"header"
argument_list|,
literal|0
argument_list|,
name|GREP_PATTERN_HEAD
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
name|GREP_HEADER_REFLOG
condition|)
name|opt
operator|->
name|use_reflog_filter
operator|=
literal|1
expr_stmt|;
name|do_append_grep_pat
argument_list|(
operator|&
name|opt
operator|->
name|header_tail
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append_grep_pattern
name|void
name|append_grep_pattern
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|no
parameter_list|,
name|enum
name|grep_pat_token
name|t
parameter_list|)
block|{
name|append_grep_pat
argument_list|(
name|opt
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|origin
argument_list|,
name|no
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|append_grep_pat
name|void
name|append_grep_pat
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|size_t
name|patlen
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|no
parameter_list|,
name|enum
name|grep_pat_token
name|t
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
init|=
name|create_grep_pat
argument_list|(
name|pat
argument_list|,
name|patlen
argument_list|,
name|origin
argument_list|,
name|no
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|do_append_grep_pat
argument_list|(
operator|&
name|opt
operator|->
name|pattern_tail
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_opt_dup
name|struct
name|grep_opt
modifier|*
name|grep_opt_dup
parameter_list|(
specifier|const
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|pat
decl_stmt|;
name|struct
name|grep_opt
modifier|*
name|ret
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|grep_opt
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|ret
operator|=
operator|*
name|opt
expr_stmt|;
name|ret
operator|->
name|pattern_list
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|pattern_tail
operator|=
operator|&
name|ret
operator|->
name|pattern_list
expr_stmt|;
for|for
control|(
name|pat
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|pat
operator|!=
name|NULL
condition|;
name|pat
operator|=
name|pat
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pat
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
condition|)
name|append_header_grep_pattern
argument_list|(
name|ret
argument_list|,
name|pat
operator|->
name|field
argument_list|,
name|pat
operator|->
name|pattern
argument_list|)
expr_stmt|;
else|else
name|append_grep_pat
argument_list|(
name|ret
argument_list|,
name|pat
operator|->
name|pattern
argument_list|,
name|pat
operator|->
name|patternlen
argument_list|,
name|pat
operator|->
name|origin
argument_list|,
name|pat
operator|->
name|no
argument_list|,
name|pat
operator|->
name|token
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|compile_regexp_failed
specifier|static
name|NORETURN
name|void
name|compile_regexp_failed
parameter_list|(
specifier|const
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|error
parameter_list|)
block|{
name|char
name|where
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|no
condition|)
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"In '%s' at %d, "
argument_list|,
name|p
operator|->
name|origin
argument_list|,
name|p
operator|->
name|no
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|origin
condition|)
name|sprintf
argument_list|(
name|where
argument_list|,
literal|"%s, "
argument_list|,
name|p
operator|->
name|origin
argument_list|)
expr_stmt|;
else|else
name|where
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|die
argument_list|(
literal|"%s'%s': %s"
argument_list|,
name|where
argument_list|,
name|p
operator|->
name|pattern
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|USE_LIBPCRE
end_ifdef
begin_function
DECL|function|compile_pcre_regexp
specifier|static
name|void
name|compile_pcre_regexp
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
name|int
name|erroffset
decl_stmt|;
name|int
name|options
init|=
name|PCRE_MULTILINE
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|ignore_case
condition|)
name|options
operator||=
name|PCRE_CASELESS
expr_stmt|;
name|p
operator|->
name|pcre_regexp
operator|=
name|pcre_compile
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
name|options
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|erroffset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|pcre_regexp
condition|)
name|compile_regexp_failed
argument_list|(
name|p
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|p
operator|->
name|pcre_extra_info
operator|=
name|pcre_study
argument_list|(
name|p
operator|->
name|pcre_regexp
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|pcre_extra_info
operator|&&
name|error
condition|)
name|die
argument_list|(
literal|"%s"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pcrematch
specifier|static
name|int
name|pcrematch
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|regmatch_t
modifier|*
name|match
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|int
name|ovector
index|[
literal|30
index|]
decl_stmt|,
name|ret
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|eflags
operator|&
name|REG_NOTBOL
condition|)
name|flags
operator||=
name|PCRE_NOTBOL
expr_stmt|;
name|ret
operator|=
name|pcre_exec
argument_list|(
name|p
operator|->
name|pcre_regexp
argument_list|,
name|p
operator|->
name|pcre_extra_info
argument_list|,
name|line
argument_list|,
name|eol
operator|-
name|line
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|ovector
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|ovector
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|&&
name|ret
operator|!=
name|PCRE_ERROR_NOMATCH
condition|)
name|die
argument_list|(
literal|"pcre_exec failed with error code %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
name|match
operator|->
name|rm_so
operator|=
name|ovector
index|[
literal|0
index|]
expr_stmt|;
name|match
operator|->
name|rm_eo
operator|=
name|ovector
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|free_pcre_regexp
specifier|static
name|void
name|free_pcre_regexp
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|)
block|{
name|pcre_free
argument_list|(
name|p
operator|->
name|pcre_regexp
argument_list|)
expr_stmt|;
name|pcre_free
argument_list|(
name|p
operator|->
name|pcre_extra_info
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !USE_LIBPCRE */
end_comment
begin_function
DECL|function|compile_pcre_regexp
specifier|static
name|void
name|compile_pcre_regexp
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|die
argument_list|(
literal|"cannot use Perl-compatible regexes when not compiled with USE_LIBPCRE"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pcrematch
specifier|static
name|int
name|pcrematch
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|eol
parameter_list|,
name|regmatch_t
modifier|*
name|match
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|free_pcre_regexp
specifier|static
name|void
name|free_pcre_regexp
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|)
block|{ }
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !USE_LIBPCRE */
end_comment
begin_function
DECL|function|is_fixed
specifier|static
name|int
name|is_fixed
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* regcomp cannot accept patterns with NULs so we 	 * consider any pattern containing a NUL fixed. 	 */
if|if
condition|(
name|memchr
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is_regex_special
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|compile_regexp
specifier|static
name|void
name|compile_regexp
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|p
operator|->
name|word_regexp
operator|=
name|opt
operator|->
name|word_regexp
expr_stmt|;
name|p
operator|->
name|ignore_case
operator|=
name|opt
operator|->
name|ignore_case
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|fixed
operator|||
name|is_fixed
argument_list|(
name|p
operator|->
name|pattern
argument_list|,
name|p
operator|->
name|patternlen
argument_list|)
condition|)
name|p
operator|->
name|fixed
operator|=
literal|1
expr_stmt|;
else|else
name|p
operator|->
name|fixed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fixed
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|regflags
operator|&
name|REG_ICASE
operator|||
name|p
operator|->
name|ignore_case
condition|)
name|p
operator|->
name|kws
operator|=
name|kwsalloc
argument_list|(
name|tolower_trans_tbl
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|kws
operator|=
name|kwsalloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|kwsincr
argument_list|(
name|p
operator|->
name|kws
argument_list|,
name|p
operator|->
name|pattern
argument_list|,
name|p
operator|->
name|patternlen
argument_list|)
expr_stmt|;
name|kwsprep
argument_list|(
name|p
operator|->
name|kws
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opt
operator|->
name|pcre
condition|)
block|{
name|compile_pcre_regexp
argument_list|(
name|p
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|regcomp
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|p
operator|->
name|pattern
argument_list|,
name|opt
operator|->
name|regflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|regerror
argument_list|(
name|err
argument_list|,
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|errbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|compile_regexp_failed
argument_list|(
name|p
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function_decl
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_or
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|compile_pattern_atom
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_atom
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|x
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|node
operator|=
name|GREP_NODE_ATOM
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|atom
operator|=
name|p
expr_stmt|;
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
name|x
return|;
case|case
name|GREP_OPEN_PAREN
case|:
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|x
operator|=
name|compile_pattern_or
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|list
operator|||
operator|(
operator|*
name|list
operator|)
operator|->
name|token
operator|!=
name|GREP_CLOSE_PAREN
condition|)
name|die
argument_list|(
literal|"unmatched parenthesis"
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
return|return
name|x
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function
begin_function
DECL|function|compile_pattern_not
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_not
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_NOT
case|:
if|if
condition|(
operator|!
name|p
operator|->
name|next
condition|)
name|die
argument_list|(
literal|"--not not followed by pattern expression"
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|x
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|node
operator|=
name|GREP_NODE_NOT
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|unary
operator|=
name|compile_pattern_not
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|->
name|u
operator|.
name|unary
condition|)
name|die
argument_list|(
literal|"--not followed by non pattern expression"
argument_list|)
expr_stmt|;
return|return
name|x
return|;
default|default:
return|return
name|compile_pattern_atom
argument_list|(
name|list
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|compile_pattern_and
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_and
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|x
operator|=
name|compile_pattern_not
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|token
operator|==
name|GREP_AND
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|next
condition|)
name|die
argument_list|(
literal|"--and not followed by pattern expression"
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|y
operator|=
name|compile_pattern_and
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|y
condition|)
name|die
argument_list|(
literal|"--and not followed by pattern expression"
argument_list|)
expr_stmt|;
name|z
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|node
operator|=
name|GREP_NODE_AND
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|=
name|y
expr_stmt|;
return|return
name|z
return|;
block|}
return|return
name|x
return|;
block|}
end_function
begin_function
DECL|function|compile_pattern_or
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_or
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|x
operator|=
name|compile_pattern_and
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
name|x
operator|&&
name|p
operator|&&
name|p
operator|->
name|token
operator|!=
name|GREP_CLOSE_PAREN
condition|)
block|{
name|y
operator|=
name|compile_pattern_or
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|y
condition|)
name|die
argument_list|(
literal|"not a pattern expression %s"
argument_list|,
name|p
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|z
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|grep_expr
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|node
operator|=
name|GREP_NODE_OR
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|=
name|x
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|=
name|y
expr_stmt|;
return|return
name|z
return|;
block|}
return|return
name|x
return|;
block|}
end_function
begin_function
DECL|function|compile_pattern_expr
specifier|static
name|struct
name|grep_expr
modifier|*
name|compile_pattern_expr
parameter_list|(
name|struct
name|grep_pat
modifier|*
modifier|*
name|list
parameter_list|)
block|{
return|return
name|compile_pattern_or
argument_list|(
name|list
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|indent
specifier|static
name|void
name|indent
parameter_list|(
name|int
name|in
parameter_list|)
block|{
while|while
condition|(
name|in
operator|--
operator|>
literal|0
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump_grep_pat
specifier|static
name|void
name|dump_grep_pat
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_AND
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*and*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_OPEN_PAREN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*(*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_CLOSE_PAREN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*)*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NOT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*not*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_OR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*or*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_PATTERN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pattern"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_PATTERN_HEAD
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pattern_head"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_PATTERN_BODY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pattern_body"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
default|default:
break|break;
case|case
name|GREP_PATTERN_HEAD
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<head %d>"
argument_list|,
name|p
operator|->
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_PATTERN_BODY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<body>"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
default|default:
break|break;
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
case|case
name|GREP_PATTERN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|patternlen
argument_list|,
name|p
operator|->
name|pattern
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dump_grep_expression_1
specifier|static
name|void
name|dump_grep_expression_1
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|,
name|int
name|in
parameter_list|)
block|{
name|indent
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
operator|->
name|node
condition|)
block|{
case|case
name|GREP_NODE_TRUE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"true\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_ATOM
case|:
name|dump_grep_pat
argument_list|(
name|x
operator|->
name|u
operator|.
name|atom
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_NOT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(not\n"
argument_list|)
expr_stmt|;
name|dump_grep_expression_1
argument_list|(
name|x
operator|->
name|u
operator|.
name|unary
argument_list|,
name|in
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_AND
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(and\n"
argument_list|)
expr_stmt|;
name|dump_grep_expression_1
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|in
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_grep_expression_1
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|in
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_OR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(or\n"
argument_list|)
expr_stmt|;
name|dump_grep_expression_1
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|in
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_grep_expression_1
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|in
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|dump_grep_expression
specifier|static
name|void
name|dump_grep_expression
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_expr
modifier|*
name|x
init|=
name|opt
operator|->
name|pattern_expression
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|all_match
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[all-match]\n"
argument_list|)
expr_stmt|;
name|dump_grep_expression_1
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_true_expr
specifier|static
name|struct
name|grep_expr
modifier|*
name|grep_true_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|grep_expr
modifier|*
name|z
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
decl_stmt|;
name|z
operator|->
name|node
operator|=
name|GREP_NODE_TRUE
expr_stmt|;
return|return
name|z
return|;
block|}
end_function
begin_function
DECL|function|grep_or_expr
specifier|static
name|struct
name|grep_expr
modifier|*
name|grep_or_expr
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|left
parameter_list|,
name|struct
name|grep_expr
modifier|*
name|right
parameter_list|)
block|{
name|struct
name|grep_expr
modifier|*
name|z
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
decl_stmt|;
name|z
operator|->
name|node
operator|=
name|GREP_NODE_OR
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|z
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|=
name|right
expr_stmt|;
return|return
name|z
return|;
block|}
end_function
begin_function
DECL|function|prep_header_patterns
specifier|static
name|struct
name|grep_expr
modifier|*
name|prep_header_patterns
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|header_expr
decl_stmt|;
name|struct
name|grep_expr
modifier|*
argument_list|(
name|header_group
index|[
name|GREP_HEADER_FIELD_MAX
index|]
argument_list|)
decl_stmt|;
name|enum
name|grep_header_field
name|fld
decl_stmt|;
if|if
condition|(
operator|!
name|opt
operator|->
name|header_list
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|header_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|token
operator|!=
name|GREP_PATTERN_HEAD
condition|)
name|die
argument_list|(
literal|"bug: a non-header pattern in grep header list."
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|field
operator|<
literal|0
operator|||
name|GREP_HEADER_FIELD_MAX
operator|<=
name|p
operator|->
name|field
condition|)
name|die
argument_list|(
literal|"bug: unknown header field %d"
argument_list|,
name|p
operator|->
name|field
argument_list|)
expr_stmt|;
name|compile_regexp
argument_list|(
name|p
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fld
operator|=
literal|0
init|;
name|fld
operator|<
name|GREP_HEADER_FIELD_MAX
condition|;
name|fld
operator|++
control|)
name|header_group
index|[
name|fld
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|header_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|grep_expr
modifier|*
name|h
decl_stmt|;
name|struct
name|grep_pat
modifier|*
name|pp
init|=
name|p
decl_stmt|;
name|h
operator|=
name|compile_pattern_atom
argument_list|(
operator|&
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|pp
operator|!=
name|p
operator|->
name|next
condition|)
name|die
argument_list|(
literal|"bug: malformed header expr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header_group
index|[
name|p
operator|->
name|field
index|]
condition|)
block|{
name|header_group
index|[
name|p
operator|->
name|field
index|]
operator|=
name|h
expr_stmt|;
continue|continue;
block|}
name|header_group
index|[
name|p
operator|->
name|field
index|]
operator|=
name|grep_or_expr
argument_list|(
name|h
argument_list|,
name|header_group
index|[
name|p
operator|->
name|field
index|]
argument_list|)
expr_stmt|;
block|}
name|header_expr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|fld
operator|=
literal|0
init|;
name|fld
operator|<
name|GREP_HEADER_FIELD_MAX
condition|;
name|fld
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|header_group
index|[
name|fld
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|header_expr
condition|)
name|header_expr
operator|=
name|grep_true_expr
argument_list|()
expr_stmt|;
name|header_expr
operator|=
name|grep_or_expr
argument_list|(
name|header_group
index|[
name|fld
index|]
argument_list|,
name|header_expr
argument_list|)
expr_stmt|;
block|}
return|return
name|header_expr
return|;
block|}
end_function
begin_function
DECL|function|grep_splice_or
specifier|static
name|struct
name|grep_expr
modifier|*
name|grep_splice_or
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|,
name|struct
name|grep_expr
modifier|*
name|y
parameter_list|)
block|{
name|struct
name|grep_expr
modifier|*
name|z
init|=
name|x
decl_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|assert
argument_list|(
name|x
operator|->
name|node
operator|==
name|GREP_NODE_OR
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|&&
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|->
name|node
operator|==
name|GREP_NODE_TRUE
condition|)
block|{
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
operator|=
name|y
expr_stmt|;
break|break;
block|}
name|x
operator|=
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function
begin_function
DECL|function|compile_grep_patterns_real
specifier|static
name|void
name|compile_grep_patterns_real
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|struct
name|grep_expr
modifier|*
name|header_expr
init|=
name|prep_header_patterns
argument_list|(
name|opt
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|compile_regexp
argument_list|(
name|p
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|opt
operator|->
name|extended
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|opt
operator|->
name|all_match
operator|||
name|header_expr
condition|)
name|opt
operator|->
name|extended
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|opt
operator|->
name|extended
operator|&&
operator|!
name|opt
operator|->
name|debug
condition|)
return|return;
name|p
operator|=
name|opt
operator|->
name|pattern_list
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|opt
operator|->
name|pattern_expression
operator|=
name|compile_pattern_expr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|die
argument_list|(
literal|"incomplete pattern expression: %s"
argument_list|,
name|p
operator|->
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header_expr
condition|)
return|return;
if|if
condition|(
operator|!
name|opt
operator|->
name|pattern_expression
condition|)
name|opt
operator|->
name|pattern_expression
operator|=
name|header_expr
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|all_match
condition|)
name|opt
operator|->
name|pattern_expression
operator|=
name|grep_splice_or
argument_list|(
name|header_expr
argument_list|,
name|opt
operator|->
name|pattern_expression
argument_list|)
expr_stmt|;
else|else
name|opt
operator|->
name|pattern_expression
operator|=
name|grep_or_expr
argument_list|(
name|opt
operator|->
name|pattern_expression
argument_list|,
name|header_expr
argument_list|)
expr_stmt|;
name|opt
operator|->
name|all_match
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compile_grep_patterns
name|void
name|compile_grep_patterns
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|compile_grep_patterns_real
argument_list|(
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|debug
condition|)
name|dump_grep_expression
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_pattern_expr
specifier|static
name|void
name|free_pattern_expr
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|x
operator|->
name|node
condition|)
block|{
case|case
name|GREP_NODE_TRUE
case|:
case|case
name|GREP_NODE_ATOM
case|:
break|break;
case|case
name|GREP_NODE_NOT
case|:
name|free_pattern_expr
argument_list|(
name|x
operator|->
name|u
operator|.
name|unary
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_AND
case|:
case|case
name|GREP_NODE_OR
case|:
name|free_pattern_expr
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|)
expr_stmt|;
name|free_pattern_expr
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|free_grep_patterns
name|void
name|free_grep_patterns
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|n
control|)
block|{
name|n
operator|=
name|p
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
if|if
condition|(
name|p
operator|->
name|kws
condition|)
name|kwsfree
argument_list|(
name|p
operator|->
name|kws
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pcre_regexp
condition|)
name|free_pcre_regexp
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|regfree
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|pattern
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|opt
operator|->
name|extended
condition|)
return|return;
name|free_pattern_expr
argument_list|(
name|opt
operator|->
name|pattern_expression
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|end_of_line
specifier|static
name|char
modifier|*
name|end_of_line
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|unsigned
name|long
modifier|*
name|left
parameter_list|)
block|{
name|unsigned
name|long
name|l
init|=
operator|*
name|left
decl_stmt|;
while|while
condition|(
name|l
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|left
operator|=
name|l
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function
begin_function
DECL|function|word_char
specifier|static
name|int
name|word_char
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|isalnum
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'_'
return|;
block|}
end_function
begin_function
DECL|function|output_color
specifier|static
name|void
name|output_color
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|color
parameter_list|)
block|{
if|if
condition|(
name|want_color
argument_list|(
name|opt
operator|->
name|color
argument_list|)
operator|&&
name|color
operator|&&
name|color
index|[
literal|0
index|]
condition|)
block|{
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|color
argument_list|,
name|strlen
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|GIT_COLOR_RESET
argument_list|,
name|strlen
argument_list|(
name|GIT_COLOR_RESET
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|output_sep
specifier|static
name|void
name|output_sep
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
name|sign
parameter_list|)
block|{
if|if
condition|(
name|opt
operator|->
name|null_following_name
condition|)
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|output_color
argument_list|(
name|opt
argument_list|,
operator|&
name|sign
argument_list|,
literal|1
argument_list|,
name|opt
operator|->
name|color_sep
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_name
specifier|static
name|void
name|show_name
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|opt
operator|->
name|null_following_name
condition|?
literal|"\0"
else|:
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|fixmatch
specifier|static
name|int
name|fixmatch
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|regmatch_t
modifier|*
name|match
parameter_list|)
block|{
name|struct
name|kwsmatch
name|kwsm
decl_stmt|;
name|size_t
name|offset
init|=
name|kwsexec
argument_list|(
name|p
operator|->
name|kws
argument_list|,
name|line
argument_list|,
name|eol
operator|-
name|line
argument_list|,
operator|&
name|kwsm
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
name|match
operator|->
name|rm_so
operator|=
name|match
operator|->
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|REG_NOMATCH
return|;
block|}
else|else
block|{
name|match
operator|->
name|rm_so
operator|=
name|offset
expr_stmt|;
name|match
operator|->
name|rm_eo
operator|=
name|match
operator|->
name|rm_so
operator|+
name|kwsm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function
begin_function
DECL|function|regmatch
specifier|static
name|int
name|regmatch
parameter_list|(
specifier|const
name|regex_t
modifier|*
name|preg
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|regmatch_t
modifier|*
name|match
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|REG_STARTEND
name|match
operator|->
name|rm_so
operator|=
literal|0
expr_stmt|;
name|match
operator|->
name|rm_eo
operator|=
name|eol
operator|-
name|line
expr_stmt|;
name|eflags
operator||=
name|REG_STARTEND
expr_stmt|;
endif|#
directive|endif
return|return
name|regexec
argument_list|(
name|preg
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
name|match
argument_list|,
name|eflags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|patmatch
specifier|static
name|int
name|patmatch
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|regmatch_t
modifier|*
name|match
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|int
name|hit
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|fixed
condition|)
name|hit
operator|=
operator|!
name|fixmatch
argument_list|(
name|p
argument_list|,
name|line
argument_list|,
name|eol
argument_list|,
name|match
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pcre_regexp
condition|)
name|hit
operator|=
operator|!
name|pcrematch
argument_list|(
name|p
argument_list|,
name|line
argument_list|,
name|eol
argument_list|,
name|match
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
else|else
name|hit
operator|=
operator|!
name|regmatch
argument_list|(
operator|&
name|p
operator|->
name|regexp
argument_list|,
name|line
argument_list|,
name|eol
argument_list|,
name|match
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
return|return
name|hit
return|;
block|}
end_function
begin_function
DECL|function|strip_timestamp
specifier|static
name|int
name|strip_timestamp
parameter_list|(
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
modifier|*
name|eol_p
parameter_list|)
block|{
name|char
modifier|*
name|eol
init|=
operator|*
name|eol_p
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
name|bol
operator|<
operator|--
name|eol
condition|)
block|{
if|if
condition|(
operator|*
name|eol
operator|!=
literal|'>'
condition|)
continue|continue;
operator|*
name|eol_p
operator|=
operator|++
name|eol
expr_stmt|;
name|ch
operator|=
operator|*
name|eol
expr_stmt|;
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ch
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_struct
specifier|static
struct|struct
block|{
DECL|member|field
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
DECL|member|len
name|size_t
name|len
decl_stmt|;
block|}
DECL|variable|header_field
name|header_field
index|[]
init|=
block|{
block|{
literal|"author "
block|,
literal|7
block|}
block|,
block|{
literal|"committer "
block|,
literal|10
block|}
block|,
block|{
literal|"reflog "
block|,
literal|7
block|}
block|, }
struct|;
end_struct
begin_function
DECL|function|match_one_pattern
specifier|static
name|int
name|match_one_pattern
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|regmatch_t
modifier|*
name|pmatch
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|int
name|hit
init|=
literal|0
decl_stmt|;
name|int
name|saved_ch
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|bol
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|token
operator|!=
name|GREP_PATTERN
operator|)
operator|&&
operator|(
operator|(
name|p
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
operator|)
operator|!=
operator|(
name|ctx
operator|==
name|GREP_CONTEXT_HEAD
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
condition|)
block|{
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|field
operator|<
name|ARRAY_SIZE
argument_list|(
name|header_field
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|=
name|header_field
index|[
name|p
operator|->
name|field
index|]
operator|.
name|field
expr_stmt|;
name|len
operator|=
name|header_field
index|[
name|p
operator|->
name|field
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bol
argument_list|,
name|field
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|bol
operator|+=
name|len
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|field
condition|)
block|{
case|case
name|GREP_HEADER_AUTHOR
case|:
case|case
name|GREP_HEADER_COMMITTER
case|:
name|saved_ch
operator|=
name|strip_timestamp
argument_list|(
name|bol
argument_list|,
operator|&
name|eol
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|again
label|:
name|hit
operator|=
name|patmatch
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|pmatch
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit
operator|&&
name|p
operator|->
name|word_regexp
condition|)
block|{
if|if
condition|(
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|<
literal|0
operator|)
operator|||
operator|(
name|eol
operator|-
name|bol
operator|)
operator|<
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|||
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|<
literal|0
operator|)
operator|||
operator|(
name|eol
operator|-
name|bol
operator|)
operator|<
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
condition|)
name|die
argument_list|(
literal|"regexp returned nonsense"
argument_list|)
expr_stmt|;
comment|/* Match beginning must be either beginning of the 		 * line, or at word boundary (i.e. the last char must 		 * not be a word char).  Similarly, match end must be 		 * either end of the line, or at word boundary 		 * (i.e. the next char must not be a word char). 		 */
if|if
condition|(
operator|(
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
operator|)
operator|||
operator|!
name|word_char
argument_list|(
name|bol
index|[
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
operator|(
name|eol
operator|-
name|bol
operator|)
operator|)
operator|||
operator|!
name|word_char
argument_list|(
name|bol
index|[
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
index|]
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|hit
operator|=
literal|0
expr_stmt|;
comment|/* Words consist of at least one character. */
if|if
condition|(
name|pmatch
operator|->
name|rm_so
operator|==
name|pmatch
operator|->
name|rm_eo
condition|)
name|hit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hit
operator|&&
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+
name|bol
operator|+
literal|1
operator|<
name|eol
condition|)
block|{
comment|/* There could be more than one match on the 			 * line, and the first match might not be 			 * strict word match.  But later ones could be! 			 * Forward to the next possible start, i.e. the 			 * next position following a non-word char. 			 */
name|bol
operator|=
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+
name|bol
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|word_char
argument_list|(
name|bol
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|bol
operator|<
name|eol
condition|)
name|bol
operator|++
expr_stmt|;
name|eflags
operator||=
name|REG_NOTBOL
expr_stmt|;
if|if
condition|(
name|bol
operator|<
name|eol
condition|)
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|token
operator|==
name|GREP_PATTERN_HEAD
operator|&&
name|saved_ch
condition|)
operator|*
name|eol
operator|=
name|saved_ch
expr_stmt|;
if|if
condition|(
name|hit
condition|)
block|{
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+=
name|bol
operator|-
name|start
expr_stmt|;
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|+=
name|bol
operator|-
name|start
expr_stmt|;
block|}
return|return
name|hit
return|;
block|}
end_function
begin_function
DECL|function|match_expr_eval
specifier|static
name|int
name|match_expr_eval
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
name|regmatch_t
name|match
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|die
argument_list|(
literal|"Not a valid grep expression"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
operator|->
name|node
condition|)
block|{
case|case
name|GREP_NODE_TRUE
case|:
name|h
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GREP_NODE_ATOM
case|:
name|h
operator|=
name|match_one_pattern
argument_list|(
name|x
operator|->
name|u
operator|.
name|atom
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_NOT
case|:
name|h
operator|=
operator|!
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|unary
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_AND
case|:
if|if
condition|(
operator|!
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|h
operator|=
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_NODE_OR
case|:
if|if
condition|(
operator|!
name|collect_hits
condition|)
return|return
operator|(
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
operator|||
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|h
operator|=
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|->
name|hit
operator||=
name|h
expr_stmt|;
name|h
operator||=
name|match_expr_eval
argument_list|(
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|die
argument_list|(
literal|"Unexpected node type (internal error) %d"
argument_list|,
name|x
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|collect_hits
condition|)
name|x
operator|->
name|hit
operator||=
name|h
expr_stmt|;
return|return
name|h
return|;
block|}
end_function
begin_function
DECL|function|match_expr
specifier|static
name|int
name|match_expr
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|struct
name|grep_expr
modifier|*
name|x
init|=
name|opt
operator|->
name|pattern_expression
decl_stmt|;
return|return
name|match_expr_eval
argument_list|(
name|x
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|collect_hits
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|match_line
specifier|static
name|int
name|match_line
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|regmatch_t
name|match
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|extended
condition|)
return|return
name|match_expr
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|collect_hits
argument_list|)
return|;
comment|/* we do not call with collect_hits without being extended */
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|match_one_pattern
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|match_next_pattern
specifier|static
name|int
name|match_next_pattern
parameter_list|(
name|struct
name|grep_pat
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|regmatch_t
modifier|*
name|pmatch
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|regmatch_t
name|match
decl_stmt|;
if|if
condition|(
operator|!
name|match_one_pattern
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
name|eflags
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|match
operator|.
name|rm_so
operator|<
literal|0
operator|||
name|match
operator|.
name|rm_eo
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pmatch
operator|->
name|rm_so
operator|>=
literal|0
operator|&&
name|pmatch
operator|->
name|rm_eo
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|rm_so
operator|>
name|pmatch
operator|->
name|rm_so
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|match
operator|.
name|rm_so
operator|==
name|pmatch
operator|->
name|rm_so
operator|&&
name|match
operator|.
name|rm_eo
operator|<
name|pmatch
operator|->
name|rm_eo
condition|)
return|return
literal|1
return|;
block|}
name|pmatch
operator|->
name|rm_so
operator|=
name|match
operator|.
name|rm_so
expr_stmt|;
name|pmatch
operator|->
name|rm_eo
operator|=
name|match
operator|.
name|rm_eo
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|next_match
specifier|static
name|int
name|next_match
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
name|enum
name|grep_context
name|ctx
parameter_list|,
name|regmatch_t
modifier|*
name|pmatch
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|int
name|hit
init|=
literal|0
decl_stmt|;
name|pmatch
operator|->
name|rm_so
operator|=
name|pmatch
operator|->
name|rm_eo
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bol
operator|<
name|eol
condition|)
block|{
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|token
condition|)
block|{
case|case
name|GREP_PATTERN
case|:
comment|/* atom */
case|case
name|GREP_PATTERN_HEAD
case|:
case|case
name|GREP_PATTERN_BODY
case|:
name|hit
operator||=
name|match_next_pattern
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|pmatch
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
return|return
name|hit
return|;
block|}
end_function
begin_function
DECL|function|show_line
specifier|static
name|void
name|show_line
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|lno
parameter_list|,
name|char
name|sign
parameter_list|)
block|{
name|int
name|rest
init|=
name|eol
operator|-
name|bol
decl_stmt|;
name|char
modifier|*
name|line_color
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|file_break
operator|&&
name|opt
operator|->
name|last_shown
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|show_hunk_mark
condition|)
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|->
name|pre_context
operator|||
name|opt
operator|->
name|post_context
operator|||
name|opt
operator|->
name|funcbody
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|last_shown
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt
operator|->
name|show_hunk_mark
condition|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|,
name|opt
operator|->
name|color_sep
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lno
operator|>
name|opt
operator|->
name|last_shown
operator|+
literal|1
condition|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|,
name|opt
operator|->
name|color_sep
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opt
operator|->
name|heading
operator|&&
name|opt
operator|->
name|last_shown
operator|==
literal|0
condition|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|opt
operator|->
name|last_shown
operator|=
name|lno
expr_stmt|;
if|if
condition|(
operator|!
name|opt
operator|->
name|heading
operator|&&
name|opt
operator|->
name|pathname
condition|)
block|{
name|output_color
argument_list|(
name|opt
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|output_sep
argument_list|(
name|opt
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|->
name|linenum
condition|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|opt
operator|->
name|color_lineno
argument_list|)
expr_stmt|;
name|output_sep
argument_list|(
name|opt
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|->
name|color
condition|)
block|{
name|regmatch_t
name|match
decl_stmt|;
name|enum
name|grep_context
name|ctx
init|=
name|GREP_CONTEXT_BODY
decl_stmt|;
name|int
name|ch
init|=
operator|*
name|eol
decl_stmt|;
name|int
name|eflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sign
operator|==
literal|':'
condition|)
name|line_color
operator|=
name|opt
operator|->
name|color_selected
expr_stmt|;
elseif|else
if|if
condition|(
name|sign
operator|==
literal|'-'
condition|)
name|line_color
operator|=
name|opt
operator|->
name|color_context
expr_stmt|;
elseif|else
if|if
condition|(
name|sign
operator|==
literal|'='
condition|)
name|line_color
operator|=
name|opt
operator|->
name|color_function
expr_stmt|;
operator|*
name|eol
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|next_match
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
operator|&
name|match
argument_list|,
name|eflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|rm_so
operator|==
name|match
operator|.
name|rm_eo
condition|)
break|break;
name|output_color
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|match
operator|.
name|rm_so
argument_list|,
name|line_color
argument_list|)
expr_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|bol
operator|+
name|match
operator|.
name|rm_so
argument_list|,
name|match
operator|.
name|rm_eo
operator|-
name|match
operator|.
name|rm_so
argument_list|,
name|opt
operator|->
name|color_match
argument_list|)
expr_stmt|;
name|bol
operator|+=
name|match
operator|.
name|rm_eo
expr_stmt|;
name|rest
operator|-=
name|match
operator|.
name|rm_eo
expr_stmt|;
name|eflags
operator|=
name|REG_NOTBOL
expr_stmt|;
block|}
operator|*
name|eol
operator|=
name|ch
expr_stmt|;
block|}
name|output_color
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|rest
argument_list|,
name|line_color
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_PTHREADS
end_ifndef
begin_decl_stmt
DECL|variable|grep_use_locks
name|int
name|grep_use_locks
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * This lock protects access to the gitattributes machinery, which is  * not thread-safe.  */
end_comment
begin_decl_stmt
DECL|variable|grep_attr_mutex
name|pthread_mutex_t
name|grep_attr_mutex
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|grep_attr_lock
specifier|static
specifier|inline
name|void
name|grep_attr_lock
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|grep_use_locks
condition|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|grep_attr_mutex
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_attr_unlock
specifier|static
specifier|inline
name|void
name|grep_attr_unlock
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|grep_use_locks
condition|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|grep_attr_mutex
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Same as git_attr_mutex, but protecting the thread-unsafe object db access.  */
end_comment
begin_decl_stmt
DECL|variable|grep_read_mutex
name|pthread_mutex_t
name|grep_read_mutex
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|grep_attr_lock
define|#
directive|define
name|grep_attr_lock
parameter_list|()
end_define
begin_define
DECL|macro|grep_attr_unlock
define|#
directive|define
name|grep_attr_unlock
parameter_list|()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|match_funcname
specifier|static
name|int
name|match_funcname
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|eol
parameter_list|)
block|{
name|xdemitconf_t
modifier|*
name|xecfg
init|=
name|opt
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|xecfg
operator|&&
operator|!
name|xecfg
operator|->
name|find_func
condition|)
block|{
name|grep_source_load_driver
argument_list|(
name|gs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|->
name|driver
operator|->
name|funcname
operator|.
name|pattern
condition|)
block|{
specifier|const
name|struct
name|userdiff_funcname
modifier|*
name|pe
init|=
operator|&
name|gs
operator|->
name|driver
operator|->
name|funcname
decl_stmt|;
name|xdiff_set_find_func
argument_list|(
name|xecfg
argument_list|,
name|pe
operator|->
name|pattern
argument_list|,
name|pe
operator|->
name|cflags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xecfg
operator|=
name|opt
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xecfg
condition|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
return|return
name|xecfg
operator|->
name|find_func
argument_list|(
name|bol
argument_list|,
name|eol
operator|-
name|bol
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
name|xecfg
operator|->
name|find_func_priv
argument_list|)
operator|>=
literal|0
return|;
block|}
if|if
condition|(
name|bol
operator|==
name|eol
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|bol
argument_list|)
operator|||
operator|*
name|bol
operator|==
literal|'_'
operator|||
operator|*
name|bol
operator|==
literal|'$'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|show_funcname_line
specifier|static
name|void
name|show_funcname_line
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|unsigned
name|lno
parameter_list|)
block|{
while|while
condition|(
name|bol
operator|>
name|gs
operator|->
name|buf
condition|)
block|{
name|char
modifier|*
name|eol
init|=
operator|--
name|bol
decl_stmt|;
while|while
condition|(
name|bol
operator|>
name|gs
operator|->
name|buf
operator|&&
name|bol
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|bol
operator|--
expr_stmt|;
name|lno
operator|--
expr_stmt|;
if|if
condition|(
name|lno
operator|<=
name|opt
operator|->
name|last_shown
condition|)
break|break;
if|if
condition|(
name|match_funcname
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|)
condition|)
block|{
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|gs
operator|->
name|name
argument_list|,
name|lno
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_function
DECL|function|show_pre_context
specifier|static
name|void
name|show_pre_context
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|,
name|char
modifier|*
name|bol
parameter_list|,
name|char
modifier|*
name|end
parameter_list|,
name|unsigned
name|lno
parameter_list|)
block|{
name|unsigned
name|cur
init|=
name|lno
decl_stmt|,
name|from
init|=
literal|1
decl_stmt|,
name|funcname_lno
init|=
literal|0
decl_stmt|;
name|int
name|funcname_needed
init|=
operator|!
operator|!
name|opt
operator|->
name|funcname
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|funcbody
operator|&&
operator|!
name|match_funcname
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
name|bol
argument_list|,
name|end
argument_list|)
condition|)
name|funcname_needed
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|pre_context
operator|<
name|lno
condition|)
name|from
operator|=
name|lno
operator|-
name|opt
operator|->
name|pre_context
expr_stmt|;
if|if
condition|(
name|from
operator|<=
name|opt
operator|->
name|last_shown
condition|)
name|from
operator|=
name|opt
operator|->
name|last_shown
operator|+
literal|1
expr_stmt|;
comment|/* Rewind. */
while|while
condition|(
name|bol
operator|>
name|gs
operator|->
name|buf
operator|&&
name|cur
operator|>
operator|(
name|funcname_needed
operator|==
literal|2
condition|?
name|opt
operator|->
name|last_shown
operator|+
literal|1
else|:
name|from
operator|)
condition|)
block|{
name|char
modifier|*
name|eol
init|=
operator|--
name|bol
decl_stmt|;
while|while
condition|(
name|bol
operator|>
name|gs
operator|->
name|buf
operator|&&
name|bol
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|bol
operator|--
expr_stmt|;
name|cur
operator|--
expr_stmt|;
if|if
condition|(
name|funcname_needed
operator|&&
name|match_funcname
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|)
condition|)
block|{
name|funcname_lno
operator|=
name|cur
expr_stmt|;
name|funcname_needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* We need to look even further back to find a function signature. */
if|if
condition|(
name|opt
operator|->
name|funcname
operator|&&
name|funcname_needed
condition|)
name|show_funcname_line
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
name|bol
argument_list|,
name|cur
argument_list|)
expr_stmt|;
comment|/* Back forward. */
while|while
condition|(
name|cur
operator|<
name|lno
condition|)
block|{
name|char
modifier|*
name|eol
init|=
name|bol
decl_stmt|,
name|sign
init|=
operator|(
name|cur
operator|==
name|funcname_lno
operator|)
condition|?
literal|'='
else|:
literal|'-'
decl_stmt|;
while|while
condition|(
operator|*
name|eol
operator|!=
literal|'\n'
condition|)
name|eol
operator|++
expr_stmt|;
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|gs
operator|->
name|name
argument_list|,
name|cur
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|bol
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|should_lookahead
specifier|static
name|int
name|should_lookahead
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|)
block|{
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|opt
operator|->
name|extended
condition|)
return|return
literal|0
return|;
comment|/* punt for too complex stuff */
if|if
condition|(
name|opt
operator|->
name|invert
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|token
operator|!=
name|GREP_PATTERN
condition|)
return|return
literal|0
return|;
comment|/* punt for "header only" and stuff */
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|look_ahead
specifier|static
name|int
name|look_ahead
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|unsigned
name|long
modifier|*
name|left_p
parameter_list|,
name|unsigned
modifier|*
name|lno_p
parameter_list|,
name|char
modifier|*
modifier|*
name|bol_p
parameter_list|)
block|{
name|unsigned
name|lno
init|=
operator|*
name|lno_p
decl_stmt|;
name|char
modifier|*
name|bol
init|=
operator|*
name|bol_p
decl_stmt|;
name|struct
name|grep_pat
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|last_bol
decl_stmt|;
name|regoff_t
name|earliest
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|p
operator|=
name|opt
operator|->
name|pattern_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|hit
decl_stmt|;
name|regmatch_t
name|m
decl_stmt|;
name|hit
operator|=
name|patmatch
argument_list|(
name|p
argument_list|,
name|bol
argument_list|,
name|bol
operator|+
operator|*
name|left_p
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hit
operator|||
name|m
operator|.
name|rm_so
operator|<
literal|0
operator|||
name|m
operator|.
name|rm_eo
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|earliest
operator|<
literal|0
operator|||
name|m
operator|.
name|rm_so
operator|<
name|earliest
condition|)
name|earliest
operator|=
name|m
operator|.
name|rm_so
expr_stmt|;
block|}
if|if
condition|(
name|earliest
operator|<
literal|0
condition|)
block|{
operator|*
name|bol_p
operator|=
name|bol
operator|+
operator|*
name|left_p
expr_stmt|;
operator|*
name|left_p
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|sp
operator|=
name|bol
operator|+
name|earliest
init|;
name|bol
operator|<
name|sp
operator|&&
name|sp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
name|sp
operator|--
control|)
empty_stmt|;
comment|/* find the beginning of the line */
name|last_bol
operator|=
name|sp
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|bol
init|;
name|sp
operator|<
name|last_bol
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\n'
condition|)
name|lno
operator|++
expr_stmt|;
block|}
operator|*
name|left_p
operator|-=
name|last_bol
operator|-
name|bol
expr_stmt|;
operator|*
name|bol_p
operator|=
name|last_bol
expr_stmt|;
operator|*
name|lno_p
operator|=
name|lno
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|std_output
specifier|static
name|void
name|std_output
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_source_1
specifier|static
name|int
name|grep_source_1
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|,
name|int
name|collect_hits
parameter_list|)
block|{
name|char
modifier|*
name|bol
decl_stmt|;
name|unsigned
name|long
name|left
decl_stmt|;
name|unsigned
name|lno
init|=
literal|1
decl_stmt|;
name|unsigned
name|last_hit
init|=
literal|0
decl_stmt|;
name|int
name|binary_match_only
init|=
literal|0
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
name|int
name|try_lookahead
init|=
literal|0
decl_stmt|;
name|int
name|show_function
init|=
literal|0
decl_stmt|;
name|enum
name|grep_context
name|ctx
init|=
name|GREP_CONTEXT_HEAD
decl_stmt|;
name|xdemitconf_t
name|xecfg
decl_stmt|;
if|if
condition|(
operator|!
name|opt
operator|->
name|output
condition|)
name|opt
operator|->
name|output
operator|=
name|std_output
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|pre_context
operator|||
name|opt
operator|->
name|post_context
operator|||
name|opt
operator|->
name|file_break
operator|||
name|opt
operator|->
name|funcbody
condition|)
block|{
comment|/* Show hunk marks, except for the first file. */
if|if
condition|(
name|opt
operator|->
name|last_shown
condition|)
name|opt
operator|->
name|show_hunk_mark
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If we're using threads then we can't easily identify 		 * the first file.  Always put hunk marks in that case 		 * and skip the very first one later in work_done(). 		 */
if|if
condition|(
name|opt
operator|->
name|output
operator|!=
name|std_output
condition|)
name|opt
operator|->
name|show_hunk_mark
operator|=
literal|1
expr_stmt|;
block|}
name|opt
operator|->
name|last_shown
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opt
operator|->
name|binary
condition|)
block|{
case|case
name|GREP_BINARY_DEFAULT
case|:
if|if
condition|(
name|grep_source_is_binary
argument_list|(
name|gs
argument_list|)
condition|)
name|binary_match_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GREP_BINARY_NOMATCH
case|:
if|if
condition|(
name|grep_source_is_binary
argument_list|(
name|gs
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Assume unmatch */
break|break;
case|case
name|GREP_BINARY_TEXT
case|:
break|break;
default|default:
name|die
argument_list|(
literal|"bug: unknown binary handling mode"
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|xecfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xecfg
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|->
name|priv
operator|=
operator|&
name|xecfg
expr_stmt|;
name|try_lookahead
operator|=
name|should_lookahead
argument_list|(
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|grep_source_load
argument_list|(
name|gs
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|bol
operator|=
name|gs
operator|->
name|buf
expr_stmt|;
name|left
operator|=
name|gs
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|left
condition|)
block|{
name|char
modifier|*
name|eol
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|hit
decl_stmt|;
comment|/* 		 * look_ahead() skips quickly to the line that possibly 		 * has the next hit; don't call it if we need to do 		 * something more than just skipping the current line 		 * in response to an unmatch for the current line.  E.g. 		 * inside a post-context window, we will show the current 		 * line as a context around the previous hit when it 		 * doesn't hit. 		 */
if|if
condition|(
name|try_lookahead
operator|&&
operator|!
operator|(
name|last_hit
operator|&&
operator|(
name|show_function
operator|||
name|lno
operator|<=
name|last_hit
operator|+
name|opt
operator|->
name|post_context
operator|)
operator|)
operator|&&
name|look_ahead
argument_list|(
name|opt
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|lno
argument_list|,
operator|&
name|bol
argument_list|)
condition|)
break|break;
name|eol
operator|=
name|end_of_line
argument_list|(
name|bol
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|eol
expr_stmt|;
operator|*
name|eol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|==
name|GREP_CONTEXT_HEAD
operator|)
operator|&&
operator|(
name|eol
operator|==
name|bol
operator|)
condition|)
name|ctx
operator|=
name|GREP_CONTEXT_BODY
expr_stmt|;
name|hit
operator|=
name|match_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|ctx
argument_list|,
name|collect_hits
argument_list|)
expr_stmt|;
operator|*
name|eol
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|collect_hits
condition|)
goto|goto
name|next_line
goto|;
comment|/* "grep -v -e foo -e bla" should list lines 		 * that do not have either, so inversion should 		 * be done outside. 		 */
if|if
condition|(
name|opt
operator|->
name|invert
condition|)
name|hit
operator|=
operator|!
name|hit
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|unmatch_name_only
condition|)
block|{
if|if
condition|(
name|hit
condition|)
return|return
literal|0
return|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|hit
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|status_only
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|opt
operator|->
name|name_only
condition|)
block|{
name|show_name
argument_list|(
name|opt
argument_list|,
name|gs
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|opt
operator|->
name|count
condition|)
goto|goto
name|next_line
goto|;
if|if
condition|(
name|binary_match_only
condition|)
block|{
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|"Binary file "
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|gs
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|gs
operator|->
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
literal|" matches\n"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Hit at this line.  If we haven't shown the 			 * pre-context lines, we would need to show them. 			 */
if|if
condition|(
name|opt
operator|->
name|pre_context
operator|||
name|opt
operator|->
name|funcbody
condition|)
name|show_pre_context
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|lno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|->
name|funcname
condition|)
name|show_funcname_line
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
name|bol
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|gs
operator|->
name|name
argument_list|,
name|lno
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|last_hit
operator|=
name|lno
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|funcbody
condition|)
name|show_function
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|show_function
operator|&&
name|match_funcname
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|)
condition|)
name|show_function
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|show_function
operator|||
operator|(
name|last_hit
operator|&&
name|lno
operator|<=
name|last_hit
operator|+
name|opt
operator|->
name|post_context
operator|)
condition|)
block|{
comment|/* If the last hit is within the post context, 			 * we need to show this line. 			 */
name|show_line
argument_list|(
name|opt
argument_list|,
name|bol
argument_list|,
name|eol
argument_list|,
name|gs
operator|->
name|name
argument_list|,
name|lno
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|next_line
label|:
name|bol
operator|=
name|eol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|left
condition|)
break|break;
name|left
operator|--
expr_stmt|;
name|lno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|collect_hits
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opt
operator|->
name|status_only
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opt
operator|->
name|unmatch_name_only
condition|)
block|{
comment|/* We did not see any hit, so we want to show this */
name|show_name
argument_list|(
name|opt
argument_list|,
name|gs
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|xdiff_clear_find_func
argument_list|(
operator|&
name|xecfg
argument_list|)
expr_stmt|;
name|opt
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
comment|/* NEEDSWORK: 	 * The real "grep -c foo *.c" gives many "bar.c:0" lines, 	 * which feels mostly useless but sometimes useful.  Maybe 	 * make it another option?  For now suppress them. 	 */
if|if
condition|(
name|opt
operator|->
name|count
operator|&&
name|count
condition|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|output_color
argument_list|(
name|opt
argument_list|,
name|gs
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|gs
operator|->
name|name
argument_list|)
argument_list|,
name|opt
operator|->
name|color_filename
argument_list|)
expr_stmt|;
name|output_sep
argument_list|(
name|opt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%u\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|opt
operator|->
name|output
argument_list|(
name|opt
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
operator|!
operator|!
name|last_hit
return|;
block|}
end_function
begin_function
DECL|function|clr_hit_marker
specifier|static
name|void
name|clr_hit_marker
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|)
block|{
comment|/* All-hit markers are meaningful only at the very top level 	 * OR node. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|x
operator|->
name|hit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|node
operator|!=
name|GREP_NODE_OR
condition|)
return|return;
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|->
name|hit
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|chk_hit_marker
specifier|static
name|int
name|chk_hit_marker
parameter_list|(
name|struct
name|grep_expr
modifier|*
name|x
parameter_list|)
block|{
comment|/* Top level nodes have hit markers.  See if they all are hits */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|node
operator|!=
name|GREP_NODE_OR
condition|)
return|return
name|x
operator|->
name|hit
return|;
if|if
condition|(
operator|!
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|left
operator|->
name|hit
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|x
operator|->
name|u
operator|.
name|binary
operator|.
name|right
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|grep_source
name|int
name|grep_source
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
comment|/* 	 * we do not have to do the two-pass grep when we do not check 	 * buffer-wide "all-match". 	 */
if|if
condition|(
operator|!
name|opt
operator|->
name|all_match
condition|)
return|return
name|grep_source_1
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Otherwise the toplevel "or" terms hit a bit differently. 	 * We first clear hit markers from them. 	 */
name|clr_hit_marker
argument_list|(
name|opt
operator|->
name|pattern_expression
argument_list|)
expr_stmt|;
name|grep_source_1
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chk_hit_marker
argument_list|(
name|opt
operator|->
name|pattern_expression
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|grep_source_1
argument_list|(
name|opt
argument_list|,
name|gs
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|grep_buffer
name|int
name|grep_buffer
parameter_list|(
name|struct
name|grep_opt
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|struct
name|grep_source
name|gs
decl_stmt|;
name|int
name|r
decl_stmt|;
name|grep_source_init
argument_list|(
operator|&
name|gs
argument_list|,
name|GREP_SOURCE_BUF
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gs
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|gs
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|r
operator|=
name|grep_source
argument_list|(
name|opt
argument_list|,
operator|&
name|gs
argument_list|)
expr_stmt|;
name|grep_source_clear
argument_list|(
operator|&
name|gs
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function
begin_function
DECL|function|grep_source_init
name|void
name|grep_source_init
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|,
name|enum
name|grep_source_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|identifier
parameter_list|)
block|{
name|gs
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|gs
operator|->
name|name
operator|=
name|name
condition|?
name|xstrdup
argument_list|(
name|name
argument_list|)
else|:
name|NULL
expr_stmt|;
name|gs
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|gs
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|gs
operator|->
name|driver
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GREP_SOURCE_FILE
case|:
name|gs
operator|->
name|identifier
operator|=
name|xstrdup
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_SOURCE_SHA1
case|:
name|gs
operator|->
name|identifier
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|gs
operator|->
name|identifier
argument_list|,
name|identifier
argument_list|,
literal|20
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREP_SOURCE_BUF
case|:
name|gs
operator|->
name|identifier
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|grep_source_clear
name|void
name|grep_source_clear
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
name|free
argument_list|(
name|gs
operator|->
name|name
argument_list|)
expr_stmt|;
name|gs
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|gs
operator|->
name|identifier
argument_list|)
expr_stmt|;
name|gs
operator|->
name|identifier
operator|=
name|NULL
expr_stmt|;
name|grep_source_clear_data
argument_list|(
name|gs
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_source_clear_data
name|void
name|grep_source_clear_data
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
switch|switch
condition|(
name|gs
operator|->
name|type
condition|)
block|{
case|case
name|GREP_SOURCE_FILE
case|:
case|case
name|GREP_SOURCE_SHA1
case|:
name|free
argument_list|(
name|gs
operator|->
name|buf
argument_list|)
expr_stmt|;
name|gs
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|gs
operator|->
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GREP_SOURCE_BUF
case|:
comment|/* leave user-provided buf intact */
break|break;
block|}
block|}
end_function
begin_function
DECL|function|grep_source_load_sha1
specifier|static
name|int
name|grep_source_load_sha1
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
name|enum
name|object_type
name|type
decl_stmt|;
name|grep_read_lock
argument_list|()
expr_stmt|;
name|gs
operator|->
name|buf
operator|=
name|read_sha1_file
argument_list|(
name|gs
operator|->
name|identifier
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|gs
operator|->
name|size
argument_list|)
expr_stmt|;
name|grep_read_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gs
operator|->
name|buf
condition|)
return|return
name|error
argument_list|(
name|_
argument_list|(
literal|"'%s': unable to read %s"
argument_list|)
argument_list|,
name|gs
operator|->
name|name
argument_list|,
name|sha1_to_hex
argument_list|(
name|gs
operator|->
name|identifier
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|grep_source_load_file
specifier|static
name|int
name|grep_source_load_file
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|gs
operator|->
name|identifier
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err_ret
label|:
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"'%s': %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
goto|goto
name|err_ret
goto|;
name|data
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_size
operator|!=
name|read_in_full
argument_list|(
name|i
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"'%s': short read %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|data
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|gs
operator|->
name|buf
operator|=
name|data
expr_stmt|;
name|gs
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|grep_source_load
specifier|static
name|int
name|grep_source_load
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
if|if
condition|(
name|gs
operator|->
name|buf
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|gs
operator|->
name|type
condition|)
block|{
case|case
name|GREP_SOURCE_FILE
case|:
return|return
name|grep_source_load_file
argument_list|(
name|gs
argument_list|)
return|;
case|case
name|GREP_SOURCE_SHA1
case|:
return|return
name|grep_source_load_sha1
argument_list|(
name|gs
argument_list|)
return|;
case|case
name|GREP_SOURCE_BUF
case|:
return|return
name|gs
operator|->
name|buf
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
name|die
argument_list|(
literal|"BUG: invalid grep_source type"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_source_load_driver
name|void
name|grep_source_load_driver
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
if|if
condition|(
name|gs
operator|->
name|driver
condition|)
return|return;
name|grep_attr_lock
argument_list|()
expr_stmt|;
name|gs
operator|->
name|driver
operator|=
name|userdiff_find_by_path
argument_list|(
name|gs
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gs
operator|->
name|driver
condition|)
name|gs
operator|->
name|driver
operator|=
name|userdiff_find_by_name
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
name|grep_attr_unlock
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|grep_source_is_binary
specifier|static
name|int
name|grep_source_is_binary
parameter_list|(
name|struct
name|grep_source
modifier|*
name|gs
parameter_list|)
block|{
name|grep_source_load_driver
argument_list|(
name|gs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|->
name|driver
operator|->
name|binary
operator|!=
operator|-
literal|1
condition|)
return|return
name|gs
operator|->
name|driver
operator|->
name|binary
return|;
if|if
condition|(
operator|!
name|grep_source_load
argument_list|(
name|gs
argument_list|)
condition|)
return|return
name|buffer_is_binary
argument_list|(
name|gs
operator|->
name|buf
argument_list|,
name|gs
operator|->
name|size
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function
end_unit
