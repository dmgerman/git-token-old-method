begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_function
DECL|function|show_new
specifier|static
name|void
name|show_new
parameter_list|(
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1_new
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s: %s\n"
argument_list|,
name|type
argument_list|,
name|find_unique_abbrev
argument_list|(
name|sha1_new
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|update_ref
specifier|static
name|int
name|update_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|action
parameter_list|,
specifier|const
name|char
modifier|*
name|refname
parameter_list|,
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|unsigned
name|char
modifier|*
name|oldval
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|rla
init|=
name|getenv
argument_list|(
literal|"GIT_REFLOG_ACTION"
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|ref_lock
modifier|*
name|lock
decl_stmt|;
if|if
condition|(
operator|!
name|rla
condition|)
name|rla
operator|=
literal|"(reflog update)"
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"%s: %s"
argument_list|,
name|rla
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|<=
name|len
condition|)
name|die
argument_list|(
literal|"insanely long action"
argument_list|)
expr_stmt|;
name|lock
operator|=
name|lock_any_ref_for_update
argument_list|(
name|refname
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|write_ref_sha1
argument_list|(
name|lock
argument_list|,
name|sha1
argument_list|,
name|msg
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|update_local_ref
specifier|static
name|int
name|update_local_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|new_head
parameter_list|,
specifier|const
name|char
modifier|*
name|note
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|char
name|type
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|char
name|sha1_old
index|[
literal|20
index|]
decl_stmt|,
name|sha1_new
index|[
literal|20
index|]
decl_stmt|;
name|char
name|oldh
index|[
literal|41
index|]
decl_stmt|,
name|newh
index|[
literal|41
index|]
decl_stmt|;
name|struct
name|commit
modifier|*
name|current
decl_stmt|,
modifier|*
name|updated
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|new_head
argument_list|,
name|sha1_new
argument_list|)
condition|)
name|die
argument_list|(
literal|"malformed object name %s"
argument_list|,
name|new_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_object_info
argument_list|(
name|sha1_new
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|)
condition|)
name|die
argument_list|(
literal|"object %s not found"
argument_list|,
name|new_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
block|{
comment|/* Not storing */
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* fetched %s\n"
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|show_new
argument_list|(
name|type
argument_list|,
name|sha1_new
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|get_sha1
argument_list|(
name|name
argument_list|,
name|sha1_old
argument_list|)
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|just_store
label|:
comment|/* new ref */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|,
literal|10
argument_list|)
condition|)
name|msg
operator|=
literal|"storing tag"
expr_stmt|;
else|else
name|msg
operator|=
literal|"storing head"
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s: storing %s\n"
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|show_new
argument_list|(
name|type
argument_list|,
name|sha1_new
argument_list|)
expr_stmt|;
return|return
name|update_ref
argument_list|(
name|msg
argument_list|,
name|name
argument_list|,
name|sha1_new
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|hashcmp
argument_list|(
name|sha1_old
argument_list|,
name|sha1_new
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s: same as %s\n"
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|show_new
argument_list|(
name|type
argument_list|,
name|sha1_new
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"refs/tags/"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s: updating with %s\n"
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|show_new
argument_list|(
name|type
argument_list|,
name|sha1_new
argument_list|)
expr_stmt|;
return|return
name|update_ref
argument_list|(
literal|"updating tag"
argument_list|,
name|name
argument_list|,
name|sha1_new
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|current
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1_old
argument_list|)
expr_stmt|;
name|updated
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1_new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|||
operator|!
name|updated
condition|)
goto|goto
name|just_store
goto|;
name|strcpy
argument_list|(
name|oldh
argument_list|,
name|find_unique_abbrev
argument_list|(
name|current
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newh
argument_list|,
name|find_unique_abbrev
argument_list|(
name|sha1_new
argument_list|,
name|DEFAULT_ABBREV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_merge_bases
argument_list|(
name|current
argument_list|,
operator|&
name|updated
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s: fast forward to %s\n"
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  old..new: %s..%s\n"
argument_list|,
name|oldh
argument_list|,
name|newh
argument_list|)
expr_stmt|;
return|return
name|update_ref
argument_list|(
literal|"fast forward"
argument_list|,
name|name
argument_list|,
name|sha1_new
argument_list|,
name|sha1_old
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s: not updating to non-fast forward %s\n"
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  old...new: %s...%s\n"
argument_list|,
name|oldh
argument_list|,
name|newh
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"* %s: forcing update to non-fast forward %s\n"
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  old...new: %s...%s\n"
argument_list|,
name|oldh
argument_list|,
name|newh
argument_list|)
expr_stmt|;
return|return
name|update_ref
argument_list|(
literal|"forced-update"
argument_list|,
name|name
argument_list|,
name|sha1_new
argument_list|,
name|sha1_old
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|append_fetch_head
specifier|static
name|int
name|append_fetch_head
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|remote
parameter_list|,
specifier|const
name|char
modifier|*
name|remote_name
parameter_list|,
specifier|const
name|char
modifier|*
name|remote_nick
parameter_list|,
specifier|const
name|char
modifier|*
name|local_name
parameter_list|,
name|int
name|not_for_merge
parameter_list|,
name|int
name|verbose
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|int
name|remote_len
decl_stmt|,
name|i
decl_stmt|,
name|note_len
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
name|char
name|note
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|kind
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|head
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
name|error
argument_list|(
literal|"Not a valid object name: %s"
argument_list|,
name|head
argument_list|)
return|;
name|commit
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|not_for_merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|remote_name
argument_list|,
literal|"HEAD"
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|""
expr_stmt|;
name|what
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|remote_name
argument_list|,
literal|"refs/heads/"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|"branch"
expr_stmt|;
name|what
operator|=
name|remote_name
operator|+
literal|11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|remote_name
argument_list|,
literal|"refs/tags/"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|"tag"
expr_stmt|;
name|what
operator|=
name|remote_name
operator|+
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|remote_name
argument_list|,
literal|"refs/remotes/"
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|"remote branch"
expr_stmt|;
name|what
operator|=
name|remote_name
operator|+
literal|13
expr_stmt|;
block|}
else|else
block|{
name|kind
operator|=
literal|""
expr_stmt|;
name|what
operator|=
name|remote_name
expr_stmt|;
block|}
name|remote_len
operator|=
name|strlen
argument_list|(
name|remote
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|remote_len
operator|-
literal|1
init|;
name|remote
index|[
name|i
index|]
operator|==
literal|'/'
operator|&&
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
empty_stmt|;
name|remote_len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
literal|4
operator|<
name|i
operator|&&
operator|!
name|strncmp
argument_list|(
literal|".git"
argument_list|,
name|remote
operator|+
name|i
operator|-
literal|3
argument_list|,
literal|4
argument_list|)
condition|)
name|remote_len
operator|=
name|i
operator|-
literal|3
expr_stmt|;
name|note_len
operator|=
name|sprintf
argument_list|(
name|note
argument_list|,
literal|"%s\t%s\t"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
condition|?
name|commit
operator|->
name|object
operator|.
name|sha1
else|:
name|sha1
argument_list|)
argument_list|,
name|not_for_merge
condition|?
literal|"not-for-merge"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|what
condition|)
block|{
if|if
condition|(
operator|*
name|kind
condition|)
name|note_len
operator|+=
name|sprintf
argument_list|(
name|note
operator|+
name|note_len
argument_list|,
literal|"%s "
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|note_len
operator|+=
name|sprintf
argument_list|(
name|note
operator|+
name|note_len
argument_list|,
literal|"'%s' of "
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
name|note_len
operator|+=
name|sprintf
argument_list|(
name|note
operator|+
name|note_len
argument_list|,
literal|"%.*s"
argument_list|,
name|remote_len
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|note
argument_list|)
expr_stmt|;
return|return
name|update_local_ref
argument_list|(
name|local_name
argument_list|,
name|head
argument_list|,
name|note
argument_list|,
name|verbose
argument_list|,
name|force
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_fetch__tool
name|int
name|cmd_fetch__tool
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|verbose
init|=
literal|0
decl_stmt|;
name|int
name|force
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
operator|<
name|argc
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
name|argv
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-v"
argument_list|,
name|arg
argument_list|)
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-f"
argument_list|,
name|arg
argument_list|)
condition|)
name|force
operator|=
literal|1
expr_stmt|;
else|else
break|break;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"Missing subcommand"
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"append-fetch-head"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|result
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|8
condition|)
return|return
name|error
argument_list|(
literal|"append-fetch-head takes 6 args"
argument_list|)
return|;
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"FETCH_HEAD"
argument_list|)
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|result
operator|=
name|append_fetch_head
argument_list|(
name|fp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|,
name|argv
index|[
literal|6
index|]
argument_list|,
operator|!
operator|!
name|argv
index|[
literal|7
index|]
index|[
literal|0
index|]
argument_list|,
name|verbose
argument_list|,
name|force
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"update-local-ref"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
return|return
name|error
argument_list|(
literal|"update-local-ref takes 3 args"
argument_list|)
return|;
return|return
name|update_local_ref
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|verbose
argument_list|,
name|force
argument_list|)
return|;
block|}
return|return
name|error
argument_list|(
literal|"Unknown subcommand: %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function
end_unit
