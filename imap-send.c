begin_unit
begin_comment
comment|/*  * git-imap-send - drops patches into an imap Drafts folder  *                 derived from isync/mbsync - mailbox synchronizer  *  * Copyright (C) 2000-2002 Michael R. Elkins<me@mutt.org>  * Copyright (C) 2002-2004 Oswald Buddenhagen<ossi@users.sf.net>  * Copyright (C) 2004 Theodore Y. Ts'o<tytso@mit.edu>  * Copyright (C) 2006 Mike McCormack  *  *  This program is free software; you can redistribute it and/or modify  *  it under the terms of the GNU General Public License as published by  *  the Free Software Foundation; either version 2 of the License, or  *  (at your option) any later version.  *  *  This program is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with this program; if not, write to the Free Software  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|NO_OPENSSL
end_ifdef
begin_typedef
DECL|typedef|SSL
typedef|typedef
name|void
modifier|*
name|SSL
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|store_conf
struct|struct
name|store_conf
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* should this be here? its interpretation is driver-specific */
DECL|member|map_inbox
name|char
modifier|*
name|map_inbox
decl_stmt|;
DECL|member|trash
name|char
modifier|*
name|trash
decl_stmt|;
DECL|member|max_size
name|unsigned
name|max_size
decl_stmt|;
comment|/* off_t is overkill */
DECL|member|trash_remote_new
DECL|member|trash_only_new
name|unsigned
name|trash_remote_new
range|:
literal|1
decl_stmt|,
name|trash_only_new
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|string_list
struct|struct
name|string_list
block|{
DECL|member|next
name|struct
name|string_list
modifier|*
name|next
decl_stmt|;
DECL|member|string
name|char
name|string
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|channel_conf
struct|struct
name|channel_conf
block|{
DECL|member|next
name|struct
name|channel_conf
modifier|*
name|next
decl_stmt|;
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|master
DECL|member|slave
name|struct
name|store_conf
modifier|*
name|master
decl_stmt|,
modifier|*
name|slave
decl_stmt|;
DECL|member|master_name
DECL|member|slave_name
name|char
modifier|*
name|master_name
decl_stmt|,
modifier|*
name|slave_name
decl_stmt|;
DECL|member|sync_state
name|char
modifier|*
name|sync_state
decl_stmt|;
DECL|member|patterns
name|struct
name|string_list
modifier|*
name|patterns
decl_stmt|;
DECL|member|mops
DECL|member|sops
name|int
name|mops
decl_stmt|,
name|sops
decl_stmt|;
DECL|member|max_messages
name|unsigned
name|max_messages
decl_stmt|;
comment|/* for slave only */
block|}
struct|;
end_struct
begin_struct
DECL|struct|group_conf
struct|struct
name|group_conf
block|{
DECL|member|next
name|struct
name|group_conf
modifier|*
name|next
decl_stmt|;
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|channels
name|struct
name|string_list
modifier|*
name|channels
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* For message->status */
end_comment
begin_define
DECL|macro|M_RECENT
define|#
directive|define
name|M_RECENT
value|(1<<0)
end_define
begin_comment
DECL|macro|M_RECENT
comment|/* unsyncable flag; maildir_* depend on this being 1<<0 */
end_comment
begin_define
DECL|macro|M_DEAD
define|#
directive|define
name|M_DEAD
value|(1<<1)
end_define
begin_comment
DECL|macro|M_DEAD
comment|/* expunged */
end_comment
begin_define
DECL|macro|M_FLAGS
define|#
directive|define
name|M_FLAGS
value|(1<<2)
end_define
begin_comment
DECL|macro|M_FLAGS
comment|/* flags fetched */
end_comment
begin_struct
DECL|struct|message
struct|struct
name|message
block|{
DECL|member|next
name|struct
name|message
modifier|*
name|next
decl_stmt|;
comment|/* struct string_list *keywords; */
DECL|member|size
name|size_t
name|size
decl_stmt|;
comment|/* zero implies "not fetched" */
DECL|member|uid
name|int
name|uid
decl_stmt|;
DECL|member|flags
DECL|member|status
name|unsigned
name|char
name|flags
decl_stmt|,
name|status
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|store
struct|struct
name|store
block|{
DECL|member|conf
name|struct
name|store_conf
modifier|*
name|conf
decl_stmt|;
comment|/* foreign */
comment|/* currently open mailbox */
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* foreign! maybe preset? */
DECL|member|path
name|char
modifier|*
name|path
decl_stmt|;
comment|/* own */
DECL|member|msgs
name|struct
name|message
modifier|*
name|msgs
decl_stmt|;
comment|/* own */
DECL|member|uidvalidity
name|int
name|uidvalidity
decl_stmt|;
DECL|member|opts
name|unsigned
name|char
name|opts
decl_stmt|;
comment|/* maybe preset? */
comment|/* note that the following do _not_ reflect stats from msgs, but mailbox totals */
DECL|member|count
name|int
name|count
decl_stmt|;
comment|/* # of messages */
DECL|member|recent
name|int
name|recent
decl_stmt|;
comment|/* # of recent messages - don't trust this beyond the initial read */
block|}
struct|;
end_struct
begin_struct
DECL|struct|msg_data
struct|struct
name|msg_data
block|{
DECL|member|data
name|char
modifier|*
name|data
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|flags
name|unsigned
name|char
name|flags
decl_stmt|;
DECL|member|crlf
name|unsigned
name|int
name|crlf
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|DRV_OK
define|#
directive|define
name|DRV_OK
value|0
end_define
begin_define
DECL|macro|DRV_MSG_BAD
define|#
directive|define
name|DRV_MSG_BAD
value|-1
end_define
begin_define
DECL|macro|DRV_BOX_BAD
define|#
directive|define
name|DRV_BOX_BAD
value|-2
end_define
begin_define
DECL|macro|DRV_STORE_BAD
define|#
directive|define
name|DRV_STORE_BAD
value|-3
end_define
begin_decl_stmt
DECL|variable|Verbose
DECL|variable|Quiet
specifier|static
name|int
name|Verbose
decl_stmt|,
name|Quiet
decl_stmt|;
end_decl_stmt
begin_function_decl
specifier|static
name|void
name|imap_info
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|imap_warn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|char
modifier|*
name|next_arg
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|free_generic_messages
parameter_list|(
name|struct
name|message
modifier|*
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|nfsnprintf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|blen
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|nfvasprintf
specifier|static
name|int
name|nfvasprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|strp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|tmp
index|[
literal|8192
index|]
decl_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Fatal: Out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
name|die
argument_list|(
literal|"imap command overflow!"
argument_list|)
expr_stmt|;
operator|*
name|strp
operator|=
name|xmemdupz
argument_list|(
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|arc4_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|unsigned
name|char
name|arc4_getbyte
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_struct
DECL|struct|imap_server_conf
struct|struct
name|imap_server_conf
block|{
DECL|member|name
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|tunnel
name|char
modifier|*
name|tunnel
decl_stmt|;
DECL|member|host
name|char
modifier|*
name|host
decl_stmt|;
DECL|member|port
name|int
name|port
decl_stmt|;
DECL|member|user
name|char
modifier|*
name|user
decl_stmt|;
DECL|member|pass
name|char
modifier|*
name|pass
decl_stmt|;
DECL|member|use_ssl
name|int
name|use_ssl
decl_stmt|;
DECL|member|ssl_verify
name|int
name|ssl_verify
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|imap_store_conf
struct|struct
name|imap_store_conf
block|{
DECL|member|gen
name|struct
name|store_conf
name|gen
decl_stmt|;
DECL|member|server
name|struct
name|imap_server_conf
modifier|*
name|server
decl_stmt|;
DECL|member|use_namespace
name|unsigned
name|use_namespace
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|NIL
define|#
directive|define
name|NIL
value|(void *)0x1
end_define
begin_define
DECL|macro|LIST
define|#
directive|define
name|LIST
value|(void *)0x2
end_define
begin_struct
DECL|struct|imap_list
struct|struct
name|imap_list
block|{
DECL|member|next
DECL|member|child
name|struct
name|imap_list
modifier|*
name|next
decl_stmt|,
modifier|*
name|child
decl_stmt|;
DECL|member|val
name|char
modifier|*
name|val
decl_stmt|;
DECL|member|len
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|imap_socket
struct|struct
name|imap_socket
block|{
DECL|member|fd
name|int
name|fd
decl_stmt|;
DECL|member|ssl
name|SSL
modifier|*
name|ssl
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|imap_buffer
struct|struct
name|imap_buffer
block|{
DECL|member|sock
name|struct
name|imap_socket
name|sock
decl_stmt|;
DECL|member|bytes
name|int
name|bytes
decl_stmt|;
DECL|member|offset
name|int
name|offset
decl_stmt|;
DECL|member|buf
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct_decl
struct_decl|struct
name|imap_cmd
struct_decl|;
end_struct_decl
begin_struct
DECL|struct|imap
struct|struct
name|imap
block|{
DECL|member|uidnext
name|int
name|uidnext
decl_stmt|;
comment|/* from SELECT responses */
DECL|member|ns_personal
DECL|member|ns_other
DECL|member|ns_shared
name|struct
name|imap_list
modifier|*
name|ns_personal
decl_stmt|,
modifier|*
name|ns_other
decl_stmt|,
modifier|*
name|ns_shared
decl_stmt|;
comment|/* NAMESPACE info */
DECL|member|caps
DECL|member|rcaps
name|unsigned
name|caps
decl_stmt|,
name|rcaps
decl_stmt|;
comment|/* CAPABILITY results */
comment|/* command queue */
DECL|member|nexttag
DECL|member|num_in_progress
DECL|member|literal_pending
name|int
name|nexttag
decl_stmt|,
name|num_in_progress
decl_stmt|,
name|literal_pending
decl_stmt|;
DECL|member|in_progress
DECL|member|in_progress_append
name|struct
name|imap_cmd
modifier|*
name|in_progress
decl_stmt|,
modifier|*
modifier|*
name|in_progress_append
decl_stmt|;
DECL|member|buf
name|struct
name|imap_buffer
name|buf
decl_stmt|;
comment|/* this is BIG, so put it last */
block|}
struct|;
end_struct
begin_struct
DECL|struct|imap_store
struct|struct
name|imap_store
block|{
DECL|member|gen
name|struct
name|store
name|gen
decl_stmt|;
DECL|member|uidvalidity
name|int
name|uidvalidity
decl_stmt|;
DECL|member|imap
name|struct
name|imap
modifier|*
name|imap
decl_stmt|;
DECL|member|prefix
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
DECL|member|trashnc
name|unsigned
comment|/*currentnc:1,*/
name|trashnc
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|imap_cmd_cb
struct|struct
name|imap_cmd_cb
block|{
DECL|member|cont
name|int
function_decl|(
modifier|*
name|cont
function_decl|)
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|prompt
parameter_list|)
function_decl|;
DECL|member|done
name|void
function_decl|(
modifier|*
name|done
function_decl|)
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd
modifier|*
name|cmd
parameter_list|,
name|int
name|response
parameter_list|)
function_decl|;
DECL|member|ctx
name|void
modifier|*
name|ctx
decl_stmt|;
DECL|member|data
name|char
modifier|*
name|data
decl_stmt|;
DECL|member|dlen
name|int
name|dlen
decl_stmt|;
DECL|member|uid
name|int
name|uid
decl_stmt|;
DECL|member|create
DECL|member|trycreate
name|unsigned
name|create
range|:
literal|1
decl_stmt|,
name|trycreate
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|imap_cmd
struct|struct
name|imap_cmd
block|{
DECL|member|next
name|struct
name|imap_cmd
modifier|*
name|next
decl_stmt|;
DECL|member|cb
name|struct
name|imap_cmd_cb
name|cb
decl_stmt|;
DECL|member|cmd
name|char
modifier|*
name|cmd
decl_stmt|;
DECL|member|tag
name|int
name|tag
decl_stmt|;
block|}
struct|;
end_struct
begin_define
DECL|macro|CAP
define|#
directive|define
name|CAP
parameter_list|(
name|cap
parameter_list|)
value|(imap->caps& (1<< (cap)))
end_define
begin_enum
DECL|enum|CAPABILITY
enum|enum
name|CAPABILITY
block|{
DECL|enumerator|NOLOGIN
name|NOLOGIN
init|=
literal|0
block|,
DECL|enumerator|UIDPLUS
name|UIDPLUS
block|,
DECL|enumerator|LITERALPLUS
name|LITERALPLUS
block|,
DECL|enumerator|NAMESPACE
name|NAMESPACE
block|,
DECL|enumerator|STARTTLS
name|STARTTLS
block|, }
enum|;
end_enum
begin_decl_stmt
DECL|variable|cap_list
specifier|static
specifier|const
name|char
modifier|*
name|cap_list
index|[]
init|=
block|{
literal|"LOGINDISABLED"
block|,
literal|"UIDPLUS"
block|,
literal|"LITERAL+"
block|,
literal|"NAMESPACE"
block|,
literal|"STARTTLS"
block|, }
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|RESP_OK
define|#
directive|define
name|RESP_OK
value|0
end_define
begin_define
DECL|macro|RESP_NO
define|#
directive|define
name|RESP_NO
value|1
end_define
begin_define
DECL|macro|RESP_BAD
define|#
directive|define
name|RESP_BAD
value|2
end_define
begin_function_decl
specifier|static
name|int
name|get_cmd_result
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd
modifier|*
name|tcmd
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|variable|Flags
specifier|static
specifier|const
name|char
modifier|*
name|Flags
index|[]
init|=
block|{
literal|"Draft"
block|,
literal|"Flagged"
block|,
literal|"Answered"
block|,
literal|"Seen"
block|,
literal|"Deleted"
block|, }
decl_stmt|;
end_decl_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENSSL
end_ifndef
begin_function
DECL|function|ssl_socket_perror
specifier|static
name|void
name|ssl_socket_perror
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|func
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|socket_perror
specifier|static
name|void
name|socket_perror
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|struct
name|imap_socket
modifier|*
name|sock
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NO_OPENSSL
if|if
condition|(
name|sock
operator|->
name|ssl
condition|)
block|{
name|int
name|sslerr
init|=
name|SSL_get_error
argument_list|(
name|sock
operator|->
name|ssl
argument_list|,
name|ret
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sslerr
condition|)
block|{
case|case
name|SSL_ERROR_NONE
case|:
break|break;
case|case
name|SSL_ERROR_SYSCALL
case|:
name|perror
argument_list|(
literal|"SSL_connect"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ssl_socket_perror
argument_list|(
literal|"SSL_connect"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|perror
argument_list|(
name|func
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unexpected EOF\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ssl_socket_connect
specifier|static
name|int
name|ssl_socket_connect
parameter_list|(
name|struct
name|imap_socket
modifier|*
name|sock
parameter_list|,
name|int
name|use_tls_only
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NO_OPENSSL
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SSL requested but SSL support not compiled in\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
else|#
directive|else
name|SSL_METHOD
modifier|*
name|meth
decl_stmt|;
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|SSL_library_init
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
if|if
condition|(
name|use_tls_only
condition|)
name|meth
operator|=
name|TLSv1_method
argument_list|()
expr_stmt|;
else|else
name|meth
operator|=
name|SSLv23_method
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|meth
condition|)
block|{
name|ssl_socket_perror
argument_list|(
literal|"SSLv23_method"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|meth
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
condition|)
name|SSL_CTX_set_verify
argument_list|(
name|ctx
argument_list|,
name|SSL_VERIFY_PEER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SSL_CTX_set_default_verify_paths
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|ssl_socket_perror
argument_list|(
literal|"SSL_CTX_set_default_verify_paths"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sock
operator|->
name|ssl
operator|=
name|SSL_new
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sock
operator|->
name|ssl
condition|)
block|{
name|ssl_socket_perror
argument_list|(
literal|"SSL_new"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|SSL_set_fd
argument_list|(
name|sock
operator|->
name|ssl
argument_list|,
name|sock
operator|->
name|fd
argument_list|)
condition|)
block|{
name|ssl_socket_perror
argument_list|(
literal|"SSL_set_fd"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
name|SSL_connect
argument_list|(
name|sock
operator|->
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
name|socket_perror
argument_list|(
literal|"SSL_connect"
argument_list|,
name|sock
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|socket_read
specifier|static
name|int
name|socket_read
parameter_list|(
name|struct
name|imap_socket
modifier|*
name|sock
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|ssize_t
name|n
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENSSL
if|if
condition|(
name|sock
operator|->
name|ssl
condition|)
name|n
operator|=
name|SSL_read
argument_list|(
name|sock
operator|->
name|ssl
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|n
operator|=
name|xread
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|socket_perror
argument_list|(
literal|"read"
argument_list|,
name|sock
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|socket_write
specifier|static
name|int
name|socket_write
parameter_list|(
name|struct
name|imap_socket
modifier|*
name|sock
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENSSL
if|if
condition|(
name|sock
operator|->
name|ssl
condition|)
name|n
operator|=
name|SSL_write
argument_list|(
name|sock
operator|->
name|ssl
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|n
operator|=
name|write_in_full
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|len
condition|)
block|{
name|socket_perror
argument_list|(
literal|"write"
argument_list|,
name|sock
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function
begin_function
DECL|function|socket_shutdown
specifier|static
name|void
name|socket_shutdown
parameter_list|(
name|struct
name|imap_socket
modifier|*
name|sock
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NO_OPENSSL
if|if
condition|(
name|sock
operator|->
name|ssl
condition|)
block|{
name|SSL_shutdown
argument_list|(
name|sock
operator|->
name|ssl
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|sock
operator|->
name|ssl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* simple line buffering */
end_comment
begin_function
DECL|function|buffer_gets
specifier|static
name|int
name|buffer_gets
parameter_list|(
name|struct
name|imap_buffer
modifier|*
name|b
parameter_list|,
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|start
init|=
name|b
operator|->
name|offset
decl_stmt|;
operator|*
name|s
operator|=
name|b
operator|->
name|buf
operator|+
name|start
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* make sure we have enough data to read the \r\n sequence */
if|if
condition|(
name|b
operator|->
name|offset
operator|+
literal|1
operator|>=
name|b
operator|->
name|bytes
condition|)
block|{
if|if
condition|(
name|start
condition|)
block|{
comment|/* shift down used bytes */
operator|*
name|s
operator|=
name|b
operator|->
name|buf
expr_stmt|;
name|assert
argument_list|(
name|start
operator|<=
name|b
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|n
operator|=
name|b
operator|->
name|bytes
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|memmove
argument_list|(
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|buf
operator|+
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|b
operator|->
name|offset
operator|-=
name|start
expr_stmt|;
name|b
operator|->
name|bytes
operator|=
name|n
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|=
name|socket_read
argument_list|(
operator|&
name|b
operator|->
name|sock
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|->
name|buf
argument_list|)
operator|-
name|b
operator|->
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|b
operator|->
name|bytes
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|buf
index|[
name|b
operator|->
name|offset
index|]
operator|==
literal|'\r'
condition|)
block|{
name|assert
argument_list|(
name|b
operator|->
name|offset
operator|+
literal|1
operator|<
name|b
operator|->
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|buf
index|[
name|b
operator|->
name|offset
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|b
operator|->
name|buf
index|[
name|b
operator|->
name|offset
index|]
operator|=
literal|0
expr_stmt|;
comment|/* terminate the string */
name|b
operator|->
name|offset
operator|+=
literal|2
expr_stmt|;
comment|/* next line */
if|if
condition|(
name|Verbose
condition|)
name|puts
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|b
operator|->
name|offset
operator|++
expr_stmt|;
block|}
comment|/* not reached */
block|}
end_function
begin_function
DECL|function|imap_info
specifier|static
name|void
name|imap_info
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
if|if
condition|(
operator|!
name|Quiet
condition|)
block|{
name|va_start
argument_list|(
name|va
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|msg
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|imap_warn
specifier|static
name|void
name|imap_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
if|if
condition|(
name|Quiet
operator|<
literal|2
condition|)
block|{
name|va_start
argument_list|(
name|va
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|next_arg
specifier|static
name|char
modifier|*
name|next_arg
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
operator|*
name|s
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|s
argument_list|)
condition|)
operator|(
operator|*
name|s
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|s
operator|==
literal|'"'
condition|)
block|{
operator|++
operator|*
name|s
expr_stmt|;
name|ret
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
name|strchr
argument_list|(
operator|*
name|s
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|*
name|s
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|s
argument_list|)
condition|)
operator|(
operator|*
name|s
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|s
condition|)
operator|*
operator|(
operator|*
name|s
operator|)
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|s
condition|)
operator|*
name|s
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|free_generic_messages
specifier|static
name|void
name|free_generic_messages
parameter_list|(
name|struct
name|message
modifier|*
name|msgs
parameter_list|)
block|{
name|struct
name|message
modifier|*
name|tmsg
decl_stmt|;
for|for
control|(
init|;
name|msgs
condition|;
name|msgs
operator|=
name|tmsg
control|)
block|{
name|tmsg
operator|=
name|msgs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|msgs
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|nfsnprintf
specifier|static
name|int
name|nfsnprintf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|blen
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|blen
operator|<=
literal|0
operator|||
call|(
name|unsigned
call|)
argument_list|(
name|ret
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|blen
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|blen
condition|)
name|die
argument_list|(
literal|"Fatal: buffer too small. Please report a bug."
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_struct
specifier|static
struct|struct
block|{
DECL|member|i
DECL|member|j
DECL|member|s
name|unsigned
name|char
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
index|[
literal|256
index|]
decl_stmt|;
block|}
DECL|variable|rs
name|rs
struct|;
end_struct
begin_function
DECL|function|arc4_init
specifier|static
name|void
name|arc4_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|unsigned
name|char
name|j
decl_stmt|,
name|si
decl_stmt|,
name|dat
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/urandom"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/random"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal: no random number source available.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|dat
argument_list|,
literal|128
argument_list|)
operator|!=
literal|128
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal: cannot read random number source.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|rs
operator|.
name|s
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|si
operator|=
name|rs
operator|.
name|s
index|[
name|i
index|]
expr_stmt|;
name|j
operator|+=
name|si
operator|+
name|dat
index|[
name|i
operator|&
literal|127
index|]
expr_stmt|;
name|rs
operator|.
name|s
index|[
name|i
index|]
operator|=
name|rs
operator|.
name|s
index|[
name|j
index|]
expr_stmt|;
name|rs
operator|.
name|s
index|[
name|j
index|]
operator|=
name|si
expr_stmt|;
block|}
name|rs
operator|.
name|i
operator|=
name|rs
operator|.
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|arc4_getbyte
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|arc4_getbyte
specifier|static
name|unsigned
name|char
name|arc4_getbyte
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|si
decl_stmt|,
name|sj
decl_stmt|;
name|rs
operator|.
name|i
operator|++
expr_stmt|;
name|si
operator|=
name|rs
operator|.
name|s
index|[
name|rs
operator|.
name|i
index|]
expr_stmt|;
name|rs
operator|.
name|j
operator|+=
name|si
expr_stmt|;
name|sj
operator|=
name|rs
operator|.
name|s
index|[
name|rs
operator|.
name|j
index|]
expr_stmt|;
name|rs
operator|.
name|s
index|[
name|rs
operator|.
name|i
index|]
operator|=
name|sj
expr_stmt|;
name|rs
operator|.
name|s
index|[
name|rs
operator|.
name|j
index|]
operator|=
name|si
expr_stmt|;
return|return
name|rs
operator|.
name|s
index|[
operator|(
name|si
operator|+
name|sj
operator|)
operator|&
literal|0xff
index|]
return|;
block|}
end_function
begin_function
DECL|function|v_issue_imap_cmd
specifier|static
name|struct
name|imap_cmd
modifier|*
name|v_issue_imap_cmd
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd_cb
modifier|*
name|cb
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|imap
modifier|*
name|imap
init|=
name|ctx
operator|->
name|imap
decl_stmt|;
name|struct
name|imap_cmd
modifier|*
name|cmd
decl_stmt|;
name|int
name|n
decl_stmt|,
name|bufl
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|cmd
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|imap_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|nfvasprintf
argument_list|(
operator|&
name|cmd
operator|->
name|cmd
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|tag
operator|=
operator|++
name|imap
operator|->
name|nexttag
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|cmd
operator|->
name|cb
operator|=
operator|*
name|cb
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|cmd
operator|->
name|cb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
operator|->
name|cb
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|imap
operator|->
name|literal_pending
condition|)
name|get_cmd_result
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bufl
operator|=
name|nfsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|cmd
operator|->
name|cb
operator|.
name|data
condition|?
name|CAP
argument_list|(
name|LITERALPLUS
argument_list|)
condition|?
literal|"%d %s{%d+}\r\n"
else|:
literal|"%d %s{%d}\r\n"
else|:
literal|"%d %s\r\n"
argument_list|,
name|cmd
operator|->
name|tag
argument_list|,
name|cmd
operator|->
name|cmd
argument_list|,
name|cmd
operator|->
name|cb
operator|.
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|imap
operator|->
name|num_in_progress
condition|)
name|printf
argument_list|(
literal|"(%d in progress) "
argument_list|,
name|imap
operator|->
name|num_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|cmd
operator|->
name|cmd
argument_list|,
literal|"LOGIN"
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|">>> %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|">>> %d LOGIN<user><pass>\n"
argument_list|,
name|cmd
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|socket_write
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
name|buf
argument_list|,
name|bufl
argument_list|)
operator|!=
name|bufl
condition|)
block|{
name|free
argument_list|(
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|free
argument_list|(
name|cb
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cmd
operator|->
name|cb
operator|.
name|data
condition|)
block|{
if|if
condition|(
name|CAP
argument_list|(
name|LITERALPLUS
argument_list|)
condition|)
block|{
name|n
operator|=
name|socket_write
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
name|cmd
operator|->
name|cb
operator|.
name|data
argument_list|,
name|cmd
operator|->
name|cb
operator|.
name|dlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
operator|->
name|cb
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|cmd
operator|->
name|cb
operator|.
name|dlen
operator|||
operator|(
name|n
operator|=
name|socket_write
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
literal|2
condition|)
block|{
name|free
argument_list|(
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cmd
operator|->
name|cb
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|imap
operator|->
name|literal_pending
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|cb
operator|.
name|cont
condition|)
name|imap
operator|->
name|literal_pending
operator|=
literal|1
expr_stmt|;
name|cmd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|imap
operator|->
name|in_progress_append
operator|=
name|cmd
expr_stmt|;
name|imap
operator|->
name|in_progress_append
operator|=
operator|&
name|cmd
operator|->
name|next
expr_stmt|;
name|imap
operator|->
name|num_in_progress
operator|++
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function
begin_function
DECL|function|issue_imap_cmd
specifier|static
name|struct
name|imap_cmd
modifier|*
name|issue_imap_cmd
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd_cb
modifier|*
name|cb
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|imap_cmd
modifier|*
name|ret
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|v_issue_imap_cmd
argument_list|(
name|ctx
argument_list|,
name|cb
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|imap_exec
specifier|static
name|int
name|imap_exec
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd_cb
modifier|*
name|cb
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|struct
name|imap_cmd
modifier|*
name|cmdp
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|cmdp
operator|=
name|v_issue_imap_cmd
argument_list|(
name|ctx
argument_list|,
name|cb
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmdp
condition|)
return|return
name|RESP_BAD
return|;
return|return
name|get_cmd_result
argument_list|(
name|ctx
argument_list|,
name|cmdp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|imap_exec_m
specifier|static
name|int
name|imap_exec_m
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd_cb
modifier|*
name|cb
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|struct
name|imap_cmd
modifier|*
name|cmdp
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|cmdp
operator|=
name|v_issue_imap_cmd
argument_list|(
name|ctx
argument_list|,
name|cb
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmdp
condition|)
return|return
name|DRV_STORE_BAD
return|;
switch|switch
condition|(
name|get_cmd_result
argument_list|(
name|ctx
argument_list|,
name|cmdp
argument_list|)
condition|)
block|{
case|case
name|RESP_BAD
case|:
return|return
name|DRV_STORE_BAD
return|;
case|case
name|RESP_NO
case|:
return|return
name|DRV_MSG_BAD
return|;
default|default:
return|return
name|DRV_OK
return|;
block|}
block|}
end_function
begin_function
DECL|function|is_atom
specifier|static
name|int
name|is_atom
parameter_list|(
name|struct
name|imap_list
modifier|*
name|list
parameter_list|)
block|{
return|return
name|list
operator|&&
name|list
operator|->
name|val
operator|&&
name|list
operator|->
name|val
operator|!=
name|NIL
operator|&&
name|list
operator|->
name|val
operator|!=
name|LIST
return|;
block|}
end_function
begin_function
DECL|function|is_list
specifier|static
name|int
name|is_list
parameter_list|(
name|struct
name|imap_list
modifier|*
name|list
parameter_list|)
block|{
return|return
name|list
operator|&&
name|list
operator|->
name|val
operator|==
name|LIST
return|;
block|}
end_function
begin_function
DECL|function|free_list
specifier|static
name|void
name|free_list
parameter_list|(
name|struct
name|imap_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|imap_list
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|tmp
control|)
block|{
name|tmp
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|is_list
argument_list|(
name|list
argument_list|)
condition|)
name|free_list
argument_list|(
name|list
operator|->
name|child
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_atom
argument_list|(
name|list
argument_list|)
condition|)
name|free
argument_list|(
name|list
operator|->
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|parse_imap_list_l
specifier|static
name|int
name|parse_imap_list_l
parameter_list|(
name|struct
name|imap
modifier|*
name|imap
parameter_list|,
name|char
modifier|*
modifier|*
name|sp
parameter_list|,
name|struct
name|imap_list
modifier|*
modifier|*
name|curp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|imap_list
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|*
name|sp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|,
name|bytes
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|level
operator|&&
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
name|s
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|curp
operator|=
name|cur
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cur
argument_list|)
argument_list|)
expr_stmt|;
name|curp
operator|=
operator|&
name|cur
operator|->
name|next
expr_stmt|;
name|cur
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
comment|/* for clean bail */
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
comment|/* sublist */
name|s
operator|++
expr_stmt|;
name|cur
operator|->
name|val
operator|=
name|LIST
expr_stmt|;
if|if
condition|(
name|parse_imap_list_l
argument_list|(
name|imap
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|cur
operator|->
name|child
argument_list|,
name|level
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|bail
goto|;
block|}
elseif|else
if|if
condition|(
name|imap
operator|&&
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* literal */
name|bytes
operator|=
name|cur
operator|->
name|len
operator|=
name|strtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'}'
condition|)
goto|goto
name|bail
goto|;
name|s
operator|=
name|cur
operator|->
name|val
operator|=
name|xmalloc
argument_list|(
name|cur
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* dump whats left over in the input buffer */
name|n
operator|=
name|imap
operator|->
name|buf
operator|.
name|bytes
operator|-
name|imap
operator|->
name|buf
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|bytes
condition|)
comment|/* the entire message fit in the buffer */
name|n
operator|=
name|bytes
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|imap
operator|->
name|buf
operator|.
name|buf
operator|+
name|imap
operator|->
name|buf
operator|.
name|offset
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
name|bytes
operator|-=
name|n
expr_stmt|;
comment|/* mark that we used part of the buffer */
name|imap
operator|->
name|buf
operator|.
name|offset
operator|+=
name|n
expr_stmt|;
comment|/* now read the rest of the message */
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|socket_read
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
name|s
argument_list|,
name|bytes
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|bail
goto|;
name|s
operator|+=
name|n
expr_stmt|;
name|bytes
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|buffer_gets
argument_list|(
operator|&
name|imap
operator|->
name|buf
argument_list|,
operator|&
name|s
argument_list|)
condition|)
goto|goto
name|bail
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
condition|)
block|{
comment|/* quoted string */
name|s
operator|++
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'"'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|bail
goto|;
name|cur
operator|->
name|len
operator|=
name|s
operator|-
name|p
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|cur
operator|->
name|val
operator|=
name|xmemdupz
argument_list|(
name|p
argument_list|,
name|cur
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* atom */
name|p
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|level
operator|&&
operator|*
name|s
operator|==
literal|')'
condition|)
break|break;
name|cur
operator|->
name|len
operator|=
name|s
operator|-
name|p
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|len
operator|==
literal|3
operator|&&
operator|!
name|memcmp
argument_list|(
literal|"NIL"
argument_list|,
name|p
argument_list|,
literal|3
argument_list|)
condition|)
name|cur
operator|->
name|val
operator|=
name|NIL
expr_stmt|;
else|else
name|cur
operator|->
name|val
operator|=
name|xmemdupz
argument_list|(
name|p
argument_list|,
name|cur
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|level
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|bail
goto|;
block|}
operator|*
name|sp
operator|=
name|s
expr_stmt|;
operator|*
name|curp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
name|bail
label|:
operator|*
name|curp
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|parse_imap_list
specifier|static
name|struct
name|imap_list
modifier|*
name|parse_imap_list
parameter_list|(
name|struct
name|imap
modifier|*
name|imap
parameter_list|,
name|char
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|imap_list
modifier|*
name|head
decl_stmt|;
if|if
condition|(
operator|!
name|parse_imap_list_l
argument_list|(
name|imap
argument_list|,
name|sp
argument_list|,
operator|&
name|head
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|head
return|;
name|free_list
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|parse_list
specifier|static
name|struct
name|imap_list
modifier|*
name|parse_list
parameter_list|(
name|char
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
return|return
name|parse_imap_list
argument_list|(
name|NULL
argument_list|,
name|sp
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse_capability
specifier|static
name|void
name|parse_capability
parameter_list|(
name|struct
name|imap
modifier|*
name|imap
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|imap
operator|->
name|caps
operator|=
literal|0x80000000
expr_stmt|;
while|while
condition|(
operator|(
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|cmd
argument_list|)
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cap_list
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cap_list
index|[
name|i
index|]
argument_list|,
name|arg
argument_list|)
condition|)
name|imap
operator|->
name|caps
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|imap
operator|->
name|rcaps
operator|=
name|imap
operator|->
name|caps
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_response_code
specifier|static
name|int
name|parse_response_code
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd_cb
modifier|*
name|cb
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|imap
modifier|*
name|imap
init|=
name|ctx
operator|->
name|imap
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'['
condition|)
return|return
name|RESP_OK
return|;
comment|/* no response code */
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|']'
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: malformed response code\n"
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"UIDVALIDITY"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|s
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ctx
operator|->
name|gen
operator|.
name|uidvalidity
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: malformed UIDVALIDITY status\n"
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"UIDNEXT"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|s
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|imap
operator|->
name|uidnext
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: malformed NEXTUID status\n"
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"CAPABILITY"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|parse_capability
argument_list|(
name|imap
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ALERT"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
comment|/* RFC2060 says that these messages MUST be displayed 		 * to the user 		 */
for|for
control|(
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** IMAP ALERT *** %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|&&
name|cb
operator|->
name|ctx
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"APPENDUID"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|s
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|ctx
operator|->
name|gen
operator|.
name|uidvalidity
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|s
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|cb
operator|->
name|ctx
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: malformed APPENDUID status\n"
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
block|}
return|return
name|RESP_OK
return|;
block|}
end_function
begin_function
DECL|function|get_cmd_result
specifier|static
name|int
name|get_cmd_result
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ctx
parameter_list|,
name|struct
name|imap_cmd
modifier|*
name|tcmd
parameter_list|)
block|{
name|struct
name|imap
modifier|*
name|imap
init|=
name|ctx
operator|->
name|imap
decl_stmt|;
name|struct
name|imap_cmd
modifier|*
name|cmdp
decl_stmt|,
modifier|*
modifier|*
name|pcmdp
decl_stmt|,
modifier|*
name|ncmdp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|,
name|resp
decl_stmt|,
name|resp2
decl_stmt|,
name|tag
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|buffer_gets
argument_list|(
operator|&
name|imap
operator|->
name|buf
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
return|return
name|RESP_BAD
return|;
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: unable to parse untagged response\n"
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"NAMESPACE"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|imap
operator|->
name|ns_personal
operator|=
name|parse_list
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|imap
operator|->
name|ns_other
operator|=
name|parse_list
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|imap
operator|->
name|ns_shared
operator|=
name|parse_list
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"OK"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"BAD"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"NO"
argument_list|,
name|arg
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"BYE"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|resp
operator|=
name|parse_response_code
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|,
name|cmd
argument_list|)
operator|)
operator|!=
name|RESP_OK
condition|)
return|return
name|resp
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"CAPABILITY"
argument_list|,
name|arg
argument_list|)
condition|)
name|parse_capability
argument_list|(
name|imap
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg1
operator|=
name|next_arg
argument_list|(
operator|&
name|cmd
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"EXISTS"
argument_list|,
name|arg1
argument_list|)
condition|)
name|ctx
operator|->
name|gen
operator|.
name|count
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"RECENT"
argument_list|,
name|arg1
argument_list|)
condition|)
name|ctx
operator|->
name|gen
operator|.
name|recent
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: unable to parse untagged response\n"
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|imap
operator|->
name|in_progress
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: unexpected reply: %s %s\n"
argument_list|,
name|arg
argument_list|,
name|cmd
condition|?
name|cmd
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|arg
operator|==
literal|'+'
condition|)
block|{
comment|/* This can happen only with the last command underway, as 			   it enforces a round-trip. */
name|cmdp
operator|=
operator|(
expr|struct
name|imap_cmd
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|imap
operator|->
name|in_progress_append
operator|-
name|offsetof
argument_list|(
expr|struct
name|imap_cmd
argument_list|,
name|next
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cmdp
operator|->
name|cb
operator|.
name|data
condition|)
block|{
name|n
operator|=
name|socket_write
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
name|cmdp
operator|->
name|cb
operator|.
name|data
argument_list|,
name|cmdp
operator|->
name|cb
operator|.
name|dlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdp
operator|->
name|cb
operator|.
name|data
argument_list|)
expr_stmt|;
name|cmdp
operator|->
name|cb
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|(
name|int
operator|)
name|cmdp
operator|->
name|cb
operator|.
name|dlen
condition|)
return|return
name|RESP_BAD
return|;
block|}
elseif|else
if|if
condition|(
name|cmdp
operator|->
name|cb
operator|.
name|cont
condition|)
block|{
if|if
condition|(
name|cmdp
operator|->
name|cb
operator|.
name|cont
argument_list|(
name|ctx
argument_list|,
name|cmdp
argument_list|,
name|cmd
argument_list|)
condition|)
return|return
name|RESP_BAD
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: unexpected command continuation request\n"
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
block|}
if|if
condition|(
name|socket_write
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|RESP_BAD
return|;
if|if
condition|(
operator|!
name|cmdp
operator|->
name|cb
operator|.
name|cont
condition|)
name|imap
operator|->
name|literal_pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|tcmd
condition|)
return|return
name|DRV_OK
return|;
block|}
else|else
block|{
name|tag
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
for|for
control|(
name|pcmdp
operator|=
operator|&
name|imap
operator|->
name|in_progress
init|;
operator|(
name|cmdp
operator|=
operator|*
name|pcmdp
operator|)
condition|;
name|pcmdp
operator|=
operator|&
name|cmdp
operator|->
name|next
control|)
if|if
condition|(
name|cmdp
operator|->
name|tag
operator|==
name|tag
condition|)
goto|goto
name|gottag
goto|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: unexpected tag %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|RESP_BAD
return|;
name|gottag
label|:
if|if
condition|(
operator|!
operator|(
operator|*
name|pcmdp
operator|=
name|cmdp
operator|->
name|next
operator|)
condition|)
name|imap
operator|->
name|in_progress_append
operator|=
name|pcmdp
expr_stmt|;
name|imap
operator|->
name|num_in_progress
operator|--
expr_stmt|;
if|if
condition|(
name|cmdp
operator|->
name|cb
operator|.
name|cont
operator|||
name|cmdp
operator|->
name|cb
operator|.
name|data
condition|)
name|imap
operator|->
name|literal_pending
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"OK"
argument_list|,
name|arg
argument_list|)
condition|)
name|resp
operator|=
name|DRV_OK
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"NO"
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmdp
operator|->
name|cb
operator|.
name|create
operator|&&
name|cmd
operator|&&
operator|(
name|cmdp
operator|->
name|cb
operator|.
name|trycreate
operator|||
operator|!
name|memcmp
argument_list|(
name|cmd
argument_list|,
literal|"[TRYCREATE]"
argument_list|,
literal|11
argument_list|)
operator|)
condition|)
block|{
comment|/* SELECT, APPEND or UID COPY */
name|p
operator|=
name|strchr
argument_list|(
name|cmdp
operator|->
name|cmd
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|issue_imap_cmd
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|"CREATE \"%.*s\""
argument_list|,
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'"'
argument_list|)
operator|-
name|p
operator|+
literal|1
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|resp
operator|=
name|RESP_BAD
expr_stmt|;
goto|goto
name|normal
goto|;
block|}
comment|/* not waiting here violates the spec, but a server that does not 						   grok this nonetheless violates it too. */
name|cmdp
operator|->
name|cb
operator|.
name|create
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ncmdp
operator|=
name|issue_imap_cmd
argument_list|(
name|ctx
argument_list|,
operator|&
name|cmdp
operator|->
name|cb
argument_list|,
literal|"%s"
argument_list|,
name|cmdp
operator|->
name|cmd
argument_list|)
operator|)
condition|)
block|{
name|resp
operator|=
name|RESP_BAD
expr_stmt|;
goto|goto
name|normal
goto|;
block|}
name|free
argument_list|(
name|cmdp
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcmd
condition|)
return|return
literal|0
return|;
comment|/* ignored */
if|if
condition|(
name|cmdp
operator|==
name|tcmd
condition|)
name|tcmd
operator|=
name|ncmdp
expr_stmt|;
continue|continue;
block|}
name|resp
operator|=
name|RESP_NO
expr_stmt|;
block|}
else|else
comment|/*if (!strcmp("BAD", arg))*/
name|resp
operator|=
name|RESP_BAD
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP command '%s' returned response (%s) - %s\n"
argument_list|,
name|memcmp
argument_list|(
name|cmdp
operator|->
name|cmd
argument_list|,
literal|"LOGIN"
argument_list|,
literal|5
argument_list|)
condition|?
name|cmdp
operator|->
name|cmd
else|:
literal|"LOGIN<user><pass>"
argument_list|,
name|arg
argument_list|,
name|cmd
condition|?
name|cmd
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|resp2
operator|=
name|parse_response_code
argument_list|(
name|ctx
argument_list|,
operator|&
name|cmdp
operator|->
name|cb
argument_list|,
name|cmd
argument_list|)
operator|)
operator|>
name|resp
condition|)
name|resp
operator|=
name|resp2
expr_stmt|;
name|normal
label|:
if|if
condition|(
name|cmdp
operator|->
name|cb
operator|.
name|done
condition|)
name|cmdp
operator|->
name|cb
operator|.
name|done
argument_list|(
name|ctx
argument_list|,
name|cmdp
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdp
operator|->
name|cb
operator|.
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdp
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tcmd
operator|||
name|tcmd
operator|==
name|cmdp
condition|)
return|return
name|resp
return|;
block|}
block|}
comment|/* not reached */
block|}
end_function
begin_function
DECL|function|imap_close_server
specifier|static
name|void
name|imap_close_server
parameter_list|(
name|struct
name|imap_store
modifier|*
name|ictx
parameter_list|)
block|{
name|struct
name|imap
modifier|*
name|imap
init|=
name|ictx
operator|->
name|imap
decl_stmt|;
if|if
condition|(
name|imap
operator|->
name|buf
operator|.
name|sock
operator|.
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|imap_exec
argument_list|(
name|ictx
argument_list|,
name|NULL
argument_list|,
literal|"LOGOUT"
argument_list|)
expr_stmt|;
name|socket_shutdown
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|)
expr_stmt|;
block|}
name|free_list
argument_list|(
name|imap
operator|->
name|ns_personal
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|imap
operator|->
name|ns_other
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
name|imap
operator|->
name|ns_shared
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imap
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|imap_close_store
specifier|static
name|void
name|imap_close_store
parameter_list|(
name|struct
name|store
modifier|*
name|ctx
parameter_list|)
block|{
name|imap_close_server
argument_list|(
operator|(
expr|struct
name|imap_store
operator|*
operator|)
name|ctx
argument_list|)
expr_stmt|;
name|free_generic_messages
argument_list|(
name|ctx
operator|->
name|msgs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|imap_open_store
specifier|static
name|struct
name|store
modifier|*
name|imap_open_store
parameter_list|(
name|struct
name|imap_server_conf
modifier|*
name|srvc
parameter_list|)
block|{
name|struct
name|imap_store
modifier|*
name|ctx
decl_stmt|;
name|struct
name|imap
modifier|*
name|imap
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|rsp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|he
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|s
decl_stmt|,
name|a
index|[
literal|2
index|]
decl_stmt|,
name|preauth
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|ctx
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|imap
operator|=
name|imap
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|imap
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|imap
operator|->
name|buf
operator|.
name|sock
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|imap
operator|->
name|in_progress_append
operator|=
operator|&
name|imap
operator|->
name|in_progress
expr_stmt|;
comment|/* open connection to IMAP server */
if|if
condition|(
name|srvc
operator|->
name|tunnel
condition|)
block|{
name|imap_info
argument_list|(
literal|"Starting tunnel '%s'... "
argument_list|,
name|srvc
operator|->
name|tunnel
argument_list|)
expr_stmt|;
if|if
condition|(
name|socketpair
argument_list|(
name|PF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|a
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"socketpair"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pid
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|dup2
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|srvc
operator|->
name|tunnel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|imap
operator|->
name|buf
operator|.
name|sock
operator|.
name|fd
operator|=
name|a
index|[
literal|1
index|]
expr_stmt|;
name|imap_info
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|srvc
operator|->
name|port
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|imap_info
argument_list|(
literal|"Resolving %s... "
argument_list|,
name|srvc
operator|->
name|host
argument_list|)
expr_stmt|;
name|he
operator|=
name|gethostbyname
argument_list|(
name|srvc
operator|->
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
block|{
name|perror
argument_list|(
literal|"gethostbyname"
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|imap_info
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|he
operator|->
name|h_addr_list
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imap_info
argument_list|(
literal|"Connecting to %s:%hu... "
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|imap
operator|->
name|buf
operator|.
name|sock
operator|.
name|fd
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|srvc
operator|->
name|use_ssl
operator|&&
name|ssl_socket_connect
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
literal|0
argument_list|,
name|srvc
operator|->
name|ssl_verify
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|imap_info
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
comment|/* read the greeting string */
if|if
condition|(
name|buffer_gets
argument_list|(
operator|&
name|imap
operator|->
name|buf
argument_list|,
operator|&
name|rsp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: no greeting response\n"
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|rsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|*
name|arg
operator|!=
literal|'*'
operator|||
operator|(
name|arg
operator|=
name|next_arg
argument_list|(
operator|&
name|rsp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: invalid greeting response\n"
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|preauth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"PREAUTH"
argument_list|,
name|arg
argument_list|)
condition|)
name|preauth
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"OK"
argument_list|,
name|arg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: unknown greeting response\n"
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|parse_response_code
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imap
operator|->
name|caps
operator|&&
name|imap_exec
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|"CAPABILITY"
argument_list|)
operator|!=
name|RESP_OK
condition|)
goto|goto
name|bail
goto|;
if|if
condition|(
operator|!
name|preauth
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_OPENSSL
if|if
condition|(
operator|!
name|srvc
operator|->
name|use_ssl
operator|&&
name|CAP
argument_list|(
name|STARTTLS
argument_list|)
condition|)
block|{
if|if
condition|(
name|imap_exec
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|"STARTTLS"
argument_list|)
operator|!=
name|RESP_OK
condition|)
goto|goto
name|bail
goto|;
if|if
condition|(
name|ssl_socket_connect
argument_list|(
operator|&
name|imap
operator|->
name|buf
operator|.
name|sock
argument_list|,
literal|1
argument_list|,
name|srvc
operator|->
name|ssl_verify
argument_list|)
condition|)
goto|goto
name|bail
goto|;
comment|/* capabilities may have changed, so get the new capabilities */
if|if
condition|(
name|imap_exec
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
literal|"CAPABILITY"
argument_list|)
operator|!=
name|RESP_OK
condition|)
goto|goto
name|bail
goto|;
block|}
endif|#
directive|endif
name|imap_info
argument_list|(
literal|"Logging in...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srvc
operator|->
name|user
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping server %s, no user\n"
argument_list|,
name|srvc
operator|->
name|host
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
if|if
condition|(
operator|!
name|srvc
operator|->
name|pass
condition|)
block|{
name|char
name|prompt
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|"Password (%s@%s): "
argument_list|,
name|srvc
operator|->
name|user
argument_list|,
name|srvc
operator|->
name|host
argument_list|)
expr_stmt|;
name|arg
operator|=
name|getpass
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|perror
argument_list|(
literal|"getpass"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|arg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping account %s@%s, no password\n"
argument_list|,
name|srvc
operator|->
name|user
argument_list|,
name|srvc
operator|->
name|host
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
comment|/* 			 * getpass() returns a pointer to a static buffer.  make a copy 			 * for long term storage. 			 */
name|srvc
operator|->
name|pass
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CAP
argument_list|(
name|NOLOGIN
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping account %s@%s, server forbids LOGIN\n"
argument_list|,
name|srvc
operator|->
name|user
argument_list|,
name|srvc
operator|->
name|host
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
if|if
condition|(
operator|!
name|imap
operator|->
name|buf
operator|.
name|sock
operator|.
name|ssl
condition|)
name|imap_warn
argument_list|(
literal|"*** IMAP Warning *** Password is being "
literal|"sent in the clear\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|imap_exec
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|"LOGIN \"%s\" \"%s\""
argument_list|,
name|srvc
operator|->
name|user
argument_list|,
name|srvc
operator|->
name|pass
argument_list|)
operator|!=
name|RESP_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMAP error: LOGIN failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
block|}
comment|/* !preauth */
name|ctx
operator|->
name|prefix
operator|=
literal|""
expr_stmt|;
name|ctx
operator|->
name|trashnc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|store
operator|*
operator|)
name|ctx
return|;
name|bail
label|:
name|imap_close_store
argument_list|(
operator|&
name|ctx
operator|->
name|gen
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|imap_make_flags
specifier|static
name|int
name|imap_make_flags
parameter_list|(
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
name|d
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|Flags
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|buf
index|[
name|d
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
name|d
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|Flags
index|[
name|i
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|buf
index|[
name|d
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
name|buf
index|[
name|d
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_define
DECL|macro|TUIDL
define|#
directive|define
name|TUIDL
value|8
end_define
begin_function
DECL|function|imap_store_msg
specifier|static
name|int
name|imap_store_msg
parameter_list|(
name|struct
name|store
modifier|*
name|gctx
parameter_list|,
name|struct
name|msg_data
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|uid
parameter_list|)
block|{
name|struct
name|imap_store
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|imap_store
operator|*
operator|)
name|gctx
decl_stmt|;
name|struct
name|imap
modifier|*
name|imap
init|=
name|ctx
operator|->
name|imap
decl_stmt|;
name|struct
name|imap_cmd_cb
name|cb
decl_stmt|;
name|char
modifier|*
name|fmap
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|box
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|d
decl_stmt|,
name|len
decl_stmt|,
name|extra
decl_stmt|,
name|nocr
decl_stmt|;
name|int
name|start
decl_stmt|,
name|sbreak
init|=
literal|0
decl_stmt|,
name|ebreak
init|=
literal|0
decl_stmt|;
name|char
name|flagstr
index|[
literal|128
index|]
decl_stmt|,
name|tuid
index|[
name|TUIDL
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|fmap
operator|=
name|data
operator|->
name|data
expr_stmt|;
name|len
operator|=
name|data
operator|->
name|len
expr_stmt|;
name|nocr
operator|=
operator|!
name|data
operator|->
name|crlf
expr_stmt|;
name|extra
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CAP
argument_list|(
name|UIDPLUS
argument_list|)
operator|&&
name|uid
condition|)
block|{
name|nloop
label|:
name|start
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
if|if
condition|(
name|fmap
index|[
name|i
operator|++
index|]
operator|==
literal|'\n'
condition|)
block|{
name|extra
operator|+=
name|nocr
expr_stmt|;
if|if
condition|(
name|i
operator|-
literal|2
operator|+
name|nocr
operator|==
name|start
condition|)
block|{
name|sbreak
operator|=
name|ebreak
operator|=
name|i
operator|-
literal|2
operator|+
name|nocr
expr_stmt|;
goto|goto
name|mktid
goto|;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|fmap
operator|+
name|start
argument_list|,
literal|"X-TUID: "
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|extra
operator|-=
operator|(
name|ebreak
operator|=
name|i
operator|)
operator|-
operator|(
name|sbreak
operator|=
name|start
operator|)
operator|+
name|nocr
expr_stmt|;
goto|goto
name|mktid
goto|;
block|}
goto|goto
name|nloop
goto|;
block|}
comment|/* invalid message */
name|free
argument_list|(
name|fmap
argument_list|)
expr_stmt|;
return|return
name|DRV_MSG_BAD
return|;
name|mktid
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TUIDL
condition|;
name|j
operator|++
control|)
name|sprintf
argument_list|(
name|tuid
operator|+
name|j
operator|*
literal|2
argument_list|,
literal|"%02x"
argument_list|,
name|arc4_getbyte
argument_list|()
argument_list|)
expr_stmt|;
name|extra
operator|+=
literal|8
operator|+
name|TUIDL
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|nocr
condition|)
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmap
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|extra
operator|++
expr_stmt|;
name|cb
operator|.
name|dlen
operator|=
name|len
operator|+
name|extra
expr_stmt|;
name|buf
operator|=
name|cb
operator|.
name|data
operator|=
name|xmalloc
argument_list|(
name|cb
operator|.
name|dlen
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CAP
argument_list|(
name|UIDPLUS
argument_list|)
operator|&&
name|uid
condition|)
block|{
if|if
condition|(
name|nocr
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|sbreak
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmap
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
operator|*
name|buf
operator|++
operator|=
name|fmap
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|fmap
argument_list|,
name|sbreak
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|sbreak
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
literal|"X-TUID: "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|tuid
argument_list|,
name|TUIDL
operator|*
literal|2
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|TUIDL
operator|*
literal|2
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|i
operator|=
name|ebreak
expr_stmt|;
block|}
if|if
condition|(
name|nocr
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmap
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
operator|*
name|buf
operator|++
operator|=
name|fmap
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|buf
argument_list|,
name|fmap
operator|+
name|i
argument_list|,
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fmap
argument_list|)
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
condition|)
block|{
name|d
operator|=
name|imap_make_flags
argument_list|(
name|data
operator|->
name|flags
argument_list|,
name|flagstr
argument_list|)
expr_stmt|;
name|flagstr
index|[
name|d
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|flagstr
index|[
name|d
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|uid
condition|)
block|{
name|box
operator|=
name|gctx
operator|->
name|conf
operator|->
name|trash
expr_stmt|;
name|prefix
operator|=
name|ctx
operator|->
name|prefix
expr_stmt|;
name|cb
operator|.
name|create
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|trashnc
condition|)
name|imap
operator|->
name|caps
operator|=
name|imap
operator|->
name|rcaps
operator|&
operator|~
operator|(
literal|1
operator|<<
name|LITERALPLUS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|box
operator|=
name|gctx
operator|->
name|name
expr_stmt|;
name|prefix
operator|=
operator|!
name|strcmp
argument_list|(
name|box
argument_list|,
literal|"INBOX"
argument_list|)
condition|?
literal|""
else|:
name|ctx
operator|->
name|prefix
expr_stmt|;
name|cb
operator|.
name|create
operator|=
literal|0
expr_stmt|;
block|}
name|cb
operator|.
name|ctx
operator|=
name|uid
expr_stmt|;
name|ret
operator|=
name|imap_exec_m
argument_list|(
name|ctx
argument_list|,
operator|&
name|cb
argument_list|,
literal|"APPEND \"%s%s\" %s"
argument_list|,
name|prefix
argument_list|,
name|box
argument_list|,
name|flagstr
argument_list|)
expr_stmt|;
name|imap
operator|->
name|caps
operator|=
name|imap
operator|->
name|rcaps
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|DRV_OK
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|uid
condition|)
name|ctx
operator|->
name|trashnc
operator|=
literal|0
expr_stmt|;
else|else
name|gctx
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|DRV_OK
return|;
block|}
end_function
begin_define
DECL|macro|CHUNKSIZE
define|#
directive|define
name|CHUNKSIZE
value|0x1000
end_define
begin_function
DECL|function|read_message
specifier|static
name|int
name|read_message
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|msg_data
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|strbuf_fread
argument_list|(
operator|&
name|buf
argument_list|,
name|CHUNKSIZE
argument_list|,
name|f
argument_list|)
operator|<=
literal|0
condition|)
break|break;
block|}
do|while
condition|(
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
do|;
name|msg
operator|->
name|len
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|msg
operator|->
name|data
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|msg
operator|->
name|len
return|;
block|}
end_function
begin_function
DECL|function|count_messages
specifier|static
name|int
name|count_messages
parameter_list|(
name|struct
name|msg_data
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|msg
operator|->
name|data
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|p
argument_list|,
literal|"From "
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
block|}
name|p
operator|=
name|strstr
argument_list|(
name|p
operator|+
literal|5
argument_list|,
literal|"\nFrom "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|split_msg
specifier|static
name|int
name|split_msg
parameter_list|(
name|struct
name|msg_data
modifier|*
name|all_msgs
parameter_list|,
name|struct
name|msg_data
modifier|*
name|msg
parameter_list|,
name|int
modifier|*
name|ofs
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofs
operator|>=
name|all_msgs
operator|->
name|len
condition|)
return|return
literal|0
return|;
name|data
operator|=
operator|&
name|all_msgs
operator|->
name|data
index|[
operator|*
name|ofs
index|]
expr_stmt|;
name|msg
operator|->
name|len
operator|=
name|all_msgs
operator|->
name|len
operator|-
operator|*
name|ofs
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|len
operator|<
literal|5
operator|||
name|prefixcmp
argument_list|(
name|data
argument_list|,
literal|"From "
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|strchr
argument_list|(
name|data
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|=
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
name|msg
operator|->
name|len
operator|-=
name|p
operator|-
name|data
expr_stmt|;
operator|*
name|ofs
operator|+=
name|p
operator|-
name|data
expr_stmt|;
name|data
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|=
name|strstr
argument_list|(
name|data
argument_list|,
literal|"\nFrom "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|msg
operator|->
name|len
operator|=
operator|&
name|p
index|[
literal|1
index|]
operator|-
name|data
expr_stmt|;
name|msg
operator|->
name|data
operator|=
name|xmemdupz
argument_list|(
name|data
argument_list|,
name|msg
operator|->
name|len
argument_list|)
expr_stmt|;
operator|*
name|ofs
operator|+=
name|msg
operator|->
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|server
specifier|static
name|struct
name|imap_server_conf
name|server
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* tunnel */
name|NULL
block|,
comment|/* host */
literal|0
block|,
comment|/* port */
name|NULL
block|,
comment|/* user */
name|NULL
block|,
comment|/* pass */
literal|0
block|,
comment|/* use_ssl */
literal|1
block|,
comment|/* ssl_verify */
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|imap_folder
specifier|static
name|char
modifier|*
name|imap_folder
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|git_imap_config
specifier|static
name|int
name|git_imap_config
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
name|char
name|imap_key
index|[]
init|=
literal|"imap."
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|key
argument_list|,
name|imap_key
argument_list|,
sizeof|sizeof
name|imap_key
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|key
argument_list|)
return|;
name|key
operator|+=
sizeof|sizeof
name|imap_key
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"folder"
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|imap_folder
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"host"
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|val
argument_list|,
literal|"imap:"
argument_list|)
condition|)
name|val
operator|+=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|val
argument_list|,
literal|"imaps:"
argument_list|)
condition|)
block|{
name|val
operator|+=
literal|6
expr_stmt|;
name|server
operator|.
name|use_ssl
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prefixcmp
argument_list|(
name|val
argument_list|,
literal|"//"
argument_list|)
condition|)
name|val
operator|+=
literal|2
expr_stmt|;
name|server
operator|.
name|host
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"user"
argument_list|,
name|key
argument_list|)
condition|)
name|server
operator|.
name|user
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"pass"
argument_list|,
name|key
argument_list|)
condition|)
name|server
operator|.
name|pass
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"port"
argument_list|,
name|key
argument_list|)
condition|)
name|server
operator|.
name|port
operator|=
name|git_config_int
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"tunnel"
argument_list|,
name|key
argument_list|)
condition|)
name|server
operator|.
name|tunnel
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"sslverify"
argument_list|,
name|key
argument_list|)
condition|)
name|server
operator|.
name|ssl_verify
operator|=
name|git_config_bool
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|msg_data
name|all_msgs
decl_stmt|,
name|msg
decl_stmt|;
name|struct
name|store
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|int
name|uid
init|=
literal|0
decl_stmt|;
name|int
name|ofs
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|total
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|int
name|nongit_ok
decl_stmt|;
comment|/* init the random number generator */
name|arc4_init
argument_list|()
expr_stmt|;
name|setup_git_directory_gently
argument_list|(
operator|&
name|nongit_ok
argument_list|)
expr_stmt|;
name|git_config
argument_list|(
name|git_imap_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|server
operator|.
name|port
condition|)
name|server
operator|.
name|port
operator|=
name|server
operator|.
name|use_ssl
condition|?
literal|993
else|:
literal|143
expr_stmt|;
if|if
condition|(
operator|!
name|imap_folder
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no imap store specified\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|server
operator|.
name|host
condition|)
block|{
if|if
condition|(
operator|!
name|server
operator|.
name|tunnel
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no imap host specified\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|server
operator|.
name|host
operator|=
literal|"tunnel"
expr_stmt|;
block|}
comment|/* read the messages */
if|if
condition|(
operator|!
name|read_message
argument_list|(
name|stdin
argument_list|,
operator|&
name|all_msgs
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nothing to send\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|total
operator|=
name|count_messages
argument_list|(
operator|&
name|all_msgs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|total
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no messages to send\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* write it to the imap server */
name|ctx
operator|=
name|imap_open_store
argument_list|(
operator|&
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"failed to open store\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sending %d message%s\n"
argument_list|,
name|total
argument_list|,
operator|(
name|total
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|name
operator|=
name|imap_folder
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|percent
init|=
name|n
operator|*
literal|100
operator|/
name|total
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%4u%% (%d/%d) done\r"
argument_list|,
name|percent
argument_list|,
name|n
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|split_msg
argument_list|(
operator|&
name|all_msgs
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|ofs
argument_list|)
condition|)
break|break;
name|r
operator|=
name|imap_store_msg
argument_list|(
name|ctx
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|DRV_OK
condition|)
break|break;
name|n
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|imap_close_store
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
