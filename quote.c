begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_comment
comment|/* Help to copy the thing properly quoted for the shell safety.  * any single quote is replaced with '\'', any exclamation point  * is replaced with '\!', and the whole thing is enclosed in a  *  * E.g.  *  original     sq_quote     result  *  name     ==> name      ==> 'name'  *  a b      ==> a b       ==> 'a b'  *  a'b      ==> a'\''b    ==> 'a'\''b'  *  a!b      ==> a'\!'b    ==> 'a'\!'b'  */
end_comment
begin_undef
DECL|macro|EMIT
undef|#
directive|undef
name|EMIT
end_undef
begin_define
DECL|macro|EMIT
define|#
directive|define
name|EMIT
parameter_list|(
name|x
parameter_list|)
value|do { if (++len< n) *bp++ = (x); } while(0)
end_define
begin_function
DECL|function|need_bs_quote
specifier|static
specifier|inline
name|int
name|need_bs_quote
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'!'
operator|)
return|;
block|}
end_function
begin_function
DECL|function|sq_quote_buf
specifier|static
name|size_t
name|sq_quote_buf
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|dst
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|EMIT
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|need_bs_quote
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|EMIT
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EMIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|EMIT
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|sq_quote_print
name|void
name|sq_quote_print
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|need_bs_quote
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"'\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sq_quote_argv
name|char
modifier|*
name|sq_quote_argv
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
comment|/* Count argv if needed. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|count
operator|=
literal|0
init|;
name|argv
index|[
name|count
index|]
condition|;
name|count
operator|++
control|)
empty_stmt|;
comment|/* just counting */
block|}
comment|/* Special case: no argv. */
if|if
condition|(
operator|!
name|count
condition|)
return|return
name|xcalloc
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
return|;
comment|/* Get destination buffer length. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|sq_quote_buf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Alloc destination buffer. */
name|to
operator|=
name|buf
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy into destination buffer. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|to
operator|++
operator|=
literal|' '
expr_stmt|;
name|to
operator|+=
name|sq_quote_buf
argument_list|(
name|to
argument_list|,
name|len
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function
begin_comment
comment|/*  * Append a string to a string buffer, with or without shell quoting.  * Return true if the buffer overflowed.  */
end_comment
begin_function
DECL|function|add_to_string
name|int
name|add_to_string
parameter_list|(
name|char
modifier|*
modifier|*
name|ptrp
parameter_list|,
name|int
modifier|*
name|sizep
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|quote
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|ptrp
decl_stmt|;
name|int
name|size
init|=
operator|*
name|sizep
decl_stmt|;
name|int
name|oc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|quote
condition|)
name|oc
operator|=
name|sq_quote_buf
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
block|{
name|oc
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|str
argument_list|,
operator|(
name|size
operator|<=
name|oc
operator|)
condition|?
name|size
operator|-
literal|1
else|:
name|oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|<=
name|oc
condition|)
block|{
name|err
operator|=
literal|1
expr_stmt|;
name|oc
operator|=
name|size
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|ptrp
operator|+=
name|oc
expr_stmt|;
operator|*
operator|*
name|ptrp
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sizep
operator|-=
name|oc
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
begin_function
DECL|function|sq_dequote
name|char
modifier|*
name|sq_dequote
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|dst
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|arg
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|'\''
condition|)
return|return
name|NULL
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|++
name|src
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* We stepped out of sq */
switch|switch
condition|(
operator|*
operator|++
name|src
condition|)
block|{
case|case
literal|'\0'
case|:
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
return|return
name|arg
return|;
case|case
literal|'\\'
case|:
name|c
operator|=
operator|*
operator|++
name|src
expr_stmt|;
if|if
condition|(
name|need_bs_quote
argument_list|(
name|c
argument_list|)
operator|&&
operator|*
operator|++
name|src
operator|==
literal|'\''
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* Fallthrough */
default|default:
return|return
name|NULL
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*  * C-style name quoting.  *  * Does one of three things:  *  * (1) if outbuf and outfp are both NULL, inspect the input name and  *     counts the number of bytes that are needed to hold c_style  *     quoted version of name, counting the double quotes around  *     it but not terminating NUL, and returns it.  However, if name  *     does not need c_style quoting, it returns 0.  *  * (2) if outbuf is not NULL, it must point at a buffer large enough  *     to hold the c_style quoted version of name, enclosing double  *     quotes, and terminating NUL.  Fills outbuf with c_style quoted  *     version of name enclosed in double-quote pair.  Return value  *     is undefined.  *  * (3) if outfp is not NULL, outputs c_style quoted version of name,  *     but not enclosed in double-quote pair.  Return value is undefined.  */
end_comment
begin_function
DECL|function|quote_c_style_counted
specifier|static
name|int
name|quote_c_style_counted
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|outbuf
parameter_list|,
name|FILE
modifier|*
name|outfp
parameter_list|,
name|int
name|no_dq
parameter_list|)
block|{
DECL|macro|EMIT
undef|#
directive|undef
name|EMIT
DECL|macro|EMIT
define|#
directive|define
name|EMIT
parameter_list|(
name|c
parameter_list|)
define|\
value|(outbuf ? (*outbuf++ = (c)) : outfp ? fputc(c, outfp) : (count++))
DECL|macro|EMITQ
define|#
directive|define
name|EMITQ
parameter_list|()
value|EMIT('\\')
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|needquote
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|no_dq
condition|)
name|EMIT
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|name
init|;
name|sp
operator|<
name|name
operator|+
name|namelen
condition|;
name|sp
operator|++
control|)
block|{
name|ch
operator|=
operator|*
name|sp
expr_stmt|;
if|if
condition|(
operator|!
name|ch
condition|)
break|break;
if|if
condition|(
operator|(
name|ch
operator|<
literal|' '
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'"'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|quote_path_fully
operator|&&
operator|(
name|ch
operator|>=
literal|0177
operator|)
operator|)
condition|)
block|{
name|needquote
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\a'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
name|ch
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* fallthru */
case|case
literal|'"'
case|:
name|EMITQ
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* octal */
name|EMITQ
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|03
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
operator|(
operator|(
name|ch
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
name|ch
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
break|break;
block|}
block|}
name|EMIT
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_dq
condition|)
name|EMIT
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
condition|)
operator|*
name|outbuf
operator|=
literal|0
expr_stmt|;
return|return
name|needquote
condition|?
name|count
else|:
literal|0
return|;
block|}
end_function
begin_function
DECL|function|quote_c_style
name|int
name|quote_c_style
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|outbuf
parameter_list|,
name|FILE
modifier|*
name|outfp
parameter_list|,
name|int
name|no_dq
parameter_list|)
block|{
name|int
name|cnt
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|quote_c_style_counted
argument_list|(
name|name
argument_list|,
name|cnt
argument_list|,
name|outbuf
argument_list|,
name|outfp
argument_list|,
name|no_dq
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * C-style name unquoting.  *  * Quoted should point at the opening double quote.  * + Returns 0 if it was able to unquote the string properly, and appends the  *   result in the strbuf `sb'.  * + Returns -1 in case of error, and doesn't touch the strbuf. Though note  *   that this function will allocate memory in the strbuf, so calling  *   strbuf_release is mandatory whichever result unquote_c_style returns.  *  * Updates endp pointer to point at one past the ending double quote if given.  */
end_comment
begin_function
DECL|function|unquote_c_style
name|int
name|unquote_c_style
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|quoted
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endp
parameter_list|)
block|{
name|size_t
name|oldlen
init|=
name|sb
operator|->
name|len
decl_stmt|,
name|len
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|ac
decl_stmt|;
if|if
condition|(
operator|*
name|quoted
operator|++
operator|!=
literal|'"'
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|strcspn
argument_list|(
name|quoted
argument_list|,
literal|"\"\\"
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
name|sb
argument_list|,
name|quoted
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|quoted
operator|+=
name|len
expr_stmt|;
switch|switch
condition|(
operator|*
name|quoted
operator|++
condition|)
block|{
case|case
literal|'"'
case|:
if|if
condition|(
name|endp
condition|)
operator|*
name|endp
operator|=
name|quoted
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'\\'
case|:
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
switch|switch
condition|(
operator|(
name|ch
operator|=
operator|*
name|quoted
operator|++
operator|)
condition|)
block|{
case|case
literal|'a'
case|:
name|ch
operator|=
literal|'\a'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ch
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
comment|/* verbatim */
comment|/* octal values with first digit over 4 overflow */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
name|ac
operator|=
operator|(
operator|(
name|ch
operator|-
literal|'0'
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|quoted
operator|++
operator|)
operator|<
literal|'0'
operator|||
literal|'7'
operator|<
name|ch
condition|)
goto|goto
name|error
goto|;
name|ac
operator||=
operator|(
operator|(
name|ch
operator|-
literal|'0'
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|quoted
operator|++
operator|)
operator|<
literal|'0'
operator|||
literal|'7'
operator|<
name|ch
condition|)
goto|goto
name|error
goto|;
name|ac
operator||=
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ch
operator|=
name|ac
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
name|strbuf_addch
argument_list|(
name|sb
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|strbuf_setlen
argument_list|(
name|sb
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|write_name_quoted
name|void
name|write_name_quoted
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|prefix_len
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|quote
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|int
name|needquote
decl_stmt|;
if|if
condition|(
operator|!
name|quote
condition|)
block|{
name|no_quote
label|:
if|if
condition|(
name|prefix_len
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%.*s"
argument_list|,
name|prefix_len
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|name
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
name|needquote
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prefix_len
condition|)
name|needquote
operator|=
name|quote_c_style_counted
argument_list|(
name|prefix
argument_list|,
name|prefix_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needquote
condition|)
name|needquote
operator|=
name|quote_c_style
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|needquote
condition|)
block|{
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_len
condition|)
name|quote_c_style_counted
argument_list|(
name|prefix
argument_list|,
name|prefix_len
argument_list|,
name|NULL
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|quote_c_style
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|no_quote
goto|;
block|}
end_function
begin_comment
comment|/* quoting as a string literal for other languages */
end_comment
begin_function
DECL|function|perl_quote_print
name|void
name|perl_quote_print
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
specifier|const
name|char
name|sq
init|=
literal|'\''
decl_stmt|;
specifier|const
name|char
name|bq
init|=
literal|'\\'
decl_stmt|;
name|char
name|c
decl_stmt|;
name|fputc
argument_list|(
name|sq
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|sq
operator|||
name|c
operator|==
name|bq
condition|)
name|fputc
argument_list|(
name|bq
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
name|sq
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|python_quote_print
name|void
name|python_quote_print
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
specifier|const
name|char
name|sq
init|=
literal|'\''
decl_stmt|;
specifier|const
name|char
name|bq
init|=
literal|'\\'
decl_stmt|;
specifier|const
name|char
name|nl
init|=
literal|'\n'
decl_stmt|;
name|char
name|c
decl_stmt|;
name|fputc
argument_list|(
name|sq
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|nl
condition|)
block|{
name|fputc
argument_list|(
name|bq
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|sq
operator|||
name|c
operator|==
name|bq
condition|)
name|fputc
argument_list|(
name|bq
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
name|sq
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|tcl_quote_print
name|void
name|tcl_quote_print
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
case|case
literal|'$'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
default|default:
name|fputc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs
argument_list|(
literal|"\\v"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
