begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"transport.h"
end_include
begin_include
include|#
directive|include
file|"quote.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"remote.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"thread-utils.h"
end_include
begin_include
include|#
directive|include
file|"sigchain.h"
end_include
begin_include
include|#
directive|include
file|"argv-array.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_decl_stmt
DECL|variable|debug
specifier|static
name|int
name|debug
decl_stmt|;
end_decl_stmt
begin_struct
DECL|struct|helper_data
struct|struct
name|helper_data
block|{
DECL|member|name
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
DECL|member|helper
name|struct
name|child_process
modifier|*
name|helper
decl_stmt|;
DECL|member|out
name|FILE
modifier|*
name|out
decl_stmt|;
DECL|member|fetch
name|unsigned
name|fetch
range|:
literal|1
decl_stmt|,
DECL|member|import
name|import
range|:
literal|1
decl_stmt|,
DECL|member|bidi_import
name|bidi_import
range|:
literal|1
decl_stmt|,
DECL|member|export
name|export
range|:
literal|1
decl_stmt|,
DECL|member|option
name|option
range|:
literal|1
decl_stmt|,
DECL|member|push
name|push
range|:
literal|1
decl_stmt|,
DECL|member|connect
name|connect
range|:
literal|1
decl_stmt|,
DECL|member|signed_tags
name|signed_tags
range|:
literal|1
decl_stmt|,
DECL|member|check_connectivity
name|check_connectivity
range|:
literal|1
decl_stmt|,
DECL|member|no_disconnect_req
name|no_disconnect_req
range|:
literal|1
decl_stmt|,
DECL|member|no_private_update
name|no_private_update
range|:
literal|1
decl_stmt|;
DECL|member|export_marks
name|char
modifier|*
name|export_marks
decl_stmt|;
DECL|member|import_marks
name|char
modifier|*
name|import_marks
decl_stmt|;
comment|/* These go from remote name (as in "list") to private name */
DECL|member|refspecs
name|struct
name|refspec
modifier|*
name|refspecs
decl_stmt|;
DECL|member|refspec_nr
name|int
name|refspec_nr
decl_stmt|;
comment|/* Transport options for fetch-pack/send-pack (should one of 	 * those be invoked). 	 */
DECL|member|transport_options
name|struct
name|git_transport_options
name|transport_options
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|sendline
specifier|static
name|void
name|sendline
parameter_list|(
name|struct
name|helper_data
modifier|*
name|helper
parameter_list|,
name|struct
name|strbuf
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Remote helper: -> %s"
argument_list|,
name|buffer
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|helper
operator|->
name|helper
operator|->
name|in
argument_list|,
name|buffer
operator|->
name|buf
argument_list|,
name|buffer
operator|->
name|len
argument_list|)
operator|!=
name|buffer
operator|->
name|len
condition|)
name|die_errno
argument_list|(
literal|"Full write to remote helper failed"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|recvline_fh
specifier|static
name|int
name|recvline_fh
parameter_list|(
name|FILE
modifier|*
name|helper
parameter_list|,
name|struct
name|strbuf
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|strbuf_reset
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Remote helper: Waiting...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_getline
argument_list|(
name|buffer
argument_list|,
name|helper
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Remote helper quit.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Remote helper:<- %s\n"
argument_list|,
name|buffer
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|recvline
specifier|static
name|int
name|recvline
parameter_list|(
name|struct
name|helper_data
modifier|*
name|helper
parameter_list|,
name|struct
name|strbuf
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|recvline_fh
argument_list|(
name|helper
operator|->
name|out
argument_list|,
name|buffer
argument_list|,
name|helper
operator|->
name|name
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|write_constant
specifier|static
name|void
name|write_constant
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Remote helper: -> %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_in_full
argument_list|(
name|fd
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
operator|!=
name|strlen
argument_list|(
name|str
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"Full write to remote helper failed"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove_ext_force
specifier|static
specifier|const
name|char
modifier|*
name|remove_ext_force
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
if|if
condition|(
name|url
condition|)
block|{
specifier|const
name|char
modifier|*
name|colon
init|=
name|strchr
argument_list|(
name|url
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon
operator|&&
name|colon
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
return|return
name|colon
operator|+
literal|2
return|;
block|}
return|return
name|url
return|;
block|}
end_function
begin_function
DECL|function|do_take_over
specifier|static
name|void
name|do_take_over
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
operator|(
expr|struct
name|helper_data
operator|*
operator|)
name|transport
operator|->
name|data
expr_stmt|;
name|transport_take_over
argument_list|(
name|transport
argument_list|,
name|data
operator|->
name|helper
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|data
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|standard_options
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|get_helper
specifier|static
name|struct
name|child_process
modifier|*
name|get_helper
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|child_process
modifier|*
name|helper
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|refspecs
init|=
name|NULL
decl_stmt|;
name|int
name|refspec_nr
init|=
literal|0
decl_stmt|;
name|int
name|refspec_alloc
init|=
literal|0
decl_stmt|;
name|int
name|duped
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|helper
condition|)
return|return
name|data
operator|->
name|helper
return|;
name|helper
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|helper
argument_list|)
argument_list|)
expr_stmt|;
name|child_process_init
argument_list|(
name|helper
argument_list|)
expr_stmt|;
name|helper
operator|->
name|in
operator|=
operator|-
literal|1
expr_stmt|;
name|helper
operator|->
name|out
operator|=
operator|-
literal|1
expr_stmt|;
name|helper
operator|->
name|err
operator|=
literal|0
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|helper
operator|->
name|args
argument_list|,
literal|"git-remote-%s"
argument_list|,
name|data
operator|->
name|name
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|helper
operator|->
name|args
argument_list|,
name|transport
operator|->
name|remote
operator|->
name|name
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|helper
operator|->
name|args
argument_list|,
name|remove_ext_force
argument_list|(
name|transport
operator|->
name|url
argument_list|)
argument_list|)
expr_stmt|;
name|helper
operator|->
name|git_cmd
operator|=
literal|0
expr_stmt|;
name|helper
operator|->
name|silent_exec_failure
operator|=
literal|1
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|helper
operator|->
name|env_array
argument_list|,
literal|"%s=%s"
argument_list|,
name|GIT_DIR_ENVIRONMENT
argument_list|,
name|get_git_dir
argument_list|()
argument_list|)
expr_stmt|;
name|code
operator|=
name|start_command
argument_list|(
name|helper
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
name|die
argument_list|(
literal|"Unable to find remote helper for '%s'"
argument_list|,
name|data
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|data
operator|->
name|helper
operator|=
name|helper
expr_stmt|;
name|data
operator|->
name|no_disconnect_req
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Open the output as FILE* so strbuf_getline() can be used. 	 * Do this with duped fd because fclose() will close the fd, 	 * and stuff like taking over will require the fd to remain. 	 */
name|duped
operator|=
name|dup
argument_list|(
name|helper
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|duped
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"Can't dup helper output fd"
argument_list|)
expr_stmt|;
name|data
operator|->
name|out
operator|=
name|xfdopen
argument_list|(
name|duped
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|write_constant
argument_list|(
name|helper
operator|->
name|in
argument_list|,
literal|"capabilities\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|capname
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|mandatory
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|recvline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|buf
operator|.
name|buf
condition|)
break|break;
if|if
condition|(
operator|*
name|buf
operator|.
name|buf
operator|==
literal|'*'
condition|)
block|{
name|capname
operator|=
name|buf
operator|.
name|buf
operator|+
literal|1
expr_stmt|;
name|mandatory
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|capname
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Got cap %s\n"
argument_list|,
name|capname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"fetch"
argument_list|)
condition|)
name|data
operator|->
name|fetch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"option"
argument_list|)
condition|)
name|data
operator|->
name|option
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"push"
argument_list|)
condition|)
name|data
operator|->
name|push
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"import"
argument_list|)
condition|)
name|data
operator|->
name|import
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"bidi-import"
argument_list|)
condition|)
name|data
operator|->
name|bidi_import
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"export"
argument_list|)
condition|)
name|data
operator|->
name|export
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"check-connectivity"
argument_list|)
condition|)
name|data
operator|->
name|check_connectivity
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|data
operator|->
name|refspecs
operator|&&
name|skip_prefix
argument_list|(
name|capname
argument_list|,
literal|"refspec "
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
name|ALLOC_GROW
argument_list|(
name|refspecs
argument_list|,
name|refspec_nr
operator|+
literal|1
argument_list|,
name|refspec_alloc
argument_list|)
expr_stmt|;
name|refspecs
index|[
name|refspec_nr
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"connect"
argument_list|)
condition|)
block|{
name|data
operator|->
name|connect
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|capname
argument_list|,
literal|"signed-tags"
argument_list|)
condition|)
block|{
name|data
operator|->
name|signed_tags
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|capname
argument_list|,
literal|"export-marks "
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
name|data
operator|->
name|export_marks
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_prefix
argument_list|(
name|capname
argument_list|,
literal|"import-marks "
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
name|data
operator|->
name|import_marks
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|capname
argument_list|,
literal|"no-private-update"
argument_list|)
condition|)
block|{
name|data
operator|->
name|no_private_update
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mandatory
condition|)
block|{
name|die
argument_list|(
literal|"Unknown mandatory capability %s. This remote "
literal|"helper probably needs newer version of Git."
argument_list|,
name|capname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|refspecs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|data
operator|->
name|refspec_nr
operator|=
name|refspec_nr
expr_stmt|;
name|data
operator|->
name|refspecs
operator|=
name|parse_fetch_refspec
argument_list|(
name|refspec_nr
argument_list|,
name|refspecs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|refspec_nr
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|refspecs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|refspecs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|import
operator|||
name|data
operator|->
name|bidi_import
operator|||
name|data
operator|->
name|export
condition|)
block|{
name|warning
argument_list|(
literal|"This remote helper should implement refspec capability."
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Capabilities complete.\n"
argument_list|)
expr_stmt|;
name|standard_options
argument_list|(
name|transport
argument_list|)
expr_stmt|;
return|return
name|data
operator|->
name|helper
return|;
block|}
end_function
begin_function
DECL|function|disconnect_helper
specifier|static
name|int
name|disconnect_helper
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|helper
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Disconnecting.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|no_disconnect_req
condition|)
block|{
comment|/* 			 * Ignore write errors; there's nothing we can do, 			 * since we're about to close the pipe anyway. And the 			 * most likely error is EPIPE due to the helper dying 			 * to report an error itself. 			 */
name|sigchain_push
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|xwrite
argument_list|(
name|data
operator|->
name|helper
operator|->
name|in
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sigchain_pop
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|data
operator|->
name|helper
operator|->
name|in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|data
operator|->
name|helper
operator|->
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|data
operator|->
name|out
argument_list|)
expr_stmt|;
name|res
operator|=
name|finish_command
argument_list|(
name|data
operator|->
name|helper
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|helper
argument_list|)
expr_stmt|;
name|data
operator|->
name|helper
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|unsupported_options
specifier|static
specifier|const
name|char
modifier|*
name|unsupported_options
index|[]
init|=
block|{
name|TRANS_OPT_UPLOADPACK
block|,
name|TRANS_OPT_RECEIVEPACK
block|,
name|TRANS_OPT_THIN
block|,
name|TRANS_OPT_KEEP
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|boolean_options
specifier|static
specifier|const
name|char
modifier|*
name|boolean_options
index|[]
init|=
block|{
name|TRANS_OPT_THIN
block|,
name|TRANS_OPT_KEEP
block|,
name|TRANS_OPT_FOLLOWTAGS
block|, 	}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|set_helper_option
specifier|static
name|int
name|set_helper_option
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|is_bool
init|=
literal|0
decl_stmt|;
name|get_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|option
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|unsupported_options
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|unsupported_options
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|boolean_options
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|boolean_options
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|is_bool
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"option %s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_bool
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|value
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
else|else
name|quote_c_style
argument_list|(
name|value
argument_list|,
operator|&
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|"ok"
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|"error"
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|"unsupported"
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"%s unexpectedly said: '%s'"
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|standard_options
specifier|static
name|void
name|standard_options
parameter_list|(
name|struct
name|transport
modifier|*
name|t
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|v
init|=
name|t
operator|->
name|verbose
decl_stmt|;
name|set_helper_option
argument_list|(
name|t
argument_list|,
literal|"progress"
argument_list|,
name|t
operator|->
name|progress
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|v
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|die
argument_list|(
literal|"impossibly large verbosity value"
argument_list|)
expr_stmt|;
name|set_helper_option
argument_list|(
name|t
argument_list|,
literal|"verbosity"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|family
condition|)
block|{
case|case
name|TRANSPORT_FAMILY_ALL
case|:
comment|/* 		 * this is already the default, 		 * do not break old remote helpers by setting "all" here 		 */
break|break;
case|case
name|TRANSPORT_FAMILY_IPV4
case|:
name|set_helper_option
argument_list|(
name|t
argument_list|,
literal|"family"
argument_list|,
literal|"ipv4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRANSPORT_FAMILY_IPV6
case|:
name|set_helper_option
argument_list|(
name|t
argument_list|,
literal|"family"
argument_list|,
literal|"ipv6"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|release_helper
specifier|static
name|int
name|release_helper
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|free_refspec
argument_list|(
name|data
operator|->
name|refspec_nr
argument_list|,
name|data
operator|->
name|refspecs
argument_list|)
expr_stmt|;
name|data
operator|->
name|refspecs
operator|=
name|NULL
expr_stmt|;
name|res
operator|=
name|disconnect_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|transport
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function
begin_function
DECL|function|fetch_with_fetch
specifier|static
name|int
name|fetch_with_fetch
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|int
name|nr_heads
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|to_fetch
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_heads
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ref
modifier|*
name|posn
init|=
name|to_fetch
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|posn
operator|->
name|status
operator|&
name|REF_STATUS_UPTODATE
condition|)
continue|continue;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"fetch %s %s\n"
argument_list|,
name|oid_to_hex
argument_list|(
operator|&
name|posn
operator|->
name|old_oid
argument_list|)
argument_list|,
name|posn
operator|->
name|symref
condition|?
name|posn
operator|->
name|symref
else|:
name|posn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|recvline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|"lock "
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|buf
operator|.
name|buf
operator|+
literal|5
decl_stmt|;
if|if
condition|(
name|transport
operator|->
name|pack_lockfile
condition|)
name|warning
argument_list|(
literal|"%s also locked %s"
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|transport
operator|->
name|pack_lockfile
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|check_connectivity
operator|&&
name|data
operator|->
name|transport_options
operator|.
name|check_self_contained_and_connected
operator|&&
operator|!
name|strcmp
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|"connectivity-ok"
argument_list|)
condition|)
name|data
operator|->
name|transport_options
operator|.
name|self_contained_and_connected
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|buf
operator|.
name|len
condition|)
break|break;
else|else
name|warning
argument_list|(
literal|"%s unexpectedly said: '%s'"
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_importer
specifier|static
name|int
name|get_importer
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|child_process
modifier|*
name|fastimport
parameter_list|)
block|{
name|struct
name|child_process
modifier|*
name|helper
init|=
name|get_helper
argument_list|(
name|transport
argument_list|)
decl_stmt|;
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|int
name|cat_blob_fd
decl_stmt|,
name|code
decl_stmt|;
name|child_process_init
argument_list|(
name|fastimport
argument_list|)
expr_stmt|;
name|fastimport
operator|->
name|in
operator|=
name|helper
operator|->
name|out
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|fastimport
operator|->
name|args
argument_list|,
literal|"fast-import"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|fastimport
operator|->
name|args
argument_list|,
name|debug
condition|?
literal|"--stats"
else|:
literal|"--quiet"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|bidi_import
condition|)
block|{
name|cat_blob_fd
operator|=
name|xdup
argument_list|(
name|helper
operator|->
name|in
argument_list|)
expr_stmt|;
name|argv_array_pushf
argument_list|(
operator|&
name|fastimport
operator|->
name|args
argument_list|,
literal|"--cat-blob-fd=%d"
argument_list|,
name|cat_blob_fd
argument_list|)
expr_stmt|;
block|}
name|fastimport
operator|->
name|git_cmd
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|start_command
argument_list|(
name|fastimport
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
begin_function
DECL|function|get_exporter
specifier|static
name|int
name|get_exporter
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|child_process
modifier|*
name|fastexport
parameter_list|,
name|struct
name|string_list
modifier|*
name|revlist_args
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|struct
name|child_process
modifier|*
name|helper
init|=
name|get_helper
argument_list|(
name|transport
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|child_process_init
argument_list|(
name|fastexport
argument_list|)
expr_stmt|;
comment|/* we need to duplicate helper->in because we want to use it after 	 * fastexport is done with it. */
name|fastexport
operator|->
name|out
operator|=
name|dup
argument_list|(
name|helper
operator|->
name|in
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|fastexport
operator|->
name|args
argument_list|,
literal|"fast-export"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|fastexport
operator|->
name|args
argument_list|,
literal|"--use-done-feature"
argument_list|)
expr_stmt|;
name|argv_array_push
argument_list|(
operator|&
name|fastexport
operator|->
name|args
argument_list|,
name|data
operator|->
name|signed_tags
condition|?
literal|"--signed-tags=verbatim"
else|:
literal|"--signed-tags=warn-strip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|export_marks
condition|)
name|argv_array_pushf
argument_list|(
operator|&
name|fastexport
operator|->
name|args
argument_list|,
literal|"--export-marks=%s.tmp"
argument_list|,
name|data
operator|->
name|export_marks
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|import_marks
condition|)
name|argv_array_pushf
argument_list|(
operator|&
name|fastexport
operator|->
name|args
argument_list|,
literal|"--import-marks=%s"
argument_list|,
name|data
operator|->
name|import_marks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revlist_args
operator|->
name|nr
condition|;
name|i
operator|++
control|)
name|argv_array_push
argument_list|(
operator|&
name|fastexport
operator|->
name|args
argument_list|,
name|revlist_args
operator|->
name|items
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|fastexport
operator|->
name|git_cmd
operator|=
literal|1
expr_stmt|;
return|return
name|start_command
argument_list|(
name|fastexport
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fetch_with_import
specifier|static
name|int
name|fetch_with_import
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|int
name|nr_heads
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|to_fetch
parameter_list|)
block|{
name|struct
name|child_process
name|fastimport
decl_stmt|;
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ref
modifier|*
name|posn
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|get_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_importer
argument_list|(
name|transport
argument_list|,
operator|&
name|fastimport
argument_list|)
condition|)
name|die
argument_list|(
literal|"Couldn't run fast-import"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_heads
condition|;
name|i
operator|++
control|)
block|{
name|posn
operator|=
name|to_fetch
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|posn
operator|->
name|status
operator|&
name|REF_STATUS_UPTODATE
condition|)
continue|continue;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"import %s\n"
argument_list|,
name|posn
operator|->
name|symref
condition|?
name|posn
operator|->
name|symref
else|:
name|posn
operator|->
name|name
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_reset
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
name|write_constant
argument_list|(
name|data
operator|->
name|helper
operator|->
name|in
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * remote-helpers that advertise the bidi-import capability are required to 	 * buffer the complete batch of import commands until this newline before 	 * sending data to fast-import. 	 * These helpers read back data from fast-import on their stdin, which could 	 * be mixed with import commands, otherwise. 	 */
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|fastimport
argument_list|)
condition|)
name|die
argument_list|(
literal|"Error while running fast-import"
argument_list|)
expr_stmt|;
comment|/* 	 * The fast-import stream of a remote helper that advertises 	 * the "refspec" capability writes to the refs named after the 	 * right hand side of the first refspec matching each ref we 	 * were fetching. 	 * 	 * (If no "refspec" capability was specified, for historical 	 * reasons we default to the equivalent of *:*.) 	 * 	 * Store the result in to_fetch[i].old_sha1.  Callers such 	 * as "git fetch" can use the value to write feedback to the 	 * terminal, populate FETCH_HEAD, and determine what new value 	 * should be written to peer_ref if the update is a 	 * fast-forward or this is a forced update. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_heads
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|private
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|posn
operator|=
name|to_fetch
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|posn
operator|->
name|status
operator|&
name|REF_STATUS_UPTODATE
condition|)
continue|continue;
name|name
operator|=
name|posn
operator|->
name|symref
condition|?
name|posn
operator|->
name|symref
else|:
name|posn
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|refspecs
condition|)
name|private
operator|=
name|apply_refspecs
argument_list|(
name|data
operator|->
name|refspecs
argument_list|,
name|data
operator|->
name|refspec_nr
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|private
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
condition|)
block|{
if|if
condition|(
name|read_ref
argument_list|(
name|private
argument_list|,
name|posn
operator|->
name|old_oid
operator|.
name|hash
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Could not read ref %s"
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|private
argument_list|)
expr_stmt|;
block|}
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|process_connect_service
specifier|static
name|int
name|process_connect_service
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|exec
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|struct
name|strbuf
name|cmdbuf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|child_process
modifier|*
name|helper
decl_stmt|;
name|int
name|r
decl_stmt|,
name|duped
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|input
decl_stmt|;
name|helper
operator|=
name|get_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
comment|/* 	 * Yes, dup the pipe another time, as we need unbuffered version 	 * of input pipe as FILE*. fclose() closes the underlying fd and 	 * stream buffering only can be changed before first I/O operation 	 * on it. 	 */
name|duped
operator|=
name|dup
argument_list|(
name|helper
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|duped
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"Can't dup helper output fd"
argument_list|)
expr_stmt|;
name|input
operator|=
name|xfdopen
argument_list|(
name|duped
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|input
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Handle --upload-pack and friends. This is fire and forget... 	 * just warn if it fails. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|exec
argument_list|)
condition|)
block|{
name|r
operator|=
name|set_helper_option
argument_list|(
name|transport
argument_list|,
literal|"servpath"
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|warning
argument_list|(
literal|"Setting remote service path not supported by protocol."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|warning
argument_list|(
literal|"Invalid remote service path."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|connect
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|cmdbuf
argument_list|,
literal|"connect %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
goto|goto
name|exit
goto|;
name|sendline
argument_list|(
name|data
argument_list|,
operator|&
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvline_fh
argument_list|(
name|input
argument_list|,
operator|&
name|cmdbuf
argument_list|,
name|name
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmdbuf
operator|.
name|buf
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|data
operator|->
name|no_disconnect_req
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Smart transport connection "
literal|"ready.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmdbuf
operator|.
name|buf
argument_list|,
literal|"fallback"
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Falling back to dumb "
literal|"transport.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"Unknown response to connect: %s"
argument_list|,
name|cmdbuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|exit
label|:
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|process_connect
specifier|static
name|int
name|process_connect
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|int
name|for_push
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|exec
decl_stmt|;
name|name
operator|=
name|for_push
condition|?
literal|"git-receive-pack"
else|:
literal|"git-upload-pack"
expr_stmt|;
if|if
condition|(
name|for_push
condition|)
name|exec
operator|=
name|data
operator|->
name|transport_options
operator|.
name|receivepack
expr_stmt|;
else|else
name|exec
operator|=
name|data
operator|->
name|transport_options
operator|.
name|uploadpack
expr_stmt|;
return|return
name|process_connect_service
argument_list|(
name|transport
argument_list|,
name|name
argument_list|,
name|exec
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|connect_helper
specifier|static
name|int
name|connect_helper
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|exec
parameter_list|,
name|int
name|fd
index|[
literal|2
index|]
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
comment|/* Get_helper so connect is inited. */
name|get_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|connect
condition|)
name|die
argument_list|(
literal|"Operation not supported by protocol."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process_connect_service
argument_list|(
name|transport
argument_list|,
name|name
argument_list|,
name|exec
argument_list|)
condition|)
name|die
argument_list|(
literal|"Can't connect to subservice %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|data
operator|->
name|helper
operator|->
name|out
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|data
operator|->
name|helper
operator|->
name|in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fetch
specifier|static
name|int
name|fetch
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|int
name|nr_heads
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|to_fetch
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|process_connect
argument_list|(
name|transport
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|do_take_over
argument_list|(
name|transport
argument_list|)
expr_stmt|;
return|return
name|transport
operator|->
name|fetch
argument_list|(
name|transport
argument_list|,
name|nr_heads
argument_list|,
name|to_fetch
argument_list|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_heads
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|to_fetch
index|[
name|i
index|]
operator|->
name|status
operator|&
name|REF_STATUS_UPTODATE
operator|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|data
operator|->
name|check_connectivity
operator|&&
name|data
operator|->
name|transport_options
operator|.
name|check_self_contained_and_connected
condition|)
name|set_helper_option
argument_list|(
name|transport
argument_list|,
literal|"check-connectivity"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|transport
operator|->
name|cloning
condition|)
name|set_helper_option
argument_list|(
name|transport
argument_list|,
literal|"cloning"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|transport_options
operator|.
name|update_shallow
condition|)
name|set_helper_option
argument_list|(
name|transport
argument_list|,
literal|"update-shallow"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|fetch
condition|)
return|return
name|fetch_with_fetch
argument_list|(
name|transport
argument_list|,
name|nr_heads
argument_list|,
name|to_fetch
argument_list|)
return|;
if|if
condition|(
name|data
operator|->
name|import
condition|)
return|return
name|fetch_with_import
argument_list|(
name|transport
argument_list|,
name|nr_heads
argument_list|,
name|to_fetch
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|push_update_ref_status
specifier|static
name|int
name|push_update_ref_status
parameter_list|(
name|struct
name|strbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|ref
modifier|*
modifier|*
name|ref
parameter_list|,
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|)
block|{
name|char
modifier|*
name|refname
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|int
name|status
decl_stmt|,
name|forced
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|starts_with
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
literal|"ok "
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_OK
expr_stmt|;
name|refname
operator|=
name|buf
operator|->
name|buf
operator|+
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|starts_with
argument_list|(
name|buf
operator|->
name|buf
argument_list|,
literal|"error "
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_REMOTE_REJECT
expr_stmt|;
name|refname
operator|=
name|buf
operator|->
name|buf
operator|+
literal|6
expr_stmt|;
block|}
else|else
name|die
argument_list|(
literal|"expected ok/error, helper said '%s'"
argument_list|,
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|msg
operator|=
name|strchr
argument_list|(
name|refname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|struct
name|strbuf
name|msg_buf
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
operator|*
name|msg
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|unquote_c_style
argument_list|(
operator|&
name|msg_buf
argument_list|,
name|msg
argument_list|,
operator|&
name|end
argument_list|)
condition|)
name|msg
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|msg_buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|xstrdup
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|msg_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"no match"
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_NONE
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"up to date"
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_UPTODATE
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"non-fast forward"
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_REJECT_NONFASTFORWARD
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"already exists"
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_REJECT_ALREADY_EXISTS
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"fetch first"
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_REJECT_FETCH_FIRST
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"needs force"
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_REJECT_NEEDS_FORCE
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"stale info"
argument_list|)
condition|)
block|{
name|status
operator|=
name|REF_STATUS_REJECT_STALE
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"forced update"
argument_list|)
condition|)
block|{
name|forced
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|ref
condition|)
operator|*
name|ref
operator|=
name|find_ref_by_name
argument_list|(
operator|*
name|ref
argument_list|,
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ref
condition|)
operator|*
name|ref
operator|=
name|find_ref_by_name
argument_list|(
name|remote_refs
argument_list|,
name|refname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ref
condition|)
block|{
name|warning
argument_list|(
literal|"helper reported unexpected status of %s"
argument_list|,
name|refname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|ref
operator|)
operator|->
name|status
operator|!=
name|REF_STATUS_NONE
condition|)
block|{
comment|/* 		 * Earlier, the ref was marked not to be pushed, so ignore the ref 		 * status reported by the remote helper if the latter is 'no match'. 		 */
if|if
condition|(
name|status
operator|==
name|REF_STATUS_NONE
condition|)
return|return
literal|1
return|;
block|}
operator|(
operator|*
name|ref
operator|)
operator|->
name|status
operator|=
name|status
expr_stmt|;
operator|(
operator|*
name|ref
operator|)
operator|->
name|forced_update
operator||=
name|forced
expr_stmt|;
operator|(
operator|*
name|ref
operator|)
operator|->
name|remote_status
operator|=
name|msg
expr_stmt|;
return|return
operator|!
operator|(
name|status
operator|==
name|REF_STATUS_OK
operator|)
return|;
block|}
end_function
begin_function
DECL|function|push_update_refs_status
specifier|static
name|int
name|push_update_refs_status
parameter_list|(
name|struct
name|helper_data
modifier|*
name|data
parameter_list|,
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
init|=
name|remote_refs
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|private
decl_stmt|;
if|if
condition|(
name|recvline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|buf
operator|.
name|len
condition|)
break|break;
if|if
condition|(
name|push_update_ref_status
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|ref
argument_list|,
name|remote_refs
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|flags
operator|&
name|TRANSPORT_PUSH_DRY_RUN
operator|||
operator|!
name|data
operator|->
name|refspecs
operator|||
name|data
operator|->
name|no_private_update
condition|)
continue|continue;
comment|/* propagate back the update to the remote namespace */
name|private
operator|=
name|apply_refspecs
argument_list|(
name|data
operator|->
name|refspecs
argument_list|,
name|data
operator|->
name|refspec_nr
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|private
condition|)
continue|continue;
name|update_ref
argument_list|(
literal|"update by helper"
argument_list|,
name|private
argument_list|,
name|ref
operator|->
name|new_oid
operator|.
name|hash
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|private
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|set_common_push_options
specifier|static
name|void
name|set_common_push_options
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|TRANSPORT_PUSH_DRY_RUN
condition|)
block|{
if|if
condition|(
name|set_helper_option
argument_list|(
name|transport
argument_list|,
literal|"dry-run"
argument_list|,
literal|"true"
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"helper %s does not support dry-run"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TRANSPORT_PUSH_CERT_ALWAYS
condition|)
block|{
if|if
condition|(
name|set_helper_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_PUSH_CERT
argument_list|,
literal|"true"
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"helper %s does not support --signed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|TRANSPORT_PUSH_CERT_IF_ASKED
condition|)
block|{
if|if
condition|(
name|set_helper_option
argument_list|(
name|transport
argument_list|,
name|TRANS_OPT_PUSH_CERT
argument_list|,
literal|"if-asked"
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"helper %s does not support --signed=if-asked"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|push_refs_with_push
specifier|static
name|int
name|push_refs_with_push
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|force_all
init|=
name|flags
operator|&
name|TRANSPORT_PUSH_FORCE
decl_stmt|;
name|int
name|mirror
init|=
name|flags
operator|&
name|TRANSPORT_PUSH_MIRROR
decl_stmt|;
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|string_list
name|cas_options
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|cas_option
decl_stmt|;
name|get_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|push
condition|)
return|return
literal|1
return|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ref
operator|->
name|peer_ref
operator|&&
operator|!
name|mirror
condition|)
continue|continue;
comment|/* Check for statuses set by set_ref_status_for_push() */
switch|switch
condition|(
name|ref
operator|->
name|status
condition|)
block|{
case|case
name|REF_STATUS_REJECT_NONFASTFORWARD
case|:
case|case
name|REF_STATUS_REJECT_STALE
case|:
case|case
name|REF_STATUS_REJECT_ALREADY_EXISTS
case|:
case|case
name|REF_STATUS_UPTODATE
case|:
continue|continue;
default|default:
empty_stmt|;
comment|/* do nothing */
block|}
if|if
condition|(
name|force_all
condition|)
name|ref
operator|->
name|force
operator|=
literal|1
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
literal|"push "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
operator|->
name|deletion
condition|)
block|{
if|if
condition|(
name|ref
operator|->
name|force
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|peer_ref
condition|)
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|oid_to_hex
argument_list|(
operator|&
name|ref
operator|->
name|new_oid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|buf
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* 		 * The "--force-with-lease" options without explicit 		 * values to expect have already been expanded into 		 * the ref->old_oid_expect[] field; we can ignore 		 * transport->smart_options->cas altogether and instead 		 * can enumerate them from the refs. 		 */
if|if
condition|(
name|ref
operator|->
name|expect_old_sha1
condition|)
block|{
name|struct
name|strbuf
name|cas
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|cas
argument_list|,
literal|"%s:%s"
argument_list|,
name|ref
operator|->
name|name
argument_list|,
name|oid_to_hex
argument_list|(
operator|&
name|ref
operator|->
name|old_oid_expect
argument_list|)
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|cas_options
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|cas
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|string_list_clear
argument_list|(
operator|&
name|cas_options
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|for_each_string_list_item
argument_list|(
argument|cas_option
argument_list|,
argument|&cas_options
argument_list|)
name|set_helper_option
argument_list|(
name|transport
argument_list|,
literal|"cas"
argument_list|,
name|cas_option
operator|->
name|string
argument_list|)
expr_stmt|;
name|set_common_push_options
argument_list|(
name|transport
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|push_update_refs_status
argument_list|(
name|data
argument_list|,
name|remote_refs
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|push_refs_with_export
specifier|static
name|int
name|push_refs_with_export
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|child_process
modifier|*
name|helper
decl_stmt|,
name|exporter
decl_stmt|;
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|struct
name|string_list
name|revlist_args
init|=
name|STRING_LIST_INIT_DUP
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|refspecs
condition|)
name|die
argument_list|(
literal|"remote-helper doesn't support push; refspec needed"
argument_list|)
expr_stmt|;
name|set_common_push_options
argument_list|(
name|transport
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TRANSPORT_PUSH_FORCE
condition|)
block|{
if|if
condition|(
name|set_helper_option
argument_list|(
name|transport
argument_list|,
literal|"force"
argument_list|,
literal|"true"
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"helper %s does not support 'force'"
argument_list|,
name|data
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|helper
operator|=
name|get_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
name|write_constant
argument_list|(
name|helper
operator|->
name|in
argument_list|,
literal|"export\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ref
operator|=
name|remote_refs
init|;
name|ref
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|private
decl_stmt|;
name|struct
name|object_id
name|oid
decl_stmt|;
name|private
operator|=
name|apply_refspecs
argument_list|(
name|data
operator|->
name|refspecs
argument_list|,
name|data
operator|->
name|refspec_nr
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|&&
operator|!
name|get_sha1
argument_list|(
name|private
argument_list|,
name|oid
operator|.
name|hash
argument_list|)
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"^%s"
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|revlist_args
argument_list|,
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|oidcpy
argument_list|(
operator|&
name|ref
operator|->
name|old_oid
argument_list|,
operator|&
name|oid
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|private
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|peer_ref
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ref
operator|->
name|name
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ref
operator|->
name|deletion
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* Follow symbolic refs (mainly for HEAD). */
name|name
operator|=
name|resolve_ref_unsafe
argument_list|(
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|,
name|RESOLVE_REF_READING
argument_list|,
name|oid
operator|.
name|hash
argument_list|,
operator|&
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|(
name|flag
operator|&
name|REF_ISSYMREF
operator|)
condition|)
name|name
operator|=
name|ref
operator|->
name|peer_ref
operator|->
name|name
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s:%s"
argument_list|,
name|name
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|":%s"
argument_list|,
name|ref
operator|->
name|name
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|revlist_args
argument_list|,
literal|"--refspec"
argument_list|)
expr_stmt|;
name|string_list_append
argument_list|(
operator|&
name|revlist_args
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ref
operator|->
name|deletion
condition|)
name|string_list_append
argument_list|(
operator|&
name|revlist_args
argument_list|,
name|ref
operator|->
name|peer_ref
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|get_exporter
argument_list|(
name|transport
argument_list|,
operator|&
name|exporter
argument_list|,
operator|&
name|revlist_args
argument_list|)
condition|)
name|die
argument_list|(
literal|"Couldn't run fast-export"
argument_list|)
expr_stmt|;
name|string_list_clear
argument_list|(
operator|&
name|revlist_args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish_command
argument_list|(
operator|&
name|exporter
argument_list|)
condition|)
name|die
argument_list|(
literal|"Error while running fast-export"
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_update_refs_status
argument_list|(
name|data
argument_list|,
name|remote_refs
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|data
operator|->
name|export_marks
condition|)
block|{
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s.tmp"
argument_list|,
name|data
operator|->
name|export_marks
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
name|data
operator|->
name|export_marks
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|push_refs
specifier|static
name|int
name|push_refs
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|struct
name|ref
modifier|*
name|remote_refs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|process_connect
argument_list|(
name|transport
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|do_take_over
argument_list|(
name|transport
argument_list|)
expr_stmt|;
return|return
name|transport
operator|->
name|push_refs
argument_list|(
name|transport
argument_list|,
name|remote_refs
argument_list|,
name|flags
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|remote_refs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No refs in common and none specified; doing nothing.\n"
literal|"Perhaps you should specify a branch such as 'master'.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|data
operator|->
name|push
condition|)
return|return
name|push_refs_with_push
argument_list|(
name|transport
argument_list|,
name|remote_refs
argument_list|,
name|flags
argument_list|)
return|;
if|if
condition|(
name|data
operator|->
name|export
condition|)
return|return
name|push_refs_with_export
argument_list|(
name|transport
argument_list|,
name|remote_refs
argument_list|,
name|flags
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|has_attribute
specifier|static
name|int
name|has_attribute
parameter_list|(
specifier|const
name|char
modifier|*
name|attrs
parameter_list|,
specifier|const
name|char
modifier|*
name|attr
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|attrs
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|strlen
argument_list|(
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|space
init|=
name|strchrnul
argument_list|(
name|attrs
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|space
operator|-
name|attrs
operator|&&
operator|!
name|strncmp
argument_list|(
name|attrs
argument_list|,
name|attr
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|space
condition|)
return|return
literal|0
return|;
name|attrs
operator|=
name|space
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|get_refs_list
specifier|static
name|struct
name|ref
modifier|*
name|get_refs_list
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
name|int
name|for_push
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|transport
operator|->
name|data
decl_stmt|;
name|struct
name|child_process
modifier|*
name|helper
decl_stmt|;
name|struct
name|ref
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ret
decl_stmt|;
name|struct
name|ref
modifier|*
name|posn
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|helper
operator|=
name|get_helper
argument_list|(
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_connect
argument_list|(
name|transport
argument_list|,
name|for_push
argument_list|)
condition|)
block|{
name|do_take_over
argument_list|(
name|transport
argument_list|)
expr_stmt|;
return|return
name|transport
operator|->
name|get_refs_list
argument_list|(
name|transport
argument_list|,
name|for_push
argument_list|)
return|;
block|}
if|if
condition|(
name|data
operator|->
name|push
operator|&&
name|for_push
condition|)
name|write_str_in_full
argument_list|(
name|helper
operator|->
name|in
argument_list|,
literal|"list for-push\n"
argument_list|)
expr_stmt|;
else|else
name|write_str_in_full
argument_list|(
name|helper
operator|->
name|in
argument_list|,
literal|"list\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|eov
decl_stmt|,
modifier|*
name|eon
decl_stmt|;
if|if
condition|(
name|recvline
argument_list|(
name|data
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|buf
operator|.
name|buf
condition|)
break|break;
name|eov
operator|=
name|strchr
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eov
condition|)
name|die
argument_list|(
literal|"Malformed response in ref list: %s"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|eon
operator|=
name|strchr
argument_list|(
name|eov
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|*
name|eov
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|eon
condition|)
operator|*
name|eon
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|tail
operator|=
name|alloc_ref
argument_list|(
name|eov
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|buf
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|symref
operator|=
name|xstrdup
argument_list|(
name|buf
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
operator|.
name|buf
index|[
literal|0
index|]
operator|!=
literal|'?'
condition|)
name|get_oid_hex
argument_list|(
name|buf
operator|.
name|buf
argument_list|,
operator|&
operator|(
operator|*
name|tail
operator|)
operator|->
name|old_oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|eon
condition|)
block|{
if|if
condition|(
name|has_attribute
argument_list|(
name|eon
operator|+
literal|1
argument_list|,
literal|"unchanged"
argument_list|)
condition|)
block|{
operator|(
operator|*
name|tail
operator|)
operator|->
name|status
operator||=
name|REF_STATUS_UPTODATE
expr_stmt|;
if|if
condition|(
name|read_ref
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|tail
operator|)
operator|->
name|old_oid
operator|.
name|hash
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
name|N_
argument_list|(
literal|"Could not read ref %s"
argument_list|)
argument_list|,
operator|(
operator|*
name|tail
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|tail
operator|=
operator|&
operator|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Read ref listing.\n"
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|posn
operator|=
name|ret
init|;
name|posn
condition|;
name|posn
operator|=
name|posn
operator|->
name|next
control|)
name|resolve_remote_symref
argument_list|(
name|posn
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|transport_helper_init
name|int
name|transport_helper_init
parameter_list|(
name|struct
name|transport
modifier|*
name|transport
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|helper_data
modifier|*
name|data
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|transport_check_allowed
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GIT_TRANSPORT_HELPER_DEBUG"
argument_list|)
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
name|transport
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|transport
operator|->
name|set_option
operator|=
name|set_helper_option
expr_stmt|;
name|transport
operator|->
name|get_refs_list
operator|=
name|get_refs_list
expr_stmt|;
name|transport
operator|->
name|fetch
operator|=
name|fetch
expr_stmt|;
name|transport
operator|->
name|push_refs
operator|=
name|push_refs
expr_stmt|;
name|transport
operator|->
name|disconnect
operator|=
name|release_helper
expr_stmt|;
name|transport
operator|->
name|connect
operator|=
name|connect_helper
expr_stmt|;
name|transport
operator|->
name|smart_options
operator|=
operator|&
operator|(
name|data
operator|->
name|transport_options
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Linux pipes can buffer 65536 bytes at once (and most platforms can  * buffer less), so attempt reads and writes with up to that size.  */
end_comment
begin_define
DECL|macro|BUFFERSIZE
define|#
directive|define
name|BUFFERSIZE
value|65536
end_define
begin_comment
comment|/* This should be enough to hold debugging message. */
end_comment
begin_define
DECL|macro|PBUFFERSIZE
define|#
directive|define
name|PBUFFERSIZE
value|8192
end_define
begin_comment
comment|/* Print bidirectional transfer loop debug message. */
end_comment
begin_macro
name|__attribute__
argument_list|(
argument|(format (printf,
literal|1
argument|,
literal|2
argument|))
argument_list|)
end_macro
begin_function
DECL|function|transfer_debug
specifier|static
name|void
name|transfer_debug
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|msgbuf
index|[
name|PBUFFERSIZE
index|]
decl_stmt|;
specifier|static
name|int
name|debug_enabled
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|debug_enabled
operator|<
literal|0
condition|)
name|debug_enabled
operator|=
name|getenv
argument_list|(
literal|"GIT_TRANSLOOP_DEBUG"
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|debug_enabled
condition|)
return|return;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
name|PBUFFERSIZE
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Transfer loop debugging: %s\n"
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Stream state: More data may be coming in this direction. */
end_comment
begin_define
DECL|macro|SSTATE_TRANSFERING
define|#
directive|define
name|SSTATE_TRANSFERING
value|0
end_define
begin_comment
comment|/*  * Stream state: No more data coming in this direction, flushing rest of  * data.  */
end_comment
begin_define
DECL|macro|SSTATE_FLUSHING
define|#
directive|define
name|SSTATE_FLUSHING
value|1
end_define
begin_comment
comment|/* Stream state: Transfer in this direction finished. */
end_comment
begin_define
DECL|macro|SSTATE_FINISHED
define|#
directive|define
name|SSTATE_FINISHED
value|2
end_define
begin_define
DECL|macro|STATE_NEEDS_READING
define|#
directive|define
name|STATE_NEEDS_READING
parameter_list|(
name|state
parameter_list|)
value|((state)<= SSTATE_TRANSFERING)
end_define
begin_define
DECL|macro|STATE_NEEDS_WRITING
define|#
directive|define
name|STATE_NEEDS_WRITING
parameter_list|(
name|state
parameter_list|)
value|((state)<= SSTATE_FLUSHING)
end_define
begin_define
DECL|macro|STATE_NEEDS_CLOSING
define|#
directive|define
name|STATE_NEEDS_CLOSING
parameter_list|(
name|state
parameter_list|)
value|((state) == SSTATE_FLUSHING)
end_define
begin_comment
comment|/* Unidirectional transfer. */
end_comment
begin_struct
DECL|struct|unidirectional_transfer
struct|struct
name|unidirectional_transfer
block|{
comment|/* Source */
DECL|member|src
name|int
name|src
decl_stmt|;
comment|/* Destination */
DECL|member|dest
name|int
name|dest
decl_stmt|;
comment|/* Is source socket? */
DECL|member|src_is_sock
name|int
name|src_is_sock
decl_stmt|;
comment|/* Is destination socket? */
DECL|member|dest_is_sock
name|int
name|dest_is_sock
decl_stmt|;
comment|/* Transfer state (TRANSFERRING/FLUSHING/FINISHED) */
DECL|member|state
name|int
name|state
decl_stmt|;
comment|/* Buffer. */
DECL|member|buf
name|char
name|buf
index|[
name|BUFFERSIZE
index|]
decl_stmt|;
comment|/* Buffer used. */
DECL|member|bufuse
name|size_t
name|bufuse
decl_stmt|;
comment|/* Name of source. */
DECL|member|src_name
specifier|const
name|char
modifier|*
name|src_name
decl_stmt|;
comment|/* Name of destination. */
DECL|member|dest_name
specifier|const
name|char
modifier|*
name|dest_name
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Closes the target (for writing) if transfer has finished. */
end_comment
begin_function
DECL|function|udt_close_if_finished
specifier|static
name|void
name|udt_close_if_finished
parameter_list|(
name|struct
name|unidirectional_transfer
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|STATE_NEEDS_CLOSING
argument_list|(
name|t
operator|->
name|state
argument_list|)
operator|&&
operator|!
name|t
operator|->
name|bufuse
condition|)
block|{
name|t
operator|->
name|state
operator|=
name|SSTATE_FINISHED
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|dest_is_sock
condition|)
name|shutdown
argument_list|(
name|t
operator|->
name|dest
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|t
operator|->
name|dest
argument_list|)
expr_stmt|;
name|transfer_debug
argument_list|(
literal|"Closed %s."
argument_list|,
name|t
operator|->
name|dest_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Tries to read read data from source into buffer. If buffer is full,  * no data is read. Returns 0 on success, -1 on error.  */
end_comment
begin_function
DECL|function|udt_do_read
specifier|static
name|int
name|udt_do_read
parameter_list|(
name|struct
name|unidirectional_transfer
modifier|*
name|t
parameter_list|)
block|{
name|ssize_t
name|bytes
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|bufuse
operator|==
name|BUFFERSIZE
condition|)
return|return
literal|0
return|;
comment|/* No space for more. */
name|transfer_debug
argument_list|(
literal|"%s is readable"
argument_list|,
name|t
operator|->
name|src_name
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|read
argument_list|(
name|t
operator|->
name|src
argument_list|,
name|t
operator|->
name|buf
operator|+
name|t
operator|->
name|bufuse
argument_list|,
name|BUFFERSIZE
operator|-
name|t
operator|->
name|bufuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|error
argument_list|(
literal|"read(%s) failed: %s"
argument_list|,
name|t
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|transfer_debug
argument_list|(
literal|"%s EOF (with %i bytes in buffer)"
argument_list|,
name|t
operator|->
name|src_name
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|bufuse
argument_list|)
expr_stmt|;
name|t
operator|->
name|state
operator|=
name|SSTATE_FLUSHING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|t
operator|->
name|bufuse
operator|+=
name|bytes
expr_stmt|;
name|transfer_debug
argument_list|(
literal|"Read %i bytes from %s (buffer now at %i)"
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|,
name|t
operator|->
name|src_name
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|bufuse
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Tries to write data from buffer into destination. If buffer is empty,  * no data is written. Returns 0 on success, -1 on error.  */
end_comment
begin_function
DECL|function|udt_do_write
specifier|static
name|int
name|udt_do_write
parameter_list|(
name|struct
name|unidirectional_transfer
modifier|*
name|t
parameter_list|)
block|{
name|ssize_t
name|bytes
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|bufuse
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Nothing to write. */
name|transfer_debug
argument_list|(
literal|"%s is writable"
argument_list|,
name|t
operator|->
name|dest_name
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|xwrite
argument_list|(
name|t
operator|->
name|dest
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|bufuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|error
argument_list|(
literal|"write(%s) failed: %s"
argument_list|,
name|t
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
name|t
operator|->
name|bufuse
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bufuse
condition|)
name|memmove
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|buf
operator|+
name|bytes
argument_list|,
name|t
operator|->
name|bufuse
argument_list|)
expr_stmt|;
name|transfer_debug
argument_list|(
literal|"Wrote %i bytes to %s (buffer now at %i)"
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|,
name|t
operator|->
name|dest_name
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|bufuse
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* State of bidirectional transfer loop. */
end_comment
begin_struct
DECL|struct|bidirectional_transfer_state
struct|struct
name|bidirectional_transfer_state
block|{
comment|/* Direction from program to git. */
DECL|member|ptg
name|struct
name|unidirectional_transfer
name|ptg
decl_stmt|;
comment|/* Direction from git to program. */
DECL|member|gtp
name|struct
name|unidirectional_transfer
name|gtp
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|udt_copy_task_routine
specifier|static
name|void
modifier|*
name|udt_copy_task_routine
parameter_list|(
name|void
modifier|*
name|udt
parameter_list|)
block|{
name|struct
name|unidirectional_transfer
modifier|*
name|t
init|=
operator|(
expr|struct
name|unidirectional_transfer
operator|*
operator|)
name|udt
decl_stmt|;
while|while
condition|(
name|t
operator|->
name|state
operator|!=
name|SSTATE_FINISHED
condition|)
block|{
if|if
condition|(
name|STATE_NEEDS_READING
argument_list|(
name|t
operator|->
name|state
argument_list|)
condition|)
if|if
condition|(
name|udt_do_read
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|STATE_NEEDS_WRITING
argument_list|(
name|t
operator|->
name|state
argument_list|)
condition|)
if|if
condition|(
name|udt_do_write
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|STATE_NEEDS_CLOSING
argument_list|(
name|t
operator|->
name|state
argument_list|)
condition|)
name|udt_close_if_finished
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|udt
return|;
comment|/* Just some non-NULL value. */
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_PTHREADS
end_ifndef
begin_comment
comment|/*  * Join thread, with appropriate errors on failure. Name is name for the  * thread (for error messages). Returns 0 on success, 1 on failure.  */
end_comment
begin_function
DECL|function|tloop_join
specifier|static
name|int
name|tloop_join
parameter_list|(
name|pthread_t
name|thread
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|void
modifier|*
name|tret
decl_stmt|;
name|err
operator|=
name|pthread_join
argument_list|(
name|thread
argument_list|,
operator|&
name|tret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tret
condition|)
block|{
name|error
argument_list|(
literal|"%s thread failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"%s thread failed to join: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Spawn the transfer tasks and then wait for them. Returns 0 on success,  * -1 on failure.  */
end_comment
begin_function
DECL|function|tloop_spawnwait_tasks
specifier|static
name|int
name|tloop_spawnwait_tasks
parameter_list|(
name|struct
name|bidirectional_transfer_state
modifier|*
name|s
parameter_list|)
block|{
name|pthread_t
name|gtp_thread
decl_stmt|;
name|pthread_t
name|ptg_thread
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|pthread_create
argument_list|(
operator|&
name|gtp_thread
argument_list|,
name|NULL
argument_list|,
name|udt_copy_task_routine
argument_list|,
operator|&
name|s
operator|->
name|gtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|die
argument_list|(
literal|"Can't start thread for copying data: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|pthread_create
argument_list|(
operator|&
name|ptg_thread
argument_list|,
name|NULL
argument_list|,
name|udt_copy_task_routine
argument_list|,
operator|&
name|s
operator|->
name|ptg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|die
argument_list|(
literal|"Can't start thread for copying data: %s"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator||=
name|tloop_join
argument_list|(
name|gtp_thread
argument_list|,
literal|"Git to program copy"
argument_list|)
expr_stmt|;
name|ret
operator||=
name|tloop_join
argument_list|(
name|ptg_thread
argument_list|,
literal|"Program to git copy"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* Close the source and target (for writing) for transfer. */
end_comment
begin_function
DECL|function|udt_kill_transfer
specifier|static
name|void
name|udt_kill_transfer
parameter_list|(
name|struct
name|unidirectional_transfer
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|state
operator|=
name|SSTATE_FINISHED
expr_stmt|;
comment|/* 	 * Socket read end left open isn't a disaster if nobody 	 * attempts to read from it (mingw compat headers do not 	 * have SHUT_RD)... 	 * 	 * We can't fully close the socket since otherwise gtp 	 * task would first close the socket it sends data to 	 * while closing the ptg file descriptors. 	 */
if|if
condition|(
operator|!
name|t
operator|->
name|src_is_sock
condition|)
name|close
argument_list|(
name|t
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|dest_is_sock
condition|)
name|shutdown
argument_list|(
name|t
operator|->
name|dest
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|t
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Join process, with appropriate errors on failure. Name is name for the  * process (for error messages). Returns 0 on success, 1 on failure.  */
end_comment
begin_function
DECL|function|tloop_join
specifier|static
name|int
name|tloop_join
parameter_list|(
name|pid_t
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|tret
decl_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|tret
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s process failed to wait: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|tret
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|tret
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s process failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Spawn the transfer tasks and then wait for them. Returns 0 on success,  * -1 on failure.  */
end_comment
begin_function
DECL|function|tloop_spawnwait_tasks
specifier|static
name|int
name|tloop_spawnwait_tasks
parameter_list|(
name|struct
name|bidirectional_transfer_state
modifier|*
name|s
parameter_list|)
block|{
name|pid_t
name|pid1
decl_stmt|,
name|pid2
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Fork thread #1: git to program. */
name|pid1
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid1
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"Can't start thread for copying data"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pid1
operator|==
literal|0
condition|)
block|{
name|udt_kill_transfer
argument_list|(
operator|&
name|s
operator|->
name|ptg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|udt_copy_task_routine
argument_list|(
operator|&
name|s
operator|->
name|gtp
argument_list|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Fork thread #2: program to git. */
name|pid2
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid2
operator|<
literal|0
condition|)
name|die_errno
argument_list|(
literal|"Can't start thread for copying data"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pid2
operator|==
literal|0
condition|)
block|{
name|udt_kill_transfer
argument_list|(
operator|&
name|s
operator|->
name|gtp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|udt_copy_task_routine
argument_list|(
operator|&
name|s
operator|->
name|ptg
argument_list|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Close both streams in parent as to not interfere with 	 * end of file detection and wait for both tasks to finish. 	 */
name|udt_kill_transfer
argument_list|(
operator|&
name|s
operator|->
name|gtp
argument_list|)
expr_stmt|;
name|udt_kill_transfer
argument_list|(
operator|&
name|s
operator|->
name|ptg
argument_list|)
expr_stmt|;
name|ret
operator||=
name|tloop_join
argument_list|(
name|pid1
argument_list|,
literal|"Git to program copy"
argument_list|)
expr_stmt|;
name|ret
operator||=
name|tloop_join
argument_list|(
name|pid2
argument_list|,
literal|"Program to git copy"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Copies data from stdin to output and from input to stdout simultaneously.  * Additionally filtering through given filter. If filter is NULL, uses  * identity filter.  */
end_comment
begin_function
DECL|function|bidirectional_transfer_loop
name|int
name|bidirectional_transfer_loop
parameter_list|(
name|int
name|input
parameter_list|,
name|int
name|output
parameter_list|)
block|{
name|struct
name|bidirectional_transfer_state
name|state
decl_stmt|;
comment|/* Fill the state fields. */
name|state
operator|.
name|ptg
operator|.
name|src
operator|=
name|input
expr_stmt|;
name|state
operator|.
name|ptg
operator|.
name|dest
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|ptg
operator|.
name|src_is_sock
operator|=
operator|(
name|input
operator|==
name|output
operator|)
expr_stmt|;
name|state
operator|.
name|ptg
operator|.
name|dest_is_sock
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|ptg
operator|.
name|state
operator|=
name|SSTATE_TRANSFERING
expr_stmt|;
name|state
operator|.
name|ptg
operator|.
name|bufuse
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|ptg
operator|.
name|src_name
operator|=
literal|"remote input"
expr_stmt|;
name|state
operator|.
name|ptg
operator|.
name|dest_name
operator|=
literal|"stdout"
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|src
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|dest
operator|=
name|output
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|src_is_sock
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|dest_is_sock
operator|=
operator|(
name|input
operator|==
name|output
operator|)
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|state
operator|=
name|SSTATE_TRANSFERING
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|bufuse
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|src_name
operator|=
literal|"stdin"
expr_stmt|;
name|state
operator|.
name|gtp
operator|.
name|dest_name
operator|=
literal|"remote output"
expr_stmt|;
return|return
name|tloop_spawnwait_tasks
argument_list|(
operator|&
name|state
argument_list|)
return|;
block|}
end_function
end_unit
