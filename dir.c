begin_unit
begin_comment
comment|/*  * This handles recursive filename detection with exclude  * files, index knowledge etc..  *  * Copyright (C) Linus Torvalds, 2005-2006  *		 Junio Hamano, 2005-2006  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_struct
DECL|struct|path_simplify
struct|struct
name|path_simplify
block|{
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct
begin_function_decl
specifier|static
name|int
name|read_directory_recursive
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|int
name|check_only
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|get_dtype
parameter_list|(
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|common_prefix
name|int
name|common_prefix
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|prefix
decl_stmt|;
if|if
condition|(
operator|!
name|pathspec
condition|)
return|return
literal|0
return|;
name|path
operator|=
operator|*
name|pathspec
expr_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slash
condition|)
return|return
literal|0
return|;
name|prefix
operator|=
name|slash
operator|-
name|path
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
operator|*
operator|++
name|pathspec
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|prefix
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|next
argument_list|,
name|prefix
argument_list|)
condition|)
continue|continue;
name|len
operator|=
name|prefix
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|next
index|[
operator|--
name|len
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|path
argument_list|,
name|next
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
continue|continue;
name|prefix
operator|=
name|len
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|prefix
return|;
block|}
end_function
begin_function
DECL|function|special_char
specifier|static
specifier|inline
name|int
name|special_char
parameter_list|(
name|unsigned
name|char
name|c1
parameter_list|)
block|{
return|return
operator|!
name|c1
operator|||
name|c1
operator|==
literal|'*'
operator|||
name|c1
operator|==
literal|'['
operator|||
name|c1
operator|==
literal|'?'
operator|||
name|c1
operator|==
literal|'\\'
return|;
block|}
end_function
begin_comment
comment|/*  * Does 'match' matches the given name?  * A match is found if  *  * (1) the 'match' string is leading directory of 'name', or  * (2) the 'match' string is a wildcard and matches 'name', or  * (3) the 'match' string is exactly the same as 'name'.  *  * and the return value tells which case it was.  *  * It returns 0 when there is no match.  */
end_comment
begin_function
DECL|function|match_one
specifier|static
name|int
name|match_one
parameter_list|(
specifier|const
name|char
modifier|*
name|match
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|int
name|matchlen
decl_stmt|;
comment|/* If the match was just the prefix, we matched */
if|if
condition|(
operator|!
operator|*
name|match
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c1
init|=
operator|*
name|match
decl_stmt|;
name|unsigned
name|char
name|c2
init|=
operator|*
name|name
decl_stmt|;
if|if
condition|(
name|special_char
argument_list|(
name|c1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
literal|0
return|;
name|match
operator|++
expr_stmt|;
name|name
operator|++
expr_stmt|;
name|namelen
operator|--
expr_stmt|;
block|}
comment|/* 	 * If we don't match the matchstring exactly, 	 * we need to match by fnmatch 	 */
name|matchlen
operator|=
name|strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
name|matchlen
argument_list|)
condition|)
return|return
operator|!
name|fnmatch
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
condition|?
name|MATCHED_FNMATCH
else|:
literal|0
return|;
if|if
condition|(
name|namelen
operator|==
name|matchlen
condition|)
return|return
name|MATCHED_EXACTLY
return|;
if|if
condition|(
name|match
index|[
name|matchlen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
name|matchlen
index|]
operator|==
literal|'/'
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given a name and a list of pathspecs, see if the name matches  * any of the pathspecs.  The caller is also interested in seeing  * all pathspec matches some names it calls this function with  * (otherwise the user could have mistyped the unmatched pathspec),  * and a mark is left in seen[] array for pathspec element that  * actually matched anything.  */
end_comment
begin_function
DECL|function|match_pathspec
name|int
name|match_pathspec
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|prefix
parameter_list|,
name|char
modifier|*
name|seen
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
name|name
operator|+=
name|prefix
expr_stmt|;
name|namelen
operator|-=
name|prefix
expr_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
init|;
operator|(
name|match
operator|=
operator|*
name|pathspec
operator|++
operator|)
operator|!=
name|NULL
condition|;
name|seen
operator|++
control|)
block|{
name|int
name|how
decl_stmt|;
if|if
condition|(
name|retval
operator|&&
operator|*
name|seen
operator|==
name|MATCHED_EXACTLY
condition|)
continue|continue;
name|match
operator|+=
name|prefix
expr_stmt|;
name|how
operator|=
name|match_one
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
condition|)
block|{
if|if
condition|(
name|retval
operator|<
name|how
condition|)
name|retval
operator|=
name|how
expr_stmt|;
if|if
condition|(
operator|*
name|seen
operator|<
name|how
condition|)
operator|*
name|seen
operator|=
name|how
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|no_wildcard
specifier|static
name|int
name|no_wildcard
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|string
index|[
name|strcspn
argument_list|(
name|string
argument_list|,
literal|"*?[{"
argument_list|)
index|]
operator|==
literal|'\0'
return|;
block|}
end_function
begin_function
DECL|function|add_exclude
name|void
name|add_exclude
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|which
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|x
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|to_exclude
init|=
literal|1
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'!'
condition|)
block|{
name|to_exclude
operator|=
literal|0
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|string
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|x
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|string
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string
operator|=
name|s
expr_stmt|;
name|x
operator|->
name|pattern
operator|=
name|s
expr_stmt|;
name|flags
operator|=
name|EXC_FLAG_MUSTBEDIR
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|pattern
operator|=
name|string
expr_stmt|;
block|}
name|x
operator|->
name|to_exclude
operator|=
name|to_exclude
expr_stmt|;
name|x
operator|->
name|patternlen
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|x
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|x
operator|->
name|baselen
operator|=
name|baselen
expr_stmt|;
name|x
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|string
argument_list|,
literal|'/'
argument_list|)
condition|)
name|x
operator|->
name|flags
operator||=
name|EXC_FLAG_NODIR
expr_stmt|;
if|if
condition|(
name|no_wildcard
argument_list|(
name|string
argument_list|)
condition|)
name|x
operator|->
name|flags
operator||=
name|EXC_FLAG_NOWILDCARD
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'*'
operator|&&
name|no_wildcard
argument_list|(
name|string
operator|+
literal|1
argument_list|)
condition|)
name|x
operator|->
name|flags
operator||=
name|EXC_FLAG_ENDSWITH
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|which
operator|->
name|excludes
argument_list|,
name|which
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|which
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|which
operator|->
name|excludes
index|[
name|which
operator|->
name|nr
operator|++
index|]
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_excludes_from_file_1
specifier|static
name|int
name|add_excludes_from_file_1
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|char
modifier|*
modifier|*
name|buf_p
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|which
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_p
condition|)
operator|*
name|buf_p
operator|=
name|buf
expr_stmt|;
name|buf
index|[
name|size
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|entry
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|entry
operator|!=
name|buf
operator|+
name|i
operator|&&
name|entry
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|buf
index|[
name|i
operator|-
operator|(
name|i
operator|&&
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|add_exclude
argument_list|(
name|entry
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
name|buf
operator|+
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|add_excludes_from_file
name|void
name|add_excludes_from_file
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
if|if
condition|(
name|add_excludes_from_file_1
argument_list|(
name|fname
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|dir
operator|->
name|exclude_list
index|[
name|EXC_FILE
index|]
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"cannot use %s as an exclude file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prep_exclude
specifier|static
name|void
name|prep_exclude
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|)
block|{
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|struct
name|exclude_stack
modifier|*
name|stk
init|=
name|NULL
decl_stmt|;
name|int
name|current
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|dir
operator|->
name|exclude_per_dir
operator|)
operator|||
operator|(
name|baselen
operator|+
name|strlen
argument_list|(
name|dir
operator|->
name|exclude_per_dir
argument_list|)
operator|>=
name|PATH_MAX
operator|)
condition|)
return|return;
comment|/* too long a path -- ignore */
comment|/* Pop the ones that are not the prefix of the path being checked. */
name|el
operator|=
operator|&
name|dir
operator|->
name|exclude_list
index|[
name|EXC_DIRS
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|stk
operator|=
name|dir
operator|->
name|exclude_stack
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stk
operator|->
name|baselen
operator|<=
name|baselen
operator|&&
operator|!
name|strncmp
argument_list|(
name|dir
operator|->
name|basebuf
argument_list|,
name|base
argument_list|,
name|stk
operator|->
name|baselen
argument_list|)
condition|)
break|break;
name|dir
operator|->
name|exclude_stack
operator|=
name|stk
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|stk
operator|->
name|exclude_ix
operator|<
name|el
operator|->
name|nr
condition|)
name|free
argument_list|(
name|el
operator|->
name|excludes
index|[
operator|--
name|el
operator|->
name|nr
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stk
operator|->
name|filebuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stk
argument_list|)
expr_stmt|;
block|}
comment|/* Read from the parent directories and push them down. */
name|current
operator|=
name|stk
condition|?
name|stk
operator|->
name|baselen
else|:
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|current
operator|<
name|baselen
condition|)
block|{
name|struct
name|exclude_stack
modifier|*
name|stk
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stk
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|current
operator|<
literal|0
condition|)
block|{
name|cp
operator|=
name|base
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|base
operator|+
name|current
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|die
argument_list|(
literal|"oops in prep_exclude"
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|stk
operator|->
name|prev
operator|=
name|dir
operator|->
name|exclude_stack
expr_stmt|;
name|stk
operator|->
name|baselen
operator|=
name|cp
operator|-
name|base
expr_stmt|;
name|stk
operator|->
name|exclude_ix
operator|=
name|el
operator|->
name|nr
expr_stmt|;
name|memcpy
argument_list|(
name|dir
operator|->
name|basebuf
operator|+
name|current
argument_list|,
name|base
operator|+
name|current
argument_list|,
name|stk
operator|->
name|baselen
operator|-
name|current
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dir
operator|->
name|basebuf
operator|+
name|stk
operator|->
name|baselen
argument_list|,
name|dir
operator|->
name|exclude_per_dir
argument_list|)
expr_stmt|;
name|add_excludes_from_file_1
argument_list|(
name|dir
operator|->
name|basebuf
argument_list|,
name|dir
operator|->
name|basebuf
argument_list|,
name|stk
operator|->
name|baselen
argument_list|,
operator|&
name|stk
operator|->
name|filebuf
argument_list|,
name|el
argument_list|)
expr_stmt|;
name|dir
operator|->
name|exclude_stack
operator|=
name|stk
expr_stmt|;
name|current
operator|=
name|stk
operator|->
name|baselen
expr_stmt|;
block|}
name|dir
operator|->
name|basebuf
index|[
name|baselen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Scan the list and let the last match determines the fate.  * Return 1 for exclude, 0 for include and -1 for undecided.  */
end_comment
begin_function
DECL|function|excluded_1
specifier|static
name|int
name|excluded_1
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|el
operator|->
name|nr
condition|)
block|{
for|for
control|(
name|i
operator|=
name|el
operator|->
name|nr
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|exclude
modifier|*
name|x
init|=
name|el
operator|->
name|excludes
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|exclude
init|=
name|x
operator|->
name|pattern
decl_stmt|;
name|int
name|to_exclude
init|=
name|x
operator|->
name|to_exclude
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_MUSTBEDIR
condition|)
block|{
if|if
condition|(
operator|*
name|dtype
operator|==
name|DT_UNKNOWN
condition|)
operator|*
name|dtype
operator|=
name|get_dtype
argument_list|(
name|NULL
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dtype
operator|!=
name|DT_DIR
condition|)
continue|continue;
block|}
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_NODIR
condition|)
block|{
comment|/* match basename */
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_NOWILDCARD
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|exclude
argument_list|,
name|basename
argument_list|)
condition|)
return|return
name|to_exclude
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_ENDSWITH
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|patternlen
operator|-
literal|1
operator|<=
name|pathlen
operator|&&
operator|!
name|strcmp
argument_list|(
name|exclude
operator|+
literal|1
argument_list|,
name|pathname
operator|+
name|pathlen
operator|-
name|x
operator|->
name|patternlen
operator|+
literal|1
argument_list|)
condition|)
return|return
name|to_exclude
return|;
block|}
else|else
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|exclude
argument_list|,
name|basename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|to_exclude
return|;
block|}
block|}
else|else
block|{
comment|/* match with FNM_PATHNAME: 				 * exclude has base (baselen long) implicitly 				 * in front of it. 				 */
name|int
name|baselen
init|=
name|x
operator|->
name|baselen
decl_stmt|;
if|if
condition|(
operator|*
name|exclude
operator|==
literal|'/'
condition|)
name|exclude
operator|++
expr_stmt|;
if|if
condition|(
name|pathlen
operator|<
name|baselen
operator|||
operator|(
name|baselen
operator|&&
name|pathname
index|[
name|baselen
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
operator|||
name|strncmp
argument_list|(
name|pathname
argument_list|,
name|x
operator|->
name|base
argument_list|,
name|baselen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_NOWILDCARD
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|exclude
argument_list|,
name|pathname
operator|+
name|baselen
argument_list|)
condition|)
return|return
name|to_exclude
return|;
block|}
else|else
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|exclude
argument_list|,
name|pathname
operator|+
name|baselen
argument_list|,
name|FNM_PATHNAME
argument_list|)
operator|==
literal|0
condition|)
return|return
name|to_exclude
return|;
block|}
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|/* undecided */
block|}
end_function
begin_function
DECL|function|excluded
name|int
name|excluded
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
modifier|*
name|dtype_p
parameter_list|)
block|{
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
name|int
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|basename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|basename
operator|=
operator|(
name|basename
operator|)
condition|?
name|basename
operator|+
literal|1
else|:
name|pathname
expr_stmt|;
name|prep_exclude
argument_list|(
name|dir
argument_list|,
name|pathname
argument_list|,
name|basename
operator|-
name|pathname
argument_list|)
expr_stmt|;
for|for
control|(
name|st
operator|=
name|EXC_CMDL
init|;
name|st
operator|<=
name|EXC_FILE
condition|;
name|st
operator|++
control|)
block|{
switch|switch
condition|(
name|excluded_1
argument_list|(
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|basename
argument_list|,
name|dtype_p
argument_list|,
operator|&
name|dir
operator|->
name|exclude_list
index|[
name|st
index|]
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|dir_entry_new
specifier|static
name|struct
name|dir_entry
modifier|*
name|dir_entry_new
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|dir_entry
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ent
operator|->
name|name
argument_list|,
name|pathname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|ent
return|;
block|}
end_function
begin_function
DECL|function|dir_add_name
name|struct
name|dir_entry
modifier|*
name|dir_add_name
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|cache_name_exists
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
name|ignore_case
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|entries
argument_list|,
name|dir
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|alloc
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|entries
index|[
name|dir
operator|->
name|nr
operator|++
index|]
operator|=
name|dir_entry_new
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dir_add_ignored
name|struct
name|dir_entry
modifier|*
name|dir_add_ignored
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|cache_name_pos
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|NULL
return|;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|ignored
argument_list|,
name|dir
operator|->
name|ignored_nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|ignored_alloc
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|ignored
index|[
name|dir
operator|->
name|ignored_nr
operator|++
index|]
operator|=
name|dir_entry_new
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_enum
DECL|enum|exist_status
enum|enum
name|exist_status
block|{
DECL|enumerator|index_nonexistent
name|index_nonexistent
init|=
literal|0
block|,
DECL|enumerator|index_directory
name|index_directory
block|,
DECL|enumerator|index_gitdir
name|index_gitdir
block|, }
enum|;
end_enum
begin_comment
comment|/*  * The index sorts alphabetically by entry name, which  * means that a gitlink sorts as '\0' at the end, while  * a directory (which is defined not as an entry, but as  * the files it contains) will sort with the '/' at the  * end.  */
end_comment
begin_function
DECL|function|directory_exists_in_index
specifier|static
name|enum
name|exist_status
name|directory_exists_in_index
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|pos
init|=
name|cache_name_pos
argument_list|(
name|dirname
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
condition|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
operator|++
index|]
decl_stmt|;
name|unsigned
name|char
name|endchar
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|)
condition|)
break|break;
name|endchar
operator|=
name|ce
operator|->
name|name
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|endchar
operator|>
literal|'/'
condition|)
break|break;
if|if
condition|(
name|endchar
operator|==
literal|'/'
condition|)
return|return
name|index_directory
return|;
if|if
condition|(
operator|!
name|endchar
operator|&&
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
return|return
name|index_gitdir
return|;
block|}
return|return
name|index_nonexistent
return|;
block|}
end_function
begin_comment
comment|/*  * When we find a directory when traversing the filesystem, we  * have three distinct cases:  *  *  - ignore it  *  - see it as a directory  *  - recurse into it  *  * and which one we choose depends on a combination of existing  * git index contents and the flags passed into the directory  * traversal routine.  *  * Case 1: If we *already* have entries in the index under that  * directory name, we always recurse into the directory to see  * all the files.  *  * Case 2: If we *already* have that directory name as a gitlink,  * we always continue to see it as a gitlink, regardless of whether  * there is an actual git directory there or not (it might not  * be checked out as a subproject!)  *  * Case 3: if we didn't have it in the index previously, we  * have a few sub-cases:  *  *  (a) if "show_other_directories" is true, we show it as  *      just a directory, unless "hide_empty_directories" is  *      also true and the directory is empty, in which case  *      we just ignore it entirely.  *  (b) if it looks like a git directory, and we don't have  *      'no_gitlinks' set we treat it as a gitlink, and show it  *      as a directory.  *  (c) otherwise, we recurse into it.  */
end_comment
begin_enum
DECL|enum|directory_treatment
enum|enum
name|directory_treatment
block|{
DECL|enumerator|show_directory
name|show_directory
block|,
DECL|enumerator|ignore_directory
name|ignore_directory
block|,
DECL|enumerator|recurse_into_directory
name|recurse_into_directory
block|, }
enum|;
end_enum
begin_function
DECL|function|treat_directory
specifier|static
name|enum
name|directory_treatment
name|treat_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
comment|/* The "len-1" is to strip the final '/' */
switch|switch
condition|(
name|directory_exists_in_index
argument_list|(
name|dirname
argument_list|,
name|len
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
name|index_directory
case|:
return|return
name|recurse_into_directory
return|;
case|case
name|index_gitdir
case|:
if|if
condition|(
name|dir
operator|->
name|show_other_directories
condition|)
return|return
name|ignore_directory
return|;
return|return
name|show_directory
return|;
case|case
name|index_nonexistent
case|:
if|if
condition|(
name|dir
operator|->
name|show_other_directories
condition|)
break|break;
if|if
condition|(
operator|!
name|dir
operator|->
name|no_gitlinks
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|resolve_gitlink_ref
argument_list|(
name|dirname
argument_list|,
literal|"HEAD"
argument_list|,
name|sha1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|show_directory
return|;
block|}
return|return
name|recurse_into_directory
return|;
block|}
comment|/* This is the "show_other_directories" case */
if|if
condition|(
operator|!
name|dir
operator|->
name|hide_empty_directories
condition|)
return|return
name|show_directory
return|;
if|if
condition|(
operator|!
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|dirname
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|simplify
argument_list|)
condition|)
return|return
name|ignore_directory
return|;
return|return
name|show_directory
return|;
block|}
end_function
begin_comment
comment|/*  * This is an inexact early pruning of any recursive directory  * reading - if the path cannot possibly be in the pathspec,  * return true, and we'll skip it early.  */
end_comment
begin_function
DECL|function|simplify_away
specifier|static
name|int
name|simplify_away
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
if|if
condition|(
name|simplify
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|match
init|=
name|simplify
operator|->
name|path
decl_stmt|;
name|int
name|len
init|=
name|simplify
operator|->
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
if|if
condition|(
name|len
operator|>
name|pathlen
condition|)
name|len
operator|=
name|pathlen
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|match
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|simplify
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|in_pathspec
specifier|static
name|int
name|in_pathspec
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
if|if
condition|(
name|simplify
condition|)
block|{
for|for
control|(
init|;
name|simplify
operator|->
name|path
condition|;
name|simplify
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|==
name|simplify
operator|->
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|simplify
operator|->
name|path
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_dtype
specifier|static
name|int
name|get_dtype
parameter_list|(
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|dtype
init|=
name|de
condition|?
name|DTYPE
argument_list|(
name|de
argument_list|)
else|:
name|DT_UNKNOWN
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|DT_UNKNOWN
condition|)
return|return
name|dtype
return|;
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
name|dtype
return|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_REG
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_DIR
return|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_LNK
return|;
return|return
name|dtype
return|;
block|}
end_function
begin_comment
comment|/*  * Read a directory tree. We currently ignore anything but  * directories, regular files and symlinks. That's because git  * doesn't handle them at all yet. Maybe that will change some  * day.  *  * Also, we ignore the name ".git" (even if it is not a directory).  * That likely will not change.  */
end_comment
begin_function
DECL|function|read_directory_recursive
specifier|static
name|int
name|read_directory_recursive
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|int
name|check_only
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|DIR
modifier|*
name|fdir
init|=
name|opendir
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|contents
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fdir
condition|)
block|{
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|char
name|fullname
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|fullname
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|fdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|,
name|dtype
decl_stmt|;
name|int
name|exclude
decl_stmt|;
if|if
condition|(
operator|(
name|de
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|de
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|de
operator|->
name|d_name
operator|+
literal|1
argument_list|,
literal|"."
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|de
operator|->
name|d_name
operator|+
literal|1
argument_list|,
literal|"git"
argument_list|)
operator|)
condition|)
continue|continue;
name|len
operator|=
name|strlen
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* Ignore overly long pathnames! */
if|if
condition|(
name|len
operator|+
name|baselen
operator|+
literal|8
operator|>
sizeof|sizeof
argument_list|(
name|fullname
argument_list|)
condition|)
continue|continue;
name|memcpy
argument_list|(
name|fullname
operator|+
name|baselen
argument_list|,
name|de
operator|->
name|d_name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|simplify_away
argument_list|(
name|fullname
argument_list|,
name|baselen
operator|+
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
continue|continue;
name|dtype
operator|=
name|DTYPE
argument_list|(
name|de
argument_list|)
expr_stmt|;
name|exclude
operator|=
name|excluded
argument_list|(
name|dir
argument_list|,
name|fullname
argument_list|,
operator|&
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclude
operator|&&
name|dir
operator|->
name|collect_ignored
operator|&&
name|in_pathspec
argument_list|(
name|fullname
argument_list|,
name|baselen
operator|+
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
name|dir_add_ignored
argument_list|(
name|dir
argument_list|,
name|fullname
argument_list|,
name|baselen
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* 			 * Excluded? If we don't explicitly want to show 			 * ignored files, ignore it 			 */
if|if
condition|(
name|exclude
operator|&&
operator|!
name|dir
operator|->
name|show_ignored
condition|)
continue|continue;
if|if
condition|(
name|dtype
operator|==
name|DT_UNKNOWN
condition|)
name|dtype
operator|=
name|get_dtype
argument_list|(
name|de
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
comment|/* 			 * Do we want to see just the ignored files? 			 * We still need to recurse into directories, 			 * even if we don't ignore them, since the 			 * directory may contain files that we do.. 			 */
if|if
condition|(
operator|!
name|exclude
operator|&&
name|dir
operator|->
name|show_ignored
condition|)
block|{
if|if
condition|(
name|dtype
operator|!=
name|DT_DIR
condition|)
continue|continue;
block|}
switch|switch
condition|(
name|dtype
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_DIR
case|:
name|memcpy
argument_list|(
name|fullname
operator|+
name|baselen
operator|+
name|len
argument_list|,
literal|"/"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
switch|switch
condition|(
name|treat_directory
argument_list|(
name|dir
argument_list|,
name|fullname
argument_list|,
name|baselen
operator|+
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
block|{
case|case
name|show_directory
case|:
if|if
condition|(
name|exclude
operator|!=
name|dir
operator|->
name|show_ignored
condition|)
continue|continue;
break|break;
case|case
name|recurse_into_directory
case|:
name|contents
operator|+=
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|fullname
argument_list|,
name|fullname
argument_list|,
name|baselen
operator|+
name|len
argument_list|,
literal|0
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ignore_directory
case|:
continue|continue;
block|}
break|break;
case|case
name|DT_REG
case|:
case|case
name|DT_LNK
case|:
break|break;
block|}
name|contents
operator|++
expr_stmt|;
if|if
condition|(
name|check_only
condition|)
goto|goto
name|exit_early
goto|;
else|else
name|dir_add_name
argument_list|(
name|dir
argument_list|,
name|fullname
argument_list|,
name|baselen
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
name|exit_early
label|:
name|closedir
argument_list|(
name|fdir
argument_list|)
expr_stmt|;
block|}
return|return
name|contents
return|;
block|}
end_function
begin_function
DECL|function|cmp_name
specifier|static
name|int
name|cmp_name
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|dir_entry
modifier|*
name|e1
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dir_entry
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|dir_entry
modifier|*
name|e2
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dir_entry
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|cache_name_compare
argument_list|(
name|e1
operator|->
name|name
argument_list|,
name|e1
operator|->
name|len
argument_list|,
name|e2
operator|->
name|name
argument_list|,
name|e2
operator|->
name|len
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Return the length of the "simple" part of a path match limiter.  */
end_comment
begin_function
DECL|function|simple_length
specifier|static
name|int
name|simple_length
parameter_list|(
specifier|const
name|char
modifier|*
name|match
parameter_list|)
block|{
specifier|const
name|char
name|special
index|[
literal|256
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
literal|1
block|,
index|[
literal|'?'
index|]
operator|=
literal|1
block|,
index|[
literal|'\\'
index|]
operator|=
literal|1
block|,
index|[
literal|'*'
index|]
operator|=
literal|1
block|,
index|[
literal|'['
index|]
operator|=
literal|1
block|}
decl_stmt|;
name|int
name|len
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|match
operator|++
decl_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|special
index|[
name|c
index|]
condition|)
return|return
name|len
return|;
block|}
block|}
end_function
begin_function
DECL|function|create_simplify
specifier|static
name|struct
name|path_simplify
modifier|*
name|create_simplify
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|int
name|nr
decl_stmt|,
name|alloc
init|=
literal|0
decl_stmt|;
name|struct
name|path_simplify
modifier|*
name|simplify
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pathspec
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
condition|;
name|nr
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
if|if
condition|(
name|nr
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|=
name|alloc_nr
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|simplify
operator|=
name|xrealloc
argument_list|(
name|simplify
argument_list|,
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|simplify
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|match
operator|=
operator|*
name|pathspec
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
name|simplify
index|[
name|nr
index|]
operator|.
name|path
operator|=
name|match
expr_stmt|;
name|simplify
index|[
name|nr
index|]
operator|.
name|len
operator|=
name|simple_length
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
name|simplify
index|[
name|nr
index|]
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
name|simplify
index|[
name|nr
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|simplify
return|;
block|}
end_function
begin_function
DECL|function|free_simplify
specifier|static
name|void
name|free_simplify
parameter_list|(
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|free
argument_list|(
name|simplify
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_directory
name|int
name|read_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|struct
name|path_simplify
modifier|*
name|simplify
init|=
name|create_simplify
argument_list|(
name|pathspec
argument_list|)
decl_stmt|;
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|,
literal|0
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
name|free_simplify
argument_list|(
name|simplify
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|dir
operator|->
name|entries
argument_list|,
name|dir
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir_entry
operator|*
argument_list|)
argument_list|,
name|cmp_name
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|dir
operator|->
name|ignored
argument_list|,
name|dir
operator|->
name|ignored_nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir_entry
operator|*
argument_list|)
argument_list|,
name|cmp_name
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|nr
return|;
block|}
end_function
begin_function
DECL|function|file_exists
name|int
name|file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
return|return
name|lstat
argument_list|(
name|f
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * get_relative_cwd() gets the prefix of the current working directory  * relative to 'dir'.  If we are not inside 'dir', it returns NULL.  *  * As a convenience, it also returns NULL if 'dir' is already NULL.  The  * reason for this behaviour is that it is natural for functions returning  * directory names to return NULL to say "this directory does not exist"  * or "this directory is invalid".  These cases are usually handled the  * same as if the cwd is not inside 'dir' at all, so get_relative_cwd()  * returns NULL for both of them.  *  * Most notably, get_relative_cwd(buffer, size, get_git_work_tree())  * unifies the handling of "outside work tree" with "no work tree at all".  */
end_comment
begin_function
DECL|function|get_relative_cwd
name|char
modifier|*
name|get_relative_cwd
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|cwd
init|=
name|buffer
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|)
condition|)
name|die
argument_list|(
literal|"can't find the current directory: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_absolute_path
argument_list|(
name|dir
argument_list|)
condition|)
name|dir
operator|=
name|make_absolute_path
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|dir
operator|&&
operator|*
name|dir
operator|==
operator|*
name|cwd
condition|)
block|{
name|dir
operator|++
expr_stmt|;
name|cwd
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|dir
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|cwd
operator|==
literal|'/'
condition|)
return|return
name|cwd
operator|+
literal|1
return|;
return|return
name|cwd
return|;
block|}
end_function
begin_function
DECL|function|is_inside_dir
name|int
name|is_inside_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|char
name|buffer
index|[
name|PATH_MAX
index|]
decl_stmt|;
return|return
name|get_relative_cwd
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|dir
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|remove_dir_recursively
name|int
name|remove_dir_recursively
parameter_list|(
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|only_empty
parameter_list|)
block|{
name|DIR
modifier|*
name|dir
init|=
name|opendir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
decl_stmt|;
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|original_len
init|=
name|path
operator|->
name|len
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|path
operator|->
name|buf
index|[
name|original_len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strbuf_addch
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|len
operator|=
name|path
operator|->
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|e
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|e
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|e
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
continue|continue;
comment|/* "." and ".." */
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|path
argument_list|,
name|e
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|path
operator|->
name|buf
argument_list|,
operator|&
name|st
argument_list|)
condition|)
empty_stmt|;
comment|/* fall thru */
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|remove_dir_recursively
argument_list|(
name|path
argument_list|,
name|only_empty
argument_list|)
condition|)
continue|continue;
comment|/* happy */
block|}
elseif|else
if|if
condition|(
operator|!
name|only_empty
operator|&&
operator|!
name|unlink
argument_list|(
name|path
operator|->
name|buf
argument_list|)
condition|)
continue|continue;
comment|/* happy, too */
comment|/* path too long, stat fails, or non-directory still exists */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|original_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|rmdir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|setup_standard_excludes
name|void
name|setup_standard_excludes
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|dir
operator|->
name|exclude_per_dir
operator|=
literal|".gitignore"
expr_stmt|;
name|path
operator|=
name|git_path
argument_list|(
literal|"info/exclude"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|path
argument_list|,
name|R_OK
argument_list|)
condition|)
name|add_excludes_from_file
argument_list|(
name|dir
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|excludes_file
operator|&&
operator|!
name|access
argument_list|(
name|excludes_file
argument_list|,
name|R_OK
argument_list|)
condition|)
name|add_excludes_from_file
argument_list|(
name|dir
argument_list|,
name|excludes_file
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
