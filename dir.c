begin_unit
begin_comment
comment|/*  * This handles recursive filename detection with exclude  * files, index knowledge etc..  *  * See Documentation/technical/api-directory-listing.txt  *  * Copyright (C) Linus Torvalds, 2005-2006  *		 Junio Hamano, 2005-2006  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"wildmatch.h"
end_include
begin_include
include|#
directive|include
file|"pathspec.h"
end_include
begin_struct
DECL|struct|path_simplify
struct|struct
name|path_simplify
block|{
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Tells read_directory_recursive how a file or directory should be treated.  * Values are ordered by significance, e.g. if a directory contains both  * excluded and untracked files, it is listed as untracked because  * path_untracked> path_excluded.  */
end_comment
begin_enum
DECL|enum|path_treatment
enum|enum
name|path_treatment
block|{
DECL|enumerator|path_none
name|path_none
init|=
literal|0
block|,
DECL|enumerator|path_recurse
name|path_recurse
block|,
DECL|enumerator|path_excluded
name|path_excluded
block|,
DECL|enumerator|path_untracked
name|path_untracked
block|}
enum|;
end_enum
begin_function_decl
specifier|static
name|enum
name|path_treatment
name|read_directory_recursive
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|untracked_cache_dir
modifier|*
name|untracked
parameter_list|,
name|int
name|check_only
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|get_dtype
parameter_list|(
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* helper string functions with support for the ignore_case flag */
end_comment
begin_function
DECL|function|strcmp_icase
name|int
name|strcmp_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
return|return
name|ignore_case
condition|?
name|strcasecmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
else|:
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|strncmp_icase
name|int
name|strncmp_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
return|return
name|ignore_case
condition|?
name|strncasecmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|count
argument_list|)
else|:
name|strncmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fnmatch_icase
name|int
name|fnmatch_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|wildmatch
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|flags
operator||
operator|(
name|ignore_case
condition|?
name|WM_CASEFOLD
else|:
literal|0
operator|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_fnmatch
name|int
name|git_fnmatch
parameter_list|(
specifier|const
name|struct
name|pathspec_item
modifier|*
name|item
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ps_strncmp
argument_list|(
name|item
argument_list|,
name|pattern
argument_list|,
name|string
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
name|WM_NOMATCH
return|;
name|pattern
operator|+=
name|prefix
expr_stmt|;
name|string
operator|+=
name|prefix
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|->
name|flags
operator|&
name|PATHSPEC_ONESTAR
condition|)
block|{
name|int
name|pattern_len
init|=
name|strlen
argument_list|(
operator|++
name|pattern
argument_list|)
decl_stmt|;
name|int
name|string_len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
return|return
name|string_len
operator|<
name|pattern_len
operator|||
name|ps_strcmp
argument_list|(
name|item
argument_list|,
name|pattern
argument_list|,
name|string
operator|+
name|string_len
operator|-
name|pattern_len
argument_list|)
return|;
block|}
if|if
condition|(
name|item
operator|->
name|magic
operator|&
name|PATHSPEC_GLOB
condition|)
return|return
name|wildmatch
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|WM_PATHNAME
operator||
operator|(
name|item
operator|->
name|magic
operator|&
name|PATHSPEC_ICASE
condition|?
name|WM_CASEFOLD
else|:
literal|0
operator|)
argument_list|,
name|NULL
argument_list|)
return|;
else|else
comment|/* wildmatch has not learned no FNM_PATHNAME mode yet */
return|return
name|wildmatch
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|item
operator|->
name|magic
operator|&
name|PATHSPEC_ICASE
condition|?
name|WM_CASEFOLD
else|:
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fnmatch_icase_mem
specifier|static
name|int
name|fnmatch_icase_mem
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|patternlen
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|stringlen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|match_status
decl_stmt|;
name|struct
name|strbuf
name|pat_buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|struct
name|strbuf
name|str_buf
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|use_pat
init|=
name|pattern
decl_stmt|;
specifier|const
name|char
modifier|*
name|use_str
init|=
name|string
decl_stmt|;
if|if
condition|(
name|pattern
index|[
name|patternlen
index|]
condition|)
block|{
name|strbuf_add
argument_list|(
operator|&
name|pat_buf
argument_list|,
name|pattern
argument_list|,
name|patternlen
argument_list|)
expr_stmt|;
name|use_pat
operator|=
name|pat_buf
operator|.
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|string
index|[
name|stringlen
index|]
condition|)
block|{
name|strbuf_add
argument_list|(
operator|&
name|str_buf
argument_list|,
name|string
argument_list|,
name|stringlen
argument_list|)
expr_stmt|;
name|use_str
operator|=
name|str_buf
operator|.
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|ignore_case
condition|)
name|flags
operator||=
name|WM_CASEFOLD
expr_stmt|;
name|match_status
operator|=
name|wildmatch
argument_list|(
name|use_pat
argument_list|,
name|use_str
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|pat_buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|str_buf
argument_list|)
expr_stmt|;
return|return
name|match_status
return|;
block|}
end_function
begin_function
DECL|function|common_prefix_len
specifier|static
name|size_t
name|common_prefix_len
parameter_list|(
specifier|const
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|size_t
name|max
init|=
literal|0
decl_stmt|;
comment|/* 	 * ":(icase)path" is treated as a pathspec full of 	 * wildcard. In other words, only prefix is considered common 	 * prefix. If the pathspec is abc/foo abc/bar, running in 	 * subdir xyz, the common prefix is still xyz, not xuz/abc as 	 * in non-:(icase). 	 */
name|GUARD_PATHSPEC
argument_list|(
name|pathspec
argument_list|,
name|PATHSPEC_FROMTOP
operator||
name|PATHSPEC_MAXDEPTH
operator||
name|PATHSPEC_LITERAL
operator||
name|PATHSPEC_GLOB
operator||
name|PATHSPEC_ICASE
operator||
name|PATHSPEC_EXCLUDE
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|pathspec
operator|->
name|nr
condition|;
name|n
operator|++
control|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|item_len
decl_stmt|;
if|if
condition|(
name|pathspec
operator|->
name|items
index|[
name|n
index|]
operator|.
name|magic
operator|&
name|PATHSPEC_EXCLUDE
condition|)
continue|continue;
if|if
condition|(
name|pathspec
operator|->
name|items
index|[
name|n
index|]
operator|.
name|magic
operator|&
name|PATHSPEC_ICASE
condition|)
name|item_len
operator|=
name|pathspec
operator|->
name|items
index|[
name|n
index|]
operator|.
name|prefix
expr_stmt|;
else|else
name|item_len
operator|=
name|pathspec
operator|->
name|items
index|[
name|n
index|]
operator|.
name|nowildcard_len
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|item_len
operator|&&
operator|(
name|n
operator|==
literal|0
operator|||
name|i
operator|<
name|max
operator|)
condition|)
block|{
name|char
name|c
init|=
name|pathspec
operator|->
name|items
index|[
name|n
index|]
operator|.
name|match
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|pathspec
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|match
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|len
operator|<
name|max
condition|)
block|{
name|max
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|max
condition|)
break|break;
block|}
block|}
return|return
name|max
return|;
block|}
end_function
begin_comment
comment|/*  * Returns a copy of the longest leading path common among all  * pathspecs.  */
end_comment
begin_function
DECL|function|common_prefix
name|char
modifier|*
name|common_prefix
parameter_list|(
specifier|const
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|)
block|{
name|unsigned
name|long
name|len
init|=
name|common_prefix_len
argument_list|(
name|pathspec
argument_list|)
decl_stmt|;
return|return
name|len
condition|?
name|xmemdupz
argument_list|(
name|pathspec
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|match
argument_list|,
name|len
argument_list|)
else|:
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|fill_directory
name|int
name|fill_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
comment|/* 	 * Calculate common prefix for the pathspec, and 	 * use that to optimize the directory walk 	 */
name|len
operator|=
name|common_prefix_len
argument_list|(
name|pathspec
argument_list|)
expr_stmt|;
comment|/* Read the directory and prune it */
name|read_directory
argument_list|(
name|dir
argument_list|,
name|pathspec
operator|->
name|nr
condition|?
name|pathspec
operator|->
name|_raw
index|[
literal|0
index|]
else|:
literal|""
argument_list|,
name|len
argument_list|,
name|pathspec
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|within_depth
name|int
name|within_depth
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|max_depth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
name|name
decl_stmt|,
modifier|*
name|cpe
init|=
name|name
operator|+
name|namelen
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpe
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'/'
condition|)
continue|continue;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|max_depth
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_define
DECL|macro|DO_MATCH_EXCLUDE
define|#
directive|define
name|DO_MATCH_EXCLUDE
value|1
end_define
begin_define
DECL|macro|DO_MATCH_DIRECTORY
define|#
directive|define
name|DO_MATCH_DIRECTORY
value|2
end_define
begin_comment
comment|/*  * Does 'match' match the given name?  * A match is found if  *  * (1) the 'match' string is leading directory of 'name', or  * (2) the 'match' string is a wildcard and matches 'name', or  * (3) the 'match' string is exactly the same as 'name'.  *  * and the return value tells which case it was.  *  * It returns 0 when there is no match.  */
end_comment
begin_function
DECL|function|match_pathspec_item
specifier|static
name|int
name|match_pathspec_item
parameter_list|(
specifier|const
name|struct
name|pathspec_item
modifier|*
name|item
parameter_list|,
name|int
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
comment|/* name/namelen has prefix cut off by caller */
specifier|const
name|char
modifier|*
name|match
init|=
name|item
operator|->
name|match
operator|+
name|prefix
decl_stmt|;
name|int
name|matchlen
init|=
name|item
operator|->
name|len
operator|-
name|prefix
decl_stmt|;
comment|/* 	 * The normal call pattern is: 	 * 1. prefix = common_prefix_len(ps); 	 * 2. prune something, or fill_directory 	 * 3. match_pathspec() 	 * 	 * 'prefix' at #1 may be shorter than the command's prefix and 	 * it's ok for #2 to match extra files. Those extras will be 	 * trimmed at #3. 	 * 	 * Suppose the pathspec is 'foo' and '../bar' running from 	 * subdir 'xyz'. The common prefix at #1 will be empty, thanks 	 * to "../". We may have xyz/foo _and_ XYZ/foo after #2. The 	 * user does not want XYZ/foo, only the "foo" part should be 	 * case-insensitive. We need to filter out XYZ/foo here. In 	 * other words, we do not trust the caller on comparing the 	 * prefix part when :(icase) is involved. We do exact 	 * comparison ourselves. 	 * 	 * Normally the caller (common_prefix_len() in fact) does 	 * _exact_ matching on name[-prefix+1..-1] and we do not need 	 * to check that part. Be defensive and check it anyway, in 	 * case common_prefix_len is changed, or a new caller is 	 * introduced that does not use common_prefix_len. 	 * 	 * If the penalty turns out too high when prefix is really 	 * long, maybe change it to 	 * strncmp(match, name, item->prefix - prefix) 	 */
if|if
condition|(
name|item
operator|->
name|prefix
operator|&&
operator|(
name|item
operator|->
name|magic
operator|&
name|PATHSPEC_ICASE
operator|)
operator|&&
name|strncmp
argument_list|(
name|item
operator|->
name|match
argument_list|,
name|name
operator|-
name|prefix
argument_list|,
name|item
operator|->
name|prefix
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the match was just the prefix, we matched */
if|if
condition|(
operator|!
operator|*
name|match
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
if|if
condition|(
name|matchlen
operator|<=
name|namelen
operator|&&
operator|!
name|ps_strncmp
argument_list|(
name|item
argument_list|,
name|match
argument_list|,
name|name
argument_list|,
name|matchlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|matchlen
operator|==
name|namelen
condition|)
return|return
name|MATCHED_EXACTLY
return|;
if|if
condition|(
name|match
index|[
name|matchlen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
name|matchlen
index|]
operator|==
literal|'/'
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|DO_MATCH_DIRECTORY
operator|)
operator|&&
name|match
index|[
name|matchlen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|namelen
operator|==
name|matchlen
operator|-
literal|1
operator|&&
operator|!
name|ps_strncmp
argument_list|(
name|item
argument_list|,
name|match
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
condition|)
return|return
name|MATCHED_EXACTLY
return|;
if|if
condition|(
name|item
operator|->
name|nowildcard_len
operator|<
name|item
operator|->
name|len
operator|&&
operator|!
name|git_fnmatch
argument_list|(
name|item
argument_list|,
name|match
argument_list|,
name|name
argument_list|,
name|item
operator|->
name|nowildcard_len
operator|-
name|prefix
argument_list|)
condition|)
return|return
name|MATCHED_FNMATCH
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given a name and a list of pathspecs, returns the nature of the  * closest (i.e. most specific) match of the name to any of the  * pathspecs.  *  * The caller typically calls this multiple times with the same  * pathspec and seen[] array but with different name/namelen  * (e.g. entries from the index) and is interested in seeing if and  * how each pathspec matches all the names it calls this function  * with.  A mark is left in the seen[] array for each pathspec element  * indicating the closest type of match that element achieved, so if  * seen[n] remains zero after multiple invocations, that means the nth  * pathspec did not match any names, which could indicate that the  * user mistyped the nth pathspec.  */
end_comment
begin_function
DECL|function|do_match_pathspec
specifier|static
name|int
name|do_match_pathspec
parameter_list|(
specifier|const
name|struct
name|pathspec
modifier|*
name|ps
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|prefix
parameter_list|,
name|char
modifier|*
name|seen
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|,
name|exclude
init|=
name|flags
operator|&
name|DO_MATCH_EXCLUDE
decl_stmt|;
name|GUARD_PATHSPEC
argument_list|(
name|ps
argument_list|,
name|PATHSPEC_FROMTOP
operator||
name|PATHSPEC_MAXDEPTH
operator||
name|PATHSPEC_LITERAL
operator||
name|PATHSPEC_GLOB
operator||
name|PATHSPEC_ICASE
operator||
name|PATHSPEC_EXCLUDE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|->
name|nr
condition|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|recursive
operator|||
operator|!
operator|(
name|ps
operator|->
name|magic
operator|&
name|PATHSPEC_MAXDEPTH
operator|)
operator|||
name|ps
operator|->
name|max_depth
operator|==
operator|-
literal|1
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
if|if
condition|(
name|within_depth
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
literal|0
argument_list|,
name|ps
operator|->
name|max_depth
argument_list|)
condition|)
return|return
name|MATCHED_EXACTLY
return|;
else|else
return|return
literal|0
return|;
block|}
name|name
operator|+=
name|prefix
expr_stmt|;
name|namelen
operator|-=
name|prefix
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ps
operator|->
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|how
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|exclude
operator|&&
name|ps
operator|->
name|items
index|[
name|i
index|]
operator|.
name|magic
operator|&
name|PATHSPEC_EXCLUDE
operator|)
operator|||
operator|(
name|exclude
operator|&&
operator|!
operator|(
name|ps
operator|->
name|items
index|[
name|i
index|]
operator|.
name|magic
operator|&
name|PATHSPEC_EXCLUDE
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|seen
operator|&&
name|seen
index|[
name|i
index|]
operator|==
name|MATCHED_EXACTLY
condition|)
continue|continue;
comment|/* 		 * Make exclude patterns optional and never report 		 * "pathspec ':(exclude)foo' matches no files" 		 */
if|if
condition|(
name|seen
operator|&&
name|ps
operator|->
name|items
index|[
name|i
index|]
operator|.
name|magic
operator|&
name|PATHSPEC_EXCLUDE
condition|)
name|seen
index|[
name|i
index|]
operator|=
name|MATCHED_FNMATCH
expr_stmt|;
name|how
operator|=
name|match_pathspec_item
argument_list|(
name|ps
operator|->
name|items
operator|+
name|i
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|recursive
operator|&&
operator|(
name|ps
operator|->
name|magic
operator|&
name|PATHSPEC_MAXDEPTH
operator|)
operator|&&
name|ps
operator|->
name|max_depth
operator|!=
operator|-
literal|1
operator|&&
name|how
operator|&&
name|how
operator|!=
name|MATCHED_FNMATCH
condition|)
block|{
name|int
name|len
init|=
name|ps
operator|->
name|items
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|name
index|[
name|len
index|]
operator|==
literal|'/'
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|within_depth
argument_list|(
name|name
operator|+
name|len
argument_list|,
name|namelen
operator|-
name|len
argument_list|,
literal|0
argument_list|,
name|ps
operator|->
name|max_depth
argument_list|)
condition|)
name|how
operator|=
name|MATCHED_EXACTLY
expr_stmt|;
else|else
name|how
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|how
condition|)
block|{
if|if
condition|(
name|retval
operator|<
name|how
condition|)
name|retval
operator|=
name|how
expr_stmt|;
if|if
condition|(
name|seen
operator|&&
name|seen
index|[
name|i
index|]
operator|<
name|how
condition|)
name|seen
index|[
name|i
index|]
operator|=
name|how
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function
begin_function
DECL|function|match_pathspec
name|int
name|match_pathspec
parameter_list|(
specifier|const
name|struct
name|pathspec
modifier|*
name|ps
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|prefix
parameter_list|,
name|char
modifier|*
name|seen
parameter_list|,
name|int
name|is_dir
parameter_list|)
block|{
name|int
name|positive
decl_stmt|,
name|negative
decl_stmt|;
name|unsigned
name|flags
init|=
name|is_dir
condition|?
name|DO_MATCH_DIRECTORY
else|:
literal|0
decl_stmt|;
name|positive
operator|=
name|do_match_pathspec
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|prefix
argument_list|,
name|seen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ps
operator|->
name|magic
operator|&
name|PATHSPEC_EXCLUDE
operator|)
operator|||
operator|!
name|positive
condition|)
return|return
name|positive
return|;
name|negative
operator|=
name|do_match_pathspec
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|prefix
argument_list|,
name|seen
argument_list|,
name|flags
operator||
name|DO_MATCH_EXCLUDE
argument_list|)
expr_stmt|;
return|return
name|negative
condition|?
literal|0
else|:
name|positive
return|;
block|}
end_function
begin_comment
comment|/*  * Return the length of the "simple" part of a path match limiter.  */
end_comment
begin_function
DECL|function|simple_length
name|int
name|simple_length
parameter_list|(
specifier|const
name|char
modifier|*
name|match
parameter_list|)
block|{
name|int
name|len
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|match
operator|++
decl_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|is_glob_special
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|len
return|;
block|}
block|}
end_function
begin_function
DECL|function|no_wildcard
name|int
name|no_wildcard
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|string
index|[
name|simple_length
argument_list|(
name|string
argument_list|)
index|]
operator|==
literal|'\0'
return|;
block|}
end_function
begin_function
DECL|function|parse_exclude_pattern
name|void
name|parse_exclude_pattern
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|,
name|int
modifier|*
name|patternlen
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|,
name|int
modifier|*
name|nowildcardlen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pattern
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
operator|*
name|flags
operator||=
name|EXC_FLAG_NEGATIVE
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|len
operator|--
expr_stmt|;
operator|*
name|flags
operator||=
name|EXC_FLAG_MUSTBEDIR
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
condition|)
operator|*
name|flags
operator||=
name|EXC_FLAG_NODIR
expr_stmt|;
operator|*
name|nowildcardlen
operator|=
name|simple_length
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * we should have excluded the trailing slash from 'p' too, 	 * but that's one more allocation. Instead just make sure 	 * nowildcardlen does not exceed real patternlen 	 */
if|if
condition|(
operator|*
name|nowildcardlen
operator|>
name|len
condition|)
operator|*
name|nowildcardlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|&&
name|no_wildcard
argument_list|(
name|p
operator|+
literal|1
argument_list|)
condition|)
operator|*
name|flags
operator||=
name|EXC_FLAG_ENDSWITH
expr_stmt|;
operator|*
name|pattern
operator|=
name|p
expr_stmt|;
operator|*
name|patternlen
operator|=
name|len
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_exclude
name|void
name|add_exclude
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|,
name|int
name|srcpos
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|x
decl_stmt|;
name|int
name|patternlen
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|nowildcardlen
decl_stmt|;
name|parse_exclude_pattern
argument_list|(
operator|&
name|string
argument_list|,
operator|&
name|patternlen
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|nowildcardlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EXC_FLAG_MUSTBEDIR
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
operator|+
name|patternlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|x
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|string
argument_list|,
name|patternlen
argument_list|)
expr_stmt|;
name|s
index|[
name|patternlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|x
operator|->
name|pattern
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|pattern
operator|=
name|string
expr_stmt|;
block|}
name|x
operator|->
name|patternlen
operator|=
name|patternlen
expr_stmt|;
name|x
operator|->
name|nowildcardlen
operator|=
name|nowildcardlen
expr_stmt|;
name|x
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|x
operator|->
name|baselen
operator|=
name|baselen
expr_stmt|;
name|x
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|x
operator|->
name|srcpos
operator|=
name|srcpos
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|el
operator|->
name|excludes
argument_list|,
name|el
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|el
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|el
operator|->
name|excludes
index|[
name|el
operator|->
name|nr
operator|++
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|el
operator|=
name|el
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_skip_worktree_file_from_index
specifier|static
name|void
modifier|*
name|read_skip_worktree_file_from_index
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|struct
name|sha1_stat
modifier|*
name|sha1_stat
parameter_list|)
block|{
name|int
name|pos
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|ce_skip_worktree
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
name|data
operator|=
name|read_sha1_file
argument_list|(
name|active_cache
index|[
name|pos
index|]
operator|->
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
name|type
operator|!=
name|OBJ_BLOB
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|size
operator|=
name|xsize_t
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_stat
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sha1_stat
operator|->
name|stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1_stat
operator|->
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1_stat
operator|->
name|sha1
argument_list|,
name|active_cache
index|[
name|pos
index|]
operator|->
name|sha1
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*  * Frees memory within el which was allocated for exclude patterns and  * the file buffer.  Does not free el itself.  */
end_comment
begin_function
DECL|function|clear_exclude_list
name|void
name|clear_exclude_list
parameter_list|(
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|nr
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|el
operator|->
name|excludes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|el
operator|->
name|excludes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|el
operator|->
name|filebuf
argument_list|)
expr_stmt|;
name|el
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|excludes
operator|=
name|NULL
expr_stmt|;
name|el
operator|->
name|filebuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|trim_trailing_spaces
specifier|static
name|void
name|trim_trailing_spaces
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|last_space
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|' '
case|:
if|if
condition|(
operator|!
name|last_space
condition|)
name|last_space
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return;
comment|/* fallthrough */
default|default:
name|last_space
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|last_space
condition|)
operator|*
name|last_space
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Given a subdirectory name and "dir" of the current directory,  * search the subdir in "dir" and return it, or create a new one if it  * does not exist in "dir".  *  * If "name" has the trailing slash, it'll be excluded in the search.  */
end_comment
begin_function
DECL|function|lookup_untracked
specifier|static
name|struct
name|untracked_cache_dir
modifier|*
name|lookup_untracked
parameter_list|(
name|struct
name|untracked_cache
modifier|*
name|uc
parameter_list|,
name|struct
name|untracked_cache_dir
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|struct
name|untracked_cache_dir
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|len
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|len
operator|--
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|dir
operator|->
name|dirs_nr
expr_stmt|;
while|while
condition|(
name|last
operator|>
name|first
condition|)
block|{
name|int
name|cmp
decl_stmt|,
name|next
init|=
operator|(
name|last
operator|+
name|first
operator|)
operator|>>
literal|1
decl_stmt|;
name|d
operator|=
name|dir
operator|->
name|dirs
index|[
name|next
index|]
expr_stmt|;
name|cmp
operator|=
name|strncmp
argument_list|(
name|name
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
operator|&&
name|strlen
argument_list|(
name|d
operator|->
name|name
argument_list|)
operator|>
name|len
condition|)
name|cmp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
condition|)
return|return
name|d
return|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|last
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
name|first
operator|=
name|next
operator|+
literal|1
expr_stmt|;
block|}
name|uc
operator|->
name|dir_created
operator|++
expr_stmt|;
name|d
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|dirs
argument_list|,
name|dir
operator|->
name|dirs_nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|dirs_alloc
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|dir
operator|->
name|dirs
operator|+
name|first
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|dirs
operator|+
name|first
argument_list|,
operator|(
name|dir
operator|->
name|dirs_nr
operator|-
name|first
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dir
operator|->
name|dirs
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|dirs_nr
operator|++
expr_stmt|;
name|dir
operator|->
name|dirs
index|[
name|first
index|]
operator|=
name|d
expr_stmt|;
return|return
name|d
return|;
block|}
end_function
begin_function
DECL|function|do_invalidate_gitignore
specifier|static
name|void
name|do_invalidate_gitignore
parameter_list|(
name|struct
name|untracked_cache_dir
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dir
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|untracked_nr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir
operator|->
name|dirs_nr
condition|;
name|i
operator|++
control|)
name|do_invalidate_gitignore
argument_list|(
name|dir
operator|->
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|invalidate_gitignore
specifier|static
name|void
name|invalidate_gitignore
parameter_list|(
name|struct
name|untracked_cache
modifier|*
name|uc
parameter_list|,
name|struct
name|untracked_cache_dir
modifier|*
name|dir
parameter_list|)
block|{
name|uc
operator|->
name|gitignore_invalidated
operator|++
expr_stmt|;
name|do_invalidate_gitignore
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Given a file with name "fname", read it (either from disk, or from  * the index if "check_index" is non-zero), parse it and store the  * exclude rules in "el".  *  * If "ss" is not NULL, compute SHA-1 of the exclude file and fill  * stat data from disk (only valid if add_excludes returns zero). If  * ss_valid is non-zero, "ss" must contain good value as input.  */
end_comment
begin_function
DECL|function|add_excludes
specifier|static
name|int
name|add_excludes
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|,
name|int
name|check_index
parameter_list|,
name|struct
name|sha1_stat
modifier|*
name|sha1_stat
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|lineno
init|=
literal|1
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|warn_on_inaccessible
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_index
operator|||
operator|(
name|buf
operator|=
name|read_skip_worktree_file_from_index
argument_list|(
name|fname
argument_list|,
operator|&
name|size
argument_list|,
name|sha1_stat
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|buf
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|size
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
else|else
block|{
name|size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sha1_stat
condition|)
block|{
name|fill_stat_data
argument_list|(
operator|&
name|sha1_stat
operator|->
name|stat
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|hashcpy
argument_list|(
name|sha1_stat
operator|->
name|sha1
argument_list|,
name|EMPTY_BLOB_SHA1_BIN
argument_list|)
expr_stmt|;
name|sha1_stat
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|buf
index|[
name|size
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sha1_stat
condition|)
block|{
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|sha1_stat
operator|->
name|valid
operator|&&
operator|!
name|match_stat_data
argument_list|(
operator|&
name|sha1_stat
operator|->
name|stat
argument_list|,
operator|&
name|st
argument_list|)
condition|)
empty_stmt|;
comment|/* no content change, ss->sha1 still good */
elseif|else
if|if
condition|(
name|check_index
operator|&&
operator|(
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|!
name|ce_stage
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
operator|&&
name|ce_uptodate
argument_list|(
name|active_cache
index|[
name|pos
index|]
argument_list|)
operator|&&
operator|!
name|would_convert_to_git
argument_list|(
name|fname
argument_list|)
condition|)
name|hashcpy
argument_list|(
name|sha1_stat
operator|->
name|sha1
argument_list|,
name|active_cache
index|[
name|pos
index|]
operator|->
name|sha1
argument_list|)
expr_stmt|;
else|else
name|hash_sha1_file
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|"blob"
argument_list|,
name|sha1_stat
operator|->
name|sha1
argument_list|)
expr_stmt|;
name|fill_stat_data
argument_list|(
operator|&
name|sha1_stat
operator|->
name|stat
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|sha1_stat
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|el
operator|->
name|filebuf
operator|=
name|buf
expr_stmt|;
name|entry
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|entry
operator|!=
name|buf
operator|+
name|i
operator|&&
name|entry
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|buf
index|[
name|i
operator|-
operator|(
name|i
operator|&&
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|trim_trailing_spaces
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|add_exclude
argument_list|(
name|entry
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|,
name|el
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|lineno
operator|++
expr_stmt|;
name|entry
operator|=
name|buf
operator|+
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|add_excludes_from_file_to_list
name|int
name|add_excludes_from_file_to_list
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|,
name|int
name|check_index
parameter_list|)
block|{
return|return
name|add_excludes
argument_list|(
name|fname
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|,
name|el
argument_list|,
name|check_index
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|add_exclude_list
name|struct
name|exclude_list
modifier|*
name|add_exclude_list
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|int
name|group_type
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|group_type
index|]
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|group
operator|->
name|el
argument_list|,
name|group
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|group
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|el
operator|=
operator|&
name|group
operator|->
name|el
index|[
name|group
operator|->
name|nr
operator|++
index|]
expr_stmt|;
name|memset
argument_list|(
name|el
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|el
argument_list|)
argument_list|)
expr_stmt|;
name|el
operator|->
name|src
operator|=
name|src
expr_stmt|;
return|return
name|el
return|;
block|}
end_function
begin_comment
comment|/*  * Used to set up core.excludesfile and .git/info/exclude lists.  */
end_comment
begin_function
DECL|function|add_excludes_from_file_1
specifier|static
name|void
name|add_excludes_from_file_1
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|sha1_stat
modifier|*
name|sha1_stat
parameter_list|)
block|{
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
comment|/* 	 * catch setup_standard_excludes() that's called before 	 * dir->untracked is assigned. That function behaves 	 * differently when dir->untracked is non-NULL. 	 */
if|if
condition|(
operator|!
name|dir
operator|->
name|untracked
condition|)
name|dir
operator|->
name|unmanaged_exclude_files
operator|++
expr_stmt|;
name|el
operator|=
name|add_exclude_list
argument_list|(
name|dir
argument_list|,
name|EXC_FILE
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_excludes
argument_list|(
name|fname
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|el
argument_list|,
literal|0
argument_list|,
name|sha1_stat
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"cannot use %s as an exclude file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_excludes_from_file
name|void
name|add_excludes_from_file
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|dir
operator|->
name|unmanaged_exclude_files
operator|++
expr_stmt|;
comment|/* see validate_untracked_cache() */
name|add_excludes_from_file_1
argument_list|(
name|dir
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|match_basename
name|int
name|match_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
name|basenamelen
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|prefix
parameter_list|,
name|int
name|patternlen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|==
name|patternlen
condition|)
block|{
if|if
condition|(
name|patternlen
operator|==
name|basenamelen
operator|&&
operator|!
name|strncmp_icase
argument_list|(
name|pattern
argument_list|,
name|basename
argument_list|,
name|basenamelen
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EXC_FLAG_ENDSWITH
condition|)
block|{
comment|/* "*literal" matching against "fooliteral" */
if|if
condition|(
name|patternlen
operator|-
literal|1
operator|<=
name|basenamelen
operator|&&
operator|!
name|strncmp_icase
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
name|basename
operator|+
name|basenamelen
operator|-
operator|(
name|patternlen
operator|-
literal|1
operator|)
argument_list|,
name|patternlen
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|fnmatch_icase_mem
argument_list|(
name|pattern
argument_list|,
name|patternlen
argument_list|,
name|basename
argument_list|,
name|basenamelen
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|match_pathname
name|int
name|match_pathname
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|prefix
parameter_list|,
name|int
name|patternlen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
comment|/* 	 * match with FNM_PATHNAME; the pattern has base implicitly 	 * in front of it. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'/'
condition|)
block|{
name|pattern
operator|++
expr_stmt|;
name|patternlen
operator|--
expr_stmt|;
name|prefix
operator|--
expr_stmt|;
block|}
comment|/* 	 * baselen does not count the trailing slash. base[] may or 	 * may not end with a trailing slash though. 	 */
if|if
condition|(
name|pathlen
operator|<
name|baselen
operator|+
literal|1
operator|||
operator|(
name|baselen
operator|&&
name|pathname
index|[
name|baselen
index|]
operator|!=
literal|'/'
operator|)
operator|||
name|strncmp_icase
argument_list|(
name|pathname
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
condition|)
return|return
literal|0
return|;
name|namelen
operator|=
name|baselen
condition|?
name|pathlen
operator|-
name|baselen
operator|-
literal|1
else|:
name|pathlen
expr_stmt|;
name|name
operator|=
name|pathname
operator|+
name|pathlen
operator|-
name|namelen
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
comment|/* 		 * if the non-wildcard part is longer than the 		 * remaining pathname, surely it cannot match. 		 */
if|if
condition|(
name|prefix
operator|>
name|namelen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp_icase
argument_list|(
name|pattern
argument_list|,
name|name
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
literal|0
return|;
name|pattern
operator|+=
name|prefix
expr_stmt|;
name|patternlen
operator|-=
name|prefix
expr_stmt|;
name|name
operator|+=
name|prefix
expr_stmt|;
name|namelen
operator|-=
name|prefix
expr_stmt|;
comment|/* 		 * If the whole pattern did not have a wildcard, 		 * then our prefix match is all we need; we 		 * do not need to call fnmatch at all. 		 */
if|if
condition|(
operator|!
name|patternlen
operator|&&
operator|!
name|namelen
condition|)
return|return
literal|1
return|;
block|}
return|return
name|fnmatch_icase_mem
argument_list|(
name|pattern
argument_list|,
name|patternlen
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|WM_PATHNAME
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Scan the given exclude list in reverse to see whether pathname  * should be ignored.  The first match (i.e. the last on the list), if  * any, determines the fate.  Returns the exclude_list element which  * matched, or NULL for undecided.  */
end_comment
begin_function
DECL|function|last_exclude_matching_from_list
specifier|static
name|struct
name|exclude
modifier|*
name|last_exclude_matching_from_list
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|el
operator|->
name|nr
condition|)
return|return
name|NULL
return|;
comment|/* undefined */
for|for
control|(
name|i
operator|=
name|el
operator|->
name|nr
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|exclude
modifier|*
name|x
init|=
name|el
operator|->
name|excludes
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|exclude
init|=
name|x
operator|->
name|pattern
decl_stmt|;
name|int
name|prefix
init|=
name|x
operator|->
name|nowildcardlen
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_MUSTBEDIR
condition|)
block|{
if|if
condition|(
operator|*
name|dtype
operator|==
name|DT_UNKNOWN
condition|)
operator|*
name|dtype
operator|=
name|get_dtype
argument_list|(
name|NULL
argument_list|,
name|pathname
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dtype
operator|!=
name|DT_DIR
condition|)
continue|continue;
block|}
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_NODIR
condition|)
block|{
if|if
condition|(
name|match_basename
argument_list|(
name|basename
argument_list|,
name|pathlen
operator|-
operator|(
name|basename
operator|-
name|pathname
operator|)
argument_list|,
name|exclude
argument_list|,
name|prefix
argument_list|,
name|x
operator|->
name|patternlen
argument_list|,
name|x
operator|->
name|flags
argument_list|)
condition|)
return|return
name|x
return|;
continue|continue;
block|}
name|assert
argument_list|(
name|x
operator|->
name|baselen
operator|==
literal|0
operator|||
name|x
operator|->
name|base
index|[
name|x
operator|->
name|baselen
operator|-
literal|1
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_pathname
argument_list|(
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|x
operator|->
name|base
argument_list|,
name|x
operator|->
name|baselen
condition|?
name|x
operator|->
name|baselen
operator|-
literal|1
else|:
literal|0
argument_list|,
name|exclude
argument_list|,
name|prefix
argument_list|,
name|x
operator|->
name|patternlen
argument_list|,
name|x
operator|->
name|flags
argument_list|)
condition|)
return|return
name|x
return|;
block|}
return|return
name|NULL
return|;
comment|/* undecided */
block|}
end_function
begin_comment
comment|/*  * Scan the list and let the last match determine the fate.  * Return 1 for exclude, 0 for include and -1 for undecided.  */
end_comment
begin_function
DECL|function|is_excluded_from_list
name|int
name|is_excluded_from_list
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|exclude
decl_stmt|;
name|exclude
operator|=
name|last_exclude_matching_from_list
argument_list|(
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|basename
argument_list|,
name|dtype
argument_list|,
name|el
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclude
condition|)
return|return
name|exclude
operator|->
name|flags
operator|&
name|EXC_FLAG_NEGATIVE
condition|?
literal|0
else|:
literal|1
return|;
return|return
operator|-
literal|1
return|;
comment|/* undecided */
block|}
end_function
begin_function
DECL|function|last_exclude_matching_from_lists
specifier|static
name|struct
name|exclude
modifier|*
name|last_exclude_matching_from_lists
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
modifier|*
name|dtype_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|struct
name|exclude
modifier|*
name|exclude
decl_stmt|;
for|for
control|(
name|i
operator|=
name|EXC_CMDL
init|;
name|i
operator|<=
name|EXC_FILE
condition|;
name|i
operator|++
control|)
block|{
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|group
operator|->
name|nr
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|exclude
operator|=
name|last_exclude_matching_from_list
argument_list|(
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|basename
argument_list|,
name|dtype_p
argument_list|,
operator|&
name|group
operator|->
name|el
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclude
condition|)
return|return
name|exclude
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Loads the per-directory exclude list for the substring of base  * which has a char length of baselen.  */
end_comment
begin_function
DECL|function|prep_exclude
specifier|static
name|void
name|prep_exclude
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|)
block|{
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|struct
name|exclude_stack
modifier|*
name|stk
init|=
name|NULL
decl_stmt|;
name|struct
name|untracked_cache_dir
modifier|*
name|untracked
decl_stmt|;
name|int
name|current
decl_stmt|;
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|EXC_DIRS
index|]
expr_stmt|;
comment|/* 	 * Pop the exclude lists from the EXCL_DIRS exclude_list_group 	 * which originate from directories not in the prefix of the 	 * path being checked. 	 */
while|while
condition|(
operator|(
name|stk
operator|=
name|dir
operator|->
name|exclude_stack
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stk
operator|->
name|baselen
operator|<=
name|baselen
operator|&&
operator|!
name|strncmp
argument_list|(
name|dir
operator|->
name|basebuf
operator|.
name|buf
argument_list|,
name|base
argument_list|,
name|stk
operator|->
name|baselen
argument_list|)
condition|)
break|break;
name|el
operator|=
operator|&
name|group
operator|->
name|el
index|[
name|dir
operator|->
name|exclude_stack
operator|->
name|exclude_ix
index|]
expr_stmt|;
name|dir
operator|->
name|exclude_stack
operator|=
name|stk
operator|->
name|prev
expr_stmt|;
name|dir
operator|->
name|exclude
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|el
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* see strbuf_detach() below */
name|clear_exclude_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stk
argument_list|)
expr_stmt|;
name|group
operator|->
name|nr
operator|--
expr_stmt|;
block|}
comment|/* Skip traversing into sub directories if the parent is excluded */
if|if
condition|(
name|dir
operator|->
name|exclude
condition|)
return|return;
comment|/* 	 * Lazy initialization. All call sites currently just 	 * memset(dir, 0, sizeof(*dir)) before use. Changing all of 	 * them seems lots of work for little benefit. 	 */
if|if
condition|(
operator|!
name|dir
operator|->
name|basebuf
operator|.
name|buf
condition|)
name|strbuf_init
argument_list|(
operator|&
name|dir
operator|->
name|basebuf
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Read from the parent directories and push them down. */
name|current
operator|=
name|stk
condition|?
name|stk
operator|->
name|baselen
else|:
operator|-
literal|1
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|dir
operator|->
name|basebuf
argument_list|,
name|current
operator|<
literal|0
condition|?
literal|0
else|:
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|untracked
condition|)
name|untracked
operator|=
name|stk
condition|?
name|stk
operator|->
name|ucd
else|:
name|dir
operator|->
name|untracked
operator|->
name|root
expr_stmt|;
else|else
name|untracked
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|current
operator|<
name|baselen
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|sha1_stat
name|sha1_stat
decl_stmt|;
name|stk
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|<
literal|0
condition|)
block|{
name|cp
operator|=
name|base
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|base
operator|+
name|current
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|die
argument_list|(
literal|"oops in prep_exclude"
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|untracked
operator|=
name|lookup_untracked
argument_list|(
name|dir
operator|->
name|untracked
argument_list|,
name|untracked
argument_list|,
name|base
operator|+
name|current
argument_list|,
name|cp
operator|-
name|base
operator|-
name|current
argument_list|)
expr_stmt|;
block|}
name|stk
operator|->
name|prev
operator|=
name|dir
operator|->
name|exclude_stack
expr_stmt|;
name|stk
operator|->
name|baselen
operator|=
name|cp
operator|-
name|base
expr_stmt|;
name|stk
operator|->
name|exclude_ix
operator|=
name|group
operator|->
name|nr
expr_stmt|;
name|stk
operator|->
name|ucd
operator|=
name|untracked
expr_stmt|;
name|el
operator|=
name|add_exclude_list
argument_list|(
name|dir
argument_list|,
name|EXC_DIRS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|dir
operator|->
name|basebuf
argument_list|,
name|base
operator|+
name|current
argument_list|,
name|stk
operator|->
name|baselen
operator|-
name|current
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|stk
operator|->
name|baselen
operator|==
name|dir
operator|->
name|basebuf
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Abort if the directory is excluded */
if|if
condition|(
name|stk
operator|->
name|baselen
condition|)
block|{
name|int
name|dt
init|=
name|DT_DIR
decl_stmt|;
name|dir
operator|->
name|basebuf
operator|.
name|buf
index|[
name|stk
operator|->
name|baselen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|exclude
operator|=
name|last_exclude_matching_from_lists
argument_list|(
name|dir
argument_list|,
name|dir
operator|->
name|basebuf
operator|.
name|buf
argument_list|,
name|stk
operator|->
name|baselen
operator|-
literal|1
argument_list|,
name|dir
operator|->
name|basebuf
operator|.
name|buf
operator|+
name|current
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
name|dir
operator|->
name|basebuf
operator|.
name|buf
index|[
name|stk
operator|->
name|baselen
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|exclude
operator|&&
name|dir
operator|->
name|exclude
operator|->
name|flags
operator|&
name|EXC_FLAG_NEGATIVE
condition|)
name|dir
operator|->
name|exclude
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|exclude
condition|)
block|{
name|dir
operator|->
name|exclude_stack
operator|=
name|stk
expr_stmt|;
return|return;
block|}
block|}
comment|/* Try to read per-directory file */
name|hashclr
argument_list|(
name|sha1_stat
operator|.
name|sha1
argument_list|)
expr_stmt|;
name|sha1_stat
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|exclude_per_dir
condition|)
block|{
comment|/* 			 * dir->basebuf gets reused by the traversal, but we 			 * need fname to remain unchanged to ensure the src 			 * member of each struct exclude correctly 			 * back-references its source file.  Other invocations 			 * of add_exclude_list provide stable strings, so we 			 * strbuf_detach() and free() here in the caller. 			 */
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|dir
operator|->
name|basebuf
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sb
argument_list|,
name|dir
operator|->
name|exclude_per_dir
argument_list|)
expr_stmt|;
name|el
operator|->
name|src
operator|=
name|strbuf_detach
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_excludes
argument_list|(
name|el
operator|->
name|src
argument_list|,
name|el
operator|->
name|src
argument_list|,
name|stk
operator|->
name|baselen
argument_list|,
name|el
argument_list|,
literal|1
argument_list|,
name|untracked
condition|?
operator|&
name|sha1_stat
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|untracked
condition|)
block|{
name|hashcpy
argument_list|(
name|untracked
operator|->
name|exclude_sha1
argument_list|,
name|sha1_stat
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
name|dir
operator|->
name|exclude_stack
operator|=
name|stk
expr_stmt|;
name|current
operator|=
name|stk
operator|->
name|baselen
expr_stmt|;
block|}
name|strbuf_setlen
argument_list|(
operator|&
name|dir
operator|->
name|basebuf
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Loads the exclude lists for the directory containing pathname, then  * scans all exclude lists to determine whether pathname is excluded.  * Returns the exclude_list element which matched, or NULL for  * undecided.  */
end_comment
begin_function
DECL|function|last_exclude_matching
name|struct
name|exclude
modifier|*
name|last_exclude_matching
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
modifier|*
name|dtype_p
parameter_list|)
block|{
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|basename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|basename
operator|=
operator|(
name|basename
operator|)
condition|?
name|basename
operator|+
literal|1
else|:
name|pathname
expr_stmt|;
name|prep_exclude
argument_list|(
name|dir
argument_list|,
name|pathname
argument_list|,
name|basename
operator|-
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|exclude
condition|)
return|return
name|dir
operator|->
name|exclude
return|;
return|return
name|last_exclude_matching_from_lists
argument_list|(
name|dir
argument_list|,
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|basename
argument_list|,
name|dtype_p
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Loads the exclude lists for the directory containing pathname, then  * scans all exclude lists to determine whether pathname is excluded.  * Returns 1 if true, otherwise 0.  */
end_comment
begin_function
DECL|function|is_excluded
name|int
name|is_excluded
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
modifier|*
name|dtype_p
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|exclude
init|=
name|last_exclude_matching
argument_list|(
name|dir
argument_list|,
name|pathname
argument_list|,
name|dtype_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|exclude
condition|)
return|return
name|exclude
operator|->
name|flags
operator|&
name|EXC_FLAG_NEGATIVE
condition|?
literal|0
else|:
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|dir_entry_new
specifier|static
name|struct
name|dir_entry
modifier|*
name|dir_entry_new
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|dir_entry
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ent
operator|->
name|name
argument_list|,
name|pathname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|ent
return|;
block|}
end_function
begin_function
DECL|function|dir_add_name
specifier|static
name|struct
name|dir_entry
modifier|*
name|dir_add_name
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|cache_file_exists
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
name|ignore_case
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|entries
argument_list|,
name|dir
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|alloc
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|entries
index|[
name|dir
operator|->
name|nr
operator|++
index|]
operator|=
name|dir_entry_new
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dir_add_ignored
name|struct
name|dir_entry
modifier|*
name|dir_add_ignored
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cache_name_is_other
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|ignored
argument_list|,
name|dir
operator|->
name|ignored_nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|ignored_alloc
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|ignored
index|[
name|dir
operator|->
name|ignored_nr
operator|++
index|]
operator|=
name|dir_entry_new
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_enum
DECL|enum|exist_status
enum|enum
name|exist_status
block|{
DECL|enumerator|index_nonexistent
name|index_nonexistent
init|=
literal|0
block|,
DECL|enumerator|index_directory
name|index_directory
block|,
DECL|enumerator|index_gitdir
name|index_gitdir
block|}
enum|;
end_enum
begin_comment
comment|/*  * Do not use the alphabetically sorted index to look up  * the directory name; instead, use the case insensitive  * directory hash.  */
end_comment
begin_function
DECL|function|directory_exists_in_index_icase
specifier|static
name|enum
name|exist_status
name|directory_exists_in_index_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|cache_dir_exists
argument_list|(
name|dirname
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|endchar
decl_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
name|index_nonexistent
return|;
name|endchar
operator|=
name|ce
operator|->
name|name
index|[
name|len
index|]
expr_stmt|;
comment|/* 	 * The cache_entry structure returned will contain this dirname 	 * and possibly additional path components. 	 */
if|if
condition|(
name|endchar
operator|==
literal|'/'
condition|)
return|return
name|index_directory
return|;
comment|/* 	 * If there are no additional path components, then this cache_entry 	 * represents a submodule.  Submodules, despite being directories, 	 * are stored in the cache without a closing slash. 	 */
if|if
condition|(
operator|!
name|endchar
operator|&&
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
return|return
name|index_gitdir
return|;
comment|/* This should never be hit, but it exists just in case. */
return|return
name|index_nonexistent
return|;
block|}
end_function
begin_comment
comment|/*  * The index sorts alphabetically by entry name, which  * means that a gitlink sorts as '\0' at the end, while  * a directory (which is defined not as an entry, but as  * the files it contains) will sort with the '/' at the  * end.  */
end_comment
begin_function
DECL|function|directory_exists_in_index
specifier|static
name|enum
name|exist_status
name|directory_exists_in_index
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|ignore_case
condition|)
return|return
name|directory_exists_in_index_icase
argument_list|(
name|dirname
argument_list|,
name|len
argument_list|)
return|;
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|dirname
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
condition|)
block|{
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
operator|++
index|]
decl_stmt|;
name|unsigned
name|char
name|endchar
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|)
condition|)
break|break;
name|endchar
operator|=
name|ce
operator|->
name|name
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|endchar
operator|>
literal|'/'
condition|)
break|break;
if|if
condition|(
name|endchar
operator|==
literal|'/'
condition|)
return|return
name|index_directory
return|;
if|if
condition|(
operator|!
name|endchar
operator|&&
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
return|return
name|index_gitdir
return|;
block|}
return|return
name|index_nonexistent
return|;
block|}
end_function
begin_comment
comment|/*  * When we find a directory when traversing the filesystem, we  * have three distinct cases:  *  *  - ignore it  *  - see it as a directory  *  - recurse into it  *  * and which one we choose depends on a combination of existing  * git index contents and the flags passed into the directory  * traversal routine.  *  * Case 1: If we *already* have entries in the index under that  * directory name, we always recurse into the directory to see  * all the files.  *  * Case 2: If we *already* have that directory name as a gitlink,  * we always continue to see it as a gitlink, regardless of whether  * there is an actual git directory there or not (it might not  * be checked out as a subproject!)  *  * Case 3: if we didn't have it in the index previously, we  * have a few sub-cases:  *  *  (a) if "show_other_directories" is true, we show it as  *      just a directory, unless "hide_empty_directories" is  *      also true, in which case we need to check if it contains any  *      untracked and / or ignored files.  *  (b) if it looks like a git directory, and we don't have  *      'no_gitlinks' set we treat it as a gitlink, and show it  *      as a directory.  *  (c) otherwise, we recurse into it.  */
end_comment
begin_function
DECL|function|treat_directory
specifier|static
name|enum
name|path_treatment
name|treat_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|struct
name|untracked_cache_dir
modifier|*
name|untracked
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|exclude
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
comment|/* The "len-1" is to strip the final '/' */
switch|switch
condition|(
name|directory_exists_in_index
argument_list|(
name|dirname
argument_list|,
name|len
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
name|index_directory
case|:
return|return
name|path_recurse
return|;
case|case
name|index_gitdir
case|:
return|return
name|path_none
return|;
case|case
name|index_nonexistent
case|:
if|if
condition|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_OTHER_DIRECTORIES
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_NO_GITLINKS
operator|)
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|resolve_gitlink_ref
argument_list|(
name|dirname
argument_list|,
literal|"HEAD"
argument_list|,
name|sha1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|path_untracked
return|;
block|}
return|return
name|path_recurse
return|;
block|}
comment|/* This is the "show_other_directories" case */
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_HIDE_EMPTY_DIRECTORIES
operator|)
condition|)
return|return
name|exclude
condition|?
name|path_excluded
else|:
name|path_untracked
return|;
name|untracked
operator|=
name|lookup_untracked
argument_list|(
name|dir
operator|->
name|untracked
argument_list|,
name|untracked
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|,
name|untracked
argument_list|,
literal|1
argument_list|,
name|simplify
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * This is an inexact early pruning of any recursive directory  * reading - if the path cannot possibly be in the pathspec,  * return true, and we'll skip it early.  */
end_comment
begin_function
DECL|function|simplify_away
specifier|static
name|int
name|simplify_away
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
if|if
condition|(
name|simplify
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|match
init|=
name|simplify
operator|->
name|path
decl_stmt|;
name|int
name|len
init|=
name|simplify
operator|->
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
if|if
condition|(
name|len
operator|>
name|pathlen
condition|)
name|len
operator|=
name|pathlen
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|match
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|simplify
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * This function tells us whether an excluded path matches a  * list of "interesting" pathspecs. That is, whether a path matched  * by any of the pathspecs could possibly be ignored by excluding  * the specified path. This can happen if:  *  *   1. the path is mentioned explicitly in the pathspec  *  *   2. the path is a directory prefix of some element in the  *      pathspec  */
end_comment
begin_function
DECL|function|exclude_matches_pathspec
specifier|static
name|int
name|exclude_matches_pathspec
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
if|if
condition|(
name|simplify
condition|)
block|{
for|for
control|(
init|;
name|simplify
operator|->
name|path
condition|;
name|simplify
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|==
name|simplify
operator|->
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|simplify
operator|->
name|path
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<
name|simplify
operator|->
name|len
operator|&&
name|simplify
operator|->
name|path
index|[
name|len
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|simplify
operator|->
name|path
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_index_dtype
specifier|static
name|int
name|get_index_dtype
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
specifier|const
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|cache_file_exists
argument_list|(
name|path
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
condition|)
block|{
if|if
condition|(
operator|!
name|ce_uptodate
argument_list|(
name|ce
argument_list|)
condition|)
return|return
name|DT_UNKNOWN
return|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
return|return
name|DT_DIR
return|;
comment|/* 		 * Nobody actually cares about the 		 * difference between DT_LNK and DT_REG 		 */
return|return
name|DT_REG
return|;
block|}
comment|/* Try to look it up as a directory */
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
return|return
name|DT_UNKNOWN
return|;
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
condition|)
block|{
name|ce
operator|=
name|active_cache
index|[
name|pos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ce
operator|->
name|name
index|[
name|len
index|]
operator|>
literal|'/'
condition|)
break|break;
if|if
condition|(
name|ce
operator|->
name|name
index|[
name|len
index|]
operator|<
literal|'/'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ce_uptodate
argument_list|(
name|ce
argument_list|)
condition|)
break|break;
comment|/* continue? */
return|return
name|DT_DIR
return|;
block|}
return|return
name|DT_UNKNOWN
return|;
block|}
end_function
begin_function
DECL|function|get_dtype
specifier|static
name|int
name|get_dtype
parameter_list|(
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|dtype
init|=
name|de
condition|?
name|DTYPE
argument_list|(
name|de
argument_list|)
else|:
name|DT_UNKNOWN
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|DT_UNKNOWN
condition|)
return|return
name|dtype
return|;
name|dtype
operator|=
name|get_index_dtype
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|DT_UNKNOWN
condition|)
return|return
name|dtype
return|;
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
name|dtype
return|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_REG
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_DIR
return|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_LNK
return|;
return|return
name|dtype
return|;
block|}
end_function
begin_function
DECL|function|treat_one_path
specifier|static
name|enum
name|path_treatment
name|treat_one_path
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|struct
name|untracked_cache_dir
modifier|*
name|untracked
parameter_list|,
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|,
name|int
name|dtype
parameter_list|,
name|struct
name|dirent
modifier|*
name|de
parameter_list|)
block|{
name|int
name|exclude
decl_stmt|;
name|int
name|has_path_in_index
init|=
operator|!
operator|!
name|cache_file_exists
argument_list|(
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|ignore_case
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DT_UNKNOWN
condition|)
name|dtype
operator|=
name|get_dtype
argument_list|(
name|de
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Always exclude indexed files */
if|if
condition|(
name|dtype
operator|!=
name|DT_DIR
operator|&&
name|has_path_in_index
condition|)
return|return
name|path_none
return|;
comment|/* 	 * When we are looking at a directory P in the working tree, 	 * there are three cases: 	 * 	 * (1) P exists in the index.  Everything inside the directory P in 	 * the working tree needs to go when P is checked out from the 	 * index. 	 * 	 * (2) P does not exist in the index, but there is P/Q in the index. 	 * We know P will stay a directory when we check out the contents 	 * of the index, but we do not know yet if there is a directory 	 * P/Q in the working tree to be killed, so we need to recurse. 	 * 	 * (3) P does not exist in the index, and there is no P/Q in the index 	 * to require P to be a directory, either.  Only in this case, we 	 * know that everything inside P will not be killed without 	 * recursing. 	 */
if|if
condition|(
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_COLLECT_KILLED_ONLY
operator|)
operator|&&
operator|(
name|dtype
operator|==
name|DT_DIR
operator|)
operator|&&
operator|!
name|has_path_in_index
operator|&&
operator|(
name|directory_exists_in_index
argument_list|(
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|)
operator|==
name|index_nonexistent
operator|)
condition|)
return|return
name|path_none
return|;
name|exclude
operator|=
name|is_excluded
argument_list|(
name|dir
argument_list|,
name|path
operator|->
name|buf
argument_list|,
operator|&
name|dtype
argument_list|)
expr_stmt|;
comment|/* 	 * Excluded? If we don't explicitly want to show 	 * ignored files, ignore it 	 */
if|if
condition|(
name|exclude
operator|&&
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
operator|(
name|DIR_SHOW_IGNORED
operator||
name|DIR_SHOW_IGNORED_TOO
operator|)
operator|)
condition|)
return|return
name|path_excluded
return|;
switch|switch
condition|(
name|dtype
condition|)
block|{
default|default:
return|return
name|path_none
return|;
case|case
name|DT_DIR
case|:
name|strbuf_addch
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
return|return
name|treat_directory
argument_list|(
name|dir
argument_list|,
name|untracked
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|exclude
argument_list|,
name|simplify
argument_list|)
return|;
case|case
name|DT_REG
case|:
case|case
name|DT_LNK
case|:
return|return
name|exclude
condition|?
name|path_excluded
else|:
name|path_untracked
return|;
block|}
block|}
end_function
begin_function
DECL|function|treat_path
specifier|static
name|enum
name|path_treatment
name|treat_path
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|struct
name|untracked_cache_dir
modifier|*
name|untracked
parameter_list|,
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|int
name|dtype
decl_stmt|;
if|if
condition|(
name|is_dot_or_dotdot
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".git"
argument_list|)
condition|)
return|return
name|path_none
return|;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|path
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|simplify_away
argument_list|(
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
return|return
name|path_none
return|;
name|dtype
operator|=
name|DTYPE
argument_list|(
name|de
argument_list|)
expr_stmt|;
return|return
name|treat_one_path
argument_list|(
name|dir
argument_list|,
name|untracked
argument_list|,
name|path
argument_list|,
name|simplify
argument_list|,
name|dtype
argument_list|,
name|de
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|add_untracked
specifier|static
name|void
name|add_untracked
parameter_list|(
name|struct
name|untracked_cache_dir
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dir
condition|)
return|return;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|untracked
argument_list|,
name|dir
operator|->
name|untracked_nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|untracked_alloc
argument_list|)
expr_stmt|;
name|dir
operator|->
name|untracked
index|[
name|dir
operator|->
name|untracked_nr
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Read a directory tree. We currently ignore anything but  * directories, regular files and symlinks. That's because git  * doesn't handle them at all yet. Maybe that will change some  * day.  *  * Also, we ignore the name ".git" (even if it is not a directory).  * That likely will not change.  *  * Returns the most significant path_treatment value encountered in the scan.  */
end_comment
begin_function
DECL|function|read_directory_recursive
specifier|static
name|enum
name|path_treatment
name|read_directory_recursive
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|struct
name|untracked_cache_dir
modifier|*
name|untracked
parameter_list|,
name|int
name|check_only
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|DIR
modifier|*
name|fdir
decl_stmt|;
name|enum
name|path_treatment
name|state
decl_stmt|,
name|subdir_state
decl_stmt|,
name|dir_state
init|=
name|path_none
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|struct
name|strbuf
name|path
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|path
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|fdir
operator|=
name|opendir
argument_list|(
name|path
operator|.
name|len
condition|?
name|path
operator|.
name|buf
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdir
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|untracked
condition|)
name|untracked
operator|->
name|check_only
operator|=
operator|!
operator|!
name|check_only
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|fdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* check how the file or directory should be treated */
name|state
operator|=
name|treat_path
argument_list|(
name|dir
argument_list|,
name|untracked
argument_list|,
name|de
argument_list|,
operator|&
name|path
argument_list|,
name|baselen
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|>
name|dir_state
condition|)
name|dir_state
operator|=
name|state
expr_stmt|;
comment|/* recurse into subdir if instructed by treat_path */
if|if
condition|(
name|state
operator|==
name|path_recurse
condition|)
block|{
name|struct
name|untracked_cache_dir
modifier|*
name|ud
decl_stmt|;
name|ud
operator|=
name|lookup_untracked
argument_list|(
name|dir
operator|->
name|untracked
argument_list|,
name|untracked
argument_list|,
name|path
operator|.
name|buf
operator|+
name|baselen
argument_list|,
name|path
operator|.
name|len
operator|-
name|baselen
argument_list|)
expr_stmt|;
name|subdir_state
operator|=
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|path
operator|.
name|buf
argument_list|,
name|path
operator|.
name|len
argument_list|,
name|ud
argument_list|,
name|check_only
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdir_state
operator|>
name|dir_state
condition|)
name|dir_state
operator|=
name|subdir_state
expr_stmt|;
block|}
if|if
condition|(
name|check_only
condition|)
block|{
comment|/* abort early if maximum state has been reached */
if|if
condition|(
name|dir_state
operator|==
name|path_untracked
condition|)
block|{
if|if
condition|(
name|untracked
condition|)
name|add_untracked
argument_list|(
name|untracked
argument_list|,
name|path
operator|.
name|buf
operator|+
name|baselen
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* skip the dir_add_* part */
continue|continue;
block|}
comment|/* add the path to the appropriate result list */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|path_excluded
case|:
if|if
condition|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
condition|)
name|dir_add_name
argument_list|(
name|dir
argument_list|,
name|path
operator|.
name|buf
argument_list|,
name|path
operator|.
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED_TOO
operator|)
operator|||
operator|(
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_COLLECT_IGNORED
operator|)
operator|&&
name|exclude_matches_pathspec
argument_list|(
name|path
operator|.
name|buf
argument_list|,
name|path
operator|.
name|len
argument_list|,
name|simplify
argument_list|)
operator|)
condition|)
name|dir_add_ignored
argument_list|(
name|dir
argument_list|,
name|path
operator|.
name|buf
argument_list|,
name|path
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|path_untracked
case|:
if|if
condition|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
condition|)
break|break;
name|dir_add_name
argument_list|(
name|dir
argument_list|,
name|path
operator|.
name|buf
argument_list|,
name|path
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|untracked
condition|)
name|add_untracked
argument_list|(
name|untracked
argument_list|,
name|path
operator|.
name|buf
operator|+
name|baselen
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|closedir
argument_list|(
name|fdir
argument_list|)
expr_stmt|;
name|out
label|:
name|strbuf_release
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
name|dir_state
return|;
block|}
end_function
begin_function
DECL|function|cmp_name
specifier|static
name|int
name|cmp_name
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|dir_entry
modifier|*
name|e1
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dir_entry
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|dir_entry
modifier|*
name|e2
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dir_entry
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|name_compare
argument_list|(
name|e1
operator|->
name|name
argument_list|,
name|e1
operator|->
name|len
argument_list|,
name|e2
operator|->
name|name
argument_list|,
name|e2
operator|->
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|create_simplify
specifier|static
name|struct
name|path_simplify
modifier|*
name|create_simplify
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|int
name|nr
decl_stmt|,
name|alloc
init|=
literal|0
decl_stmt|;
name|struct
name|path_simplify
modifier|*
name|simplify
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pathspec
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
condition|;
name|nr
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
name|ALLOC_GROW
argument_list|(
name|simplify
argument_list|,
name|nr
operator|+
literal|1
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|match
operator|=
operator|*
name|pathspec
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
name|simplify
index|[
name|nr
index|]
operator|.
name|path
operator|=
name|match
expr_stmt|;
name|simplify
index|[
name|nr
index|]
operator|.
name|len
operator|=
name|simple_length
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
name|simplify
index|[
name|nr
index|]
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
name|simplify
index|[
name|nr
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|simplify
return|;
block|}
end_function
begin_function
DECL|function|free_simplify
specifier|static
name|void
name|free_simplify
parameter_list|(
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|free
argument_list|(
name|simplify
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|treat_leading_path
specifier|static
name|int
name|treat_leading_path
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|baselen
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|old_flags
init|=
name|dir
operator|->
name|flags
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|1
return|;
name|baselen
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|flags
operator|&=
operator|~
name|DIR_SHOW_OTHER_DIRECTORIES
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|cp
operator|=
name|path
operator|+
name|baselen
operator|+
operator|!
operator|!
name|baselen
expr_stmt|;
name|cp
operator|=
name|memchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|,
name|path
operator|+
name|len
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|baselen
operator|=
name|len
expr_stmt|;
else|else
name|baselen
operator|=
name|cp
operator|-
name|path
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|path
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_directory
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
condition|)
break|break;
if|if
condition|(
name|simplify_away
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
break|break;
if|if
condition|(
name|treat_one_path
argument_list|(
name|dir
argument_list|,
name|NULL
argument_list|,
operator|&
name|sb
argument_list|,
name|simplify
argument_list|,
name|DT_DIR
argument_list|,
name|NULL
argument_list|)
operator|==
name|path_none
condition|)
break|break;
comment|/* do not recurse into it */
if|if
condition|(
name|len
operator|<=
name|baselen
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* finished checking */
block|}
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|dir
operator|->
name|flags
operator|=
name|old_flags
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|validate_untracked_cache
specifier|static
name|struct
name|untracked_cache_dir
modifier|*
name|validate_untracked_cache
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|int
name|base_len
parameter_list|,
specifier|const
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|)
block|{
name|struct
name|untracked_cache_dir
modifier|*
name|root
decl_stmt|;
if|if
condition|(
operator|!
name|dir
operator|->
name|untracked
condition|)
return|return
name|NULL
return|;
comment|/* 	 * We only support $GIT_DIR/info/exclude and core.excludesfile 	 * as the global ignore rule files. Any other additions 	 * (e.g. from command line) invalidate the cache. This 	 * condition also catches running setup_standard_excludes() 	 * before setting dir->untracked! 	 */
if|if
condition|(
name|dir
operator|->
name|unmanaged_exclude_files
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Optimize for the main use case only: whole-tree git 	 * status. More work involved in treat_leading_path() if we 	 * use cache on just a subset of the worktree. pathspec 	 * support could make the matter even worse. 	 */
if|if
condition|(
name|base_len
operator|||
operator|(
name|pathspec
operator|&&
name|pathspec
operator|->
name|nr
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Different set of flags may produce different results */
if|if
condition|(
name|dir
operator|->
name|flags
operator|!=
name|dir
operator|->
name|untracked
operator|->
name|dir_flags
operator|||
comment|/* 	     * See treat_directory(), case index_nonexistent. Without 	     * this flag, we may need to also cache .git file content 	     * for the resolve_gitlink_ref() call, which we don't. 	     */
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_OTHER_DIRECTORIES
operator|)
operator|||
comment|/* We don't support collecting ignore files */
operator|(
name|dir
operator|->
name|flags
operator|&
operator|(
name|DIR_SHOW_IGNORED
operator||
name|DIR_SHOW_IGNORED_TOO
operator||
name|DIR_COLLECT_IGNORED
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * If we use .gitignore in the cache and now you change it to 	 * .gitexclude, everything will go wrong. 	 */
if|if
condition|(
name|dir
operator|->
name|exclude_per_dir
operator|!=
name|dir
operator|->
name|untracked
operator|->
name|exclude_per_dir
operator|&&
name|strcmp
argument_list|(
name|dir
operator|->
name|exclude_per_dir
argument_list|,
name|dir
operator|->
name|untracked
operator|->
name|exclude_per_dir
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * EXC_CMDL is not considered in the cache. If people set it, 	 * skip the cache. 	 */
if|if
condition|(
name|dir
operator|->
name|exclude_list_group
index|[
name|EXC_CMDL
index|]
operator|.
name|nr
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|dir
operator|->
name|untracked
operator|->
name|root
condition|)
block|{
specifier|const
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|dir
operator|->
name|untracked
operator|->
name|root
argument_list|)
decl_stmt|;
name|dir
operator|->
name|untracked
operator|->
name|root
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dir
operator|->
name|untracked
operator|->
name|root
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Validate $GIT_DIR/info/exclude and core.excludesfile */
name|root
operator|=
name|dir
operator|->
name|untracked
operator|->
name|root
expr_stmt|;
if|if
condition|(
name|hashcmp
argument_list|(
name|dir
operator|->
name|ss_info_exclude
operator|.
name|sha1
argument_list|,
name|dir
operator|->
name|untracked
operator|->
name|ss_info_exclude
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|invalidate_gitignore
argument_list|(
name|dir
operator|->
name|untracked
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|dir
operator|->
name|untracked
operator|->
name|ss_info_exclude
operator|=
name|dir
operator|->
name|ss_info_exclude
expr_stmt|;
block|}
if|if
condition|(
name|hashcmp
argument_list|(
name|dir
operator|->
name|ss_excludes_file
operator|.
name|sha1
argument_list|,
name|dir
operator|->
name|untracked
operator|->
name|ss_excludes_file
operator|.
name|sha1
argument_list|)
condition|)
block|{
name|invalidate_gitignore
argument_list|(
name|dir
operator|->
name|untracked
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|dir
operator|->
name|untracked
operator|->
name|ss_excludes_file
operator|=
name|dir
operator|->
name|ss_excludes_file
expr_stmt|;
block|}
return|return
name|root
return|;
block|}
end_function
begin_function
DECL|function|read_directory
name|int
name|read_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|)
block|{
name|struct
name|path_simplify
modifier|*
name|simplify
decl_stmt|;
name|struct
name|untracked_cache_dir
modifier|*
name|untracked
decl_stmt|;
comment|/* 	 * Check out create_simplify() 	 */
if|if
condition|(
name|pathspec
condition|)
name|GUARD_PATHSPEC
argument_list|(
name|pathspec
argument_list|,
name|PATHSPEC_FROMTOP
operator||
name|PATHSPEC_MAXDEPTH
operator||
name|PATHSPEC_LITERAL
operator||
name|PATHSPEC_GLOB
operator||
name|PATHSPEC_ICASE
operator||
name|PATHSPEC_EXCLUDE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_symlink_leading_path
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|dir
operator|->
name|nr
return|;
comment|/* 	 * exclude patterns are treated like positive ones in 	 * create_simplify. Usually exclude patterns should be a 	 * subset of positive ones, which has no impacts on 	 * create_simplify(). 	 */
name|simplify
operator|=
name|create_simplify
argument_list|(
name|pathspec
condition|?
name|pathspec
operator|->
name|_raw
else|:
name|NULL
argument_list|)
expr_stmt|;
name|untracked
operator|=
name|validate_untracked_cache
argument_list|(
name|dir
argument_list|,
name|len
argument_list|,
name|pathspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|untracked
condition|)
comment|/* 		 * make sure untracked cache code path is disabled, 		 * e.g. prep_exclude() 		 */
name|dir
operator|->
name|untracked
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|treat_leading_path
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|len
argument_list|,
name|untracked
argument_list|,
literal|0
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
name|free_simplify
argument_list|(
name|simplify
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|dir
operator|->
name|entries
argument_list|,
name|dir
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir_entry
operator|*
argument_list|)
argument_list|,
name|cmp_name
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|dir
operator|->
name|ignored
argument_list|,
name|dir
operator|->
name|ignored_nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir_entry
operator|*
argument_list|)
argument_list|,
name|cmp_name
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|nr
return|;
block|}
end_function
begin_function
DECL|function|file_exists
name|int
name|file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
return|return
name|lstat
argument_list|(
name|f
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given two normalized paths (a trailing slash is ok), if subdir is  * outside dir, return -1.  Otherwise return the offset in subdir that  * can be used as relative path to dir.  */
end_comment
begin_function
DECL|function|dir_inside_of
name|int
name|dir_inside_of
parameter_list|(
specifier|const
name|char
modifier|*
name|subdir
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|dir
operator|&&
name|subdir
operator|&&
operator|*
name|dir
operator|&&
operator|*
name|subdir
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|dir
operator|&&
operator|*
name|subdir
operator|&&
operator|*
name|dir
operator|==
operator|*
name|subdir
condition|)
block|{
name|dir
operator|++
expr_stmt|;
name|subdir
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
comment|/* hel[p]/me vs hel[l]/yeah */
if|if
condition|(
operator|*
name|dir
operator|&&
operator|*
name|subdir
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|subdir
condition|)
return|return
operator|!
operator|*
name|dir
condition|?
name|offset
else|:
operator|-
literal|1
return|;
comment|/* same dir */
comment|/* foo/[b]ar vs foo/[] */
if|if
condition|(
name|is_dir_sep
argument_list|(
name|dir
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
name|is_dir_sep
argument_list|(
name|subdir
index|[
operator|-
literal|1
index|]
argument_list|)
condition|?
name|offset
else|:
operator|-
literal|1
return|;
comment|/* foo[/]bar vs foo[] */
return|return
name|is_dir_sep
argument_list|(
operator|*
name|subdir
argument_list|)
condition|?
name|offset
operator|+
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|is_inside_dir
name|int
name|is_inside_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|cwd
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
literal|0
return|;
name|cwd
operator|=
name|xgetcwd
argument_list|()
expr_stmt|;
name|rc
operator|=
operator|(
name|dir_inside_of
argument_list|(
name|cwd
argument_list|,
name|dir
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|free
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|is_empty_dir
name|int
name|is_empty_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|DIR
modifier|*
name|dir
init|=
name|opendir
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|is_dot_or_dotdot
argument_list|(
name|e
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|remove_dir_recurse
specifier|static
name|int
name|remove_dir_recurse
parameter_list|(
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
modifier|*
name|kept_up
parameter_list|)
block|{
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|original_len
init|=
name|path
operator|->
name|len
decl_stmt|,
name|len
decl_stmt|,
name|kept_down
init|=
literal|0
decl_stmt|;
name|int
name|only_empty
init|=
operator|(
name|flag
operator|&
name|REMOVE_DIR_EMPTY_ONLY
operator|)
decl_stmt|;
name|int
name|keep_toplevel
init|=
operator|(
name|flag
operator|&
name|REMOVE_DIR_KEEP_TOPLEVEL
operator|)
decl_stmt|;
name|unsigned
name|char
name|submodule_head
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|REMOVE_DIR_KEEP_NESTED_GIT
operator|)
operator|&&
operator|!
name|resolve_gitlink_ref
argument_list|(
name|path
operator|->
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|submodule_head
argument_list|)
condition|)
block|{
comment|/* Do not descend and nuke a nested git work tree. */
if|if
condition|(
name|kept_up
condition|)
operator|*
name|kept_up
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|flag
operator|&=
operator|~
name|REMOVE_DIR_KEEP_TOPLEVEL
expr_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
name|keep_toplevel
condition|?
operator|-
literal|1
else|:
literal|0
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EACCES
operator|&&
operator|!
name|keep_toplevel
condition|)
comment|/* 			 * An empty dir could be removable even if it 			 * is unreadable: 			 */
return|return
name|rmdir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|path
operator|->
name|buf
index|[
name|original_len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strbuf_addch
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|len
operator|=
name|path
operator|->
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|is_dot_or_dotdot
argument_list|(
name|e
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|path
argument_list|,
name|e
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|path
operator|->
name|buf
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
comment|/* 				 * file disappeared, which is what we 				 * wanted anyway 				 */
continue|continue;
comment|/* fall thru */
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|remove_dir_recurse
argument_list|(
name|path
argument_list|,
name|flag
argument_list|,
operator|&
name|kept_down
argument_list|)
condition|)
continue|continue;
comment|/* happy */
block|}
elseif|else
if|if
condition|(
operator|!
name|only_empty
operator|&&
operator|(
operator|!
name|unlink
argument_list|(
name|path
operator|->
name|buf
argument_list|)
operator|||
name|errno
operator|==
name|ENOENT
operator|)
condition|)
block|{
continue|continue;
comment|/* happy, too */
block|}
comment|/* path too long, stat fails, or non-directory still exists */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|original_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|!
name|keep_toplevel
operator|&&
operator|!
name|kept_down
condition|)
name|ret
operator|=
operator|(
operator|!
name|rmdir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
operator|||
name|errno
operator|==
name|ENOENT
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|kept_up
condition|)
comment|/* 		 * report the uplevel that it is not an error that we 		 * did not rmdir() our directory. 		 */
operator|*
name|kept_up
operator|=
operator|!
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|remove_dir_recursively
name|int
name|remove_dir_recursively
parameter_list|(
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
name|remove_dir_recurse
argument_list|(
name|path
argument_list|,
name|flag
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setup_standard_excludes
name|void
name|setup_standard_excludes
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|xdg_path
decl_stmt|;
name|dir
operator|->
name|exclude_per_dir
operator|=
literal|".gitignore"
expr_stmt|;
name|path
operator|=
name|git_path
argument_list|(
literal|"info/exclude"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|excludes_file
condition|)
block|{
name|home_config_paths
argument_list|(
name|NULL
argument_list|,
operator|&
name|xdg_path
argument_list|,
literal|"ignore"
argument_list|)
expr_stmt|;
name|excludes_file
operator|=
name|xdg_path
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|access_or_warn
argument_list|(
name|path
argument_list|,
name|R_OK
argument_list|,
literal|0
argument_list|)
condition|)
name|add_excludes_from_file_1
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|dir
operator|->
name|untracked
condition|?
operator|&
name|dir
operator|->
name|ss_info_exclude
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|excludes_file
operator|&&
operator|!
name|access_or_warn
argument_list|(
name|excludes_file
argument_list|,
name|R_OK
argument_list|,
literal|0
argument_list|)
condition|)
name|add_excludes_from_file_1
argument_list|(
name|dir
argument_list|,
name|excludes_file
argument_list|,
name|dir
operator|->
name|untracked
condition|?
operator|&
name|dir
operator|->
name|ss_excludes_file
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove_path
name|int
name|remove_path
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|ENOTDIR
condition|)
return|return
operator|-
literal|1
return|;
name|slash
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
block|{
name|char
modifier|*
name|dirs
init|=
name|xstrdup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|slash
operator|=
name|dirs
operator|+
operator|(
name|slash
operator|-
name|name
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
name|rmdir
argument_list|(
name|dirs
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|slash
operator|=
name|strrchr
argument_list|(
name|dirs
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
do|;
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Frees memory within dir which was allocated for exclude lists and  * the exclude_stack.  Does not free dir itself.  */
end_comment
begin_function
DECL|function|clear_directory
name|void
name|clear_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|struct
name|exclude_stack
modifier|*
name|stk
decl_stmt|;
for|for
control|(
name|i
operator|=
name|EXC_CMDL
init|;
name|i
operator|<=
name|EXC_FILE
condition|;
name|i
operator|++
control|)
block|{
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|group
operator|->
name|nr
condition|;
name|j
operator|++
control|)
block|{
name|el
operator|=
operator|&
name|group
operator|->
name|el
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EXC_DIRS
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|el
operator|->
name|src
argument_list|)
expr_stmt|;
name|clear_exclude_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|group
operator|->
name|el
argument_list|)
expr_stmt|;
block|}
name|stk
operator|=
name|dir
operator|->
name|exclude_stack
expr_stmt|;
while|while
condition|(
name|stk
condition|)
block|{
name|struct
name|exclude_stack
modifier|*
name|prev
init|=
name|stk
operator|->
name|prev
decl_stmt|;
name|free
argument_list|(
name|stk
argument_list|)
expr_stmt|;
name|stk
operator|=
name|prev
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|dir
operator|->
name|basebuf
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
