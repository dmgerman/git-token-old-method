begin_unit
begin_comment
comment|/*  * This handles recursive filename detection with exclude  * files, index knowledge etc..  *  * See Documentation/technical/api-directory-listing.txt  *  * Copyright (C) Linus Torvalds, 2005-2006  *		 Junio Hamano, 2005-2006  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"wildmatch.h"
end_include
begin_struct
DECL|struct|path_simplify
struct|struct
name|path_simplify
block|{
DECL|member|len
name|int
name|len
decl_stmt|;
DECL|member|path
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct
begin_function_decl
specifier|static
name|int
name|read_directory_recursive
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|check_only
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|int
name|get_dtype
parameter_list|(
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* helper string functions with support for the ignore_case flag */
end_comment
begin_function
DECL|function|strcmp_icase
name|int
name|strcmp_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
return|return
name|ignore_case
condition|?
name|strcasecmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
else|:
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|strncmp_icase
name|int
name|strncmp_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
return|return
name|ignore_case
condition|?
name|strncasecmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|count
argument_list|)
else|:
name|strncmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|fnmatch_icase
name|int
name|fnmatch_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|flags
operator||
operator|(
name|ignore_case
condition|?
name|FNM_CASEFOLD
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|git_fnmatch
specifier|inline
name|int
name|git_fnmatch
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|prefix
parameter_list|)
block|{
name|int
name|fnm_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|GFNM_PATHNAME
condition|)
name|fnm_flags
operator||=
name|FNM_PATHNAME
expr_stmt|;
if|if
condition|(
name|prefix
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
name|pattern
operator|+=
name|prefix
expr_stmt|;
name|string
operator|+=
name|prefix
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|GFNM_ONESTAR
condition|)
block|{
name|int
name|pattern_len
init|=
name|strlen
argument_list|(
operator|++
name|pattern
argument_list|)
decl_stmt|;
name|int
name|string_len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
return|return
name|string_len
operator|<
name|pattern_len
operator|||
name|strcmp
argument_list|(
name|pattern
argument_list|,
name|string
operator|+
name|string_len
operator|-
name|pattern_len
argument_list|)
return|;
block|}
return|return
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|fnm_flags
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|common_prefix_len
specifier|static
name|size_t
name|common_prefix_len
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|size_t
name|max
init|=
literal|0
decl_stmt|;
name|int
name|literal
init|=
name|limit_pathspec_to_literal
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pathspec
condition|)
return|return
name|max
return|;
name|first
operator|=
operator|*
name|pathspec
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
operator|*
name|pathspec
operator|++
operator|)
condition|)
block|{
name|size_t
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|first
operator|==
name|n
operator|||
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|n
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
name|c
operator|!=
name|first
index|[
name|i
index|]
operator|||
operator|(
operator|!
name|literal
operator|&&
name|is_glob_special
argument_list|(
name|c
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|==
name|n
operator|||
name|len
operator|<
name|max
condition|)
block|{
name|max
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|max
condition|)
break|break;
block|}
block|}
return|return
name|max
return|;
block|}
end_function
begin_comment
comment|/*  * Returns a copy of the longest leading path common among all  * pathspecs.  */
end_comment
begin_function
DECL|function|common_prefix
name|char
modifier|*
name|common_prefix
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|unsigned
name|long
name|len
init|=
name|common_prefix_len
argument_list|(
name|pathspec
argument_list|)
decl_stmt|;
return|return
name|len
condition|?
name|xmemdupz
argument_list|(
operator|*
name|pathspec
argument_list|,
name|len
argument_list|)
else|:
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|fill_directory
name|int
name|fill_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
comment|/* 	 * Calculate common prefix for the pathspec, and 	 * use that to optimize the directory walk 	 */
name|len
operator|=
name|common_prefix_len
argument_list|(
name|pathspec
argument_list|)
expr_stmt|;
comment|/* Read the directory and prune it */
name|read_directory
argument_list|(
name|dir
argument_list|,
name|pathspec
condition|?
operator|*
name|pathspec
else|:
literal|""
argument_list|,
name|len
argument_list|,
name|pathspec
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_function
DECL|function|within_depth
name|int
name|within_depth
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|max_depth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
name|name
decl_stmt|,
modifier|*
name|cpe
init|=
name|name
operator|+
name|namelen
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpe
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'/'
condition|)
continue|continue;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|max_depth
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Does 'match' match the given name?  * A match is found if  *  * (1) the 'match' string is leading directory of 'name', or  * (2) the 'match' string is a wildcard and matches 'name', or  * (3) the 'match' string is exactly the same as 'name'.  *  * and the return value tells which case it was.  *  * It returns 0 when there is no match.  */
end_comment
begin_function
DECL|function|match_one
specifier|static
name|int
name|match_one
parameter_list|(
specifier|const
name|char
modifier|*
name|match
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|int
name|matchlen
decl_stmt|;
name|int
name|literal
init|=
name|limit_pathspec_to_literal
argument_list|()
decl_stmt|;
comment|/* If the match was just the prefix, we matched */
if|if
condition|(
operator|!
operator|*
name|match
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
if|if
condition|(
name|ignore_case
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c1
init|=
name|tolower
argument_list|(
operator|*
name|match
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|c2
init|=
name|tolower
argument_list|(
operator|*
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'\0'
operator|||
operator|(
operator|!
name|literal
operator|&&
name|is_glob_special
argument_list|(
name|c1
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
literal|0
return|;
name|match
operator|++
expr_stmt|;
name|name
operator|++
expr_stmt|;
name|namelen
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c1
init|=
operator|*
name|match
decl_stmt|;
name|unsigned
name|char
name|c2
init|=
operator|*
name|name
decl_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'\0'
operator|||
operator|(
operator|!
name|literal
operator|&&
name|is_glob_special
argument_list|(
name|c1
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
literal|0
return|;
name|match
operator|++
expr_stmt|;
name|name
operator|++
expr_stmt|;
name|namelen
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * If we don't match the matchstring exactly, 	 * we need to match by fnmatch 	 */
name|matchlen
operator|=
name|strlen
argument_list|(
name|match
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp_icase
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
name|matchlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|literal
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|fnmatch_icase
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
condition|?
name|MATCHED_FNMATCH
else|:
literal|0
return|;
block|}
if|if
condition|(
name|namelen
operator|==
name|matchlen
condition|)
return|return
name|MATCHED_EXACTLY
return|;
if|if
condition|(
name|match
index|[
name|matchlen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
name|matchlen
index|]
operator|==
literal|'/'
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given a name and a list of pathspecs, returns the nature of the  * closest (i.e. most specific) match of the name to any of the  * pathspecs.  *  * The caller typically calls this multiple times with the same  * pathspec and seen[] array but with different name/namelen  * (e.g. entries from the index) and is interested in seeing if and  * how each pathspec matches all the names it calls this function  * with.  A mark is left in the seen[] array for each pathspec element  * indicating the closest type of match that element achieved, so if  * seen[n] remains zero after multiple invocations, that means the nth  * pathspec did not match any names, which could indicate that the  * user mistyped the nth pathspec.  */
end_comment
begin_function
DECL|function|match_pathspec
name|int
name|match_pathspec
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|prefix
parameter_list|,
name|char
modifier|*
name|seen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pathspec
condition|)
return|return
literal|1
return|;
name|name
operator|+=
name|prefix
expr_stmt|;
name|namelen
operator|-=
name|prefix
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pathspec
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|int
name|how
decl_stmt|;
specifier|const
name|char
modifier|*
name|match
init|=
name|pathspec
index|[
name|i
index|]
operator|+
name|prefix
decl_stmt|;
if|if
condition|(
name|seen
operator|&&
name|seen
index|[
name|i
index|]
operator|==
name|MATCHED_EXACTLY
condition|)
continue|continue;
name|how
operator|=
name|match_one
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
condition|)
block|{
if|if
condition|(
name|retval
operator|<
name|how
condition|)
name|retval
operator|=
name|how
expr_stmt|;
if|if
condition|(
name|seen
operator|&&
name|seen
index|[
name|i
index|]
operator|<
name|how
condition|)
name|seen
index|[
name|i
index|]
operator|=
name|how
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*  * Does 'match' match the given name?  * A match is found if  *  * (1) the 'match' string is leading directory of 'name', or  * (2) the 'match' string is a wildcard and matches 'name', or  * (3) the 'match' string is exactly the same as 'name'.  *  * and the return value tells which case it was.  *  * It returns 0 when there is no match.  */
end_comment
begin_function
DECL|function|match_pathspec_item
specifier|static
name|int
name|match_pathspec_item
parameter_list|(
specifier|const
name|struct
name|pathspec_item
modifier|*
name|item
parameter_list|,
name|int
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
comment|/* name/namelen has prefix cut off by caller */
specifier|const
name|char
modifier|*
name|match
init|=
name|item
operator|->
name|match
operator|+
name|prefix
decl_stmt|;
name|int
name|matchlen
init|=
name|item
operator|->
name|len
operator|-
name|prefix
decl_stmt|;
comment|/* If the match was just the prefix, we matched */
if|if
condition|(
operator|!
operator|*
name|match
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
if|if
condition|(
name|matchlen
operator|<=
name|namelen
operator|&&
operator|!
name|strncmp
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
name|matchlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|matchlen
operator|==
name|namelen
condition|)
return|return
name|MATCHED_EXACTLY
return|;
if|if
condition|(
name|match
index|[
name|matchlen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
name|matchlen
index|]
operator|==
literal|'/'
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
block|}
if|if
condition|(
name|item
operator|->
name|nowildcard_len
operator|<
name|item
operator|->
name|len
operator|&&
operator|!
name|git_fnmatch
argument_list|(
name|match
argument_list|,
name|name
argument_list|,
name|item
operator|->
name|flags
operator|&
name|PATHSPEC_ONESTAR
condition|?
name|GFNM_ONESTAR
else|:
literal|0
argument_list|,
name|item
operator|->
name|nowildcard_len
operator|-
name|prefix
argument_list|)
condition|)
return|return
name|MATCHED_FNMATCH
return|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given a name and a list of pathspecs, returns the nature of the  * closest (i.e. most specific) match of the name to any of the  * pathspecs.  *  * The caller typically calls this multiple times with the same  * pathspec and seen[] array but with different name/namelen  * (e.g. entries from the index) and is interested in seeing if and  * how each pathspec matches all the names it calls this function  * with.  A mark is left in the seen[] array for each pathspec element  * indicating the closest type of match that element achieved, so if  * seen[n] remains zero after multiple invocations, that means the nth  * pathspec did not match any names, which could indicate that the  * user mistyped the nth pathspec.  */
end_comment
begin_function
DECL|function|match_pathspec_depth
name|int
name|match_pathspec_depth
parameter_list|(
specifier|const
name|struct
name|pathspec
modifier|*
name|ps
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|prefix
parameter_list|,
name|char
modifier|*
name|seen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ps
operator|->
name|nr
condition|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|recursive
operator|||
name|ps
operator|->
name|max_depth
operator|==
operator|-
literal|1
condition|)
return|return
name|MATCHED_RECURSIVELY
return|;
if|if
condition|(
name|within_depth
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
literal|0
argument_list|,
name|ps
operator|->
name|max_depth
argument_list|)
condition|)
return|return
name|MATCHED_EXACTLY
return|;
else|else
return|return
literal|0
return|;
block|}
name|name
operator|+=
name|prefix
expr_stmt|;
name|namelen
operator|-=
name|prefix
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ps
operator|->
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|how
decl_stmt|;
if|if
condition|(
name|seen
operator|&&
name|seen
index|[
name|i
index|]
operator|==
name|MATCHED_EXACTLY
condition|)
continue|continue;
name|how
operator|=
name|match_pathspec_item
argument_list|(
name|ps
operator|->
name|items
operator|+
name|i
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|recursive
operator|&&
name|ps
operator|->
name|max_depth
operator|!=
operator|-
literal|1
operator|&&
name|how
operator|&&
name|how
operator|!=
name|MATCHED_FNMATCH
condition|)
block|{
name|int
name|len
init|=
name|ps
operator|->
name|items
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|name
index|[
name|len
index|]
operator|==
literal|'/'
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|within_depth
argument_list|(
name|name
operator|+
name|len
argument_list|,
name|namelen
operator|-
name|len
argument_list|,
literal|0
argument_list|,
name|ps
operator|->
name|max_depth
argument_list|)
condition|)
name|how
operator|=
name|MATCHED_EXACTLY
expr_stmt|;
else|else
name|how
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|how
condition|)
block|{
if|if
condition|(
name|retval
operator|<
name|how
condition|)
name|retval
operator|=
name|how
expr_stmt|;
if|if
condition|(
name|seen
operator|&&
name|seen
index|[
name|i
index|]
operator|<
name|how
condition|)
name|seen
index|[
name|i
index|]
operator|=
name|how
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function
begin_comment
comment|/*  * Return the length of the "simple" part of a path match limiter.  */
end_comment
begin_function
DECL|function|simple_length
specifier|static
name|int
name|simple_length
parameter_list|(
specifier|const
name|char
modifier|*
name|match
parameter_list|)
block|{
name|int
name|len
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|match
operator|++
decl_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|is_glob_special
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|len
return|;
block|}
block|}
end_function
begin_function
DECL|function|no_wildcard
specifier|static
name|int
name|no_wildcard
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|string
index|[
name|simple_length
argument_list|(
name|string
argument_list|)
index|]
operator|==
literal|'\0'
return|;
block|}
end_function
begin_function
DECL|function|parse_exclude_pattern
name|void
name|parse_exclude_pattern
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|,
name|int
modifier|*
name|patternlen
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|,
name|int
modifier|*
name|nowildcardlen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pattern
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
operator|*
name|flags
operator||=
name|EXC_FLAG_NEGATIVE
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|len
operator|--
expr_stmt|;
operator|*
name|flags
operator||=
name|EXC_FLAG_MUSTBEDIR
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
condition|)
operator|*
name|flags
operator||=
name|EXC_FLAG_NODIR
expr_stmt|;
operator|*
name|nowildcardlen
operator|=
name|simple_length
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * we should have excluded the trailing slash from 'p' too, 	 * but that's one more allocation. Instead just make sure 	 * nowildcardlen does not exceed real patternlen 	 */
if|if
condition|(
operator|*
name|nowildcardlen
operator|>
name|len
condition|)
operator|*
name|nowildcardlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|&&
name|no_wildcard
argument_list|(
name|p
operator|+
literal|1
argument_list|)
condition|)
operator|*
name|flags
operator||=
name|EXC_FLAG_ENDSWITH
expr_stmt|;
operator|*
name|pattern
operator|=
name|p
expr_stmt|;
operator|*
name|patternlen
operator|=
name|len
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_exclude
name|void
name|add_exclude
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|,
name|int
name|srcpos
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|x
decl_stmt|;
name|int
name|patternlen
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|nowildcardlen
decl_stmt|;
name|parse_exclude_pattern
argument_list|(
operator|&
name|string
argument_list|,
operator|&
name|patternlen
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|nowildcardlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EXC_FLAG_MUSTBEDIR
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
operator|+
name|patternlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|x
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|string
argument_list|,
name|patternlen
argument_list|)
expr_stmt|;
name|s
index|[
name|patternlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|x
operator|->
name|pattern
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|pattern
operator|=
name|string
expr_stmt|;
block|}
name|x
operator|->
name|patternlen
operator|=
name|patternlen
expr_stmt|;
name|x
operator|->
name|nowildcardlen
operator|=
name|nowildcardlen
expr_stmt|;
name|x
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|x
operator|->
name|baselen
operator|=
name|baselen
expr_stmt|;
name|x
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|x
operator|->
name|srcpos
operator|=
name|srcpos
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|el
operator|->
name|excludes
argument_list|,
name|el
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|el
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|el
operator|->
name|excludes
index|[
name|el
operator|->
name|nr
operator|++
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|el
operator|=
name|el
expr_stmt|;
block|}
end_function
begin_function
DECL|function|read_skip_worktree_file_from_index
specifier|static
name|void
modifier|*
name|read_skip_worktree_file_from_index
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|int
name|pos
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
name|enum
name|object_type
name|type
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|index_state
modifier|*
name|istate
init|=
operator|&
name|the_index
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|pos
operator|=
name|index_name_pos
argument_list|(
name|istate
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|ce_skip_worktree
argument_list|(
name|istate
operator|->
name|cache
index|[
name|pos
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
name|data
operator|=
name|read_sha1_file
argument_list|(
name|istate
operator|->
name|cache
index|[
name|pos
index|]
operator|->
name|sha1
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|||
name|type
operator|!=
name|OBJ_BLOB
condition|)
block|{
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|size
operator|=
name|xsize_t
argument_list|(
name|sz
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function
begin_comment
comment|/*  * Frees memory within el which was allocated for exclude patterns and  * the file buffer.  Does not free el itself.  */
end_comment
begin_function
DECL|function|clear_exclude_list
name|void
name|clear_exclude_list
parameter_list|(
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|nr
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|el
operator|->
name|excludes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|el
operator|->
name|excludes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|el
operator|->
name|filebuf
argument_list|)
expr_stmt|;
name|el
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|excludes
operator|=
name|NULL
expr_stmt|;
name|el
operator|->
name|filebuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|add_excludes_from_file_to_list
name|int
name|add_excludes_from_file_to_list
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|,
name|int
name|check_index
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|lineno
init|=
literal|1
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|warn_on_inaccessible
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_index
operator|||
operator|(
name|buf
operator|=
name|read_skip_worktree_file_from_index
argument_list|(
name|fname
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|buf
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|size
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
else|else
block|{
name|size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_in_full
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|buf
index|[
name|size
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|el
operator|->
name|filebuf
operator|=
name|buf
expr_stmt|;
name|entry
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|entry
operator|!=
name|buf
operator|+
name|i
operator|&&
name|entry
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|buf
index|[
name|i
operator|-
operator|(
name|i
operator|&&
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|add_exclude
argument_list|(
name|entry
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|,
name|el
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|lineno
operator|++
expr_stmt|;
name|entry
operator|=
name|buf
operator|+
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|add_exclude_list
name|struct
name|exclude_list
modifier|*
name|add_exclude_list
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|int
name|group_type
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|group_type
index|]
expr_stmt|;
name|ALLOC_GROW
argument_list|(
name|group
operator|->
name|el
argument_list|,
name|group
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|group
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|el
operator|=
operator|&
name|group
operator|->
name|el
index|[
name|group
operator|->
name|nr
operator|++
index|]
expr_stmt|;
name|memset
argument_list|(
name|el
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|el
argument_list|)
argument_list|)
expr_stmt|;
name|el
operator|->
name|src
operator|=
name|src
expr_stmt|;
return|return
name|el
return|;
block|}
end_function
begin_comment
comment|/*  * Used to set up core.excludesfile and .git/info/exclude lists.  */
end_comment
begin_function
DECL|function|add_excludes_from_file
name|void
name|add_excludes_from_file
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|el
operator|=
name|add_exclude_list
argument_list|(
name|dir
argument_list|,
name|EXC_FILE
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_excludes_from_file_to_list
argument_list|(
name|fname
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|el
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"cannot use %s as an exclude file"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * Loads the per-directory exclude list for the substring of base  * which has a char length of baselen.  */
end_comment
begin_function
DECL|function|prep_exclude
specifier|static
name|void
name|prep_exclude
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|)
block|{
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|struct
name|exclude_stack
modifier|*
name|stk
init|=
name|NULL
decl_stmt|;
name|int
name|current
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|dir
operator|->
name|exclude_per_dir
operator|)
operator|||
operator|(
name|baselen
operator|+
name|strlen
argument_list|(
name|dir
operator|->
name|exclude_per_dir
argument_list|)
operator|>=
name|PATH_MAX
operator|)
condition|)
return|return;
comment|/* too long a path -- ignore */
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|EXC_DIRS
index|]
expr_stmt|;
comment|/* Pop the exclude lists from the EXCL_DIRS exclude_list_group 	 * which originate from directories not in the prefix of the 	 * path being checked. */
while|while
condition|(
operator|(
name|stk
operator|=
name|dir
operator|->
name|exclude_stack
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stk
operator|->
name|baselen
operator|<=
name|baselen
operator|&&
operator|!
name|strncmp
argument_list|(
name|dir
operator|->
name|basebuf
argument_list|,
name|base
argument_list|,
name|stk
operator|->
name|baselen
argument_list|)
condition|)
break|break;
name|el
operator|=
operator|&
name|group
operator|->
name|el
index|[
name|dir
operator|->
name|exclude_stack
operator|->
name|exclude_ix
index|]
expr_stmt|;
name|dir
operator|->
name|exclude_stack
operator|=
name|stk
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|el
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* see strdup() below */
name|clear_exclude_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stk
argument_list|)
expr_stmt|;
name|group
operator|->
name|nr
operator|--
expr_stmt|;
block|}
comment|/* Read from the parent directories and push them down. */
name|current
operator|=
name|stk
condition|?
name|stk
operator|->
name|baselen
else|:
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|current
operator|<
name|baselen
condition|)
block|{
name|struct
name|exclude_stack
modifier|*
name|stk
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stk
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|current
operator|<
literal|0
condition|)
block|{
name|cp
operator|=
name|base
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|base
operator|+
name|current
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|die
argument_list|(
literal|"oops in prep_exclude"
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|stk
operator|->
name|prev
operator|=
name|dir
operator|->
name|exclude_stack
expr_stmt|;
name|stk
operator|->
name|baselen
operator|=
name|cp
operator|-
name|base
expr_stmt|;
name|memcpy
argument_list|(
name|dir
operator|->
name|basebuf
operator|+
name|current
argument_list|,
name|base
operator|+
name|current
argument_list|,
name|stk
operator|->
name|baselen
operator|-
name|current
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dir
operator|->
name|basebuf
operator|+
name|stk
operator|->
name|baselen
argument_list|,
name|dir
operator|->
name|exclude_per_dir
argument_list|)
expr_stmt|;
comment|/* 		 * dir->basebuf gets reused by the traversal, but we 		 * need fname to remain unchanged to ensure the src 		 * member of each struct exclude correctly 		 * back-references its source file.  Other invocations 		 * of add_exclude_list provide stable strings, so we 		 * strdup() and free() here in the caller. 		 */
name|el
operator|=
name|add_exclude_list
argument_list|(
name|dir
argument_list|,
name|EXC_DIRS
argument_list|,
name|strdup
argument_list|(
name|dir
operator|->
name|basebuf
argument_list|)
argument_list|)
expr_stmt|;
name|stk
operator|->
name|exclude_ix
operator|=
name|group
operator|->
name|nr
operator|-
literal|1
expr_stmt|;
name|add_excludes_from_file_to_list
argument_list|(
name|dir
operator|->
name|basebuf
argument_list|,
name|dir
operator|->
name|basebuf
argument_list|,
name|stk
operator|->
name|baselen
argument_list|,
name|el
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dir
operator|->
name|exclude_stack
operator|=
name|stk
expr_stmt|;
name|current
operator|=
name|stk
operator|->
name|baselen
expr_stmt|;
block|}
name|dir
operator|->
name|basebuf
index|[
name|baselen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function
begin_function
DECL|function|match_basename
name|int
name|match_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
name|basenamelen
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|prefix
parameter_list|,
name|int
name|patternlen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|==
name|patternlen
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp_icase
argument_list|(
name|pattern
argument_list|,
name|basename
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EXC_FLAG_ENDSWITH
condition|)
block|{
if|if
condition|(
name|patternlen
operator|-
literal|1
operator|<=
name|basenamelen
operator|&&
operator|!
name|strcmp_icase
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
name|basename
operator|+
name|basenamelen
operator|-
name|patternlen
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|fnmatch_icase
argument_list|(
name|pattern
argument_list|,
name|basename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|match_pathname
name|int
name|match_pathname
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|prefix
parameter_list|,
name|int
name|patternlen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
comment|/* 	 * match with FNM_PATHNAME; the pattern has base implicitly 	 * in front of it. 	 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'/'
condition|)
block|{
name|pattern
operator|++
expr_stmt|;
name|prefix
operator|--
expr_stmt|;
block|}
comment|/* 	 * baselen does not count the trailing slash. base[] may or 	 * may not end with a trailing slash though. 	 */
if|if
condition|(
name|pathlen
operator|<
name|baselen
operator|+
literal|1
operator|||
operator|(
name|baselen
operator|&&
name|pathname
index|[
name|baselen
index|]
operator|!=
literal|'/'
operator|)
operator|||
name|strncmp_icase
argument_list|(
name|pathname
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
condition|)
return|return
literal|0
return|;
name|namelen
operator|=
name|baselen
condition|?
name|pathlen
operator|-
name|baselen
operator|-
literal|1
else|:
name|pathlen
expr_stmt|;
name|name
operator|=
name|pathname
operator|+
name|pathlen
operator|-
name|namelen
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
comment|/* 		 * if the non-wildcard part is longer than the 		 * remaining pathname, surely it cannot match. 		 */
if|if
condition|(
name|prefix
operator|>
name|namelen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp_icase
argument_list|(
name|pattern
argument_list|,
name|name
argument_list|,
name|prefix
argument_list|)
condition|)
return|return
literal|0
return|;
name|pattern
operator|+=
name|prefix
expr_stmt|;
name|name
operator|+=
name|prefix
expr_stmt|;
name|namelen
operator|-=
name|prefix
expr_stmt|;
block|}
return|return
name|wildmatch
argument_list|(
name|pattern
argument_list|,
name|name
argument_list|,
name|WM_PATHNAME
operator||
operator|(
name|ignore_case
condition|?
name|WM_CASEFOLD
else|:
literal|0
operator|)
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Scan the given exclude list in reverse to see whether pathname  * should be ignored.  The first match (i.e. the last on the list), if  * any, determines the fate.  Returns the exclude_list element which  * matched, or NULL for undecided.  */
end_comment
begin_function
DECL|function|last_exclude_matching_from_list
specifier|static
name|struct
name|exclude
modifier|*
name|last_exclude_matching_from_list
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|el
operator|->
name|nr
condition|)
return|return
name|NULL
return|;
comment|/* undefined */
for|for
control|(
name|i
operator|=
name|el
operator|->
name|nr
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|exclude
modifier|*
name|x
init|=
name|el
operator|->
name|excludes
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|exclude
init|=
name|x
operator|->
name|pattern
decl_stmt|;
name|int
name|prefix
init|=
name|x
operator|->
name|nowildcardlen
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_MUSTBEDIR
condition|)
block|{
if|if
condition|(
operator|*
name|dtype
operator|==
name|DT_UNKNOWN
condition|)
operator|*
name|dtype
operator|=
name|get_dtype
argument_list|(
name|NULL
argument_list|,
name|pathname
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dtype
operator|!=
name|DT_DIR
condition|)
continue|continue;
block|}
if|if
condition|(
name|x
operator|->
name|flags
operator|&
name|EXC_FLAG_NODIR
condition|)
block|{
if|if
condition|(
name|match_basename
argument_list|(
name|basename
argument_list|,
name|pathlen
operator|-
operator|(
name|basename
operator|-
name|pathname
operator|)
argument_list|,
name|exclude
argument_list|,
name|prefix
argument_list|,
name|x
operator|->
name|patternlen
argument_list|,
name|x
operator|->
name|flags
argument_list|)
condition|)
return|return
name|x
return|;
continue|continue;
block|}
name|assert
argument_list|(
name|x
operator|->
name|baselen
operator|==
literal|0
operator|||
name|x
operator|->
name|base
index|[
name|x
operator|->
name|baselen
operator|-
literal|1
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_pathname
argument_list|(
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|x
operator|->
name|base
argument_list|,
name|x
operator|->
name|baselen
condition|?
name|x
operator|->
name|baselen
operator|-
literal|1
else|:
literal|0
argument_list|,
name|exclude
argument_list|,
name|prefix
argument_list|,
name|x
operator|->
name|patternlen
argument_list|,
name|x
operator|->
name|flags
argument_list|)
condition|)
return|return
name|x
return|;
block|}
return|return
name|NULL
return|;
comment|/* undecided */
block|}
end_function
begin_comment
comment|/*  * Scan the list and let the last match determine the fate.  * Return 1 for exclude, 0 for include and -1 for undecided.  */
end_comment
begin_function
DECL|function|is_excluded_from_list
name|int
name|is_excluded_from_list
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|char
modifier|*
name|basename
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|,
name|struct
name|exclude_list
modifier|*
name|el
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|exclude
decl_stmt|;
name|exclude
operator|=
name|last_exclude_matching_from_list
argument_list|(
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|basename
argument_list|,
name|dtype
argument_list|,
name|el
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclude
condition|)
return|return
name|exclude
operator|->
name|flags
operator|&
name|EXC_FLAG_NEGATIVE
condition|?
literal|0
else|:
literal|1
return|;
return|return
operator|-
literal|1
return|;
comment|/* undecided */
block|}
end_function
begin_comment
comment|/*  * Loads the exclude lists for the directory containing pathname, then  * scans all exclude lists to determine whether pathname is excluded.  * Returns the exclude_list element which matched, or NULL for  * undecided.  */
end_comment
begin_function
DECL|function|last_exclude_matching
specifier|static
name|struct
name|exclude
modifier|*
name|last_exclude_matching
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
modifier|*
name|dtype_p
parameter_list|)
block|{
name|int
name|pathlen
init|=
name|strlen
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|struct
name|exclude
modifier|*
name|exclude
decl_stmt|;
specifier|const
name|char
modifier|*
name|basename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|basename
operator|=
operator|(
name|basename
operator|)
condition|?
name|basename
operator|+
literal|1
else|:
name|pathname
expr_stmt|;
name|prep_exclude
argument_list|(
name|dir
argument_list|,
name|pathname
argument_list|,
name|basename
operator|-
name|pathname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|EXC_CMDL
init|;
name|i
operator|<=
name|EXC_FILE
condition|;
name|i
operator|++
control|)
block|{
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|group
operator|->
name|nr
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|exclude
operator|=
name|last_exclude_matching_from_list
argument_list|(
name|pathname
argument_list|,
name|pathlen
argument_list|,
name|basename
argument_list|,
name|dtype_p
argument_list|,
operator|&
name|group
operator|->
name|el
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclude
condition|)
return|return
name|exclude
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*  * Loads the exclude lists for the directory containing pathname, then  * scans all exclude lists to determine whether pathname is excluded.  * Returns 1 if true, otherwise 0.  */
end_comment
begin_function
DECL|function|is_excluded
specifier|static
name|int
name|is_excluded
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
modifier|*
name|dtype_p
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|exclude
init|=
name|last_exclude_matching
argument_list|(
name|dir
argument_list|,
name|pathname
argument_list|,
name|dtype_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|exclude
condition|)
return|return
name|exclude
operator|->
name|flags
operator|&
name|EXC_FLAG_NEGATIVE
condition|?
literal|0
else|:
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|path_exclude_check_init
name|void
name|path_exclude_check_init
parameter_list|(
name|struct
name|path_exclude_check
modifier|*
name|check
parameter_list|,
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|)
block|{
name|check
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|check
operator|->
name|exclude
operator|=
name|NULL
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|check
operator|->
name|path
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|path_exclude_check_clear
name|void
name|path_exclude_check_clear
parameter_list|(
name|struct
name|path_exclude_check
modifier|*
name|check
parameter_list|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|check
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  * For each subdirectory in name, starting with the top-most, checks  * to see if that subdirectory is excluded, and if so, returns the  * corresponding exclude structure.  Otherwise, checks whether name  * itself (which is presumably a file) is excluded.  *  * A path to a directory known to be excluded is left in check->path to  * optimize for repeated checks for files in the same excluded directory.  */
end_comment
begin_function
DECL|function|last_exclude_matching_path
name|struct
name|exclude
modifier|*
name|last_exclude_matching_path
parameter_list|(
name|struct
name|path_exclude_check
modifier|*
name|check
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|strbuf
modifier|*
name|path
init|=
operator|&
name|check
operator|->
name|path
decl_stmt|;
name|struct
name|exclude
modifier|*
name|exclude
decl_stmt|;
comment|/* 	 * we allow the caller to pass namelen as an optimization; it 	 * must match the length of the name, as we eventually call 	 * is_excluded() on the whole name string. 	 */
if|if
condition|(
name|namelen
operator|<
literal|0
condition|)
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * If path is non-empty, and name is equal to path or a 	 * subdirectory of path, name should be excluded, because 	 * it's inside a directory which is already known to be 	 * excluded and was previously left in check->path. 	 */
if|if
condition|(
name|path
operator|->
name|len
operator|&&
name|path
operator|->
name|len
operator|<=
name|namelen
operator|&&
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|)
operator|&&
operator|(
operator|!
name|name
index|[
name|path
operator|->
name|len
index|]
operator|||
name|name
index|[
name|path
operator|->
name|len
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|check
operator|->
name|exclude
return|;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
init|=
name|name
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
name|int
name|dt
init|=
name|DT_DIR
decl_stmt|;
name|exclude
operator|=
name|last_exclude_matching
argument_list|(
name|check
operator|->
name|dir
argument_list|,
name|path
operator|->
name|buf
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclude
condition|)
block|{
name|check
operator|->
name|exclude
operator|=
name|exclude
expr_stmt|;
return|return
name|exclude
return|;
block|}
block|}
name|strbuf_addch
argument_list|(
name|path
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* An entry in the index; cannot be a directory with subentries */
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|last_exclude_matching
argument_list|(
name|check
operator|->
name|dir
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Is this name excluded?  This is for a caller like show_files() that  * do not honor directory hierarchy and iterate through paths that are  * possibly in an ignored directory.  */
end_comment
begin_function
DECL|function|is_path_excluded
name|int
name|is_path_excluded
parameter_list|(
name|struct
name|path_exclude_check
modifier|*
name|check
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|)
block|{
name|struct
name|exclude
modifier|*
name|exclude
init|=
name|last_exclude_matching_path
argument_list|(
name|check
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|dtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|exclude
condition|)
return|return
name|exclude
operator|->
name|flags
operator|&
name|EXC_FLAG_NEGATIVE
condition|?
literal|0
else|:
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|dir_entry_new
specifier|static
name|struct
name|dir_entry
modifier|*
name|dir_entry_new
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|dir_entry
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ent
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ent
operator|->
name|name
argument_list|,
name|pathname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|ent
return|;
block|}
end_function
begin_function
DECL|function|dir_add_name
specifier|static
name|struct
name|dir_entry
modifier|*
name|dir_add_name
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
operator|)
operator|&&
name|cache_name_exists
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|,
name|ignore_case
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|entries
argument_list|,
name|dir
operator|->
name|nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|alloc
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|entries
index|[
name|dir
operator|->
name|nr
operator|++
index|]
operator|=
name|dir_entry_new
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|dir_add_ignored
name|struct
name|dir_entry
modifier|*
name|dir_add_ignored
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cache_name_is_other
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ALLOC_GROW
argument_list|(
name|dir
operator|->
name|ignored
argument_list|,
name|dir
operator|->
name|ignored_nr
operator|+
literal|1
argument_list|,
name|dir
operator|->
name|ignored_alloc
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|ignored
index|[
name|dir
operator|->
name|ignored_nr
operator|++
index|]
operator|=
name|dir_entry_new
argument_list|(
name|pathname
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function
begin_enum
DECL|enum|exist_status
enum|enum
name|exist_status
block|{
DECL|enumerator|index_nonexistent
name|index_nonexistent
init|=
literal|0
block|,
DECL|enumerator|index_directory
name|index_directory
block|,
DECL|enumerator|index_gitdir
name|index_gitdir
block|}
enum|;
end_enum
begin_comment
comment|/*  * Do not use the alphabetically stored index to look up  * the directory name; instead, use the case insensitive  * name hash.  */
end_comment
begin_function
DECL|function|directory_exists_in_index_icase
specifier|static
name|enum
name|exist_status
name|directory_exists_in_index_icase
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|index_name_exists
argument_list|(
operator|&
name|the_index
argument_list|,
name|dirname
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|ignore_case
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|endchar
decl_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return
name|index_nonexistent
return|;
name|endchar
operator|=
name|ce
operator|->
name|name
index|[
name|len
index|]
expr_stmt|;
comment|/* 	 * The cache_entry structure returned will contain this dirname 	 * and possibly additional path components. 	 */
if|if
condition|(
name|endchar
operator|==
literal|'/'
condition|)
return|return
name|index_directory
return|;
comment|/* 	 * If there are no additional path components, then this cache_entry 	 * represents a submodule.  Submodules, despite being directories, 	 * are stored in the cache without a closing slash. 	 */
if|if
condition|(
operator|!
name|endchar
operator|&&
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
return|return
name|index_gitdir
return|;
comment|/* This should never be hit, but it exists just in case. */
return|return
name|index_nonexistent
return|;
block|}
end_function
begin_comment
comment|/*  * The index sorts alphabetically by entry name, which  * means that a gitlink sorts as '\0' at the end, while  * a directory (which is defined not as an entry, but as  * the files it contains) will sort with the '/' at the  * end.  */
end_comment
begin_function
DECL|function|directory_exists_in_index
specifier|static
name|enum
name|exist_status
name|directory_exists_in_index
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|ignore_case
condition|)
return|return
name|directory_exists_in_index_icase
argument_list|(
name|dirname
argument_list|,
name|len
argument_list|)
return|;
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|dirname
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
condition|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|pos
operator|++
index|]
decl_stmt|;
name|unsigned
name|char
name|endchar
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|)
condition|)
break|break;
name|endchar
operator|=
name|ce
operator|->
name|name
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|endchar
operator|>
literal|'/'
condition|)
break|break;
if|if
condition|(
name|endchar
operator|==
literal|'/'
condition|)
return|return
name|index_directory
return|;
if|if
condition|(
operator|!
name|endchar
operator|&&
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
return|return
name|index_gitdir
return|;
block|}
return|return
name|index_nonexistent
return|;
block|}
end_function
begin_comment
comment|/*  * When we find a directory when traversing the filesystem, we  * have three distinct cases:  *  *  - ignore it  *  - see it as a directory  *  - recurse into it  *  * and which one we choose depends on a combination of existing  * git index contents and the flags passed into the directory  * traversal routine.  *  * Case 1: If we *already* have entries in the index under that  * directory name, we recurse into the directory to see all the files,  * unless the directory is excluded and we want to show ignored  * directories  *  * Case 2: If we *already* have that directory name as a gitlink,  * we always continue to see it as a gitlink, regardless of whether  * there is an actual git directory there or not (it might not  * be checked out as a subproject!)  *  * Case 3: if we didn't have it in the index previously, we  * have a few sub-cases:  *  *  (a) if "show_other_directories" is true, we show it as  *      just a directory, unless "hide_empty_directories" is  *      also true and the directory is empty, in which case  *      we just ignore it entirely.  *      if we are looking for ignored directories, look if it  *      contains only ignored files to decide if it must be shown as  *      ignored or not.  *  (b) if it looks like a git directory, and we don't have  *      'no_gitlinks' set we treat it as a gitlink, and show it  *      as a directory.  *  (c) otherwise, we recurse into it.  */
end_comment
begin_enum
DECL|enum|directory_treatment
enum|enum
name|directory_treatment
block|{
DECL|enumerator|show_directory
name|show_directory
block|,
DECL|enumerator|ignore_directory
name|ignore_directory
block|,
DECL|enumerator|recurse_into_directory
name|recurse_into_directory
block|}
enum|;
end_enum
begin_function
DECL|function|treat_directory
specifier|static
name|enum
name|directory_treatment
name|treat_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|exclude
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
comment|/* The "len-1" is to strip the final '/' */
switch|switch
condition|(
name|directory_exists_in_index
argument_list|(
name|dirname
argument_list|,
name|len
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
name|index_directory
case|:
if|if
condition|(
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_OTHER_DIRECTORIES
operator|)
operator|&&
name|exclude
condition|)
break|break;
return|return
name|recurse_into_directory
return|;
case|case
name|index_gitdir
case|:
if|if
condition|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_OTHER_DIRECTORIES
condition|)
return|return
name|ignore_directory
return|;
return|return
name|show_directory
return|;
case|case
name|index_nonexistent
case|:
if|if
condition|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_OTHER_DIRECTORIES
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_NO_GITLINKS
operator|)
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|resolve_gitlink_ref
argument_list|(
name|dirname
argument_list|,
literal|"HEAD"
argument_list|,
name|sha1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|show_directory
return|;
block|}
return|return
name|recurse_into_directory
return|;
block|}
comment|/* This is the "show_other_directories" case */
comment|/* 	 * We are looking for ignored files and our directory is not ignored, 	 * check if it contains only ignored files 	 */
if|if
condition|(
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
operator|)
operator|&&
operator|!
name|exclude
condition|)
block|{
name|int
name|ignored
decl_stmt|;
name|dir
operator|->
name|flags
operator|&=
operator|~
name|DIR_SHOW_IGNORED
expr_stmt|;
name|dir
operator|->
name|flags
operator||=
name|DIR_HIDE_EMPTY_DIRECTORIES
expr_stmt|;
name|ignored
operator|=
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
name|dir
operator|->
name|flags
operator|&=
operator|~
name|DIR_HIDE_EMPTY_DIRECTORIES
expr_stmt|;
name|dir
operator|->
name|flags
operator||=
name|DIR_SHOW_IGNORED
expr_stmt|;
return|return
name|ignored
condition|?
name|ignore_directory
else|:
name|show_directory
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
operator|)
operator|&&
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_HIDE_EMPTY_DIRECTORIES
operator|)
condition|)
return|return
name|show_directory
return|;
if|if
condition|(
operator|!
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|dirname
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|simplify
argument_list|)
condition|)
return|return
name|ignore_directory
return|;
return|return
name|show_directory
return|;
block|}
end_function
begin_comment
comment|/*  * Decide what to do when we find a file while traversing the  * filesystem. Mostly two cases:  *  *  1. We are looking for ignored files  *   (a) File is ignored, include it  *   (b) File is in ignored path, include it  *   (c) File is not ignored, exclude it  *  *  2. Other scenarios, include the file if not excluded  *  * Return 1 for exclude, 0 for include.  */
end_comment
begin_function
DECL|function|treat_file
specifier|static
name|int
name|treat_file
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|exclude
parameter_list|,
name|int
modifier|*
name|dtype
parameter_list|)
block|{
name|struct
name|path_exclude_check
name|check
decl_stmt|;
name|int
name|exclude_file
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exclude
condition|)
name|exclude_file
operator|=
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
condition|)
block|{
comment|/* Always exclude indexed files */
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|index_name_exists
argument_list|(
operator|&
name|the_index
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|ignore_case
argument_list|)
decl_stmt|;
if|if
condition|(
name|ce
condition|)
return|return
literal|1
return|;
name|path_exclude_check_init
argument_list|(
operator|&
name|check
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_path_excluded
argument_list|(
operator|&
name|check
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|dtype
argument_list|)
condition|)
name|exclude_file
operator|=
literal|1
expr_stmt|;
name|path_exclude_check_clear
argument_list|(
operator|&
name|check
argument_list|)
expr_stmt|;
block|}
return|return
name|exclude_file
return|;
block|}
end_function
begin_comment
comment|/*  * This is an inexact early pruning of any recursive directory  * reading - if the path cannot possibly be in the pathspec,  * return true, and we'll skip it early.  */
end_comment
begin_function
DECL|function|simplify_away
specifier|static
name|int
name|simplify_away
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|pathlen
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
if|if
condition|(
name|simplify
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|match
init|=
name|simplify
operator|->
name|path
decl_stmt|;
name|int
name|len
init|=
name|simplify
operator|->
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
if|if
condition|(
name|len
operator|>
name|pathlen
condition|)
name|len
operator|=
name|pathlen
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|match
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
name|simplify
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * This function tells us whether an excluded path matches a  * list of "interesting" pathspecs. That is, whether a path matched  * by any of the pathspecs could possibly be ignored by excluding  * the specified path. This can happen if:  *  *   1. the path is mentioned explicitly in the pathspec  *  *   2. the path is a directory prefix of some element in the  *      pathspec  */
end_comment
begin_function
DECL|function|exclude_matches_pathspec
specifier|static
name|int
name|exclude_matches_pathspec
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
if|if
condition|(
name|simplify
condition|)
block|{
for|for
control|(
init|;
name|simplify
operator|->
name|path
condition|;
name|simplify
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|==
name|simplify
operator|->
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|simplify
operator|->
name|path
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<
name|simplify
operator|->
name|len
operator|&&
name|simplify
operator|->
name|path
index|[
name|len
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|memcmp
argument_list|(
name|path
argument_list|,
name|simplify
operator|->
name|path
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_index_dtype
specifier|static
name|int
name|get_index_dtype
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|struct
name|cache_entry
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|cache_name_exists
argument_list|(
name|path
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
condition|)
block|{
if|if
condition|(
operator|!
name|ce_uptodate
argument_list|(
name|ce
argument_list|)
condition|)
return|return
name|DT_UNKNOWN
return|;
if|if
condition|(
name|S_ISGITLINK
argument_list|(
name|ce
operator|->
name|ce_mode
argument_list|)
condition|)
return|return
name|DT_DIR
return|;
comment|/* 		 * Nobody actually cares about the 		 * difference between DT_LNK and DT_REG 		 */
return|return
name|DT_REG
return|;
block|}
comment|/* Try to look it up as a directory */
name|pos
operator|=
name|cache_name_pos
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
return|return
name|DT_UNKNOWN
return|;
name|pos
operator|=
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|active_nr
condition|)
block|{
name|ce
operator|=
name|active_cache
index|[
name|pos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ce
operator|->
name|name
index|[
name|len
index|]
operator|>
literal|'/'
condition|)
break|break;
if|if
condition|(
name|ce
operator|->
name|name
index|[
name|len
index|]
operator|<
literal|'/'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ce_uptodate
argument_list|(
name|ce
argument_list|)
condition|)
break|break;
comment|/* continue? */
return|return
name|DT_DIR
return|;
block|}
return|return
name|DT_UNKNOWN
return|;
block|}
end_function
begin_function
DECL|function|get_dtype
specifier|static
name|int
name|get_dtype
parameter_list|(
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|dtype
init|=
name|de
condition|?
name|DTYPE
argument_list|(
name|de
argument_list|)
else|:
name|DT_UNKNOWN
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|DT_UNKNOWN
condition|)
return|return
name|dtype
return|;
name|dtype
operator|=
name|get_index_dtype
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|DT_UNKNOWN
condition|)
return|return
name|dtype
return|;
if|if
condition|(
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
name|dtype
return|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_REG
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_DIR
return|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|DT_LNK
return|;
return|return
name|dtype
return|;
block|}
end_function
begin_enum
DECL|enum|path_treatment
enum|enum
name|path_treatment
block|{
DECL|enumerator|path_ignored
name|path_ignored
block|,
DECL|enumerator|path_handled
name|path_handled
block|,
DECL|enumerator|path_recurse
name|path_recurse
block|}
enum|;
end_enum
begin_function
DECL|function|treat_one_path
specifier|static
name|enum
name|path_treatment
name|treat_one_path
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|,
name|int
name|dtype
parameter_list|,
name|struct
name|dirent
modifier|*
name|de
parameter_list|)
block|{
name|int
name|exclude
init|=
name|is_excluded
argument_list|(
name|dir
argument_list|,
name|path
operator|->
name|buf
argument_list|,
operator|&
name|dtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|exclude
operator|&&
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_COLLECT_IGNORED
operator|)
operator|&&
name|exclude_matches_pathspec
argument_list|(
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
name|dir_add_ignored
argument_list|(
name|dir
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Excluded? If we don't explicitly want to show 	 * ignored files, ignore it 	 */
if|if
condition|(
name|exclude
operator|&&
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|DIR_SHOW_IGNORED
operator|)
condition|)
return|return
name|path_ignored
return|;
if|if
condition|(
name|dtype
operator|==
name|DT_UNKNOWN
condition|)
name|dtype
operator|=
name|get_dtype
argument_list|(
name|de
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dtype
condition|)
block|{
default|default:
return|return
name|path_ignored
return|;
case|case
name|DT_DIR
case|:
name|strbuf_addch
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|treat_directory
argument_list|(
name|dir
argument_list|,
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|exclude
argument_list|,
name|simplify
argument_list|)
condition|)
block|{
case|case
name|show_directory
case|:
break|break;
case|case
name|recurse_into_directory
case|:
return|return
name|path_recurse
return|;
case|case
name|ignore_directory
case|:
return|return
name|path_ignored
return|;
block|}
break|break;
case|case
name|DT_REG
case|:
case|case
name|DT_LNK
case|:
switch|switch
condition|(
name|treat_file
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|exclude
argument_list|,
operator|&
name|dtype
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|path_ignored
return|;
default|default:
break|break;
block|}
block|}
return|return
name|path_handled
return|;
block|}
end_function
begin_function
DECL|function|treat_path
specifier|static
name|enum
name|path_treatment
name|treat_path
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
name|struct
name|dirent
modifier|*
name|de
parameter_list|,
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|baselen
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|int
name|dtype
decl_stmt|;
if|if
condition|(
name|is_dot_or_dotdot
argument_list|(
name|de
operator|->
name|d_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
literal|".git"
argument_list|)
condition|)
return|return
name|path_ignored
return|;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|path
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|simplify_away
argument_list|(
name|path
operator|->
name|buf
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
return|return
name|path_ignored
return|;
name|dtype
operator|=
name|DTYPE
argument_list|(
name|de
argument_list|)
expr_stmt|;
return|return
name|treat_one_path
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|simplify
argument_list|,
name|dtype
argument_list|,
name|de
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*  * Read a directory tree. We currently ignore anything but  * directories, regular files and symlinks. That's because git  * doesn't handle them at all yet. Maybe that will change some  * day.  *  * Also, we ignore the name ".git" (even if it is not a directory).  * That likely will not change.  */
end_comment
begin_function
DECL|function|read_directory_recursive
specifier|static
name|int
name|read_directory_recursive
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|baselen
parameter_list|,
name|int
name|check_only
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|DIR
modifier|*
name|fdir
decl_stmt|;
name|int
name|contents
init|=
literal|0
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|struct
name|strbuf
name|path
init|=
name|STRBUF_INIT
decl_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|path
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
name|fdir
operator|=
name|opendir
argument_list|(
name|path
operator|.
name|len
condition|?
name|path
operator|.
name|buf
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdir
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|fdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|treat_path
argument_list|(
name|dir
argument_list|,
name|de
argument_list|,
operator|&
name|path
argument_list|,
name|baselen
argument_list|,
name|simplify
argument_list|)
condition|)
block|{
case|case
name|path_recurse
case|:
name|contents
operator|+=
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|path
operator|.
name|buf
argument_list|,
name|path
operator|.
name|len
argument_list|,
literal|0
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|path_ignored
case|:
continue|continue;
case|case
name|path_handled
case|:
break|break;
block|}
name|contents
operator|++
expr_stmt|;
if|if
condition|(
name|check_only
condition|)
break|break;
name|dir_add_name
argument_list|(
name|dir
argument_list|,
name|path
operator|.
name|buf
argument_list|,
name|path
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|fdir
argument_list|)
expr_stmt|;
name|out
label|:
name|strbuf_release
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
name|contents
return|;
block|}
end_function
begin_function
DECL|function|cmp_name
specifier|static
name|int
name|cmp_name
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|dir_entry
modifier|*
name|e1
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dir_entry
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|dir_entry
modifier|*
name|e2
init|=
operator|*
operator|(
specifier|const
expr|struct
name|dir_entry
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|cache_name_compare
argument_list|(
name|e1
operator|->
name|name
argument_list|,
name|e1
operator|->
name|len
argument_list|,
name|e2
operator|->
name|name
argument_list|,
name|e2
operator|->
name|len
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|create_simplify
specifier|static
name|struct
name|path_simplify
modifier|*
name|create_simplify
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|int
name|nr
decl_stmt|,
name|alloc
init|=
literal|0
decl_stmt|;
name|struct
name|path_simplify
modifier|*
name|simplify
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pathspec
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
condition|;
name|nr
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|match
decl_stmt|;
if|if
condition|(
name|nr
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|=
name|alloc_nr
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|simplify
operator|=
name|xrealloc
argument_list|(
name|simplify
argument_list|,
name|alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|simplify
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|match
operator|=
operator|*
name|pathspec
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
name|simplify
index|[
name|nr
index|]
operator|.
name|path
operator|=
name|match
expr_stmt|;
name|simplify
index|[
name|nr
index|]
operator|.
name|len
operator|=
name|simple_length
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
name|simplify
index|[
name|nr
index|]
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
name|simplify
index|[
name|nr
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|simplify
return|;
block|}
end_function
begin_function
DECL|function|free_simplify
specifier|static
name|void
name|free_simplify
parameter_list|(
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|free
argument_list|(
name|simplify
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|treat_leading_path
specifier|static
name|int
name|treat_leading_path
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|struct
name|path_simplify
modifier|*
name|simplify
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|baselen
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
while|while
condition|(
name|len
operator|&&
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|1
return|;
name|baselen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|cp
operator|=
name|path
operator|+
name|baselen
operator|+
operator|!
operator|!
name|baselen
expr_stmt|;
name|cp
operator|=
name|memchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|,
name|path
operator|+
name|len
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|baselen
operator|=
name|len
expr_stmt|;
else|else
name|baselen
operator|=
name|cp
operator|-
name|path
expr_stmt|;
name|strbuf_setlen
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|path
argument_list|,
name|baselen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_directory
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
condition|)
break|break;
if|if
condition|(
name|simplify_away
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
break|break;
if|if
condition|(
name|treat_one_path
argument_list|(
name|dir
argument_list|,
operator|&
name|sb
argument_list|,
name|simplify
argument_list|,
name|DT_DIR
argument_list|,
name|NULL
argument_list|)
operator|==
name|path_ignored
condition|)
break|break;
comment|/* do not recurse into it */
if|if
condition|(
name|len
operator|<=
name|baselen
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* finished checking */
block|}
block|}
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|read_directory
name|int
name|read_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
parameter_list|)
block|{
name|struct
name|path_simplify
modifier|*
name|simplify
decl_stmt|;
if|if
condition|(
name|has_symlink_leading_path
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|dir
operator|->
name|nr
return|;
name|simplify
operator|=
name|create_simplify
argument_list|(
name|pathspec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|treat_leading_path
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|len
argument_list|,
name|simplify
argument_list|)
condition|)
name|read_directory_recursive
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|simplify
argument_list|)
expr_stmt|;
name|free_simplify
argument_list|(
name|simplify
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|dir
operator|->
name|entries
argument_list|,
name|dir
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir_entry
operator|*
argument_list|)
argument_list|,
name|cmp_name
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|dir
operator|->
name|ignored
argument_list|,
name|dir
operator|->
name|ignored_nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir_entry
operator|*
argument_list|)
argument_list|,
name|cmp_name
argument_list|)
expr_stmt|;
return|return
name|dir
operator|->
name|nr
return|;
block|}
end_function
begin_function
DECL|function|file_exists
name|int
name|file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
return|return
name|lstat
argument_list|(
name|f
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_comment
comment|/*  * Given two normalized paths (a trailing slash is ok), if subdir is  * outside dir, return -1.  Otherwise return the offset in subdir that  * can be used as relative path to dir.  */
end_comment
begin_function
DECL|function|dir_inside_of
name|int
name|dir_inside_of
parameter_list|(
specifier|const
name|char
modifier|*
name|subdir
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|dir
operator|&&
name|subdir
operator|&&
operator|*
name|dir
operator|&&
operator|*
name|subdir
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|dir
operator|&&
operator|*
name|subdir
operator|&&
operator|*
name|dir
operator|==
operator|*
name|subdir
condition|)
block|{
name|dir
operator|++
expr_stmt|;
name|subdir
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
comment|/* hel[p]/me vs hel[l]/yeah */
if|if
condition|(
operator|*
name|dir
operator|&&
operator|*
name|subdir
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|subdir
condition|)
return|return
operator|!
operator|*
name|dir
condition|?
name|offset
else|:
operator|-
literal|1
return|;
comment|/* same dir */
comment|/* foo/[b]ar vs foo/[] */
if|if
condition|(
name|is_dir_sep
argument_list|(
name|dir
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
name|is_dir_sep
argument_list|(
name|subdir
index|[
operator|-
literal|1
index|]
argument_list|)
condition|?
name|offset
else|:
operator|-
literal|1
return|;
comment|/* foo[/]bar vs foo[] */
return|return
name|is_dir_sep
argument_list|(
operator|*
name|subdir
argument_list|)
condition|?
name|offset
operator|+
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|is_inside_dir
name|int
name|is_inside_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|char
name|cwd
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|cwd
argument_list|)
argument_list|)
condition|)
name|die_errno
argument_list|(
literal|"can't find the current directory"
argument_list|)
expr_stmt|;
return|return
name|dir_inside_of
argument_list|(
name|cwd
argument_list|,
name|dir
argument_list|)
operator|>=
literal|0
return|;
block|}
end_function
begin_function
DECL|function|is_empty_dir
name|int
name|is_empty_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|DIR
modifier|*
name|dir
init|=
name|opendir
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|is_dot_or_dotdot
argument_list|(
name|e
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|remove_dir_recurse
specifier|static
name|int
name|remove_dir_recurse
parameter_list|(
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
modifier|*
name|kept_up
parameter_list|)
block|{
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|original_len
init|=
name|path
operator|->
name|len
decl_stmt|,
name|len
decl_stmt|,
name|kept_down
init|=
literal|0
decl_stmt|;
name|int
name|only_empty
init|=
operator|(
name|flag
operator|&
name|REMOVE_DIR_EMPTY_ONLY
operator|)
decl_stmt|;
name|int
name|keep_toplevel
init|=
operator|(
name|flag
operator|&
name|REMOVE_DIR_KEEP_TOPLEVEL
operator|)
decl_stmt|;
name|unsigned
name|char
name|submodule_head
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|REMOVE_DIR_KEEP_NESTED_GIT
operator|)
operator|&&
operator|!
name|resolve_gitlink_ref
argument_list|(
name|path
operator|->
name|buf
argument_list|,
literal|"HEAD"
argument_list|,
name|submodule_head
argument_list|)
condition|)
block|{
comment|/* Do not descend and nuke a nested git work tree. */
if|if
condition|(
name|kept_up
condition|)
operator|*
name|kept_up
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|flag
operator|&=
operator|~
name|REMOVE_DIR_KEEP_TOPLEVEL
expr_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
block|{
comment|/* an empty dir could be removed even if it is unreadble */
if|if
condition|(
operator|!
name|keep_toplevel
condition|)
return|return
name|rmdir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|path
operator|->
name|buf
index|[
name|original_len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strbuf_addch
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|len
operator|=
name|path
operator|->
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|is_dot_or_dotdot
argument_list|(
name|e
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|path
argument_list|,
name|e
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|path
operator|->
name|buf
argument_list|,
operator|&
name|st
argument_list|)
condition|)
empty_stmt|;
comment|/* fall thru */
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|remove_dir_recurse
argument_list|(
name|path
argument_list|,
name|flag
argument_list|,
operator|&
name|kept_down
argument_list|)
condition|)
continue|continue;
comment|/* happy */
block|}
elseif|else
if|if
condition|(
operator|!
name|only_empty
operator|&&
operator|!
name|unlink
argument_list|(
name|path
operator|->
name|buf
argument_list|)
condition|)
continue|continue;
comment|/* happy, too */
comment|/* path too long, stat fails, or non-directory still exists */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|strbuf_setlen
argument_list|(
name|path
argument_list|,
name|original_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|!
name|keep_toplevel
operator|&&
operator|!
name|kept_down
condition|)
name|ret
operator|=
name|rmdir
argument_list|(
name|path
operator|->
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kept_up
condition|)
comment|/* 		 * report the uplevel that it is not an error that we 		 * did not rmdir() our directory. 		 */
operator|*
name|kept_up
operator|=
operator|!
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|remove_dir_recursively
name|int
name|remove_dir_recursively
parameter_list|(
name|struct
name|strbuf
modifier|*
name|path
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
name|remove_dir_recurse
argument_list|(
name|path
argument_list|,
name|flag
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setup_standard_excludes
name|void
name|setup_standard_excludes
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|xdg_path
decl_stmt|;
name|dir
operator|->
name|exclude_per_dir
operator|=
literal|".gitignore"
expr_stmt|;
name|path
operator|=
name|git_path
argument_list|(
literal|"info/exclude"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|excludes_file
condition|)
block|{
name|home_config_paths
argument_list|(
name|NULL
argument_list|,
operator|&
name|xdg_path
argument_list|,
literal|"ignore"
argument_list|)
expr_stmt|;
name|excludes_file
operator|=
name|xdg_path
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|access_or_warn
argument_list|(
name|path
argument_list|,
name|R_OK
argument_list|)
condition|)
name|add_excludes_from_file
argument_list|(
name|dir
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|excludes_file
operator|&&
operator|!
name|access_or_warn
argument_list|(
name|excludes_file
argument_list|,
name|R_OK
argument_list|)
condition|)
name|add_excludes_from_file
argument_list|(
name|dir
argument_list|,
name|excludes_file
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|remove_path
name|int
name|remove_path
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
name|slash
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
block|{
name|char
modifier|*
name|dirs
init|=
name|xstrdup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|slash
operator|=
name|dirs
operator|+
operator|(
name|slash
operator|-
name|name
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
name|rmdir
argument_list|(
name|dirs
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|slash
operator|=
name|strrchr
argument_list|(
name|dirs
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
do|;
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|pathspec_item_cmp
specifier|static
name|int
name|pathspec_item_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a_
parameter_list|,
specifier|const
name|void
modifier|*
name|b_
parameter_list|)
block|{
name|struct
name|pathspec_item
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|a
operator|=
operator|(
expr|struct
name|pathspec_item
operator|*
operator|)
name|a_
expr_stmt|;
name|b
operator|=
operator|(
expr|struct
name|pathspec_item
operator|*
operator|)
name|b_
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|match
argument_list|,
name|b
operator|->
name|match
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init_pathspec
name|int
name|init_pathspec
parameter_list|(
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|paths
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p
init|=
name|paths
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|pathspec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pathspec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
name|pathspec
operator|->
name|raw
operator|=
name|paths
expr_stmt|;
name|pathspec
operator|->
name|nr
operator|=
name|p
operator|-
name|paths
expr_stmt|;
if|if
condition|(
operator|!
name|pathspec
operator|->
name|nr
condition|)
return|return
literal|0
return|;
name|pathspec
operator|->
name|items
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pathspec_item
argument_list|)
operator|*
name|pathspec
operator|->
name|nr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pathspec
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|pathspec_item
modifier|*
name|item
init|=
name|pathspec
operator|->
name|items
operator|+
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|paths
index|[
name|i
index|]
decl_stmt|;
name|item
operator|->
name|match
operator|=
name|path
expr_stmt|;
name|item
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|item
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|limit_pathspec_to_literal
argument_list|()
condition|)
block|{
name|item
operator|->
name|nowildcard_len
operator|=
name|item
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|nowildcard_len
operator|=
name|simple_length
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|nowildcard_len
operator|<
name|item
operator|->
name|len
condition|)
block|{
name|pathspec
operator|->
name|has_wildcard
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|path
index|[
name|item
operator|->
name|nowildcard_len
index|]
operator|==
literal|'*'
operator|&&
name|no_wildcard
argument_list|(
name|path
operator|+
name|item
operator|->
name|nowildcard_len
operator|+
literal|1
argument_list|)
condition|)
name|item
operator|->
name|flags
operator||=
name|PATHSPEC_ONESTAR
expr_stmt|;
block|}
block|}
block|}
name|qsort
argument_list|(
name|pathspec
operator|->
name|items
argument_list|,
name|pathspec
operator|->
name|nr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pathspec_item
argument_list|)
argument_list|,
name|pathspec_item_cmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|free_pathspec
name|void
name|free_pathspec
parameter_list|(
name|struct
name|pathspec
modifier|*
name|pathspec
parameter_list|)
block|{
name|free
argument_list|(
name|pathspec
operator|->
name|items
argument_list|)
expr_stmt|;
name|pathspec
operator|->
name|items
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|limit_pathspec_to_literal
name|int
name|limit_pathspec_to_literal
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|flag
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
name|flag
operator|=
name|git_env_bool
argument_list|(
name|GIT_LITERAL_PATHSPECS_ENVIRONMENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|flag
return|;
block|}
end_function
begin_comment
comment|/*  * Frees memory within dir which was allocated for exclude lists and  * the exclude_stack.  Does not free dir itself.  */
end_comment
begin_function
DECL|function|clear_directory
name|void
name|clear_directory
parameter_list|(
name|struct
name|dir_struct
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|exclude_list_group
modifier|*
name|group
decl_stmt|;
name|struct
name|exclude_list
modifier|*
name|el
decl_stmt|;
name|struct
name|exclude_stack
modifier|*
name|stk
decl_stmt|;
for|for
control|(
name|i
operator|=
name|EXC_CMDL
init|;
name|i
operator|<=
name|EXC_FILE
condition|;
name|i
operator|++
control|)
block|{
name|group
operator|=
operator|&
name|dir
operator|->
name|exclude_list_group
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|group
operator|->
name|nr
condition|;
name|j
operator|++
control|)
block|{
name|el
operator|=
operator|&
name|group
operator|->
name|el
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EXC_DIRS
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|el
operator|->
name|src
argument_list|)
expr_stmt|;
name|clear_exclude_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|group
operator|->
name|el
argument_list|)
expr_stmt|;
block|}
name|stk
operator|=
name|dir
operator|->
name|exclude_stack
expr_stmt|;
while|while
condition|(
name|stk
condition|)
block|{
name|struct
name|exclude_stack
modifier|*
name|prev
init|=
name|stk
operator|->
name|prev
decl_stmt|;
name|free
argument_list|(
name|stk
argument_list|)
expr_stmt|;
name|stk
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function
end_unit
