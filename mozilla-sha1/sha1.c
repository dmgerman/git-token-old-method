begin_unit
begin_comment
comment|/*  * The contents of this file are subject to the Mozilla Public  * License Version 1.1 (the "License"); you may not use this file  * except in compliance with the License. You may obtain a copy of  * the License at http://www.mozilla.org/MPL/  *  * Software distributed under the License is distributed on an "AS  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or  * implied. See the License for the specific language governing  * rights and limitations under the License.  *  * The Original Code is SHA 180-1 Reference Implementation (Compact version)  *  * The Initial Developer of the Original Code is Paul Kocher of  * Cryptography Research.  Portions created by Paul Kocher are  * Copyright (C) 1995-9 by Cryptography Research, Inc.  All  * Rights Reserved.  *  * Contributor(s):  *  *     Paul Kocher  *  * Alternatively, the contents of this file may be used under the  * terms of the GNU General Public License Version 2 or later (the  * "GPL"), in which case the provisions of the GPL are applicable  * instead of those above.  If you wish to allow use of your  * version of this file only under the terms of the GPL and not to  * allow others to use your version of this file under the MPL,  * indicate your decision by deleting the provisions above and  * replace them with the notice and other provisions required by  * the GPL.  If you do not delete the provisions above, a recipient  * may use your version of this file under either the MPL or the  * GPL.  */
end_comment
begin_include
include|#
directive|include
file|"sha1.h"
end_include
begin_function_decl
specifier|static
name|void
name|shaHashBlock
parameter_list|(
name|SHA_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|SHA1_Init
name|void
name|SHA1_Init
parameter_list|(
name|SHA_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ctx
operator|->
name|lenW
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|sizeHi
operator|=
name|ctx
operator|->
name|sizeLo
operator|=
literal|0
expr_stmt|;
comment|/* Initialize H with the magic constants (see FIPS180 for constants)    */
name|ctx
operator|->
name|H
index|[
literal|0
index|]
operator|=
literal|0x67452301
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|1
index|]
operator|=
literal|0xefcdab89
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|2
index|]
operator|=
literal|0x98badcfe
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|3
index|]
operator|=
literal|0x10325476
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|4
index|]
operator|=
literal|0xc3d2e1f0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|80
condition|;
name|i
operator|++
control|)
name|ctx
operator|->
name|W
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|SHA1_Update
name|void
name|SHA1_Update
parameter_list|(
name|SHA_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|_dataIn
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|dataIn
init|=
name|_dataIn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Read the data into W and process blocks as they get full    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ctx
operator|->
name|W
index|[
name|ctx
operator|->
name|lenW
operator|/
literal|4
index|]
operator|<<=
literal|8
expr_stmt|;
name|ctx
operator|->
name|W
index|[
name|ctx
operator|->
name|lenW
operator|/
literal|4
index|]
operator||=
operator|(
name|unsigned
name|int
operator|)
name|dataIn
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|ctx
operator|->
name|lenW
operator|)
operator|%
literal|64
operator|==
literal|0
condition|)
block|{
name|shaHashBlock
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|lenW
operator|=
literal|0
expr_stmt|;
block|}
name|ctx
operator|->
name|sizeLo
operator|+=
literal|8
expr_stmt|;
name|ctx
operator|->
name|sizeHi
operator|+=
operator|(
name|ctx
operator|->
name|sizeLo
operator|<
literal|8
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|SHA1_Final
name|void
name|SHA1_Final
parameter_list|(
name|unsigned
name|char
name|hashout
index|[
literal|20
index|]
parameter_list|,
name|SHA_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|unsigned
name|char
name|pad0x80
init|=
literal|0x80
decl_stmt|;
name|unsigned
name|char
name|pad0x00
init|=
literal|0x00
decl_stmt|;
name|unsigned
name|char
name|padlen
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Pad with a binary 1 (e.g. 0x80), then zeroes, then length    */
name|padlen
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeHi
operator|>>
literal|24
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|padlen
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeHi
operator|>>
literal|16
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|padlen
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeHi
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|padlen
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeHi
operator|>>
literal|0
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|padlen
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeLo
operator|>>
literal|24
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|padlen
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeLo
operator|>>
literal|16
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|padlen
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeLo
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|padlen
index|[
literal|7
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|ctx
operator|->
name|sizeLo
operator|>>
literal|0
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
name|ctx
argument_list|,
operator|&
name|pad0x80
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctx
operator|->
name|lenW
operator|!=
literal|56
condition|)
name|SHA1_Update
argument_list|(
name|ctx
argument_list|,
operator|&
name|pad0x00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SHA1_Update
argument_list|(
name|ctx
argument_list|,
name|padlen
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Output hash    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|hashout
index|[
name|i
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|ctx
operator|->
name|H
index|[
name|i
operator|/
literal|4
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|H
index|[
name|i
operator|/
literal|4
index|]
operator|<<=
literal|8
expr_stmt|;
block|}
comment|/*    *  Re-initialize the context (also zeroizes contents)    */
name|SHA1_Init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|SHA_ROT
define|#
directive|define
name|SHA_ROT
parameter_list|(
name|X
parameter_list|,
name|n
parameter_list|)
value|(((X)<< (n)) | ((X)>> (32-(n))))
end_define
begin_function
DECL|function|shaHashBlock
specifier|static
name|void
name|shaHashBlock
parameter_list|(
name|SHA_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|unsigned
name|int
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|,
name|E
decl_stmt|,
name|TEMP
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|16
init|;
name|t
operator|<=
literal|79
condition|;
name|t
operator|++
control|)
name|ctx
operator|->
name|W
index|[
name|t
index|]
operator|=
name|SHA_ROT
argument_list|(
name|ctx
operator|->
name|W
index|[
name|t
operator|-
literal|3
index|]
operator|^
name|ctx
operator|->
name|W
index|[
name|t
operator|-
literal|8
index|]
operator|^
name|ctx
operator|->
name|W
index|[
name|t
operator|-
literal|14
index|]
operator|^
name|ctx
operator|->
name|W
index|[
name|t
operator|-
literal|16
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|A
operator|=
name|ctx
operator|->
name|H
index|[
literal|0
index|]
expr_stmt|;
name|B
operator|=
name|ctx
operator|->
name|H
index|[
literal|1
index|]
expr_stmt|;
name|C
operator|=
name|ctx
operator|->
name|H
index|[
literal|2
index|]
expr_stmt|;
name|D
operator|=
name|ctx
operator|->
name|H
index|[
literal|3
index|]
expr_stmt|;
name|E
operator|=
name|ctx
operator|->
name|H
index|[
literal|4
index|]
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<=
literal|19
condition|;
name|t
operator|++
control|)
block|{
name|TEMP
operator|=
name|SHA_ROT
argument_list|(
name|A
argument_list|,
literal|5
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|C
operator|^
name|D
operator|)
operator|&
name|B
operator|)
operator|^
name|D
operator|)
operator|+
name|E
operator|+
name|ctx
operator|->
name|W
index|[
name|t
index|]
operator|+
literal|0x5a827999
expr_stmt|;
name|E
operator|=
name|D
expr_stmt|;
name|D
operator|=
name|C
expr_stmt|;
name|C
operator|=
name|SHA_ROT
argument_list|(
name|B
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
name|TEMP
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
literal|20
init|;
name|t
operator|<=
literal|39
condition|;
name|t
operator|++
control|)
block|{
name|TEMP
operator|=
name|SHA_ROT
argument_list|(
name|A
argument_list|,
literal|5
argument_list|)
operator|+
operator|(
name|B
operator|^
name|C
operator|^
name|D
operator|)
operator|+
name|E
operator|+
name|ctx
operator|->
name|W
index|[
name|t
index|]
operator|+
literal|0x6ed9eba1
expr_stmt|;
name|E
operator|=
name|D
expr_stmt|;
name|D
operator|=
name|C
expr_stmt|;
name|C
operator|=
name|SHA_ROT
argument_list|(
name|B
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
name|TEMP
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
literal|40
init|;
name|t
operator|<=
literal|59
condition|;
name|t
operator|++
control|)
block|{
name|TEMP
operator|=
name|SHA_ROT
argument_list|(
name|A
argument_list|,
literal|5
argument_list|)
operator|+
operator|(
operator|(
name|B
operator|&
name|C
operator|)
operator||
operator|(
name|D
operator|&
operator|(
name|B
operator||
name|C
operator|)
operator|)
operator|)
operator|+
name|E
operator|+
name|ctx
operator|->
name|W
index|[
name|t
index|]
operator|+
literal|0x8f1bbcdc
expr_stmt|;
name|E
operator|=
name|D
expr_stmt|;
name|D
operator|=
name|C
expr_stmt|;
name|C
operator|=
name|SHA_ROT
argument_list|(
name|B
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
name|TEMP
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
literal|60
init|;
name|t
operator|<=
literal|79
condition|;
name|t
operator|++
control|)
block|{
name|TEMP
operator|=
name|SHA_ROT
argument_list|(
name|A
argument_list|,
literal|5
argument_list|)
operator|+
operator|(
name|B
operator|^
name|C
operator|^
name|D
operator|)
operator|+
name|E
operator|+
name|ctx
operator|->
name|W
index|[
name|t
index|]
operator|+
literal|0xca62c1d6
expr_stmt|;
name|E
operator|=
name|D
expr_stmt|;
name|D
operator|=
name|C
expr_stmt|;
name|C
operator|=
name|SHA_ROT
argument_list|(
name|B
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
name|TEMP
expr_stmt|;
block|}
name|ctx
operator|->
name|H
index|[
literal|0
index|]
operator|+=
name|A
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|1
index|]
operator|+=
name|B
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|2
index|]
operator|+=
name|C
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|3
index|]
operator|+=
name|D
expr_stmt|;
name|ctx
operator|->
name|H
index|[
literal|4
index|]
operator|+=
name|E
expr_stmt|;
block|}
end_function
end_unit
