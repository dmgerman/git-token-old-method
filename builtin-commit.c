begin_unit
begin_comment
comment|/*  * Builtin "git commit"  *  * Copyright (c) 2007 Kristian HÃ¸gsberg<krh@redhat.com>  * Based on git-commit.sh by Junio C Hamano and Linus Torvalds  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"color.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"wt-status.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"string-list.h"
end_include
begin_include
include|#
directive|include
file|"rerere.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_decl_stmt
DECL|variable|builtin_commit_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_commit_usage
index|[]
init|=
block|{
literal|"git commit [options] [--]<filepattern>..."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|builtin_status_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_status_usage
index|[]
init|=
block|{
literal|"git status [options] [--]<filepattern>..."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|head_sha1
DECL|variable|merge_head_sha1
specifier|static
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|,
name|merge_head_sha1
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_message_buffer
specifier|static
name|char
modifier|*
name|use_message_buffer
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_editmsg
specifier|static
specifier|const
name|char
name|commit_editmsg
index|[]
init|=
literal|"COMMIT_EDITMSG"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|index_lock
specifier|static
name|struct
name|lock_file
name|index_lock
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|index_lock
comment|/* real index */
end_comment
begin_decl_stmt
DECL|variable|false_lock
specifier|static
name|struct
name|lock_file
name|false_lock
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|false_lock
comment|/* used only for partial commits */
end_comment
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|COMMIT_AS_IS
name|COMMIT_AS_IS
init|=
literal|1
block|,
DECL|enumerator|COMMIT_NORMAL
name|COMMIT_NORMAL
block|,
DECL|enumerator|COMMIT_PARTIAL
name|COMMIT_PARTIAL
block|, }
DECL|variable|commit_style
name|commit_style
enum|;
end_enum
begin_decl_stmt
DECL|variable|logfile
DECL|variable|force_author
specifier|static
specifier|const
name|char
modifier|*
name|logfile
decl_stmt|,
modifier|*
name|force_author
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|template_file
specifier|static
specifier|const
name|char
modifier|*
name|template_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|edit_message
DECL|variable|use_message
specifier|static
name|char
modifier|*
name|edit_message
decl_stmt|,
modifier|*
name|use_message
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|author_name
DECL|variable|author_email
DECL|variable|author_date
specifier|static
name|char
modifier|*
name|author_name
decl_stmt|,
modifier|*
name|author_email
decl_stmt|,
modifier|*
name|author_date
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|all
DECL|variable|edit_flag
DECL|variable|also
DECL|variable|interactive
DECL|variable|only
DECL|variable|amend
DECL|variable|signoff
specifier|static
name|int
name|all
decl_stmt|,
name|edit_flag
decl_stmt|,
name|also
decl_stmt|,
name|interactive
decl_stmt|,
name|only
decl_stmt|,
name|amend
decl_stmt|,
name|signoff
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|quiet
DECL|variable|verbose
DECL|variable|no_verify
DECL|variable|allow_empty
specifier|static
name|int
name|quiet
decl_stmt|,
name|verbose
decl_stmt|,
name|no_verify
decl_stmt|,
name|allow_empty
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|untracked_files_arg
specifier|static
name|char
modifier|*
name|untracked_files_arg
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * The default commit message cleanup mode will remove the lines  * beginning with # (shell comments) and leading and trailing  * whitespaces (empty lines or containing only whitespaces)  * if editor is used, and only the whitespaces if the message  * is specified explicitly.  */
end_comment
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|CLEANUP_SPACE
name|CLEANUP_SPACE
block|,
DECL|enumerator|CLEANUP_NONE
name|CLEANUP_NONE
block|,
DECL|enumerator|CLEANUP_ALL
name|CLEANUP_ALL
block|, }
DECL|variable|cleanup_mode
name|cleanup_mode
enum|;
end_enum
begin_decl_stmt
DECL|variable|cleanup_arg
specifier|static
name|char
modifier|*
name|cleanup_arg
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_editor
DECL|variable|initial_commit
DECL|variable|in_merge
specifier|static
name|int
name|use_editor
init|=
literal|1
decl_stmt|,
name|initial_commit
decl_stmt|,
name|in_merge
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|only_include_assumed
specifier|static
specifier|const
name|char
modifier|*
name|only_include_assumed
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|message
specifier|static
name|struct
name|strbuf
name|message
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|opt_parse_m
specifier|static
name|int
name|opt_parse_m
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|buf
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|unset
condition|)
name|strbuf_setlen
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|strbuf_addstr
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
name|buf
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|builtin_commit_options
specifier|static
name|struct
name|option
name|builtin_commit_options
index|[]
init|=
block|{
name|OPT__QUIET
argument_list|(
operator|&
name|quiet
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|verbose
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
literal|"Commit message options"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'F'
argument_list|,
literal|"file"
argument_list|,
operator|&
name|logfile
argument_list|,
literal|"FILE"
argument_list|,
literal|"read log from file"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"author"
argument_list|,
operator|&
name|force_author
argument_list|,
literal|"AUTHOR"
argument_list|,
literal|"override author for commit"
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|'m'
argument_list|,
literal|"message"
argument_list|,
operator|&
name|message
argument_list|,
literal|"MESSAGE"
argument_list|,
literal|"specify commit message"
argument_list|,
name|opt_parse_m
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'c'
argument_list|,
literal|"reedit-message"
argument_list|,
operator|&
name|edit_message
argument_list|,
literal|"COMMIT"
argument_list|,
literal|"reuse and edit message from specified commit "
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'C'
argument_list|,
literal|"reuse-message"
argument_list|,
operator|&
name|use_message
argument_list|,
literal|"COMMIT"
argument_list|,
literal|"reuse message from specified commit"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'s'
argument_list|,
literal|"signoff"
argument_list|,
operator|&
name|signoff
argument_list|,
literal|"add Signed-off-by:"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'t'
argument_list|,
literal|"template"
argument_list|,
operator|&
name|template_file
argument_list|,
literal|"FILE"
argument_list|,
literal|"use specified template file"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'e'
argument_list|,
literal|"edit"
argument_list|,
operator|&
name|edit_flag
argument_list|,
literal|"force edit of commit"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"cleanup"
argument_list|,
operator|&
name|cleanup_arg
argument_list|,
literal|"default"
argument_list|,
literal|"how to strip spaces and #comments from message"
argument_list|)
block|,
comment|/* end commit message options */
name|OPT_GROUP
argument_list|(
literal|"Commit contents options"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'a'
argument_list|,
literal|"all"
argument_list|,
operator|&
name|all
argument_list|,
literal|"commit all changed files"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'i'
argument_list|,
literal|"include"
argument_list|,
operator|&
name|also
argument_list|,
literal|"add specified files to index for commit"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"interactive"
argument_list|,
operator|&
name|interactive
argument_list|,
literal|"interactively add files"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'o'
argument_list|,
literal|"only"
argument_list|,
operator|&
name|only
argument_list|,
literal|"commit only specified files"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'n'
argument_list|,
literal|"no-verify"
argument_list|,
operator|&
name|no_verify
argument_list|,
literal|"bypass pre-commit hook"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"amend"
argument_list|,
operator|&
name|amend
argument_list|,
literal|"amend previous commit"
argument_list|)
block|,
block|{
name|OPTION_STRING
block|,
literal|'u'
block|,
literal|"untracked-files"
block|,
operator|&
name|untracked_files_arg
block|,
literal|"mode"
block|,
literal|"show untracked files, optional modes: all, normal, no. (Default: all)"
block|,
name|PARSE_OPT_OPTARG
block|,
name|NULL
block|,
operator|(
name|intptr_t
operator|)
literal|"all"
block|}
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"allow-empty"
argument_list|,
operator|&
name|allow_empty
argument_list|,
literal|"ok to record an empty change"
argument_list|)
block|,
comment|/* end commit contents options */
name|OPT_END
argument_list|()
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|rollback_index_files
specifier|static
name|void
name|rollback_index_files
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|commit_style
condition|)
block|{
case|case
name|COMMIT_AS_IS
case|:
break|break;
comment|/* nothing to do */
case|case
name|COMMIT_NORMAL
case|:
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMIT_PARTIAL
case|:
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|commit_index_files
specifier|static
name|int
name|commit_index_files
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|commit_style
condition|)
block|{
case|case
name|COMMIT_AS_IS
case|:
break|break;
comment|/* nothing to do */
case|case
name|COMMIT_NORMAL
case|:
name|err
operator|=
name|commit_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMIT_PARTIAL
case|:
name|err
operator|=
name|commit_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function
begin_comment
comment|/*  * Take a union of paths in the index and the named tree (typically, "HEAD"),  * and return the paths that match the given pattern in list.  */
end_comment
begin_function
DECL|function|list_paths
specifier|static
name|int
name|list_paths
parameter_list|(
name|struct
name|string_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|with_tree
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pattern
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|m
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_tree
condition|)
name|overlay_tree_on_cache
argument_list|(
name|with_tree
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_flags
operator|&
name|CE_UPDATE
condition|)
continue|continue;
if|if
condition|(
operator|!
name|match_pathspec
argument_list|(
name|pattern
argument_list|,
name|ce
operator|->
name|name
argument_list|,
name|ce_namelen
argument_list|(
name|ce
argument_list|)
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
condition|)
continue|continue;
name|string_list_insert
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|report_path_error
argument_list|(
name|m
argument_list|,
name|pattern
argument_list|,
name|prefix
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|add_remove_files
specifier|static
name|void
name|add_remove_files
parameter_list|(
name|struct
name|string_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|string_list_item
modifier|*
name|p
init|=
operator|&
operator|(
name|list
operator|->
name|items
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|p
operator|->
name|string
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
name|add_to_cache
argument_list|(
name|p
operator|->
name|string
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
condition|)
name|die
argument_list|(
literal|"updating files failed"
argument_list|)
expr_stmt|;
block|}
else|else
name|remove_file_from_cache
argument_list|(
name|p
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|create_base_index
specifier|static
name|void
name|create_base_index
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|t
decl_stmt|;
if|if
condition|(
name|initial_commit
condition|)
block|{
name|discard_cache
argument_list|()
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|index_only
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|src_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|dst_index
operator|=
operator|&
name|the_index
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
name|die
argument_list|(
literal|"failed to unpack HEAD tree object"
argument_list|)
expr_stmt|;
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpack_trees
argument_list|(
literal|1
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|opts
argument_list|)
condition|)
name|exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
comment|/* We've already reported the error, finish dying */
block|}
end_function
begin_function
DECL|function|prepare_index
specifier|static
name|char
modifier|*
name|prepare_index
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|string_list
name|partial
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|interactive
condition|)
block|{
if|if
condition|(
name|interactive_add
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"interactive add failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cache_preload
argument_list|(
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"index file corrupt"
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_AS_IS
expr_stmt|;
return|return
name|get_index_file
argument_list|()
return|;
block|}
if|if
condition|(
operator|*
name|argv
condition|)
name|pathspec
operator|=
name|get_pathspec
argument_list|(
name|prefix
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cache_preload
argument_list|(
name|pathspec
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"index file corrupt"
argument_list|)
expr_stmt|;
comment|/* 	 * Non partial, non as-is commit. 	 * 	 * (1) get the real index; 	 * (2) update the_index as necessary; 	 * (3) write the_index out to the real index (still locked); 	 * (4) return the name of the locked index file. 	 * 	 * The caller should run hooks on the locked real index, and 	 * (A) if all goes well, commit the real index; 	 * (B) on failure, rollback the real index. 	 */
if|if
condition|(
name|all
operator|||
operator|(
name|also
operator|&&
name|pathspec
operator|&&
operator|*
name|pathspec
operator|)
condition|)
block|{
name|int
name|fd
init|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|add_files_to_cache
argument_list|(
name|also
condition|?
name|prefix
else|:
name|NULL
argument_list|,
name|pathspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write new_index file"
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_NORMAL
expr_stmt|;
return|return
name|index_lock
operator|.
name|filename
return|;
block|}
comment|/* 	 * As-is commit. 	 * 	 * (1) return the name of the real index file. 	 * 	 * The caller should run hooks on the real index, and run 	 * hooks on the real index, and create commit from the_index. 	 * We still need to refresh the index here. 	 */
if|if
condition|(
operator|!
name|pathspec
operator|||
operator|!
operator|*
name|pathspec
condition|)
block|{
name|fd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write new_index file"
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_AS_IS
expr_stmt|;
return|return
name|get_index_file
argument_list|()
return|;
block|}
comment|/* 	 * A partial commit. 	 * 	 * (0) find the set of affected paths; 	 * (1) get lock on the real index file; 	 * (2) update the_index with the given paths; 	 * (3) write the_index out to the real index (still locked); 	 * (4) get lock on the false index file; 	 * (5) reset the_index from HEAD; 	 * (6) update the_index the same way as (2); 	 * (7) write the_index out to the false index file; 	 * (8) return the name of the false index file (still locked); 	 * 	 * The caller should run hooks on the locked false index, and 	 * create commit from it.  Then 	 * (A) if all goes well, commit the real index; 	 * (B) on failure, rollback the real index; 	 * In either case, rollback the false index. 	 */
name|commit_style
operator|=
name|COMMIT_PARTIAL
expr_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot do a partial commit during a merge."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|partial
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|partial
argument_list|)
argument_list|)
expr_stmt|;
name|partial
operator|.
name|strdup_strings
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|list_paths
argument_list|(
operator|&
name|partial
argument_list|,
name|initial_commit
condition|?
name|NULL
else|:
literal|"HEAD"
argument_list|,
name|prefix
argument_list|,
name|pathspec
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"cannot read the index"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_remove_files
argument_list|(
operator|&
name|partial
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write new_index file"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|false_lock
argument_list|,
name|git_path
argument_list|(
literal|"next-index-%"
name|PRIuMAX
argument_list|,
operator|(
name|uintmax_t
operator|)
name|getpid
argument_list|()
argument_list|)
argument_list|,
name|LOCK_DIE_ON_ERROR
argument_list|)
expr_stmt|;
name|create_base_index
argument_list|()
expr_stmt|;
name|add_remove_files
argument_list|(
operator|&
name|partial
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write temporary index file"
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|false_lock
operator|.
name|filename
argument_list|)
expr_stmt|;
return|return
name|false_lock
operator|.
name|filename
return|;
block|}
end_function
begin_function
DECL|function|run_status
specifier|static
name|int
name|run_status
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|nowarn
parameter_list|)
block|{
name|struct
name|wt_status
name|s
decl_stmt|;
name|wt_status_prepare
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt_status_relative_paths
condition|)
name|s
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
if|if
condition|(
name|amend
condition|)
block|{
name|s
operator|.
name|amend
operator|=
literal|1
expr_stmt|;
name|s
operator|.
name|reference
operator|=
literal|"HEAD^1"
expr_stmt|;
block|}
name|s
operator|.
name|verbose
operator|=
name|verbose
expr_stmt|;
name|s
operator|.
name|untracked
operator|=
operator|(
name|show_untracked_files
operator|==
name|SHOW_ALL_UNTRACKED_FILES
operator|)
expr_stmt|;
name|s
operator|.
name|index_file
operator|=
name|index_file
expr_stmt|;
name|s
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|s
operator|.
name|nowarn
operator|=
name|nowarn
expr_stmt|;
name|wt_status_print
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|commitable
return|;
block|}
end_function
begin_function
DECL|function|is_a_merge
specifier|static
name|int
name|is_a_merge
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse HEAD commit"
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
operator|(
name|commit
operator|->
name|parents
operator|&&
name|commit
operator|->
name|parents
operator|->
name|next
operator|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|sign_off_header
specifier|static
specifier|const
name|char
name|sign_off_header
index|[]
init|=
literal|"Signed-off-by: "
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|determine_author_info
specifier|static
name|void
name|determine_author_info
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|email
decl_stmt|,
modifier|*
name|date
decl_stmt|;
name|name
operator|=
name|getenv
argument_list|(
literal|"GIT_AUTHOR_NAME"
argument_list|)
expr_stmt|;
name|email
operator|=
name|getenv
argument_list|(
literal|"GIT_AUTHOR_EMAIL"
argument_list|)
expr_stmt|;
name|date
operator|=
name|getenv
argument_list|(
literal|"GIT_AUTHOR_DATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
block|{
specifier|const
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|lb
decl_stmt|,
modifier|*
name|rb
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|a
operator|=
name|strstr
argument_list|(
name|use_message_buffer
argument_list|,
literal|"\nauthor "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
name|die
argument_list|(
literal|"invalid commit: %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|lb
operator|=
name|strstr
argument_list|(
name|a
operator|+
literal|8
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|rb
operator|=
name|strstr
argument_list|(
name|a
operator|+
literal|8
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
name|eol
operator|=
name|strchr
argument_list|(
name|a
operator|+
literal|8
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lb
operator|||
operator|!
name|rb
operator|||
operator|!
name|eol
condition|)
name|die
argument_list|(
literal|"invalid commit: %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrndup
argument_list|(
name|a
operator|+
literal|8
argument_list|,
name|lb
operator|-
operator|(
name|a
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
name|email
operator|=
name|xstrndup
argument_list|(
name|lb
operator|+
literal|2
argument_list|,
name|rb
operator|-
operator|(
name|lb
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|date
operator|=
name|xstrndup
argument_list|(
name|rb
operator|+
literal|2
argument_list|,
name|eol
operator|-
operator|(
name|rb
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_author
condition|)
block|{
specifier|const
name|char
modifier|*
name|lb
init|=
name|strstr
argument_list|(
name|force_author
argument_list|,
literal|"<"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rb
init|=
name|strchr
argument_list|(
name|force_author
argument_list|,
literal|'>'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lb
operator|||
operator|!
name|rb
condition|)
name|die
argument_list|(
literal|"malformed --author parameter"
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrndup
argument_list|(
name|force_author
argument_list|,
name|lb
operator|-
name|force_author
argument_list|)
expr_stmt|;
name|email
operator|=
name|xstrndup
argument_list|(
name|lb
operator|+
literal|2
argument_list|,
name|rb
operator|-
operator|(
name|lb
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
name|author_name
operator|=
name|name
expr_stmt|;
name|author_email
operator|=
name|email
expr_stmt|;
name|author_date
operator|=
name|date
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_to_commit
specifier|static
name|int
name|prepare_to_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|commitable
decl_stmt|,
name|saved_color_setting
decl_stmt|;
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|hook_arg1
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|hook_arg2
init|=
name|NULL
decl_stmt|;
name|int
name|ident_shown
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|no_verify
operator|&&
name|run_hook
argument_list|(
name|index_file
argument_list|,
literal|"pre-commit"
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|message
operator|.
name|len
condition|)
block|{
name|strbuf_addbuf
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logfile
operator|&&
operator|!
name|strcmp
argument_list|(
name|logfile
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(reading log message from standard input)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read log from standard input"
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logfile
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|logfile
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read log file '%s': %s"
argument_list|,
name|logfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"message"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_message
condition|)
block|{
name|buffer
operator|=
name|strstr
argument_list|(
name|use_message_buffer
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
name|buffer
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|die
argument_list|(
literal|"commit has empty message"
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|buffer
operator|+
literal|2
argument_list|,
name|strlen
argument_list|(
name|buffer
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"commit"
expr_stmt|;
name|hook_arg2
operator|=
name|use_message
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read MERGE_MSG: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"merge"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read SQUASH_MSG: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"squash"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|template_file
operator|&&
operator|!
name|stat
argument_list|(
name|template_file
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|template_file
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read %s: %s"
argument_list|,
name|template_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|hook_arg1
operator|=
literal|"template"
expr_stmt|;
block|}
comment|/* 	 * This final case does not modify the template message, 	 * it just sets the argument to the prepare-commit-msg hook. 	 */
elseif|else
if|if
condition|(
name|in_merge
condition|)
name|hook_arg1
operator|=
literal|"merge"
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"could not open %s: %s"
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_mode
operator|!=
name|CLEANUP_NONE
condition|)
name|stripspace
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|signoff
condition|)
block|{
name|struct
name|strbuf
name|sob
init|=
name|STRBUF_INIT
decl_stmt|;
name|int
name|i
decl_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sob
argument_list|,
name|sign_off_header
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sob
argument_list|,
name|fmt_name
argument_list|(
name|getenv
argument_list|(
literal|"GIT_COMMITTER_NAME"
argument_list|)
argument_list|,
name|getenv
argument_list|(
literal|"GIT_COMMITTER_EMAIL"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sob
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sb
operator|.
name|len
operator|-
literal|1
init|;
name|i
operator|>
literal|0
operator|&&
name|sb
operator|.
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|--
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|prefixcmp
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|i
argument_list|,
name|sob
operator|.
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|i
argument_list|,
name|sign_off_header
argument_list|)
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|sob
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sob
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|fp
argument_list|)
operator|<
name|sb
operator|.
name|len
condition|)
name|die
argument_list|(
literal|"could not write commit template: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|determine_author_info
argument_list|()
expr_stmt|;
comment|/* This checks if committer ident is explicitly given */
name|git_committer_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_editor
condition|)
block|{
name|char
modifier|*
name|author_ident
decl_stmt|;
specifier|const
name|char
modifier|*
name|committer_ident
decl_stmt|;
if|if
condition|(
name|in_merge
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\n"
literal|"# It looks like you may be committing a MERGE.\n"
literal|"# If this is not correct, please remove the file\n"
literal|"#	%s\n"
literal|"# and try again.\n"
literal|"#\n"
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
literal|"# Please enter the commit message for your changes."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_ALL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" Lines starting\n"
literal|"# with '#' will be ignored, and an empty"
literal|" message aborts the commit.\n"
argument_list|)
expr_stmt|;
else|else
comment|/* CLEANUP_SPACE, that is. */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" Lines starting\n"
literal|"# with '#' will be kept; you may remove them"
literal|" yourself if you want to.\n"
literal|"# An empty message aborts the commit.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_include_assumed
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# %s\n"
argument_list|,
name|only_include_assumed
argument_list|)
expr_stmt|;
name|author_ident
operator|=
name|xstrdup
argument_list|(
name|fmt_name
argument_list|(
name|author_name
argument_list|,
name|author_email
argument_list|)
argument_list|)
expr_stmt|;
name|committer_ident
operator|=
name|fmt_name
argument_list|(
name|getenv
argument_list|(
literal|"GIT_COMMITTER_NAME"
argument_list|)
argument_list|,
name|getenv
argument_list|(
literal|"GIT_COMMITTER_EMAIL"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|author_ident
argument_list|,
name|committer_ident
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
literal|"# Author:    %s\n"
argument_list|,
name|ident_shown
operator|++
condition|?
literal|""
else|:
literal|"#\n"
argument_list|,
name|author_ident
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|author_ident
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user_ident_explicitly_given
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
literal|"# Committer: %s\n"
argument_list|,
name|ident_shown
operator|++
condition|?
literal|""
else|:
literal|"#\n"
argument_list|,
name|committer_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident_shown
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|saved_color_setting
operator|=
name|wt_status_use_color
expr_stmt|;
name|wt_status_use_color
operator|=
literal|0
expr_stmt|;
name|commitable
operator|=
name|run_status
argument_list|(
name|fp
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wt_status_use_color
operator|=
name|saved_color_setting
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
init|=
literal|"HEAD"
decl_stmt|;
if|if
condition|(
operator|!
name|active_nr
operator|&&
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Cannot read index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
condition|)
name|parent
operator|=
literal|"HEAD^1"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|parent
argument_list|,
name|sha1
argument_list|)
condition|)
name|commitable
operator|=
operator|!
operator|!
name|active_nr
expr_stmt|;
else|else
name|commitable
operator|=
name|index_differs_from
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commitable
operator|&&
operator|!
name|in_merge
operator|&&
operator|!
name|allow_empty
operator|&&
operator|!
operator|(
name|amend
operator|&&
name|is_a_merge
argument_list|(
name|head_sha1
argument_list|)
operator|)
condition|)
block|{
name|run_status
argument_list|(
name|stdout
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Re-read the index as pre-commit hook could have updated it, 	 * and write it out as a tree.  We must do this before we invoke 	 * the editor and after we invoke run_status above. 	 */
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|index_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active_cache_tree
condition|)
name|active_cache_tree
operator|=
name|cache_tree
argument_list|()
expr_stmt|;
if|if
condition|(
name|cache_tree_update
argument_list|(
name|active_cache_tree
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Error building trees"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|run_hook
argument_list|(
name|index_file
argument_list|,
literal|"prepare-commit-msg"
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|hook_arg1
argument_list|,
name|hook_arg2
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|use_editor
condition|)
block|{
name|char
name|index
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|env
index|[
literal|2
index|]
init|=
block|{
name|index
block|,
name|NULL
block|}
decl_stmt|;
name|snprintf
argument_list|(
name|index
argument_list|,
sizeof|sizeof
argument_list|(
name|index
argument_list|)
argument_list|,
literal|"GIT_INDEX_FILE=%s"
argument_list|,
name|index_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|launch_editor
argument_list|(
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|env
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Please supply the message using either -m or -F option.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|no_verify
operator|&&
name|run_hook
argument_list|(
name|index_file
argument_list|,
literal|"commit-msg"
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_comment
comment|/*  * Find out if the message in the strbuf contains only whitespace and  * Signed-off-by lines.  */
end_comment
begin_function
DECL|function|message_is_empty
specifier|static
name|int
name|message_is_empty
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|strbuf
name|tmpl
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|nl
decl_stmt|;
name|int
name|eol
decl_stmt|,
name|i
decl_stmt|,
name|start
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_NONE
operator|&&
name|sb
operator|->
name|len
condition|)
return|return
literal|0
return|;
comment|/* See if the template is just a prefix of the message. */
if|if
condition|(
name|template_file
operator|&&
name|strbuf_read_file
argument_list|(
operator|&
name|tmpl
argument_list|,
name|template_file
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|stripspace
argument_list|(
operator|&
name|tmpl
argument_list|,
name|cleanup_mode
operator|==
name|CLEANUP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|tmpl
operator|.
name|len
operator|<=
name|sb
operator|->
name|len
operator|&&
name|memcmp
argument_list|(
name|tmpl
operator|.
name|buf
argument_list|,
name|sb
operator|->
name|buf
operator|+
name|start
argument_list|,
name|tmpl
operator|.
name|len
argument_list|)
operator|==
literal|0
condition|)
name|start
operator|+=
name|tmpl
operator|.
name|len
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|tmpl
argument_list|)
expr_stmt|;
comment|/* Check if the rest is just whitespace and Signed-of-by's. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|sb
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|i
argument_list|,
literal|'\n'
argument_list|,
name|sb
operator|->
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|eol
operator|=
name|nl
operator|-
name|sb
operator|->
name|buf
expr_stmt|;
else|else
name|eol
operator|=
name|sb
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|sign_off_header
argument_list|)
operator|<=
name|eol
operator|-
name|i
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|i
argument_list|,
name|sign_off_header
argument_list|)
condition|)
block|{
name|i
operator|=
name|eol
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|i
operator|<
name|eol
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|sb
operator|->
name|buf
index|[
name|i
operator|++
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|find_author_by_nickname
specifier|static
specifier|const
name|char
modifier|*
name|find_author_by_nickname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|rev_info
name|revs
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|av
index|[
literal|20
index|]
decl_stmt|;
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|init_revisions
argument_list|(
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"--author=%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
literal|"--all"
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
literal|"-i"
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
name|av
index|[
operator|++
name|ac
index|]
operator|=
name|NULL
expr_stmt|;
name|setup_revisions
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
operator|&
name|revs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prepare_revision_walk
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
name|commit
operator|=
name|get_revision
argument_list|(
operator|&
name|revs
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
literal|"%an<%ae>"
argument_list|,
operator|&
name|buf
argument_list|,
name|DATE_NORMAL
argument_list|)
expr_stmt|;
return|return
name|strbuf_detach
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|die
argument_list|(
literal|"No existing author found with '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_and_validate_options
specifier|static
name|int
name|parse_and_validate_options
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|usage
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|builtin_commit_options
argument_list|,
name|usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|parse_options_fix_filename
argument_list|(
name|prefix
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
condition|)
name|logfile
operator|=
name|xstrdup
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|template_file
operator|=
name|parse_options_fix_filename
argument_list|(
name|prefix
argument_list|,
name|template_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_file
condition|)
name|template_file
operator|=
name|xstrdup
argument_list|(
name|template_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_author
operator|&&
operator|!
name|strchr
argument_list|(
name|force_author
argument_list|,
literal|'>'
argument_list|)
condition|)
name|force_author
operator|=
name|find_author_by_nickname
argument_list|(
name|force_author
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|||
name|message
operator|.
name|len
operator|||
name|use_message
condition|)
name|use_editor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|edit_flag
condition|)
name|use_editor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|use_editor
condition|)
name|setenv
argument_list|(
literal|"GIT_EDITOR"
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|)
condition|)
name|initial_commit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
literal|"MERGE_HEAD"
argument_list|,
name|merge_head_sha1
argument_list|)
condition|)
name|in_merge
operator|=
literal|1
expr_stmt|;
comment|/* Sanity check options */
if|if
condition|(
name|amend
operator|&&
name|initial_commit
condition|)
name|die
argument_list|(
literal|"You have nothing to amend."
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
operator|&&
name|in_merge
condition|)
name|die
argument_list|(
literal|"You are in the middle of a merge -- cannot amend."
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|edit_message
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|logfile
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|f
operator|>
literal|1
condition|)
name|die
argument_list|(
literal|"Only one of -c/-C/-F can be used."
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|.
name|len
operator|&&
name|f
operator|>
literal|0
condition|)
name|die
argument_list|(
literal|"Option -m cannot be combined with -c/-C/-F."
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_message
condition|)
name|use_message
operator|=
name|edit_message
expr_stmt|;
if|if
condition|(
name|amend
operator|&&
operator|!
name|use_message
condition|)
name|use_message
operator|=
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|utf8
index|[]
init|=
literal|"UTF-8"
decl_stmt|;
specifier|const
name|char
modifier|*
name|out_enc
decl_stmt|;
name|char
modifier|*
name|enc
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|use_message
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not lookup commit %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|commit
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse commit %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|enc
operator|=
name|strstr
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
literal|"\nencoding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|enc
operator|+
literal|10
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|enc
operator|=
name|xstrndup
argument_list|(
name|enc
operator|+
literal|10
argument_list|,
name|end
operator|-
operator|(
name|enc
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enc
operator|=
name|utf8
expr_stmt|;
block|}
name|out_enc
operator|=
name|git_commit_encoding
condition|?
name|git_commit_encoding
else|:
name|utf8
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|out_enc
argument_list|,
name|enc
argument_list|)
condition|)
name|use_message_buffer
operator|=
name|reencode_string
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
name|out_enc
argument_list|,
name|enc
argument_list|)
expr_stmt|;
comment|/* 		 * If we failed to reencode the buffer, just copy it 		 * byte for byte so the user can try to fix it up. 		 * This also handles the case where input and output 		 * encodings are identical. 		 */
if|if
condition|(
name|use_message_buffer
operator|==
name|NULL
condition|)
name|use_message_buffer
operator|=
name|xstrdup
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|!=
name|utf8
condition|)
name|free
argument_list|(
name|enc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|!
name|also
operator|+
operator|!
operator|!
name|only
operator|+
operator|!
operator|!
name|all
operator|+
operator|!
operator|!
name|interactive
operator|>
literal|1
condition|)
name|die
argument_list|(
literal|"Only one of --include/--only/--all/--interactive can be used."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
operator|(
name|also
operator|||
operator|(
name|only
operator|&&
operator|!
name|amend
operator|)
operator|)
condition|)
name|die
argument_list|(
literal|"No paths with --include/--only does not make sense."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|only
operator|&&
name|amend
condition|)
name|only_include_assumed
operator|=
literal|"Clever... amending the last one with dirty index."
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|!
name|also
operator|&&
operator|!
name|only
condition|)
name|only_include_assumed
operator|=
literal|"Explicit paths specified without -i nor -o; assuming --only paths..."
expr_stmt|;
if|if
condition|(
operator|!
name|cleanup_arg
operator|||
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"default"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|use_editor
condition|?
name|CLEANUP_ALL
else|:
name|CLEANUP_SPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"verbatim"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_NONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"whitespace"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_SPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"strip"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_ALL
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Invalid cleanup mode %s"
argument_list|,
name|cleanup_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|untracked_files_arg
condition|)
empty_stmt|;
comment|/* default already initialized */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|untracked_files_arg
argument_list|,
literal|"no"
argument_list|)
condition|)
name|show_untracked_files
operator|=
name|SHOW_NO_UNTRACKED_FILES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|untracked_files_arg
argument_list|,
literal|"normal"
argument_list|)
condition|)
name|show_untracked_files
operator|=
name|SHOW_NORMAL_UNTRACKED_FILES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|untracked_files_arg
argument_list|,
literal|"all"
argument_list|)
condition|)
name|show_untracked_files
operator|=
name|SHOW_ALL_UNTRACKED_FILES
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Invalid untracked files mode '%s'"
argument_list|,
name|untracked_files_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
operator|&&
name|argc
operator|>
literal|0
condition|)
name|die
argument_list|(
literal|"Paths with -a does not make sense."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|interactive
operator|&&
name|argc
operator|>
literal|0
condition|)
name|die
argument_list|(
literal|"Paths with --interactive does not make sense."
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
end_function
begin_function
DECL|function|cmd_status
name|int
name|cmd_status
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|index_file
decl_stmt|;
name|int
name|commitable
decl_stmt|;
name|git_config
argument_list|(
name|git_status_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt_status_use_color
operator|==
operator|-
literal|1
condition|)
name|wt_status_use_color
operator|=
name|git_use_color_default
expr_stmt|;
if|if
condition|(
name|diff_use_color_default
operator|==
operator|-
literal|1
condition|)
name|diff_use_color_default
operator|=
name|git_use_color_default
expr_stmt|;
name|argc
operator|=
name|parse_and_validate_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|builtin_status_usage
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|index_file
operator|=
name|prepare_index
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|commitable
operator|=
name|run_status
argument_list|(
name|stdout
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rollback_index_files
argument_list|()
expr_stmt|;
return|return
name|commitable
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|print_summary
specifier|static
name|void
name|print_summary
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|format
init|=
literal|"format:%h] %s"
decl_stmt|;
name|unsigned
name|char
name|junk_sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|head
init|=
name|resolve_ref
argument_list|(
literal|"HEAD"
argument_list|,
name|junk_sha1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|commit
operator|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|die
argument_list|(
literal|"couldn't look up newly created commit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse newly created commit"
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|abbrev
operator|=
literal|0
expr_stmt|;
name|rev
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_SHORTSTAT
operator||
name|DIFF_FORMAT_SUMMARY
expr_stmt|;
name|rev
operator|.
name|verbose_header
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|show_root_diff
operator|=
literal|1
expr_stmt|;
name|get_commit_format
argument_list|(
name|format
argument_list|,
operator|&
name|rev
argument_list|)
expr_stmt|;
name|rev
operator|.
name|always_show_header
operator|=
literal|0
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|detect_rename
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|rename_limit
operator|=
literal|100
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|break_opt
operator|=
literal|0
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s%s "
argument_list|,
operator|!
name|prefixcmp
argument_list|(
name|head
argument_list|,
literal|"refs/heads/"
argument_list|)
condition|?
name|head
operator|+
literal|11
else|:
operator|!
name|strcmp
argument_list|(
name|head
argument_list|,
literal|"HEAD"
argument_list|)
condition|?
literal|"detached HEAD"
else|:
name|head
argument_list|,
name|initial_commit
condition|?
literal|" (root-commit)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_tree_commit
argument_list|(
operator|&
name|rev
argument_list|,
name|commit
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
name|format
operator|+
literal|7
argument_list|,
operator|&
name|buf
argument_list|,
name|DATE_NORMAL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|git_commit_config
specifier|static
name|int
name|git_commit_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|void
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"commit.template"
argument_list|)
condition|)
return|return
name|git_config_string
argument_list|(
operator|&
name|template_file
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
return|;
return|return
name|git_status_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|cmd_commit
name|int
name|cmd_commit
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|strbuf
name|sb
init|=
name|STRBUF_INIT
decl_stmt|;
specifier|const
name|char
modifier|*
name|index_file
decl_stmt|,
modifier|*
name|reflog_msg
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|commit_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ref_lock
modifier|*
name|ref_lock
decl_stmt|;
name|struct
name|commit_list
modifier|*
name|parents
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|pptr
init|=
operator|&
name|parents
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|allow_fast_forward
init|=
literal|1
decl_stmt|;
name|git_config
argument_list|(
name|git_commit_config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt_status_use_color
operator|==
operator|-
literal|1
condition|)
name|wt_status_use_color
operator|=
name|git_use_color_default
expr_stmt|;
name|argc
operator|=
name|parse_and_validate_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|builtin_commit_usage
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|index_file
operator|=
name|prepare_index
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
comment|/* Set up everything for writing the commit object.  This includes 	   running hooks, writing the trees, and interacting with the user.  */
if|if
condition|(
operator|!
name|prepare_to_commit
argument_list|(
name|index_file
argument_list|,
name|prefix
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Determine parents */
if|if
condition|(
name|initial_commit
condition|)
block|{
name|reflog_msg
operator|=
literal|"commit (initial)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amend
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|c
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|reflog_msg
operator|=
literal|"commit (amend)"
expr_stmt|;
name|commit
operator|=
name|lookup_commit
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse HEAD commit"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|commit
operator|->
name|parents
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|c
operator|->
name|item
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_merge
condition|)
block|{
name|struct
name|strbuf
name|m
init|=
name|STRBUF_INIT
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|reflog_msg
operator|=
literal|"commit (merge)"
expr_stmt|;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|lookup_commit
argument_list|(
name|head_sha1
argument_list|)
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"could not open %s for reading: %s"
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|m
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|m
operator|.
name|buf
argument_list|,
name|sha1
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Corrupt MERGE_HEAD file (%s)"
argument_list|,
name|m
operator|.
name|buf
argument_list|)
expr_stmt|;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read MERGE_MODE: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"no-ff"
argument_list|)
condition|)
name|allow_fast_forward
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|allow_fast_forward
condition|)
name|parents
operator|=
name|reduce_heads
argument_list|(
name|parents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reflog_msg
operator|=
literal|"commit"
expr_stmt|;
name|pptr
operator|=
operator|&
name|commit_list_insert
argument_list|(
name|lookup_commit
argument_list|(
name|head_sha1
argument_list|)
argument_list|,
name|pptr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
comment|/* Finally, get the commit message */
name|strbuf_reset
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"could not read commit message"
argument_list|)
expr_stmt|;
block|}
comment|/* Truncate the message just before the diff, if any. */
if|if
condition|(
name|verbose
condition|)
block|{
name|p
operator|=
name|strstr
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"\ndiff --git "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|strbuf_setlen
argument_list|(
operator|&
name|sb
argument_list|,
name|p
operator|-
name|sb
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleanup_mode
operator|!=
name|CLEANUP_NONE
condition|)
name|stripspace
argument_list|(
operator|&
name|sb
argument_list|,
name|cleanup_mode
operator|==
name|CLEANUP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_is_empty
argument_list|(
operator|&
name|sb
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Aborting commit due to empty commit message.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit_tree
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|active_cache_tree
operator|->
name|sha1
argument_list|,
name|parents
argument_list|,
name|commit_sha1
argument_list|,
name|fmt_ident
argument_list|(
name|author_name
argument_list|,
name|author_email
argument_list|,
name|author_date
argument_list|,
name|IDENT_ERROR_ON_NO_NAME
argument_list|)
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"failed to write commit object"
argument_list|)
expr_stmt|;
block|}
name|ref_lock
operator|=
name|lock_any_ref_for_update
argument_list|(
literal|"HEAD"
argument_list|,
name|initial_commit
condition|?
name|NULL
else|:
name|head_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|strbuf_setlen
argument_list|(
operator|&
name|sb
argument_list|,
name|nl
operator|+
literal|1
operator|-
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|reflog_msg
argument_list|,
name|strlen
argument_list|(
name|reflog_msg
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|sb
argument_list|,
name|strlen
argument_list|(
name|reflog_msg
argument_list|)
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref_lock
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"cannot lock HEAD ref"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_ref_sha1
argument_list|(
name|ref_lock
argument_list|,
name|commit_sha1
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"cannot update HEAD ref"
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MODE"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_index_files
argument_list|()
condition|)
name|die
argument_list|(
literal|"Repository has been updated, but unable to write\n"
literal|"new_index file. Check that disk is not full or quota is\n"
literal|"not exceeded, and then \"git reset HEAD\" to recover."
argument_list|)
expr_stmt|;
name|rerere
argument_list|()
expr_stmt|;
name|run_hook
argument_list|(
name|get_index_file
argument_list|()
argument_list|,
literal|"post-commit"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|print_summary
argument_list|(
name|prefix
argument_list|,
name|commit_sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
