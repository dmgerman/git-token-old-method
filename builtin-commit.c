begin_unit
begin_comment
comment|/*  * Builtin "git commit"  *  * Copyright (c) 2007 Kristian HÃ¸gsberg<krh@redhat.com>  * Based on git-commit.sh by Junio C Hamano and Linus Torvalds  */
end_comment
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"cache-tree.h"
end_include
begin_include
include|#
directive|include
file|"dir.h"
end_include
begin_include
include|#
directive|include
file|"builtin.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"diffcore.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"wt-status.h"
end_include
begin_include
include|#
directive|include
file|"run-command.h"
end_include
begin_include
include|#
directive|include
file|"refs.h"
end_include
begin_include
include|#
directive|include
file|"log-tree.h"
end_include
begin_include
include|#
directive|include
file|"strbuf.h"
end_include
begin_include
include|#
directive|include
file|"utf8.h"
end_include
begin_include
include|#
directive|include
file|"parse-options.h"
end_include
begin_include
include|#
directive|include
file|"path-list.h"
end_include
begin_include
include|#
directive|include
file|"unpack-trees.h"
end_include
begin_decl_stmt
DECL|variable|builtin_commit_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_commit_usage
index|[]
init|=
block|{
literal|"git-commit [options] [--]<filepattern>..."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|builtin_status_usage
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_status_usage
index|[]
init|=
block|{
literal|"git-status [options] [--]<filepattern>..."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|head_sha1
DECL|variable|merge_head_sha1
specifier|static
name|unsigned
name|char
name|head_sha1
index|[
literal|20
index|]
decl_stmt|,
name|merge_head_sha1
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_message_buffer
specifier|static
name|char
modifier|*
name|use_message_buffer
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|commit_editmsg
specifier|static
specifier|const
name|char
name|commit_editmsg
index|[]
init|=
literal|"COMMIT_EDITMSG"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|index_lock
specifier|static
name|struct
name|lock_file
name|index_lock
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|index_lock
comment|/* real index */
end_comment
begin_decl_stmt
DECL|variable|false_lock
specifier|static
name|struct
name|lock_file
name|false_lock
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|false_lock
comment|/* used only for partial commits */
end_comment
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|COMMIT_AS_IS
name|COMMIT_AS_IS
init|=
literal|1
block|,
DECL|enumerator|COMMIT_NORMAL
name|COMMIT_NORMAL
block|,
DECL|enumerator|COMMIT_PARTIAL
name|COMMIT_PARTIAL
block|, }
DECL|variable|commit_style
name|commit_style
enum|;
end_enum
begin_decl_stmt
DECL|variable|logfile
DECL|variable|force_author
DECL|variable|template_file
specifier|static
name|char
modifier|*
name|logfile
decl_stmt|,
modifier|*
name|force_author
decl_stmt|,
modifier|*
name|template_file
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|edit_message
DECL|variable|use_message
specifier|static
name|char
modifier|*
name|edit_message
decl_stmt|,
modifier|*
name|use_message
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|all
DECL|variable|edit_flag
DECL|variable|also
DECL|variable|interactive
DECL|variable|only
DECL|variable|amend
DECL|variable|signoff
specifier|static
name|int
name|all
decl_stmt|,
name|edit_flag
decl_stmt|,
name|also
decl_stmt|,
name|interactive
decl_stmt|,
name|only
decl_stmt|,
name|amend
decl_stmt|,
name|signoff
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|quiet
DECL|variable|verbose
DECL|variable|untracked_files
DECL|variable|no_verify
DECL|variable|allow_empty
specifier|static
name|int
name|quiet
decl_stmt|,
name|verbose
decl_stmt|,
name|untracked_files
decl_stmt|,
name|no_verify
decl_stmt|,
name|allow_empty
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * The default commit message cleanup mode will remove the lines  * beginning with # (shell comments) and leading and trailing  * whitespaces (empty lines or containing only whitespaces)  * if editor is used, and only the whitespaces if the message  * is specified explicitly.  */
end_comment
begin_enum
specifier|static
enum|enum
block|{
DECL|enumerator|CLEANUP_SPACE
name|CLEANUP_SPACE
block|,
DECL|enumerator|CLEANUP_NONE
name|CLEANUP_NONE
block|,
DECL|enumerator|CLEANUP_ALL
name|CLEANUP_ALL
block|, }
DECL|variable|cleanup_mode
name|cleanup_mode
enum|;
end_enum
begin_decl_stmt
DECL|variable|cleanup_arg
specifier|static
name|char
modifier|*
name|cleanup_arg
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|use_editor
DECL|variable|initial_commit
DECL|variable|in_merge
specifier|static
name|int
name|use_editor
init|=
literal|1
decl_stmt|,
name|initial_commit
decl_stmt|,
name|in_merge
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|only_include_assumed
specifier|const
name|char
modifier|*
name|only_include_assumed
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|message
name|struct
name|strbuf
name|message
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|opt_parse_m
specifier|static
name|int
name|opt_parse_m
parameter_list|(
specifier|const
name|struct
name|option
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|unset
parameter_list|)
block|{
name|struct
name|strbuf
modifier|*
name|buf
init|=
name|opt
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|unset
condition|)
name|strbuf_setlen
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|strbuf_addstr
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|builtin_commit_options
specifier|static
name|struct
name|option
name|builtin_commit_options
index|[]
init|=
block|{
name|OPT__QUIET
argument_list|(
operator|&
name|quiet
argument_list|)
block|,
name|OPT__VERBOSE
argument_list|(
operator|&
name|verbose
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
literal|"Commit message options"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'F'
argument_list|,
literal|"file"
argument_list|,
operator|&
name|logfile
argument_list|,
literal|"FILE"
argument_list|,
literal|"read log from file"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"author"
argument_list|,
operator|&
name|force_author
argument_list|,
literal|"AUTHOR"
argument_list|,
literal|"override author for commit"
argument_list|)
block|,
name|OPT_CALLBACK
argument_list|(
literal|'m'
argument_list|,
literal|"message"
argument_list|,
operator|&
name|message
argument_list|,
literal|"MESSAGE"
argument_list|,
literal|"specify commit message"
argument_list|,
name|opt_parse_m
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'c'
argument_list|,
literal|"reedit-message"
argument_list|,
operator|&
name|edit_message
argument_list|,
literal|"COMMIT"
argument_list|,
literal|"reuse and edit message from specified commit "
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'C'
argument_list|,
literal|"reuse-message"
argument_list|,
operator|&
name|use_message
argument_list|,
literal|"COMMIT"
argument_list|,
literal|"reuse message from specified commit"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'s'
argument_list|,
literal|"signoff"
argument_list|,
operator|&
name|signoff
argument_list|,
literal|"add Signed-off-by: header"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|'t'
argument_list|,
literal|"template"
argument_list|,
operator|&
name|template_file
argument_list|,
literal|"FILE"
argument_list|,
literal|"use specified template file"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'e'
argument_list|,
literal|"edit"
argument_list|,
operator|&
name|edit_flag
argument_list|,
literal|"force edit of commit"
argument_list|)
block|,
name|OPT_GROUP
argument_list|(
literal|"Commit contents options"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'a'
argument_list|,
literal|"all"
argument_list|,
operator|&
name|all
argument_list|,
literal|"commit all changed files"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'i'
argument_list|,
literal|"include"
argument_list|,
operator|&
name|also
argument_list|,
literal|"add specified files to index for commit"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"interactive"
argument_list|,
operator|&
name|interactive
argument_list|,
literal|"interactively add files"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'o'
argument_list|,
literal|"only"
argument_list|,
operator|&
name|only
argument_list|,
literal|""
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|'n'
argument_list|,
literal|"no-verify"
argument_list|,
operator|&
name|no_verify
argument_list|,
literal|"bypass pre-commit hook"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"amend"
argument_list|,
operator|&
name|amend
argument_list|,
literal|"amend previous commit"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"untracked-files"
argument_list|,
operator|&
name|untracked_files
argument_list|,
literal|"show all untracked files"
argument_list|)
block|,
name|OPT_BOOLEAN
argument_list|(
literal|0
argument_list|,
literal|"allow-empty"
argument_list|,
operator|&
name|allow_empty
argument_list|,
literal|"ok to record an empty change"
argument_list|)
block|,
name|OPT_STRING
argument_list|(
literal|0
argument_list|,
literal|"cleanup"
argument_list|,
operator|&
name|cleanup_arg
argument_list|,
literal|"default"
argument_list|,
literal|"how to strip spaces and #comments from message"
argument_list|)
block|,
name|OPT_END
argument_list|()
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|rollback_index_files
specifier|static
name|void
name|rollback_index_files
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|commit_style
condition|)
block|{
case|case
name|COMMIT_AS_IS
case|:
break|break;
comment|/* nothing to do */
case|case
name|COMMIT_NORMAL
case|:
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMIT_PARTIAL
case|:
name|rollback_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|commit_index_files
specifier|static
name|int
name|commit_index_files
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|commit_style
condition|)
block|{
case|case
name|COMMIT_AS_IS
case|:
break|break;
comment|/* nothing to do */
case|case
name|COMMIT_NORMAL
case|:
name|err
operator|=
name|commit_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMIT_PARTIAL
case|:
name|err
operator|=
name|commit_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
expr_stmt|;
name|rollback_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function
begin_comment
comment|/*  * Take a union of paths in the index and the named tree (typically, "HEAD"),  * and return the paths that match the given pattern in list.  */
end_comment
begin_function
DECL|function|list_paths
specifier|static
name|int
name|list_paths
parameter_list|(
name|struct
name|path_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|with_tree
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pattern
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pattern
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|m
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|with_tree
condition|)
name|overlay_tree_on_cache
argument_list|(
name|with_tree
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cache_entry
modifier|*
name|ce
init|=
name|active_cache
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_flags
operator|&
name|htons
argument_list|(
name|CE_UPDATE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|pathspec_match
argument_list|(
name|pattern
argument_list|,
name|m
argument_list|,
name|ce
operator|->
name|name
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|path_list_insert
argument_list|(
name|ce
operator|->
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|report_path_error
argument_list|(
name|m
argument_list|,
name|pattern
argument_list|,
name|prefix
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|add_remove_files
specifier|static
name|void
name|add_remove_files
parameter_list|(
name|struct
name|path_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|path_list_item
modifier|*
name|p
init|=
operator|&
operator|(
name|list
operator|->
name|items
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|p
operator|->
name|path
argument_list|)
condition|)
name|add_file_to_cache
argument_list|(
name|p
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|remove_file_from_cache
argument_list|(
name|p
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|create_base_index
specifier|static
name|void
name|create_base_index
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|unpack_trees_options
name|opts
decl_stmt|;
name|struct
name|tree_desc
name|t
decl_stmt|;
if|if
condition|(
name|initial_commit
condition|)
block|{
name|discard_cache
argument_list|()
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|opts
operator|.
name|head_idx
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|index_only
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|merge
operator|=
literal|1
expr_stmt|;
name|opts
operator|.
name|fn
operator|=
name|oneway_merge
expr_stmt|;
name|tree
operator|=
name|parse_tree_indirect
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
name|die
argument_list|(
literal|"failed to unpack HEAD tree object"
argument_list|)
expr_stmt|;
name|parse_tree
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|init_tree_desc
argument_list|(
operator|&
name|t
argument_list|,
name|tree
operator|->
name|buffer
argument_list|,
name|tree
operator|->
name|size
argument_list|)
expr_stmt|;
name|unpack_trees
argument_list|(
literal|1
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|opts
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prepare_index
specifier|static
name|char
modifier|*
name|prepare_index
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|path_list
name|partial
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pathspec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|interactive
condition|)
block|{
name|interactive_add
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_AS_IS
expr_stmt|;
return|return
name|get_index_file
argument_list|()
return|;
block|}
if|if
condition|(
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"index file corrupt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argv
condition|)
name|pathspec
operator|=
name|get_pathspec
argument_list|(
name|prefix
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* 	 * Non partial, non as-is commit. 	 * 	 * (1) get the real index; 	 * (2) update the_index as necessary; 	 * (3) write the_index out to the real index (still locked); 	 * (4) return the name of the locked index file. 	 * 	 * The caller should run hooks on the locked real index, and 	 * (A) if all goes well, commit the real index; 	 * (B) on failure, rollback the real index. 	 */
if|if
condition|(
name|all
operator|||
operator|(
name|also
operator|&&
name|pathspec
operator|&&
operator|*
name|pathspec
operator|)
condition|)
block|{
name|int
name|fd
init|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|add_files_to_cache
argument_list|(
literal|0
argument_list|,
name|also
condition|?
name|prefix
else|:
name|NULL
argument_list|,
name|pathspec
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write new_index file"
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_NORMAL
expr_stmt|;
return|return
name|index_lock
operator|.
name|filename
return|;
block|}
comment|/* 	 * As-is commit. 	 * 	 * (1) return the name of the real index file. 	 * 	 * The caller should run hooks on the real index, and run 	 * hooks on the real index, and create commit from the_index. 	 * We still need to refresh the index here. 	 */
if|if
condition|(
operator|!
name|pathspec
operator|||
operator|!
operator|*
name|pathspec
condition|)
block|{
name|fd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|commit_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write new_index file"
argument_list|)
expr_stmt|;
name|commit_style
operator|=
name|COMMIT_AS_IS
expr_stmt|;
return|return
name|get_index_file
argument_list|()
return|;
block|}
comment|/* 	 * A partial commit. 	 * 	 * (0) find the set of affected paths; 	 * (1) get lock on the real index file; 	 * (2) update the_index with the given paths; 	 * (3) write the_index out to the real index (still locked); 	 * (4) get lock on the false index file; 	 * (5) reset the_index from HEAD; 	 * (6) update the_index the same way as (2); 	 * (7) write the_index out to the false index file; 	 * (8) return the name of the false index file (still locked); 	 * 	 * The caller should run hooks on the locked false index, and 	 * create commit from it.  Then 	 * (A) if all goes well, commit the real index; 	 * (B) on failure, rollback the real index; 	 * In either case, rollback the false index. 	 */
name|commit_style
operator|=
name|COMMIT_PARTIAL
expr_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot do a partial commit during a merge."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|partial
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|partial
argument_list|)
argument_list|)
expr_stmt|;
name|partial
operator|.
name|strdup_paths
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|list_paths
argument_list|(
operator|&
name|partial
argument_list|,
name|initial_commit
condition|?
name|NULL
else|:
literal|"HEAD"
argument_list|,
name|prefix
argument_list|,
name|pathspec
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|discard_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"cannot read the index"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_locked_index
argument_list|(
operator|&
name|index_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_remove_files
argument_list|(
operator|&
name|partial
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close_lock_file
argument_list|(
operator|&
name|index_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write new_index file"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|hold_lock_file_for_update
argument_list|(
operator|&
name|false_lock
argument_list|,
name|git_path
argument_list|(
literal|"next-index-%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|create_base_index
argument_list|()
expr_stmt|;
name|add_remove_files
argument_list|(
operator|&
name|partial
argument_list|)
expr_stmt|;
name|refresh_cache
argument_list|(
name|REFRESH_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_cache
argument_list|(
name|fd
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|)
operator|||
name|close_lock_file
argument_list|(
operator|&
name|false_lock
argument_list|)
condition|)
name|die
argument_list|(
literal|"unable to write temporary index file"
argument_list|)
expr_stmt|;
return|return
name|false_lock
operator|.
name|filename
return|;
block|}
end_function
begin_function
DECL|function|run_status
specifier|static
name|int
name|run_status
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|nowarn
parameter_list|)
block|{
name|struct
name|wt_status
name|s
decl_stmt|;
name|wt_status_prepare
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt_status_relative_paths
condition|)
name|s
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
if|if
condition|(
name|amend
condition|)
block|{
name|s
operator|.
name|amend
operator|=
literal|1
expr_stmt|;
name|s
operator|.
name|reference
operator|=
literal|"HEAD^1"
expr_stmt|;
block|}
name|s
operator|.
name|verbose
operator|=
name|verbose
expr_stmt|;
name|s
operator|.
name|untracked
operator|=
name|untracked_files
expr_stmt|;
name|s
operator|.
name|index_file
operator|=
name|index_file
expr_stmt|;
name|s
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|s
operator|.
name|nowarn
operator|=
name|nowarn
expr_stmt|;
name|wt_status_print
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|commitable
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|sign_off_header
specifier|static
specifier|const
name|char
name|sign_off_header
index|[]
init|=
literal|"Signed-off-by: "
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|prepare_log_message
specifier|static
name|int
name|prepare_log_message
parameter_list|(
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|commitable
decl_stmt|,
name|saved_color_setting
decl_stmt|;
name|struct
name|strbuf
name|sb
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|.
name|len
condition|)
block|{
name|strbuf_addbuf
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|message
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logfile
operator|&&
operator|!
name|strcmp
argument_list|(
name|logfile
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(reading log message from standard input)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strbuf_read
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read log from standard input"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logfile
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|logfile
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read log file '%s': %s"
argument_list|,
name|logfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_message
condition|)
block|{
name|buffer
operator|=
name|strstr
argument_list|(
name|use_message_buffer
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
name|buffer
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|die
argument_list|(
literal|"commit has empty message"
argument_list|)
expr_stmt|;
name|strbuf_add
argument_list|(
operator|&
name|sb
argument_list|,
name|buffer
operator|+
literal|2
argument_list|,
name|strlen
argument_list|(
name|buffer
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read MERGE_MSG: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|stat
argument_list|(
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read SQUASH_MSG: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|template_file
operator|&&
operator|!
name|stat
argument_list|(
name|template_file
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|template_file
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"could not read %s: %s"
argument_list|,
name|template_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"could not open %s"
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_mode
operator|!=
name|CLEANUP_NONE
condition|)
name|stripspace
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|signoff
condition|)
block|{
name|struct
name|strbuf
name|sob
decl_stmt|;
name|int
name|i
decl_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|sob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sob
argument_list|,
name|sign_off_header
argument_list|)
expr_stmt|;
name|strbuf_addstr
argument_list|(
operator|&
name|sob
argument_list|,
name|fmt_name
argument_list|(
name|getenv
argument_list|(
literal|"GIT_COMMITTER_NAME"
argument_list|)
argument_list|,
name|getenv
argument_list|(
literal|"GIT_COMMITTER_EMAIL"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sob
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sb
operator|.
name|len
operator|-
literal|1
init|;
name|i
operator|>
literal|0
operator|&&
name|sb
operator|.
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|--
control|)
empty_stmt|;
comment|/* do nothing */
if|if
condition|(
name|prefixcmp
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|i
argument_list|,
name|sob
operator|.
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|prefixcmp
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|i
argument_list|,
name|sign_off_header
argument_list|)
condition|)
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_addbuf
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|sob
argument_list|)
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|sob
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|sb
operator|.
name|len
argument_list|,
name|fp
argument_list|)
operator|<
name|sb
operator|.
name|len
condition|)
name|die
argument_list|(
literal|"could not write commit template: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_editor
condition|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
init|=
literal|"HEAD"
decl_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active_nr
operator|&&
name|read_cache
argument_list|()
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Cannot read index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
condition|)
name|parent
operator|=
literal|"HEAD^1"
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|parent
argument_list|,
name|sha1
argument_list|)
condition|)
return|return
operator|!
operator|!
name|active_nr
return|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|rev
operator|.
name|abbrev
operator|=
literal|0
expr_stmt|;
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rev
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|QUIET
argument_list|)
expr_stmt|;
name|DIFF_OPT_SET
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|EXIT_WITH_STATUS
argument_list|)
expr_stmt|;
name|run_diff_index
argument_list|(
operator|&
name|rev
argument_list|,
literal|1
comment|/* cached */
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|DIFF_OPT_TST
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|,
name|HAS_CHANGES
argument_list|)
return|;
block|}
if|if
condition|(
name|in_merge
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#\n"
literal|"# It looks like you may be committing a MERGE.\n"
literal|"# If this is not correct, please remove the file\n"
literal|"#	%s\n"
literal|"# and try again.\n"
literal|"#\n"
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
literal|"# Please enter the commit message for your changes.\n"
literal|"# (Comment lines starting with '#' will "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_ALL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"not be included)\n"
argument_list|)
expr_stmt|;
else|else
comment|/* CLEANUP_SPACE, that is. */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"be kept.\n"
literal|"# You can remove them yourself if you want to)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_include_assumed
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# %s\n"
argument_list|,
name|only_include_assumed
argument_list|)
expr_stmt|;
name|saved_color_setting
operator|=
name|wt_status_use_color
expr_stmt|;
name|wt_status_use_color
operator|=
literal|0
expr_stmt|;
name|commitable
operator|=
name|run_status
argument_list|(
name|fp
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wt_status_use_color
operator|=
name|saved_color_setting
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|commitable
return|;
block|}
end_function
begin_comment
comment|/*  * Find out if the message starting at position 'start' in the strbuf  * contains only whitespace and Signed-off-by lines.  */
end_comment
begin_function
DECL|function|message_is_empty
specifier|static
name|int
name|message_is_empty
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|struct
name|strbuf
name|tmpl
decl_stmt|;
specifier|const
name|char
modifier|*
name|nl
decl_stmt|;
name|int
name|eol
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|cleanup_mode
operator|==
name|CLEANUP_NONE
operator|&&
name|sb
operator|->
name|len
condition|)
return|return
literal|0
return|;
comment|/* See if the template is just a prefix of the message. */
name|strbuf_init
argument_list|(
operator|&
name|tmpl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_file
operator|&&
name|strbuf_read_file
argument_list|(
operator|&
name|tmpl
argument_list|,
name|template_file
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|stripspace
argument_list|(
operator|&
name|tmpl
argument_list|,
name|cleanup_mode
operator|==
name|CLEANUP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|tmpl
operator|.
name|len
operator|<=
name|sb
operator|->
name|len
operator|&&
name|memcmp
argument_list|(
name|tmpl
operator|.
name|buf
argument_list|,
name|sb
operator|->
name|buf
operator|+
name|start
argument_list|,
name|tmpl
operator|.
name|len
argument_list|)
operator|==
literal|0
condition|)
name|start
operator|+=
name|tmpl
operator|.
name|len
expr_stmt|;
block|}
name|strbuf_release
argument_list|(
operator|&
name|tmpl
argument_list|)
expr_stmt|;
comment|/* Check if the rest is just whitespace and Signed-of-by's. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|sb
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|i
argument_list|,
literal|'\n'
argument_list|,
name|sb
operator|->
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|eol
operator|=
name|nl
operator|-
name|sb
operator|->
name|buf
expr_stmt|;
else|else
name|eol
operator|=
name|sb
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|sign_off_header
argument_list|)
operator|<=
name|eol
operator|-
name|i
operator|&&
operator|!
name|prefixcmp
argument_list|(
name|sb
operator|->
name|buf
operator|+
name|i
argument_list|,
name|sign_off_header
argument_list|)
condition|)
block|{
name|i
operator|=
name|eol
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|i
operator|<
name|eol
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|sb
operator|->
name|buf
index|[
name|i
operator|++
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|determine_author_info
specifier|static
name|void
name|determine_author_info
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|email
decl_stmt|,
modifier|*
name|date
decl_stmt|;
name|name
operator|=
name|getenv
argument_list|(
literal|"GIT_AUTHOR_NAME"
argument_list|)
expr_stmt|;
name|email
operator|=
name|getenv
argument_list|(
literal|"GIT_AUTHOR_EMAIL"
argument_list|)
expr_stmt|;
name|date
operator|=
name|getenv
argument_list|(
literal|"GIT_AUTHOR_DATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
block|{
specifier|const
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|lb
decl_stmt|,
modifier|*
name|rb
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|a
operator|=
name|strstr
argument_list|(
name|use_message_buffer
argument_list|,
literal|"\nauthor "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
name|die
argument_list|(
literal|"invalid commit: %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|lb
operator|=
name|strstr
argument_list|(
name|a
operator|+
literal|8
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|rb
operator|=
name|strstr
argument_list|(
name|a
operator|+
literal|8
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
name|eol
operator|=
name|strchr
argument_list|(
name|a
operator|+
literal|8
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lb
operator|||
operator|!
name|rb
operator|||
operator|!
name|eol
condition|)
name|die
argument_list|(
literal|"invalid commit: %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrndup
argument_list|(
name|a
operator|+
literal|8
argument_list|,
name|lb
operator|-
operator|(
name|a
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
name|email
operator|=
name|xstrndup
argument_list|(
name|lb
operator|+
literal|2
argument_list|,
name|rb
operator|-
operator|(
name|lb
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|date
operator|=
name|xstrndup
argument_list|(
name|rb
operator|+
literal|2
argument_list|,
name|eol
operator|-
operator|(
name|rb
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_author
condition|)
block|{
specifier|const
name|char
modifier|*
name|lb
init|=
name|strstr
argument_list|(
name|force_author
argument_list|,
literal|"<"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rb
init|=
name|strchr
argument_list|(
name|force_author
argument_list|,
literal|'>'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lb
operator|||
operator|!
name|rb
condition|)
name|die
argument_list|(
literal|"malformed --author parameter"
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrndup
argument_list|(
name|force_author
argument_list|,
name|lb
operator|-
name|force_author
argument_list|)
expr_stmt|;
name|email
operator|=
name|xstrndup
argument_list|(
name|lb
operator|+
literal|2
argument_list|,
name|rb
operator|-
operator|(
name|lb
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"author %s\n"
argument_list|,
name|fmt_ident
argument_list|(
name|name
argument_list|,
name|email
argument_list|,
name|date
argument_list|,
name|IDENT_ERROR_ON_NO_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parse_and_validate_options
specifier|static
name|int
name|parse_and_validate_options
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|usage
index|[]
parameter_list|)
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
name|argc
operator|=
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|builtin_commit_options
argument_list|,
name|usage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|||
name|message
operator|.
name|len
operator|||
name|use_message
condition|)
name|use_editor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|edit_flag
condition|)
name|use_editor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
literal|"HEAD"
argument_list|,
name|head_sha1
argument_list|)
condition|)
name|initial_commit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|get_sha1
argument_list|(
literal|"MERGE_HEAD"
argument_list|,
name|merge_head_sha1
argument_list|)
condition|)
name|in_merge
operator|=
literal|1
expr_stmt|;
comment|/* Sanity check options */
if|if
condition|(
name|amend
operator|&&
name|initial_commit
condition|)
name|die
argument_list|(
literal|"You have nothing to amend."
argument_list|)
expr_stmt|;
if|if
condition|(
name|amend
operator|&&
name|in_merge
condition|)
name|die
argument_list|(
literal|"You are in the middle of a merge -- cannot amend."
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|edit_message
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|logfile
condition|)
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|f
operator|>
literal|1
condition|)
name|die
argument_list|(
literal|"Only one of -c/-C/-F can be used."
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|.
name|len
operator|&&
name|f
operator|>
literal|0
condition|)
name|die
argument_list|(
literal|"Option -m cannot be combined with -c/-C/-F."
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_message
condition|)
name|use_message
operator|=
name|edit_message
expr_stmt|;
if|if
condition|(
name|amend
operator|&&
operator|!
name|use_message
condition|)
name|use_message
operator|=
literal|"HEAD"
expr_stmt|;
if|if
condition|(
name|use_message
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|utf8
index|[]
init|=
literal|"UTF-8"
decl_stmt|;
specifier|const
name|char
modifier|*
name|out_enc
decl_stmt|;
name|char
modifier|*
name|enc
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
if|if
condition|(
name|get_sha1
argument_list|(
name|use_message
argument_list|,
name|sha1
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not lookup commit %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|commit
operator|=
name|lookup_commit_reference
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse commit %s"
argument_list|,
name|use_message
argument_list|)
expr_stmt|;
name|enc
operator|=
name|strstr
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
literal|"\nencoding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
condition|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|enc
operator|+
literal|10
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|enc
operator|=
name|xstrndup
argument_list|(
name|enc
operator|+
literal|10
argument_list|,
name|end
operator|-
operator|(
name|enc
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enc
operator|=
name|utf8
expr_stmt|;
block|}
name|out_enc
operator|=
name|git_commit_encoding
condition|?
name|git_commit_encoding
else|:
name|utf8
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|out_enc
argument_list|,
name|enc
argument_list|)
condition|)
name|use_message_buffer
operator|=
name|reencode_string
argument_list|(
name|commit
operator|->
name|buffer
argument_list|,
name|out_enc
argument_list|,
name|enc
argument_list|)
expr_stmt|;
comment|/* 		 * If we failed to reencode the buffer, just copy it 		 * byte for byte so the user can try to fix it up. 		 * This also handles the case where input and output 		 * encodings are identical. 		 */
if|if
condition|(
name|use_message_buffer
operator|==
name|NULL
condition|)
name|use_message_buffer
operator|=
name|xstrdup
argument_list|(
name|commit
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|!=
name|utf8
condition|)
name|free
argument_list|(
name|enc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|!
name|also
operator|+
operator|!
operator|!
name|only
operator|+
operator|!
operator|!
name|all
operator|+
operator|!
operator|!
name|interactive
operator|>
literal|1
condition|)
name|die
argument_list|(
literal|"Only one of --include/--only/--all/--interactive can be used."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
operator|(
name|also
operator|||
operator|(
name|only
operator|&&
operator|!
name|amend
operator|)
operator|)
condition|)
name|die
argument_list|(
literal|"No paths with --include/--only does not make sense."
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
name|only
operator|&&
name|amend
condition|)
name|only_include_assumed
operator|=
literal|"Clever... amending the last one with dirty index."
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|!
name|also
operator|&&
operator|!
name|only
condition|)
block|{
name|only_include_assumed
operator|=
literal|"Explicit paths specified without -i nor -o; assuming --only paths..."
expr_stmt|;
name|also
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cleanup_arg
operator|||
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"default"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|use_editor
condition|?
name|CLEANUP_ALL
else|:
name|CLEANUP_SPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"verbatim"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_NONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"whitespace"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_SPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cleanup_arg
argument_list|,
literal|"strip"
argument_list|)
condition|)
name|cleanup_mode
operator|=
name|CLEANUP_ALL
expr_stmt|;
else|else
name|die
argument_list|(
literal|"Invalid cleanup mode %s"
argument_list|,
name|cleanup_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
operator|&&
name|argc
operator|>
literal|0
condition|)
name|die
argument_list|(
literal|"Paths with -a does not make sense."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|interactive
operator|&&
name|argc
operator|>
literal|0
condition|)
name|die
argument_list|(
literal|"Paths with --interactive does not make sense."
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
end_function
begin_function
DECL|function|cmd_status
name|int
name|cmd_status
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|index_file
decl_stmt|;
name|int
name|commitable
decl_stmt|;
name|git_config
argument_list|(
name|git_status_config
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_and_validate_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|builtin_status_usage
argument_list|)
expr_stmt|;
name|index_file
operator|=
name|prepare_index
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|commitable
operator|=
name|run_status
argument_list|(
name|stdout
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rollback_index_files
argument_list|()
expr_stmt|;
return|return
name|commitable
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function
begin_function
DECL|function|run_hook
specifier|static
name|int
name|run_hook
parameter_list|(
specifier|const
name|char
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|child_process
name|hook
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|env
index|[
literal|2
index|]
decl_stmt|;
name|char
name|index
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|git_path
argument_list|(
literal|"hooks/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|index
argument_list|,
sizeof|sizeof
argument_list|(
name|index
argument_list|)
argument_list|,
literal|"GIT_INDEX_FILE=%s"
argument_list|,
name|index_file
argument_list|)
expr_stmt|;
name|env
index|[
literal|0
index|]
operator|=
name|index
expr_stmt|;
name|env
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|hook
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|hook
operator|.
name|no_stdin
operator|=
literal|1
expr_stmt|;
name|hook
operator|.
name|stdout_to_stderr
operator|=
literal|1
expr_stmt|;
name|hook
operator|.
name|env
operator|=
name|env
expr_stmt|;
return|return
name|run_command
argument_list|(
operator|&
name|hook
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|print_summary
specifier|static
name|void
name|print_summary
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|rev_info
name|rev
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|commit
operator|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|die
argument_list|(
literal|"couldn't look up newly created commit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse newly created commit"
argument_list|)
expr_stmt|;
name|init_revisions
argument_list|(
operator|&
name|rev
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|setup_revisions
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rev
operator|.
name|abbrev
operator|=
literal|0
expr_stmt|;
name|rev
operator|.
name|diff
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|output_format
operator|=
name|DIFF_FORMAT_SHORTSTAT
operator||
name|DIFF_FORMAT_SUMMARY
expr_stmt|;
name|rev
operator|.
name|verbose_header
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|show_root_diff
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|commit_format
operator|=
name|get_commit_format
argument_list|(
literal|"format:%h: %s"
argument_list|)
expr_stmt|;
name|rev
operator|.
name|always_show_header
operator|=
literal|0
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|detect_rename
operator|=
literal|1
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|rename_limit
operator|=
literal|100
expr_stmt|;
name|rev
operator|.
name|diffopt
operator|.
name|break_opt
operator|=
literal|0
expr_stmt|;
name|diff_setup_done
argument_list|(
operator|&
name|rev
operator|.
name|diffopt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Created %scommit "
argument_list|,
name|initial_commit
condition|?
literal|"initial "
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_tree_commit
argument_list|(
operator|&
name|rev
argument_list|,
name|commit
argument_list|)
condition|)
block|{
name|struct
name|strbuf
name|buf
init|=
name|STRBUF_INIT
decl_stmt|;
name|format_commit_message
argument_list|(
name|commit
argument_list|,
literal|"%h: %s"
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|git_commit_config
name|int
name|git_commit_config
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|k
argument_list|,
literal|"commit.template"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|v
condition|)
return|return
name|config_error_nonbool
argument_list|(
name|v
argument_list|)
return|;
name|template_file
operator|=
name|xstrdup
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|git_status_config
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|is_a_merge
specifier|static
name|int
name|is_a_merge
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|commit
modifier|*
name|commit
init|=
name|lookup_commit
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse HEAD commit"
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
operator|(
name|commit
operator|->
name|parents
operator|&&
name|commit
operator|->
name|parents
operator|->
name|next
operator|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|commit_utf8_warn
specifier|static
specifier|const
name|char
name|commit_utf8_warn
index|[]
init|=
literal|"Warning: commit message does not conform to UTF-8.\n"
literal|"You may want to amend it after fixing the message, or set the config\n"
literal|"variable i18n.commitencoding to the encoding your project uses.\n"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|add_parent
specifier|static
name|void
name|add_parent
parameter_list|(
name|struct
name|strbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|obj
init|=
name|parse_object
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
init|=
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
name|die
argument_list|(
literal|"Unable to find commit parent %s"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJ_COMMIT
condition|)
name|die
argument_list|(
literal|"Parent %s isn't a proper commit"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
name|sb
argument_list|,
literal|"parent %s\n"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|cmd_commit
name|int
name|cmd_commit
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|header_len
decl_stmt|;
name|struct
name|strbuf
name|sb
decl_stmt|;
specifier|const
name|char
modifier|*
name|index_file
decl_stmt|,
modifier|*
name|reflog_msg
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|commit_sha1
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ref_lock
modifier|*
name|ref_lock
decl_stmt|;
name|git_config
argument_list|(
name|git_commit_config
argument_list|)
expr_stmt|;
name|argc
operator|=
name|parse_and_validate_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|builtin_commit_usage
argument_list|)
expr_stmt|;
name|index_file
operator|=
name|prepare_index
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_verify
operator|&&
name|run_hook
argument_list|(
name|index_file
argument_list|,
literal|"pre-commit"
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|prepare_log_message
argument_list|(
name|index_file
argument_list|,
name|prefix
argument_list|)
operator|&&
operator|!
name|in_merge
operator|&&
operator|!
name|allow_empty
operator|&&
operator|!
operator|(
name|amend
operator|&&
name|is_a_merge
argument_list|(
name|head_sha1
argument_list|)
operator|)
condition|)
block|{
name|run_status
argument_list|(
name|stdout
argument_list|,
name|index_file
argument_list|,
name|prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rollback_index_files
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
name|commit_editmsg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Re-read the index as pre-commit hook could have updated it, 	 * and write it out as a tree. 	 */
name|discard_cache
argument_list|()
expr_stmt|;
name|read_cache_from
argument_list|(
name|index_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|active_cache_tree
condition|)
name|active_cache_tree
operator|=
name|cache_tree
argument_list|()
expr_stmt|;
if|if
condition|(
name|cache_tree_update
argument_list|(
name|active_cache_tree
argument_list|,
name|active_cache
argument_list|,
name|active_nr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"Error building trees"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The commit object 	 */
name|strbuf_init
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"tree %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|active_cache_tree
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine parents */
if|if
condition|(
name|initial_commit
condition|)
block|{
name|reflog_msg
operator|=
literal|"commit (initial)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amend
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|c
decl_stmt|;
name|struct
name|commit
modifier|*
name|commit
decl_stmt|;
name|reflog_msg
operator|=
literal|"commit (amend)"
expr_stmt|;
name|commit
operator|=
name|lookup_commit
argument_list|(
name|head_sha1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commit
operator|||
name|parse_commit
argument_list|(
name|commit
argument_list|)
condition|)
name|die
argument_list|(
literal|"could not parse HEAD commit"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|commit
operator|->
name|parents
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
name|add_parent
argument_list|(
operator|&
name|sb
argument_list|,
name|c
operator|->
name|item
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_merge
condition|)
block|{
name|struct
name|strbuf
name|m
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|reflog_msg
operator|=
literal|"commit (merge)"
expr_stmt|;
name|add_parent
argument_list|(
operator|&
name|sb
argument_list|,
name|head_sha1
argument_list|)
expr_stmt|;
name|strbuf_init
argument_list|(
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"could not open %s for reading: %s"
argument_list|,
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|strbuf_getline
argument_list|(
operator|&
name|m
argument_list|,
name|fp
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|get_sha1_hex
argument_list|(
name|m
operator|.
name|buf
argument_list|,
name|sha1
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Corrupt MERGE_HEAD file (%s)"
argument_list|,
name|m
operator|.
name|buf
argument_list|)
expr_stmt|;
name|add_parent
argument_list|(
operator|&
name|sb
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strbuf_release
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reflog_msg
operator|=
literal|"commit"
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"parent %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|head_sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|determine_author_info
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"committer %s\n"
argument_list|,
name|git_committer_info
argument_list|(
name|IDENT_ERROR_ON_NO_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_encoding_utf8
argument_list|(
name|git_commit_encoding
argument_list|)
condition|)
name|strbuf_addf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"encoding %s\n"
argument_list|,
name|git_commit_encoding
argument_list|)
expr_stmt|;
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Get the commit message and validate it */
name|header_len
operator|=
name|sb
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|use_editor
condition|)
block|{
name|char
name|index
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|env
index|[
literal|2
index|]
init|=
block|{
name|index
block|,
name|NULL
block|}
decl_stmt|;
name|snprintf
argument_list|(
name|index
argument_list|,
sizeof|sizeof
argument_list|(
name|index
argument_list|)
argument_list|,
literal|"GIT_INDEX_FILE=%s"
argument_list|,
name|index_file
argument_list|)
expr_stmt|;
name|launch_editor
argument_list|(
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_verify
operator|&&
name|run_hook
argument_list|(
name|index_file
argument_list|,
literal|"commit-msg"
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strbuf_read_file
argument_list|(
operator|&
name|sb
argument_list|,
name|git_path
argument_list|(
name|commit_editmsg
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"could not read commit message"
argument_list|)
expr_stmt|;
block|}
comment|/* Truncate the message just before the diff, if any. */
name|p
operator|=
name|strstr
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
literal|"\ndiff --git a/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|strbuf_setlen
argument_list|(
operator|&
name|sb
argument_list|,
name|p
operator|-
name|sb
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_mode
operator|!=
name|CLEANUP_NONE
condition|)
name|stripspace
argument_list|(
operator|&
name|sb
argument_list|,
name|cleanup_mode
operator|==
name|CLEANUP_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|len
operator|<
name|header_len
operator|||
name|message_is_empty
argument_list|(
operator|&
name|sb
argument_list|,
name|header_len
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"no commit message?  aborting commit."
argument_list|)
expr_stmt|;
block|}
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_encoding_utf8
argument_list|(
name|git_commit_encoding
argument_list|)
operator|&&
operator|!
name|is_utf8
argument_list|(
name|sb
operator|.
name|buf
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|commit_utf8_warn
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_sha1_file
argument_list|(
name|sb
operator|.
name|buf
argument_list|,
name|sb
operator|.
name|len
operator|-
literal|1
argument_list|,
name|commit_type
argument_list|,
name|commit_sha1
argument_list|)
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"failed to write commit object"
argument_list|)
expr_stmt|;
block|}
name|ref_lock
operator|=
name|lock_any_ref_for_update
argument_list|(
literal|"HEAD"
argument_list|,
name|initial_commit
condition|?
name|NULL
else|:
name|head_sha1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|sb
operator|.
name|buf
operator|+
name|header_len
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|strbuf_setlen
argument_list|(
operator|&
name|sb
argument_list|,
name|nl
operator|+
literal|1
operator|-
name|sb
operator|.
name|buf
argument_list|)
expr_stmt|;
else|else
name|strbuf_addch
argument_list|(
operator|&
name|sb
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|strbuf_remove
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|header_len
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|sb
argument_list|,
literal|0
argument_list|,
name|reflog_msg
argument_list|,
name|strlen
argument_list|(
name|reflog_msg
argument_list|)
argument_list|)
expr_stmt|;
name|strbuf_insert
argument_list|(
operator|&
name|sb
argument_list|,
name|strlen
argument_list|(
name|reflog_msg
argument_list|)
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref_lock
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"cannot lock HEAD ref"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_ref_sha1
argument_list|(
name|ref_lock
argument_list|,
name|commit_sha1
argument_list|,
name|sb
operator|.
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rollback_index_files
argument_list|()
expr_stmt|;
name|die
argument_list|(
literal|"cannot update HEAD ref"
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_HEAD"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"MERGE_MSG"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|git_path
argument_list|(
literal|"SQUASH_MSG"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_index_files
argument_list|()
condition|)
name|die
argument_list|(
literal|"Repository has been updated, but unable to write\n"
literal|"new_index file. Check that disk is not full or quota is\n"
literal|"not exceeded, and then \"git reset HEAD\" to recover."
argument_list|)
expr_stmt|;
name|rerere
argument_list|()
expr_stmt|;
name|run_hook
argument_list|(
name|get_index_file
argument_list|()
argument_list|,
literal|"post-commit"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|print_summary
argument_list|(
name|prefix
argument_list|,
name|commit_sha1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
