begin_unit
begin_include
include|#
directive|include
file|"cache.h"
end_include
begin_include
include|#
directive|include
file|"commit.h"
end_include
begin_include
include|#
directive|include
file|"tag.h"
end_include
begin_include
include|#
directive|include
file|"diff.h"
end_include
begin_include
include|#
directive|include
file|"revision.h"
end_include
begin_include
include|#
directive|include
file|"progress.h"
end_include
begin_include
include|#
directive|include
file|"list-objects.h"
end_include
begin_include
include|#
directive|include
file|"pack.h"
end_include
begin_include
include|#
directive|include
file|"pack-bitmap.h"
end_include
begin_include
include|#
directive|include
file|"pack-revindex.h"
end_include
begin_include
include|#
directive|include
file|"pack-objects.h"
end_include
begin_comment
comment|/*  * An entry on the bitmap index, representing the bitmap for a given  * commit.  */
end_comment
begin_struct
DECL|struct|stored_bitmap
struct|struct
name|stored_bitmap
block|{
DECL|member|sha1
name|unsigned
name|char
name|sha1
index|[
literal|20
index|]
decl_stmt|;
DECL|member|root
name|struct
name|ewah_bitmap
modifier|*
name|root
decl_stmt|;
DECL|member|xor
name|struct
name|stored_bitmap
modifier|*
name|xor
decl_stmt|;
DECL|member|flags
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * The currently active bitmap index. By design, repositories only have  * a single bitmap index available (the index for the biggest packfile in  * the repository), since bitmap indexes need full closure.  *  * If there is more than one bitmap index available (e.g. because of alternates),  * the active bitmap index is the largest one.  */
end_comment
begin_struct
DECL|struct|bitmap_index
specifier|static
struct|struct
name|bitmap_index
block|{
comment|/* Packfile to which this bitmap index belongs to */
DECL|member|pack
name|struct
name|packed_git
modifier|*
name|pack
decl_stmt|;
comment|/* reverse index for the packfile */
DECL|member|reverse_index
name|struct
name|pack_revindex
modifier|*
name|reverse_index
decl_stmt|;
comment|/* 	 * Mark the first `reuse_objects` in the packfile as reused: 	 * they will be sent as-is without using them for repacking 	 * calculations 	 */
DECL|member|reuse_objects
name|uint32_t
name|reuse_objects
decl_stmt|;
comment|/* mmapped buffer of the whole bitmap index */
DECL|member|map
name|unsigned
name|char
modifier|*
name|map
decl_stmt|;
DECL|member|map_size
name|size_t
name|map_size
decl_stmt|;
comment|/* size of the mmaped buffer */
DECL|member|map_pos
name|size_t
name|map_pos
decl_stmt|;
comment|/* current position when loading the index */
comment|/* 	 * Type indexes. 	 * 	 * Each bitmap marks which objects in the packfile  are of the given 	 * type. This provides type information when yielding the objects from 	 * the packfile during a walk, which allows for better delta bases. 	 */
DECL|member|commits
name|struct
name|ewah_bitmap
modifier|*
name|commits
decl_stmt|;
DECL|member|trees
name|struct
name|ewah_bitmap
modifier|*
name|trees
decl_stmt|;
DECL|member|blobs
name|struct
name|ewah_bitmap
modifier|*
name|blobs
decl_stmt|;
DECL|member|tags
name|struct
name|ewah_bitmap
modifier|*
name|tags
decl_stmt|;
comment|/* Map from SHA1 -> `stored_bitmap` for all the bitmapped commits */
DECL|member|bitmaps
name|khash_sha1
modifier|*
name|bitmaps
decl_stmt|;
comment|/* Number of bitmapped commits */
DECL|member|entry_count
name|uint32_t
name|entry_count
decl_stmt|;
comment|/* Name-hash cache (or NULL if not present). */
DECL|member|hashes
name|uint32_t
modifier|*
name|hashes
decl_stmt|;
comment|/* 	 * Extended index. 	 * 	 * When trying to perform bitmap operations with objects that are not 	 * packed in `pack`, these objects are added to this "fake index" and 	 * are assumed to appear at the end of the packfile for all operations 	 */
DECL|struct|eindex
struct|struct
name|eindex
block|{
DECL|member|objects
name|struct
name|object
modifier|*
modifier|*
name|objects
decl_stmt|;
DECL|member|hashes
name|uint32_t
modifier|*
name|hashes
decl_stmt|;
DECL|member|count
DECL|member|alloc
name|uint32_t
name|count
decl_stmt|,
name|alloc
decl_stmt|;
DECL|member|positions
name|khash_sha1_pos
modifier|*
name|positions
decl_stmt|;
block|}
DECL|member|ext_index
name|ext_index
struct|;
comment|/* Bitmap result of the last performed walk */
DECL|member|result
name|struct
name|bitmap
modifier|*
name|result
decl_stmt|;
comment|/* Version of the bitmap index */
DECL|member|version
name|unsigned
name|int
name|version
decl_stmt|;
DECL|member|loaded
name|unsigned
name|loaded
range|:
literal|1
decl_stmt|;
block|}
DECL|variable|bitmap_git
name|bitmap_git
struct|;
end_struct
begin_function
DECL|function|lookup_stored_bitmap
specifier|static
name|struct
name|ewah_bitmap
modifier|*
name|lookup_stored_bitmap
parameter_list|(
name|struct
name|stored_bitmap
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|ewah_bitmap
modifier|*
name|parent
decl_stmt|;
name|struct
name|ewah_bitmap
modifier|*
name|composed
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|xor
operator|==
name|NULL
condition|)
return|return
name|st
operator|->
name|root
return|;
name|composed
operator|=
name|ewah_pool_new
argument_list|()
expr_stmt|;
name|parent
operator|=
name|lookup_stored_bitmap
argument_list|(
name|st
operator|->
name|xor
argument_list|)
expr_stmt|;
name|ewah_xor
argument_list|(
name|st
operator|->
name|root
argument_list|,
name|parent
argument_list|,
name|composed
argument_list|)
expr_stmt|;
name|ewah_pool_free
argument_list|(
name|st
operator|->
name|root
argument_list|)
expr_stmt|;
name|st
operator|->
name|root
operator|=
name|composed
expr_stmt|;
name|st
operator|->
name|xor
operator|=
name|NULL
expr_stmt|;
return|return
name|composed
return|;
block|}
end_function
begin_comment
comment|/*  * Read a bitmap from the current read position on the mmaped  * index, and increase the read position accordingly  */
end_comment
begin_function
DECL|function|read_bitmap_1
specifier|static
name|struct
name|ewah_bitmap
modifier|*
name|read_bitmap_1
parameter_list|(
name|struct
name|bitmap_index
modifier|*
name|index
parameter_list|)
block|{
name|struct
name|ewah_bitmap
modifier|*
name|b
init|=
name|ewah_pool_new
argument_list|()
decl_stmt|;
name|int
name|bitmap_size
init|=
name|ewah_read_mmap
argument_list|(
name|b
argument_list|,
name|index
operator|->
name|map
operator|+
name|index
operator|->
name|map_pos
argument_list|,
name|index
operator|->
name|map_size
operator|-
name|index
operator|->
name|map_pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitmap_size
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Failed to load bitmap index (corrupted?)"
argument_list|)
expr_stmt|;
name|ewah_pool_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|index
operator|->
name|map_pos
operator|+=
name|bitmap_size
expr_stmt|;
return|return
name|b
return|;
block|}
end_function
begin_function
DECL|function|load_bitmap_header
specifier|static
name|int
name|load_bitmap_header
parameter_list|(
name|struct
name|bitmap_index
modifier|*
name|index
parameter_list|)
block|{
name|struct
name|bitmap_disk_header
modifier|*
name|header
init|=
operator|(
name|void
operator|*
operator|)
name|index
operator|->
name|map
decl_stmt|;
if|if
condition|(
name|index
operator|->
name|map_size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|+
literal|20
condition|)
return|return
name|error
argument_list|(
literal|"Corrupted bitmap index (missing header data)"
argument_list|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
name|BITMAP_IDX_SIGNATURE
argument_list|,
sizeof|sizeof
argument_list|(
name|BITMAP_IDX_SIGNATURE
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"Corrupted bitmap index file (wrong header)"
argument_list|)
return|;
name|index
operator|->
name|version
operator|=
name|ntohs
argument_list|(
name|header
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|->
name|version
operator|!=
literal|1
condition|)
return|return
name|error
argument_list|(
literal|"Unsupported version for bitmap index file (%d)"
argument_list|,
name|index
operator|->
name|version
argument_list|)
return|;
comment|/* Parse known bitmap format options */
block|{
name|uint32_t
name|flags
init|=
name|ntohs
argument_list|(
name|header
operator|->
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BITMAP_OPT_FULL_DAG
operator|)
operator|==
literal|0
condition|)
return|return
name|error
argument_list|(
literal|"Unsupported options for bitmap index file "
literal|"(Git requires BITMAP_OPT_FULL_DAG)"
argument_list|)
return|;
if|if
condition|(
name|flags
operator|&
name|BITMAP_OPT_HASH_CACHE
condition|)
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|index
operator|->
name|map
operator|+
name|index
operator|->
name|map_size
operator|-
literal|20
decl_stmt|;
name|index
operator|->
name|hashes
operator|=
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|end
operator|)
operator|-
name|index
operator|->
name|pack
operator|->
name|num_objects
expr_stmt|;
block|}
block|}
name|index
operator|->
name|entry_count
operator|=
name|ntohl
argument_list|(
name|header
operator|->
name|entry_count
argument_list|)
expr_stmt|;
name|index
operator|->
name|map_pos
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|store_bitmap
specifier|static
name|struct
name|stored_bitmap
modifier|*
name|store_bitmap
parameter_list|(
name|struct
name|bitmap_index
modifier|*
name|index
parameter_list|,
name|struct
name|ewah_bitmap
modifier|*
name|root
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|struct
name|stored_bitmap
modifier|*
name|xor_with
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|stored_bitmap
modifier|*
name|stored
decl_stmt|;
name|khiter_t
name|hash_pos
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|stored
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stored_bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|stored
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|stored
operator|->
name|xor
operator|=
name|xor_with
expr_stmt|;
name|stored
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|hashcpy
argument_list|(
name|stored
operator|->
name|sha1
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
name|hash_pos
operator|=
name|kh_put_sha1
argument_list|(
name|index
operator|->
name|bitmaps
argument_list|,
name|stored
operator|->
name|sha1
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
comment|/* a 0 return code means the insertion succeeded with no changes, 	 * because the SHA1 already existed on the map. this is bad, there 	 * shouldn't be duplicated commits in the index */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Duplicate entry in bitmap index: %s"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|kh_value
argument_list|(
name|index
operator|->
name|bitmaps
argument_list|,
name|hash_pos
argument_list|)
operator|=
name|stored
expr_stmt|;
return|return
name|stored
return|;
block|}
end_function
begin_function
DECL|function|read_be32
specifier|static
specifier|inline
name|uint32_t
name|read_be32
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|pos
parameter_list|)
block|{
name|uint32_t
name|result
init|=
name|get_be32
argument_list|(
name|buffer
operator|+
operator|*
name|pos
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
sizeof|sizeof
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|read_u8
specifier|static
specifier|inline
name|uint8_t
name|read_u8
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|pos
parameter_list|)
block|{
return|return
name|buffer
index|[
operator|(
operator|*
name|pos
operator|)
operator|++
index|]
return|;
block|}
end_function
begin_define
DECL|macro|MAX_XOR_OFFSET
define|#
directive|define
name|MAX_XOR_OFFSET
value|160
end_define
begin_function
DECL|function|load_bitmap_entries_v1
specifier|static
name|int
name|load_bitmap_entries_v1
parameter_list|(
name|struct
name|bitmap_index
modifier|*
name|index
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|struct
name|stored_bitmap
modifier|*
name|recent_bitmaps
index|[
name|MAX_XOR_OFFSET
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
operator|->
name|entry_count
condition|;
operator|++
name|i
control|)
block|{
name|int
name|xor_offset
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ewah_bitmap
modifier|*
name|bitmap
init|=
name|NULL
decl_stmt|;
name|struct
name|stored_bitmap
modifier|*
name|xor_bitmap
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|commit_idx_pos
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|commit_idx_pos
operator|=
name|read_be32
argument_list|(
name|index
operator|->
name|map
argument_list|,
operator|&
name|index
operator|->
name|map_pos
argument_list|)
expr_stmt|;
name|xor_offset
operator|=
name|read_u8
argument_list|(
name|index
operator|->
name|map
argument_list|,
operator|&
name|index
operator|->
name|map_pos
argument_list|)
expr_stmt|;
name|flags
operator|=
name|read_u8
argument_list|(
name|index
operator|->
name|map
argument_list|,
operator|&
name|index
operator|->
name|map_pos
argument_list|)
expr_stmt|;
name|sha1
operator|=
name|nth_packed_object_sha1
argument_list|(
name|index
operator|->
name|pack
argument_list|,
name|commit_idx_pos
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|read_bitmap_1
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|xor_offset
operator|>
name|MAX_XOR_OFFSET
operator|||
name|xor_offset
operator|>
name|i
condition|)
return|return
name|error
argument_list|(
literal|"Corrupted bitmap pack index"
argument_list|)
return|;
if|if
condition|(
name|xor_offset
operator|>
literal|0
condition|)
block|{
name|xor_bitmap
operator|=
name|recent_bitmaps
index|[
operator|(
name|i
operator|-
name|xor_offset
operator|)
operator|%
name|MAX_XOR_OFFSET
index|]
expr_stmt|;
if|if
condition|(
name|xor_bitmap
operator|==
name|NULL
condition|)
return|return
name|error
argument_list|(
literal|"Invalid XOR offset in bitmap pack index"
argument_list|)
return|;
block|}
name|recent_bitmaps
index|[
name|i
operator|%
name|MAX_XOR_OFFSET
index|]
operator|=
name|store_bitmap
argument_list|(
name|index
argument_list|,
name|bitmap
argument_list|,
name|sha1
argument_list|,
name|xor_bitmap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|pack_bitmap_filename
specifier|static
name|char
modifier|*
name|pack_bitmap_filename
parameter_list|(
name|struct
name|packed_git
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|idx_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|pack_name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|".pack"
argument_list|)
expr_stmt|;
name|idx_name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
name|strlen
argument_list|(
literal|".bitmap"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|idx_name
argument_list|,
name|p
operator|->
name|pack_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|idx_name
operator|+
name|len
argument_list|,
literal|".bitmap"
argument_list|,
name|strlen
argument_list|(
literal|".bitmap"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|idx_name
return|;
block|}
end_function
begin_function
DECL|function|open_pack_bitmap_1
specifier|static
name|int
name|open_pack_bitmap_1
parameter_list|(
name|struct
name|packed_git
modifier|*
name|packfile
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|idx_name
decl_stmt|;
if|if
condition|(
name|open_pack_index
argument_list|(
name|packfile
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|idx_name
operator|=
name|pack_bitmap_filename
argument_list|(
name|packfile
argument_list|)
expr_stmt|;
name|fd
operator|=
name|git_open_noatime
argument_list|(
name|idx_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|idx_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bitmap_git
operator|.
name|pack
condition|)
block|{
name|warning
argument_list|(
literal|"ignoring extra bitmap file: %s"
argument_list|,
name|packfile
operator|->
name|pack_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bitmap_git
operator|.
name|pack
operator|=
name|packfile
expr_stmt|;
name|bitmap_git
operator|.
name|map_size
operator|=
name|xsize_t
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|bitmap_git
operator|.
name|map
operator|=
name|xmmap
argument_list|(
name|NULL
argument_list|,
name|bitmap_git
operator|.
name|map_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_git
operator|.
name|map_pos
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_bitmap_header
argument_list|(
operator|&
name|bitmap_git
argument_list|)
operator|<
literal|0
condition|)
block|{
name|munmap
argument_list|(
name|bitmap_git
operator|.
name|map
argument_list|,
name|bitmap_git
operator|.
name|map_size
argument_list|)
expr_stmt|;
name|bitmap_git
operator|.
name|map
operator|=
name|NULL
expr_stmt|;
name|bitmap_git
operator|.
name|map_size
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|load_pack_bitmap
specifier|static
name|int
name|load_pack_bitmap
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|bitmap_git
operator|.
name|map
operator|&&
operator|!
name|bitmap_git
operator|.
name|loaded
argument_list|)
expr_stmt|;
name|bitmap_git
operator|.
name|bitmaps
operator|=
name|kh_init_sha1
argument_list|()
expr_stmt|;
name|bitmap_git
operator|.
name|ext_index
operator|.
name|positions
operator|=
name|kh_init_sha1_pos
argument_list|()
expr_stmt|;
name|bitmap_git
operator|.
name|reverse_index
operator|=
name|revindex_for_pack
argument_list|(
name|bitmap_git
operator|.
name|pack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bitmap_git
operator|.
name|commits
operator|=
name|read_bitmap_1
argument_list|(
operator|&
name|bitmap_git
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|bitmap_git
operator|.
name|trees
operator|=
name|read_bitmap_1
argument_list|(
operator|&
name|bitmap_git
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|bitmap_git
operator|.
name|blobs
operator|=
name|read_bitmap_1
argument_list|(
operator|&
name|bitmap_git
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|bitmap_git
operator|.
name|tags
operator|=
name|read_bitmap_1
argument_list|(
operator|&
name|bitmap_git
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|load_bitmap_entries_v1
argument_list|(
operator|&
name|bitmap_git
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
name|bitmap_git
operator|.
name|loaded
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|failed
label|:
name|munmap
argument_list|(
name|bitmap_git
operator|.
name|map
argument_list|,
name|bitmap_git
operator|.
name|map_size
argument_list|)
expr_stmt|;
name|bitmap_git
operator|.
name|map
operator|=
name|NULL
expr_stmt|;
name|bitmap_git
operator|.
name|map_size
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|open_pack_bitmap
specifier|static
name|int
name|open_pack_bitmap
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|packed_git
modifier|*
name|p
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
operator|!
name|bitmap_git
operator|.
name|map
operator|&&
operator|!
name|bitmap_git
operator|.
name|loaded
argument_list|)
expr_stmt|;
name|prepare_packed_git
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|packed_git
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|open_pack_bitmap_1
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|prepare_bitmap_git
name|int
name|prepare_bitmap_git
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|bitmap_git
operator|.
name|loaded
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|open_pack_bitmap
argument_list|()
condition|)
return|return
name|load_pack_bitmap
argument_list|()
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_struct
DECL|struct|include_data
struct|struct
name|include_data
block|{
DECL|member|base
name|struct
name|bitmap
modifier|*
name|base
decl_stmt|;
DECL|member|seen
name|struct
name|bitmap
modifier|*
name|seen
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|bitmap_position_extended
specifier|static
specifier|inline
name|int
name|bitmap_position_extended
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|khash_sha1_pos
modifier|*
name|positions
init|=
name|bitmap_git
operator|.
name|ext_index
operator|.
name|positions
decl_stmt|;
name|khiter_t
name|pos
init|=
name|kh_get_sha1_pos
argument_list|(
name|positions
argument_list|,
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
name|kh_end
argument_list|(
name|positions
argument_list|)
condition|)
block|{
name|int
name|bitmap_pos
init|=
name|kh_value
argument_list|(
name|positions
argument_list|,
name|pos
argument_list|)
decl_stmt|;
return|return
name|bitmap_pos
operator|+
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|bitmap_position_packfile
specifier|static
specifier|inline
name|int
name|bitmap_position_packfile
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|off_t
name|offset
init|=
name|find_pack_entry_one
argument_list|(
name|sha1
argument_list|,
name|bitmap_git
operator|.
name|pack
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|find_revindex_position
argument_list|(
name|bitmap_git
operator|.
name|reverse_index
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|bitmap_position
specifier|static
name|int
name|bitmap_position
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|)
block|{
name|int
name|pos
init|=
name|bitmap_position_packfile
argument_list|(
name|sha1
argument_list|)
decl_stmt|;
return|return
operator|(
name|pos
operator|>=
literal|0
operator|)
condition|?
name|pos
else|:
name|bitmap_position_extended
argument_list|(
name|sha1
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|ext_index_add_object
specifier|static
name|int
name|ext_index_add_object
parameter_list|(
name|struct
name|object
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|eindex
modifier|*
name|eindex
init|=
operator|&
name|bitmap_git
operator|.
name|ext_index
decl_stmt|;
name|khiter_t
name|hash_pos
decl_stmt|;
name|int
name|hash_ret
decl_stmt|;
name|int
name|bitmap_pos
decl_stmt|;
name|hash_pos
operator|=
name|kh_put_sha1_pos
argument_list|(
name|eindex
operator|->
name|positions
argument_list|,
name|object
operator|->
name|sha1
argument_list|,
operator|&
name|hash_ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ret
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|eindex
operator|->
name|count
operator|>=
name|eindex
operator|->
name|alloc
condition|)
block|{
name|eindex
operator|->
name|alloc
operator|=
operator|(
name|eindex
operator|->
name|alloc
operator|+
literal|16
operator|)
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
name|REALLOC_ARRAY
argument_list|(
name|eindex
operator|->
name|objects
argument_list|,
name|eindex
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|REALLOC_ARRAY
argument_list|(
name|eindex
operator|->
name|hashes
argument_list|,
name|eindex
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bitmap_pos
operator|=
name|eindex
operator|->
name|count
expr_stmt|;
name|eindex
operator|->
name|objects
index|[
name|eindex
operator|->
name|count
index|]
operator|=
name|object
expr_stmt|;
name|eindex
operator|->
name|hashes
index|[
name|eindex
operator|->
name|count
index|]
operator|=
name|pack_name_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|kh_value
argument_list|(
name|eindex
operator|->
name|positions
argument_list|,
name|hash_pos
argument_list|)
operator|=
name|bitmap_pos
expr_stmt|;
name|eindex
operator|->
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bitmap_pos
operator|=
name|kh_value
argument_list|(
name|eindex
operator|->
name|positions
argument_list|,
name|hash_pos
argument_list|)
expr_stmt|;
block|}
return|return
name|bitmap_pos
operator|+
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
return|;
block|}
end_function
begin_function
DECL|function|show_object
specifier|static
name|void
name|show_object
parameter_list|(
name|struct
name|object
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bitmap
modifier|*
name|base
init|=
name|data
decl_stmt|;
name|int
name|bitmap_pos
decl_stmt|;
name|bitmap_pos
operator|=
name|bitmap_position
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_pos
operator|<
literal|0
condition|)
name|bitmap_pos
operator|=
name|ext_index_add_object
argument_list|(
name|object
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bitmap_set
argument_list|(
name|base
argument_list|,
name|bitmap_pos
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|show_commit
specifier|static
name|void
name|show_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{ }
end_function
begin_function
DECL|function|add_to_include_set
specifier|static
name|int
name|add_to_include_set
parameter_list|(
name|struct
name|include_data
modifier|*
name|data
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|int
name|bitmap_pos
parameter_list|)
block|{
name|khiter_t
name|hash_pos
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|seen
operator|&&
name|bitmap_get
argument_list|(
name|data
operator|->
name|seen
argument_list|,
name|bitmap_pos
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bitmap_get
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|bitmap_pos
argument_list|)
condition|)
return|return
literal|0
return|;
name|hash_pos
operator|=
name|kh_get_sha1
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|,
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_pos
operator|<
name|kh_end
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|)
condition|)
block|{
name|struct
name|stored_bitmap
modifier|*
name|st
init|=
name|kh_value
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|,
name|hash_pos
argument_list|)
decl_stmt|;
name|bitmap_or_ewah
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|lookup_stored_bitmap
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bitmap_set
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|bitmap_pos
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|should_include
specifier|static
name|int
name|should_include
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|void
modifier|*
name|_data
parameter_list|)
block|{
name|struct
name|include_data
modifier|*
name|data
init|=
name|_data
decl_stmt|;
name|int
name|bitmap_pos
decl_stmt|;
name|bitmap_pos
operator|=
name|bitmap_position
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_pos
operator|<
literal|0
condition|)
name|bitmap_pos
operator|=
name|ext_index_add_object
argument_list|(
operator|(
expr|struct
name|object
operator|*
operator|)
name|commit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|add_to_include_set
argument_list|(
name|data
argument_list|,
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|,
name|bitmap_pos
argument_list|)
condition|)
block|{
name|struct
name|commit_list
modifier|*
name|parent
init|=
name|commit
operator|->
name|parents
decl_stmt|;
while|while
condition|(
name|parent
condition|)
block|{
name|parent
operator|->
name|item
operator|->
name|object
operator|.
name|flags
operator||=
name|SEEN
expr_stmt|;
name|parent
operator|=
name|parent
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|find_objects
specifier|static
name|struct
name|bitmap
modifier|*
name|find_objects
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|,
name|struct
name|object_list
modifier|*
name|roots
parameter_list|,
name|struct
name|bitmap
modifier|*
name|seen
parameter_list|)
block|{
name|struct
name|bitmap
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|int
name|needs_walk
init|=
literal|0
decl_stmt|;
name|struct
name|object_list
modifier|*
name|not_mapped
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Go through all the roots for the walk. The ones that have bitmaps 	 * on the bitmap index will be `or`ed together to form an initial 	 * global reachability analysis. 	 * 	 * The ones without bitmaps in the index will be stored in the 	 * `not_mapped_list` for further processing. 	 */
while|while
condition|(
name|roots
condition|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
name|roots
operator|->
name|item
decl_stmt|;
name|roots
operator|=
name|roots
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJ_COMMIT
condition|)
block|{
name|khiter_t
name|pos
init|=
name|kh_get_sha1
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|,
name|object
operator|->
name|sha1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
name|kh_end
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|)
condition|)
block|{
name|struct
name|stored_bitmap
modifier|*
name|st
init|=
name|kh_value
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|struct
name|ewah_bitmap
modifier|*
name|or_with
init|=
name|lookup_stored_bitmap
argument_list|(
name|st
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
name|base
operator|=
name|ewah_to_bitmap
argument_list|(
name|or_with
argument_list|)
expr_stmt|;
else|else
name|bitmap_or_ewah
argument_list|(
name|base
argument_list|,
name|or_with
argument_list|)
expr_stmt|;
name|object
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
continue|continue;
block|}
block|}
name|object_list_insert
argument_list|(
name|object
argument_list|,
operator|&
name|not_mapped
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Best case scenario: We found bitmaps for all the roots, 	 * so the resulting `or` bitmap has the full reachability analysis 	 */
if|if
condition|(
name|not_mapped
operator|==
name|NULL
condition|)
return|return
name|base
return|;
name|roots
operator|=
name|not_mapped
expr_stmt|;
comment|/* 	 * Let's iterate through all the roots that don't have bitmaps to 	 * check if we can determine them to be reachable from the existing 	 * global bitmap. 	 * 	 * If we cannot find them in the existing global bitmap, we'll need 	 * to push them to an actual walk and run it until we can confirm 	 * they are reachable 	 */
while|while
condition|(
name|roots
condition|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
name|roots
operator|->
name|item
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|roots
operator|=
name|roots
operator|->
name|next
expr_stmt|;
name|pos
operator|=
name|bitmap_position
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|base
operator|==
name|NULL
operator|||
operator|!
name|bitmap_get
argument_list|(
name|base
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|object
operator|->
name|flags
operator|&=
operator|~
name|UNINTERESTING
expr_stmt|;
name|add_pending_object
argument_list|(
name|revs
argument_list|,
name|object
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|needs_walk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|object
operator|->
name|flags
operator||=
name|SEEN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needs_walk
condition|)
block|{
name|struct
name|include_data
name|incdata
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
name|base
operator|=
name|bitmap_new
argument_list|()
expr_stmt|;
name|incdata
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|incdata
operator|.
name|seen
operator|=
name|seen
expr_stmt|;
name|revs
operator|->
name|include_check
operator|=
name|should_include
expr_stmt|;
name|revs
operator|->
name|include_check_data
operator|=
operator|&
name|incdata
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
name|revs
argument_list|)
condition|)
name|die
argument_list|(
literal|"revision walk setup failed"
argument_list|)
expr_stmt|;
name|traverse_commit_list
argument_list|(
name|revs
argument_list|,
name|show_commit
argument_list|,
name|show_object
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
return|return
name|base
return|;
block|}
end_function
begin_function
DECL|function|show_extended_objects
specifier|static
name|void
name|show_extended_objects
parameter_list|(
name|struct
name|bitmap
modifier|*
name|objects
parameter_list|,
name|show_reachable_fn
name|show_reach
parameter_list|)
block|{
name|struct
name|eindex
modifier|*
name|eindex
init|=
operator|&
name|bitmap_git
operator|.
name|ext_index
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eindex
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|object
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_get
argument_list|(
name|objects
argument_list|,
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
operator|+
name|i
argument_list|)
condition|)
continue|continue;
name|obj
operator|=
name|eindex
operator|->
name|objects
index|[
name|i
index|]
expr_stmt|;
name|show_reach
argument_list|(
name|obj
operator|->
name|sha1
argument_list|,
name|obj
operator|->
name|type
argument_list|,
literal|0
argument_list|,
name|eindex
operator|->
name|hashes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|show_objects_for_type
specifier|static
name|void
name|show_objects_for_type
parameter_list|(
name|struct
name|bitmap
modifier|*
name|objects
parameter_list|,
name|struct
name|ewah_bitmap
modifier|*
name|type_filter
parameter_list|,
name|enum
name|object_type
name|object_type
parameter_list|,
name|show_reachable_fn
name|show_reach
parameter_list|)
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|struct
name|ewah_iterator
name|it
decl_stmt|;
name|eword_t
name|filter
decl_stmt|;
if|if
condition|(
name|bitmap_git
operator|.
name|reuse_objects
operator|==
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
condition|)
return|return;
name|ewah_iterator_init
argument_list|(
operator|&
name|it
argument_list|,
name|type_filter
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|objects
operator|->
name|word_alloc
operator|&&
name|ewah_iterator_next
argument_list|(
operator|&
name|filter
argument_list|,
operator|&
name|it
argument_list|)
condition|)
block|{
name|eword_t
name|word
init|=
name|objects
operator|->
name|words
index|[
name|i
index|]
operator|&
name|filter
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|BITS_IN_EWORD
condition|;
operator|++
name|offset
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|struct
name|revindex_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|hash
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|word
operator|>>
name|offset
operator|)
operator|==
literal|0
condition|)
break|break;
name|offset
operator|+=
name|ewah_bit_ctz64
argument_list|(
name|word
operator|>>
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|offset
operator|<
name|bitmap_git
operator|.
name|reuse_objects
condition|)
continue|continue;
name|entry
operator|=
operator|&
name|bitmap_git
operator|.
name|reverse_index
operator|->
name|revindex
index|[
name|pos
operator|+
name|offset
index|]
expr_stmt|;
name|sha1
operator|=
name|nth_packed_object_sha1
argument_list|(
name|bitmap_git
operator|.
name|pack
argument_list|,
name|entry
operator|->
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_git
operator|.
name|hashes
condition|)
name|hash
operator|=
name|ntohl
argument_list|(
name|bitmap_git
operator|.
name|hashes
index|[
name|entry
operator|->
name|nr
index|]
argument_list|)
expr_stmt|;
name|show_reach
argument_list|(
name|sha1
argument_list|,
name|object_type
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|,
name|bitmap_git
operator|.
name|pack
argument_list|,
name|entry
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|BITS_IN_EWORD
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|in_bitmapped_pack
specifier|static
name|int
name|in_bitmapped_pack
parameter_list|(
name|struct
name|object_list
modifier|*
name|roots
parameter_list|)
block|{
while|while
condition|(
name|roots
condition|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
name|roots
operator|->
name|item
decl_stmt|;
name|roots
operator|=
name|roots
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|find_pack_entry_one
argument_list|(
name|object
operator|->
name|sha1
argument_list|,
name|bitmap_git
operator|.
name|pack
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|prepare_bitmap_walk
name|int
name|prepare_bitmap_walk
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|pending_nr
init|=
name|revs
operator|->
name|pending
operator|.
name|nr
decl_stmt|;
name|struct
name|object_array_entry
modifier|*
name|pending_e
init|=
name|revs
operator|->
name|pending
operator|.
name|objects
decl_stmt|;
name|struct
name|object_list
modifier|*
name|wants
init|=
name|NULL
decl_stmt|;
name|struct
name|object_list
modifier|*
name|haves
init|=
name|NULL
decl_stmt|;
name|struct
name|bitmap
modifier|*
name|wants_bitmap
init|=
name|NULL
decl_stmt|;
name|struct
name|bitmap
modifier|*
name|haves_bitmap
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_git
operator|.
name|loaded
condition|)
block|{
comment|/* try to open a bitmapped pack, but don't parse it yet 		 * because we may not need to use it */
if|if
condition|(
name|open_pack_bitmap
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pending_nr
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|object
modifier|*
name|object
init|=
name|pending_e
index|[
name|i
index|]
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJ_NONE
condition|)
name|parse_object_or_die
argument_list|(
name|object
operator|->
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|object
operator|->
name|type
operator|==
name|OBJ_TAG
condition|)
block|{
name|struct
name|tag
modifier|*
name|tag
init|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|object
decl_stmt|;
if|if
condition|(
name|object
operator|->
name|flags
operator|&
name|UNINTERESTING
condition|)
name|object_list_insert
argument_list|(
name|object
argument_list|,
operator|&
name|haves
argument_list|)
expr_stmt|;
else|else
name|object_list_insert
argument_list|(
name|object
argument_list|,
operator|&
name|wants
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tag
operator|->
name|tagged
condition|)
name|die
argument_list|(
literal|"bad tag"
argument_list|)
expr_stmt|;
name|object
operator|=
name|parse_object_or_die
argument_list|(
name|tag
operator|->
name|tagged
operator|->
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|->
name|flags
operator|&
name|UNINTERESTING
condition|)
name|object_list_insert
argument_list|(
name|object
argument_list|,
operator|&
name|haves
argument_list|)
expr_stmt|;
else|else
name|object_list_insert
argument_list|(
name|object
argument_list|,
operator|&
name|wants
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * if we have a HAVES list, but none of those haves is contained 	 * in the packfile that has a bitmap, we don't have anything to 	 * optimize here 	 */
if|if
condition|(
name|haves
operator|&&
operator|!
name|in_bitmapped_pack
argument_list|(
name|haves
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* if we don't want anything, we're done here */
if|if
condition|(
operator|!
name|wants
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * now we're going to use bitmaps, so load the actual bitmap entries 	 * from disk. this is the point of no return; after this the rev_list 	 * becomes invalidated and we must perform the revwalk through bitmaps 	 */
if|if
condition|(
operator|!
name|bitmap_git
operator|.
name|loaded
operator|&&
name|load_pack_bitmap
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|revs
operator|->
name|pending
operator|.
name|nr
operator|=
literal|0
expr_stmt|;
name|revs
operator|->
name|pending
operator|.
name|alloc
operator|=
literal|0
expr_stmt|;
name|revs
operator|->
name|pending
operator|.
name|objects
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|haves
condition|)
block|{
name|revs
operator|->
name|ignore_missing_links
operator|=
literal|1
expr_stmt|;
name|haves_bitmap
operator|=
name|find_objects
argument_list|(
name|revs
argument_list|,
name|haves
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|reset_revision_walk
argument_list|()
expr_stmt|;
name|revs
operator|->
name|ignore_missing_links
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|haves_bitmap
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"BUG: failed to perform bitmap walk"
argument_list|)
expr_stmt|;
block|}
name|wants_bitmap
operator|=
name|find_objects
argument_list|(
name|revs
argument_list|,
name|wants
argument_list|,
name|haves_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wants_bitmap
condition|)
name|die
argument_list|(
literal|"BUG: failed to perform bitmap walk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|haves_bitmap
condition|)
name|bitmap_and_not
argument_list|(
name|wants_bitmap
argument_list|,
name|haves_bitmap
argument_list|)
expr_stmt|;
name|bitmap_git
operator|.
name|result
operator|=
name|wants_bitmap
expr_stmt|;
name|bitmap_free
argument_list|(
name|haves_bitmap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|reuse_partial_packfile_from_bitmap
name|int
name|reuse_partial_packfile_from_bitmap
parameter_list|(
name|struct
name|packed_git
modifier|*
modifier|*
name|packfile
parameter_list|,
name|uint32_t
modifier|*
name|entries
parameter_list|,
name|off_t
modifier|*
name|up_to
parameter_list|)
block|{
comment|/* 	 * Reuse the packfile content if we need more than 	 * 90% of its objects 	 */
specifier|static
specifier|const
name|double
name|REUSE_PERCENT
init|=
literal|0.9
decl_stmt|;
name|struct
name|bitmap
modifier|*
name|result
init|=
name|bitmap_git
operator|.
name|result
decl_stmt|;
name|uint32_t
name|reuse_threshold
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|reuse_objects
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
operator|->
name|word_alloc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|result
operator|->
name|words
index|[
name|i
index|]
operator|!=
operator|(
name|eword_t
operator|)
operator|~
literal|0
condition|)
block|{
name|reuse_objects
operator|+=
name|ewah_bit_ctz64
argument_list|(
operator|~
name|result
operator|->
name|words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|reuse_objects
operator|+=
name|BITS_IN_EWORD
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GIT_BITMAP_DEBUG
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|struct
name|revindex_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|&
name|bitmap_git
operator|.
name|reverse_index
operator|->
name|revindex
index|[
name|reuse_objects
index|]
expr_stmt|;
name|sha1
operator|=
name|nth_packed_object_sha1
argument_list|(
name|bitmap_git
operator|.
name|pack
argument_list|,
name|entry
operator|->
name|nr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to reuse at %d (%016llx)\n"
argument_list|,
name|reuse_objects
argument_list|,
name|result
operator|->
name|words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|reuse_objects
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|reuse_objects
operator|>=
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
condition|)
block|{
name|bitmap_git
operator|.
name|reuse_objects
operator|=
operator|*
name|entries
operator|=
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
expr_stmt|;
operator|*
name|up_to
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* reuse the full pack */
operator|*
name|packfile
operator|=
name|bitmap_git
operator|.
name|pack
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reuse_threshold
operator|=
name|bitmap_popcount
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|)
operator|*
name|REUSE_PERCENT
expr_stmt|;
if|if
condition|(
name|reuse_objects
operator|<
name|reuse_threshold
condition|)
return|return
operator|-
literal|1
return|;
name|bitmap_git
operator|.
name|reuse_objects
operator|=
operator|*
name|entries
operator|=
name|reuse_objects
expr_stmt|;
operator|*
name|up_to
operator|=
name|bitmap_git
operator|.
name|reverse_index
operator|->
name|revindex
index|[
name|reuse_objects
index|]
operator|.
name|offset
expr_stmt|;
operator|*
name|packfile
operator|=
name|bitmap_git
operator|.
name|pack
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|traverse_bitmap_commit_list
name|void
name|traverse_bitmap_commit_list
parameter_list|(
name|show_reachable_fn
name|show_reachable
parameter_list|)
block|{
name|assert
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|)
expr_stmt|;
name|show_objects_for_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|bitmap_git
operator|.
name|commits
argument_list|,
name|OBJ_COMMIT
argument_list|,
name|show_reachable
argument_list|)
expr_stmt|;
name|show_objects_for_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|bitmap_git
operator|.
name|trees
argument_list|,
name|OBJ_TREE
argument_list|,
name|show_reachable
argument_list|)
expr_stmt|;
name|show_objects_for_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|bitmap_git
operator|.
name|blobs
argument_list|,
name|OBJ_BLOB
argument_list|,
name|show_reachable
argument_list|)
expr_stmt|;
name|show_objects_for_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|bitmap_git
operator|.
name|tags
argument_list|,
name|OBJ_TAG
argument_list|,
name|show_reachable
argument_list|)
expr_stmt|;
name|show_extended_objects
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|show_reachable
argument_list|)
expr_stmt|;
name|bitmap_free
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|)
expr_stmt|;
name|bitmap_git
operator|.
name|result
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
DECL|function|count_object_type
specifier|static
name|uint32_t
name|count_object_type
parameter_list|(
name|struct
name|bitmap
modifier|*
name|objects
parameter_list|,
name|enum
name|object_type
name|type
parameter_list|)
block|{
name|struct
name|eindex
modifier|*
name|eindex
init|=
operator|&
name|bitmap_git
operator|.
name|ext_index
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|ewah_iterator
name|it
decl_stmt|;
name|eword_t
name|filter
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OBJ_COMMIT
case|:
name|ewah_iterator_init
argument_list|(
operator|&
name|it
argument_list|,
name|bitmap_git
operator|.
name|commits
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_TREE
case|:
name|ewah_iterator_init
argument_list|(
operator|&
name|it
argument_list|,
name|bitmap_git
operator|.
name|trees
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_BLOB
case|:
name|ewah_iterator_init
argument_list|(
operator|&
name|it
argument_list|,
name|bitmap_git
operator|.
name|blobs
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_TAG
case|:
name|ewah_iterator_init
argument_list|(
operator|&
name|it
argument_list|,
name|bitmap_git
operator|.
name|tags
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
while|while
condition|(
name|i
operator|<
name|objects
operator|->
name|word_alloc
operator|&&
name|ewah_iterator_next
argument_list|(
operator|&
name|filter
argument_list|,
operator|&
name|it
argument_list|)
condition|)
block|{
name|eword_t
name|word
init|=
name|objects
operator|->
name|words
index|[
name|i
operator|++
index|]
operator|&
name|filter
decl_stmt|;
name|count
operator|+=
name|ewah_bit_popcount64
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eindex
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|eindex
operator|->
name|objects
index|[
name|i
index|]
operator|->
name|type
operator|==
name|type
operator|&&
name|bitmap_get
argument_list|(
name|objects
argument_list|,
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
operator|+
name|i
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function
begin_function
DECL|function|count_bitmap_commit_list
name|void
name|count_bitmap_commit_list
parameter_list|(
name|uint32_t
modifier|*
name|commits
parameter_list|,
name|uint32_t
modifier|*
name|trees
parameter_list|,
name|uint32_t
modifier|*
name|blobs
parameter_list|,
name|uint32_t
modifier|*
name|tags
parameter_list|)
block|{
name|assert
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|commits
condition|)
operator|*
name|commits
operator|=
name|count_object_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|OBJ_COMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|trees
condition|)
operator|*
name|trees
operator|=
name|count_object_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|OBJ_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobs
condition|)
operator|*
name|blobs
operator|=
name|count_object_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|OBJ_BLOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|tags
condition|)
operator|*
name|tags
operator|=
name|count_object_type
argument_list|(
name|bitmap_git
operator|.
name|result
argument_list|,
name|OBJ_TAG
argument_list|)
expr_stmt|;
block|}
end_function
begin_struct
DECL|struct|bitmap_test_data
struct|struct
name|bitmap_test_data
block|{
DECL|member|base
name|struct
name|bitmap
modifier|*
name|base
decl_stmt|;
DECL|member|prg
name|struct
name|progress
modifier|*
name|prg
decl_stmt|;
DECL|member|seen
name|size_t
name|seen
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|test_show_object
specifier|static
name|void
name|test_show_object
parameter_list|(
name|struct
name|object
modifier|*
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bitmap_test_data
modifier|*
name|tdata
init|=
name|data
decl_stmt|;
name|int
name|bitmap_pos
decl_stmt|;
name|bitmap_pos
operator|=
name|bitmap_position
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_pos
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Object not in bitmap: %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|object
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_set
argument_list|(
name|tdata
operator|->
name|base
argument_list|,
name|bitmap_pos
argument_list|)
expr_stmt|;
name|display_progress
argument_list|(
name|tdata
operator|->
name|prg
argument_list|,
operator|++
name|tdata
operator|->
name|seen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|test_show_commit
specifier|static
name|void
name|test_show_commit
parameter_list|(
name|struct
name|commit
modifier|*
name|commit
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bitmap_test_data
modifier|*
name|tdata
init|=
name|data
decl_stmt|;
name|int
name|bitmap_pos
decl_stmt|;
name|bitmap_pos
operator|=
name|bitmap_position
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_pos
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"Object not in bitmap: %s\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|commit
operator|->
name|object
operator|.
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_set
argument_list|(
name|tdata
operator|->
name|base
argument_list|,
name|bitmap_pos
argument_list|)
expr_stmt|;
name|display_progress
argument_list|(
name|tdata
operator|->
name|prg
argument_list|,
operator|++
name|tdata
operator|->
name|seen
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|test_bitmap_walk
name|void
name|test_bitmap_walk
parameter_list|(
name|struct
name|rev_info
modifier|*
name|revs
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|root
decl_stmt|;
name|struct
name|bitmap
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|khiter_t
name|pos
decl_stmt|;
name|size_t
name|result_popcnt
decl_stmt|;
name|struct
name|bitmap_test_data
name|tdata
decl_stmt|;
if|if
condition|(
name|prepare_bitmap_git
argument_list|()
condition|)
name|die
argument_list|(
literal|"failed to load bitmap indexes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|revs
operator|->
name|pending
operator|.
name|nr
operator|!=
literal|1
condition|)
name|die
argument_list|(
literal|"you must specify exactly one commit to test"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bitmap v%d test (%d entries loaded)\n"
argument_list|,
name|bitmap_git
operator|.
name|version
argument_list|,
name|bitmap_git
operator|.
name|entry_count
argument_list|)
expr_stmt|;
name|root
operator|=
name|revs
operator|->
name|pending
operator|.
name|objects
index|[
literal|0
index|]
operator|.
name|item
expr_stmt|;
name|pos
operator|=
name|kh_get_sha1
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|,
name|root
operator|->
name|sha1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|kh_end
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|)
condition|)
block|{
name|struct
name|stored_bitmap
modifier|*
name|st
init|=
name|kh_value
argument_list|(
name|bitmap_git
operator|.
name|bitmaps
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|struct
name|ewah_bitmap
modifier|*
name|bm
init|=
name|lookup_stored_bitmap
argument_list|(
name|st
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Found bitmap for %s. %d bits / %08x checksum\n"
argument_list|,
name|sha1_to_hex
argument_list|(
name|root
operator|->
name|sha1
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|bm
operator|->
name|bit_size
argument_list|,
name|ewah_checksum
argument_list|(
name|bm
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ewah_to_bitmap
argument_list|(
name|bm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"Commit %s doesn't have an indexed bitmap"
argument_list|,
name|sha1_to_hex
argument_list|(
name|root
operator|->
name|sha1
argument_list|)
argument_list|)
expr_stmt|;
name|revs
operator|->
name|tag_objects
operator|=
literal|1
expr_stmt|;
name|revs
operator|->
name|tree_objects
operator|=
literal|1
expr_stmt|;
name|revs
operator|->
name|blob_objects
operator|=
literal|1
expr_stmt|;
name|result_popcnt
operator|=
name|bitmap_popcount
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|prepare_revision_walk
argument_list|(
name|revs
argument_list|)
condition|)
name|die
argument_list|(
literal|"revision walk setup failed"
argument_list|)
expr_stmt|;
name|tdata
operator|.
name|base
operator|=
name|bitmap_new
argument_list|()
expr_stmt|;
name|tdata
operator|.
name|prg
operator|=
name|start_progress
argument_list|(
literal|"Verifying bitmap entries"
argument_list|,
name|result_popcnt
argument_list|)
expr_stmt|;
name|tdata
operator|.
name|seen
operator|=
literal|0
expr_stmt|;
name|traverse_commit_list
argument_list|(
name|revs
argument_list|,
operator|&
name|test_show_commit
argument_list|,
operator|&
name|test_show_object
argument_list|,
operator|&
name|tdata
argument_list|)
expr_stmt|;
name|stop_progress
argument_list|(
operator|&
name|tdata
operator|.
name|prg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_equals
argument_list|(
name|result
argument_list|,
name|tdata
operator|.
name|base
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OK!\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mismatch!\n"
argument_list|)
expr_stmt|;
name|bitmap_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|rebuild_bitmap
specifier|static
name|int
name|rebuild_bitmap
parameter_list|(
name|uint32_t
modifier|*
name|reposition
parameter_list|,
name|struct
name|ewah_bitmap
modifier|*
name|source
parameter_list|,
name|struct
name|bitmap
modifier|*
name|dest
parameter_list|)
block|{
name|uint32_t
name|pos
init|=
literal|0
decl_stmt|;
name|struct
name|ewah_iterator
name|it
decl_stmt|;
name|eword_t
name|word
decl_stmt|;
name|ewah_iterator_init
argument_list|(
operator|&
name|it
argument_list|,
name|source
argument_list|)
expr_stmt|;
while|while
condition|(
name|ewah_iterator_next
argument_list|(
operator|&
name|word
argument_list|,
operator|&
name|it
argument_list|)
condition|)
block|{
name|uint32_t
name|offset
decl_stmt|,
name|bit_pos
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|BITS_IN_EWORD
condition|;
operator|++
name|offset
control|)
block|{
if|if
condition|(
operator|(
name|word
operator|>>
name|offset
operator|)
operator|==
literal|0
condition|)
break|break;
name|offset
operator|+=
name|ewah_bit_ctz64
argument_list|(
name|word
operator|>>
name|offset
argument_list|)
expr_stmt|;
name|bit_pos
operator|=
name|reposition
index|[
name|pos
operator|+
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|bit_pos
operator|>
literal|0
condition|)
name|bitmap_set
argument_list|(
name|dest
argument_list|,
name|bit_pos
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* can't reuse, we don't have the object */
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|+=
name|BITS_IN_EWORD
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|rebuild_existing_bitmaps
name|int
name|rebuild_existing_bitmaps
parameter_list|(
name|struct
name|packing_data
modifier|*
name|mapping
parameter_list|,
name|khash_sha1
modifier|*
name|reused_bitmaps
parameter_list|,
name|int
name|show_progress
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|num_objects
decl_stmt|;
name|uint32_t
modifier|*
name|reposition
decl_stmt|;
name|struct
name|bitmap
modifier|*
name|rebuild
decl_stmt|;
name|struct
name|stored_bitmap
modifier|*
name|stored
decl_stmt|;
name|struct
name|progress
modifier|*
name|progress
init|=
name|NULL
decl_stmt|;
name|khiter_t
name|hash_pos
decl_stmt|;
name|int
name|hash_ret
decl_stmt|;
if|if
condition|(
name|prepare_bitmap_git
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|num_objects
operator|=
name|bitmap_git
operator|.
name|pack
operator|->
name|num_objects
expr_stmt|;
name|reposition
operator|=
name|xcalloc
argument_list|(
name|num_objects
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_objects
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
decl_stmt|;
name|struct
name|revindex_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|object_entry
modifier|*
name|oe
decl_stmt|;
name|entry
operator|=
operator|&
name|bitmap_git
operator|.
name|reverse_index
operator|->
name|revindex
index|[
name|i
index|]
expr_stmt|;
name|sha1
operator|=
name|nth_packed_object_sha1
argument_list|(
name|bitmap_git
operator|.
name|pack
argument_list|,
name|entry
operator|->
name|nr
argument_list|)
expr_stmt|;
name|oe
operator|=
name|packlist_find
argument_list|(
name|mapping
argument_list|,
name|sha1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oe
condition|)
name|reposition
index|[
name|i
index|]
operator|=
name|oe
operator|->
name|in_pack_pos
operator|+
literal|1
expr_stmt|;
block|}
name|rebuild
operator|=
name|bitmap_new
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|show_progress
condition|)
name|progress
operator|=
name|start_progress
argument_list|(
literal|"Reusing bitmaps"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kh_foreach_value
argument_list|(
argument|bitmap_git.bitmaps
argument_list|,
argument|stored
argument_list|,
argument|{ 		if (stored->flags& BITMAP_FLAG_REUSE) { 			if (!rebuild_bitmap(reposition, 					    lookup_stored_bitmap(stored), 					    rebuild)) { 				hash_pos = kh_put_sha1(reused_bitmaps, 						       stored->sha1,&hash_ret); 				kh_value(reused_bitmaps, hash_pos) = 					bitmap_to_ewah(rebuild); 			} 			bitmap_reset(rebuild); 			display_progress(progress, ++i); 		} 	}
argument_list|)
empty_stmt|;
name|stop_progress
argument_list|(
operator|&
name|progress
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reposition
argument_list|)
expr_stmt|;
name|bitmap_free
argument_list|(
name|rebuild
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
end_unit
